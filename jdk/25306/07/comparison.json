{"files":[{"patch":"@@ -32,0 +32,1 @@\n+class SerializeClosure;\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/classFileParser.hpp\"\n+#include \"classfile\/classFileStream.hpp\"\n+#include \"classfile\/classLoadInfo.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"jfr\/instrumentation\/jfrClassTransformer.hpp\"\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"prims\/jvmtiRedefineClasses.hpp\"\n+#include \"prims\/jvmtiThreadState.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+static void log_pending_exception(oop throwable) {\n+  assert(throwable != nullptr, \"invariant\");\n+  oop msg = java_lang_Throwable::message(throwable);\n+  if (msg != nullptr) {\n+    char* text = java_lang_String::as_utf8_string(msg);\n+    if (text != nullptr) {\n+      log_error(jfr, system) (\"%s\", text);\n+    }\n+  }\n+}\n+\n+\/\/ On initial class load.\n+void JfrClassTransformer::cache_class_file_data(InstanceKlass* new_ik, const ClassFileStream* new_stream, const JavaThread* thread) {\n+  assert(new_ik != nullptr, \"invariant\");\n+  assert(new_stream != nullptr, \"invariant\");\n+  assert(thread != nullptr, \"invariant\");\n+  assert(!thread->has_pending_exception(), \"invariant\");\n+  if (!JfrOptionSet::allow_retransforms()) {\n+    return;\n+  }\n+  const jint stream_len = new_stream->length();\n+  JvmtiCachedClassFileData* p =\n+    (JvmtiCachedClassFileData*)NEW_C_HEAP_ARRAY_RETURN_NULL(u1, offset_of(JvmtiCachedClassFileData, data) + stream_len, mtInternal);\n+  if (p == nullptr) {\n+    log_error(jfr, system)(\"Allocation using C_HEAP_ARRAY for %zu bytes failed in JfrEventClassTransformer::cache_class_file_data\",\n+      static_cast<size_t>(offset_of(JvmtiCachedClassFileData, data) + stream_len));\n+    return;\n+  }\n+  p->length = stream_len;\n+  memcpy(p->data, new_stream->buffer(), stream_len);\n+  new_ik->set_cached_class_file(p);\n+}\n+\n+InstanceKlass* JfrClassTransformer::create_instance_klass(InstanceKlass*& ik, ClassFileStream* stream, bool is_initial_load, JavaThread* thread) {\n+  if (stream == nullptr) {\n+    if (is_initial_load) {\n+      log_error(jfr, system)(\"JfrClassTransformer: unable to create ClassFileStream for %s\", ik->external_name());\n+    }\n+    return nullptr;\n+  }\n+  InstanceKlass* const new_ik = create_new_instance_klass(ik, stream, thread);\n+  if (new_ik == nullptr) {\n+    if (is_initial_load) {\n+      log_error(jfr, system)(\"JfrClassTransformer: unable to create InstanceKlass for %s\", ik->external_name());\n+    }\n+  }\n+  return new_ik;\n+}\n+\n+void JfrClassTransformer::copy_traceid(const InstanceKlass* ik, const InstanceKlass* new_ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(new_ik != nullptr, \"invariant\");\n+  new_ik->set_trace_id(ik->trace_id());\n+  assert(TRACE_ID(ik) == TRACE_ID(new_ik), \"invariant\");\n+}\n+\n+InstanceKlass* JfrClassTransformer::create_new_instance_klass(InstanceKlass* ik, ClassFileStream* stream, TRAPS) {\n+  assert(stream != nullptr, \"invariant\");\n+  ResourceMark rm(THREAD);\n+  ClassLoaderData* const cld = ik->class_loader_data();\n+  Handle pd(THREAD, ik->protection_domain());\n+  Symbol* const class_name = ik->name();\n+  ClassLoadInfo cl_info(pd);\n+  ClassFileParser new_parser(stream,\n+                             class_name,\n+                             cld,\n+                             &cl_info,\n+                             ClassFileParser::INTERNAL, \/\/ internal visibility\n+                             THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    log_pending_exception(PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    return nullptr;\n+  }\n+  const ClassInstanceInfo* cl_inst_info = cl_info.class_hidden_info_ptr();\n+  InstanceKlass* const new_ik = new_parser.create_instance_klass(false, *cl_inst_info, THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    log_pending_exception(PENDING_EXCEPTION);\n+    CLEAR_PENDING_EXCEPTION;\n+    return nullptr;\n+  }\n+  assert(new_ik != nullptr, \"invariant\");\n+  assert(new_ik->name() != nullptr, \"invariant\");\n+  assert(ik->name() == new_ik->name(), \"invariant\");\n+  return new_ik;\n+}\n+\n+\/\/ Redefining \/ retransforming?\n+const Klass* JfrClassTransformer::find_existing_klass(const InstanceKlass* ik, JavaThread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(thread != nullptr, \"invariant\");\n+  JvmtiThreadState* const state = thread->jvmti_thread_state();\n+  return state != nullptr ? klass_being_redefined(ik, state) : nullptr;\n+}\n+\n+const Klass* JfrClassTransformer::klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(state != nullptr, \"invariant\");\n+  const GrowableArray<Klass*>* const redef_klasses = state->get_classes_being_redefined();\n+  if (redef_klasses == nullptr || redef_klasses->is_empty()) {\n+    return nullptr;\n+  }\n+  for (int i = 0; i < redef_klasses->length(); ++i) {\n+    const Klass* const existing_klass = redef_klasses->at(i);\n+    assert(existing_klass != nullptr, \"invariant\");\n+    if (ik->name() == existing_klass->name() && ik->class_loader_data() == existing_klass->class_loader_data()) {\n+      \/\/ 'ik' is a scratch klass. Return the klass being redefined.\n+      return existing_klass;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+\/\/ On redefine \/ retransform, in case an agent modified the class, the original bytes are cached onto the scratch klass.\n+void JfrClassTransformer::transfer_cached_class_file_data(InstanceKlass* ik, InstanceKlass* new_ik, const ClassFileParser& parser, JavaThread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(new_ik != nullptr, \"invariant\");\n+  JvmtiCachedClassFileData* const p = ik->get_cached_class_file();\n+  if (p != nullptr) {\n+    new_ik->set_cached_class_file(p);\n+    ik->set_cached_class_file(nullptr);\n+    return;\n+  }\n+  \/\/ No cached classfile indicates that no agent modified the klass.\n+  \/\/ This means that the parser is holding the original bytes. Hence, we cache it onto the scratch klass.\n+  const ClassFileStream* const stream = parser.clone_stream();\n+  cache_class_file_data(new_ik, stream, thread);\n+}\n+\n+void JfrClassTransformer::rewrite_klass_pointer(InstanceKlass*& ik, InstanceKlass* new_ik, ClassFileParser& parser, const JavaThread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(new_ik != nullptr, \"invariant\");\n+  assert(thread != nullptr, \"invariant\");\n+  assert(TRACE_ID(ik) == TRACE_ID(new_ik), \"invariant\");\n+  assert(!thread->has_pending_exception(), \"invariant\");\n+  \/\/ Assign original InstanceKlass* back onto \"its\" parser object for proper destruction.\n+  parser.set_klass_to_deallocate(ik);\n+  \/\/ Finally rewrite the original pointer to the newly created InstanceKlass.\n+  ik = new_ik;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrClassTransformer.cpp","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_INSTRUMENTATION_JFRCLASSTRANSFORMER_HPP\n+#define SHARE_JFR_INSTRUMENTATION_JFRCLASSTRANSFORMER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+class ClassFileParser;\n+class ClassFileStream;\n+class InstanceKlass;\n+\n+\/*\n+ * Contains common functionality used by method and event instrumentation.\n+ *\/\n+class JfrClassTransformer : AllStatic {\n+ private:\n+  static InstanceKlass* create_new_instance_klass(InstanceKlass* ik, ClassFileStream* stream, TRAPS);\n+  static const Klass* klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state);\n+\n+ public:\n+  static const Klass* find_existing_klass(const InstanceKlass* ik, JavaThread* thread);\n+  static InstanceKlass* create_instance_klass(InstanceKlass*& ik, ClassFileStream* stream, bool is_initial_load, JavaThread* thread);\n+  static void copy_traceid(const InstanceKlass* ik, const InstanceKlass* new_ik);\n+  static void transfer_cached_class_file_data(InstanceKlass* ik, InstanceKlass* new_ik, const ClassFileParser& parser, JavaThread* thread);\n+  static void rewrite_klass_pointer(InstanceKlass*& ik, InstanceKlass* new_ik, ClassFileParser& parser, const JavaThread* thread);\n+  static void cache_class_file_data(InstanceKlass* new_ik, const ClassFileStream* new_stream, const JavaThread* thread);\n+};\n+\n+#endif \/\/ SHARE_JFR_INSTRUMENTATION_JFRCLASSTRANSFORMER_HPP\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrClassTransformer.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"classfile\/classLoadInfo.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"classfile\/verificationType.hpp\"\n@@ -35,1 +33,1 @@\n-#include \"jvm.h\"\n+#include \"jfr\/instrumentation\/jfrClassTransformer.hpp\"\n@@ -40,1 +38,0 @@\n-#include \"jfr\/recorder\/jfrRecorder.hpp\"\n@@ -42,0 +39,2 @@\n+#include \"jfr\/support\/jfrAnnotationElementIterator.hpp\"\n+#include \"jfr\/support\/jfrAnnotationIterator.hpp\"\n@@ -43,1 +42,0 @@\n-#include \"jfr\/utilities\/jfrBigEndian.hpp\"\n@@ -45,0 +43,1 @@\n+#include \"jvm.h\"\n@@ -49,1 +48,0 @@\n-#include \"oops\/constMethod.hpp\"\n@@ -53,2 +51,0 @@\n-#include \"prims\/jvmtiRedefineClasses.hpp\"\n-#include \"prims\/jvmtiThreadState.hpp\"\n@@ -58,1 +54,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -61,1 +56,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -169,37 +163,6 @@\n-\/*\n-  Annotation layout.\n-\n-  enum {  \/\/ initial annotation layout\n-    atype_off = 0,      \/\/ utf8 such as 'Ljava\/lang\/annotation\/Retention;'\n-    count_off = 2,      \/\/ u2   such as 1 (one value)\n-    member_off = 4,     \/\/ utf8 such as 'value'\n-    tag_off = 6,        \/\/ u1   such as 'c' (type) or 'e' (enum)\n-    e_tag_val = 'e',\n-    e_type_off = 7,   \/\/ utf8 such as 'Ljava\/lang\/annotation\/RetentionPolicy;'\n-    e_con_off = 9,    \/\/ utf8 payload, such as 'SOURCE', 'CLASS', 'RUNTIME'\n-    e_size = 11,     \/\/ end of 'e' annotation\n-    c_tag_val = 'c',    \/\/ payload is type\n-    c_con_off = 7,    \/\/ utf8 payload, such as 'I'\n-    c_size = 9,       \/\/ end of 'c' annotation\n-    s_tag_val = 's',    \/\/ payload is String\n-    s_con_off = 7,    \/\/ utf8 payload, such as 'Ljava\/lang\/String;'\n-    s_size = 9,\n-    min_size = 6        \/\/ smallest possible size (zero members)\n-  };\n-*\/\n-\n-static int skip_annotation_value(const address, int, int); \/\/ fwd decl\n-\n-\/\/ Skip an annotation.  Return >=limit if there is any problem.\n-static int next_annotation_index(const address buffer, int limit, int index) {\n-  assert(buffer != nullptr, \"invariant\");\n-  index += 2;  \/\/ skip atype\n-  if ((index += 2) >= limit) {\n-    return limit;\n-  }\n-  int nof_members = JfrBigEndian::read<int, u2>(buffer + index - 2);\n-  while (--nof_members >= 0 && index < limit) {\n-    index += 2; \/\/ skip member\n-    index = skip_annotation_value(buffer, limit, index);\n-  }\n-  return index;\n+static JfrAnnotationElementIterator elements_iterator(const InstanceKlass* ik, const JfrAnnotationIterator& it) {\n+  const address buffer = it.buffer();\n+  int current = it.current();\n+  int next = it.next();\n+  assert(current < next, \"invariant\");\n+  return JfrAnnotationElementIterator(ik, buffer + current, next - current);\n@@ -208,163 +171,0 @@\n-\/\/ Skip an annotation value.  Return >=limit if there is any problem.\n-static int skip_annotation_value(const address buffer, int limit, int index) {\n-  assert(buffer != nullptr, \"invariant\");\n-  \/\/ value := switch (tag:u1) {\n-  \/\/   case B, C, I, S, Z, D, F, J, c: con:u2;\n-  \/\/   case e: e_class:u2 e_name:u2;\n-  \/\/   case s: s_con:u2;\n-  \/\/   case [: do(nval:u2) {value};\n-  \/\/   case @: annotation;\n-  \/\/   case s: s_con:u2;\n-  \/\/ }\n-  if ((index += 1) >= limit) {\n-    return limit;\n-  }\n-  const u1 tag = buffer[index - 1];\n-  switch (tag) {\n-    case 'B':\n-    case 'C':\n-    case 'I':\n-    case 'S':\n-    case 'Z':\n-    case 'D':\n-    case 'F':\n-    case 'J':\n-    case 'c':\n-    case 's':\n-      index += 2;  \/\/ skip con or s_con\n-      break;\n-    case 'e':\n-      index += 4;  \/\/ skip e_class, e_name\n-      break;\n-    case '[':\n-      {\n-        if ((index += 2) >= limit) {\n-          return limit;\n-        }\n-        int nof_values = JfrBigEndian::read<int, u2>(buffer + index - 2);\n-        while (--nof_values >= 0 && index < limit) {\n-          index = skip_annotation_value(buffer, limit, index);\n-        }\n-      }\n-      break;\n-    case '@':\n-      index = next_annotation_index(buffer, limit, index);\n-      break;\n-    default:\n-      return limit;  \/\/  bad tag byte\n-  }\n-  return index;\n-}\n-\n-static constexpr const int number_of_elements_offset = 2;\n-static constexpr const int element_name_offset = number_of_elements_offset + 2;\n-static constexpr const int element_name_size = 2;\n-static constexpr const int value_type_relative_offset = 2;\n-static constexpr const int value_relative_offset = value_type_relative_offset + 1;\n-\n-\/\/ see JVMS - 4.7.16. The RuntimeVisibleAnnotations Attribute\n-\n-class AnnotationElementIterator : public StackObj {\n- private:\n-  const InstanceKlass* _ik;\n-  const address _buffer;\n-  const int _limit; \/\/ length of annotation\n-  mutable int _current; \/\/ element\n-  mutable int _next; \/\/ element\n-\n-  int value_index() const {\n-    return JfrBigEndian::read<int, u2>(_buffer + _current + value_relative_offset);\n-  }\n-\n- public:\n-  AnnotationElementIterator(const InstanceKlass* ik, address buffer, int limit) : _ik(ik),\n-                                                                                  _buffer(buffer),\n-                                                                                  _limit(limit),\n-                                                                                  _current(element_name_offset),\n-                                                                                  _next(element_name_offset) {\n-    assert(_buffer != nullptr, \"invariant\");\n-    assert(_next == element_name_offset, \"invariant\");\n-    assert(_current == element_name_offset, \"invariant\");\n-  }\n-\n-  bool has_next() const {\n-    return _next < _limit;\n-  }\n-\n-  void move_to_next() const {\n-    assert(has_next(), \"invariant\");\n-    _current = _next;\n-    if (_next < _limit) {\n-      _next = skip_annotation_value(_buffer, _limit, _next + element_name_size);\n-    }\n-    assert(_next <= _limit, \"invariant\");\n-    assert(_current <= _limit, \"invariant\");\n-  }\n-\n-  int number_of_elements() const {\n-    return JfrBigEndian::read<int, u2>(_buffer + number_of_elements_offset);\n-  }\n-\n-  const Symbol* name() const {\n-    assert(_current < _next, \"invariant\");\n-    return _ik->constants()->symbol_at(JfrBigEndian::read<int, u2>(_buffer + _current));\n-  }\n-\n-  char value_type() const {\n-    return JfrBigEndian::read<char, u1>(_buffer + _current + value_type_relative_offset);\n-  }\n-\n-  jint read_int() const {\n-    return _ik->constants()->int_at(value_index());\n-  }\n-\n-  bool read_bool() const {\n-    return read_int() != 0;\n-  }\n-};\n-\n-class AnnotationIterator : public StackObj {\n- private:\n-  const InstanceKlass* _ik;\n-  \/\/ ensure _limit field is declared before _buffer\n-  int _limit; \/\/ length of annotations array\n-  const address _buffer;\n-  mutable int _current; \/\/ annotation\n-  mutable int _next; \/\/ annotation\n-\n- public:\n-  AnnotationIterator(const InstanceKlass* ik, AnnotationArray* ar) : _ik(ik),\n-                                                                     _limit(ar != nullptr ? ar->length() : 0),\n-                                                                     _buffer(_limit > 2 ? ar->adr_at(2) : nullptr),\n-                                                                     _current(0),\n-                                                                     _next(0) {\n-    if (_limit >= 2) {\n-      _limit -= 2; \/\/ subtract sizeof(u2) number of annotations field\n-    }\n-  }\n-  bool has_next() const {\n-    return _next < _limit;\n-  }\n-\n-  void move_to_next() const {\n-    assert(has_next(), \"invariant\");\n-    _current = _next;\n-    if (_next < _limit) {\n-      _next = next_annotation_index(_buffer, _limit, _next);\n-    }\n-    assert(_next <= _limit, \"invariant\");\n-    assert(_current <= _limit, \"invariant\");\n-  }\n-\n-  const AnnotationElementIterator elements() const {\n-    assert(_current < _next, \"invariant\");\n-    return AnnotationElementIterator(_ik, _buffer + _current, _next - _current);\n-  }\n-\n-  const Symbol* type() const {\n-    assert(_buffer != nullptr, \"invariant\");\n-    assert(_current < _limit, \"invariant\");\n-    return _ik->constants()->symbol_at(JfrBigEndian::read<int, u2>(_buffer + _current));\n-  }\n-};\n-\n@@ -378,2 +178,1 @@\n-\n-  const AnnotationIterator annotation_iterator(ik, class_annotations);\n+  const JfrAnnotationIterator annotation_iterator(ik, class_annotations);\n@@ -387,1 +186,1 @@\n-      const AnnotationElementIterator element_iterator = annotation_iterator.elements();\n+      JfrAnnotationElementIterator element_iterator = elements_iterator(ik, annotation_iterator);\n@@ -416,1 +215,1 @@\n-    return true;\n+     return true;\n@@ -1558,51 +1357,0 @@\n-\/\/ On initial class load.\n-static void cache_class_file_data(InstanceKlass* new_ik, const ClassFileStream* new_stream, const JavaThread* thread) {\n-  assert(new_ik != nullptr, \"invariant\");\n-  assert(new_stream != nullptr, \"invariant\");\n-  assert(thread != nullptr, \"invariant\");\n-  assert(!thread->has_pending_exception(), \"invariant\");\n-  if (!JfrOptionSet::allow_retransforms()) {\n-    return;\n-  }\n-  const jint stream_len = new_stream->length();\n-  JvmtiCachedClassFileData* p =\n-    (JvmtiCachedClassFileData*)NEW_C_HEAP_ARRAY_RETURN_NULL(u1, offset_of(JvmtiCachedClassFileData, data) + stream_len, mtInternal);\n-  if (p == nullptr) {\n-    log_error(jfr, system)(\"Allocation using C_HEAP_ARRAY for %zu bytes failed in JfrEventClassTransformer::cache_class_file_data\",\n-      static_cast<size_t>(offset_of(JvmtiCachedClassFileData, data) + stream_len));\n-    return;\n-  }\n-  p->length = stream_len;\n-  memcpy(p->data, new_stream->buffer(), stream_len);\n-  new_ik->set_cached_class_file(p);\n-}\n-\n-\/\/ On redefine \/ retransform, in case an agent modified the class, the original bytes are cached onto the scratch klass.\n-static void transfer_cached_class_file_data(InstanceKlass* ik, InstanceKlass* new_ik, const ClassFileParser& parser, JavaThread* thread) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(new_ik != nullptr, \"invariant\");\n-  JvmtiCachedClassFileData* const p = ik->get_cached_class_file();\n-  if (p != nullptr) {\n-    new_ik->set_cached_class_file(p);\n-    ik->set_cached_class_file(nullptr);\n-    return;\n-  }\n-  \/\/ No cached classfile indicates that no agent modified the klass.\n-  \/\/ This means that the parser is holding the original bytes. Hence, we cache it onto the scratch klass.\n-  const ClassFileStream* const stream = parser.clone_stream();\n-  cache_class_file_data(new_ik, stream, thread);\n-}\n-\n-static void rewrite_klass_pointer(InstanceKlass*& ik, InstanceKlass* new_ik, ClassFileParser& parser, const JavaThread* thread) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(new_ik != nullptr, \"invariant\");\n-  assert(thread != nullptr, \"invariant\");\n-  assert(IS_EVENT_OR_HOST_KLASS(new_ik), \"invariant\");\n-  assert(TRACE_ID(ik) == TRACE_ID(new_ik), \"invariant\");\n-  assert(!thread->has_pending_exception(), \"invariant\");\n-  \/\/ Assign original InstanceKlass* back onto \"its\" parser object for proper destruction.\n-  parser.set_klass_to_deallocate(ik);\n-  \/\/ Finally rewrite the original pointer to the newly created InstanceKlass.\n-  ik = new_ik;\n-}\n-\n@@ -1661,81 +1409,0 @@\n-static void copy_traceid(const InstanceKlass* ik, const InstanceKlass* new_ik) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(new_ik != nullptr, \"invariant\");\n-  new_ik->set_trace_id(ik->trace_id());\n-  assert(TRACE_ID(ik) == TRACE_ID(new_ik), \"invariant\");\n-}\n-\n-static const Klass* klass_being_redefined(const InstanceKlass* ik, JvmtiThreadState* state) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(state != nullptr, \"invariant\");\n-  const GrowableArray<Klass*>* const redef_klasses = state->get_classes_being_redefined();\n-  if (redef_klasses == nullptr || redef_klasses->is_empty()) {\n-    return nullptr;\n-  }\n-  for (int i = 0; i < redef_klasses->length(); ++i) {\n-    const Klass* const existing_klass = redef_klasses->at(i);\n-    assert(existing_klass != nullptr, \"invariant\");\n-    if (ik->name() == existing_klass->name() && ik->class_loader_data() == existing_klass->class_loader_data()) {\n-      \/\/ 'ik' is a scratch klass. Return the klass being redefined.\n-      return existing_klass;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-\/\/ Redefining \/ retransforming?\n-static const Klass* find_existing_klass(const InstanceKlass* ik, JavaThread* thread) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(thread != nullptr, \"invariant\");\n-  JvmtiThreadState* const state = thread->jvmti_thread_state();\n-  return state != nullptr ? klass_being_redefined(ik, state) : nullptr;\n-}\n-\n-static InstanceKlass* create_new_instance_klass(InstanceKlass* ik, ClassFileStream* stream, TRAPS) {\n-  assert(stream != nullptr, \"invariant\");\n-  ResourceMark rm(THREAD);\n-  ClassLoaderData* const cld = ik->class_loader_data();\n-  Handle pd(THREAD, ik->protection_domain());\n-  Symbol* const class_name = ik->name();\n-  const char* const klass_name = class_name != nullptr ? class_name->as_C_string() : \"\";\n-  ClassLoadInfo cl_info(pd);\n-  ClassFileParser new_parser(stream,\n-                             class_name,\n-                             cld,\n-                             &cl_info,\n-                             ClassFileParser::INTERNAL, \/\/ internal visibility\n-                             THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    log_pending_exception(PENDING_EXCEPTION);\n-    CLEAR_PENDING_EXCEPTION;\n-    return nullptr;\n-  }\n-  const ClassInstanceInfo* cl_inst_info = cl_info.class_hidden_info_ptr();\n-  InstanceKlass* const new_ik = new_parser.create_instance_klass(false, *cl_inst_info, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    log_pending_exception(PENDING_EXCEPTION);\n-    CLEAR_PENDING_EXCEPTION;\n-    return nullptr;\n-  }\n-  assert(new_ik != nullptr, \"invariant\");\n-  assert(new_ik->name() != nullptr, \"invariant\");\n-  assert(strncmp(ik->name()->as_C_string(), new_ik->name()->as_C_string(), strlen(ik->name()->as_C_string())) == 0, \"invariant\");\n-  return new_ik;\n-}\n-\n-static InstanceKlass* create_instance_klass(InstanceKlass*& ik, ClassFileStream* stream, bool is_initial_load, JavaThread* thread) {\n-  if (stream == nullptr) {\n-    if (is_initial_load) {\n-      log_error(jfr, system)(\"JfrEventClassTransformer: unable to create ClassFileStream for %s\", ik->external_name());\n-    }\n-    return nullptr;\n-  }\n-  InstanceKlass* const new_ik = create_new_instance_klass(ik, stream, thread);\n-  if (new_ik == nullptr) {\n-    if (is_initial_load) {\n-      log_error(jfr, system)(\"JfrEventClassTransformer: unable to create InstanceKlass for %s\", ik->external_name());\n-    }\n-  }\n-  return new_ik;\n-}\n-\n@@ -1746,1 +1413,1 @@\n-  const Klass* const existing_klass = find_existing_klass(ik, thread);\n+  const Klass* const existing_klass = JfrClassTransformer::find_existing_klass(ik, thread);\n@@ -1754,1 +1421,1 @@\n-  InstanceKlass* const new_ik = create_instance_klass(ik, stream, existing_klass == nullptr, thread);\n+  InstanceKlass* const new_ik = JfrClassTransformer::create_instance_klass(ik, stream, existing_klass == nullptr, thread);\n@@ -1759,1 +1426,1 @@\n-    transfer_cached_class_file_data(ik, new_ik, parser, thread);\n+    JfrClassTransformer::transfer_cached_class_file_data(ik, new_ik, parser, thread);\n@@ -1761,1 +1428,1 @@\n-    cache_class_file_data(new_ik, stream, thread);\n+    JfrClassTransformer::cache_class_file_data(new_ik, stream, thread);\n@@ -1766,2 +1433,2 @@\n-  copy_traceid(ik, new_ik);\n-  rewrite_klass_pointer(ik, new_ik, parser, thread);\n+  JfrClassTransformer::copy_traceid(ik, new_ik);\n+  JfrClassTransformer::rewrite_klass_pointer(ik, new_ik, parser, thread);\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":19,"deletions":352,"binary":false,"changes":371,"status":"modified"},{"patch":"@@ -81,13 +81,0 @@\n-  if (class_being_redefined == nullptr) {\n-    return;\n-  }\n-  JavaThread* jt = JavaThread::thread_from_jni_environment(jni_env);\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));;\n-  ThreadInVMfromNative tvmfn(jt);\n-  JfrUpcalls::on_retransform(JfrTraceId::load_raw(class_being_redefined),\n-                             class_being_redefined,\n-                             class_data_len,\n-                             class_data,\n-                             new_class_data_len,\n-                             new_class_data,\n-                             jt);\n@@ -178,0 +165,4 @@\n+  retransform_classes(env, classes, classes_count, THREAD);\n+}\n+\n+void JfrJvmtiAgent::retransform_classes(JNIEnv* env, jclass* classes, jint classes_count, TRAPS) {\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrJvmtiAgent.cpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+  static void retransform_classes(JNIEnv* env, jclass* classes, jint classes_count, TRAPS) NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrJvmtiAgent.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"jfr\/instrumentation\/jfrEventClassTransformer.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"jfr\/support\/jfrKlassExtension.hpp\"\n@@ -36,0 +38,4 @@\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -75,0 +81,16 @@\n+void Jfr::on_klass_creation(InstanceKlass*& ik, ClassFileParser& parser, TRAPS) {\n+  if (IS_EVENT_OR_HOST_KLASS(ik)) {\n+    JfrEventClassTransformer::on_klass_creation(ik, parser, THREAD);\n+    return;\n+  }\n+  if (JfrMethodTracer::in_use()) {\n+    JfrMethodTracer::on_klass_creation(ik, parser, THREAD);\n+  }\n+}\n+\n+void Jfr::on_klass_redefinition(const InstanceKlass* ik, Thread* thread) {\n+  assert(JfrMethodTracer::in_use(), \"invariant\");\n+  JfrMethodTracer::on_klass_redefinition(ik, thread);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class ClassFileParser;\n@@ -37,0 +38,1 @@\n+class InstanceKlass;\n@@ -61,0 +63,2 @@\n+  static void on_klass_creation(InstanceKlass*& ik, ClassFileParser& parser, TRAPS);\n+  static void on_klass_redefinition(const InstanceKlass* ik, Thread* thread);\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -932,0 +933,11 @@\n+\n+jlongArray JfrJavaSupport::create_long_array(GrowableArray<jlong>* array, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  assert(array != nullptr, \"invariant\");\n+  assert(array->is_nonempty(), \"invariant\");\n+  const int length = array->length();\n+  assert(length > 0, \"invariant\");\n+  typeArrayOop obj = oopFactory::new_typeArray(T_LONG, length, CHECK_NULL);\n+  ArrayAccess<>::arraycopy_from_native(&array->first(), obj, typeArrayOopDesc::element_offset<jlong>(0), length);\n+  return static_cast<jlongArray>(JfrJavaSupport::local_jni_handle(obj, THREAD));\n+}\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+template <typename E> class GrowableArray;\n@@ -91,0 +92,1 @@\n+  static jlongArray create_long_array(GrowableArray<jlong>* array, TRAPS);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n@@ -440,0 +441,8 @@\n+\n+JVM_ENTRY_NO_ENV(jlongArray, jfr_set_method_trace_filters(JNIEnv* env, jclass jvm, jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modifications))\n+  return JfrMethodTracer::set_filters(env, classes, methods, annotations, modifications, thread);\n+JVM_END\n+\n+JVM_ENTRY_NO_ENV(jlongArray, jfr_drain_stale_method_tracer_ids(JNIEnv* env, jclass jvm))\n+  return JfrMethodTracer::drain_stale_class_ids(thread);\n+JVM_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,0 +172,4 @@\n+jlongArray JNICALL jfr_set_method_trace_filters(JNIEnv* env, jclass jvm, jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modifications);\n+\n+jlongArray JNICALL jfr_drain_stale_method_tracer_ids(JNIEnv* env, jclass);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,1 +104,3 @@\n-      (char*)\"isProduct\", (char*)\"()Z\", (void*)jfr_is_product\n+      (char*)\"isProduct\", (char*)\"()Z\", (void*)jfr_is_product,\n+      (char*)\"setMethodTraceFilters\", (char*)\"([Ljava\/lang\/String;[Ljava\/lang\/String;[Ljava\/lang\/String;[I)[J\", (void*)jfr_set_method_trace_filters,\n+      (char*)\"drainStaleMethodTracerIds\", (char*)\"()[J\", (void*)jfr_drain_stale_method_tracer_ids\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/classFileStream.hpp\"\n@@ -26,0 +27,1 @@\n+#include \"classfile\/moduleEntry.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n@@ -31,0 +34,1 @@\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n@@ -39,0 +43,1 @@\n+#include \"runtime\/javaCalls.hpp\"\n@@ -40,0 +45,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -50,0 +56,4 @@\n+static Symbol* on_method_trace_sym = nullptr;\n+static Symbol* on_method_trace_sig_sym = nullptr;\n+static Symbol* publish_method_timers_for_klass_sym = nullptr;\n+static Symbol* publish_method_timers_for_klass_sig_sym = nullptr;\n@@ -62,1 +72,5 @@\n-    initialized = unhide_internal_types_sig_sym != nullptr;\n+    on_method_trace_sym = SymbolTable::new_permanent_symbol(\"onMethodTrace\");\n+    on_method_trace_sig_sym = SymbolTable::new_permanent_symbol(\"(Ljava\/lang\/Module;Ljava\/lang\/ClassLoader;Ljava\/lang\/String;[B[J[Ljava\/lang\/String;[Ljava\/lang\/String;[I)[B\");\n+    publish_method_timers_for_klass_sym = SymbolTable::new_permanent_symbol(\"publishMethodTimersForClass\");\n+    publish_method_timers_for_klass_sig_sym = SymbolTable::new_permanent_symbol(\"(J)V\");\n+    initialized = publish_method_timers_for_klass_sig_sym != nullptr;\n@@ -210,0 +224,100 @@\n+\n+\/\/ Caller needs ResourceMark\n+ClassFileStream* JfrUpcalls::on_method_trace(InstanceKlass* ik, const ClassFileStream* stream, GrowableArray<JfrTracedMethod>* methods, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  assert(stream != nullptr, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n+  assert(methods->is_nonempty(), \"invariant\");\n+  initialize(THREAD);\n+  Klass* klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, CHECK_NULL);\n+  assert(klass != nullptr, \"invariant\");\n+\n+  HandleMark hm(THREAD);\n+\n+  ModuleEntry* module_entry = ik->module();\n+  oop module = nullptr;\n+  if (module_entry != nullptr) {\n+    module = module_entry->module();\n+  }\n+  instanceHandle module_handle(THREAD, (instanceOop)module);\n+\n+  \/\/ ClassLoader\n+  oop class_loader = ik->class_loader();\n+  instanceHandle class_loader_handle(THREAD, (instanceOop)class_loader);\n+\n+  \/\/ String class name\n+  Handle class_name_h = java_lang_String::create_from_symbol(ik->name(), CHECK_NULL);\n+\n+  \/\/ new byte[]\n+  int size = stream->length();\n+  typeArrayOop bytecode_array = oopFactory::new_byteArray(size, CHECK_NULL);\n+  typeArrayHandle h_bytecode_array(THREAD, bytecode_array);\n+\n+  \/\/ Copy ClassFileStream bytes to byte[]\n+  const jbyte* src = reinterpret_cast<const jbyte*>(stream->buffer());\n+  ArrayAccess<>::arraycopy_from_native(src, bytecode_array, typeArrayOopDesc::element_offset<jbyte>(0), size);\n+\n+  int method_count = methods->length();\n+\n+  \/\/ new long[method_count]\n+  typeArrayOop id_array = oopFactory::new_longArray(method_count, CHECK_NULL);\n+  typeArrayHandle h_id_array(THREAD, id_array);\n+\n+  \/\/ new String[method_count]\n+  objArrayOop name_array = oopFactory::new_objArray(vmClasses::String_klass(), method_count, CHECK_NULL);\n+  objArrayHandle h_name_array(THREAD, name_array);\n+\n+  \/\/ new String[method_count]\n+  objArrayOop signature_array = oopFactory::new_objArray(vmClasses::String_klass(), method_count, CHECK_NULL);\n+  objArrayHandle h_signature_array(THREAD, signature_array);\n+\n+   \/\/ new int[method_count]\n+  typeArrayOop modification_array = oopFactory::new_intArray(method_count, CHECK_NULL);\n+  typeArrayHandle h_modification_array(THREAD, modification_array);\n+\n+  \/\/ Fill in arrays\n+  for (int i = 0; i < method_count; i++) {\n+    JfrTracedMethod method = methods->at(i);\n+    h_id_array->long_at_put(i, method.id());\n+    Handle name = java_lang_String::create_from_symbol(method.name(), CHECK_NULL);\n+    h_name_array->obj_at_put(i, name());\n+    Handle signature = java_lang_String::create_from_symbol(method.signature(), CHECK_NULL);\n+    h_signature_array->obj_at_put(i, signature());\n+    h_modification_array->int_at_put(i, method.modification());\n+  }\n+\n+  \/\/ Call JVMUpcalls::onMethodTrace\n+  JavaCallArguments args;\n+  JavaValue result(T_ARRAY);\n+  args.push_oop(module_handle);\n+  args.push_oop(class_loader_handle);\n+  args.push_oop(class_name_h);\n+  args.push_oop(h_bytecode_array);\n+  args.push_oop(h_id_array);\n+  args.push_oop(h_name_array);\n+  args.push_oop(h_signature_array);\n+  args.push_oop(h_modification_array);\n+  JavaCalls::call_static(&result, klass, on_method_trace_sym, on_method_trace_sig_sym, &args, CHECK_NULL);\n+\n+  oop return_object = result.get_oop();\n+  if (return_object != nullptr) {\n+    assert(return_object->is_typeArray(), \"invariant\");\n+    assert(TypeArrayKlass::cast(return_object->klass())->element_type() == T_BYTE, \"invariant\");\n+    typeArrayOop byte_array = typeArrayOop(return_object);\n+    int length = byte_array->length();\n+    u1* buffer = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, u1, length);\n+    ArrayAccess<>::arraycopy_to_native<>(byte_array, typeArrayOopDesc::element_offset<jbyte>(0), buffer, length);\n+    return new ClassFileStream(buffer, length, stream->source(), stream->from_boot_loader_modules_image());\n+  }\n+  return nullptr;\n+}\n+\n+void JfrUpcalls::publish_method_timers_for_klass(traceid klass_id, TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+  Klass* const klass = SystemDictionary::resolve_or_fail(jvm_upcalls_class_sym, true, CHECK);\n+  assert(klass != nullptr, \"invariant\");\n+  JavaCallArguments args;\n+  JavaValue result(T_VOID);\n+  args.push_long(static_cast<jlong>(klass_id));\n+  JavaCalls::call_static(&result, klass, publish_method_timers_for_klass_sym, publish_method_timers_for_klass_sig_sym, &args, CHECK);\n+}\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":115,"deletions":1,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n@@ -32,0 +33,3 @@\n+class ClassFileStream;\n+class InstanceKlass;\n+class JfrTracedMethod;\n@@ -33,0 +37,1 @@\n+template <typename E> class GrowableArray;\n@@ -58,0 +63,7 @@\n+  \/\/ Caller needs ResourceMark\n+  static ClassFileStream* on_method_trace(InstanceKlass* ik, const ClassFileStream* stream,\n+                                          GrowableArray<JfrTracedMethod>* methods,\n+                                          TRAPS);\n+\n+  static void publish_method_timers_for_klass(traceid klass_id, TRAPS);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1295,0 +1295,10 @@\n+  <Event name=\"MethodTrace\" category=\"Java Application\" label=\"Method Trace\" thread=\"true\" stackTrace=\"true\" startTime=\"true\">\n+    <Field type=\"Method\" name=\"method\" label=\"Method\" \/>\n+  <\/Event>\n+\n+  <Event name=\"MethodTiming\" category=\"Java Application\" label=\"Method Timing\" thread=\"false\" stackTrace=\"false\" startTime=\"false\" period=\"everyChunk\">\n+    <Field type=\"Method\" name=\"method\" label=\"Method\" \/>\n+    <Field type=\"long\" name=\"invocations\" label=\"Invocations\" description=\"The number of times the method was invoked\" \/>\n+    <Field type=\"Tickspan\" name=\"average\" label=\"Average\" description=\"An approximation of the wall-clock time it took for the method to execute\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -324,0 +324,4 @@\n+TRACE_REQUEST_FUNC(MethodTiming) {\n+  \/\/ Emitted in Java, but defined in native to have Method type field.\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+#include \"jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n@@ -483,0 +485,48 @@\n+static void do_method_tracer_klasses() {\n+  assert(JfrTraceIdEpoch::has_method_tracer_changed_tag_state(), \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(_subsystem_callback != nullptr, \"invariant\");\n+  GrowableArray<JfrInstrumentedClass>* const instrumented = JfrMethodTracer::instrumented_classes();\n+  assert(instrumented != nullptr, \"invariant\");\n+  assert(instrumented->length() > 0, \"invariant\");\n+  for (int i = 0; i < instrumented->length(); ++i) {\n+    JfrInstrumentedClass& jic = instrumented->at(i);\n+    if (jic.unloaded()) {\n+      continue;\n+    }\n+    if (JfrKlassUnloading::is_unloaded(jic.trace_id(), previous_epoch())) {\n+      jic.set_unloaded(true);\n+      continue;\n+    }\n+    assert(jic.trace_id() == JfrTraceId::load_raw(jic.instance_klass()), \"invariant\");\n+    assert(JfrTraceId::has_sticky_bit(jic.instance_klass()), \"invariant\");\n+    if (current_epoch()) {\n+      JfrTraceId::load(jic.instance_klass()); \/\/ enqueue klass for this epoch\n+    } else {\n+      _subsystem_callback->do_artifact(jic.instance_klass()); \/\/ process directly\n+    }\n+  }\n+  JfrTraceIdEpoch::reset_method_tracer_tag_state();\n+}\n+\n+static void clear_method_tracer_klasses() {\n+  assert_locked_or_safepoint (ClassLoaderDataGraph_lock);\n+  assert(previous_epoch(), \"invariant\");\n+  GrowableArray<JfrInstrumentedClass>* const instrumented = JfrMethodTracer::instrumented_classes();\n+  assert(instrumented != nullptr, \"invariant\");\n+  const int length = instrumented->length();\n+  bool trim = false;\n+  for (int i = 0; i < length; ++i) {\n+    JfrInstrumentedClass& jic = instrumented->at(i);\n+    if (jic.unloaded()) {\n+      trim = true;\n+      continue;\n+    }\n+    if (JfrKlassUnloading::is_unloaded(jic.trace_id(), true)) {\n+      jic.set_unloaded(true);\n+      trim = true;\n+    }\n+  }\n+  JfrMethodTracer::trim_instrumented_classes(trim);\n+}\n+\n@@ -490,0 +540,3 @@\n+    if (JfrTraceId::has_sticky_bit(klass)) {\n+      JfrMethodTracer::add_to_unloaded_set(klass);\n+    }\n@@ -507,1 +560,1 @@\n-    \/\/ Only write the primitive classes once per chunk.\n+    \/\/ Only write the primitive and method tracer classes once per chunk.\n@@ -510,0 +563,4 @@\n+  if (JfrTraceIdEpoch::has_method_tracer_changed_tag_state()) {\n+    do_method_tracer_klasses();\n+  }\n+\n@@ -1209,0 +1266,1 @@\n+    clear_method_tracer_klasses();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,1 @@\n+  static traceid load_previous_epoch(const Klass* klass);\n@@ -105,0 +106,1 @@\n+  static traceid load_raw(const Klass* holder, const Method* method);\n@@ -139,0 +141,12 @@\n+\n+  \/\/ Sticky bits and timing bits\n+  static bool has_sticky_bit(const Klass* k);\n+  static bool has_sticky_bit(const Method* method);\n+  static void set_sticky_bit(const Klass* k);\n+  static void set_sticky_bit(const Method* method);\n+  static void clear_sticky_bit(const Klass* k);\n+  static void clear_sticky_bit(const Method* method);\n+  static bool has_timing_bit(const Klass* k);\n+  static void set_timing_bit(const Klass* k);\n+  static void clear_timing_bit(const Klass* k);\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -80,1 +81,5 @@\n-  return JfrTraceIdLoadBarrier::load_leakp_previuos_epoch(klass, method);\n+  return JfrTraceIdLoadBarrier::load_leakp_previous_epoch(klass, method);\n+}\n+\n+inline traceid JfrTraceId::load_previous_epoch(const Klass* klass) {\n+  return JfrTraceIdLoadBarrier::load_previous_epoch(klass);\n@@ -93,0 +98,7 @@\n+inline traceid JfrTraceId::load_raw(const Klass* holder, const Method* method) {\n+  assert(holder != nullptr, \"invariant\");\n+  assert(method != nullptr, \"invariant\");\n+  assert(method->method_holder() == holder, \"invariant\");\n+  return METHOD_ID(holder, method);\n+}\n+\n@@ -94,1 +106,1 @@\n-  return (METHOD_ID(method->method_holder(), method));\n+  return load_raw(method->method_holder(), method);\n@@ -159,0 +171,63 @@\n+inline bool JfrTraceId::has_sticky_bit(const Klass* k) {\n+  assert(k != nullptr, \"invariant\");\n+  return HAS_STICKY_BIT(k);\n+}\n+\n+inline void JfrTraceId::set_sticky_bit(const Klass* k) {\n+  assert(k != nullptr, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(!has_sticky_bit(k), \"invariant\");\n+  SET_STICKY_BIT(k);\n+  assert(has_sticky_bit(k), \"invariant\");\n+}\n+\n+inline void JfrTraceId::clear_sticky_bit(const Klass* k) {\n+  assert(k != nullptr, \"invarriant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(JfrTraceId::has_sticky_bit(k), \"invariant\");\n+  CLEAR_STICKY_BIT(k);\n+  assert(!JfrTraceId::has_sticky_bit(k), \"invariant\");\n+}\n+\n+inline bool JfrTraceId::has_sticky_bit(const Method* method) {\n+  assert(method != nullptr, \"invariant\");\n+  return METHOD_HAS_STICKY_BIT(method);\n+}\n+\n+inline void JfrTraceId::set_sticky_bit(const Method* method) {\n+  assert(method != nullptr, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(!has_sticky_bit(method), \"invariant\");\n+  SET_METHOD_STICKY_BIT(method);\n+  assert(has_sticky_bit(method), \"invariant\");\n+}\n+\n+inline void JfrTraceId::clear_sticky_bit(const Method* method) {\n+  assert(method != nullptr, \"invarriant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(JfrTraceId::has_sticky_bit(method), \"invariant\");\n+  CLEAR_STICKY_BIT_METHOD(method);\n+  assert(!JfrTraceId::has_sticky_bit(method), \"invariant\");\n+}\n+\n+inline bool JfrTraceId::has_timing_bit(const Klass* k) {\n+  assert(k != nullptr, \"invariant\");\n+  return HAS_TIMING_BIT(k);\n+}\n+\n+inline void JfrTraceId::set_timing_bit(const Klass* k) {\n+  assert(k != nullptr, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(!has_timing_bit(k), \"invariant\");\n+  SET_TIMING_BIT(k);\n+  assert(has_timing_bit(k), \"invariant\");\n+}\n+\n+inline void JfrTraceId::clear_timing_bit(const Klass* k) {\n+  assert(k != nullptr, \"invarriant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(JfrTraceId::has_timing_bit(k), \"invariant\");\n+  CLEAR_TIMING_BIT(k);\n+  assert(!JfrTraceId::has_timing_bit(k), \"invariant\");\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp","additions":78,"deletions":3,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/mutex.hpp\"\n@@ -38,0 +40,1 @@\n+bool JfrTraceIdEpoch::_method_tracer_state = false;\n@@ -62,0 +65,18 @@\n+\n+bool JfrTraceIdEpoch::is_synchronizing() {\n+  return Atomic::load_acquire(&_synchronizing);\n+}\n+\n+void JfrTraceIdEpoch::set_method_tracer_tag_state() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  Atomic::store(&_method_tracer_state, true);\n+}\n+\n+void JfrTraceIdEpoch::reset_method_tracer_tag_state() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  Atomic::store(&_method_tracer_state, false);\n+}\n+\n+bool JfrTraceIdEpoch::has_method_tracer_changed_tag_state() {\n+  return Atomic::load_acquire(&_method_tracer_state);\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -60,0 +59,1 @@\n+  static bool _method_tracer_state;\n@@ -95,3 +95,1 @@\n-  static bool is_synchronizing() {\n-    return Atomic::load_acquire(&_synchronizing);\n-  }\n+  static bool is_synchronizing();\n@@ -124,1 +122,1 @@\n-    return _tag_state.is_signaled_with_reset();\n+    return _tag_state.is_signaled_with_reset() || has_method_tracer_changed_tag_state();\n@@ -138,0 +136,4 @@\n+\n+  static void set_method_tracer_tag_state();\n+  static void reset_method_tracer_tag_state();\n+  static bool has_method_tracer_changed_tag_state();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,1 @@\n+  friend class JfrTraceTagging;\n@@ -86,0 +87,1 @@\n+  static traceid load_previous_epoch(const Klass* klass);\n@@ -92,2 +94,1 @@\n-  static traceid load_leakp_previuos_epoch(const Klass* klass, const Method* method); \/\/ leak profiler\n-  static void do_klasses(void f(Klass*), bool previous_epoch = false);\n+  static traceid load_leakp_previous_epoch(const Klass* klass, const Method* method); \/\/ leak profiler\n@@ -96,0 +97,1 @@\n+  static void do_klasses(void f(Klass*), bool previous_epoch = false);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-inline traceid JfrTraceIdLoadBarrier::load_leakp_previuos_epoch(const Klass* klass, const Method* method) {\n+inline traceid JfrTraceIdLoadBarrier::load_leakp_previous_epoch(const Klass* klass, const Method* method) {\n@@ -181,3 +181,0 @@\n-    \/\/ the method is already logically tagged, just like the klass,\n-    \/\/ but because of redefinition, the latest Method*\n-    \/\/ representation might not have a reified tag.\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#define TIMING_BIT                                LEAKP_BIT \/\/ Alias\n@@ -58,0 +59,2 @@\n+#define STICKY_META_BIT                           (BIT << 5)\n+#define STICKY_BIT                                (STICKY_META_BIT << META_SHIFT)\n@@ -61,1 +64,1 @@\n-#define META_BITS                                 (SERIALIZED_BIT | TRANSIENT_BIT | LEAKP_BIT | EPOCH_1_CLEARED_BIT | EPOCH_0_CLEARED_BIT)\n+#define META_BITS                                 (STICKY_BIT | SERIALIZED_BIT | TRANSIENT_BIT | LEAKP_BIT | EPOCH_1_CLEARED_BIT | EPOCH_0_CLEARED_BIT)\n@@ -93,1 +96,1 @@\n-#define USED_THIS_EPOCH(ptr)                      (TRACE_ID_PREDICATE(ptr, (TRANSIENT_BIT | THIS_EPOCH_BIT)))\n+#define USED_THIS_EPOCH(ptr)                      (TRACE_ID_PREDICATE(ptr, (STICKY_BIT | TRANSIENT_BIT | THIS_EPOCH_BIT)))\n@@ -95,3 +98,3 @@\n-#define USED_PREVIOUS_EPOCH(ptr)                  (TRACE_ID_PREDICATE(ptr, (TRANSIENT_BIT | PREVIOUS_EPOCH_BIT)))\n-#define USED_ANY_EPOCH(ptr)                       (TRACE_ID_PREDICATE(ptr, (TRANSIENT_BIT | EPOCH_1_BIT | EPOCH_0_BIT)))\n-#define METHOD_USED_THIS_EPOCH(kls)               (TRACE_ID_PREDICATE(kls, (THIS_EPOCH_METHOD_BIT)))\n+#define USED_PREVIOUS_EPOCH(ptr)                  (TRACE_ID_PREDICATE(ptr, (STICKY_BIT | TRANSIENT_BIT | PREVIOUS_EPOCH_BIT)))\n+#define USED_ANY_EPOCH(ptr)                       (TRACE_ID_PREDICATE(ptr, (STICKY_BIT | TRANSIENT_BIT | EPOCH_1_BIT | EPOCH_0_BIT)))\n+#define METHOD_USED_THIS_EPOCH(kls)               (TRACE_ID_PREDICATE(kls, (STICKY_BIT | THIS_EPOCH_METHOD_BIT)))\n@@ -99,1 +102,1 @@\n-#define METHOD_USED_PREVIOUS_EPOCH(kls)           (TRACE_ID_PREDICATE(kls, (PREVIOUS_EPOCH_METHOD_BIT)))\n+#define METHOD_USED_PREVIOUS_EPOCH(kls)           (TRACE_ID_PREDICATE(kls, (STICKY_BIT | PREVIOUS_EPOCH_METHOD_BIT)))\n@@ -104,1 +107,1 @@\n-#define METHOD_FLAG_USED_THIS_EPOCH(method)       (METHOD_FLAG_PREDICATE(method, (TRANSIENT_BIT | THIS_EPOCH_BIT)))\n+#define METHOD_FLAG_USED_THIS_EPOCH(method)       (METHOD_FLAG_PREDICATE(method, (STICKY_BIT | TRANSIENT_BIT | THIS_EPOCH_BIT)))\n@@ -135,0 +138,1 @@\n+#define SET_TIMING_BIT(ptr)                       (SET_LEAKP(ptr))\n@@ -136,0 +140,1 @@\n+#define HAS_TIMING_BIT(ptr)                       (IS_LEAKP(ptr))\n@@ -137,0 +142,1 @@\n+#define HAS_NOT_TIMING_BIT(ptr)                   (IS_NOT_LEAKP(ptr))\n@@ -140,0 +146,2 @@\n+#define IS_SERIALIZED(ptr)                        (TRACE_ID_PREDICATE(ptr, SERIALIZED_BIT))\n+#define IS_NOT_SERIALIZED(ptr)                    (!(IS_SERIALIZED(ptr)))\n@@ -141,0 +149,3 @@\n+#define HAS_STICKY_BIT(ptr)                       (TRACE_ID_PREDICATE(ptr, STICKY_BIT))\n+#define HAS_NOT_STICKY_BIT(ptr)                   (!(HAS_STICKY_BIT(ptr)))\n+#define SET_STICKY_BIT(ptr)                       (TRACE_ID_META_TAG(ptr, STICKY_META_BIT))\n@@ -143,2 +154,0 @@\n-#define IS_SERIALIZED(ptr)                        (TRACE_ID_PREDICATE(ptr, SERIALIZED_BIT))\n-#define IS_NOT_SERIALIZED(ptr)                    (!(IS_SERIALIZED(ptr)))\n@@ -154,0 +163,3 @@\n+#define SET_METHOD_STICKY_BIT(method)             (METHOD_META_TAG(method, STICKY_META_BIT))\n+#define METHOD_HAS_STICKY_BIT(method)             (METHOD_FLAG_PREDICATE(method, STICKY_BIT))\n+#define METHOD_HAS_NOT_STICKY_BIT(method)         (!(METHOD_HAS_STICKY_BIT(method)))\n@@ -163,0 +175,1 @@\n+#define CLEAR_TIMING_BIT(ptr)                     (CLEAR_LEAKP(ptr))\n@@ -164,0 +177,2 @@\n+#define CLEAR_STICKY_BIT(ptr)                     (TRACE_ID_META_MASK_CLEAR(ptr, (~(STICKY_META_BIT))))\n+#define CLEAR_STICKY_BIT_METHOD(method)           (METHOD_META_MASK_CLEAR(method, (~(STICKY_META_BIT))))\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+* Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"jfr\/support\/jfrAnnotationElementIterator.hpp\"\n+#include \"jfr\/support\/jfrAnnotationIterator.hpp\"\n+#include \"jfr\/utilities\/jfrBigEndian.hpp\"\n+#include \"oops\/constantPool.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/symbol.hpp\"\n+\n+\/*\n+ Annotation layout.\n+\n+ enum {  \/\/ initial annotation layout\n+   atype_off = 0,    \/\/ utf8 such as 'Ljava\/lang\/annotation\/Retention;'\n+   count_off = 2,    \/\/ u2   such as 1 (one value)\n+   member_off = 4,   \/\/ utf8 such as 'value'\n+   tag_off = 6,      \/\/ u1   such as 'c' (type) or 'e' (enum)\n+   e_tag_val = 'e',\n+   e_type_off = 7,   \/\/ utf8 such as 'Ljava\/lang\/annotation\/RetentionPolicy;'\n+   e_con_off = 9,    \/\/ utf8 payload, such as 'SOURCE', 'CLASS', 'RUNTIME'\n+   e_size = 11,      \/\/ end of 'e' annotation\n+   c_tag_val = 'c',  \/\/ payload is type\n+   c_con_off = 7,    \/\/ utf8 payload, such as 'I'\n+   c_size = 9,       \/\/ end of 'c' annotation\n+   s_tag_val = 's',  \/\/ payload is String\n+   s_con_off = 7,    \/\/ utf8 payload, such as 'Ljava\/lang\/String;'\n+   s_size = 9,\n+   min_size = 6      \/\/ smallest possible size (zero members)\n+ };\n+\n+ See JVMS - 4.7.16. The RuntimeVisibleAnnotations Attribute\n+\n+*\/\n+\n+static constexpr const int number_of_elements_offset = 2;\n+static constexpr const int element_name_offset = number_of_elements_offset + 2;\n+static constexpr const int element_name_size = 2;\n+static constexpr const int value_type_relative_offset = 2;\n+static constexpr const int value_relative_offset = value_type_relative_offset + 1;\n+\n+JfrAnnotationElementIterator::JfrAnnotationElementIterator(const InstanceKlass* ik, address buffer, int limit) :\n+  _ik(ik),\n+  _buffer(buffer),\n+  _limit(limit),\n+  _current(element_name_offset),\n+  _next(element_name_offset) {\n+  assert(_buffer != nullptr, \"invariant\");\n+  assert(_next == element_name_offset, \"invariant\"); assert(_current == element_name_offset, \"invariant\");\n+}\n+\n+int JfrAnnotationElementIterator::value_index() const {\n+  return JfrBigEndian::read<int, u2>(_buffer + _current + value_relative_offset);\n+}\n+\n+bool JfrAnnotationElementIterator::has_next() const {\n+  return _next < _limit;\n+}\n+\n+void JfrAnnotationElementIterator::move_to_next() const {\n+  assert(has_next(), \"invariant\");\n+  _current = _next;\n+  if (_next < _limit) {\n+    _next = JfrAnnotationIterator::skip_annotation_value(_buffer, _limit, _next + element_name_size);\n+  }\n+  assert(_next <= _limit, \"invariant\"); assert(_current <= _limit, \"invariant\");\n+}\n+\n+int JfrAnnotationElementIterator::number_of_elements() const {\n+  return JfrBigEndian::read<int, u2>(_buffer + number_of_elements_offset);\n+}\n+\n+const Symbol* JfrAnnotationElementIterator::name() const {\n+  assert(_current < _next, \"invariant\");\n+  return _ik->constants()->symbol_at(JfrBigEndian::read<int, u2>(_buffer + _current));\n+}\n+\n+char JfrAnnotationElementIterator::value_type() const {\n+  return JfrBigEndian::read<char, u1>(_buffer + _current + value_type_relative_offset);\n+}\n+\n+jint JfrAnnotationElementIterator::read_int() const {\n+  return _ik->constants()->int_at(value_index());\n+}\n+\n+bool JfrAnnotationElementIterator::read_bool() const {\n+  return read_int() != 0;\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAnnotationElementIterator.cpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+* Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRANNOTATIONELEMENTITERATOR_HPP\n+#define SHARE_JFR_SUPPORT_JFRANNOTATIONELEMENTITERATOR_HPP\n+\n+#include \"jni.h\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"memory\/allocation.hpp\"\n+\n+class InstanceKlass;\n+class Symbol;\n+\n+class JfrAnnotationElementIterator : public StackObj {\n+ private:\n+  const InstanceKlass* _ik;\n+  const address _buffer;\n+  const int _limit; \/\/ length of annotation\n+  mutable int _current; \/\/ element\n+  mutable int _next; \/\/ element\n+  int value_index() const;\n+\n+ public:\n+  JfrAnnotationElementIterator(const InstanceKlass* ik, address buffer, int limit);\n+  bool has_next() const;\n+  void move_to_next() const;\n+  int number_of_elements() const;\n+  bool read_bool() const;\n+  jint read_int() const;\n+  char value_type() const;\n+  const Symbol* name() const;\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRANNOTATIONELEMENTITERATOR_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAnnotationElementIterator.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+* Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"jfr\/support\/jfrAnnotationIterator.hpp\"\n+#include \"jfr\/utilities\/jfrBigEndian.hpp\"\n+#include \"oops\/constantPool.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/symbol.hpp\"\n+\n+JfrAnnotationIterator::JfrAnnotationIterator(const InstanceKlass* ik, AnnotationArray* ar) :\n+ _ik(ik),\n+ _limit(ar != nullptr ? ar->length() : 0),\n+ _buffer(_limit > 2 ? ar->adr_at(2) : nullptr),\n+ _current(0),\n+ _next(0) {\n+  if (_limit >= 2) {\n+    _limit -= 2; \/\/ subtract sizeof(u2) number of annotations field\n+  }\n+}\n+\n+bool JfrAnnotationIterator::has_next() const {\n+  return _next < _limit;\n+}\n+\n+void JfrAnnotationIterator::move_to_next() const {\n+  assert(has_next(), \"invariant\");\n+  _current = _next;\n+  if (_next < _limit) {\n+    _next = next_annotation_index(_buffer, _limit, _next);\n+  }\n+  assert(_next <= _limit, \"invariant\");\n+  assert(_current <= _limit, \"invariant\");\n+}\n+\n+const Symbol* JfrAnnotationIterator::type() const {\n+  assert(_buffer != nullptr, \"invariant\");\n+  assert(_current < _limit, \"invariant\");\n+  return _ik->constants()->symbol_at(JfrBigEndian::read<int, u2>(_buffer + _current));\n+}\n+\n+address JfrAnnotationIterator::buffer() const {\n+  return _buffer;\n+}\n+\n+int JfrAnnotationIterator::current() const {\n+  return _current;\n+}\n+\n+int JfrAnnotationIterator::next() const {\n+  return _next;\n+}\n+\n+\/\/ Skip an annotation.  Return >=limit if there is any problem.\n+int JfrAnnotationIterator::next_annotation_index(const address buffer, int limit, int index) {\n+  assert(buffer != nullptr, \"invariant\");\n+  index += 2;  \/\/ skip atype\n+  if ((index += 2) >= limit) {\n+    return limit;\n+  }\n+  int nof_members = JfrBigEndian::read<int, u2>(buffer + index - 2);\n+  while (--nof_members >= 0 && index < limit) {\n+    index += 2; \/\/ skip member\n+    index = skip_annotation_value(buffer, limit, index);\n+  }\n+  return index;\n+}\n+\n+\/\/ Skip an annotation value.  Return >=limit if there is any problem.\n+int JfrAnnotationIterator::skip_annotation_value(const address buffer, int limit, int index) {\n+  assert(buffer != nullptr, \"invariant\");\n+  \/\/ value := switch (tag:u1) {\n+  \/\/   case B, C, I, S, Z, D, F, J, c: con:u2;\n+  \/\/   case e: e_class:u2 e_name:u2;\n+  \/\/   case s: s_con:u2;\n+  \/\/   case [: do(nval:u2) {value};\n+  \/\/   case @: annotation;\n+  \/\/   case s: s_con:u2;\n+  \/\/ }\n+  if ((index += 1) >= limit) {\n+    return limit;\n+  }\n+  const u1 tag = buffer[index - 1];\n+  switch (tag) {\n+    case 'B':\n+    case 'C':\n+    case 'I':\n+    case 'S':\n+    case 'Z':\n+    case 'D':\n+    case 'F':\n+    case 'J':\n+    case 'c':\n+    case 's':\n+      index += 2;  \/\/ skip con or s_con\n+      break;\n+    case 'e':\n+      index += 4;  \/\/ skip e_class, e_name\n+      break;\n+    case '[':\n+      {\n+        if ((index += 2) >= limit) {\n+          return limit;\n+        }\n+        int nof_values = JfrBigEndian::read<int, u2>(buffer + index - 2);\n+        while (--nof_values >= 0 && index < limit) {\n+          index = skip_annotation_value(buffer, limit, index);\n+        }\n+      }\n+      break;\n+    case '@':\n+      index = next_annotation_index(buffer, limit, index);\n+      break;\n+    default:\n+      return limit;  \/\/  bad tag byte\n+  }\n+  return index;\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAnnotationIterator.cpp","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+* Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRANNOTATIONITERATOR_HPP\n+#define SHARE_JFR_SUPPORT_JFRANNOTATIONITERATOR_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/annotations.hpp\"\n+\n+class Symbol;\n+class InstanceKlass;\n+\n+class JfrAnnotationIterator: public StackObj {\n+ friend class JfrAnnotationElementIterator;\n+ private:\n+  const InstanceKlass* _ik;\n+  \/\/ ensure _limit field is declared before _buffer\n+  int _limit; \/\/ length of annotations array\n+  const address _buffer;\n+  mutable int _current; \/\/ annotation\n+  mutable int _next; \/\/ annotation\n+  static int skip_annotation_value(const address buffer, int limit, int index);\n+  static int next_annotation_index(const address buffer, int limit, int index);\n+\n+ public:\n+  JfrAnnotationIterator(const InstanceKlass* ik, AnnotationArray* ar);\n+  bool has_next() const;\n+  void move_to_next() const;\n+  const Symbol* type() const;\n+  address buffer() const;\n+  int current() const;\n+  int next() const;\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRANNOTATIONITERATOR_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrAnnotationIterator.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"jfr\/instrumentation\/jfrEventClassTransformer.hpp\"\n+#include \"jfr\/jfr.hpp\"\n@@ -40,0 +40,1 @@\n+#define EVENT_STICKY_BIT       8192\n@@ -42,1 +43,3 @@\n-#define ON_KLASS_CREATION(k, p, t) if (IS_EVENT_OR_HOST_KLASS(k)) JfrEventClassTransformer::on_klass_creation(k, p, t)\n+#define KLASS_HAS_STICKY_BIT(ptr) (((ptr)->trace_id() & STICKY_BIT) != 0)\n+#define ON_KLASS_REDEFINITION(k, t) if (KLASS_HAS_STICKY_BIT(k)) Jfr::on_klass_redefinition(k, t)\n+#define ON_KLASS_CREATION(k, p, t) Jfr::on_klass_creation(k, p, t)\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassExtension.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/support\/jfrKlassUnloading.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrClassFilterClosure.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilter.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilterManager.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n+\n+constexpr static unsigned int TABLE_SIZE = 1009;\n+constexpr static unsigned int MAX_TABLE_SIZE = 0x3fffffff;\n+\n+JfrFilterClassClosure::JfrFilterClassClosure(JavaThread* thread) :\n+  _new_filter(JfrFilterManager::current()),\n+  _classes_to_modify(new ClosureSet(TABLE_SIZE, MAX_TABLE_SIZE)),\n+  _thread(thread) {\n+  assert(_new_filter != nullptr, \"invariant\");\n+}\n+\n+static inline jclass mirror_as_local_jni_handle(const InstanceKlass* ik, JavaThread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(thread != nullptr, \"invariant\");\n+  return reinterpret_cast<jclass>(JfrJavaSupport::local_jni_handle(ik->java_mirror(), thread));\n+}\n+\n+inline bool JfrFilterClassClosure::match(const InstanceKlass* ik) const {\n+  assert(_new_filter != nullptr, \"invariant\");\n+  return _new_filter->can_instrument_class(ik) && _new_filter->match(ik);\n+}\n+\n+void JfrFilterClassClosure::do_klass(Klass* k) {\n+  assert(k != nullptr, \"invariant\");\n+  if (k->is_instance_klass()) {\n+    const InstanceKlass* const ik = InstanceKlass::cast(k);\n+    if (match(ik)) {\n+      assert(ik->is_loader_alive(), \"invariant\");\n+      const traceid klass_id = JfrTraceId::load_raw(ik);\n+      if (!_classes_to_modify->contains(klass_id)) {\n+        jclass mirror = mirror_as_local_jni_handle(ik, _thread);\n+        _classes_to_modify->put(klass_id, mirror);\n+      }\n+    }\n+  }\n+}\n+\n+ClosureSet* JfrFilterClassClosure::to_modify() const {\n+  assert(_classes_to_modify != nullptr, \"invariant\");\n+  return _classes_to_modify;\n+}\n+\n+int JfrFilterClassClosure::number_of_classes() const {\n+  assert(_classes_to_modify != nullptr, \"invariant\");\n+  return _classes_to_modify->number_of_entries();\n+}\n+\n+void JfrFilterClassClosure::iterate_all_classes(GrowableArray<JfrInstrumentedClass>* instrumented_klasses) {\n+  assert(instrumented_klasses != nullptr, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+\n+  \/\/ First we process the instrumented_klasses list. The fact that a klass is on that list implies\n+  \/\/ it matched _some_ previous filter, but we don't know which one. The nice thing is we don't need to know,\n+  \/\/ because a klass has the STICKY_BIT set for those methods that matched _some_ previous filter.\n+  \/\/ We, therefore, put these klasses directly into the classes_to_modify set. We also need to do this\n+  \/\/ because some klasses on the instrumented_klasses list may not have reached the point of add_to_hierarchy yet.\n+  \/\/ For those klasses, the ClassLoaderDataGraph iterator would not deliver them on iteration.\n+\n+  if (instrumented_klasses->is_nonempty()) {\n+    for (int i = 0; i < instrumented_klasses->length(); ++i) {\n+      if (JfrKlassUnloading::is_unloaded(instrumented_klasses->at(i).trace_id())) {\n+        continue;\n+      }\n+      const InstanceKlass* const ik = instrumented_klasses->at(i).instance_klass();\n+      assert(ik != nullptr, \"invariant\");\n+      assert(ik->is_loader_alive(), \"invariant\");\n+      assert(JfrTraceId::has_sticky_bit(ik), \"invariant\");\n+      const traceid klass_id = JfrTraceId::load_raw(ik);\n+      assert(!_classes_to_modify->contains(klass_id), \"invariant\");\n+      jclass mirror = mirror_as_local_jni_handle(ik, _thread);\n+      _classes_to_modify->put(klass_id, mirror);\n+    }\n+  }\n+  ClassLoaderDataGraph::loaded_classes_do_keepalive(this);\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrClassFilterClosure.cpp","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTERCLASSCLOSURE_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTERCLASSCLOSURE_HPP\n+\n+#include \"jni.h\"\n+#include \"memory\/iterator.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp\"\n+#include \"jfr\/utilities\/jfrRelation.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+class JavaThread;\n+class JfrFilter;\n+class Klass;\n+\n+template<typename T> class GrowableArray;\n+\n+template<typename K, typename V,\n+         AnyObj::allocation_type, MemTag,\n+         unsigned (*HASH)  (K const&),\n+         bool (*EQUALS)(K const&, K const&)> class ResizeableResourceHashtable;\n+\n+\/\/ Knuth multiplicative hashing.\n+inline uint32_t knuth_hash(const traceid& id) {\n+  const uint32_t v = static_cast<uint32_t>(id);\n+  return v * UINT32_C(2654435761);\n+}\n+\n+typedef ResizeableResourceHashtable<traceid, jclass,\n+                                    AnyObj::RESOURCE_AREA,\n+                                    mtTracing,\n+                                    knuth_hash,\n+                                    equals_traceid> ClosureSet;\n+\n+\/\/\n+\/\/ Class that collects classes that should be retransformed,\n+\/\/ either for adding instrumentation by matching the current\n+\/\/ filter or for removing old instrumentation.\n+\/\/\n+class JfrFilterClassClosure : public KlassClosure {\n+ private:\n+  const JfrFilter* const _new_filter;\n+  ClosureSet* const _classes_to_modify;\n+  JavaThread* const _thread;\n+\n+  bool match(const InstanceKlass* klass) const;\n+  void do_klass(Klass* k);\n+\n+ public:\n+  JfrFilterClassClosure(JavaThread* thread);\n+  void iterate_all_classes(GrowableArray<JfrInstrumentedClass>* instrumented_klasses);\n+  \/\/ Returned set is Resource allocated.\n+  ClosureSet* to_modify() const;\n+  int number_of_classes() const;\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTERCLASSCLOSURE_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrClassFilterClosure.hpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,270 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/support\/jfrAnnotationIterator.hpp\"\n+#include \"jfr\/support\/jfrJdkJfrEvent.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilter.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logMessage.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/method.inline.hpp\"\n+#include \"oops\/symbol.hpp\"\n+\n+JfrFilter::JfrFilter(Symbol** class_names,\n+                     Symbol** method_names,\n+                     Symbol** annotation_names,\n+                     int* modifications,\n+                     int count) :\n+  _class_names(class_names),\n+  _method_names(method_names),\n+  _annotation_names(annotation_names),\n+  _modifications(modifications),\n+  _count(count) {}\n+\n+JfrFilter::~JfrFilter() {\n+  for (int i = 0; i < _count; i++) {\n+    Symbol::maybe_decrement_refcount(_class_names[i]);\n+    Symbol::maybe_decrement_refcount(_method_names[i]);\n+    Symbol::maybe_decrement_refcount(_annotation_names[i]);\n+  }\n+  FREE_C_HEAP_ARRAY(Symbol*, _class_names);\n+  FREE_C_HEAP_ARRAY(Symbol*, _method_names);\n+  FREE_C_HEAP_ARRAY(Symbol*, _annotation_names);\n+  FREE_C_HEAP_ARRAY(int, _modifications);\n+}\n+\n+bool JfrFilter::can_instrument_module(const ModuleEntry* module) const {\n+  if (module == nullptr) {\n+    return true;\n+  }\n+  const Symbol* name = module->name();\n+  if (name == nullptr) {\n+    return true;\n+  }\n+  if (name->equals(\"jdk.jfr\", 7)) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool JfrFilter::can_instrument_class(const InstanceKlass* ik) const {\n+  assert(ik != nullptr, \"invariant\");\n+  if (JfrTraceId::has_sticky_bit(ik)) {\n+    return true;\n+  }\n+  if (ik->is_hidden()) {\n+    return false;\n+  }\n+  if (JdkJfrEvent::is_a(ik)) {\n+    return false;\n+  }\n+  if (ik == vmClasses::Continuation_klass()) {\n+    return false;\n+  }\n+  return can_instrument_module(ik->module());\n+}\n+\n+\/\/ can_intrument(InstanceKlass*) is not called in this method\n+\/\/ to avoid executing the same code for every method in a class\n+bool JfrFilter::can_instrument_method(const Method* method) const {\n+  assert(method != nullptr, \"invariant\");\n+  if (JfrTraceId::has_sticky_bit(method)) {\n+    return true;\n+  }\n+  if (method->is_abstract()) {\n+    return false;\n+  }\n+  if (method->is_synthetic()) {\n+    return false;\n+  }\n+  if (method->is_native()) {\n+    return false;\n+  }\n+  if (method->is_compiled_lambda_form()) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool JfrFilter::match_annotations(const InstanceKlass* ik, AnnotationArray* annotations, const Symbol* symbol, bool log) const {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(symbol != nullptr, \"invariant\");\n+  if (annotations == nullptr) {\n+    return false;\n+  }\n+  JfrAnnotationIterator it(ik, annotations);\n+  while (it.has_next()) {\n+    it.move_to_next();\n+    const Symbol* current = it.type();\n+    bool equal = current == symbol;\n+    if (log && log_is_enabled(Trace, methodtrace)) {\n+      ResourceMark rm;\n+      log_trace(jfr, methodtrace)(\n+        \"match_annotations: Class %s has annotation %s %s\",\n+        ik->external_name(),\n+        current->as_C_string(),\n+        (equal ? \"true\" : \"false\")\n+        );\n+    }\n+    if (equal) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+int JfrFilter::combine_bits(int a, int b) {\n+  if (a == NONE) {\n+    return b;\n+  }\n+  if (b == NONE) {\n+    return a;\n+  }\n+  return a | b;\n+}\n+\n+int JfrFilter::class_modifications(const InstanceKlass* ik, bool log) const {\n+  assert(ik != nullptr, \"invariant\");\n+  AnnotationArray* class_annotations = ik->class_annotations();\n+  if (class_annotations == nullptr) {\n+    return NONE;\n+  }\n+  int result = NONE;\n+  for (int i = 0; i < _count; i++) {\n+    const Symbol* annotation_filter = _annotation_names[i];\n+    if (annotation_filter != nullptr && match_annotations(ik, class_annotations, annotation_filter, log)) {\n+      result = combine_bits(result, _modifications[i]);\n+      if (log && log_is_enabled(Trace, methodtrace)) {\n+        ResourceMark rm;\n+        log_trace(jfr, methodtrace)(\"Class_modifications: %s bits = %d\", ik->external_name(), result);\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+bool JfrFilter::match(const InstanceKlass* ik) const {\n+  assert(ik != nullptr, \"invariant\");\n+  if (class_modifications(ik, false) != NONE) {\n+    return true;\n+  }\n+  const Array<Method*>* methods = ik->methods();\n+  const int method_count = methods->length();\n+  for (int i = 0; i < method_count; i++) {\n+    if (method_modifications(methods->at(i)) != NONE) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+int JfrFilter::method_modifications(const Method* method) const {\n+  assert(method != nullptr, \"invariant\");\n+  InstanceKlass* klass = method->method_holder();\n+  int result = NONE;\n+  for (int i = 0; i < _count; i++) {\n+    Symbol* annotation_name = _annotation_names[i];\n+    if (annotation_name != nullptr) {\n+      if (match_annotations(klass, method->annotations(), annotation_name, false)) {\n+        result = combine_bits(result, _modifications[i]);\n+      }\n+    } else {\n+      Symbol* class_name = _class_names[i];\n+      if (class_name == nullptr || klass->name() == class_name) {\n+        Symbol* method_name = _method_names[i];\n+        if (method_name == nullptr || (method->name() == method_name && can_instrument_method(method))) {\n+          result = combine_bits(result, _modifications[i]);\n+        }\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+void JfrFilter::log(const char* caption) const {\n+  assert(caption != nullptr, \"invariant\");\n+  if (!log_is_enabled(Debug, jfr, methodtrace))  {\n+    return;\n+  }\n+  LogMessage(jfr,methodtrace) msg;\n+  msg.debug(\"%s = {\", caption);\n+  for (int i = 0; i < _count; i++) {\n+    const Symbol* m = _method_names[i];\n+    const Symbol* c = _class_names[i];\n+    const Symbol* a = _annotation_names[i];\n+    const char* modification = modification_to_text(_modifications[i]);\n+\n+    if (a != nullptr) {\n+      char annotation_buffer[100];\n+      a->as_klass_external_name(annotation_buffer, 100);\n+      size_t length = strlen(annotation_buffer);\n+      if (length > 2) {\n+        annotation_buffer[length - 1] = '\\0'; \/\/ remove trailing ';'\n+        msg.debug(\" @%s %s\", annotation_buffer + 1, modification); \/\/ Skip 'L'\n+      }\n+    } else {\n+      char class_buffer[100];\n+      if (c != nullptr) {\n+        c->as_klass_external_name(class_buffer, 100);\n+      } else {\n+        class_buffer[0] = '\\0';\n+      }\n+      if (m != nullptr) {\n+        char method_buffer[100];\n+        m->as_klass_external_name(method_buffer, 100);\n+        msg.debug(\" %s::%s %s\", class_buffer, method_buffer, modification);\n+      } else {\n+        msg.debug(\" %s %s\", class_buffer, modification);\n+      }\n+    }\n+  }\n+  msg.debug(\"}\");\n+}\n+\n+bool JfrFilter::is_timing(int modification) {\n+  return modification == NONE ? false : (modification & TIMING) != 0;\n+}\n+\n+bool JfrFilter::is_tracing(int modification) {\n+  return modification == NONE ? false : (modification & TRACING) != 0;\n+}\n+\n+const char* JfrFilter::modification_to_text(int modification) {\n+  switch (modification) {\n+  case 0:\n+    return \"-timing -tracing\";\n+  case TIMING:\n+    return \"+timing\";\n+  case TRACING:\n+    return \"+tracing\";\n+  case TIMING + TRACING:\n+    return \"+timing +tracing\";\n+  default:\n+    ShouldNotReachHere();\n+  };\n+  return \"unknown modification\";\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilter.cpp","additions":270,"deletions":0,"binary":false,"changes":270,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTER_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTER_HPP\n+\n+#include \"jni.h\"\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+#include \"oops\/annotations.hpp\"\n+\n+class InstanceKlass;\n+class JavaThread;\n+class Method;\n+class ModuleEntry;\n+class Symbol;\n+\n+\/\/\n+\/\/ Class that holds the configured filters.\n+\/\/\n+\/\/ For information on how they are configured,\n+\/\/ see jdk.jfr.internal.JVM::setMethodTraceFilters(...).\n+\/\/\n+class JfrFilter : public JfrCHeapObj {\n+  friend class JfrFilterManager;\n+ private:\n+  static constexpr int TIMING  = 1;\n+  static constexpr int TRACING = 2;\n+\n+  Symbol** _class_names;\n+  Symbol** _method_names;\n+  Symbol** _annotation_names;\n+  int*     _modifications;\n+  int      _count;\n+\n+  JfrFilter(Symbol** class_names,\n+            Symbol** method_names,\n+            Symbol** annotation_names,\n+            int* modifications,\n+            int count);\n+ public:\n+  ~JfrFilter();\n+  bool can_instrument_method(const Method* m) const;\n+  bool can_instrument_class(const InstanceKlass* m) const;\n+  bool can_instrument_module(const ModuleEntry* ik) const;\n+  int class_modifications(const InstanceKlass* klass, bool log) const;\n+  int method_modifications(const Method* method) const;\n+  bool match(const InstanceKlass* klass) const;\n+  bool match_annotations(const InstanceKlass* klass, AnnotationArray* annotation, const Symbol* symbol, bool log) const;\n+  void log(const char* caption) const;\n+\n+  static constexpr int NONE = -1;\n+  static bool is_timing(int modification);\n+  static bool is_tracing(int modification);\n+  static const char* modification_to_text(int modification);\n+  static int combine_bits(int a, int b);\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTER_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilter.hpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilter.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilterManager.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"oops\/typeArrayOop.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+const JfrFilter* JfrFilterManager::_current = nullptr;\n+\n+\/\/ Track the set of previous filters during a chunk \/ epoch.\n+static constexpr const int initial_array_size = 4;\n+static GrowableArray<const JfrFilter*>* _previous_filters_epoch_0 = nullptr;\n+static GrowableArray<const JfrFilter*>* _previous_filters_epoch_1 = nullptr;\n+\n+static GrowableArray<const JfrFilter*>* c_heap_allocate_array(int size = initial_array_size) {\n+  return new (mtTracing) GrowableArray<const JfrFilter*>(size, mtTracing);\n+}\n+\n+static GrowableArray<const JfrFilter*>* previous_filters_epoch_0() {\n+  if (_previous_filters_epoch_0 == nullptr) {\n+    _previous_filters_epoch_0 = c_heap_allocate_array(initial_array_size);\n+  }\n+  return _previous_filters_epoch_0;\n+}\n+\n+static GrowableArray<const JfrFilter*>* previous_filters_epoch_1() {\n+  if (_previous_filters_epoch_1 == nullptr) {\n+    _previous_filters_epoch_1 = c_heap_allocate_array(initial_array_size);\n+  }\n+  return _previous_filters_epoch_1;\n+}\n+\n+static GrowableArray<const JfrFilter*>* get_previous_filters(u1 epoch) {\n+  return epoch == 0 ? previous_filters_epoch_0() : previous_filters_epoch_1();\n+}\n+\n+static GrowableArray<const JfrFilter*>* get_previous_filters() {\n+  return get_previous_filters(JfrTraceIdEpoch::current());\n+}\n+\n+static GrowableArray<const JfrFilter*>* get_previous_filters_previous_epoch() {\n+  return get_previous_filters(JfrTraceIdEpoch::previous());\n+}\n+\n+static void add_previous_filter(const JfrFilter* previous_filter) {\n+  if (previous_filter != nullptr) {\n+    get_previous_filters()->append(previous_filter);\n+  }\n+}\n+\n+const JfrFilter* JfrFilterManager::current() {\n+  return Atomic::load_acquire(&_current);\n+}\n+\n+void JfrFilterManager::install(const JfrFilter* new_filter) {\n+  assert(new_filter != nullptr, \"invariant\");\n+  add_previous_filter(Atomic::xchg(&_current, new_filter));\n+  new_filter->log(\"New filter installed\");\n+}\n+\n+static void delete_filters(GrowableArray<const JfrFilter*>* filters) {\n+  assert(filters != nullptr, \"invariant\");\n+  for (int i = 0; i < filters->length(); ++i) {\n+    delete filters->at(i);\n+  }\n+  filters->clear();\n+}\n+\n+void JfrFilterManager::clear_previous_filters() {\n+  delete_filters(get_previous_filters_previous_epoch());\n+}\n+\n+bool JfrFilterManager::install(jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modification_array, JavaThread* jt) {\n+  assert(classes != nullptr, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n+  assert(annotations != nullptr, \"invariant\");\n+  assert(modification_array != nullptr, \"invariant\");\n+\n+  if (!JfrOptionSet::can_retransform()) {\n+    log_info(jfr, methodtrace)(\"Flight Recorder retransform has been set to false. New method filter is ignored.\");\n+    return false;\n+  }\n+\n+  intptr_t class_size = 0;\n+  Symbol** class_names = JfrJavaSupport::symbol_array(classes, jt, &class_size, true);\n+  assert(class_names != nullptr, \"invariant\");\n+\n+  intptr_t method_size = 0;\n+  Symbol** method_names = JfrJavaSupport::symbol_array(methods, jt, &method_size, true);\n+  assert(method_names != nullptr, \"invariant\");\n+\n+  intptr_t annotation_size = 0;\n+  Symbol** annotation_names = JfrJavaSupport::symbol_array(annotations, jt, &annotation_size, true);\n+  assert(annotation_names != nullptr, \"invariant\");\n+\n+  typeArrayOop ta = typeArrayOop(JfrJavaSupport::resolve_non_null(modification_array));\n+  const typeArrayHandle modification_tah(jt, ta);\n+  const int modification_size = modification_tah->length();\n+  int* const modifications = NEW_C_HEAP_ARRAY(int, modification_size, mtTracing);\n+  for (int i = 0; i < modification_size; i++) {\n+    modifications[i] = modification_tah->int_at(i);\n+  }\n+  if (class_size != method_size || class_size != annotation_size || class_size != modification_size) {\n+    FREE_C_HEAP_ARRAY(Symbol*, class_names);\n+    FREE_C_HEAP_ARRAY(Symbol*, method_names);\n+    FREE_C_HEAP_ARRAY(Symbol*, annotation_names);\n+    FREE_C_HEAP_ARRAY(int, modifications);\n+    JfrJavaSupport::throw_internal_error(\"Method array sizes don't match\", jt);\n+    return false;\n+  }\n+  const JfrFilter* const new_filter = new JfrFilter(class_names, method_names, annotation_names, modifications, modification_size);\n+  assert(new_filter != nullptr, \"invariant\");\n+  install(new_filter);\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilterManager.cpp","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTERMANAGER_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTERMANAGER_HPP\n+\n+#include \"jni.h\"\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+\n+class JfrFilter;\n+class JavaThread;\n+class Symbol;\n+\n+\/\/\n+\/\/ Class that manages memory for JfrFilter objects to ensure they\n+\/\/ are not deleted until we have transitioned to the next epoch, which ensures\n+\/\/ they are no longer in use.\n+\/\/\n+class JfrFilterManager : public AllStatic {\n+  friend class JfrMethodTracer;\n+ private:\n+  static const JfrFilter* _current;\n+  static void install(const JfrFilter* filter);\n+  static void clear_previous_filters();\n+\n+ public:\n+  static const JfrFilter* current();\n+  static bool install(jobjectArray classses,\n+                      jobjectArray methods,\n+                      jobjectArray annotations,\n+                      jintArray modifications,\n+                      JavaThread* jt);\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRFILTERMANAGER_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrFilterManager.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRINSTRUMENTEDCLASS_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRINSTRUMENTEDCLASS_HPP\n+\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+class InstanceKlass;\n+\n+\/\/\n+\/\/ Class that holds classes that are currently being instrumented and\n+\/\/ if the have been unloaded.\n+\/\/\n+class JfrInstrumentedClass {\n+ private:\n+  traceid              _trace_id;\n+  const InstanceKlass* _instance_klass;\n+  bool                 _unloaded;\n+\n+ public:\n+  JfrInstrumentedClass(traceid trace_id = 0, const InstanceKlass* instance_klass = nullptr, bool unloaded = false) :\n+    _trace_id(trace_id), _instance_klass(instance_klass), _unloaded(unloaded) {\n+  }\n+\n+  const InstanceKlass* instance_klass() const {\n+    return _instance_klass;\n+  }\n+\n+  traceid trace_id() const {\n+    return _trace_id;\n+  }\n+\n+  jlong trace_id_as_jlong() const {\n+    return static_cast<jlong>(_trace_id);\n+  }\n+\n+  void set_unloaded(bool unloaded) {\n+    _unloaded = unloaded;\n+  }\n+\n+  bool unloaded() const {\n+    return _unloaded;\n+  }\n+\n+  bool operator==(const JfrInstrumentedClass& rhs) {\n+    return _trace_id == rhs._trace_id;\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRINSTRUMENTEDCLASS_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilter.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilterManager.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrMethodProcessor.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+JfrMethodProcessor::JfrMethodProcessor(const InstanceKlass* ik, Thread* thread) :\n+  _klass(ik),\n+  _methods(nullptr),\n+  _thread(thread),\n+  _has_timing(false),\n+  _log(log_is_enabled(Debug, jfr, methodtrace)) {\n+    assert(ik != nullptr, \"invariant\");\n+    assert(Thread::current() == thread, \"invariant\");\n+    process();\n+}\n+\n+JfrMethodProcessor::~JfrMethodProcessor() {\n+  assert(_thread != nullptr, \"invariant\");\n+  if (_methods != nullptr) {\n+    \/\/ Removal of pushed metadata keep-alive entries.\n+    for (int i = 0; i < _methods->length(); ++i) {\n+      Method* const method = const_cast<Method*>(_methods->at(i).method());\n+      if (method != nullptr) {\n+        const int idx = _thread->metadata_handles()->find_from_end(method);\n+        assert(idx >= 0, \"invariant\");\n+        _thread->metadata_handles()->remove_at(idx);\n+      }\n+    }\n+  }\n+}\n+\n+void JfrMethodProcessor::update_methods(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(_methods != nullptr, \"invariant\");\n+  const Array<Method*>* const ik_methods = ik->methods();\n+  assert(ik_methods != nullptr, \"invariant\");\n+  for (int i = 0; i < _methods->length(); ++i) {\n+    const uint32_t idx = _methods->at(i).methods_array_index();\n+    Method* const method = ik_methods->at(idx);\n+    assert(method != nullptr, \"invariant\");\n+    _methods->at(i).set_method(method);\n+    \/\/ This is to keep the method from being unloaded during redefine \/ retransform.\n+    \/\/ Equivalent functionality to that provided by the methodHandle. Unfortunately,\n+    \/\/ we cannot use that directly because our handles would reside not on the stack\n+    \/\/ but in an Arena managed by a thread-local ResourceArea, which is not allowed.\n+    \/\/ Removal of pushed metadata entries happens in the destructor.\n+    _thread->metadata_handles()->push(method);\n+  }\n+}\n+\n+void JfrMethodProcessor::set_timing(int modification) {\n+  if (_has_timing) {\n+    return;\n+  }\n+  if (modification > 0 && (modification & 1)) {\n+    _has_timing = true;\n+  }\n+}\n+\n+\n+static void log(const Method* method, traceid id, int new_modification) {\n+  assert(method != nullptr, \"invariant\");\n+  const char* timing = JfrFilter::is_timing(new_modification) ? \"+timing\" : \"-timing\";\n+  const char* tracing = JfrFilter::is_tracing(new_modification) ? \"+tracing\" : \"-tracing\";\n+  stringStream param_stream;\n+  method->signature()->print_as_signature_external_parameters(&param_stream);\n+  const char* param_string = param_stream.as_string();\n+\n+  stringStream ss;\n+  ss.print(\"%s\", method->method_holder()->external_name());\n+  ss.print(\"::\");\n+  ss.print(\"%s\", method->name()->as_C_string());\n+  ss.print(\"(\");\n+  if (strlen(param_string) < 30) {\n+    ss.print(\"%s\", param_string);\n+  } else {\n+    ss.print(\"...\");\n+  }\n+  ss.print(\")\");\n+  log_debug(jfr, methodtrace)(\"Modify bytecode for %s %s %s (Method ID: \" UINT64_FORMAT_X \")\", ss.as_string(), timing, tracing, id);\n+}\n+\n+void JfrMethodProcessor::process() {\n+  const JfrFilter* const filter = JfrFilterManager::current();\n+  assert(filter != nullptr, \"invariant\");\n+  if (!filter->can_instrument_class(_klass)) {\n+    return;\n+  }\n+  const int class_modifications = filter->class_modifications(_klass, false);\n+  const Array<Method*>* const methods = _klass->methods();\n+  const int method_count = methods->length();\n+  for (int i = 0; i < method_count; i++) {\n+    const Method* const m = methods->at(i);\n+    assert(m != nullptr, \"invariant\");\n+    if (filter->can_instrument_method(m)) {\n+      const int new_modification = JfrFilter::combine_bits(class_modifications, filter->method_modifications(m));\n+      if (new_modification != JfrFilter::NONE || JfrTraceId::has_sticky_bit(m)) {\n+        \/\/ Allocate lazy, most classes will not match a filter\n+        if (_methods == nullptr) {\n+          _methods = new GrowableArray<JfrTracedMethod>();\n+        }\n+        set_timing(new_modification);\n+        const int modification = new_modification == JfrFilter::NONE ? 0 : new_modification;\n+        JfrTracedMethod traced_method(_klass, m, modification, i);\n+        _methods->append(traced_method);\n+        if (_log) {\n+          log(m, traced_method.id(), modification);\n+        }\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodProcessor.cpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODPROCESSOR_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODPROCESSOR_HPP\n+\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n+#include \"memory\/allocation.hpp\"\n+\n+class InstanceKlass;\n+class JfrFilter;\n+class Thread;\n+\n+template <typename> class GrowableArray;\n+\n+\/\/\n+\/\/ Class responsible for determining which methods in an InstanceKlass\n+\/\/ that should be instrumented and tagged.\n+\/\/\n+class JfrMethodProcessor: public StackObj {\n+ private:\n+  const InstanceKlass* const      _klass;\n+  GrowableArray<JfrTracedMethod>* _methods;\n+  Thread*                         _thread;\n+  bool                            _has_timing;\n+  bool                            _log;\n+\n+  void set_timing(int modification);\n+  void process();\n+\n+ public:\n+  JfrMethodProcessor(const InstanceKlass* klass, Thread* thread);\n+  ~JfrMethodProcessor();\n+\n+  bool has_methods() const {\n+    return _methods != nullptr;\n+  }\n+\n+  const GrowableArray<JfrTracedMethod>* methods() const {\n+    return _methods;\n+  }\n+\n+  GrowableArray<JfrTracedMethod>* methods() {\n+    return _methods;\n+  }\n+\n+  void update_methods(const InstanceKlass* ik);\n+\n+  bool has_timing() const {\n+    return _has_timing;\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODPROCESSOR_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodProcessor.hpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,411 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/classFileParser.hpp\"\n+#include \"classfile\/classFileStream.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/modules.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"jfr\/instrumentation\/jfrClassTransformer.hpp\"\n+#include \"jfr\/instrumentation\/jfrJvmtiAgent.hpp\"\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/jni\/jfrUpcalls.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#include \"jfr\/support\/jfrKlassUnloading.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrClassFilterClosure.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilter.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrFilterManager.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrMethodProcessor.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrMethodTracer.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrTraceTagging.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n+\n+ModuleEntry*                         JfrMethodTracer::_jdk_jfr_module = nullptr;\n+GrowableArray<JfrInstrumentedClass>* JfrMethodTracer::_instrumented_classes = nullptr;\n+GrowableArray<jlong>*                JfrMethodTracer::_timing_entries = nullptr;\n+\n+\/\/ Quick and unlocked check to see if the Method Tracer has been activated.\n+\/\/ This is flipped to not null the first time a filter is set and will stay non-null forever.\n+bool JfrMethodTracer::in_use() {\n+  return JfrFilterManager::current() != nullptr;\n+}\n+\n+static void clear(GrowableArray<JfrInstrumentedClass>* instrumented_classes) {\n+  assert(instrumented_classes != nullptr, \"invariant\");\n+  if (instrumented_classes->is_nonempty()) {\n+    instrumented_classes->clear();\n+    JfrTraceIdEpoch::reset_method_tracer_tag_state();\n+  }\n+}\n+\n+jlongArray JfrMethodTracer::set_filters(JNIEnv* env, jobjectArray classes, jobjectArray methods, jobjectArray annotations, jintArray modifications, TRAPS) {\n+  assert(env != nullptr, \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD));\n+\n+  \/\/ This operation, if successful, atomically installs a JfrFilter object to represent all passed in filters.\n+  if (!JfrFilterManager::install(classes, methods, annotations, modifications, THREAD)) {\n+    return nullptr;\n+  }\n+\n+  ResourceMark rm(THREAD);\n+  JfrFilterClassClosure filter_class_closure(THREAD);\n+  {\n+    MutexLocker lock(ClassLoaderDataGraph_lock);\n+    filter_class_closure.iterate_all_classes(instrumented_classes());\n+    ::clear(instrumented_classes());\n+  }\n+  retransform(env, filter_class_closure, THREAD);\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+  if (_timing_entries->is_empty()) {\n+    return nullptr;\n+  }\n+  jlongArray array = JfrJavaSupport::create_long_array(_timing_entries, THREAD);\n+  _timing_entries->clear();\n+  return array;\n+}\n+\n+class MirrorClosure {\n+ private:\n+  jclass* const _classes;\n+  int _size;\n+  int _idx;\n+ public:\n+  MirrorClosure(int size) : _classes(NEW_RESOURCE_ARRAY(jclass, size)), _size(size), _idx(0) {}\n+\n+  jclass* classes() const {\n+    return _classes;\n+  }\n+\n+  bool operator()(const traceid& key, const jclass& mirror) {\n+    assert(_classes != nullptr, \"invariant\");\n+    assert(_idx < _size, \"invariant\");\n+    _classes[_idx++] = mirror;\n+    return true;\n+  }\n+};\n+\n+void JfrMethodTracer::retransform(JNIEnv* env, const JfrFilterClassClosure& classes, TRAPS) {\n+  log_debug(jfr, methodtrace)(\"Issuing Retransform Classes\");\n+  const int class_count = classes.number_of_classes();\n+  if (class_count > 0) {\n+    ThreadToNativeFromVM transition(THREAD);\n+    const MirrorClosure closure(class_count);\n+    classes.to_modify()->iterate_all(closure);\n+    JfrJvmtiAgent::retransform_classes(env, closure.classes(), class_count, THREAD);\n+  }\n+}\n+\n+static void handle_no_bytecode_result(const Klass* klass) {\n+  assert(klass != nullptr, \"invariant\");\n+  if (JfrTraceId::has_sticky_bit(klass)) {\n+    MutexLocker lock(ClassLoaderDataGraph_lock);\n+    JfrTraceTagging::clear_sticky_bit(InstanceKlass::cast(klass));\n+  }\n+}\n+\n+void JfrMethodTracer::on_klass_creation(InstanceKlass*& ik, ClassFileParser& parser, TRAPS) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(in_use(), \"invariant\");\n+\n+  ResourceMark rm(THREAD);\n+\n+  \/\/ 1. Is the ik the initial load, i.e.the first InstanceKlass, or a scratch klass, denoting a redefine \/ retransform?\n+  const Klass* const existing_klass = JfrClassTransformer::find_existing_klass(ik, THREAD);\n+  const bool is_retransform = existing_klass != nullptr;\n+\n+  \/\/ 2. Test the ik and its methods against the currently installed filter object.\n+  JfrMethodProcessor mp(is_retransform ? InstanceKlass::cast(existing_klass) : ik, THREAD);\n+  if (!mp.has_methods()) {\n+    return;\n+  }\n+\n+  \/\/ 3. We matched one or serveral filters. Now construct a new bytecode representation with instrumented methods in accordance with matched instructions.\n+  const ClassFileStream* clone = parser.clone_stream();\n+  ClassFileStream* const result = JfrUpcalls::on_method_trace(ik, clone, mp.methods(), THREAD);\n+  if (result == nullptr) {\n+    \/\/ If no bytecode is returned, either an error occurred during transformation, but more\n+    \/\/ likely the matched instructions were negative, i.e. instructions to remove existing instrumentation\n+    \/\/ and so Java added no new instrumentation. By not returning a bytecode result, the klass is restored to its original, non-instrumented, version.\n+    handle_no_bytecode_result(is_retransform ? InstanceKlass::cast(existing_klass) : ik);\n+    return;\n+  }\n+  \/\/ 4. Now create a new InstanceKlass representation from the modified bytecode.\n+  InstanceKlass* const new_ik = JfrClassTransformer::create_instance_klass(ik, result, !is_retransform, THREAD);\n+  if (new_ik == nullptr) {\n+    return;\n+  }\n+  \/\/ 5. Replace the passed in ik with the newly constructed, new_ik.\n+  JfrClassTransformer::copy_traceid(ik, new_ik); \/\/ copy existing traceid\n+  if (is_retransform) {\n+    \/\/ Keep the original cached class file data from the existing class.\n+    JfrClassTransformer::transfer_cached_class_file_data(ik, new_ik, parser, THREAD);\n+    JfrClassTransformer::rewrite_klass_pointer(ik, new_ik, parser, THREAD); \/\/ The ik is modified to point to new_ik here.\n+    const InstanceKlass* const existing_ik = InstanceKlass::cast(existing_klass);\n+    mp.update_methods(existing_ik);\n+    existing_ik->module()->add_read(jdk_jfr_module());\n+    \/\/ By setting the sticky bit on the existng klass, we receive a callback into on_klass_redefinition (see below)\n+    \/\/ when our new methods are installed into the existing klass as part of retransformation \/ redefinition.\n+    \/\/ Only when we know our new methods have been installed can we add the klass to the instrumented list (done as part of callback).\n+    JfrTraceTagging::install_sticky_bit_for_retransform_klass(existing_ik, mp.methods(), mp.has_timing());\n+    return;\n+  }\n+  \/\/ Initial class load.\n+  JfrClassTransformer::cache_class_file_data(new_ik, clone, THREAD); \/\/ save the initial class file bytes (clone stream)\n+  JfrClassTransformer::rewrite_klass_pointer(ik, new_ik, parser, THREAD); \/\/ The ik is modified to point to new_ik here.\n+  mp.update_methods(ik);\n+  \/\/ On initial class load the newly created klass can be installed into the instrumented class list directly.\n+  add_instrumented_class(ik, mp.methods());\n+  if (mp.has_timing()) {\n+    \/\/ After having installed the newly created klass into the list, perform an upcall to publish the associated TimedClass.\n+    JfrUpcalls::publish_method_timers_for_klass(JfrTraceId::load_raw(ik), THREAD);\n+  }\n+}\n+\n+static inline void log_add(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  if (log_is_enabled(Debug, jfr, methodtrace)) {\n+    ResourceMark rm;\n+    const traceid klass_id = JfrTraceId::load_raw(ik);\n+    log_debug(jfr, methodtrace)(\"Adding class %s to instrumented list (Klass ID: \" UINT64_FORMAT_X \")\", ik->external_name(), klass_id);\n+  }\n+}\n+\n+void JfrMethodTracer::add_timing_entry(const InstanceKlass* ik, traceid klass_id) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(_timing_entries != nullptr, \"invariant\");\n+  if (JfrTraceId::has_timing_bit(ik)) {\n+    JfrTraceId::clear_timing_bit(ik);\n+    _timing_entries->append(klass_id);\n+  }\n+}\n+\n+\/\/ At this point we have installed our new retransformed methods into the original klass, which is ik.\n+\/\/ jvmtiRedefineClassses::redefine_single_class() has finished so we are still at a safepoint.\n+\/\/ If the original klass is not already in the list, add it and also dynamically tag all\n+\/\/ artifacts that have the sticky bit set. If the klass has an associated TimedClass,\n+\/\/ also add the klass to the list of _timing_entries for publication.\n+void JfrMethodTracer::on_klass_redefinition(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invarint\");\n+  assert(ik->has_been_redefined(), \"invariant\");\n+  assert(JfrTraceId::has_sticky_bit(ik), \"invariant\");\n+  assert(in_use(), \"invariant\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+\n+  const traceid klass_id = JfrTraceId::load_raw(ik);\n+  const JfrInstrumentedClass jic(klass_id, ik, false);\n+\n+  if (instrumented_classes()->find(jic) == -1) { \/\/ not already existing\n+    const int idx = instrumented_classes()->append(jic);\n+    if (idx == 0) {\n+      assert(!JfrTraceIdEpoch::has_method_tracer_changed_tag_state(), \"invariant\");\n+      JfrTraceIdEpoch::set_method_tracer_tag_state();\n+    }\n+    add_timing_entry(ik, klass_id);\n+    JfrTraceTagging::set_dynamic_tag_for_sticky_bit(ik);\n+    log_add(ik);\n+  }\n+}\n+\n+#ifdef ASSERT\n+static bool in_instrumented_list(const InstanceKlass* ik, const GrowableArray<JfrInstrumentedClass>* list) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(list != nullptr, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  const JfrInstrumentedClass jic(JfrTraceId::load_raw(ik), ik, false);\n+  return list->find(jic) != -1;\n+}\n+#endif\n+\n+void JfrMethodTracer::add_instrumented_class(InstanceKlass* ik, GrowableArray<JfrTracedMethod>* methods) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+  assert(methods->is_nonempty(), \"invariant\");\n+  ik->module()->add_read(jdk_jfr_module());\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+  assert(!in_instrumented_list(ik, instrumented_classes()), \"invariant\");\n+  JfrTraceTagging::set_dynamic_tag(ik, methods);\n+  JfrTraceTagging::set_sticky_bit(ik, methods);\n+  const JfrInstrumentedClass jik(JfrTraceId::load_raw(ik), ik, false);\n+  const int idx = instrumented_classes()->append(jik);\n+  if (idx == 0) {\n+    JfrTraceIdEpoch::set_method_tracer_tag_state();\n+  }\n+  assert(in_instrumented_list(ik, instrumented_classes()), \"invariant\");\n+  log_add(ik);\n+}\n+\n+ModuleEntry* JfrMethodTracer::jdk_jfr_module() {\n+  if (_jdk_jfr_module == nullptr) {\n+    MutexLocker ml(Module_lock);\n+    ModuleEntryTable* const table = Modules::get_module_entry_table(Handle());\n+    Symbol* jfr_module_name = SymbolTable::probe(\"jdk.jfr\", 7);\n+    assert(jfr_module_name != nullptr, \"jdk.jfr name could not be found\");\n+    _jdk_jfr_module = table->lookup_only(jfr_module_name);\n+    assert(_jdk_jfr_module != nullptr, \"jdk.jfr module could not be found\");\n+  }\n+  return _jdk_jfr_module;\n+}\n+\n+\/\/ Track the set of unloaded class ids during a chunk \/ epoch.\n+static GrowableArray<jlong>* _unloaded_class_ids_0 = nullptr;\n+static GrowableArray<jlong>* _unloaded_class_ids_1 = nullptr;\n+static GrowableArray<jlong>* _current_unloaded_class_ids = nullptr;\n+static GrowableArray<jlong>* _stale_class_ids = nullptr;\n+static GrowableArray<jlong>* _empty_class_ids = nullptr;\n+\n+jlongArray JfrMethodTracer::drain_stale_class_ids(TRAPS) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(THREAD);)\n+  if (!in_use()) {\n+    return nullptr;\n+  }\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+  assert(_stale_class_ids != nullptr, \"invariant\");\n+  if (_stale_class_ids == _empty_class_ids) {\n+    return nullptr;\n+  }\n+  assert(_stale_class_ids != _empty_class_ids, \"invariant\");\n+  assert(_stale_class_ids->is_nonempty(), \"invariant\");\n+  jlongArray array = JfrJavaSupport::create_long_array(_stale_class_ids, THREAD);\n+  _stale_class_ids->clear();\n+  assert(_stale_class_ids->is_empty(), \"invariant\");\n+  _stale_class_ids = _empty_class_ids;\n+  return array;\n+}\n+\n+static constexpr const int initial_array_size = 256;\n+\n+static GrowableArray<jlong>* c_heap_allocate_array(int size = initial_array_size) {\n+  return new (mtTracing) GrowableArray<jlong>(size, mtTracing);\n+}\n+\n+static GrowableArray<jlong>* unloaded_class_ids_0() {\n+  if (_unloaded_class_ids_0 == nullptr) {\n+    _unloaded_class_ids_0 = c_heap_allocate_array(initial_array_size);\n+  }\n+  return _unloaded_class_ids_0;\n+}\n+\n+static GrowableArray<jlong>* unloaded_class_ids_1() {\n+  if (_unloaded_class_ids_1 == nullptr) {\n+    _unloaded_class_ids_1 = c_heap_allocate_array(initial_array_size);\n+  }\n+  return _unloaded_class_ids_1;\n+}\n+\n+GrowableArray<JfrInstrumentedClass>* JfrMethodTracer::instrumented_classes() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  if (_instrumented_classes == nullptr) {\n+    _instrumented_classes = new (mtTracing) GrowableArray<JfrInstrumentedClass>(256, mtTracing);\n+    _empty_class_ids = new (mtTracing) GrowableArray<jlong>(0, mtTracing);\n+    _stale_class_ids = _empty_class_ids;\n+    _current_unloaded_class_ids = unloaded_class_ids_0();\n+    _timing_entries = new (mtTracing) GrowableArray<jlong>(256, mtTracing);\n+  }\n+  return _instrumented_classes;\n+}\n+\n+\/\/ Invoked from JfrTypeSet on class unloading of sticky bit-tagged classes.\n+void JfrMethodTracer::add_to_unloaded_set(const Klass* k) {\n+  assert(k != nullptr, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(JfrTraceId::has_sticky_bit(k), \"invariant\");\n+  assert(_current_unloaded_class_ids != nullptr, \"invariant\");\n+  assert(_current_unloaded_class_ids->find(JfrTraceId::load_raw(k)) == -1, \"invariant\");\n+  _current_unloaded_class_ids->append(static_cast<jlong>(JfrTraceId::load_raw(k)));\n+}\n+\n+\/\/ Invoked from JfrTypeSet after having finalized rotation.\n+void JfrMethodTracer::trim_instrumented_classes(bool trim) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  if (trim) {\n+    GrowableArray<JfrInstrumentedClass>* trimmed_classes = new (mtTracing) GrowableArray<JfrInstrumentedClass>(256, mtTracing);\n+    for (int i = 0; i < _instrumented_classes->length(); i++) {\n+      const JfrInstrumentedClass& jic = _instrumented_classes->at(i);\n+      if (jic.unloaded()) {\n+        assert(JfrKlassUnloading::is_unloaded(jic.trace_id(), true), \"invariant\");\n+        assert(_stale_class_ids->find(jic.trace_id()) != -1 || _current_unloaded_class_ids->find(jic.trace_id()) != -1, \"invariant\");\n+        continue;\n+      }\n+      trimmed_classes->append(jic);\n+    }\n+    delete _instrumented_classes;\n+    _instrumented_classes = trimmed_classes;\n+  }\n+\n+  if (instrumented_classes()->is_nonempty()) {\n+    if (!JfrTraceIdEpoch::has_method_tracer_changed_tag_state()) {\n+      \/\/ Turn the tag state back on for next chunk.\n+      JfrTraceIdEpoch::set_method_tracer_tag_state();\n+    }\n+  }\n+\n+  \/\/ Clearing out filters that were used during the previous epoch.\n+  JfrFilterManager::clear_previous_filters();\n+\n+  \/\/ Tracking unloading of sticky bit-tagged classes.\n+  \/\/\n+  \/\/ We want to delay publishing an unloaded class until the very last moment.\n+  \/\/ Because of our tagging scheme, writing events for classes that have unloaded\n+  \/\/ is okay under the invariant that events are written in the same epoch during\n+  \/\/ which the class unloaded. We save classes that unloaded during an epoch and\n+  \/\/ publish them upon epoch rotation.\n+  \/\/\n+  \/\/ Precautions are necessary because of complexities involving physical recording start\/stop,\n+  \/\/ where we must be careful not to rotate away saved unloaded class IDs before they have been drained.\n+  if (_stale_class_ids == _empty_class_ids) {\n+    if (_current_unloaded_class_ids->is_nonempty()) {\n+      \/\/ Since we have rotated, we publicize the list of classes unloaded during the previous epoch.\n+      log_debug(jfr, methodtrace)(\"Since we have rotated, we publicize the list of classes unloaded during the previous epoch.\");\n+      _stale_class_ids = _current_unloaded_class_ids;\n+      \/\/ Rotating the sets for tracking the unloaded class ids.\n+      _current_unloaded_class_ids = _current_unloaded_class_ids == unloaded_class_ids_0() ? unloaded_class_ids_1() : unloaded_class_ids_0();\n+    }\n+    return;\n+  }\n+\n+  \/\/ The previously published unloaded classes are yet to be drained.\n+  \/\/ Most likely because we are now starting a new physical recording.\n+  \/\/ Move over all newly unloaded class IDs to make them available for drainage.\n+  assert(_stale_class_ids != _current_unloaded_class_ids, \"invariant\");\n+  if (_current_unloaded_class_ids->is_nonempty()) {\n+    log_debug(jfr, methodtrace)(\"Appending unloaded classes during the previous epoch.\");\n+    _stale_class_ids->appendAll(_current_unloaded_class_ids);\n+    _current_unloaded_class_ids->clear();\n+  }\n+  assert(_current_unloaded_class_ids->is_empty(), \"invariant\");\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodTracer.cpp","additions":411,"deletions":0,"binary":false,"changes":411,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODTRACER_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODTRACER_HPP\n+\n+#include \"jni.h\"\n+#include \"jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"memory\/allocation.hpp\"\n+\n+class ClassFileParser;\n+class InstanceKlass;\n+class JavaThread;\n+class JfrFilterClassClosure;\n+class Klass;\n+class ModuleEntry;\n+\n+template <typename E> class GrowableArray;\n+\n+\/\/\n+\/\/ Class responsible for installing and evaluating filters, collecting methods to\n+\/\/ be instrumented and calling Java to create the appropriate bytecode.\n+\/\/\/\n+class JfrMethodTracer: AllStatic {\n+ private:\n+  static ModuleEntry*                         _jdk_jfr_module;          \/\/ Guarded by Module_lock\n+  static GrowableArray<JfrInstrumentedClass>* _instrumented_classes;    \/\/ Guarded by ClassLoaderDataGraph_lock\n+  static GrowableArray<jlong>*                _timing_entries;          \/\/ Guarded by ClassLoaderDataGraph_lock\n+\n+  static ModuleEntry* jdk_jfr_module();\n+  static void add_timing_entry(const InstanceKlass* ik, traceid klass_id);\n+  static void retransform(JNIEnv* env, const JfrFilterClassClosure& classes, TRAPS);\n+  static void add_instrumented_class(InstanceKlass* ik, GrowableArray<JfrTracedMethod>* methods);\n+\n+ public:\n+  static bool in_use();\n+  static jlongArray drain_stale_class_ids(TRAPS);\n+  static void add_to_unloaded_set(const Klass* k);\n+  static void trim_instrumented_classes(bool trim);\n+  static GrowableArray<JfrInstrumentedClass>* instrumented_classes();\n+  static void on_klass_redefinition(const InstanceKlass* ik, Thread* thread);\n+  static void on_klass_creation(InstanceKlass*& ik, ClassFileParser& parser, TRAPS);\n+  static jlongArray set_filters(JNIEnv* env,\n+                                jobjectArray classes,\n+                                jobjectArray methods,\n+                                jobjectArray annotations,\n+                                jintArray modifications,\n+                                TRAPS);\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRMETHODTRACER_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrMethodTracer.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrInstrumentedClass.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrTraceTagging.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+void JfrTraceTagging::tag_dynamic(const InstanceKlass* ik) {\n+  JfrTraceIdLoadBarrier::load_barrier(ik);\n+}\n+\n+void JfrTraceTagging::tag_dynamic(const Method* method) {\n+  JfrTraceId::load_no_enqueue(method);\n+}\n+\n+void JfrTraceTagging::tag_dynamic(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n+\n+  for (int i = 0; i < methods->length(); ++i) {\n+    const Method* const method = methods->at(i).method();\n+    assert(method != nullptr, \"invariant\");\n+    if (!method->is_old()) {\n+      tag_dynamic(method);\n+      continue;\n+    }\n+    \/\/ A redefinition \/ retransformation interleaved.\n+    \/\/ Find and tag the latest version of the method.\n+    tag_dynamic(ik->method_with_orig_idnum(method->orig_method_idnum()));\n+  }\n+}\n+\n+void JfrTraceTagging::set_dynamic_tag(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+\n+  tag_dynamic(ik, methods);\n+  tag_dynamic(ik);\n+}\n+\n+void JfrTraceTagging::set_dynamic_tag_for_sticky_bit(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+  assert(JfrTraceId::has_sticky_bit(ik), \"invariant\");\n+\n+  const int length = ik->methods()->length();\n+  for (int i = 0; i < length; ++i) {\n+    const Method* const m = ik->methods()->at(i);\n+    if (JfrTraceId::has_sticky_bit(m)) {\n+      tag_dynamic(m);\n+    }\n+  }\n+  tag_dynamic(ik);\n+}\n+\n+void JfrTraceTagging::tag_sticky(const InstanceKlass* ik) {\n+  JfrTraceId::set_sticky_bit(ik);\n+}\n+\n+void JfrTraceTagging::tag_sticky(const Method* method) {\n+  JfrTraceId::set_sticky_bit(method);\n+}\n+\n+void JfrTraceTagging::tag_sticky(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n+\n+  for (int i = 0; i < methods->length(); ++i) {\n+    const Method* const method = methods->at(i).method();\n+    assert(method != nullptr, \"invariant\");\n+    if (!method->is_old()) {\n+      tag_sticky(method);\n+      continue;\n+    }\n+    \/\/ A redefinition \/ retransformation interleaved.\n+    \/\/ Find and tag the latest version of the method.\n+    tag_sticky(ik->method_with_orig_idnum(method->orig_method_idnum()));\n+  }\n+}\n+\n+void JfrTraceTagging::tag_timing(const InstanceKlass* ik) {\n+  JfrTraceId::set_timing_bit(ik);\n+}\n+\n+void JfrTraceTagging::install_sticky_bit_for_retransform_klass(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods, bool timing) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+  if (JfrTraceId::has_sticky_bit(ik)) {\n+    clear_sticky_bit(ik);\n+  }\n+  tag_sticky(ik, methods);\n+  tag_sticky(ik);\n+  if (timing) {\n+    tag_timing(ik);\n+  }\n+}\n+\n+void JfrTraceTagging::set_sticky_bit(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+\n+  tag_sticky(ik, methods);\n+  tag_sticky(ik);\n+}\n+\n+void JfrTraceTagging::clear_sticky_bit(const InstanceKlass* ik, bool dynamic_tag \/* true *\/) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(!ik->is_scratch_class(), \"invariant\");\n+  assert(JfrTraceId::has_sticky_bit(ik), \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+\n+  const Array<Method*>* const methods = ik->methods();\n+  assert(methods != nullptr, \"invariant\");\n+  const int length = methods->length();\n+  for (int i = 0; i < length; ++i) {\n+    const Method* const m = methods->at(i);\n+    if (JfrTraceId::has_sticky_bit(m)) {\n+      if (dynamic_tag) {\n+        tag_dynamic(m);\n+      }\n+      JfrTraceId::clear_sticky_bit(m);\n+    }\n+  }\n+  if (dynamic_tag) {\n+    tag_dynamic(ik);\n+  }\n+  JfrTraceId::clear_sticky_bit(ik);\n+  if (JfrTraceId::has_timing_bit(ik)) {\n+    JfrTraceId::clear_timing_bit(ik);\n+  }\n+  assert(!JfrTraceId::has_timing_bit(ik), \"invariant\");\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrTraceTagging.cpp","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACETAGGING_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACETAGGING_HPP\n+\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+\n+class InstanceKlass;\n+class Method;\n+\n+template <typename E> class GrowableArray;\n+\n+\/\/\n+\/\/ Class responsible for setting setting sticky, epoch, and timing bits.\n+\/\/\n+class JfrTraceTagging : AllStatic {\n+ private:\n+  static void tag_dynamic(const InstanceKlass* ik);\n+  static void tag_dynamic(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n+  static void tag_dynamic(const Method* method);\n+  static void tag_sticky(const InstanceKlass* ik);\n+  static void tag_sticky(const Method* method);\n+  static void tag_sticky(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n+  static void tag_timing(const InstanceKlass* ik);\n+ public:\n+  static void set_dynamic_tag(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n+  static void set_dynamic_tag_for_sticky_bit(const InstanceKlass* ik);\n+  static void install_sticky_bit_for_retransform_klass(const InstanceKlass* existing_klass, const GrowableArray<JfrTracedMethod>* methods, bool timing);\n+  static void set_sticky_bit(const InstanceKlass* ik, const GrowableArray<JfrTracedMethod>* methods);\n+  static void clear_sticky_bit(const InstanceKlass* ik, bool dynamic_tag = true);\n+};\n+\n+#endif \/* SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACETAGGING_HPP *\/\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrTraceTagging.hpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/support\/methodtracer\/jfrTracedMethod.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/method.hpp\"\n+\n+JfrTracedMethod::JfrTracedMethod() :\n+  _id(0), _name(nullptr), _signature(nullptr),\n+  _method(nullptr), _modification(0), _methods_array_index(0) {\n+}\n+\n+JfrTracedMethod::JfrTracedMethod(const InstanceKlass* ik,\n+                                 const Method* method,\n+                                 int32_t modification,\n+                                 int32_t methods_array_index) :\n+  _id(JfrTraceId::load_raw(ik, method)), _name(method->name()),\n+  _signature(method->signature()), _method(nullptr),\n+  _modification(modification), _methods_array_index(methods_array_index) {\n+  assert(_method == nullptr, \"invariant\");\n+}\n+\n+void JfrTracedMethod::set_method(const Method* method) {\n+  assert(method != nullptr, \"invariant\");\n+  assert(JfrTraceId::load_raw(method) == _id, \"invariant\");\n+  assert(_method == nullptr, \"invariant\");\n+  _method = method;\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrTracedMethod.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACEDMETHOD_HPP\n+#define SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACEDMETHOD_HPP\n+\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+class InstanceKlass;\n+class Method;\n+class Symbol;\n+\n+\/\/\n+\/\/ Method that has been filtered out for tracing,\n+\/\/ may or may not yet be instrumented.\n+\/\/\n+class JfrTracedMethod {\n+ private:\n+  traceid       _id;\n+  const Symbol* _name;\n+  const Symbol* _signature;\n+  const Method* _method;\n+  int32_t       _modification;\n+  int32_t       _methods_array_index;\n+\n+ public:\n+  JfrTracedMethod();\n+  JfrTracedMethod(const InstanceKlass* ik,\n+                  const Method* method,\n+                  int32_t modification,\n+                  int32_t methods_array_index);\n+\n+  traceid id() const {\n+    return _id;\n+  }\n+\n+  const Symbol* name() const {\n+    return _name;\n+  }\n+\n+  const Symbol* signature() const {\n+    return _signature;\n+  }\n+\n+  const Method* method() const {\n+    return _method;\n+  }\n+\n+  void set_method(const Method* method);\n+\n+  int32_t modification() const {\n+    return _modification;\n+  }\n+\n+  int32_t methods_array_index() const {\n+    return _methods_array_index;\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_METHODTRACER_JFRTRACEDMETHOD_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/methodtracer\/jfrTracedMethod.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -65,1 +65,2 @@\n-  JFR_LOG_TAG(jfr, start)\n+  JFR_LOG_TAG(jfr, start) \\\n+  JFR_LOG_TAG(jfr, methodtrace)\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLogTagSets.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+inline bool equals_traceid(const traceid& lhs, const traceid& rhs) {\n+  return lhs == rhs;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrRelation.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,1 @@\n+  LOG_TAG(methodtrace) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2960,2 +2960,2 @@\n-InstanceKlass* InstanceKlass::get_klass_version(int version) {\n-  for (InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n+const InstanceKlass* InstanceKlass::get_klass_version(int version) const {\n+  for (const InstanceKlass* ik = this; ik != nullptr; ik = ik->previous_versions()) {\n@@ -4459,1 +4459,1 @@\n-Method* InstanceKlass::method_with_idnum(int idnum) {\n+Method* InstanceKlass::method_with_idnum(int idnum) const {\n@@ -4478,1 +4478,1 @@\n-Method* InstanceKlass::method_with_orig_idnum(int idnum) {\n+Method* InstanceKlass::method_with_orig_idnum(int idnum) const {\n@@ -4498,2 +4498,2 @@\n-Method* InstanceKlass::method_with_orig_idnum(int idnum, int version) {\n-  InstanceKlass* holder = get_klass_version(version);\n+Method* InstanceKlass::method_with_orig_idnum(int idnum, int version) const {\n+  const InstanceKlass* holder = get_klass_version(version);\n@@ -4503,2 +4503,1 @@\n-  Method* method = holder->method_with_orig_idnum(idnum);\n-  return method;\n+  return holder->method_with_orig_idnum(idnum);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -352,3 +352,3 @@\n-  Method* method_with_idnum(int idnum);\n-  Method* method_with_orig_idnum(int idnum);\n-  Method* method_with_orig_idnum(int idnum, int version);\n+  Method* method_with_idnum(int idnum) const;\n+  Method* method_with_orig_idnum(int idnum) const;\n+  Method* method_with_orig_idnum(int idnum, int version) const;\n@@ -691,1 +691,1 @@\n-  InstanceKlass* get_klass_version(int version);\n+  const InstanceKlass* get_klass_version(int version) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4389,0 +4389,2 @@\n+  JFR_ONLY(ON_KLASS_REDEFINITION(the_class, current);)\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.Timespan;\n+import jdk.jfr.internal.RemoveFields;\n+\n+@Name(\"jdk.MethodTiming\")\n+@Label(\"Method Timing\")\n+@Category({ \"Java Virtual Machine\", \"Method Tracing\" })\n+@RemoveFields({ \"duration\", \"eventThread\", \"stackTrace\" })\n+public final class MethodTimingEvent extends AbstractJDKEvent {\n+\n+    @Label(\"Method\")\n+    public long method;\n+\n+    @Label(\"Invocations\")\n+    public long invocations;\n+\n+    @Label(\"Average Time\")\n+    @Timespan\n+    public long average;\n+\n+    public static void commit(long start, long method, long invocations, long average) {\n+        \/\/ Generated by JFR\n+    }\n+\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0;\n+    }\n+\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/MethodTimingEvent.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.StackTrace;\n+\n+@Name(\"jdk.MethodTrace\")\n+@Label(\"Method Trace\")\n+@Category({ \"Java Virtual Machine\", \"Method Tracing\" })\n+@StackTrace(true)\n+public final class MethodTraceEvent extends AbstractJDKEvent {\n+\n+    @Label(\"Method\")\n+    private long method;\n+\n+    public static void commit(long start, long duration, long method) {\n+        \/\/ Generated by JFR\n+    }\n+\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0;\n+    }\n+\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/MethodTraceEvent.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.jfr.internal.settings.MethodSetting;\n@@ -56,0 +57,1 @@\n+import jdk.jfr.internal.tracing.Modification;\n@@ -73,0 +75,1 @@\n+    private static final Type TYPE_METHOD_FILTER = TypeLibrary.createType(MethodSetting.class);\n@@ -98,0 +101,4 @@\n+        if (eventType.getModification() != Modification.NONE) {\n+            addControl(\"filter\", defineMethodFilter(eventType, eventType.getModification()));\n+        }\n+\n@@ -338,0 +345,6 @@\n+    private Control defineMethodFilter(PlatformEventType type, Modification modification) {\n+        String def = \"\";\n+        type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_METHOD_FILTER, \"filter\", def, Collections.emptyList()));\n+        return new Control(new MethodSetting(type, modification, def), def);\n+    }\n+\n@@ -343,0 +356,6 @@\n+            } else {\n+                String v = nc.control.getDefaultValue();\n+                \/\/ Avoids slow retransformation during shutdown\n+                if (v != null && !PlatformRecorder.isInShutDown()) {\n+                    nc.control.setValue(v);\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.jfr.events.MethodTimingEvent;\n+import jdk.jfr.events.MethodTraceEvent;\n@@ -46,0 +48,2 @@\n+import jdk.jfr.internal.tracing.PlatformTracer;\n+import jdk.jfr.tracing.MethodTracer;\n@@ -76,0 +80,2 @@\n+        MethodTraceEvent.class,\n+        MethodTimingEvent.class,\n@@ -86,0 +92,1 @@\n+    private static final Runnable emitMethodTiming = JDKEvents::emitMethodTiming;\n@@ -99,0 +106,1 @@\n+                PeriodicEvents.addJavaEvent(MethodTimingEvent.class, emitMethodTiming);\n@@ -203,0 +211,1 @@\n+        PeriodicEvents.removeEvent(emitMethodTiming);\n@@ -227,0 +236,6 @@\n+\n+    private static void emitMethodTiming() {\n+        if (MethodTimingEvent.enabled()) {\n+            PlatformTracer.emitTiming();\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JDKEvents.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -685,0 +685,64 @@\n+\n+    \/**\n+     * Sets method tracing filters.\n+     *\n+     * A filter can be a class, a method, or an annotation.\n+     *\n+     * For example, the following three filters:\n+     * <ul>\n+     * <li>Method timing on all methods in class com.foo.Bar<\/li>\n+     * <li>Method tracing on the method com.foo.Bar::baz<\/li>\n+     * <li>Method timing and tracing on all methods or classes with the annotation @com.foo.Foo<\/li>\n+     * <\/ul>\n+     * can be set using the following code:\n+     * <pre>\n+     * String[] classes = new String[3];\n+     * classes[0] = \"com\/foo\/Bar\";\n+     * classes[1] = \"com\/foo\/Bar\";\n+     * classes[2] = null;\n+     *\n+     * String[] methods = new String[3];\n+     * methods[0] = null;\n+     * methods[1] = \"baz\";\n+     * methods[2] = null;\n+     *\n+     * String[] annotations = new String[3];\n+     * annotations[0] = null;\n+     * annotations[1] = null;\n+     * annotations[2] = \"com\/foo\/Foo\";\n+     *\n+     * int[] modifications = new int[3];\n+     * modifications[0] = 1; \/\/ filter should apply to timing\n+     * modifications[1] = 2; \/\/ filter should apply to tracing\n+     * modifications[2] = 1 | 2; \/\/ filter should apply to both timing and tracing\n+     *\n+     * JVM.setMethodTraceFilters(classes, methods, annotations, modifications);\n+     * <\/pre>\n+     * The filter will be applied to currently and future loaded classes.\n+     * <p>\n+     * If a method is overloaded, the filter matches against all methods. It's not possible\n+     * to match specific method parameters or annotation values.\n+     * <p>\n+     * Only one type of a filter - class, method, or annotation - can be used per array index.\n+     * <p>\n+     * If the filter is matched, JVMUpcalls::onMethodTrace will be invoked with\n+     * the bytecode. If a filter is replaced, and method no longer requires instrumentation,\n+     * the method will also be called with modification = 0;\n+     *\n+     * @param classes, not {@code null}, array of class names\n+     * @param methods, not {@code null}, array of method names\n+     * @param annotations, not {@code null}, array of annotation names\n+     * @param modifications, not {@code null}, array of modification flags\n+     * @return the published IDs, or null if no classes has been published.\n+     *\/\n+    public static native long[] setMethodTraceFilters(\n+            String[] classes,\n+            String[] methods,\n+            String[] annotations,\n+            int[] modification);\n+    \/**\n+     * Returns IDs for method-traced classes that have been unloaded.\n+     *\n+     * @return the unloaded IDs, or null if no unloading has occurred.\n+     *\/\n+    public static native long[] drainStaleMethodTracerIds();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":65,"deletions":1,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\n@@ -32,0 +31,2 @@\n+import jdk.jfr.internal.tracing.PlatformTracer;\n+\n@@ -162,0 +163,31 @@\n+\n+    \/**\n+     * Called by the JVM to update method tracing instrumentation.\n+     * <p>\n+     * @param module the module the class belongs to\n+     * @param classLoader the class loader the class is being loaded for\n+     * @param className the internal class name, i.e. java\/lang\/String.\n+     * @param bytecode the bytecode to modify\n+     * @param methodIds the method IDs\n+     * @param names constant pool indices of method names\n+     * @param signatures constant pool indices of method signatures\n+     * @param modifications integer mask describing the modification\n+     *\n+     * @return the instrumented bytecode, or null if the class can't or shouldn't be modified.\n+     *\/\n+    public static byte[] onMethodTrace(Module module, ClassLoader classLoader, String className,\n+                                       byte[] bytecode, long[] methodIds, String[] names, String[] signatures,\n+                                       int[] modifications) {\n+        return PlatformTracer.onMethodTrace(module, classLoader, className,\n+                                            bytecode, methodIds, names, signatures,\n+                                            modifications);\n+    }\n+\n+    \/**\n+     * Called by the JVM to publish a class ID that can safely be used by the Method Timing event.\n+     * <p>\n+     * @param classId the methods to be published\n+     *\/\n+    public static void publishMethodTimersForClass(long classId) {\n+        PlatformTracer.publishClass(classId);\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -104,1 +104,6 @@\n-    JFR_START(16);\n+    JFR_START(16),\n+    \/**\n+     *  Covers usage of MethodTiming and MethodTrace events\n+     *\/\n+    JFR_METHODTRACE(17),\n+    ;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/LogTag.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -208,1 +208,0 @@\n-                    pEventType.setAnnotations(nativeType.getAnnotationElements());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import jdk.jfr.internal.tracing.Modification;\n+\n@@ -75,1 +77,1 @@\n-        this.isMethodSampling = isJVM && (name.equals(Type.EVENT_NAME_PREFIX + \"ExecutionSample\") || name.equals(Type.EVENT_NAME_PREFIX + \"NativeMethodSample\"));\n+        this.isMethodSampling = determineMethodSampling();\n@@ -77,1 +79,1 @@\n-        this.stackTraceOffset = stackTraceOffset(name, isJDK);\n+        this.stackTraceOffset = determineStackTraceOffset();\n@@ -80,2 +82,2 @@\n-    private static boolean isExceptionEvent(String name) {\n-        switch (name) {\n+    private boolean isExceptionEvent() {\n+        switch (getName()) {\n@@ -89,2 +91,2 @@\n-    private static boolean isUsingConfiguration(String name) {\n-        switch (name) {\n+    private boolean isStaticCommit() {\n+        switch (getName()) {\n@@ -101,1 +103,1 @@\n-    private static int stackTraceOffset(String name, boolean isJDK) {\n+    private int determineStackTraceOffset() {\n@@ -103,1 +105,2 @@\n-            if (isExceptionEvent(name)) {\n+            \/\/ Order matters\n+            if (isExceptionEvent()) {\n@@ -106,1 +109,4 @@\n-            if (isUsingConfiguration(name)) {\n+            if (getModification() == Modification.TRACING) {\n+                return 5;\n+            }\n+            if (isStaticCommit()) {\n@@ -113,0 +119,22 @@\n+    private boolean determineMethodSampling() {\n+        if (!isJVM) {\n+            return false;\n+        }\n+        switch (getName()) {\n+            case Type.EVENT_NAME_PREFIX + \"ExecutionSample\":\n+            case Type.EVENT_NAME_PREFIX + \"NativeMethodSample\":\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    public Modification getModification() {\n+        switch (getName()) {\n+            case Type.EVENT_NAME_PREFIX + \"MethodTrace\":\n+                return Modification.TRACING;\n+            case Type.EVENT_NAME_PREFIX + \"MethodTiming\":\n+                return Modification.TIMING;\n+        }\n+        return Modification.NONE;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static jdk.jfr.internal.LogLevel.ERROR;\n@@ -62,1 +61,1 @@\n-\n+    private static volatile boolean inShutdown;\n@@ -70,1 +69,0 @@\n-    private boolean inShutdown;\n@@ -153,2 +151,2 @@\n-    synchronized void setInShutDown() {\n-        this.inShutdown = true;\n+    static void setInShutDown() {\n+        inShutdown = true;\n@@ -157,2 +155,2 @@\n-    synchronized boolean isInShutDown() {\n-        return this.inShutdown;\n+    static boolean isInShutDown() {\n+        return inShutdown;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-                boolean reportOnExit = recorder.isInShutDown() && !reports.isEmpty();\n+                boolean reportOnExit = PlatformRecorder.isInShutDown() && !reports.isEmpty();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+    private static final String TRACING_PACKAGE_NAME = \"jdk.jfr.tracing\";\n@@ -65,0 +66,4 @@\n+    public static void addTracingExport() {\n+        Modules.addExports(JFR_MODULE, TRACING_PACKAGE_NAME);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-        recorder.setInShutDown();\n+        PlatformRecorder.setInShutDown();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ShutdownHook.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -138,0 +138,2 @@\n+    public int precision = -1;\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Field.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-            return ValueFormatter.formatDuration(d);\n+            return ValueFormatter.formatDuration(d, field.precision);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/FieldFormatter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.function.BiConsumer;\n@@ -283,0 +284,5 @@\n+                \/\/ This option is experimental and may not work properly\n+                \/\/ with rounding and truncation.\n+                if (text.startsWith(\"ms-precision:\")) {\n+                    yield millisPrecision(text.substring(\"ms-precision:\".length()));\n+                }\n@@ -309,0 +315,12 @@\n+    private Consumer<Field> millisPrecision(String digits) throws ParseException {\n+        try {\n+            int d = Integer.parseInt(digits);\n+            if (d < 0) {\n+                throw new ParseException(\"Expected 'precision:' to be at least 0' \", position());\n+            }\n+            return field -> field.precision = d;\n+        } catch (NumberFormatException nfe) {\n+            throw new ParseException(\"Not valid number for 'precision:' \" + digits, position());\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/QueryParser.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-; Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+; Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -449,0 +449,13 @@\n+[application.method-timing]\n+label = \"Method Timing\"\n+table = \"COLUMN 'Timed Method', 'Invocations', 'Average Time'\n+         FORMAT none, none, ms-precision:6\n+         SELECT LAST_BATCH(method) AS M, LAST_BATCH(invocations), LAST_BATCH(average)\n+         FROM jdk.MethodTiming GROUP BY method ORDER BY average\"\n+\n+[application.method-calls]\n+label = \"Method Calls\"\n+table = \"COLUMN 'Traced Method', 'Caller', 'Invocations'\n+         SELECT method as M, stackTrace.topFrame.method AS S, COUNT(*) AS C\n+         FROM jdk.MethodTrace GROUP BY M, S ORDER BY C DESC\"\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.settings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.TreeSet;\n+\n+import jdk.jfr.SettingControl;\n+import jdk.jfr.internal.PlatformEventType;\n+\n+\/**\n+ * Base class for settings that consists of semicolon-separated filters.\n+ *\/\n+public abstract class FilterSetting extends SettingControl {\n+    private final List<String> activeFilters = new ArrayList<>();\n+    private final PlatformEventType eventType;\n+    private final String defaultValue;\n+    private String value;\n+\n+    public FilterSetting(PlatformEventType eventType, String defaultValue) {\n+        this.eventType = Objects.requireNonNull(eventType);\n+        this.defaultValue = defaultValue;\n+    }\n+\n+    protected abstract void apply(PlatformEventType eventType, List<String> text);\n+\n+    protected abstract boolean isValid(String text);\n+\n+    @Override\n+    public final String combine(Set<String> settingValues) {\n+        List<String> filters = normalize(settingValues);\n+        if (!filters.isEmpty()) {\n+            return format(filters);\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Override\n+    public final void setValue(String settingValue) {\n+        List<String> filters = normalize(Set.of(settingValue));\n+        if (activeFilters.equals(filters)) {\n+            return;\n+        }\n+        apply(eventType, filters);\n+        this.value = settingValue;\n+        this.activeFilters.clear();\n+        this.activeFilters.addAll(filters);\n+    }\n+\n+    @Override\n+    public final String getValue() {\n+        return value;\n+    }\n+\n+    \/\/ Split, trim, sort and remove duplicates filters.\n+    private List<String> normalize(Set<String> settingValues) {\n+        Set<String> filters = new TreeSet<>();\n+        for (String value : settingValues) {\n+            for (String filter : value.split(\";\")) {\n+                filter = filter.strip();\n+                if (!filter.isEmpty() && !filter.isBlank() && isValid(filter)) {\n+                    filters.add(filter);\n+                }\n+            }\n+        }\n+        return new ArrayList<>(filters);\n+    }\n+\n+    private static String format(List<String> filters) {\n+        StringJoiner sj = new StringJoiner(\";\");\n+        filters.forEach(sj::add);\n+        return sj.toString();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/FilterSetting.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.settings;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.MetadataDefinition;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.PlatformEventType;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.tracing.Modification;\n+import jdk.jfr.internal.tracing.PlatformTracer;\n+\n+@MetadataDefinition\n+@Label(\"Filter\")\n+@Description(\"Methods to be filtered\")\n+@Name(Type.SETTINGS_PREFIX + \"Filter\")\n+public final class MethodSetting extends FilterSetting {\n+    private final Modification modification;\n+    private static volatile boolean initialized;\n+\n+    public MethodSetting(PlatformEventType eventType, Modification modification, String defaultValue) {\n+        super(eventType, defaultValue);\n+        this.modification = modification;\n+    }\n+\n+    public boolean isValid(String text) {\n+        return PlatformTracer.isValidFilter(text);\n+    }\n+\n+    @Override\n+    protected void apply(PlatformEventType eventType, List<String> filters) {\n+        if (!initialized) {\n+            PlatformTracer.initialize();\n+            initialized = true;\n+        }\n+        PlatformTracer.setFilters(modification, filters);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/MethodSetting.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+\/\/ \/\/ The JVM will skip all classes in the jdk.jfr module, so it's not added here.\n+public final class ExcludeList {\n+    private static final String[] EXCLUDED_CLASSES = {\n+        \/\/ Used by MethodTiming event to accumulate invocations.\n+        \"java\/util\/concurrent\/atomic\/AtomicLong\",\n+        \/\/ Used by EventWriter\n+        \"sun\/misc\/Unsafe\",\n+        \"jdk\/internal\/misc\/Unsafe;\",\n+    };\n+\n+    private static final String[] EXCLUDED_PREFIX = {\n+        \/\/ Used by MethodTiming event to store invocations, including inner classes.\n+        \"java\/util\/concurrent\/ConcurrentHashMap\",\n+        \/\/ Can't trigger <clinit> of these classes during PlatformTracer::onMethodTrace(...)\n+        \"jdk\/internal\/\", \/\/ jdk\/internal\/classfile, jdk\/internal\/loader and jdk\/internal\/foreign\n+        \"java\/lang\/classfile\/\"\n+    };\n+\n+    private static final String[] EXCLUDED_METHODS = {\n+        \/\/ Long used by MethodTiming event when looking up entry for timing entry\n+        \"java.lang.Long::<init>\",\n+        \"java.lang.Long::valueOf\",\n+        \"java.lang.Number::<init>\"\n+    };\n+\n+    public static boolean containsMethod(String methodName) {\n+        for (String method : EXCLUDED_METHODS) {\n+            if (method.equals(methodName)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static boolean containsClass(String className) {\n+        for (String clazz: EXCLUDED_CLASSES) {\n+            if (clazz.equals(className)) {\n+                return true;\n+            }\n+        }\n+        for (String prefix : EXCLUDED_PREFIX) {\n+            if (className.startsWith(prefix)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/ExcludeList.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import jdk.internal.module.Checks;\n+\n+\/**\n+ * Class that represents the filter a user can specify for the MethodTrace and\n+ * MethodTiming event.\n+ *\/\n+record Filter(String className, String methodName, String annotationName, Modification modification) {\n+\n+    static Filter of(String filter, Modification modification) {\n+        if (filter.startsWith(\"@\")) {\n+            return ofAnnotation(filter, modification);\n+        }\n+        if (filter.contains(\"::\")) {\n+            return ofMethod(filter, modification);\n+        }\n+        return ofClass(filter, modification);\n+    }\n+\n+    private static Filter ofAnnotation(String filter, Modification modification) {\n+        String annotation = filter.substring(1);\n+        if (Checks.isClassName(annotation)) {\n+            return new Filter(null, null, annotation, modification);\n+        }\n+        return null;\n+    }\n+\n+    private static Filter ofMethod(String filter, Modification modification) {\n+        int index = filter.indexOf(\"::\");\n+        String classPart = filter.substring(0, index);\n+        String methodPart = filter.substring(index + 2);\n+        if (methodPart.isEmpty()) {\n+            \/\/ Don't allow \"foo.Bar::\". User should specify \"foo.Bar\".\n+            return null;\n+        }\n+\n+        if (isMethod(methodPart)) {\n+            \/\/ Method name only, i.e. \"::baz\"\n+            if (classPart.isEmpty()) {\n+                return new Filter(null, methodPart, null, modification);\n+            }\n+            \/\/ Fully qualified method name, i.e. \"foo.Bar::baz\"\n+            if (isValidClassName(classPart)) {\n+                return new Filter(classPart, methodPart, null, modification);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static boolean isMethod(String methodName) {\n+        if (methodName.equals(\"<clinit>\") || methodName.equals(\"<init>\")) {\n+            return true;\n+        }\n+        return Checks.isJavaIdentifier(methodName);\n+    }\n+\n+    private static Filter ofClass(String filter, Modification modification) {\n+        if (isValidClassName(filter)) {\n+            return new Filter(filter, null, null, modification);\n+        }\n+        return null;\n+    }\n+\n+    private static boolean isValidClassName(String text) {\n+        return Checks.isClassName(text);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Filter.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassElement;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFile.ClassHierarchyResolverOption;\n+import java.lang.classfile.ClassFile.Option;\n+import java.lang.classfile.ClassHierarchyResolver;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+\n+\/**\n+ * Class that adds bytecode instrumentation for a class.\n+ *\/\n+final class Instrumentation {\n+    private final Map<String, Method> modificationMap = new LinkedHashMap<>();\n+    private final String className;\n+    private final ClassLoader classLoader;\n+    private final byte[] bytecode;\n+\n+    public Instrumentation(ClassLoader classLoader, String internalClassName, byte[] bytecode) {\n+        this.className = internalClassName.replace(\"\/\", \".\");\n+        this.classLoader = classLoader;\n+        this.bytecode = bytecode;\n+    }\n+\n+    public void addMethod(long methodId, String name, String signature, int modification) {\n+        modificationMap.put(name + signature, new Method(methodId, Modification.valueOf(modification), className + \"::\" + name));\n+    }\n+\n+    public List<Method> getMethods() {\n+        return new ArrayList<>(modificationMap.values());\n+    }\n+\n+    public byte[] generateBytecode() {\n+        boolean[] modified = new boolean[1];\n+        ClassFile classFile = ClassFile.of(resolverOption());\n+        ClassModel classModel = classFile.parse(bytecode);\n+        byte[] generated = classFile.build(classModel.thisClass().asSymbol(), classBuilder -> {\n+            for (var ce : classModel) {\n+                if (modifyClassElement(classBuilder, ce)) {\n+                    modified[0] = true;\n+                } else {\n+                    classBuilder.with(ce);\n+                }\n+            }\n+        });\n+        return modified[0] ? generated : null;\n+    }\n+\n+    private Option resolverOption() {\n+        return ClassHierarchyResolverOption.of(resolver());\n+    }\n+\n+    private ClassHierarchyResolver resolver() {\n+        if (classLoader == null) {\n+            return ClassHierarchyResolver.ofResourceParsing(ClassLoader.getSystemClassLoader());\n+        } else {\n+            return ClassHierarchyResolver.ofResourceParsing(classLoader);\n+        }\n+    }\n+\n+    private boolean modifyClassElement(ClassBuilder classBuilder, ClassElement ce) {\n+        if (ce instanceof MethodModel mm) {\n+            String method = mm.methodName().stringValue();\n+            String signature = mm.methodType().stringValue();\n+            String full = method + signature;\n+            Method tm = modificationMap.get(full);\n+            if (tm != null) {\n+                Modification m = tm.modification();\n+                if (m.tracing() || m.timing()) {\n+                    return modifyMethod(classBuilder, mm, tm);\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean modifyMethod(ClassBuilder classBuilder, MethodModel m, Method method) {\n+        var code = m.code();\n+        if (code.isPresent()) {\n+            if (classLoader == null && ExcludeList.containsMethod(method.name())) {\n+                String msg = \"Risk of recursion, skipping bytecode generation of \" + method.name();\n+                Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, msg);\n+                return false;\n+            }\n+            MethodTransform s = MethodTransform.ofStateful(\n+                () -> MethodTransform.transformingCode(new Transform(method))\n+            );\n+            classBuilder.transformMethod(m, s);\n+            return true;\n+        }\n+        return false;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Instrumentation.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+\n+\/**\n+ * Class that holds information about an instrumented method.\n+ *\/\n+record Method(long methodId, Modification modification, String name) {\n+    @Override\n+    public String toString() {\n+        return name + (modification.timing() ? \" +timing\" : \" -timing\") + (modification.tracing() ? \" +tracing\" : \" -tracing\") + \" (Method ID: \" + String.format(\"0x%08X)\", methodId);\n+    }\n+\n+    public long classId() {\n+        return methodId() >> 16;\n+    }\n+\n+    public boolean isTiming() {\n+        return modification.timing();\n+    }\n+\n+    public void log(String msg) {\n+        if (Logger.shouldLog(LogTag.JFR_METHODTRACE, LogLevel.DEBUG)) {\n+            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, msg + \" for \" + this);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Method.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+\/**\n+ * Class that holds the type of instrumentation that can be applied to a method.\n+ *\/\n+public record Modification(boolean timing, boolean tracing) {\n+    public static final Modification TIMING = new Modification(true, false);\n+    public static final Modification TRACING = new Modification(false, true);\n+    public static final Modification NONE = new Modification(false, false);\n+\n+    static Modification valueOf(int traceType) {\n+        return new Modification((traceType & 1) != 0, (traceType & 2) != 0);\n+    }\n+\n+    int toInt() {\n+        return (timing ? 1 : 0) + (tracing ? 2 : 0);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Modification.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import jdk.jfr.events.MethodTimingEvent;\n+import jdk.jfr.internal.JVM;\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+import jdk.jfr.internal.MetadataRepository;\n+import jdk.jfr.internal.SecuritySupport;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.util.Bytecode;\n+import jdk.jfr.tracing.MethodTracer;\n+\n+\/**\n+ * Class that contains the Method Tracer implementation.\n+ * <p>\n+ * By placing the implementation in jdk.jfr.internal.tracing package instead of\n+ * the jdk.jfr.tracing package fewer internals are exposed to the application.\n+ *\/\n+public final class PlatformTracer {\n+    private static final ConcurrentHashMap<Long, TimedMethod> timedMethods = new ConcurrentHashMap<>();\n+    private static final ConcurrentHashMap<Long, TimedClass> timedClasses = new ConcurrentHashMap<>();\n+\n+    private static List<Filter> traceFilters = List.of();\n+    private static List<Filter> timingFilters = List.of();\n+    private static TimedMethod OBJECT;\n+\n+    public static byte[] onMethodTrace(Module module, ClassLoader classLoader, String className,\n+                                       byte[] oldBytecode, long[] ids, String[] names, String[] signatures,\n+                                       int[] modifications) {\n+        if (classLoader == null && ExcludeList.containsClass(className)) {\n+            log(LogLevel.DEBUG, \"Risk of recursion, skipping bytecode generation\", module, className);\n+            return null;\n+        }\n+        try {\n+            Instrumentation instrumentation = new Instrumentation(classLoader, className, oldBytecode);\n+            for (int i = 0; i < ids.length; i++) {\n+                instrumentation.addMethod(ids[i], names[i], signatures[i], modifications[i]);\n+            }\n+            updateTiming(instrumentation.getMethods());\n+            return instrumentation.generateBytecode(); \/\/ Returns null if bytecode was not modified.\n+        } catch (ClassCircularityError cce) {\n+            log(LogLevel.WARN, \"Class circularity error, skipping instrumentation\", module, className);\n+            return null;\n+        } catch (Throwable t) {\n+            log(LogLevel.WARN, \"Unexpected error \" + t.getMessage() + \". Skipping instrumentation\", module, className);\n+            return null;\n+        }\n+    }\n+\n+    private static void updateTiming(List<Method> methods) {\n+        boolean removeClass = true;\n+        for (Method method : methods) {\n+            if (method.isTiming()) {\n+                removeClass = false;\n+            }\n+            updateTiming(method);\n+        }\n+        if (removeClass) {\n+            Long classId = methods.getFirst().classId();\n+            TimedClass timedClass = timedClasses.remove(classId);\n+            if (timedClass != null) {\n+                Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, \"TimedClass removed (Klass ID \" + String.format(\"0x%08X)\", classId));\n+            }\n+        }\n+    }\n+    private static void updateTiming(Method method) {\n+        if (!timedMethods.containsKey(method.methodId())) {\n+            if (method.isTiming()) {\n+                \/\/ Timing started\n+                TimedClass timedClass = timedClasses.computeIfAbsent(method.classId(), id -> new TimedClass());\n+                TimedMethod entry = timedClass.add(method);\n+                timedMethods.put(method.methodId(), entry);\n+                if (\"java.lang.Object::<init>\".equals(method.name())) {\n+                    OBJECT = entry;\n+                }\n+                method.log(\"Timing entry added\");\n+            }\n+            return;\n+        }\n+        if (!method.isTiming()) {\n+            TimedClass timedClass = timedClasses.get(method.classId());\n+            if (timedClass != null) {\n+                timedClass.remove(method);\n+            }\n+            timedMethods.remove(method.methodId());\n+            method.log(\"Timing entry removed\");\n+        }\n+    }\n+\n+    private static void log(LogLevel level, String message, Module module, String className) {\n+        if (!Logger.shouldLog(LogTag.JFR_METHODTRACE, level)) {\n+            return;\n+        }\n+        StringBuilder s = new StringBuilder();\n+        s.append(message);\n+        s.append(\" for \");\n+        s.append(className.replace(\"\/\", \".\"));\n+        s.append(\" in module \");\n+        s.append(module.getName());\n+        s.append(\" and class loader \" + module.getClassLoader());\n+        Logger.log(LogTag.JFR_METHODTRACE, level, s.toString());\n+    }\n+\n+    public static void emitTiming() {\n+        \/\/ Metadata lock prevents rotation\/flush while emitting events.\n+        synchronized (MetadataRepository.getInstance()) {\n+            removeClasses(JVM.drainStaleMethodTracerIds());\n+            long timestamp = MethodTimingEvent.timestamp();\n+            for (var tc : timedClasses.values()) {\n+                tc.emit(timestamp);\n+            }\n+        }\n+    }\n+\n+    public static void addObjectTiming(long duration) {\n+        OBJECT.invocations().getAndIncrement();\n+        OBJECT.time().addAndGet(duration);\n+    }\n+\n+    public static void addTiming(long id, long duration) {\n+        TimedMethod entry = timedMethods.get(id);\n+        if (entry != null) {\n+            entry.invocations().getAndIncrement();\n+            entry.time().addAndGet(duration);\n+        }\n+    }\n+\n+    public static boolean isValidFilter(String text) {\n+        return Filter.of(text, null) != null;\n+    }\n+\n+    public static void setFilters(Modification modification, List<String> filters) {\n+        publishClasses(applyFilter(modification, filters));\n+    }\n+\n+    private static long[] applyFilter(Modification modification, List<String> filters) {\n+        boolean hadFilters = hasFilters();\n+        if (modification.tracing()) {\n+            traceFilters = makeFilters(filters, modification);\n+        }\n+        if (modification.timing()) {\n+            timingFilters = makeFilters(filters, modification);\n+        }\n+        if (hadFilters || hasFilters()) {\n+            int size = filterCount();\n+            List<Filter> allFilters = new ArrayList<>(size);\n+            allFilters.addAll(traceFilters);\n+            allFilters.addAll(timingFilters);\n+            String[] classes = new String[size];\n+            String[] methods = new String[size];\n+            String[] annotations = new String[size];\n+            int[] modifications = new int[size];\n+            for (int index = 0; index < size; index++) {\n+                Filter filter = allFilters.get(index);\n+                classes[index] = Bytecode.internalName(filter.className());\n+                methods[index] = filter.methodName();\n+                annotations[index] = Bytecode.descriptorName(filter.annotationName());\n+                modifications[index] = filter.modification().toInt();\n+            }\n+            return JVM.setMethodTraceFilters(classes, methods, annotations, modifications);\n+        }\n+        return null;\n+    }\n+\n+    private static void removeClasses(long[] classIds) {\n+        if (classIds == null) {\n+            return;\n+        }\n+        for (int i = 0; i < classIds.length; i++) {\n+            TimedClass timedClass = timedClasses.remove(classIds[i]);\n+            if (timedClass != null) {\n+                for (TimedMethod tm : timedClass.methods()) {\n+                    timedMethods.remove(tm.method().methodId());\n+                    tm.method().log(\"Timing entry unloaded\");\n+                }\n+                if (Logger.shouldLog(LogTag.JFR_METHODTRACE, LogLevel.DEBUG)) {\n+                    Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, \"TimedClass unloaded and removed for klass ID \" + String.format(\"0x%08X\", classIds[i]));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void publishClasses(long[] classIds) {\n+        if (classIds == null) {\n+            return;\n+        }\n+        for (int i = 0; i < classIds.length; i++) {\n+            publishClass(classIds[i]);\n+        }\n+    }\n+\n+    public static void publishClass(long classId) {\n+        TimedClass timedClass = timedClasses.get(classId);\n+        \/\/ The class may be null if a class is drained\/unloaded before\n+        \/\/ it is being published by setFilter().\n+        if (timedClass != null) {\n+            timedClass.publish();\n+        }\n+    }\n+\n+    private static boolean hasFilters() {\n+        return filterCount() > 0;\n+    }\n+\n+    private static int filterCount() {\n+        return traceFilters.size() + timingFilters.size();\n+    }\n+\n+    private static List<Filter> makeFilters(List<String> filterTexts, Modification modification) {\n+        List<Filter> filters = new ArrayList<>(filterTexts.size());\n+        for (String filterText : filterTexts) {\n+            Filter filter = Filter.of(filterText, modification);\n+            if (filter != null) {\n+                filters.add(filter);\n+            }\n+        }\n+        return filters;\n+    }\n+\n+    private synchronized static void reset() {\n+        timedMethods.clear();\n+        timedClasses.clear();\n+    }\n+\n+    \/\/ This method has three purposes:\n+    \/\/\n+    \/\/ 1) Load classes before instrumentation to avoid recursion in class\n+    \/\/ initializers when onMethodTrace(...) is called by the JVM.\n+    \/\/\n+    \/\/ 2) Warm up methods used by the PlatformTracer class to reduce the observer\n+    \/\/ effect later.\n+    \/\/\n+    \/\/ 3) Export the jdk.jfr.tracing package to all other modules.\n+    \/\/\n+    \/\/ This method takes 1-10 milliseconds to run and is only executed once,\n+    \/\/ provided a user has specified a non-empty filter for the MethodTrace or\n+    \/\/ MethodTiming event.\n+    public static void initialize() {\n+        try {\n+            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, \"Method tracer initialization started.\");\n+            Thread current = Thread.currentThread();\n+            JVM.exclude(current);\n+            long methodId = 16384126;\n+            long classId = methodId >> 16;\n+            ClassLoader cl = null;\n+            String className = \" java\/lang\/String\";\n+            Module m = String.class.getModule();\n+            var is = ClassLoader.getSystemClassLoader().getResourceAsStream(\"java\/lang\/String.class\");\n+            byte[] oldBytecode = is.readAllBytes();\n+            is.close();\n+            long[] ids = { methodId };\n+            String[] names = { \"<clinit>\" };\n+            String[] signatures = { \"()V\" };\n+            int[] modifications = { 3 };\n+            byte[] bytes = onMethodTrace(m, cl, className, oldBytecode, ids, names, signatures, modifications);\n+            if (bytes == null) {\n+                throw new Exception(\"Could not generate bytecode\");\n+            }\n+            publishClass(classId);\n+            for (int id = 0; id < 25_000; id++) {\n+                MethodTracer.timing(MethodTracer.timestamp(), methodId);\n+                MethodTracer.trace(MethodTracer.timestamp(), methodId);\n+                MethodTracer.traceTiming(MethodTracer.timestamp(), methodId);\n+            }\n+            reset();\n+            JVM.include(current);\n+            SecuritySupport.addTracingExport();\n+            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.DEBUG, \"Method tracer initialization complete.\");\n+        } catch (Exception e) {\n+            Logger.log(LogTag.JFR_METHODTRACE, LogLevel.WARN, \"Method tracer initialization failed. \" + e.getMessage());\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/PlatformTracer.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Collection;\n+\n+import jdk.jfr.events.MethodTimingEvent;\n+\n+\/**\n+ * Holds timed method for a class. Used when publishing method ids.\n+ *\/\n+public final class TimedClass {\n+    private final ConcurrentHashMap<Long, TimedMethod> methods = new ConcurrentHashMap<>();\n+\n+    public TimedMethod add(Method method) {\n+        return methods.computeIfAbsent(method.methodId(), id -> new TimedMethod(method));\n+    }\n+\n+    public void remove(Method method) {\n+        methods.remove(method.methodId());\n+    }\n+\n+    public void publish() {\n+        for (TimedMethod t : methods.values()) {\n+            t.published().set(true);\n+            t.method().log(\"Timing entry published\");\n+        }\n+    }\n+\n+    Collection<TimedMethod> methods() {\n+        return methods.values();\n+    }\n+\n+    public void emit(long timestamp) {\n+        for (var tm : methods.values()) {\n+            if (tm.published().get()) {\n+                long methodId = tm.method().methodId();\n+                long invocations = tm.invocations().get();\n+                long time = tm.time().get();\n+                long average = invocations == 0 ? Long.MIN_VALUE : time \/ invocations;\n+                MethodTimingEvent.commit(timestamp, methodId, invocations, average);\n+                tm.method().log(\"Emitted event\");\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/TimedClass.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+\/**\n+ * Record class that holds invocation measurements used by the MethodTiming\n+ * event.\n+ * <p>\n+ * Fields in record classes are truly final so might help to have a record here.\n+ *\/\n+record TimedMethod(AtomicLong invocations, AtomicLong time, Method method, AtomicBoolean published) {\n+    TimedMethod(Method method) {\n+        this(new AtomicLong(), new AtomicLong(), method, new AtomicBoolean());\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/TimedMethod.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tracing;\n+\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.instruction.ReturnInstruction;\n+import java.lang.classfile.instruction.ThrowInstruction;\n+import java.lang.constant.ClassDesc;\n+\n+import jdk.jfr.internal.util.Bytecode;\n+import jdk.jfr.internal.util.Bytecode.MethodDesc;\n+import jdk.jfr.tracing.MethodTracer;\n+\n+\/**\n+ * Class that transforms the bytecode of a method so it can call the appropriate\n+ * methods in the jdk.jfr.tracing.MethodTracer class.\n+ * <p>\n+ * The method ID is determined by native code.\n+ *\/\n+final class Transform implements CodeTransform {\n+    private static final ClassDesc METHOD_TRACER_CLASS = ClassDesc.of(MethodTracer.class.getName());\n+    private static final MethodDesc TRACE_METHOD = MethodDesc.of(\"trace\", \"(JJ)V\");\n+    private static final MethodDesc TIMING_METHOD = MethodDesc.of(\"timing\", \"(JJ)V\");\n+    private static final MethodDesc TRACE_TIMING_METHOD = MethodDesc.of(\"traceTiming\", \"(JJ)V\");\n+    private static final MethodDesc TIMESTAMP_METHOD = MethodDesc.of(\"timestamp\", \"()J\");\n+\n+    private final Method method;\n+    private int timestampSlot = -1;\n+\n+    Transform(Method method) {\n+        this.method = method;\n+    }\n+\n+    @Override\n+    public final void accept(CodeBuilder builder, CodeElement element) {\n+        if (timestampSlot == -1) {\n+            timestampSlot = invokeTimestamp(builder);\n+            builder.lstore(timestampSlot);\n+        }\n+        if (element instanceof ReturnInstruction || element instanceof ThrowInstruction) {\n+            builder.lload(timestampSlot);\n+            builder.ldc(method.methodId());\n+            Modification modification = method.modification();\n+            boolean objectInit = method.name().equals(\"java.lang.Object::<init>\");\n+            String suffix = objectInit ? \"ObjectInit\" : \"\";\n+            if (modification.timing()) {\n+                if (modification.tracing()) {\n+                    invokeTraceTiming(builder, suffix);\n+                } else {\n+                    invokeTiming(builder, suffix);\n+                }\n+            } else {\n+                if (modification.tracing()) {\n+                    invokeTrace(builder, suffix);\n+                }\n+            }\n+        }\n+        builder.with(element);\n+    }\n+\n+    public static void invokeTiming(CodeBuilder builder, String suffix) {\n+        builder.invokestatic(METHOD_TRACER_CLASS, TIMING_METHOD.name() + suffix, TIMING_METHOD.descriptor());\n+    }\n+\n+    public static void invokeTrace(CodeBuilder builder, String suffix) {\n+        builder.invokestatic(METHOD_TRACER_CLASS, TRACE_METHOD.name() + suffix, TRACE_METHOD.descriptor());\n+    }\n+\n+    public static void invokeTraceTiming(CodeBuilder builder, String suffix) {\n+        builder.invokestatic(METHOD_TRACER_CLASS, TRACE_TIMING_METHOD.name() + suffix, TRACE_TIMING_METHOD.descriptor());\n+    }\n+\n+    public static int invokeTimestamp(CodeBuilder builder) {\n+        Bytecode.invokestatic(builder, METHOD_TRACER_CLASS, TIMESTAMP_METHOD);\n+        return builder.allocateLocal(TypeKind.LONG);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tracing\/Transform.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -104,0 +104,8 @@\n+    public static String internalName(String className) {\n+        return className != null ? className.replace(\".\", \"\/\") : null;\n+    }\n+\n+    public static String descriptorName(String className) {\n+        return className != null ? (\"L\" + internalName(className) + \";\") : null;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Bytecode.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,0 +113,4 @@\n+        return formatDuration(d, -1);\n+    }\n+\n+    public static String formatDuration(Duration d, int precision) {\n@@ -117,1 +121,1 @@\n-            return \"-\" + formatPositiveDuration(roundedDuration.abs());\n+            return \"-\" + formatPositiveDuration(roundedDuration.abs(), precision);\n@@ -119,1 +123,1 @@\n-            return formatPositiveDuration(roundedDuration);\n+            return formatPositiveDuration(roundedDuration, precision);\n@@ -123,1 +127,1 @@\n-    private static String formatPositiveDuration(Duration d){\n+    public static String formatPositiveDuration(Duration d, int precision) {\n@@ -126,0 +130,3 @@\n+            if (precision == -1) {\n+                precision = 6;\n+            }\n@@ -127,1 +134,1 @@\n-            return String.format(\"%.6f ms\", outputMs);\n+            return String.format(\"%.\" + precision + \"f ms\", outputMs);\n@@ -130,2 +137,4 @@\n-            int valueLength = countLength(d.toNanosPart());\n-            int outputDigit = NANO_SIGNIFICANT_FIGURES - valueLength;\n+            if (precision == -1) {\n+                int valueLength = countLength(d.toNanosPart());\n+                precision = NANO_SIGNIFICANT_FIGURES - valueLength;\n+            }\n@@ -133,1 +142,1 @@\n-            return String.format(\"%.\" + outputDigit + \"f ms\", outputMs);\n+            return String.format(\"%.\" + precision + \"f ms\", outputMs);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueFormatter.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -179,0 +179,25 @@\n+ * <tr>\n+ * <th scope=\"row\">{@code filter}<\/th>\n+ * <td>Specifies the filter for the event<\/td>\n+ * <td>{@code \"\"} (empty string)<\/td>\n+ * <td>An empty string if no filter is used. Otherwise, a\n+ * filter that can be used with the jdk.MethodTrace or\n+ * jdk.MethodTiming events and follows this grammar:<br>\n+ * {@snippet :\n+ * filter ::= target (\";\" target)*\n+ * target ::= class | class-method | method | annotation\n+ * class ::= identifier (\".\" identifier)*\n+ * class-method ::= class method\n+ * method ::= \"::\" method-name\n+ * method-name ::= identifier | \"<clinit>\" | \"<init>\"\n+ * annotation ::= \"@\" class\n+ * identifier ::= see JLS 3.8\n+ * }\n+ * <\/td>\n+ * <td>{@code \"java.lang.String\"}<br>\n+ * {@code \"::<clinit>\"}<br>\n+ * {@code \"java.util.HashMap::resize\"}<br>\n+ * {@code \"java.io.FileDescriptor::<init>;java.io.FileDescriptor::close\"}<br>\n+ * {@code  \"@jakarta.ws.rs.GET\"}<br>\n+ * <\/td>\n+ * <\/tr>\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/package-info.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.tracing;\n+\n+import jdk.jfr.events.MethodTimingEvent;\n+import jdk.jfr.events.MethodTraceEvent;\n+import jdk.jfr.internal.JVM;\n+import jdk.jfr.internal.tracing.PlatformTracer;\n+\n+\/**\n+ * This class serves as the frontend for method tracing capabilities. The\n+ * jdk.jfr.tracing package is exported to all modules when the first method\n+ * tracing filter is applied.\n+ * <p>\n+ * A malicious user could craft bytecode that invoke these methods with an\n+ * invalid method ID, resulting in an event where the method field is\n+ * incorrect or {@code null}. This is considered acceptable.\n+ *\/\n+public final class MethodTracer {\n+\n+    private MethodTracer() {\n+    }\n+\n+    public static long timestamp() {\n+        return JVM.counterTime();\n+    }\n+\n+    public static void traceObjectInit(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTraceEvent.enabled() && JVM.getEventWriter() != null) {\n+            MethodTraceEvent.commit(startTime, duration, methodId);\n+        }\n+    }\n+\n+    public static void timingObjectInit(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTimingEvent.enabled()) {\n+            PlatformTracer.addObjectTiming(duration);\n+        }\n+    }\n+\n+    public static void traceTimingObjectInit(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTraceEvent.enabled() && JVM.getEventWriter() != null) {\n+            MethodTraceEvent.commit(startTime, duration, methodId);\n+        }\n+        if (MethodTimingEvent.enabled()) {\n+            PlatformTracer.addObjectTiming(duration);\n+        }\n+    }\n+\n+    public static void trace(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTraceEvent.enabled()) {\n+            MethodTraceEvent.commit(startTime, duration, methodId);\n+        }\n+    }\n+\n+    public static void timing(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTimingEvent.enabled()) {\n+            PlatformTracer.addTiming(methodId, duration);\n+        }\n+    }\n+\n+    public static void traceTiming(long startTime, long methodId) {\n+        long endTime = JVM.counterTime();\n+        long duration = endTime - startTime;\n+        if (MethodTimingEvent.enabled()) {\n+            PlatformTracer.addTiming(methodId, duration);\n+        }\n+        if (MethodTraceEvent.enabled()) {\n+            MethodTraceEvent.commit(startTime, duration, methodId);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/tracing\/MethodTracer.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -209,0 +209,13 @@\n+    <event name=\"jdk.MethodTrace\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"filter\" control=\"method-trace\"><\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.MethodTiming\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"filter\" control=\"method-timing\"><\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n@@ -1161,0 +1174,4 @@\n+      <text name=\"method-timing\" label=\"Method Timing\" contentType=\"text\"><\/text>\n+\n+      <text name=\"method-trace\" label=\"Method Trace\" contentType=\"text\"><\/text>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -209,0 +209,13 @@\n+    <event name=\"jdk.MethodTrace\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"filter\" control=\"method-trace\"><\/setting>\n+      <setting name=\"threshold\">0 ms<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.MethodTiming\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"filter\" control=\"method-timing\"><\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n@@ -1160,0 +1173,4 @@\n+      <text name=\"method-timing\" label=\"Method Timing\" contentType=\"text\"><\/text>\n+\n+      <text name=\"method-trace\" label=\"Method Trace\" contentType=\"text\"><\/text>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,2 @@\n-        new SettingTest(\"throttle\", \"off\", \"jdk.ObjectAllocationSample\", List.of(\"off\", \"100\/s\", \"10\/ms\"))\n+        new SettingTest(\"throttle\", \"off\", \"jdk.ObjectAllocationSample\", List.of(\"off\", \"100\/s\", \"10\/ms\")),\n+        new SettingTest(\"filter\", \"\", \"jdk.MethodTrace\", List.of(\"\", \"foo.bar::Baz\", \"com.example.Test;foo.bar::Baz\"))\n","filename":"test\/jdk\/jdk\/jfr\/api\/settings\/TestSettingControl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.TYPE;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ TYPE, METHOD })\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Apple {\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/Apple.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.TYPE;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ TYPE, METHOD })\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Banana {\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/Banana.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+public final class Car implements Runnable {\n+\n+    public void run() {\n+        System.out.println(\"Car is running. Class loader name \" + this.getClass().getClassLoader().getName());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/Car.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+public final class StaticInitializer {\n+    public static String TRIGGERED;\n+    static {\n+        System.out.println(\"Executing StaticInitializer::<clinit>\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/StaticInitializer.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that <clinit> can be instrumented.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.event.tracing.StaticInitializer\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestClinit\n+ **\/\n+public class TestClinit {\n+    private static final String PACKAGE_NAME = TestClinit.class.getPackageName();\n+    private static final String CLINIT_CLASS_NAME = PACKAGE_NAME + \".StaticInitializer\";\n+    private static final String CLINIT_METHOD_NAME = CLINIT_CLASS_NAME + \"::<clinit>\";\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(\"jdk.MethodTrace\")\n+             .with(\"filter\", CLINIT_CLASS_NAME);\n+            r.enable(\"jdk.MethodTiming\")\n+             .with(\"filter\", CLINIT_METHOD_NAME)\n+             .with(\"period\", \"endChunk\");\n+\n+            r.start();\n+            StaticInitializer.TRIGGERED = \"true\";\n+            r.stop();\n+\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.assertEventCount(events, 2);\n+\n+            RecordedEvent traceEvent = Events.getFirst(events, \"jdk.MethodTrace\");\n+            Events.assertTopFrame(traceEvent, TestClinit.class.getName(), \"main\");\n+            assertClinitMethod(traceEvent);\n+\n+            RecordedEvent timingEvent = Events.getFirst(events, \"jdk.MethodTiming\");\n+            assertClinitMethod(timingEvent);\n+        }\n+    }\n+\n+    private static void assertClinitMethod(RecordedEvent event) throws Exception {\n+        RecordedMethod method = event.getValue(\"method\");\n+        if (!method.getName().equals(\"<clinit>\")) {\n+            System.out.println(event);\n+            throw new Exception(\"Expected <clinit>, was \" + method.getName());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestClinit.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.event.tracing.Apple;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that the union of annotation-based, class-based and\n+ *          method-based filters can be used simultaneously.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.event.tracing.Apple\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestCombinedFilters\n+ **\/\n+public class TestCombinedFilters {\n+    private static final String APPLE_ANNOTATION = Apple.class.getName();\n+    private static final String TRACE_EVENT = \"jdk.MethodTrace\";\n+    private static final String TIMING_EVENT = \"jdk.MethodTiming\";\n+    private static final String FOO_CLASS = Foo.class.getName();\n+\n+    public static class Foo {\n+        @Apple\n+        static void bar() {\n+            System.out.println(\"Executing Foo:bar\");\n+        }\n+\n+        static void baz() {\n+            System.out.println(\"Executing Foo:baz\");\n+        }\n+\n+        static void qux() {\n+            System.out.println(\"Executing Foo:qux\");\n+        }\n+    }\n+\n+    record TestEvent(String event, String type, String method) {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        String traceFilter = \"@\" + APPLE_ANNOTATION + \";\" + FOO_CLASS + \"::bar\";\n+        String timingFilter = Foo.class.getName();\n+        try (Recording r = new Recording()) {\n+            r.enable(TRACE_EVENT).with(\"filter\", traceFilter);\n+            r.enable(TIMING_EVENT).with(\"filter\", timingFilter).with(\"period\", \"endChunk\");\n+            for (var entry : r.getSettings().entrySet()) {\n+                System.out.println(entry.getKey() + \"=\" + entry.getValue());\n+            }\n+            r.start();\n+            Foo.bar();\n+            Foo.baz();\n+            Foo.qux();\n+            r.stop();\n+            var list = List.of(new TestEvent(TRACE_EVENT, FOO_CLASS, \"bar\"),\n+                               new TestEvent(TIMING_EVENT, FOO_CLASS, \"<init>\"),\n+                               new TestEvent(TIMING_EVENT, FOO_CLASS, \"bar\"),\n+                               new TestEvent(TIMING_EVENT, FOO_CLASS, \"baz\"),\n+                               new TestEvent(TIMING_EVENT, FOO_CLASS, \"qux\"));\n+            List<TestEvent> expected = new ArrayList<>(list);\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+            }\n+            Events.hasEvents(events);\n+            for (RecordedEvent e : events) {\n+                RecordedMethod method = e.getValue(\"method\");\n+                String className = method.getType().getName();\n+                String eventTypeName = e.getEventType().getName();\n+                TestEvent testEvent = new TestEvent(eventTypeName, className, method.getName());\n+                if (!expected.remove(testEvent)) {\n+                    throw new Exception(\"Unexpected event \" + testEvent);\n+                }\n+            }\n+            if (!expected.isEmpty()) {\n+                throw new Exception(\"Missing events \" + expected);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestCombinedFilters.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that class filters work as expected.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestFilterClass\n+ **\/\n+public class TestFilterClass {\n+    private static final String THIS_CLASS = TestFilterClass.class.getName();\n+    private static final String EVENT_NAME = \"jdk.MethodTrace\";\n+\n+    interface Interface {\n+        void foo();\n+\n+        void bar();\n+\n+        public static void baz() {\n+            System.out.println(\"Executing Interface::baz\");\n+        }\n+    }\n+\n+    static class Implementation implements Interface {\n+        public void foo() {\n+            System.out.println(\"Executing Implementation::foo\");\n+        }\n+\n+        @Override\n+        public void bar() {\n+            throw new Error(\"Should not happen\");\n+        }\n+    }\n+\n+    enum Enum {\n+        VALUE;\n+\n+        public void bar() {\n+            System.out.println(\"Executing Enum::bar\");\n+        }\n+    }\n+\n+    record Record(int value) {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME)\n+             .with(\"filter\", THIS_CLASS + \"$Implementation;\" +\n+                             THIS_CLASS + \"$Interface;\" +\n+                             THIS_CLASS + \"$Enum;\" +\n+                             THIS_CLASS + \"$Record\");\n+            r.start();\n+            Interface.baz();\n+            new Implementation().foo();\n+            Enum.VALUE.bar();\n+            new Record(4711).value();\n+            r.stop();\n+            var list = new ArrayList<>(List.of(THIS_CLASS + \"$Interface::baz\", THIS_CLASS + \"$Implementation::<init>\", THIS_CLASS + \"$Implementation::foo\", THIS_CLASS + \"$Enum::<clinit>\",\n+                    THIS_CLASS + \"$Enum::<init>\", THIS_CLASS + \"$Enum::bar\", THIS_CLASS + \"$Record::<init>\", THIS_CLASS + \"$Record::value\"));\n+            var events = Events.fromRecording(r);\n+            System.out.println(list);\n+            Events.hasEvents(events);\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+                RecordedMethod method = event.getValue(\"method\");\n+                String name = method.getType().getName() + \"::\" + method.getName();\n+                if (!list.remove(name)) {\n+                    throw new Exception(\"Unexpected method '\" + name + \"' in event\");\n+                }\n+            }\n+            if (!list.isEmpty()) {\n+                throw new Exception(\"Expected events for the methods \" + list);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestFilterClass.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+\n+import jdk.jfr.event.tracing.Apple;\n+import jdk.jfr.event.tracing.Banana;\n+\n+\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+import java.lang.annotation.Target;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+\n+\/**\n+ * @test\n+ * @summary Tests class-annotation-based filtering.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm\n+ *    -Xlog:jfr+methodtrace=trace\n+ *    jdk.jfr.event.tracing.TestFilterClassAnnotation\n+ *\/\n+\n+\/\/ @Banana and Apple tests multiple annotations and that the target is not the first annotation\n+@Banana\n+@Apple\n+public class TestFilterClassAnnotation {\n+    private static final String EVENT_NAME = \"jdk.MethodTrace\";\n+\n+    \/\/ Class Foo tests inner and interface classes\n+    @Apple\n+    interface Foo {\n+        \/\/ Method duck() tests that static methods in interfaces can be instrumented\n+        private static void duck() {\n+            System.out.println(\"Executing method: duck()\");\n+        }\n+\n+        \/\/ Method eggplant() tests that abstract method doesn't interfere in the\n+        \/\/ instrumentation\n+        void eggplant();\n+    }\n+\n+    \/\/ Method ant() tests that the same method annotation as the class doesn't\n+    \/\/ interfere\n+    @Apple\n+    private static void ant() {\n+        System.out.println(\"Executing method: ant()\");\n+    }\n+\n+    \/\/ Method bear() tests that other method annotation doesn't interfere\n+    @Banana\n+    private static void bear() {\n+        System.out.println(\"Executing method: bear()\");\n+    }\n+\n+    \/\/ Method cat() tests that a method in an annotated class is instrumented\n+    private static void cat() {\n+        System.out.println(\"Executing method: cat()\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME)\n+             .with(\"filter\", \"@\" + Apple.class.getName());\n+            r.start();\n+            ant();\n+            bear();\n+            cat();\n+            Foo.duck();\n+            r.stop();\n+\n+            var set = new HashSet<>(Set.of(\"ant\", \"bear\", \"cat\", \"duck\"));\n+            var events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            for (RecordedEvent e : events) {\n+                System.out.println(e);\n+                RecordedMethod method = e.getValue(\"method\");\n+                if (!set.remove(method.getName())) {\n+                    throw new Exception(\"Unexpected method '\" + method.getName() + \"' in event\");\n+                }\n+                RecordedFrame topFrame = e.getStackTrace().getFrames().get(0);\n+                String topMethod = topFrame.getMethod().getName();\n+                if (!topMethod.equals(\"main\")) {\n+                    throw new Exception(\"Expected method to be called from main\");\n+                }\n+            }\n+            if (!set.isEmpty()) {\n+                throw new Exception(\"Expected events for the methods \" + set);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestFilterClassAnnotation.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that a method filter (e.g., class::method) works as expected.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestFilterMethod\n+ *\/\n+public class TestFilterMethod {\n+    private static final String THIS_CLASS = TestFilterMethod.class.getName();\n+    private static final String EVENT_NAME = \"jdk.MethodTrace\";\n+\n+    \/\/ Tests implicit constructor\n+    static public class SomeClass {\n+        public void override() {\n+            throw new Error(\"Should not happen\");\n+        }\n+    }\n+\n+    \/\/ Tests explicit constructor\n+    static public class OtherClass extends SomeClass {\n+        public OtherClass() {\n+            System.out.println(\"Executing Otherclass::Otherclass()\");\n+        }\n+    }\n+\n+    \/\/ Tests method override\n+    static public class SomeSubclass extends SomeClass {\n+        public void override() {\n+            System.out.println(\"Executing SomeSubclass::override()\");\n+        }\n+    }\n+\n+    \/\/ Tests method in enum\n+    enum Enum {\n+        VALUE;\n+\n+        static void enumMethod() {\n+            System.out.println(\"Executing Enum:enumMethod\");\n+        }\n+    }\n+\n+    \/\/ Tests method in interface\n+    interface Interface {\n+        public static void staticMethod() {\n+            System.out.println(\"Executing Interface::staticMethod\");\n+        }\n+\n+        public void instanceMethod();\n+    }\n+\n+    static class Implementation implements Interface {\n+        @Override\n+        public void instanceMethod() {\n+        }\n+    }\n+\n+    \/\/ Tests normal method\n+    public static void overload() {\n+        System.out.println(\"Executing overload()\");\n+    }\n+\n+    \/\/ Tests overloaded method\n+    public static void overload(int value) {\n+        System.out.println(\"Executing overload(\" + value + \")\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME)\n+             .with(\"filter\", THIS_CLASS + \"$SomeSubclass::override;\" +\n+                             THIS_CLASS + \"$OtherClass::<init>;\" +\n+                             THIS_CLASS + \"::overload;\" +\n+                             THIS_CLASS + \"$Enum::enumMethod;\" +\n+                             THIS_CLASS + \"$Interface::staticMethod;\" +\n+                             THIS_CLASS + \"$Implementation::instanceMethod\");\n+            r.start();\n+            new SomeSubclass().override();\n+            new OtherClass();\n+            overload();\n+            overload(1);\n+            Enum.enumMethod();\n+            Interface.staticMethod();\n+            new Implementation().instanceMethod();\n+            r.stop();\n+\n+            var set = new ArrayList<>(List.of(\n+                \"<init>\", \/\/ OtherClass:<init>\n+                \"override\",\n+                \"overload\", \/\/ overload()\n+                \"overload\", \/\/ overload(int)\n+                \"enumMethod\",\n+                \"staticMethod\",\n+                \"instanceMethod\"));\n+            var events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+                RecordedMethod m = event.getValue(\"method\");\n+                if (!set.remove(m.getName())) {\n+                    throw new Exception(\"Unexpected method '\" + m.getName() + \"' in event\");\n+                }\n+                RecordedFrame topFrame = event.getStackTrace().getFrames().get(0);\n+                String topMethod = topFrame.getMethod().getName();\n+                if (!topMethod.equals(\"main\")) {\n+                    throw new Exception(\"Expected method to be called from main\");\n+                }\n+            }\n+            if (!set.isEmpty()) {\n+                throw new Exception(\"Expected events for the methods \" + set);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestFilterMethod.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+import static java.lang.annotation.ElementType.TYPE;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.event.tracing.Apple;\n+import jdk.jfr.event.tracing.Banana;\n+import jdk.jfr.event.tracing.TestFilterMethodAnnotation.Foo;\n+\n+\/**\n+ * @test\n+ * @summary Tests method-annotation-based filtering.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestFilterMethodAnnotation\n+ *\/\n+public class TestFilterMethodAnnotation {\n+\n+    static String EVENT_NAME = \"jdk.MethodTrace\";\n+\n+    \/\/ Tests that abstract method is ignored\n+    static abstract class Foo {\n+        @Apple\n+        abstract void baz();\n+    }\n+\n+    \/\/ Tests tracing of an inner class\n+    static class Bar extends Foo {\n+        @Override\n+        \/\/ Tests method override\n+        @Apple\n+        void baz() {\n+            System.out.println(\"Executing Bar::baz()\");\n+        }\n+\n+        @Apple\n+        void qux() {\n+            System.out.println(\"Executing Bar::qux()\");\n+        }\n+    }\n+\n+    \/\/ Tests tracing of method with multiple annotations and the target not being\n+    \/\/ first\n+    @Banana\n+    @Apple\n+    private static void ant() {\n+        System.out.println(\"Executing method: ant()\");\n+    }\n+\n+    \/\/ Tests that overloaded method with the same name is not traced\n+    private static void ant(int i) {\n+        System.out.println(\"Executing method: apple(\" + i + \")\");\n+    }\n+\n+    \/\/ Tests that non-annotated method is not traced\n+    private static void bear() {\n+        System.out.println(\"Executing method: bear()\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME)\n+             .with(\"filter\", \"@\" + Apple.class.getName());\n+            r.start();\n+            ant();\n+            ant(4711);\n+            bear();\n+            Bar bar = new Bar();\n+            bar.baz();\n+            bar.qux();\n+            r.stop();\n+            var set = new HashSet<>(Set.of(\"ant\", \"baz\", \"qux\"));\n+            var events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+                RecordedMethod method = event.getValue(\"method\");\n+                String methodName = method.getName();\n+                if (!set.remove(methodName)) {\n+                    throw new Exception(\"Unexpected method \" + methodName + \"() in event\");\n+                }\n+                RecordedFrame topFrame = event.getStackTrace().getFrames().get(0);\n+                if (!topFrame.getMethod().getName().equals(\"main\")) {\n+                    throw new Exception(\"Expected method to be called from main\");\n+                }\n+            }\n+            if (!set.isEmpty()) {\n+                throw new Exception(\"Expected events for the methods \" + set);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestFilterMethodAnnotation.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests that methods are instrumented correctly.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm\n+ *           -Xlog:jfr+methodtrace=debug\n+ *           jdk.jfr.event.tracing.TestInstrumentation\n+ **\/\n+public class TestInstrumentation {\n+    private static Object nullObject;\n+\n+    public static void main(String... args) throws Exception {\n+        List<RecordedEvent> traceEvents = new CopyOnWriteArrayList<>();\n+        List<RecordedEvent> timingEvents = new CopyOnWriteArrayList<>();\n+        try (RecordingStream r = new RecordingStream()) {\n+            r.setReuse(false);\n+            String filter = TestInstrumentation.class.getName();\n+            r.enable(\"jdk.MethodTrace\")\n+             .with(\"filter\", filter);\n+            r.enable(\"jdk.MethodTiming\")\n+             .with(\"filter\", filter)\n+             .with(\"period\", \"endChunk\");\n+            r.onEvent(\"jdk.MethodTrace\", traceEvents::add);\n+            r.onEvent(\"jdk.MethodTiming\", timingEvents::add);\n+            r.startAsync();\n+            try {\n+                whileTrue();\n+            } catch (NullPointerException npe) {\n+                \/\/ As expected\n+            }\n+            recursive(3);\n+            switchExpression(0);\n+            switchExpression(1);\n+            switchExpression(2);\n+            multipleReturns();\n+            multipleReturns();\n+            multipleReturns();\n+            multipleReturns();\n+            multipleReturns();\n+            try {\n+                exception();\n+            } catch (Exception e) {\n+            }\n+            try {\n+                deepException();\n+            } catch (Exception e) {\n+            }\n+            r.stop();\n+        }\n+        verifyTracing(traceEvents);\n+        verifyTiming(timingEvents);\n+    }\n+\n+    private static void verifyTracing(List<RecordedEvent> events) throws Exception {\n+        Map<String, Long> map = buildMethodMap(events, false);\n+        printMap(\"Tracing:\", map);\n+        assertMethod(map, \"exception\", 2);\n+        assertMethod(map, \"switchExpression\", 3);\n+        assertMethod(map, \"recursive\", 4);\n+        assertMethod(map, \"multipleReturns\", 5);\n+        if (!map.isEmpty()) {\n+            throw new Exception(\"Found unexpected methods \" + map.keySet());\n+        }\n+    }\n+\n+    private static void verifyTiming(List<RecordedEvent> events) throws Exception {\n+        Map<String, Long> map = buildMethodMap(events, true);\n+        printMap(\"Timing:\", map);\n+        assertMethod(map, \"exception\", 2);\n+        assertMethod(map, \"switchExpression\", 3);\n+        assertMethod(map, \"recursive\", 4);\n+        assertMethod(map, \"multipleReturns\", 5);\n+        for (var entry : map.entrySet()) {\n+            long invocations = entry.getValue();\n+            if (invocations != 0L) {\n+                throw new Exception(\"Unexpected \" + invocations + \" invocations for method \" + entry.getKey());\n+            }\n+        }\n+    }\n+\n+    private static void printMap(String caption, Map<String, Long> map) {\n+        System.out.println(caption);\n+        for (var entry : map.entrySet()) {\n+            System.out.println(entry.getKey() + \" = \" + entry.getValue());\n+        }\n+        System.out.println();\n+    }\n+\n+    private static void assertMethod(Map<String, Long> map, String method, long value) throws Exception {\n+        if (!map.containsKey(method)) {\n+            throw new Exception(\"Missing method \" + method);\n+        }\n+        if (!map.get(method).equals(value)) {\n+            throw new Exception(\"Expected value \" + value + \" for method \" + method);\n+        }\n+        map.remove(method);\n+    }\n+\n+    private static Map<String, Long> buildMethodMap(List<RecordedEvent> events, boolean invocations) {\n+        Map<String, Long> map = new HashMap<>();\n+        for (RecordedEvent e : events) {\n+            RecordedMethod m = e.getValue(\"method\");\n+            String name = m.getName();\n+            long add = invocations ? e.getLong(\"invocations\") : 1;\n+            map.compute(name, (key, value) -> (value == null) ? add : value + add);\n+        }\n+        return map;\n+    }\n+\n+    public static void whileTrue() {\n+        while (true) {\n+            nullObject.toString();\n+        }\n+    }\n+\n+    public static void recursive(int depth) {\n+        if (depth > 0) {\n+            recursive(depth - 1);\n+        } else {\n+            return;\n+        }\n+    }\n+\n+    public static String switchExpression(int value) {\n+        return switch (value) {\n+        case 0 -> \"zero\";\n+        case 1 -> \"one\";\n+        default -> \"number\";\n+        };\n+    }\n+\n+    public static void multipleReturns() {\n+        Random r = new Random();\n+        int v = r.nextInt(5);\n+        if (v == 0) {\n+            return;\n+        }\n+        switch (v) {\n+        case 1:\n+            return;\n+        case 2:\n+            return;\n+        }\n+        return;\n+    }\n+\n+    public static void exception() throws Exception {\n+        throw new Exception(\"\");\n+    }\n+\n+    public static void deepException() throws Exception {\n+        exception();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestInstrumentation.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.Event;\n+import jdk.jfr.StackTrace;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Basic test of the MethodTiming event.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.tracing.TestMethodTiming\n+ **\/\n+public class TestMethodTiming {\n+    private static final String EVENT_NAME = \"jdk.MethodTiming\";\n+\n+    @StackTrace(false)\n+    static class TimeMeasureEvent extends Event {\n+        public String id;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        testCount();\n+        testDuration();\n+    }\n+\n+    private static void testDuration() throws Exception {\n+        try (Recording r = new Recording()) {\n+            String filter = TestMethodTiming.class.getName() + \"::takeNap\";\n+            r.enable(EVENT_NAME).with(\"period\", \"endChunk\").with(\"filter\", filter);\n+            r.start();\n+\n+            TimeMeasureEvent maxEvent = new TimeMeasureEvent();\n+            maxEvent.id = \"max\";\n+            maxEvent.begin();\n+            takeNap();\n+            maxEvent.commit();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            for (var e : events) {\n+                System.out.println(e);\n+            }\n+            if (events.size() != 3) {\n+                throw new Exception(\"Expected three events: TimeMeasureEvent::id=max, TimeMeasureEventid=min and MethodTiming::method=takeNap()\");\n+            }\n+            RecordedEvent max = findWitdId(events, \"max\");\n+            RecordedEvent min = findWitdId(events, \"min\");\n+\n+            events.remove(min);\n+            events.remove(max);\n+            Duration minDuration = min.getDuration();\n+            Duration maxDuration = max.getDuration();\n+            RecordedEvent timingEvent = events.get(0);\n+            Duration d = timingEvent.getDuration(\"average\");\n+            if (d.compareTo(min.getDuration()) < 0) {\n+                throw new Exception(\"Expected duration to be at least \" + minDuration + \", was \" + d);\n+            }\n+            if (d.compareTo(max.getDuration()) > 0) {\n+                throw new Exception(\"Expected duration to be at most \" + maxDuration + \", was \" + d);\n+            }\n+            RecordedMethod method = timingEvent.getValue(\"method\");\n+            String methodName = method.getType().getName() + \"::\" + method.getName() + \" \" + method.getDescriptor();\n+            String expected = TestMethodTiming.class.getName() + \"::takeNap ()V\";\n+            if (!methodName.equals(expected)) {\n+                System.out.println(expected);\n+                throw new Exception(\"Expected method \" + expected + \" in event, but was \" +methodName);\n+            }\n+            if (timingEvent.getLong(\"invocations\") != 1) {\n+                throw new Exception(\"Expected one invocation\");\n+            }\n+        }\n+    }\n+\n+    private static RecordedEvent findWitdId(List<RecordedEvent> events, String id) throws Exception {\n+        for (RecordedEvent event : events) {\n+            if (event.hasField(\"id\")) {\n+                if (event.getString(\"id\").equals(id)) {\n+                    return event;\n+                }\n+            }\n+        }\n+        throw new Exception(\"Could not find event with ID \" + id);\n+    }\n+\n+    private static void takeNap() throws Exception {\n+        TimeMeasureEvent minEvent = new TimeMeasureEvent();\n+        minEvent.begin();\n+        minEvent.id = \"min\";\n+        Thread.sleep(10);\n+        minEvent.commit();\n+    }\n+\n+    private static void testCount() throws Exception {\n+        long invocations = 100_000;\n+        try (Recording r = new Recording()) {\n+            zebra();\n+            String filter = TestMethodTiming.class.getName() + \"::zebra\";\n+            r.enable(EVENT_NAME).with(\"period\", \"endChunk\").with(\"filter\", filter);\n+            r.start();\n+            for (int i = 0; i < invocations; i++) {\n+                zebra();\n+            }\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            for (RecordedEvent event : events) {\n+                Events.assertField(event, \"invocations\").equal(invocations);\n+            }\n+        }\n+    }\n+\n+    private static void zebra() {\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestMethodTiming.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.StackTrace;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Basic test of the MethodTrace event.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestMethodTrace\n+ **\/\n+public class TestMethodTrace {\n+    private static final String EVENT_NAME = \"jdk.MethodTrace\";\n+    private static final String CLASS_NAME = TestMethodTrace.class.getName();\n+\n+    @StackTrace(false)\n+    private static class OuterMeasurement extends Event {\n+    }\n+\n+    @StackTrace(false)\n+    private static class InnerMeasurement extends Event {\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        AtomicReference<RecordedEvent> o = new AtomicReference<>();\n+        AtomicReference<RecordedEvent> i = new AtomicReference<>();\n+        AtomicReference<RecordedEvent> e = new AtomicReference<>();\n+        try (RecordingStream s = new RecordingStream()) {\n+            s.enable(EVENT_NAME).with(\"filter\", CLASS_NAME + \"::bar\");\n+            s.onEvent(EVENT_NAME, e::set);\n+            s.onEvent(OuterMeasurement.class.getName(), o::set);\n+            s.onEvent(InnerMeasurement.class.getName(), i::set);\n+            s.startAsync();\n+            foo();\n+            s.stop();\n+        }\n+        RecordedEvent event = e.get();\n+        RecordedEvent outer = o.get();\n+        RecordedEvent inner = i.get();\n+        System.out.println(event);\n+\n+        System.out.println(\"Outer start          : \" + outer.getStartTime());\n+        System.out.println(\"  Method Trace start : \" + event.getStartTime());\n+        System.out.println(\"   Inner start       : \" + inner.getStartTime());\n+        System.out.println(\"   Inner end         : \" + inner.getEndTime());\n+        System.out.println(\"  Method Trace end   : \" + event.getEndTime());\n+        System.out.println(\"Outer end            : \" + outer.getEndTime());\n+\n+        if (event.getStartTime().isBefore(outer.getStartTime())) {\n+            throw new Exception(\"Too early start time\");\n+        }\n+        if (event.getStartTime().isAfter(inner.getStartTime())) {\n+            throw new Exception(\"Too late start time\");\n+        }\n+        if (event.getEndTime().isBefore(inner.getEndTime())) {\n+            throw new Exception(\"Too early end time\");\n+        }\n+        if (event.getEndTime().isAfter(outer.getEndTime())) {\n+            throw new Exception(\"Too late end time\");\n+        }\n+        RecordedMethod method = event.getValue(\"method\");\n+        if (!method.getName().equals(\"bar\")) {\n+            throw new Exception(\"Expected method too be bar()\");\n+        }\n+        RecordedMethod topMethod = event.getStackTrace().getFrames().get(0).getMethod();\n+        if (!topMethod.getName().equals(\"foo\")) {\n+            throw new Exception(\"Expected top frame too be foo()\");\n+        }\n+    }\n+\n+    private static void foo() {\n+        OuterMeasurement event = new OuterMeasurement();\n+        event.begin();\n+        bar();\n+        event.commit();\n+    }\n+\n+    private static void bar() {\n+        InnerMeasurement event = new InnerMeasurement();\n+        event.begin();\n+        event.commit();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestMethodTrace.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,221 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.EventNames;\n+\/**\n+ * @test\n+ * @summary Tests that method tracing can be used with multiple recordings.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm\n+ *           -Xlog:jfr+methodtrace=debug\n+ *           jdk.jfr.event.tracing.TestMultipleRecordings\n+ **\/\n+public class TestMultipleRecordings {\n+    private static final String METHOD_TRACE = \"jdk.MethodTrace\";\n+    private static final String METHOD_TIMING = \"jdk.MethodTiming\";\n+    private static final String CLASS_NAME = TestMultipleRecordings.class.getName();\n+\n+    public static void main(String... args) throws Exception {\n+        testNestedMethodTrace();\n+        testNestedMethodTiming();\n+    }\n+\n+    private static void testNestedMethodTiming() throws Exception {\n+        List<RecordedEvent> outerEvents = new ArrayList<>();\n+        List<RecordedEvent> innerEvents = new ArrayList<>();\n+\n+        runNested(METHOD_TIMING, outerEvents, innerEvents);\n+        var outerBatches = groupByEndTime(outerEvents);\n+        System.out.println(\"Number of outer batches: \" + outerBatches.size());\n+        \/\/ Outer started\n+        assertTimingBatch(\"outer: started\", outerBatches.get(0), Map.of(\"foo\", 0, \"baz\", 0));\n+        assertTimingBatch(\"outer: initial to bestarted\", outerBatches.get(1), Map.of(\"foo\", 1, \"baz\", 1));\n+        \/\/ Inner started\n+        assertTimingBatch(\"outer: inner started\", outerBatches.get(2), Map.of(\"foo\", 1, \"baz\", 1, \"bar\", 0));\n+        assertTimingBatch(\"outer: inner ended\", outerBatches.get(3), Map.of(\"foo\", 2, \"baz\", 2, \"bar\", 1));\n+        \/\/ Inner stopped\n+        assertTimingBatch(\"outer: only outer\", outerBatches.get(4), Map.of(\"foo\", 2, \"baz\", 2));\n+        assertTimingBatch(\"outer: ending\", outerBatches.get(5), Map.of(\"foo\", 3, \"baz\", 3));\n+        \/\/ Outer stopped\n+\n+        var innerBatches = groupByEndTime(innerEvents);\n+        System.out.println(\"Number of inner batches: \" + innerBatches.size());\n+        assertTimingBatch(\"inner: started\", innerBatches.get(0), Map.of(\"foo\", 1, \"baz\", 1, \"bar\", 0));\n+        assertTimingBatch(\"inner: ended\", innerBatches.get(1), Map.of(\"foo\", 2, \"baz\", 2, \"bar\", 1));\n+    }\n+\n+    private static void assertTimingBatch(String batchName, List<RecordedEvent> events, Map<String, Integer> expected) throws Exception {\n+        Map<String, Integer> map = new HashMap<>();\n+        for (RecordedEvent e : events) {\n+            RecordedMethod m = e.getValue(\"method\");\n+            String name = m.getName();\n+            int invocations = (int) e.getLong(\"invocations\");\n+            map.put(name, invocations);\n+        }\n+        if (!map.equals(expected)) {\n+            printBatch(\"Expected:\", expected);\n+            printBatch(\"Was:\", map);\n+            throw new Exception(\"Batch '\" + batchName + \"' not as expected\");\n+        }\n+    }\n+\n+    private static void printBatch(String name, Map<String, Integer> batch) {\n+        System.out.println(name);\n+        for (var entry : batch.entrySet()) {\n+            System.out.println(entry.getKey() + \" = \" + entry.getValue());\n+        }\n+    }\n+\n+    private static List<List<RecordedEvent>> groupByEndTime(List<RecordedEvent> events) {\n+        var listList = new ArrayList<List<RecordedEvent>>();\n+        List<RecordedEvent> list = null;\n+        Instant last = null;\n+        while (!events.isEmpty()) {\n+            RecordedEvent event = removeEarliest(events);\n+            Instant timestamp = event.getEndTime();\n+            if (last == null || !timestamp.equals(last)) {\n+                list = new ArrayList<RecordedEvent>();\n+                listList.add(list);\n+            }\n+            list.add(event);\n+            last = event.getEndTime();\n+        }\n+        return listList;\n+    }\n+\n+    private static RecordedEvent removeEarliest(List<RecordedEvent> events) {\n+        RecordedEvent earliest = null;\n+        for (RecordedEvent event : events) {\n+            if (earliest == null || event.getEndTime().isBefore(earliest.getEndTime())) {\n+                earliest = event;\n+            }\n+        }\n+        events.remove(earliest);\n+        return earliest;\n+    }\n+\n+    private static void testNestedMethodTrace() throws Exception {\n+        List<RecordedEvent> outerEvents = new ArrayList<>();\n+        List<RecordedEvent> innerEvents = new ArrayList<>();\n+\n+        runNested(METHOD_TRACE, outerEvents, innerEvents);\n+\n+        assertMethodTraceEvents(outerEvents, \"Outer\", \"foo\", 3);\n+        assertMethodTraceEvents(outerEvents, \"Outer\", \"bar\", 1);\n+        assertMethodTraceEvents(outerEvents, \"Outer\", \"baz\", 3);\n+        assertMethodTraceEvents(innerEvents, \"Inner\", \"foo\", 1);\n+        assertMethodTraceEvents(innerEvents, \"Inner\", \"bar\", 1);\n+        assertMethodTraceEvents(innerEvents, \"Inner\", \"baz\", 1);\n+    }\n+\n+    private static void runNested(String eventName, List<RecordedEvent> outerEvents, List<RecordedEvent> innerEvents)\n+            throws IOException {\n+        try (Recording outer = new Recording()) {\n+            outer.enable(eventName).with(\"filter\",\n+               CLASS_NAME + \"::foo;\" +\n+               CLASS_NAME + \"::baz\");\n+            outer.start();\n+            foo();\n+            bar();\n+            baz();\n+            nap();\n+            try (Recording inner = new Recording()) {\n+                inner.enable(eventName).with(\"filter\",\n+                    CLASS_NAME + \"::foo;\" +\n+                    CLASS_NAME + \"::bar\");\n+                inner.start();\n+                foo();\n+                bar();\n+                baz();\n+                inner.stop();\n+                innerEvents.addAll(Events.fromRecording(inner));\n+                nap();\n+            }\n+            foo();\n+            bar();\n+            baz();\n+            nap();\n+            outer.stop();\n+            outerEvents.addAll(Events.fromRecording(outer));\n+        }\n+    }\n+\n+    \/\/ Ensure that periodic events at endChunk get a different\n+    \/\/ timestamp than periodic events at beginChunk\n+    private static void nap() {\n+        Instant time = Instant.now();\n+        do {\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException e) {\n+                \/\/ ignore\n+            }\n+        } while (time.plus(Duration.ofMillis(10)).isAfter(Instant.now()));\n+    }\n+\n+    private static void assertMethodTraceEvents(List<RecordedEvent> events, String context, String methodName, int expected) throws Exception {\n+        int actual = 0;\n+        for (RecordedEvent event : events) {\n+            RecordedMethod method = event.getValue(\"method\");\n+            if (method.getName().equals(methodName)) {\n+                actual++;\n+            }\n+        }\n+        if (actual != expected) {\n+            System.out.println(context);\n+            for (RecordedEvent event : events) {\n+                System.out.println(event);\n+            }\n+            throw new Exception(context + \": expected \" + expected + \" events for method \" + methodName + \", got actual \" + actual);\n+        }\n+    }\n+\n+    private static void foo() {\n+        System.out.println(\"Executing: foo()\");\n+    }\n+\n+    private static void bar() {\n+        System.out.println(\"Executing: bar()\");\n+    }\n+\n+    private static void baz() {\n+        System.out.println(\"Executing: baz()\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestMultipleRecordings.java","additions":221,"deletions":0,"binary":false,"changes":221,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests that tracing and timing work when using multiple threads.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm\n+ *           -Xlog:jfr+methodtrace=trace\n+ *           jdk.jfr.event.tracing.TestMultipleThreads\n+ **\/\n+public class TestMultipleThreads {\n+    private static final String METHOD_PREFIX = TestMultipleThreads.class.getName() + \"::method\";\n+    private static final String TRACE_EVENT = \"jdk.MethodTrace\";\n+    private static final String TIMING_EVENT = \"jdk.MethodTiming\";\n+    private static int METHOD_COUNT = 5;\n+    private static int THREAD_COUNT = 5;\n+    private static int INVOCATIONS_PER_THREAD = 25_000; \/\/ Low enough to fit one chunk\n+    private static int INVOCATIONS_PER_METHOD = THREAD_COUNT * INVOCATIONS_PER_THREAD \/ METHOD_COUNT;\n+\n+    public static class TestThread extends Thread {\n+        public void run() {\n+            for (int i = 0; i < INVOCATIONS_PER_THREAD; i++) {\n+                switch (i % METHOD_COUNT) {\n+                case 0 -> method0();\n+                case 1 -> method1();\n+                case 2 -> method2();\n+                case 3 -> method3();\n+                case 4 -> method4();\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        List<RecordedEvent> traceEvents = new ArrayList<>();\n+        List<RecordedEvent> timingEvents = new ArrayList<>();\n+        try (RecordingStream r = new RecordingStream()) {\n+            r.enable(TRACE_EVENT).with(\"filter\",\n+                METHOD_PREFIX + \"0;\" +\n+                METHOD_PREFIX + \"2;\");\n+            r.enable(TIMING_EVENT).with(\"filter\",\n+                METHOD_PREFIX + \"0;\" +\n+                METHOD_PREFIX + \"1;\" +\n+                METHOD_PREFIX + \"2;\" +\n+                METHOD_PREFIX + \"3;\" +\n+                METHOD_PREFIX + \"4;\")\n+             .with(\"period\", \"endChunk\");\n+            List<TestThread> threads = new ArrayList<>();\n+            for (int i = 0; i < THREAD_COUNT; i++) {\n+                threads.add(new TestThread());\n+            }\n+            r.setReuse(false);\n+            r.onEvent(TRACE_EVENT, traceEvents::add);\n+            r.onEvent(TIMING_EVENT, timingEvents::add);\n+            r.startAsync();\n+            for (TestThread t : threads) {\n+                t.start();\n+            }\n+            for (TestThread t : threads) {\n+                t.join();\n+            }\n+            r.stop();\n+            verifyTraceEvents(traceEvents);\n+            for (RecordedEvent event : timingEvents) {\n+                System.out.println(event);\n+            }\n+            verifyTimingEvents(timingEvents);\n+        }\n+    }\n+\n+    private static void verifyTimingEvents(List<RecordedEvent> events) throws Exception {\n+        for (RecordedEvent e : events) {\n+            long invocations = e.getLong(\"invocations\");\n+            if (invocations != INVOCATIONS_PER_METHOD) {\n+                RecordedMethod method = e.getValue(\"method\");\n+                String msg = \"Expected \" + INVOCATIONS_PER_METHOD + \" invocations for \";\n+                msg += method.getName() + \", but got \" + invocations;\n+                throw new Exception(msg);\n+            }\n+        }\n+        if (events.size() != METHOD_COUNT) {\n+            throw new Exception(\"Expected \" + METHOD_COUNT + \" timing events, one per method\");\n+        }\n+    }\n+\n+    private static void verifyTraceEvents(List<RecordedEvent> events) throws Exception {\n+        int expected = 2 * INVOCATIONS_PER_METHOD;\n+        if (events.size() != expected) {\n+            throw new Exception(\"Expected \" + expected + \" event, but got \" + events.size());\n+        }\n+    }\n+\n+    private static void method0() {\n+    }\n+\n+    private static void method1() {\n+    }\n+\n+    private static void method2() {\n+    }\n+\n+    private static void method3() {\n+    }\n+\n+    private static void method4() {\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestMultipleThreads.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.jfr.FlightRecorder;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test\n+ * @summary Tests that restricted classes cannot be timed or traced.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.tracing.TestRestrictedClasses\n+ **\/\n+public class TestRestrictedClasses {\n+\n+    public static void main(String... args) throws Exception {\n+        testJdkJfr();\n+        testConcurrentHashMap();\n+        testConcurrentHashMapNode();\n+        testAtomicLong();\n+    }\n+\n+    private static void testJdkJfr() throws Exception {\n+        testDebug(FlightRecorder.class.getName(), null);\n+    }\n+\n+    private static void testConcurrentHashMapNode() throws Exception {\n+        testDebug(ConcurrentHashMap.class.getName() + \"$Node\", \"Risk of recursion, skipping bytecode generation for java.util.concurrent.ConcurrentHashMap$Node\");\n+    }\n+\n+    private static void testConcurrentHashMap() throws Exception {\n+        testDebug(ConcurrentHashMap.class.getName(), \"Risk of recursion, skipping bytecode generation for java.util.concurrent.ConcurrentHashMap\");\n+    }\n+\n+    private static void testAtomicLong() throws Exception {\n+        testDebug(AtomicLong.class.getName(), \"Risk of recursion, skipping bytecode generation for java.util.concurrent.atomic.AtomicLong\");\n+    }\n+\n+    private static void testDebug(String clazz, String expected) throws Exception {\n+        List<String> cmds = new ArrayList<>();\n+        cmds.add(\"-Xlog:jfr+methodtrace=debug\");\n+        cmds.add(\"-XX:StartFlightRecording:method-trace=\" + clazz);\n+        cmds.add(\"-version\");\n+        OutputAnalyzer out = ProcessTools.executeTestJava(cmds);\n+        out.shouldHaveExitValue(0);\n+        if (expected != null) {\n+            out.shouldContain(expected);\n+        }\n+        \/\/ Check that bytecode was not generated\n+        out.shouldNotMatch(\"Bytecode generation\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestRestrictedClasses.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @summary Tests that tracing doesn't work retransformation disabled.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm\n+ *     -Xlog:jfr+methodtrace=info\n+ *     -XX:FlightRecorderOptions:retransform=false\n+ *     jdk.jfr.event.tracing.TestRetransformFalse false\n+ * @run main\/othervm -Xlog:jfr+methodtrace=info\n+ *      -Xlog:jfr+methodtrace=info\n+ *      -XX:FlightRecorderOptions:retransform=true\n+ *      jdk.jfr.event.tracing.TestRetransformFalse true\n+ **\/\n+public class TestRetransformFalse {\n+    private static final String FILTER = \"jdk.jfr.event.tracing.TestRetransformFalse::foo\";\n+    public static void main(String... args) throws Exception {\n+        boolean retransform = switch (args[0]) {\n+            case \"true\" -> true;\n+            case \"false\" -> false;\n+            default -> throw new Exception(\"Test error, expected 'true' or 'false' argument to test.\");\n+        };\n+        System.out.println(\"Testing -XX:FlightRecorderOptions:retransform=\" + retransform);\n+        try (Recording r = new Recording()) {\n+            r.enable(\"jdk.MethodTrace\")\n+             .with(\"filter\", FILTER);\n+            r.enable(\"jdk.MethodTiming\")\n+             .with(\"filter\", FILTER)\n+             .with(\"period\", \"endChunk\");\n+            r.start();\n+            foo();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            System.out.println(events);\n+            if (retransform) {\n+                Events.assertEventCount(events, 2);\n+            } else {\n+                Events.assertEventCount(events, 0);\n+            }\n+        }\n+    }\n+\n+    private static void foo() {\n+        System.out.println(\"Running Foo\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestRetransformFalse.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests that filters can be applied to classes across multiple class loaders and that\n+ *          method tracing works after class unloading.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build jdk.jfr.event.tracing.Car\n+ * @run main\/othervm -XX:-DisableExplicitGC -Xlog:jfr+methodtrace=trace\n+ *      jdk.jfr.event.tracing.TestWithClassLoaders\n+ **\/\n+public class TestWithClassLoaders {\n+    private static final String METHOD_TRACE = \"jdk.MethodTrace\";\n+    private static final String METHOD_TIMING = \"jdk.MethodTiming\";\n+    private static final String CLASS_NAME = \"jdk.jfr.event.tracing.Car\";\n+\n+    public static void main(String... args) throws Exception {\n+        var traceEvents = new CopyOnWriteArrayList<RecordedEvent>();\n+        var timingEvents = new CopyOnWriteArrayList<RecordedEvent>();\n+        try (var r = new RecordingStream()) {\n+            Runnable beforeCar = createCar(\"before\");\n+            r.setReuse(false);\n+            r.enable(METHOD_TRACE)\n+             .with(\"filter\", CLASS_NAME + \"::run\");\n+            r.enable(METHOD_TIMING)\n+             .with(\"filter\", CLASS_NAME + \"::run\").with(\"period\", \"endChunk\");\n+            r.onEvent(METHOD_TRACE, traceEvents::add);\n+            r.onEvent(METHOD_TIMING, timingEvents::add);\n+            r.startAsync();\n+            Runnable duringCar = createCar(\"during\");\n+            Runnable garbageCar = createCar(\"garbage\");\n+            beforeCar.run();\n+            duringCar.run();\n+            garbageCar.run();\n+            garbageCar = null;\n+            System.gc();\n+            System.gc();\n+            r.stop();\n+            System.out.println(\"Method Trace events:\");\n+            System.out.println(traceEvents);\n+            if (traceEvents.size() != 3) {\n+                throw new Exception(\"Expected 3 Method Trace events, one for each class loader\");\n+            }\n+            for (RecordedEvent event : traceEvents) {\n+                RecordedMethod method = event.getValue(\"method\");\n+                String methodName = method.getName();\n+                if (!methodName.equals(\"run\")) {\n+                    throw new Exception(\"Expected method name to be 'run'\");\n+                }\n+            }\n+            System.out.println(\"Method Timing events:\");\n+            System.out.println(timingEvents);\n+            if (timingEvents.size() != 3) {\n+                throw new Exception(\"Expected 3 Method Timing events, one for each class loader\");\n+            }\n+            int totalInvocations = 0;\n+            for (RecordedEvent event : timingEvents) {\n+                totalInvocations += event.getLong(\"invocations\");\n+            }\n+            if (totalInvocations != 3) {\n+                throw new Exception(\"Expected three invocations in total, was \" + totalInvocations);\n+            }\n+        }\n+    }\n+\n+    public static Runnable createCar(String name) throws Exception {\n+        byte[] bytes = loadCarBytes();\n+        ClassLoader parent = TestWithClassLoaders.class.getClassLoader();\n+        CarLoader loader = new CarLoader(name, bytes, parent);\n+        Class<?> clazz = loader.loadClass(CLASS_NAME);\n+        Object instance = clazz.getConstructor().newInstance();\n+        return (Runnable) instance;\n+    }\n+\n+    private static byte[] loadCarBytes() throws IOException {\n+        String location = \"\/\" + CLASS_NAME.replaceAll(\"\\\\.\", \"\/\").concat(\".class\");\n+        try (var is = TestWithClassLoaders.class.getResourceAsStream(location)) {\n+            return is.readAllBytes();\n+        }\n+    }\n+\n+    public static class CarLoader extends ClassLoader {\n+        private final byte[] bytes;\n+\n+        public CarLoader(String name, byte[] bytes, ClassLoader parent) {\n+            super(name, parent);\n+            this.bytes = bytes;\n+        }\n+\n+        protected Class<?> loadClass(String className, boolean resolve) throws ClassNotFoundException {\n+            Class<?> clazz = findLoadedClass(className);\n+            if (clazz == null && className.equals(CLASS_NAME)) {\n+                clazz = defineClass(className, bytes, 0, bytes.length);\n+            } else {\n+                clazz = super.loadClass(className, resolve);\n+            }\n+            if (resolve) {\n+                resolveClass(clazz);\n+            }\n+            return clazz;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestWithClassLoaders.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.tracing;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.jfr.Recording;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.jfr.consumer.EventStream;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests applying filters to methods in both exported and unexported packages\n+ *          of a named module.\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.tracing.TestWithModules\n+ **\/\n+public class TestWithModules {\n+\n+    \/** Directory structure:\n+         |-src\n+           |-application\n+           | |-Main.java\n+           |-module\n+             |-module-info.java\n+             |-test\n+               |-exported\n+               | |- Exported.java\n+               |-unexported\n+                 |- UnExported.java\n+    **\/\n+    private static String MODULE_INFO =\n+    \"\"\"\n+    module test.exported {\n+       exports test.exported;\n+    }\n+    \"\"\";\n+\n+    private static String EXPORTED_CLASS =\n+    \"\"\"\n+    package test.exported;\n+\n+    import test.unexported.Unexported;\n+\n+    public class Exported {\n+       public static void run() {\n+          System.out.println(\"Exported::run executed!\");\n+          Unexported.run();\n+       }\n+    }\n+    \"\"\";\n+\n+    private static String UNEXPORTED_CLASS =\n+    \"\"\"\n+    package test.unexported;\n+\n+    public class Unexported {\n+       public static void run() {\n+          System.out.println(\"Unexported::run executed!\");\n+       }\n+    }\n+    \"\"\";\n+\n+    private static String MAIN_CLASS =\n+    \"\"\"\n+    import test.exported.Exported;\n+    import jdk.jfr.Recording;\n+    import java.nio.file.Path;\n+\n+    public class Main {\n+       public static void main(String... args) throws Exception {\n+          Path file = Path.of(args[0]);\n+          boolean before = args[1].equals(\"run-before\");\n+          System.out.println(\"Main before=\" + before);\n+          try(Recording r = new Recording()) {\n+            if (before) {\n+              \/\/ Load class before JFR starts\n+              Exported.run();\n+            }\n+            r.enable(\"jdk.MethodTrace\").with(\"filter\", \"test.unexported.Unexported::run\");\n+            r.enable(\"jdk.MethodTiming\").with(\"filter\", \"test.unexported.Unexported::run\").with(\"period\", \"endChunk\");\n+            r.start();\n+            System.out.println(\"About to run with instrumented\");\n+            Exported.run();\n+            r.stop();\n+            r.dump(file);\n+            System.out.println(\"Dump written \" + file);\n+          }\n+       }\n+    }\n+    \"\"\";\n+\n+    public static void main(String... args) throws Exception {\n+        Path src = Path.of(\"src\").toAbsolutePath();\n+        Path modulePath = materializeModule(src);\n+        Path mainFile = materializeMain(src);\n+        Path output = Files.createDirectory(Path.of(\"output\").toAbsolutePath());\n+        List<Path> srcFiles = Files.walk(modulePath).filter(Files::isRegularFile).toList();\n+        List<String> arguments = new ArrayList<>();\n+        arguments.add(\"-d\");\n+        arguments.add(output.toString());\n+        for (Path p : srcFiles) {\n+            arguments.add(p.toAbsolutePath().toString());\n+        }\n+        if (!compile(arguments)) {\n+            throw new Exception(\"Could not compile classes\");\n+        }\n+        testClassloadBefore(mainFile, output);\n+        testClassloadDuring(mainFile, output);\n+    }\n+\n+    private static Path materializeMain(Path src) throws IOException {\n+        Path srcApplication = Files.createDirectories(src.resolve(\"application\"));\n+        Path mainFile = srcApplication.resolve(\"Main.java\");\n+        Files.writeString(mainFile, MAIN_CLASS);\n+        return mainFile;\n+    }\n+\n+    private static void testClassloadBefore(Path mainFile, Path modulePath) throws Exception {\n+        Path file = Path.of(\"before.jfr\").toAbsolutePath();\n+        execute(file, mainFile, modulePath, true);\n+        verifyRecording(\"already loaded class\", file);\n+    }\n+\n+    private static void testClassloadDuring(Path mainFile, Path modulePath) throws Exception {\n+        Path file = Path.of(\"during.jfr\").toAbsolutePath();\n+        execute(file, mainFile, modulePath, false);\n+        verifyRecording(\"loading of class\", file);\n+    }\n+\n+    private static void verifyRecording(String title, Path file) throws Exception {\n+        List<RecordedEvent> traceEvents = new ArrayList<>();\n+        List<RecordedEvent> timingEvents = new ArrayList<>();\n+        System.out.println(\"********* Verifying \" + title + \" ********\");\n+        try (EventStream s = EventStream.openFile(file)) {\n+            s.setReuse(false);\n+            s.onEvent(\"jdk.MethodTrace\", traceEvents::add);\n+            s.onEvent(\"jdk.MethodTiming\", timingEvents::add);\n+            s.onEvent(System.out::println);\n+            s.start();\n+        }\n+        assertMethod(traceEvents, \"test.unexported.Unexported\", \"run\");\n+        assertMethod(timingEvents, \"test.unexported.Unexported\", \"run\");\n+        assertMethodTimingCount(timingEvents.get(0), 1);\n+    }\n+\n+    private static void assertMethodTimingCount(RecordedEvent event, int expected) throws Exception {\n+        long invocations = event.getLong(\"invocations\");\n+        if (invocations != expected) {\n+            throw new Exception(\"Expected invocations to be \" + expected + \", but was \" + invocations);\n+        }\n+    }\n+\n+    private static void assertMethod(List<RecordedEvent> events, String className, String methodName) throws Exception {\n+        for (RecordedEvent event : events) {\n+            RecordedMethod method = event.getValue(\"method\");\n+            if (method.getName().equals(methodName) && method.getType().getName().equals(className)) {\n+                return;\n+            }\n+        }\n+        throw new Exception(\"Expected method named \" + className + \"::\" + methodName);\n+    }\n+\n+    private static void execute(Path jfrFile, Path mainFile, Path modulePath, boolean before) throws Exception {\n+        String[] c = new String[7];\n+        c[0] = \"--module-path\";\n+        c[1] = modulePath.toString();\n+        c[2] = \"--add-modules\";\n+        c[3] = \"test.exported\";\n+        c[4] = mainFile.toString();\n+        c[5] = jfrFile.toString();\n+        c[6] = before ? \"run-before\" : \"not-run-before\";\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(c);\n+        oa.waitFor();\n+        oa.shouldHaveExitValue(0);\n+    }\n+\n+    private static Path materializeModule(Path src) throws IOException {\n+        Path srcModule = Files.createDirectories(src.resolve(\"module\"));\n+        Path moduleFile = srcModule.resolve(\"module-info.java\");\n+        Files.writeString(moduleFile, MODULE_INFO);\n+\n+        Path exported = Files.createDirectories(srcModule.resolve(\"test\").resolve(\"exported\"));\n+        Path exportedJava = exported.resolve(\"Exported.java\");\n+        Files.writeString(exportedJava, EXPORTED_CLASS);\n+\n+        Path unexported = Files.createDirectories(srcModule.resolve(\"test\").resolve(\"unexported\"));\n+        Path unexportedJava = unexported.resolve(\"Unexported.java\");\n+        Files.writeString(unexportedJava, UNEXPORTED_CLASS);\n+\n+        return srcModule;\n+    }\n+\n+    private static boolean compile(List<String> arguments) {\n+        Optional<ToolProvider> tp = ToolProvider.findFirst(\"javac\");\n+        if (tp.isEmpty()) {\n+            return false;\n+        }\n+        var tool = tp.get();\n+        String[] options = arguments.toArray(String[]::new);\n+        int ret = tool.run(System.out, System.err, options);\n+        return ret == 0;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/tracing\/TestWithModules.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -94,0 +94,2 @@\n+    public static final String MethodTiming = PREFIX + \"MethodTiming\";\n+    public static final String MethodTrace = PREFIX + \"MethodTrace\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -364,0 +364,10 @@\n+    public static RecordedEvent getFirst(List<RecordedEvent> events, String name) throws Exception {\n+        for (RecordedEvent event : events) {\n+            if (event.getEventType().getName().equals(name)) {\n+                return event;\n+            }\n+        }\n+        Asserts.fail(\"Missing event \" + name + \" in recording \" + events.toString());\n+        return null;\n+    }\n+\n@@ -373,0 +383,6 @@\n+    public static void assertEventCount(List<RecordedEvent> events, int count) throws Exception {\n+        if (events.size() != count) {\n+            throw new Exception(\"Expected \" + count + \" events, found \" + events.size());\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/Events.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}