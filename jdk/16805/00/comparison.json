{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    private static Map<HostIdentifier, MonitoredHost> monitoredHosts =\n+    private static final Map<HostIdentifier, MonitoredHost> monitoredHosts =\n@@ -140,1 +140,3 @@\n-    private static ServiceLoader<MonitoredHostService> monitoredHostServiceLoader =\n+    \/\/ not thread safe, access MUST be guarded through synchronization on \"monitoredHosts\"\n+    \/\/ field\n+    private static final ServiceLoader<MonitoredHostService> monitoredHostServiceLoader =\n@@ -158,1 +160,1 @@\n-            mh = monitoredHosts.get(hostId);\n+            mh = getCachedMonitoredHost(hostId);\n@@ -160,5 +162,1 @@\n-                if (mh.isErrored()) {\n-                    monitoredHosts.remove(hostId);\n-                } else {\n-                    return mh;\n-                }\n+                return mh;\n@@ -170,3 +168,6 @@\n-        for (MonitoredHostService mhs : monitoredHostServiceLoader) {\n-            if (mhs.getScheme().equals(hostId.getScheme())) {\n-                mh = mhs.getMonitoredHost(hostId);\n+        synchronized(monitoredHosts) {\n+            \/\/ re-check the internal cache before attempting to find a Service\n+            \/\/ capable of returning a MonitoredHost from this HostIdentifier\n+            mh = getCachedMonitoredHost(hostId);\n+            if (mh != null) {\n+                return mh;\n@@ -174,0 +175,11 @@\n+            for (MonitoredHostService mhs : monitoredHostServiceLoader) {\n+                if (mhs.getScheme().equals(hostId.getScheme())) {\n+                    mh = mhs.getMonitoredHost(hostId);\n+                    break;\n+                }\n+            }\n+            if (mh == null) {\n+                throw new IllegalArgumentException(\"Could not find MonitoredHost for scheme: \" + hostId.getScheme());\n+            }\n+            \/\/ add it to the internal cache\n+            monitoredHosts.put(mh.hostId, mh);\n@@ -176,0 +188,9 @@\n+        return mh;\n+    }\n+\n+    \/\/ from an internal cache returns a MonitoredHost, if present, for the HostIdentifier.\n+    \/\/ Else returns null. The thread calling this method must hold the monitor lock on\n+    \/\/ \"monitoredHosts\" field\n+    private static MonitoredHost getCachedMonitoredHost(final HostIdentifier hostId) {\n+        assert Thread.holdsLock(monitoredHosts) : \"called without holding a lock\";\n+        MonitoredHost mh = monitoredHosts.get(hostId);\n@@ -177,1 +198,1 @@\n-            throw new IllegalArgumentException(\"Could not find MonitoredHost for scheme: \" + hostId.getScheme());\n+            return null;\n@@ -179,3 +200,4 @@\n-\n-        synchronized(monitoredHosts) {\n-            monitoredHosts.put(mh.hostId, mh);\n+        \/\/ remove any errored MonitorHost from the cache\n+        if (mh.isErrored()) {\n+            monitoredHosts.remove(hostId);\n+            return null;\n@@ -183,1 +205,0 @@\n-\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/monitor\/MonitoredHost.java","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import sun.jvmstat.monitor.MonitoredHost;\n+import sun.jvmstat.monitor.VmIdentifier;\n+\n+\/*\n+ * @test\n+ * @bug 8320687\n+ * @summary verify that sun.jvmstat.monitor.MonitoredHost.getMonitoredHost() doesn't\n+ *          unexpectedly throw an exception when invoked by concurrent threads\n+ *\n+ * @run main\/othervm GetMonitoredHost\n+ *\/\n+public class GetMonitoredHost {\n+\n+    \/*\n+     * Launches multiple concurrent threads and invokes MonitoredHost.getMonitoredHost()\n+     * in each of these threads and expects the call to return successfully without any\n+     * exceptions.\n+     *\/\n+    public static void main(final String[] args) throws Exception {\n+        final String pidStr = \"12345\";\n+        final VmIdentifier vmid = new VmIdentifier(pidStr);\n+        final int numTasks = 100;\n+        final List<Task> tasks = new ArrayList<>();\n+        for (int i = 0; i < numTasks; i++) {\n+            tasks.add(new Task(vmid));\n+        }\n+        System.out.println(\"Submitting \" + numTasks + \" concurrent tasks to\" +\n+                \" get MonitoredHost for \" + vmid);\n+        try (ExecutorService executor = Executors.newCachedThreadPool()) {\n+            \/\/ wait for all tasks to complete\n+            final List<Future<MonitoredHost>> results = executor.invokeAll(tasks);\n+            \/\/ verify each one successfully completed and each of\n+            \/\/ the returned MonitoredHost is not null\n+            for (final Future<MonitoredHost> result : results) {\n+                final MonitoredHost mh = result.get();\n+                if (mh == null) {\n+                    throw new AssertionError(\"MonitoredHost.getMonitoredHost() returned\" +\n+                            \" null for vmid \" + vmid);\n+                }\n+            }\n+        }\n+        System.out.println(\"All \" + numTasks + \" completed successfully\");\n+    }\n+\n+    \/\/ a task which just calls MonitoredHost.getMonitoredHost(VmIdentifier) and\n+    \/\/ returns the resultant MonitoredHost\n+    private static final class Task implements Callable<MonitoredHost> {\n+        private final VmIdentifier vmid;\n+\n+        private Task(final VmIdentifier vmid) {\n+            this.vmid = Objects.requireNonNull(vmid);\n+        }\n+\n+        @Override\n+        public MonitoredHost call() throws Exception {\n+            return MonitoredHost.getMonitoredHost(this.vmid);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/MonitoredVm\/GetMonitoredHost.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}