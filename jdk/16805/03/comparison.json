{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    private static Map<HostIdentifier, MonitoredHost> monitoredHosts =\n+    private static final Map<HostIdentifier, MonitoredHost> monitoredHosts =\n@@ -136,7 +136,0 @@\n-\n-    \/*\n-     * Load the MonitoredHostServices\n-     *\/\n-    private static ServiceLoader<MonitoredHostService> monitoredHostServiceLoader =\n-        ServiceLoader.load(MonitoredHostService.class, MonitoredHostService.class.getClassLoader());\n-\n@@ -170,1 +163,3 @@\n-        for (MonitoredHostService mhs : monitoredHostServiceLoader) {\n+        ServiceLoader<MonitoredHostService> services = ServiceLoader.load(\n+                MonitoredHostService.class, MonitoredHostService.class.getClassLoader());\n+        for (MonitoredHostService mhs : services) {\n@@ -173,0 +168,1 @@\n+                break;\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/monitor\/MonitoredHost.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+import sun.jvmstat.monitor.MonitoredHost;\n+import sun.jvmstat.monitor.VmIdentifier;\n+\n+\/*\n+ * @test\n+ * @bug 8320687\n+ * @summary verify that sun.jvmstat.monitor.MonitoredHost.getMonitoredHost() doesn't\n+ *          unexpectedly throw an exception when invoked by concurrent threads\n+ *\n+ * @run main\/othervm ConcurrentGetMonitoredHost\n+ *\/\n+public class ConcurrentGetMonitoredHost {\n+\n+    \/*\n+     * Launches multiple concurrent threads and invokes MonitoredHost.getMonitoredHost()\n+     * in each of these threads and expects the call to return successfully without any\n+     * exceptions.\n+     *\/\n+    public static void main(final String[] args) throws Exception {\n+        final String pidStr = \"12345\";\n+        final VmIdentifier vmid = new VmIdentifier(pidStr);\n+        final int numTasks = 100;\n+        final List<Task> tasks = new ArrayList<>();\n+        for (int i = 0; i < numTasks; i++) {\n+            tasks.add(new Task(vmid));\n+        }\n+        System.out.println(\"Submitting \" + numTasks + \" concurrent tasks to\" +\n+                \" get MonitoredHost for \" + vmid);\n+        try (ExecutorService executor = Executors.newCachedThreadPool()) {\n+            \/\/ wait for all tasks to complete\n+            final List<Future<MonitoredHost>> results = executor.invokeAll(tasks);\n+            \/\/ verify each one successfully completed and each of\n+            \/\/ the returned MonitoredHost is not null\n+            for (final Future<MonitoredHost> result : results) {\n+                final MonitoredHost mh = result.get();\n+                if (mh == null) {\n+                    throw new AssertionError(\"MonitoredHost.getMonitoredHost() returned\" +\n+                            \" null for vmid \" + vmid);\n+                }\n+            }\n+        }\n+        System.out.println(\"All \" + numTasks + \" completed successfully\");\n+    }\n+\n+    \/\/ a task which just calls MonitoredHost.getMonitoredHost(VmIdentifier) and\n+    \/\/ returns the resultant MonitoredHost\n+    private static final class Task implements Callable<MonitoredHost> {\n+        private final VmIdentifier vmid;\n+\n+        private Task(final VmIdentifier vmid) {\n+            this.vmid = Objects.requireNonNull(vmid);\n+        }\n+\n+        @Override\n+        public MonitoredHost call() throws Exception {\n+            return MonitoredHost.getMonitoredHost(this.vmid);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/MonitoredVm\/ConcurrentGetMonitoredHost.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}