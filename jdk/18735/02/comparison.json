{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -982,2 +983,31 @@\n-    \/\/ This is probably the best overall implementation -- we'll\n-    \/\/ likely make this the default in future releases.\n+    \/\/ This is probably the best overall implementation, therefore it\n+    \/\/ is the default one.\n+    if (current->_hashStateX == 0) {\n+      \/\/ We initialize the seed lazily, the first time we generate an ihash\n+      \/\/ on a thread; see comment below.\n+      int initial_seed;\n+      if (CDSConfig::is_dumping_archive()) {\n+        \/\/ If we are dumping, we want ihashes to be deterministic. They should be\n+        \/\/ as invulnerable as possible against concurrent activity happening in other\n+        \/\/ threads. That rules out using os::random for initializing the seed, even\n+        \/\/ if we were to set its seed constant, since concurrent threads may call\n+        \/\/ os::random and \"eat\" from \"our\" random sequence.\n+        \/\/ When dumping CDS archives, two threads generate ihashes: the initial\n+        \/\/ java main thread, and the VMThread dumping the archive. Thankfully they don't\n+        \/\/ run concurrently. but in sequence. CDS inhibits the start of any other java\n+        \/\/ threads during dumping.\n+        \/\/ We need to use constant, deterministic seeds, but also need to prevent\n+        \/\/ these two threads from re-running the same random sequence, since that\n+        \/\/ would generate colliding ihashes. Therefore, we seed the sequence with a\n+        \/\/ constant that is offset by a global counter. That way, the random sequence\n+        \/\/ is deterministic as long as the same threads generate ihashes in the same\n+        \/\/ order.\n+        static int _counter = 0x1234567;\n+        initial_seed = os::next_random(_counter++);\n+        log_debug(cds)(\"Initializing ihash seed for thread \" PTR_FORMAT \" with %u\",\n+                       p2i(current), initial_seed);\n+      } else {\n+        initial_seed = os::random();\n+      }\n+      current->_hashStateW = (jint)initial_seed;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  _hashStateX = os::random();\n+  _hashStateX = 0;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}