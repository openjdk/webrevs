{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -982,3 +983,40 @@\n-    \/\/ This is probably the best overall implementation -- we'll\n-    \/\/ likely make this the default in future releases.\n-    value = current->_hashState.next_random();\n+    \/\/ This is probably the best overall implementation, therefore it\n+    \/\/ is the default one.\n+    if (current->_hashStateX == 0) {\n+      \/\/ We initialize the seed lazily, the first time we generate an ihash\n+      \/\/ on a thread; see comment below.\n+      int initial_seed;\n+      if (CDSConfig::is_dumping_archive()) {\n+        \/\/ If we are dumping, we want ihashes to be deterministic. They should be\n+        \/\/ as invulnerable as possible against concurrent activity happening in other\n+        \/\/ threads. That rules out using os::random for initializing the seed, even\n+        \/\/ if we were to set its seed constant, since concurrent threads may call\n+        \/\/ os::random and \"eat\" from \"our\" random sequence.\n+        \/\/ When dumping CDS archives, two threads generate ihashes: the initial\n+        \/\/ java main thread, and the VMThread dumping the archive. Thankfully they don't\n+        \/\/ run concurrently. but in sequence. CDS inhibits the start of any other java\n+        \/\/ threads during dumping.\n+        \/\/ We need to use constant, deterministic seeds, but also need to prevent\n+        \/\/ these two threads from re-running the same random sequence, since that\n+        \/\/ would generate colliding ihashes. Therefore, we seed the sequence with a\n+        \/\/ constant that is offset by a global counter. That way, the random sequence\n+        \/\/ is deterministic as long as the same threads generate ihashes in the same\n+        \/\/ order.\n+        static int _counter = 0x1234567;\n+        initial_seed = os::next_random(_counter++);\n+        log_debug(cds)(\"Initializing ihash seed for thread \" PTR_FORMAT \" with %u\",\n+                       p2i(current), initial_seed);\n+      } else {\n+        initial_seed = os::random();\n+      }\n+      current->_hashStateW = (jint)initial_seed;\n+    }\n+    unsigned t = current->_hashStateX;\n+    t ^= (t << 11);\n+    current->_hashStateX = current->_hashStateY;\n+    current->_hashStateY = current->_hashStateZ;\n+    current->_hashStateZ = current->_hashStateW;\n+    unsigned v = current->_hashStateW;\n+    v = (v ^ (v >> 19)) ^ (t ^ (t >> 8));\n+    current->_hashStateW = v;\n+    value = v;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -106,0 +105,6 @@\n+  \/\/ thread-specific hashCode stream generator state - Marsaglia shift-xor form\n+  _hashStateX = 0;\n+  _hashStateY = 842502087;\n+  _hashStateZ = 0x8767;    \/\/ (int)(3579807591LL & 0xffff) ;\n+  _hashStateW = 273326509;\n+\n@@ -599,24 +604,0 @@\n-\n-Thread::MarsagliaShiftRNG::MarsagliaShiftRNG() :\n-  _W(0), _X(0), _Y(0), _Z(0), _inited(false) {}\n-\n-unsigned Thread::MarsagliaShiftRNG::next_random() {\n-  if (!_inited) {\n-    _inited = true;\n-    _X = CDSConfig::is_dumping_archive() ?\n-         0x12345678 : \/\/ when dumping, use a constant seed to keep archive generation reproducible\n-         (unsigned) MAX2(1, os::random());\n-    _Y = 842502087;\n-    _Z = 0x8767;    \/\/ (int)(3579807591LL & 0xffff) ;\n-    _W = 273326509;\n-  }\n-  unsigned t = _X;\n-  t ^= (t << 11);\n-  _X = _Y;\n-  _Y = _Z;\n-  _Z = _W;\n-  unsigned v = _W;\n-  v = (v ^ (v >> 19)) ^ (t ^ (t >> 8));\n-  _W = v;\n-  return v;\n-}\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":25,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -620,9 +620,4 @@\n-  \/\/ Marsaglia Shift-XOR thread-local RNG for identity_hash\n-  class MarsagliaShiftRNG {\n-    jint _W, _X, _Y, _Z;\n-    bool _inited;\n-  public:\n-    MarsagliaShiftRNG();\n-    unsigned next_random();\n-  };\n-  MarsagliaShiftRNG _hashState;\n+  jint _hashStateW;                           \/\/ Marsaglia Shift-XOR thread-local RNG\n+  jint _hashStateX;                           \/\/ thread-specific hashCode generator state\n+  jint _hashStateY;\n+  jint _hashStateZ;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"}]}