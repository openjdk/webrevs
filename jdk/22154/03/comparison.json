{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/EventQueue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/NamingEventNotifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -239,1 +239,1 @@\n-                ClassLoader cl = helper.getURLClassLoader(codebases);\n+                ClassLoader cl = Thread.currentThread().getContextClassLoader();\n@@ -249,1 +249,1 @@\n-                    (String)attr.get(), codebases);\n+                    (String)attr.get());\n@@ -371,1 +371,1 @@\n-        String rmiName, String[] codebases) throws NamingException {\n+                                          String rmiName) throws NamingException {\n@@ -413,1 +413,1 @@\n-            ClassLoader cl = helper.getURLClassLoader(codebases);\n+            ClassLoader cl = Thread.currentThread().getContextClassLoader();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Obj.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,7 +28,0 @@\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n@@ -39,5 +32,0 @@\n-    \/**\n-     * Determines whether classes may be loaded from an arbitrary URL code base.\n-     *\/\n-    private static final boolean trustURLCodebase;\n-\n@@ -51,6 +39,0 @@\n-        \/\/ System property to control whether classes may be loaded from an\n-        \/\/ arbitrary URL code base\n-        String trust = getPrivilegedProperty(\n-                \"com.sun.jndi.ldap.object.trustURLCodebase\", \"false\");\n-        trustURLCodebase = \"true\".equalsIgnoreCase(trust);\n-\n@@ -59,1 +41,1 @@\n-        String trustSerialDataSp = getPrivilegedProperty(\n+        String trustSerialDataSp = System.getProperty(\n@@ -64,10 +46,0 @@\n-    @SuppressWarnings(\"removal\")\n-    private static String getPrivilegedProperty(String propertyName, String defaultVal) {\n-        PrivilegedAction<String> action = () -> System.getProperty(propertyName, defaultVal);\n-        if (System.getSecurityManager() == null) {\n-            return action.run();\n-        } else {\n-            return AccessController.doPrivileged(action);\n-        }\n-    }\n-\n@@ -92,14 +64,0 @@\n-    ClassLoader getURLClassLoader(String[] url) throws MalformedURLException {\n-        ClassLoader parent = getContextClassLoader();\n-        \/*\n-         * Classes may only be loaded from an arbitrary URL code base when\n-         * the system property com.sun.jndi.ldap.object.trustURLCodebase\n-         * has been set to \"true\".\n-         *\/\n-        if (url != null && trustURLCodebase) {\n-            return URLClassLoader.newInstance(getUrlArray(url), parent);\n-        } else {\n-            return parent;\n-        }\n-    }\n-\n@@ -107,1 +65,2 @@\n-        return Class.forName(className, true, getContextClassLoader());\n+        return Class.forName(className, true,\n+                             Thread.currentThread().getContextClassLoader());\n@@ -113,16 +72,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n-    private ClassLoader getContextClassLoader() {\n-        PrivilegedAction<ClassLoader> act =\n-                Thread.currentThread()::getContextClassLoader;\n-        return AccessController.doPrivileged(act);\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    private static URL[] getUrlArray(String[] url) throws MalformedURLException {\n-        URL[] urlArray = new URL[url.length];\n-        for (int i = 0; i < urlArray.length; i++) {\n-            urlArray[i] = new URL(url[i]);\n-        }\n-        return urlArray;\n-    }\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/VersionHelper.java","additions":3,"deletions":60,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,3 +184,2 @@\n-            InstantiationException,\n-            MalformedURLException {\n-        Class<?> clas = null;\n+            InstantiationException {\n+        Class<?> clas;\n@@ -196,17 +195,1 @@\n-            \/\/ ignore and continue\n-            \/\/ e.printStackTrace();\n-        }\n-        \/\/ All other exceptions are passed up.\n-\n-        \/\/ Not in class path; try to use codebase\n-        String codebase;\n-        if (clas == null &&\n-                (codebase = ref.getFactoryClassLocation()) != null) {\n-            try {\n-                clas = helper.loadClass(factoryName, codebase);\n-                \/\/ Validate factory's class with the objects factory serial filter\n-                if (clas == null || !filter.test(clas)) {\n-                    return null;\n-                }\n-            } catch (ClassNotFoundException e) {\n-            }\n+            return null;\n@@ -214,1 +197,1 @@\n-\n+        assert clas != null;\n@@ -216,1 +199,1 @@\n-        ObjectFactory result = (clas != null) ? (ObjectFactory) clas.newInstance() : null;\n+        ObjectFactory result = (ObjectFactory) clas.newInstance();\n@@ -404,6 +387,0 @@\n-\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSetFactory();\n-        }\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/naming\/internal\/NamingManagerHelper.java","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.net.MalformedURLException;\n@@ -33,1 +32,0 @@\n-import java.net.URLClassLoader;\n@@ -36,4 +34,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -56,15 +50,0 @@\n-    \/**\n-     * Determines whether classes may be loaded from an arbitrary URL code base.\n-     *\/\n-    private static final boolean TRUST_URL_CODE_BASE;\n-\n-    static {\n-        \/\/ System property to control whether classes may be loaded from an\n-        \/\/ arbitrary URL code base\n-        PrivilegedAction<String> act\n-                = () -> System.getProperty(\"com.sun.jndi.ldap.object.trustURLCodebase\", \"false\");\n-        @SuppressWarnings(\"removal\")\n-        String trust = AccessController.doPrivileged(act);\n-        TRUST_URL_CODE_BASE = \"true\".equalsIgnoreCase(trust);\n-    }\n-\n@@ -104,16 +83,0 @@\n-    \/**\n-     * @param className A non-null fully qualified class name.\n-     * @param codebase  A non-null, space-separated list of URL strings.\n-     *\/\n-    public Class<?> loadClass(String className, String codebase)\n-            throws ClassNotFoundException, MalformedURLException {\n-        if (TRUST_URL_CODE_BASE) {\n-            ClassLoader parent = getContextClassLoader();\n-            ClassLoader cl\n-                    = URLClassLoader.newInstance(getUrlArray(codebase), parent);\n-            return loadClass(className, cl);\n-        } else {\n-            return null;\n-        }\n-    }\n-\n@@ -139,2 +102,1 @@\n-     * null if the property is not set, or if there is no permission\n-     * to read it.\n+     * null if the property is not set.\n@@ -142,1 +104,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -144,8 +105,1 @@\n-        PrivilegedAction<String> act = () -> {\n-            try {\n-                return System.getProperty(PROPS[i]);\n-            } catch (SecurityException e) {\n-                return null;\n-            }\n-        };\n-        return AccessController.doPrivileged(act);\n+        return System.getProperty(PROPS[i]);\n@@ -158,1 +112,0 @@\n-     * Returns null if there is no permission to call System.getProperties().\n@@ -161,9 +114,1 @@\n-        PrivilegedAction<Properties> act = () -> {\n-            try {\n-                return System.getProperties();\n-            } catch (SecurityException e) {\n-                return null;\n-            }\n-        };\n-        @SuppressWarnings(\"removal\")\n-        Properties sysProps = AccessController.doPrivileged(act);\n+        Properties sysProps = System.getProperties();\n@@ -202,1 +147,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -204,8 +148,5 @@\n-        PrivilegedAction<InputStream> act = () -> {\n-            try {\n-                return c.getModule().getResourceAsStream(resolveName(c, name));\n-             } catch (IOException x) {\n-                 return null;\n-             }\n-        };\n-        return AccessController.doPrivileged(act);\n+        try {\n+            return c.getModule().getResourceAsStream(resolveName(c, name));\n+        } catch (IOException x) {\n+            return null;\n+        }\n@@ -220,1 +161,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -222,8 +162,3 @@\n-        PrivilegedAction<InputStream> act = () -> {\n-            try {\n-                String javahome = System.getProperty(\"java.home\");\n-                if (javahome == null) {\n-                    return null;\n-                }\n-                return Files.newInputStream(Path.of(javahome, \"conf\", filename));\n-            } catch (Exception e) {\n+        try {\n+            String javahome = System.getProperty(\"java.home\");\n+            if (javahome == null) {\n@@ -232,2 +167,4 @@\n-        };\n-        return AccessController.doPrivileged(act);\n+            return Files.newInputStream(Path.of(javahome, \"conf\", filename));\n+        } catch (Exception e) {\n+            return null;\n+        }\n@@ -242,1 +179,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -246,9 +182,3 @@\n-        PrivilegedExceptionAction<Enumeration<URL>> act = () ->\n-                (cl == null)\n-                        ? ClassLoader.getSystemResources(name)\n-                        : cl.getResources(name);\n-        try {\n-            urls = AccessController.doPrivileged(act);\n-        } catch (PrivilegedActionException e) {\n-            throw (IOException) e.getException();\n-        }\n+        urls = (cl == null)\n+                ? ClassLoader.getSystemResources(name)\n+                : cl.getResources(name);\n@@ -268,1 +198,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -270,21 +199,4 @@\n-\n-        PrivilegedAction<ClassLoader> act = () -> {\n-            ClassLoader loader = Thread.currentThread().getContextClassLoader();\n-            if (loader == null) {\n-                \/\/ Don't use bootstrap class loader directly!\n-                loader = ClassLoader.getSystemClassLoader();\n-            }\n-            return loader;\n-        };\n-        return AccessController.doPrivileged(act);\n-    }\n-\n-    private static URL[] getUrlArray(String codebase)\n-            throws MalformedURLException {\n-        \/\/ Parse codebase into separate URLs\n-        StringTokenizer parser = new StringTokenizer(codebase);\n-        List<URL> list = new ArrayList<>();\n-        while (parser.hasMoreTokens()) {\n-            @SuppressWarnings(\"deprecation\")\n-            var u = new URL(parser.nextToken());\n-            list.add(u);\n+        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+        if (loader == null) {\n+            \/\/ Don't use bootstrap class loader directly!\n+            loader = ClassLoader.getSystemClassLoader();\n@@ -292,1 +204,1 @@\n-        return list.toArray(new URL[0]);\n+        return loader;\n@@ -297,4 +209,1 @@\n-     * an enumeration of their InputStreams.  Each operation on the URL\n-     * enumeration is performed within a doPrivileged block.\n-     * This is used to enumerate the resources under a foreign codebase.\n-     * This class is not MT-safe.\n+     * an enumeration of their InputStreams.\n@@ -317,1 +226,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -319,7 +227,5 @@\n-            PrivilegedAction<InputStream> act = () -> {\n-                while (urls.hasMoreElements()) {\n-                    try {\n-                        return urls.nextElement().openStream();\n-                    } catch (IOException e) {\n-                        \/\/ skip this URL\n-                    }\n+            while (urls.hasMoreElements()) {\n+                try {\n+                    return urls.nextElement().openStream();\n+                } catch (IOException e) {\n+                    \/\/ skip this URL\n@@ -327,3 +233,2 @@\n-                return null;\n-            };\n-            return AccessController.doPrivileged(act);\n+            }\n+            return null;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/naming\/internal\/VersionHelper.java","additions":32,"deletions":127,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -126,3 +126,6 @@\n-     *    Under JDK 1.1, if the factory class must be loaded from a location\n-     *    specified in the reference, a {@code SecurityManager} must have\n-     *    been installed or the factory creation will fail.\n+     *    Downloading a factory class from a location specified in the reference\n+     *    can be supported by a custom implementation of {@link ObjectFactoryBuilder}.\n+     *    The {@linkplain Reference#getFactoryClassLocation() factory class\n+     *    location}, if present, is ignored. A custom {@link ObjectFactoryBuilder}\n+     *    {@linkplain #setObjectFactoryBuilder(ObjectFactoryBuilder) may be used}\n+     *    if a different policy is desired.\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/spi\/NamingManager.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -60,13 +58,0 @@\n-    \/**\n-     * Determines whether classes may be loaded from an arbitrary URL code base.\n-     *\/\n-    static final boolean trustURLCodebase;\n-    static {\n-        \/\/ System property to control whether classes may be loaded from an\n-        \/\/ arbitrary URL codebase\n-        PrivilegedAction<String> act = () -> System.getProperty(\n-            \"com.sun.jndi.rmi.object.trustURLCodebase\", \"false\");\n-        @SuppressWarnings(\"removal\")\n-        String trust = AccessController.doPrivileged(act);\n-        trustURLCodebase = \"true\".equalsIgnoreCase(trust);\n-    }\n@@ -484,6 +469,0 @@\n-            \/*\n-             * Classes may only be loaded from an arbitrary URL codebase when\n-             * the system property com.sun.jndi.rmi.object.trustURLCodebase\n-             * has been set to \"true\".\n-             *\/\n-\n@@ -498,2 +477,6 @@\n-            if (ref != null && ref.getFactoryClassLocation() != null &&\n-                !trustURLCodebase) {\n+            \/*\n+             * Downloading a factory class from a location specified in the reference\n+             * can be supported by a custom implementation of \"ObjectFactoryBuilder\".\n+             *\/\n+            if (NamingManagerHelper.getObjectFactoryBuilder() == null\n+                && ref != null && ref.getFactoryClassLocation() != null) {\n@@ -501,2 +484,1 @@\n-                    \"The object factory is untrusted. Set the system property\" +\n-                    \" 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'.\");\n+                    \"Remote object factories are not supported\");\n","filename":"src\/jdk.naming.rmi\/share\/classes\/com\/sun\/jndi\/rmi\/registry\/RegistryContext.java","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+ * <p> Downloading a factory class from a {@linkplain javax.naming.Reference#getFactoryClassLocation()\n+ * location} specified in the reference can be supported by a custom implementation of {@link\n+ * javax.naming.spi.ObjectFactoryBuilder}. Unless an {@link javax.naming.spi.ObjectFactoryBuilder\n+ * ObjectFactoryBuilder} is installed a {@link javax.naming.ConfigurationException} is thrown.\n","filename":"src\/jdk.naming.rmi\/share\/classes\/module-info.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.SimpleFileServer;\n+\n+import javax.naming.Context;\n+import javax.naming.InitialContext;\n+import javax.naming.NamingException;\n+import javax.naming.Reference;\n+import javax.naming.spi.NamingManager;\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.rmi.RemoteException;\n+import java.rmi.registry.Registry;\n+import java.rmi.server.RMISocketFactory;\n+import java.util.Hashtable;\n+import java.util.Objects;\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+\n+\/*\n+ * @test\n+ * @bug 8338536\n+ * @summary Check if an object factory builder can be used to reconstruct\n+ *          object factories from a code base specified in a\n+ * @modules java.rmi\/sun.rmi.registry\n+ *          java.rmi\/sun.rmi.server\n+ *          java.rmi\/sun.rmi.transport\n+ *          java.rmi\/sun.rmi.transport.tcp\n+ * @library \/test\/lib ..\/..\/..\/..\/..\/..\/java\/rmi\/testlibrary\n+ * @build TestLibrary\n+ * @compile TestFactory.java TestObjectFactoryBuilder.java\n+ *\n+ * @run main\/othervm ObjectFactoryBuilderCodebaseTest setObjectFactoryBuilder\n+ * @run main\/othervm ObjectFactoryBuilderCodebaseTest default\n+ *\/\n+public class ObjectFactoryBuilderCodebaseTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        setupRmiHostNameAndRmiSocketFactory();\n+        boolean useCustomObjectFactoryBuilder =\n+                \"setObjectFactoryBuilder\".equals(args[0]);\n+\n+        if (args.length > 0 && useCustomObjectFactoryBuilder) {\n+            NamingManager.setObjectFactoryBuilder(new TestObjectFactoryBuilder());\n+        }\n+        FileServer fileServer = configureAndLaunchFileServer();\n+        int registryPort;\n+        try {\n+            Registry registry = TestLibrary.createRegistryOnEphemeralPort();\n+            registryPort = TestLibrary.getRegistryPort(registry);\n+            System.out.println(\"Registry port: \" + registryPort);\n+        } catch (RemoteException re) {\n+            throw new RuntimeException(\"Failed to create registry\", re);\n+        }\n+\n+        Context context = getInitialContext(registryPort);\n+        \/\/ Bind the Reference object\n+        String factoryURL = fileServer.factoryLocation();\n+        System.err.println(\"Setting Reference factory location: \" + factoryURL);\n+        Reference ref = new Reference(\"TestObject\", \"com.test.TestFactory\",\n+                factoryURL);\n+        context.bind(\"objectTest\", ref);\n+\n+        \/\/ Try to load bound reference\n+        try {\n+            Object object = context.lookup(\"objectTest\");\n+            if (!useCustomObjectFactoryBuilder) {\n+                throw new RuntimeException(\"Lookup not expected to complete\");\n+            }\n+            System.err.println(\"Loaded object: \" + object);\n+        } catch (NamingException ne) {\n+            if (useCustomObjectFactoryBuilder) {\n+                throw new RuntimeException(\"Lookup expected to complete successfully\", ne);\n+            }\n+        }\n+    }\n+\n+    private static Context getInitialContext(int port) throws NamingException {\n+        Hashtable<String, String> env = new Hashtable<>();\n+\n+        \/\/ Prepare registry URL\n+        String providerURL = URIBuilder.newBuilder()\n+                .loopback()\n+                .port(port)\n+                .scheme(\"rmi\")\n+                .buildUnchecked().toString();\n+\n+        env.put(Context.INITIAL_CONTEXT_FACTORY,\n+                \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\n+        env.put(Context.PROVIDER_URL, providerURL);\n+        return new InitialContext(env);\n+    }\n+\n+    private record FileServer(Path rootPath, InetSocketAddress address, HttpServer httpServer) {\n+\n+        public static FileServer newInstance(Path rootPath, InetSocketAddress address) {\n+            Objects.requireNonNull(address);\n+            Objects.requireNonNull(rootPath);\n+            var httpServer = SimpleFileServer.createFileServer(address, rootPath,\n+                    SimpleFileServer.OutputLevel.VERBOSE);\n+            return new FileServer(rootPath, address, httpServer);\n+        }\n+\n+        String factoryLocation() {\n+            return URIBuilder.newBuilder()\n+                    .loopback()\n+                    .port(port())\n+                    .scheme(\"http\")\n+                    .path(\"\/\")\n+                    .buildUnchecked()\n+                    .toString();\n+        }\n+\n+        int port() {\n+            return httpServer.getAddress().getPort();\n+        }\n+\n+        void start() {\n+            httpServer.start();\n+        }\n+    }\n+\n+    \/\/ Prepares and launches the file server capable of serving TestFactory.class\n+    private static FileServer configureAndLaunchFileServer() throws IOException {\n+\n+        \/\/ Location of compiled classes with compiled MyFactory\n+        Path factoryClassPath = Path.of(System.getProperty(\"test.classes\", \".\"))\n+                .resolve(OBJ_FACTORY_PACKAGE_PATH)\n+                .resolve(OBJ_FACTORY_CLASS_NAME);\n+\n+        \/\/ File server content root directory\n+        Path serverRoot = Paths.get(\"serverRoot\").toAbsolutePath();\n+        Path packageDirInServerRoot = serverRoot.resolve(OBJ_FACTORY_PACKAGE_PATH);\n+        Path factoryClassFileInServerRoot = packageDirInServerRoot.resolve(OBJ_FACTORY_CLASS_NAME);\n+\n+        \/\/ Remove files from previous run\n+        Files.deleteIfExists(factoryClassFileInServerRoot);\n+        Files.deleteIfExists(packageDirInServerRoot);\n+        Files.deleteIfExists(packageDirInServerRoot.getParent());\n+        Files.deleteIfExists(serverRoot);\n+\n+        \/\/ Create server root and copy compiled object factory inside\n+        Files.createDirectories(packageDirInServerRoot);\n+        Files.copy(factoryClassPath, factoryClassFileInServerRoot);\n+\n+        \/\/ Bind file server to loopback address\n+        InetSocketAddress serverAddress =\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0);\n+        FileServer fileServer = FileServer.newInstance(serverRoot, serverAddress);\n+\n+        \/\/ Start the file server\n+        fileServer.start();\n+        System.err.println(\"File server content root: \" + serverRoot);\n+        System.err.printf(\"File server running on %s:%d%n\",\n+                serverAddress.getAddress(), fileServer.port());\n+        return fileServer;\n+    }\n+\n+\n+    \/\/ Configure RMI to launch registry on a loopback address\n+    private static void setupRmiHostNameAndRmiSocketFactory() throws IOException {\n+        String rmiServerHostAddressString = InetAddress.getLoopbackAddress().getHostAddress();\n+        System.out.println(\"Setting 'java.rmi.server.hostname' to: \" + rmiServerHostAddressString);\n+        System.setProperty(\"java.rmi.server.hostname\", rmiServerHostAddressString);\n+        RMISocketFactory.setSocketFactory(new TestRmiSocketFactory());\n+    }\n+\n+    private static class TestRmiSocketFactory extends RMISocketFactory {\n+        public ServerSocket createServerSocket(int port) throws IOException {\n+            var loopbackAddress = InetAddress.getLoopbackAddress();\n+            System.out.printf(\"Creating RMI server socket on %s:%d%n\", loopbackAddress, port);\n+            ServerSocket rmiServerSocket = new ServerSocket();\n+            rmiServerSocket.setOption(java.net.StandardSocketOptions.SO_REUSEADDR, false);\n+            SocketAddress serverAddress = new InetSocketAddress(loopbackAddress, port);\n+            rmiServerSocket.bind(serverAddress, BACKLOG_OF_5);\n+            return rmiServerSocket;\n+        }\n+\n+        public Socket createSocket(String host, int port) throws IOException {\n+            System.out.printf(\"Creating RMI client socket connected to %s:%d%n\", host, port);\n+            \/\/ just call the default client socket factory\n+            return RMISocketFactory.getDefaultSocketFactory()\n+                    .createSocket(host, port);\n+        }\n+    }\n+\n+    \/\/ File server backlog value\n+    private static final int BACKLOG_OF_5 = 5;\n+    \/\/ Test objects factory class filename\n+    private static final String OBJ_FACTORY_CLASS_NAME = \"TestFactory.class\";\n+    \/\/ Package directory of the test's objects factory class\n+    private static final Path OBJ_FACTORY_PACKAGE_PATH = Paths.get(\"com\").resolve(\"test\");\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/rmi\/registry\/objects\/ObjectFactoryBuilderCodebaseTest.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.naming.ConfigurationException;\n+import javax.naming.NamingException;\n+import javax.naming.Reference;\n+import javax.naming.spi.ObjectFactory;\n+import javax.naming.spi.ObjectFactoryBuilder;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Hashtable;\n+\n+\/**\n+ * Test library class that implements {@code javax.naming.spi.ObjectFactoryBuilder} interface.\n+ * Its implementation allows object factory class loading from any remote location.\n+ *\/\n+public class TestObjectFactoryBuilder implements ObjectFactoryBuilder {\n+\n+    @Override\n+    public ObjectFactory createObjectFactory(Object obj, Hashtable<?, ?> environment) throws NamingException {\n+        System.err.println(\"TestObjectFactoryBuilder: Creating new object factory\");\n+        System.err.println(\"Builder for object: \" + obj);\n+        System.err.println(\"And for environment: \" + environment);\n+        \/\/ Only objects of the Reference type are supported, others are rejected\n+        if (obj instanceof Reference ref) {\n+            String objectFactoryLocation = ref.getFactoryClassLocation();\n+            try {\n+                URL factoryURL = new URL(objectFactoryLocation);\n+                var cl = new URLClassLoader(new URL[]{factoryURL});\n+                Class<?> factoryClass = cl.loadClass(ref.getFactoryClassName());\n+                System.err.println(\"Loaded object factory: \" + factoryClass);\n+                if (ObjectFactory.class.isAssignableFrom(factoryClass)) {\n+                    return (ObjectFactory) factoryClass\n+                            .getDeclaredConstructor().newInstance();\n+                } else {\n+                    throw new ConfigurationException(\"Test configuration error -\" +\n+                            \" loaded object factory of wrong type\");\n+                }\n+            } catch (MalformedURLException e) {\n+                throw new ConfigurationException(\"Error constructing test object factory\");\n+            } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException |\n+                     IllegalAccessException | InvocationTargetException e) {\n+                throw new ConfigurationException(\"Test configuration error: \" +\n+                        \"factory class cannot be loaded from the provided \" +\n+                        \"object factory location\");\n+            }\n+        } else {\n+            throw new ConfigurationException(\"Test factory builder \" +\n+                    \"supports only Reference types\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/rmi\/registry\/objects\/TestObjectFactoryBuilder.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}