{"files":[{"patch":"@@ -1558,1 +1558,1 @@\n-    \/\/ precondition: -2^31 * MONT_Q <= a, b < 2^31, -2^31 < a * b < 2^31 * MONT_Q\n+    \/\/ precondition: -2^31 <= a, b < 2^31, -2^31 * MONT_Q <= a * b < 2^31 * MONT_Q\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n- * @comment This test should be reenabled on aarch64\n- * @requires os.simpleArch == \"x64\"\n@@ -49,2 +47,5 @@\n-\/\/ To run manually: java --add-opens java.base\/sun.security.provider=ALL-UNNAMED --add-exports java.base\/sun.security.provider=ALL-UNNAMED\n-\/\/  -XX:+UnlockDiagnosticVMOptions -XX:+UseDilithiumIntrinsics test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Intrinsic_Test.java\n+\/\/ To run manually:\n+\/\/ java --add-opens java.base\/sun.security.provider=ALL-UNNAMED\n+\/\/  --add-exports java.base\/sun.security.provider=ALL-UNNAMED\n+\/\/  -XX:+UnlockDiagnosticVMOptions -XX:+UseDilithiumIntrinsics\n+\/\/  test\/jdk\/sun\/security\/provider\/pqc\/ML_DSA_Intrinsic_Test.java\n@@ -107,1 +108,0 @@\n-        \/\/ Hint: if test fails, you can hardcode the seed to make the test more reproducible\n@@ -110,0 +110,2 @@\n+        \/\/ Hint: if a test fails, it prints the seed, so you can hardcode\n+        \/\/ it here to reproduce the failure\n@@ -120,3 +122,2 @@\n-            \/\/ Hint: if test fails, you can hardcode the seed to make the test more reproducible:\n-            \/\/ rnd.setSeed(seed);\n-            testMult(prod1, prod2, coeffs1, coeffs2, mult, multJava, rnd, seed, i);\n+            testMult(prod1, prod2, coeffs1, coeffs2,\n+                    mult, multJava, rnd, seed, i);\n@@ -124,1 +125,2 @@\n-            testDecompose(prod1, prod2, prod3, prod4, coeffs1, coeffs2, decompose, decomposeJava, rnd, seed, i);\n+            testDecompose(prod1, prod2, prod3, prod4, coeffs1, coeffs2,\n+                    decompose, decomposeJava, rnd, seed, i);\n@@ -131,2 +133,2 @@\n-    private static final int ML_DSA_N = 256;\n-    public static void testMult(int[] prod1, int[] prod2, int[] coeffs1, int[] coeffs2,\n+    public static void testMult(int[] prod1, int[] prod2,\n+        int[] coeffs1, int[] coeffs2,\n@@ -136,3 +138,7 @@\n-        for (int j = 0; j<ML_DSA_N; j++) {\n-            coeffs1[j] = rnd.nextInt();\n-            coeffs2[j] = rnd.nextInt();\n+        \/\/ This method is always called with arrays whose elements are between\n+        \/\/ -ML_DSA_Q and ML_DSA_Q, so we only test for these here (although\n+        \/\/ both versions work fine with array element sizes that satisfy the\n+        \/\/ montMul() preconditions in sun.security.provider.ML_DSA.java\n+        for (int j = 0; j < ML_DSA_N; j++) {\n+            coeffs1[j] = rnd.nextInt(2 * ML_DSA_Q) - ML_DSA_Q;\n+            coeffs2[j] = rnd.nextInt(2 * ML_DSA_Q) - ML_DSA_Q;\n@@ -145,1 +151,14 @@\n-                throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result mult mismatch: \" + formatOf(prod1) + \" != \" + formatOf(prod2));\n+            \/\/ The Java version and the intrinsic version should not produce\n+            \/\/ the exact same result (although usually they do), it is enough\n+            \/\/ if the corresponding array elements are congruent modulo ML_DSA_Q\n+            boolean modQequal = true;\n+            for (int j = 0; j < ML_DSA_N; j++) {\n+                if (prod1[j] != prod2[j]) {\n+                    modQequal &= (((prod1[j] - prod2[j]) % ML_DSA_Q) == 0);\n+                }\n+            }\n+            if (!modQequal) {\n+                throw new RuntimeException(\"[Seed \" + seed + \"@\" + i\n+                        + \"] Result mult mismatch: \"\n+                        + formatOf(prod1) + \"\\n != \" + formatOf(prod2));\n+            }\n@@ -153,1 +172,1 @@\n-        for (int j = 0; j<ML_DSA_N; j++) {\n+        for (int j = 0; j < ML_DSA_N; j++) {\n@@ -156,3 +175,4 @@\n-        \/\/ Per Algorithm 3 in https:\/\/eprint.iacr.org\/2018\/039.pdf, one of the inputs is bound, which prevents overflows\n-        int dilithium_q = 8380417;\n-        int c = rnd.nextInt(dilithium_q);\n+\n+        \/\/ Per Algorithm 3 in https:\/\/eprint.iacr.org\/2018\/039.pdf,\n+        \/\/ one of the inputs is bound, which prevents overflows\n+        int c = rnd.nextInt(ML_DSA_Q);\n@@ -164,1 +184,3 @@\n-                throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result multConst mismatch: \" + formatOf(prod1) + \" != \" + formatOf(prod2));\n+                throw new RuntimeException(\"[Seed \" + seed + \"@\" + i\n+                        + \"] Result multConst mismatch: \"\n+                        + formatOf(prod1) + \" != \" + formatOf(prod2));\n@@ -168,1 +190,2 @@\n-    public static void testDecompose(int[] low1, int[] high1, int[] low2, int[] high2, int[] coeffs1, int[] coeffs2,\n+    public static void testDecompose(int[] low1, int[] high1, int[] low2,\n+        int[] high2, int[] coeffs1, int[] coeffs2,\n@@ -172,1 +195,1 @@\n-        for (int j = 0; j<ML_DSA_N; j++) {\n+        for (int j = 0; j < ML_DSA_N; j++) {\n@@ -185,1 +208,3 @@\n-                throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result low mismatch: \" + formatOf(low1) + \" != \" + formatOf(low2));\n+                throw new RuntimeException(\"[Seed \" + seed + \"@\" + i\n+                        + \"] Result low mismatch: \"\n+                        + formatOf(low1) + \" != \" + formatOf(low2));\n@@ -189,1 +214,3 @@\n-                throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result high mismatch: \" + formatOf(high1) + \" != \" + formatOf(high2));\n+                throw new RuntimeException(\"[Seed \" + seed + \"@\" + i\n+                        + \"] Result high mismatch: \"\n+                        + formatOf(high1) + \" != \" + formatOf(high2));\n@@ -196,1 +223,1 @@\n-        for (int j = 0; j<ML_DSA_N; j++) {\n+        for (int j = 0; j < ML_DSA_N; j++) {\n@@ -204,1 +231,3 @@\n-            throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result AlmostNtt mismatch: \" + formatOf(coeffs1) + \" != \" + formatOf(coeffs2));\n+            throw new RuntimeException(\"[Seed \" + seed + \"@\" + i\n+                    +\"] Result AlmostNtt mismatch: \"\n+                    + formatOf(coeffs1) + \" != \" + formatOf(coeffs2));\n@@ -211,1 +240,1 @@\n-        for (int j = 0; j<ML_DSA_N; j++) {\n+        for (int j = 0; j < ML_DSA_N; j++) {\n@@ -219,1 +248,3 @@\n-            throw new RuntimeException(\"[Seed \"+seed+\"@\"+i+\"] Result InverseNtt mismatch: \" + formatOf(coeffs1) + \" != \" + formatOf(coeffs2));\n+            throw new RuntimeException(\"[Seed \" + seed+  \"@\" + i\n+                    +\"] Result InverseNtt mismatch: \"\n+                    + formatOf(coeffs1) + \" != \" + formatOf(coeffs2));\n@@ -233,0 +264,3 @@\n+    private static final int ML_DSA_N = 256;\n+    private static final int ML_DSA_Q = 8380417;\n+\n","filename":"test\/jdk\/sun\/security\/provider\/pqc\/ML_DSA_Intrinsic_Test.java","additions":62,"deletions":28,"binary":false,"changes":90,"previous_filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Intrinsic_Test.java","status":"renamed"}]}