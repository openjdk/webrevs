{"files":[{"patch":"@@ -27,1 +27,1 @@\n-#include \"asm\/assembler.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n@@ -31,0 +31,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -82,0 +84,1 @@\n+\n@@ -135,0 +138,24 @@\n+\n+  \/\/ Initialize klass decode mode and check compability with decode instructions\n+  if (!check_klass_decode_mode()) {\n+\n+    \/\/ Give fatal error if this is a specified address\n+    if ((address)CompressedClassSpaceBaseAddress == _base) {\n+      vm_exit_during_initialization(\n+            err_msg(\"CompressedClassSpaceBaseAddress=\" PTR_FORMAT \" given with shift %d, cannot be used to encode class pointers\",\n+                    CompressedClassSpaceBaseAddress, _shift));\n+    } else {\n+      \/\/ If this fails, it's a bug in the allocation code.\n+      fatal(\"CompressedClassSpaceBaseAddress=\" PTR_FORMAT \" given with shift %d, cannot be used to encode class pointers\",\n+            p2i(_base), _shift);\n+    }\n+  }\n+}\n+\n+bool CompressedKlassPointers::check_klass_decode_mode(address base, int shift, const size_t range) {\n+  return MacroAssembler::check_klass_decode_mode(base, shift, range);\n+}\n+\n+bool CompressedKlassPointers::check_klass_decode_mode() {\n+  const size_t range = CompressedKlassPointers::klass_range_end() - CompressedKlassPointers::base();\n+  return check_klass_decode_mode(_base, _shift, range);\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -5103,0 +5103,13 @@\n+\/\/ Check if one of the above decoding modes will work for given base, shift and range.\n+bool MacroAssembler::check_klass_decode_mode(address base, int shift, const size_t range) {\n+  assert(UseCompressedClassPointers, \"not using compressed class pointers\");\n+  const uint64_t base_address = (uint64_t)base;\n+  const uint64_t range_mask = (1ULL << log2i(range)) - 1;\n+  const uint64_t shifted_base = base_address >> shift;\n+\n+  return (base == nullptr ||\n+         (operand_valid_for_logical_immediate(\/*is32*\/false, base_address) &&\n+            ((base_address & range_mask) == 0))  ||\n+         (shifted_base & 0xffff0000ffffffff) == 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -101,0 +101,4 @@\n+\n+ public:\n+  \/\/ Sets the decode mode and returns false if cannot be set.\n+  static bool check_klass_decode_mode(address base, int shift, const size_t range);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1359,0 +1359,9 @@\n+  \/\/ Test that class space base address plus shift can be decoded by aarch64, when restored.\n+  const int precomputed_narrow_klass_shift = ArchiveHeapWriter::precomputed_narrow_klass_shift;\n+  if (!CompressedKlassPointers::check_klass_decode_mode(base_address, precomputed_narrow_klass_shift,\n+                                                        total_range_size)) {\n+    log_info(cds)(\"CDS initialization: Cannot use SharedBaseAddress \" PTR_FORMAT \" with precomputed shift %d.\",\n+                  p2i(base_address), precomputed_narrow_klass_shift);\n+    use_archive_base_addr = false;\n+  }\n+\n@@ -1398,1 +1407,1 @@\n-    assert(base_address == nullptr || (address)total_space_rs.base() == base_address,\n+    assert(!use_archive_base_addr || (address)total_space_rs.base() == base_address,\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -72,0 +73,6 @@\n+\n+  \/\/ This has already been checked for SharedBaseAddress and if this fails, it's a bug in the allocation code.\n+  if (!check_klass_decode_mode()) {\n+    fatal(\"base=\" PTR_FORMAT \" given with shift %d, cannot be used to encode class pointers\",\n+          p2i(_base), _shift);\n+  }\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -182,0 +182,9 @@\n+\n+  \/\/ Check that with the given base, shift and range, aarch64 an encode and decode the klass pointer.\n+#ifdef AARCH64\n+  static bool check_klass_decode_mode(address base, int shift, const size_t range);\n+  static bool check_klass_decode_mode();  \/\/ can be called after initialization\n+#else\n+  static bool check_klass_decode_mode(address base, int shift, const size_t range) { return true; }\n+  static bool check_klass_decode_mode() { return true; }  \/\/ can be called after initialization\n+#endif\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,27 @@\n+    private static void testFailure(String forceAddressString) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-Xshare:off\", \/\/ to make CompressedClassSpaceBaseAddress work\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:CompressedClassSpaceBaseAddress=\" + forceAddressString,\n+                \"-Xmx128m\",\n+                \"-Xlog:metaspace*\",\n+                \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.reportDiagnosticSummary();\n+\n+        \/\/ We ignore cases where we were not able to map at the force address\n+        if (!output.contains(\"Successfully forced class space address to \" + forceAddressString)) {\n+            throw new SkippedException(\"Skipping because we cannot force ccs to \" + forceAddressString);\n+        }\n+\n+        if (Platform.isAArch64()) {\n+            output.shouldHaveExitValue(1);\n+            output.shouldContain(\"Error occurred during initialization of VM\");\n+            output.shouldContain(\"CompressedClassSpaceBaseAddress=\" + forceAddressString +\n+                                 \" given with shift 0, cannot be used to encode class pointers\");\n+        } else {\n+            output.shouldHaveExitValue(0);\n+        }\n+    }\n+\n@@ -79,1 +106,1 @@\n-\n+        testFailure(\"0x0000040001000000\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointersEncodingScheme.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"}]}