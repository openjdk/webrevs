{"files":[{"patch":"@@ -27,1 +27,1 @@\n-#include \"asm\/assembler.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n@@ -31,0 +31,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -82,0 +84,1 @@\n+\n@@ -120,0 +123,9 @@\n+\n+bool CompressedKlassPointers::check_klass_decode_mode(address base, int shift, const size_t range) {\n+  return MacroAssembler::check_klass_decode_mode(base, shift, range);\n+}\n+\n+bool CompressedKlassPointers::check_klass_decode_mode() {\n+  const size_t range = CompressedKlassPointers::klass_range_end() - CompressedKlassPointers::base();\n+  return check_klass_decode_mode(_base, _shift, range);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5298,1 +5298,1 @@\n-    const uint64_t range_mask = (1ULL << log2i(range)) - 1;\n+    const uint64_t range_mask = right_n_bits(ceil_log2(range));\n@@ -5312,0 +5312,13 @@\n+\/\/ Check if one of the above decoding modes will work for given base, shift and range.\n+bool MacroAssembler::check_klass_decode_mode(address base, int shift, const size_t range) {\n+  assert(UseCompressedClassPointers, \"not using compressed class pointers\");\n+  const uint64_t base_address = (uint64_t)base;\n+  const uint64_t range_mask = right_n_bits(ceil_log2(range));\n+  const uint64_t shifted_base = base_address >> shift;\n+\n+  return (base == nullptr ||\n+         (operand_valid_for_logical_immediate(\/*is32*\/false, base_address) &&\n+            ((base_address & range_mask) == 0))  ||\n+         (shifted_base & 0xffff0000ffffffff) == 0);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -102,0 +102,4 @@\n+ public:\n+  \/\/ Sets the decode mode and returns false if cannot be set.\n+  static bool check_klass_decode_mode(address base, int shift, const size_t range);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1417,0 +1417,9 @@\n+  \/\/ Test that class space base address plus shift can be decoded by aarch64, when restored.\n+  const int precomputed_narrow_klass_shift = ArchiveBuilder::precomputed_narrow_klass_shift();\n+  if (!CompressedKlassPointers::check_klass_decode_mode(base_address, precomputed_narrow_klass_shift,\n+                                                        total_range_size)) {\n+    log_info(cds)(\"CDS initialization: Cannot use SharedBaseAddress \" PTR_FORMAT \" with precomputed shift %d.\",\n+                  p2i(base_address), precomputed_narrow_klass_shift);\n+    use_archive_base_addr = false;\n+  }\n+\n@@ -1456,1 +1465,1 @@\n-    assert(base_address == nullptr || (address)total_space_rs.base() == base_address,\n+    assert(!use_archive_base_addr || (address)total_space_rs.base() == base_address,\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -179,0 +180,6 @@\n+  \/\/ This has already been checked for SharedBaseAddress and if this fails, it's a bug in the allocation code.\n+  if (!check_klass_decode_mode()) {\n+    fatal(\"base=\" PTR_FORMAT \" given with shift %d, cannot be used to encode class pointers\",\n+          p2i(_base), _shift);\n+  }\n+\n@@ -270,0 +277,14 @@\n+  \/\/ Initialize klass decode mode and check compability with decode instructions\n+  if (!check_klass_decode_mode()) {\n+\n+    \/\/ Give fatal error if this is a specified address\n+    if ((address)CompressedClassSpaceBaseAddress == _base) {\n+      vm_exit_during_initialization(\n+            err_msg(\"CompressedClassSpaceBaseAddress=\" PTR_FORMAT \" given with shift %d, cannot be used to encode class pointers\",\n+                    CompressedClassSpaceBaseAddress, _shift));\n+    } else {\n+      \/\/ If this fails, it's a bug in the allocation code.\n+      fatal(\"CompressedClassSpaceBaseAddress=\" PTR_FORMAT \" given with shift %d, cannot be used to encode class pointers\",\n+            p2i(_base), _shift);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -261,0 +261,8 @@\n+  \/\/ Check that with the given base, shift and range, aarch64 an encode and decode the klass pointer.\n+#ifdef AARCH64\n+  static bool check_klass_decode_mode(address base, int shift, const size_t range);\n+  static bool check_klass_decode_mode();  \/\/ can be called after initialization\n+#else\n+  static bool check_klass_decode_mode(address base, int shift, const size_t range) { return true; }\n+  static bool check_klass_decode_mode() { return true; }  \/\/ can be called after initialization\n+#endif\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -117,4 +117,0 @@\n-# Fails with +UseCompactObjectHeaders on aarch64\n-runtime\/cds\/appcds\/SharedBaseAddress.java 8340212 linux-aarch64,macosx-aarch64\n-runtime\/cds\/SharedBaseAddress.java 8340212 linux-aarch64,macosx-aarch64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,27 @@\n+    private static void testFailure(String forceAddressString) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-Xshare:off\", \/\/ to make CompressedClassSpaceBaseAddress work\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:CompressedClassSpaceBaseAddress=\" + forceAddressString,\n+                \"-Xmx128m\",\n+                \"-Xlog:metaspace*\",\n+                \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.reportDiagnosticSummary();\n+\n+        \/\/ We ignore cases where we were not able to map at the force address\n+        if (!output.contains(\"Successfully forced class space address to \" + forceAddressString)) {\n+            throw new SkippedException(\"Skipping because we cannot force ccs to \" + forceAddressString);\n+        }\n+\n+        if (Platform.isAArch64()) {\n+            output.shouldHaveExitValue(1);\n+            output.shouldContain(\"Error occurred during initialization of VM\");\n+            output.shouldContain(\"CompressedClassSpaceBaseAddress=\" + forceAddressString +\n+                                 \" given with shift 0, cannot be used to encode class pointers\");\n+        } else {\n+            output.shouldHaveExitValue(0);\n+        }\n+    }\n+\n@@ -126,0 +153,4 @@\n+\n+        \/\/ Test failure for -XX:CompressedClassBaseAddress and -Xshare:off\n+        testFailure(\"0x0000040001000000\");\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointersEncodingScheme.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"}]}