{"files":[{"patch":"@@ -454,1 +454,0 @@\n-#if defined(AIX)\n@@ -456,10 +455,39 @@\n-\/\/ Set thread signal mask (for some reason on AIX sigthreadmask() seems\n-\/\/ to be the thing to call; documentation is not terribly clear about whether\n-\/\/ pthread_sigmask also works, and if it does, whether it does the same.\n-bool set_thread_signal_mask(int how, const sigset_t* set, sigset_t* oset) {\n-  const int rc = ::pthread_sigmask(how, set, oset);\n-  \/\/ return value semantics differ slightly for error case:\n-  \/\/ pthread_sigmask returns error number, sigthreadmask -1 and sets global errno\n-  \/\/ (so, pthread_sigmask is more theadsafe for error handling)\n-  \/\/ But success is always 0.\n-  return rc == 0 ? true : false;\n+\/\/\/\/\/ Synchronous (non-deferrable) error signals (ILL, SEGV, FPE, BUS, TRAP):\n+\n+\/\/ These signals are special because they cannot be deferred and, if they\n+\/\/ happen while delivery is blocked for the receiving thread, will cause UB\n+\/\/ (in practice typically resulting in sudden process deaths or hangs, see\n+\/\/ JDK-8252533). So we must take care never to block them when we cannot be\n+\/\/ absolutely sure they won't happen. In practice, this is always.\n+\/\/\n+\/\/ Relevant Posix quote:\n+\/\/ \"The behavior of a process is undefined after it ignores a SIGFPE, SIGILL,\n+\/\/  SIGSEGV, or SIGBUS signal that was not generated by kill(), sigqueue(), or\n+\/\/  raise().\"\n+\/\/\n+\/\/ We also include SIGTRAP in that list of never-to-block-signals. While not\n+\/\/ mentioned by the Posix documentation, in our (SAPs) experience blocking it\n+\/\/ causes similar problems. Beside, during normal operation - outside of error\n+\/\/ handling - SIGTRAP may be used for implicit NULL checking, so it makes sense\n+\/\/ to never block it.\n+\/\/\n+\/\/ We deal with those signals in two ways:\n+\/\/ - we just never explicitly block them, which includes not accidentally blocking\n+\/\/   them via sa_mask when establishing signal handlers.\n+\/\/ - as an additional safety measure, at the entrance of a signal handler, we\n+\/\/   unblock them explicitly.\n+\n+static void add_error_signals_to_set(sigset_t* set) {\n+  sigaddset(set, SIGILL);\n+  sigaddset(set, SIGBUS);\n+  sigaddset(set, SIGFPE);\n+  sigaddset(set, SIGSEGV);\n+  sigaddset(set, SIGTRAP);\n+}\n+\n+static void remove_error_signals_from_set(sigset_t* set) {\n+  sigdelset(set, SIGILL);\n+  sigdelset(set, SIGBUS);\n+  sigdelset(set, SIGFPE);\n+  sigdelset(set, SIGSEGV);\n+  sigdelset(set, SIGTRAP);\n@@ -468,4 +496,3 @@\n-\/\/ Function to unblock all signals which are, according\n-\/\/ to POSIX, typical program error signals. If they happen while being blocked,\n-\/\/ they typically will bring down the process immediately.\n-bool unblock_program_error_signals() {\n+\/\/ Unblock all signals whose delivery cannot be deferred and which, if they happen\n+\/\/  while delivery is blocked, would cause crashes or hangs (JDK-8252533).\n+void PosixSignals::unblock_error_signals() {\n@@ -474,5 +501,2 @@\n-  sigaddset(&set, SIGILL);\n-  sigaddset(&set, SIGBUS);\n-  sigaddset(&set, SIGFPE);\n-  sigaddset(&set, SIGSEGV);\n-  return set_thread_signal_mask(SIG_UNBLOCK, &set, NULL);\n+  add_error_signals_to_set(&set);\n+  ::pthread_sigmask(SIG_UNBLOCK, &set, NULL);\n@@ -481,2 +505,0 @@\n-#endif\n-\n@@ -487,7 +509,1 @@\n-\/\/ TODO: reconcile the differences between Linux\/BSD vs AIX here!\n-#if defined(AIX)\n-  \/\/ Never leave program error signals blocked;\n-  \/\/ on all our platforms they would bring down the process immediately when\n-  \/\/ getting raised while being blocked.\n-  unblock_program_error_signals();\n-#endif\n+  PosixSignals::unblock_error_signals();\n@@ -507,0 +523,3 @@\n+\n+  PosixSignals::unblock_error_signals();\n+\n@@ -705,17 +724,1 @@\n-\n-#if defined(AIX)\n-  \/\/ Do not block out synchronous signals in the signal handler.\n-  \/\/ Blocking synchronous signals only makes sense if you can really\n-  \/\/ be sure that those signals won't happen during signal handling,\n-  \/\/ when the blocking applies. Normal signal handlers are lean and\n-  \/\/ do not cause signals. But our signal handlers tend to be \"risky\"\n-  \/\/ - secondary SIGSEGV, SIGILL, SIGBUS' may and do happen.\n-  \/\/ On AIX, PASE there was a case where a SIGSEGV happened, followed\n-  \/\/ by a SIGILL, which was blocked due to the signal mask. The process\n-  \/\/ just hung forever. Better to crash from a secondary signal than to hang.\n-  sigdelset(&(sigAct.sa_mask), SIGSEGV);\n-  sigdelset(&(sigAct.sa_mask), SIGBUS);\n-  sigdelset(&(sigAct.sa_mask), SIGILL);\n-  sigdelset(&(sigAct.sa_mask), SIGFPE);\n-  sigdelset(&(sigAct.sa_mask), SIGTRAP);\n-#endif\n+  remove_error_signals_from_set(&(sigAct.sa_mask));\n@@ -1102,0 +1105,1 @@\n+  remove_error_signals_from_set(&(sigAct.sa_mask));\n@@ -1306,4 +1310,0 @@\n-int PosixSignals::unblock_thread_signal_mask(const sigset_t *set) {\n-  return pthread_sigmask(SIG_UNBLOCK, set, NULL);\n-}\n-\n@@ -1473,0 +1473,1 @@\n+\n@@ -1477,0 +1478,2 @@\n+  PosixSignals::unblock_error_signals();\n+\n@@ -1570,0 +1573,1 @@\n+  remove_error_signals_from_set(&(act.sa_mask));\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":54,"deletions":50,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-  \/\/ unblocks the signal masks for current thread\n-  static int unblock_thread_signal_mask(const sigset_t *set);\n@@ -67,0 +65,5 @@\n+\n+  \/\/ Unblock all signals whose delivery cannot be deferred and which, if they happen\n+  \/\/  while delivery is blocked, would cause crashes or hangs (see JDK-8252533).\n+  static void unblock_error_signals();\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -104,9 +104,2 @@\n-  \/\/ unmask current signal\n-  sigset_t newset;\n-  sigemptyset(&newset);\n-  sigaddset(&newset, sig);\n-  \/\/ also unmask other synchronous signals\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    sigaddset(&newset, SIGNALS[i]);\n-  }\n-  PosixSignals::unblock_thread_signal_mask(&newset);\n+\n+  PosixSignals::unblock_error_signals();\n@@ -142,4 +135,0 @@\n-  \/\/ install signal handlers for all synchronous program error signals\n-  sigset_t newset;\n-  sigemptyset(&newset);\n-\n@@ -149,1 +138,0 @@\n-    sigaddset(&newset, SIGNALS[i]);\n@@ -151,1 +139,0 @@\n-  PosixSignals::unblock_thread_signal_mask(&newset);\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"}]}