{"files":[{"patch":"@@ -107,1 +107,1 @@\n-          \/\/ ShenandoahOldGarbageThreshold so it will be promoted in place, or because there is not sufficient room\n+          \/\/ old garbage threshold so it will be promoted in place, or because there is not sufficient room\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahGenerationalHeuristics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,2 @@\n-  _fragmentation_last_old_region(0)\n+  _fragmentation_last_old_region(0),\n+  _old_garbage_threshold(ShenandoahOldGarbageThreshold)\n@@ -376,1 +377,2 @@\n-  _old_generation->set_live_bytes_after_last_mark(live_data);\n+  \/\/ TODO: subtract from live_data bytes promoted during concurrent GC.\n+  _old_generation->set_live_bytes_at_last_mark(live_data);\n@@ -388,1 +390,1 @@\n-  const size_t garbage_threshold = region_size_bytes * ShenandoahOldGarbageThreshold \/ 100;\n+  const size_t garbage_threshold = region_size_bytes * get_old_garbage_threshold() \/ 100;\n@@ -658,0 +660,1 @@\n+    adjust_old_garbage_threshold();\n@@ -680,0 +683,1 @@\n+    adjust_old_garbage_threshold();\n@@ -702,1 +706,1 @@\n-      const size_t live_at_previous_old = _old_generation->get_live_bytes_after_last_mark();\n+      const size_t live_at_previous_old = _old_generation->get_live_bytes_at_last_mark();\n@@ -708,0 +712,1 @@\n+      adjust_old_garbage_threshold();\n@@ -716,1 +721,35 @@\n-  return this->ShenandoahHeuristics::should_start_gc();\n+  bool result = this->ShenandoahHeuristics::should_start_gc();\n+  if (result) {\n+    adjust_old_garbage_threshold();\n+  }\n+  return result;\n+}\n+\n+void ShenandoahOldHeuristics::adjust_old_garbage_threshold() {\n+  const uintx MinimumOldGarbageThreshold = 10;\n+  const uintx InterventionPercentage = 50;\n+\n+  const ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  size_t old_regions_size = _old_generation->used_regions_size();\n+  size_t soft_max_size = heap->soft_max_capacity();\n+  uintx percent_used = (uintx) ((old_regions_size * 100) \/ soft_max_size);\n+  _old_garbage_threshold = ShenandoahOldGarbageThreshold;\n+  if (percent_used > InterventionPercentage) {\n+    uintx severity = percent_used - InterventionPercentage;    \/\/ ranges from 0 to 50\n+    if (MinimumOldGarbageThreshold < ShenandoahOldGarbageThreshold) {\n+      uintx adjustment_potential = ShenandoahOldGarbageThreshold - MinimumOldGarbageThreshold;\n+      \/\/ With default values:\n+      \/\/   if percent_used > 80, garbage_threshold is 10\n+      \/\/   else if percent_used > 65, garbage_threshold is 15\n+      \/\/   else if percent_used > 50, garbage_threshold is 20\n+      if (severity > 30) {\n+        _old_garbage_threshold = ShenandoahOldGarbageThreshold - adjustment_potential;\n+      } else if (severity > 15) {\n+        _old_garbage_threshold = ShenandoahOldGarbageThreshold - 2 * adjustment_potential \/ 3;\n+      } else {\n+        _old_garbage_threshold = ShenandoahOldGarbageThreshold - adjustment_potential \/ 3;\n+      }\n+      log_info(gc)(\"Adjusting old garbage threshold to %lu because Old Generation used regions represents %lu%% of heap\",\n+                   _old_garbage_threshold, percent_used);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.cpp","additions":44,"deletions":5,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -105,0 +105,11 @@\n+  \/\/ The value of command-line argument ShenandoahOldGarbageThreshold represents the percent of garbage that must\n+  \/\/ be present within an old-generation region before that region is considered a good candidate for inclusion in\n+  \/\/ the collection set under normal circumstances.  For our purposes, normal circustances are when the memory consumed\n+  \/\/ by the old generation is less than 50% of the soft heap capacity.  When the old generation grows beyond the 50%\n+  \/\/ threshold, we dynamically adjust the old garbage threshold, allowing us to invest in packing the old generation\n+  \/\/ more tightly so that more memory can be made available to the more frequent young GC cycles.  This variable\n+  \/\/ is used in place of ShenandoahOldGarbageThreshold.  Under normal circumstances, its value is equal to\n+  \/\/ ShenandoahOldGarbageThreshold.  When the GC is under duress, this value may be adjusted to a smaller value,\n+  \/\/ as scaled according to the severity of duress that we are experiencing.\n+  uintx _old_garbage_threshold;\n+\n@@ -203,0 +214,4 @@\n+  \/\/ Returns the current value of a dynamically adjusted threshold percentage of garbage above which an old region is\n+  \/\/ deemed eligible for evacuation.\n+  inline uintx get_old_garbage_threshold() { return _old_garbage_threshold; }\n+\n@@ -206,0 +221,15 @@\n+\n+  \/\/ The normal old_garbage_threshold is specified by ShenandoahOldGarbageThreshold command-line argument, with default\n+  \/\/ value 25, denoting that a region that has at least 25% garbage is eligible for evacuation.  With default values for\n+  \/\/ all command-line arguments, we make the following adjustments:\n+  \/\/  1. If the old generation has grown to consume more than 80% of the soft max capacity, adjust threshold to 10%\n+  \/\/  2. Otherwise, if the old generation has grown to consume more than 65%, adjust threshold to 15%\n+  \/\/  3. Otherwise, if the old generation has grown to consume more than 50%, adjust threshold to 20%\n+  \/\/ The effect is to compact the old generation more aggressively as the old generation consumes larger percentages\n+  \/\/ of the available heap memory.  In these circumstances, we pack the old generation more tightly in order to make\n+  \/\/ more memory avaiable to the young generation so that the more frequent young collections can operate more\n+  \/\/ efficiently.\n+  \/\/\n+  \/\/ If the ShenandoahOldGarbageThreshold is specified on the command line, the effect of adjusting the old garbage\n+  \/\/ threshold is scaled linearly.\n+  void adjust_old_garbage_threshold();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahOldHeuristics.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -508,4 +508,4 @@\n-\/\/ Preselect for inclusion into the collection set regions whose age is at or above tenure age which contain more than\n-\/\/ ShenandoahOldGarbageThreshold amounts of garbage.  We identify these regions by setting the appropriate entry of\n-\/\/ the collection set's preselected regions array to true.  All entries are initialized to false before calling this\n-\/\/ function.\n+\/\/ Preselect for inclusion into the collection set all regions whose age is at or above tenure age and for which the\n+\/\/ garbage percentage exceeds a dynamically adjusted threshold (known as the old-garbage threshold percentage).  We\n+\/\/ identify these regions by setting the appropriate entry of the collection set's preselected regions array to true.  \n+\/\/ All entries are initialized to false before calling this function.\n@@ -534,1 +534,2 @@\n-  const size_t old_garbage_threshold = (ShenandoahHeapRegion::region_size_bytes() * ShenandoahOldGarbageThreshold) \/ 100;\n+  const size_t old_garbage_threshold =\n+    (ShenandoahHeapRegion::region_size_bytes() * heap->old_generation()->heuristics()->get_old_garbage_threshold()) \/ 100;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-  \/\/ Criterion 2. region garbage percentage > ShenandoahOldGarbageThreshold\n+  \/\/ Criterion 2. region garbage percentage > old garbage threshold\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-      \/\/ more garbage than ShenandoahOldGarbageThreshold, we'll promote by evacuation.  If there is room for evacuation\n+      \/\/ more garbage than the old garbage threshold, we'll promote by evacuation.  If there is room for evacuation\n@@ -180,1 +180,2 @@\n-    const size_t old_garbage_threshold = (region_size_bytes * ShenandoahOldGarbageThreshold) \/ 100;\n+    const size_t old_garbage_threshold =\n+      (region_size_bytes * _heap->old_generation()->heuristics()->get_old_garbage_threshold()) \/ 100;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  old->set_live_bytes_after_last_mark(old->used());\n+  old->set_live_bytes_at_last_mark(old->used());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,2 +119,1 @@\n-    _growth_before_compaction(INITIAL_GROWTH_BEFORE_COMPACTION),\n-    _min_growth_before_compaction ((ShenandoahMinOldGenGrowthPercent * FRACTIONAL_DENOMINATOR) \/ 100)\n+    _growth_percent_before_collection(INITIAL_GROWTH_PERCENT_BEFORE_COLLECTION)\n@@ -123,1 +122,1 @@\n-  _live_bytes_after_last_mark = ShenandoahHeap::heap()->capacity() * INITIAL_LIVE_FRACTION \/ FRACTIONAL_DENOMINATOR;\n+  _live_bytes_at_last_mark = (ShenandoahHeap::heap()->soft_max_capacity() * INITIAL_LIVE_PERCENT) \/ 100;\n@@ -224,2 +223,2 @@\n-size_t ShenandoahOldGeneration::get_live_bytes_after_last_mark() const {\n-  return _live_bytes_after_last_mark;\n+size_t ShenandoahOldGeneration::get_live_bytes_at_last_mark() const {\n+  return _live_bytes_at_last_mark;\n@@ -228,1 +227,1 @@\n-void ShenandoahOldGeneration::set_live_bytes_after_last_mark(size_t bytes) {\n+void ShenandoahOldGeneration::set_live_bytes_at_last_mark(size_t bytes) {\n@@ -231,2 +230,2 @@\n-    _live_bytes_after_last_mark = ShenandoahHeap::heap()->capacity() * INITIAL_LIVE_FRACTION \/ FRACTIONAL_DENOMINATOR;\n-    _growth_before_compaction = INITIAL_GROWTH_BEFORE_COMPACTION;\n+    _live_bytes_at_last_mark = (ShenandoahHeap::heap()->soft_max_capacity() * INITIAL_LIVE_PERCENT) \/ 100;\n+    _growth_percent_before_collection = INITIAL_GROWTH_PERCENT_BEFORE_COLLECTION;\n@@ -234,4 +233,4 @@\n-    _live_bytes_after_last_mark = bytes;\n-    _growth_before_compaction \/= 2;\n-    if (_growth_before_compaction < _min_growth_before_compaction) {\n-      _growth_before_compaction = _min_growth_before_compaction;\n+    _live_bytes_at_last_mark = bytes;\n+    _growth_percent_before_collection \/= 2;\n+    if (_growth_percent_before_collection < ShenandoahMinOldGenGrowthPercent) {\n+      _growth_percent_before_collection = ShenandoahMinOldGenGrowthPercent;\n@@ -247,1 +246,13 @@\n-  size_t result = _live_bytes_after_last_mark + (_live_bytes_after_last_mark * _growth_before_compaction) \/ FRACTIONAL_DENOMINATOR;\n+  size_t threshold_by_relative_growth =\n+    _live_bytes_at_last_mark + (_live_bytes_at_last_mark * _growth_percent_before_collection) \/ 100;\n+  size_t soft_max_capacity = ShenandoahHeap::heap()->soft_max_capacity();\n+  size_t threshold_by_growth_into_percent_remaining;\n+  if (_live_bytes_at_last_mark < soft_max_capacity) {\n+    threshold_by_growth_into_percent_remaining = (size_t)\n+      (_live_bytes_at_last_mark + ((soft_max_capacity - _live_bytes_at_last_mark)\n+                                      * ShenandoahMinOldGenGrowthRemainingHeapPercent \/ 100.0));\n+  } else {\n+    \/\/ we're already consuming more than soft max capacity, so we should start old GC right away.\n+    threshold_by_growth_into_percent_remaining = soft_max_capacity;\n+  }\n+  size_t result = MIN2(threshold_by_relative_growth, threshold_by_growth_into_percent_remaining);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -290,2 +290,0 @@\n-  static const size_t FRACTIONAL_DENOMINATOR = 65536;\n-\n@@ -293,9 +291,7 @@\n-  \/\/ collection when old-gen usage is 50% more (INITIAL_GROWTH_BEFORE_COMPACTION) than the initial old-gen size\n-  \/\/ estimate (3.125% of heap).  The next old-gen trigger occurs when old-gen grows 25% larger than its live\n-  \/\/ memory at the end of the first old-gen collection.  Then we trigger again when old-gen grows 12.5%\n-  \/\/ more than its live memory at the end of the previous old-gen collection.  Thereafter, we trigger each time\n-  \/\/ old-gen grows more than 12.5% following the end of its previous old-gen collection.\n-  static const size_t INITIAL_GROWTH_BEFORE_COMPACTION = FRACTIONAL_DENOMINATOR \/ 2;        \/\/  50.0%\n-\n-  \/\/ INITIAL_LIVE_FRACTION represents the initial guess of how large old-gen should be.  We estimate that old-gen\n-  \/\/ needs to consume 6.25% of the total heap size.  And we \"pretend\" that we start out with this amount of live\n+  \/\/ collection when old-gen usage is 50% more (INITIAL_GROWTH_PERCENT_BEFORE_COLLECTION) than the initial old-gen size\n+  \/\/ estimate (16% of heap).  With each successive old-gen collection, we divide the growth trigger by two, but\n+  \/\/ never use a growth trigger smaller than ShenandoahMinOldGenGrowthPercent.\n+  static const size_t INITIAL_GROWTH_PERCENT_BEFORE_COLLECTION = 50;\n+\n+  \/\/ INITIAL_LIVE_PERCENT represents the initial guess of how large old-gen should be.  We estimate that old gen\n+  \/\/ needs to consume 16% of the total heap size.  And we \"pretend\" that we start out with this amount of live\n@@ -303,3 +299,3 @@\n-  \/\/ approximation of the old-gen memory requirement, in other words when old-gen usage is 150% of 6.25%, which\n-  \/\/ is 9.375% of the total heap size.\n-  static const uint16_t INITIAL_LIVE_FRACTION = FRACTIONAL_DENOMINATOR \/ 16;                \/\/   6.25%\n+  \/\/ approximation of the old-gen memory requirement, in other words when old-gen usage is 150% of 16%, which\n+  \/\/ is 24% of the heap size.\n+  static const size_t INITIAL_LIVE_PERCENT = 16;\n@@ -307,1 +303,1 @@\n-  size_t _live_bytes_after_last_mark;\n+  size_t _live_bytes_at_last_mark;\n@@ -309,3 +305,2 @@\n-  \/\/ How much growth in usage before we trigger old collection, per FRACTIONAL_DENOMINATOR (65_536)\n-  size_t _growth_before_compaction;\n-  const size_t _min_growth_before_compaction;                                               \/\/ Default is 12.5%\n+  \/\/ How much growth in usage before we trigger old collection as a percent of soft_max_capacity\n+  size_t _growth_percent_before_collection;\n@@ -326,2 +321,2 @@\n-  size_t get_live_bytes_after_last_mark() const;\n-  void set_live_bytes_after_last_mark(size_t new_live);\n+  size_t get_live_bytes_at_last_mark() const;\n+  void set_live_bytes_at_last_mark(size_t new_live);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  product(double, ShenandoahMinOldGenGrowthPercent, 12.5, EXPERIMENTAL,     \\\n+  product(double, ShenandoahMinOldGenGrowthPercent, 50, EXPERIMENTAL,       \\\n@@ -65,3 +65,2 @@\n-          \"at completion of the most recent old-generation marking \"        \\\n-          \"effort, heuristics may trigger the start of a new old-gen \"      \\\n-          \"collection.\")                                                    \\\n+          \"at the start of the previous old-generation marking effort, \"    \\\n+          \"heuristics may trigger the start of a new old-gen collection.\")  \\\n@@ -70,1 +69,16 @@\n-  product(uintx, ShenandoahIgnoreOldGrowthBelowPercentage,10, EXPERIMENTAL, \\\n+  product(double, ShenandoahMinOldGenGrowthRemainingHeapPercent,            \\\n+          35, EXPERIMENTAL,                                                 \\\n+          \"(Generational mode only) If the usage within old generation \"    \\\n+          \"has grown to exceed this percent of the remaining heap that \"    \\\n+          \"was not marked live within the old generation at the time \"      \\\n+          \"of the last old-generation marking effort, heuristics may \"      \\\n+          \"trigger the start of a new old-gen collection.  Setting \"        \\\n+          \"this value to a smaller value may cause back-to-back old \"       \\\n+          \"generation marking triggers, since the typical memory used \"     \\\n+          \"by the old generation is about 30% larger than the live \"        \\\n+          \"memory contained within the old generation (because default \"    \\\n+          \"value of ShenandoahOldGarbageThreshold is 25.\")                  \\\n+          range(0.0,100.0)                                                  \\\n+                                                                            \\\n+  product(uintx, ShenandoahIgnoreOldGrowthBelowPercentage,                  \\\n+          40, EXPERIMENTAL,                                                 \\\n@@ -80,6 +94,7 @@\n-          50, EXPERIMENTAL,                                                 \\\n-          \"(Generational mode only) Even if the usage of old generation \"   \\\n-          \"is below ShenandoahIgnoreOldGrowthBelowPercentage, \"             \\\n-          \"trigger an old-generation mark if old has grown and this \"       \\\n-          \"many consecutive young-gen collections have been \"               \\\n-          \"completed following the preceding old-gen collection.\")          \\\n+          100, EXPERIMENTAL,                                                \\\n+          \"(Generational mode only) Trigger an old-generation mark \"        \\\n+          \"if old has grown and this many consecutive young-gen \"           \\\n+          \"collections have been completed following the preceding \"        \\\n+          \"old-gen collection.  We perform this old-generation mark \"       \\\n+          \"evvort even if the usage of old generation is below \"            \\\n+          \"ShenandoahIgnoreOldGrowthBelowPercentage.\")                      \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -102,0 +102,3 @@\n+                \"-XX:ShenandoahMinOldGenGrowthPercent=12.5\",\n+                \"-XX:ShenandoahIgnoreOldGrowthBelowPercentage=10\",\n+                \"-XX:ShenandoahMinOldGenGrowthRemainingHeapPercent=100\",\n@@ -103,1 +106,2 @@\n-                \"-XX:ShenandoahGuaranteedOldGCInterval=0\"\n+                \"-XX:ShenandoahGuaranteedOldGCInterval=0\",\n+                \"-XX:-UseCompactObjectHeaders\"\n@@ -113,0 +117,3 @@\n+                \"-XX:ShenandoahMinOldGenGrowthPercent=12.5\",\n+                \"-XX:ShenandoahIgnoreOldGrowthBelowPercentage=10\",\n+                \"-XX:ShenandoahMinOldGenGrowthRemainingHeapPercent=100\",\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/generational\/TestOldGrowthTriggers.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}