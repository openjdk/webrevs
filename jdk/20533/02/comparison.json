{"files":[{"patch":"@@ -1856,0 +1856,4 @@\n+        if (bestSoFar.kind == AMBIGUOUS) {\n+            AmbiguityError a_err = (AmbiguityError)bestSoFar.baseSymbol();\n+            bestSoFar = a_err.mergeAbstracts(site);\n+        }\n@@ -2760,1 +2764,1 @@\n-                    Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+                    Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2792,1 +2796,1 @@\n-            Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+            Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2916,1 +2920,1 @@\n-            Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+            Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -2975,1 +2979,1 @@\n-                    Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n+                    Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n@@ -3506,12 +3510,0 @@\n-        @Override\n-        final Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n-            Symbol sym = doLookup(env, phase);\n-            if (sym.kind == AMBIGUOUS) {\n-                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n-                sym = a_err.mergeAbstracts(site);\n-            }\n-            return sym;\n-        }\n-\n-        abstract Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase);\n-\n@@ -3564,4 +3556,0 @@\n-            if (sym.kind == AMBIGUOUS) {\n-                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n-                sym = a_err.mergeAbstracts(site);\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8337980\n+ * @summary Test compiler crash due to failure to resolve method ambiguity\n+ * @compile\/fail\/ref=MethodAmbiguityCrash1.out -XDrawDiagnostics MethodAmbiguityCrash1.java\n+ *\/\n+public class MethodAmbiguityCrash1 {\n+\n+    public interface A {\n+        int op();\n+    }\n+\n+    public abstract static class B {\n+        abstract int op();\n+    }\n+\n+    public abstract static class C extends B implements A {\n+\n+        public static int test() {\n+            return op();    \/\/ compile should fail here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/resolve\/MethodAmbiguityCrash1.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+MethodAmbiguityCrash1.java:20:20: compiler.err.non-static.cant.be.ref: kindname.method, op()\n+1 error\n","filename":"test\/langtools\/tools\/javac\/resolve\/MethodAmbiguityCrash1.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8337980\n+ * @summary Test compiler crash due to failure to resolve method ambiguity\n+ * @compile\/fail\/ref=MethodAmbiguityCrash2.out -XDrawDiagnostics MethodAmbiguityCrash2.java\n+ *\/\n+public class MethodAmbiguityCrash2 {\n+\n+    public interface A {\n+        int op();\n+    }\n+\n+    public abstract static class B {\n+        public abstract int op();\n+    }\n+\n+    public abstract static class C extends B implements A {\n+\n+        public C(int x) {\n+        }\n+\n+        public C() {\n+            this(op());     \/\/ compile should fail here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/resolve\/MethodAmbiguityCrash2.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+MethodAmbiguityCrash2.java:23:18: compiler.err.cant.ref.before.ctor.called: op()\n+1 error\n","filename":"test\/langtools\/tools\/javac\/resolve\/MethodAmbiguityCrash2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"}]}