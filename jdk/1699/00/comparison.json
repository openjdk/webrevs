{"files":[{"patch":"@@ -793,1 +793,9 @@\n-     * <p>Note that in most cases, for two instances of class\n+     * @apiNote\n+     * This method is defined in terms of {@link\n+     * #doubleToLongBits(double)} rather than the {@code ==} operator\n+     * on {@code double} values since the {@code ==} operator does\n+     * <em>not<\/em> define an equivalence relation and to satisfy the\n+     * {@linkplain Object#equals equals contract} an equivalence\n+     * relation must be implemented.\n+     *\n+     * However, in most cases, for two instances of class\n@@ -803,1 +811,2 @@\n-     * exceptions:\n+     * exceptions where the properties of an equivalence relations are\n+     * not satisfied by {@code ==}:\n@@ -809,1 +818,4 @@\n-     *     {@code false}.\n+     *     {@code false}. Therefore, for two NaN arguments the\n+     *     <em>reflexive<\/em> property of an equivalence relation is\n+     *     <em>not<\/em> satisfied by the {@code ==} operator.\n+     *\n@@ -812,1 +824,1 @@\n-     *     the {@code equal} test has the value {@code false},\n+     *     the {@code equals} method returns the value {@code false},\n@@ -814,0 +826,9 @@\n+     *\n+     *     In other words, while {@code +0.0} and {@code -0.0} compare\n+     *     as equal under the {@code ==} operator, they are\n+     *     <em>not<\/em> equivalent values because signed zeros can be\n+     *     distinguished under other floating-point operations. For\n+     *     example, {@code 1.0\/+0.0} evaluates to positive infinity\n+     *     while {@code 1.0\/-0.0} evaluates to <em>negative<\/em>\n+     *     infinity and positive infinity and negative infinity are\n+     *     neither equal to each other nor equivalent to each other.\n@@ -815,1 +836,10 @@\n-     * This definition allows hash tables to operate properly.\n+     *\n+     * Despite not defining an equivalence relation, the semantics of\n+     * the IEEE 754 {@code ==} operator were deliberately designed to\n+     * meet other needs of numerical computation.\n+     *\n+     * By defining an equivalence relation largely consistent with the\n+     * {@code ==} operator, this method allows hash tables on {@code\n+     * Double} objects to operate properly while reducing surprising\n+     * behavior.\n+     *\n@@ -820,0 +850,3 @@\n+     * @jls 4.2.3 Floating-Point Types, Formats, and Values\n+     * @jls 4.2.4. Floating-Point Operations\n+     * @jls 15.21.1 Numerical Equality Operators == and !=\n@@ -971,13 +1004,23 @@\n-     * Compares two {@code Double} objects numerically.  There\n-     * are two ways in which comparisons performed by this method\n-     * differ from those performed by the Java language numerical\n-     * comparison operators ({@code <, <=, ==, >=, >})\n-     * when applied to primitive {@code double} values:\n-     * <ul><li>\n-     *          {@code Double.NaN} is considered by this method\n-     *          to be equal to itself and greater than all other\n-     *          {@code double} values (including\n-     *          {@code Double.POSITIVE_INFINITY}).\n-     * <li>\n-     *          {@code 0.0d} is considered by this method to be greater\n-     *          than {@code -0.0d}.\n+     * Compares two {@code Double} objects numerically.\n+\n+     * This method imposes a total order on {@code Double} objects\n+     * with two differences compared to the incomplete order defined the\n+     * by Java language numerical comparison operators ({@code <, <=,\n+     * ==, >=, >}) on {@code double} values.\n+\n+     * There are two ways in which comparisons performed by this\n+     * method differ from those performed by the Java language\n+     * numerical comparison operators when applied to primitive {@code\n+     * double} values:\n+     *\n+     * <ul><li> A NaN is <em>unordered<\/em> with respect to other\n+     *          values and unequal to itself under the comparison\n+     *          operators.  This method chooses to define {@code\n+     *          Double.NaN} to be equal to itself and greater than all\n+     *          other {@code double} values (including {@code\n+     *          Double.POSITIVE_INFINITY}).\n+     *\n+     *      <li> Positive zero and negative zero compare equal\n+     *      numerically, but are distinct and distinguishable values.\n+     *      This method chooses to define positive zero ({@code\n+     *      0.0d}), to be greater than negative zero({@code -0.0d}).\n@@ -999,0 +1042,4 @@\n+     * @jls 4.2.3 Floating-Point Types, Formats, and Values\n+     * @jls 4.2.4. Floating-Point Operations\n+     * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n+     * @jls 15.21.1 Numerical Equality Operators == and !=\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Double.java","additions":65,"deletions":18,"binary":false,"changes":83,"status":"modified"}]}