{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.Executors;\n@@ -48,8 +49,9 @@\n-        final ConcurrentHashMap<Integer, Integer> m = new ConcurrentHashMap<>();\n-        final ThreadLocalRandom rnd = ThreadLocalRandom.current();\n-        final int nCPU = Runtime.getRuntime().availableProcessors();\n-        final int minWorkers = 2;\n-        final int maxWorkers = Math.max(minWorkers, Math.min(32, nCPU));\n-        final int nWorkers = rnd.nextInt(minWorkers, maxWorkers + 1);\n-        final int sizePerWorker = 1024;\n-        final int maxSize = nWorkers * sizePerWorker;\n+        try (var executor = Executors.newCachedThreadPool()) {\n+            final ConcurrentHashMap<Integer, Integer> m = new ConcurrentHashMap<>();\n+            final ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+            final int nCPU = Runtime.getRuntime().availableProcessors();\n+            final int minWorkers = 2;\n+            final int maxWorkers = Math.max(minWorkers, Math.min(32, nCPU));\n+            final int nWorkers = rnd.nextInt(minWorkers, maxWorkers + 1);\n+            final int sizePerWorker = 1024;\n+            final int maxSize = nWorkers * sizePerWorker;\n@@ -57,3 +59,3 @@\n-        \/\/ The foreman busy-checks that the size of the arrays obtained\n-        \/\/ from the keys and values views grows monotonically until it\n-        \/\/ reaches the maximum size.\n+            \/\/ The foreman busy-checks that the size of the arrays obtained\n+            \/\/ from the keys and values views grows monotonically until it\n+            \/\/ reaches the maximum size.\n@@ -61,4 +63,4 @@\n-        \/\/ NOTE: these size constraints are not specific to toArray and are\n-        \/\/ applicable to any form of traversal of the collection views\n-        CompletableFuture<?> foreman = CompletableFuture.runAsync(new Runnable() {\n-            private int prevSize = 0;\n+            \/\/ NOTE: these size constraints are not specific to toArray and are\n+            \/\/ applicable to any form of traversal of the collection views\n+            CompletableFuture<?> foreman = CompletableFuture.runAsync(new Runnable() {\n+                private int prevSize = 0;\n@@ -66,9 +68,9 @@\n-            private boolean checkProgress(Object[] a) {\n-                int size = a.length;\n-                if (size < prevSize || size > maxSize)\n-                    throw new AssertionError(\n-                        String.format(\"prevSize=%d size=%d maxSize=%d\",\n-                                      prevSize, size, maxSize));\n-                prevSize = size;\n-                return size == maxSize;\n-            }\n+                private boolean checkProgress(Object[] a) {\n+                    int size = a.length;\n+                    if (size < prevSize || size > maxSize)\n+                        throw new AssertionError(\n+                                String.format(\"prevSize=%d size=%d maxSize=%d\",\n+                                        prevSize, size, maxSize));\n+                    prevSize = size;\n+                    return size == maxSize;\n+                }\n@@ -76,10 +78,10 @@\n-            public void run() {\n-                Integer[] empty = new Integer[0];\n-                for (;;)\n-                    if (checkProgress(m.values().toArray())\n-                        & checkProgress(m.keySet().toArray())\n-                        & checkProgress(m.values().toArray(empty))\n-                        & checkProgress(m.keySet().toArray(empty)))\n-                        return;\n-            }\n-        });\n+                public void run() {\n+                    Integer[] empty = new Integer[0];\n+                    for (; ; )\n+                        if (checkProgress(m.values().toArray())\n+                                & checkProgress(m.keySet().toArray())\n+                                & checkProgress(m.values().toArray(empty))\n+                                & checkProgress(m.keySet().toArray(empty)))\n+                            return;\n+                }\n+            }, executor);\n@@ -87,9 +89,9 @@\n-        \/\/ Each worker puts globally unique keys into the map\n-        List<CompletableFuture<?>> workers =\n-            IntStream.range(0, nWorkers)\n-            .mapToObj(w -> (Runnable) () -> {\n-                for (int i = 0, o = w * sizePerWorker; i < sizePerWorker; i++)\n-                    m.put(o + i, i);\n-            })\n-            .map(CompletableFuture::runAsync)\n-            .collect(Collectors.toList());\n+            \/\/ Each worker puts globally unique keys into the map\n+            List<CompletableFuture<?>> workers =\n+                    IntStream.range(0, nWorkers)\n+                            .mapToObj(w -> (Runnable) () -> {\n+                                for (int i = 0, o = w * sizePerWorker; i < sizePerWorker; i++)\n+                                    m.put(o + i, i);\n+                            })\n+                            .map(r -> CompletableFuture.runAsync(r, executor))\n+                            .collect(Collectors.toList());\n@@ -97,3 +99,4 @@\n-        \/\/ Wait for workers and foreman to complete\n-        workers.forEach(CompletableFuture<?>::join);\n-        foreman.join();\n+            \/\/ Wait for workers and foreman to complete\n+            workers.forEach(CompletableFuture<?>::join);\n+            foreman.join();\n+        }\n","filename":"test\/jdk\/java\/util\/concurrent\/ConcurrentHashMap\/ToArray.java","additions":50,"deletions":47,"binary":false,"changes":97,"status":"modified"}]}