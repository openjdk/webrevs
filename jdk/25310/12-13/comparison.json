{"files":[{"patch":"@@ -286,2 +286,4 @@\n-     *   < 4 bytes > Peer certificate length\n-     *   < length in bytes> Peer certificate\n+     *   For each entry {\n+     *     < 4 bytes > Peer certificate length\n+     *     < length in bytes> Peer certificate\n+     *   }\n@@ -289,3 +291,5 @@\n-     *   < 1 byte > Local Certificate algorithm length\n-     *   < length in bytes> Local Certificate algorithm\n-     *   < 4 bytes > Certificate checksum\n+     *   For each entry {\n+     *     < 1 byte > Local Certificate algorithm length\n+     *     < length in bytes> Local Certificate algorithm\n+     *     < 4 bytes > Certificate checksum\n+     *   }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -107,27 +107,30 @@\n-            case BASIC:\n-                \/\/ Fail if session is not resumed or session's certificates\n-                \/\/ are not restored correctly.\n-                if (secondSession.getCreationTime() > secondStartTime) {\n-                    throw new RuntimeException(\"Session was not reused\");\n-                } else if (!java.util.Arrays.equals(\n-                        firstSession.getLocalCertificates(),\n-                        secondSession.getLocalCertificates())) {\n-                    throw new RuntimeException(\"Certificates do not match\");\n-                }\n-                break;\n-            case CLIENT_AUTH:\n-                \/\/ throws an exception if the client is not authenticated\n-                secondSession.getPeerCertificates();\n-                break;\n-            case VERSION_2_TO_3:\n-            case VERSION_3_TO_2:\n-            case CIPHER_SUITE:\n-            case SIGNATURE_SCHEME:\n-            case LOCAL_CERTS:\n-                \/\/ fail if a new session is not created\n-                if (secondSession.getCreationTime() <= secondStartTime) {\n-                    throw new RuntimeException(\"Existing session was used\");\n-                }\n-                break;\n-            default:\n-                throw new RuntimeException(\"unknown mode: \" + testMode);\n+        case BASIC:\n+            \/\/ fail if session is not resumed\n+            if (secondSession.getCreationTime() > secondStartTime) {\n+                throw new RuntimeException(\"Session was not reused\");\n+            }\n+\n+            \/\/ Fail if session's certificates are not restored correctly.\n+            if (!java.util.Arrays.equals(\n+                    firstSession.getLocalCertificates(),\n+                    secondSession.getLocalCertificates())) {\n+                throw new RuntimeException(\"Certificates do not match\");\n+            }\n+\n+            break;\n+        case CLIENT_AUTH:\n+            \/\/ throws an exception if the client is not authenticated\n+            secondSession.getPeerCertificates();\n+            break;\n+        case VERSION_2_TO_3:\n+        case VERSION_3_TO_2:\n+        case CIPHER_SUITE:\n+        case SIGNATURE_SCHEME:\n+        case LOCAL_CERTS:\n+            \/\/ fail if a new session is not created\n+            if (secondSession.getCreationTime() <= secondStartTime) {\n+                throw new RuntimeException(\"Existing session was used\");\n+            }\n+            break;\n+        default:\n+            throw new RuntimeException(\"unknown mode: \" + testMode);\n@@ -177,34 +180,5 @@\n-                case BASIC:\n-                    \/\/ do nothing to ensure resumption works\n-                    break;\n-                case CLIENT_AUTH:\n-                    if (second) {\n-                        params.setNeedClientAuth(true);\n-                    } else {\n-                        params.setNeedClientAuth(false);\n-                    }\n-                    break;\n-                case VERSION_2_TO_3:\n-                    if (second) {\n-                        params.setProtocols(new String[]{\"TLSv1.3\"});\n-                    } else {\n-                        params.setProtocols(new String[]{\"TLSv1.2\"});\n-                    }\n-                    break;\n-                case VERSION_3_TO_2:\n-                    if (second) {\n-                        params.setProtocols(new String[]{\"TLSv1.2\"});\n-                    } else {\n-                        params.setProtocols(new String[]{\"TLSv1.3\"});\n-                    }\n-                    break;\n-                case CIPHER_SUITE:\n-                    if (second) {\n-                        params.setCipherSuites(\n-                                new String[]{\"TLS_AES_128_GCM_SHA256\"});\n-                    } else {\n-                        params.setCipherSuites(\n-                                new String[]{\"TLS_AES_256_GCM_SHA384\"});\n-                    }\n-                    break;\n-                case SIGNATURE_SCHEME:\n+            case BASIC:\n+                \/\/ do nothing to ensure resumption works\n+                break;\n+            case CLIENT_AUTH:\n+                if (second) {\n@@ -212,23 +186,52 @@\n-                    AlgorithmConstraints constraints =\n-                            params.getAlgorithmConstraints();\n-                    if (second) {\n-                        params.setAlgorithmConstraints(\n-                                new NoSig(\"ecdsa_secp384r1_sha384\"));\n-                    } else {\n-                        params.setAlgorithmConstraints(\n-                                new NoSig(\"ecdsa_secp521r1_sha512\"));\n-                    }\n-                    break;\n-                case LOCAL_CERTS:\n-                    if (second) {\n-                        \/\/ Add first session's certificate signature\n-                        \/\/ algorithm to constraints so local certificates\n-                        \/\/ can't be restored from the session ticket.\n-                        params.setAlgorithmConstraints(\n-                                new NoSig(X509CertImpl.toImpl((X509CertImpl)\n-                                                firstSession.getLocalCertificates()[0])\n-                                        .getSigAlgName()));\n-                    }\n-                    break;\n-                default:\n-                    throw new RuntimeException(\"unknown mode: \" + mode);\n+                } else {\n+                    params.setNeedClientAuth(false);\n+                }\n+                break;\n+            case VERSION_2_TO_3:\n+                if (second) {\n+                    params.setProtocols(new String[]{\"TLSv1.3\"});\n+                } else {\n+                    params.setProtocols(new String[]{\"TLSv1.2\"});\n+                }\n+                break;\n+            case VERSION_3_TO_2:\n+                if (second) {\n+                    params.setProtocols(new String[]{\"TLSv1.2\"});\n+                } else {\n+                    params.setProtocols(new String[]{\"TLSv1.3\"});\n+                }\n+                break;\n+            case CIPHER_SUITE:\n+                if (second) {\n+                    params.setCipherSuites(\n+                        new String[] {\"TLS_AES_128_GCM_SHA256\"});\n+                } else {\n+                    params.setCipherSuites(\n+                        new String[] {\"TLS_AES_256_GCM_SHA384\"});\n+                }\n+                break;\n+            case SIGNATURE_SCHEME:\n+                params.setNeedClientAuth(true);\n+                AlgorithmConstraints constraints =\n+                    params.getAlgorithmConstraints();\n+                if (second) {\n+                    params.setAlgorithmConstraints(\n+                            new NoSig(\"ecdsa_secp384r1_sha384\"));\n+                } else {\n+                    params.setAlgorithmConstraints(\n+                            new NoSig(\"ecdsa_secp521r1_sha512\"));\n+                }\n+                break;\n+            case LOCAL_CERTS:\n+                if (second) {\n+                    \/\/ Add first session's certificate signature\n+                    \/\/ algorithm to constraints so local certificates\n+                    \/\/ can't be restored from the session ticket.\n+                    params.setAlgorithmConstraints(\n+                            new NoSig(X509CertImpl.toImpl((X509CertImpl)\n+                                            firstSession.getLocalCertificates()[0])\n+                                    .getSigAlgName()));\n+                }\n+                break;\n+            default:\n+                throw new RuntimeException(\"unknown mode: \" + mode);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksServer.java","additions":87,"deletions":84,"binary":false,"changes":171,"status":"modified"}]}