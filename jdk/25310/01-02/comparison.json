{"files":[{"patch":"@@ -27,0 +27,3 @@\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.zip.Adler32;\n@@ -266,2 +269,0 @@\n-     *     < 1 byte > preSharedKey algorithm length\n-     *     < length in bytes > preSharedKey algorithm\n@@ -271,2 +272,0 @@\n-     *     < 1 byte > masterSecret algorithm length\n-     *     < length in bytes > masterSecret algorithm\n@@ -292,1 +291,1 @@\n-     * < 1 byte > Number of Local Certificate algorithms\n+     * < 1 byte > Number of Local Certificate entries\n@@ -295,0 +294,1 @@\n+     *   < 4 bytes > Certificate checksum\n@@ -322,1 +322,1 @@\n-            b = Record.getBytes8(buf);\n+            b = Record.getBytes16(buf);\n@@ -324,4 +324,1 @@\n-                String alg = new String(b);\n-                \/\/ Pre-shared key\n-                b = Record.getBytes16(buf);\n-                this.preSharedKey = new SecretKeySpec(b, alg);\n+                this.preSharedKey = new SecretKeySpec(b, \"TlsMasterSecret\");\n@@ -335,1 +332,1 @@\n-            b = Record.getBytes8(buf);\n+            b = Record.getBytes16(buf);\n@@ -337,4 +334,1 @@\n-                String alg = new String(b);\n-                \/\/ Master secret key\n-                b = Record.getBytes16(buf);\n-                this.masterSecret = new SecretKeySpec(b, alg);\n+                this.masterSecret = new SecretKeySpec(b, \"TlsMasterSecret\");\n@@ -409,1 +403,1 @@\n-        \/\/ Load local certificates if cert algorithm(s) present.\n+        \/\/ Restore local certificates if cert algorithm(s) present.\n@@ -415,0 +409,1 @@\n+            Set<Integer> certCheckSums = new HashSet<>(len);\n@@ -418,0 +413,1 @@\n+                certCheckSums.add(Record.getInt32(buf));\n@@ -422,17 +418,20 @@\n-\n-            if (pos == null) {\n-                throw hc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n-                        \"No available certificates for algorithms: \"\n-                                + Arrays.toString(certAlgs));\n-            }\n-\n-            if (!(pos instanceof X509Possession x509Possession)) {\n-                throw hc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n-                        \"No available X.509 certificates for algorithms: \"\n-                                + Arrays.toString(certAlgs));\n-            }\n-\n-            localCerts = x509Possession.popCerts;\n-            if (localCerts == null || localCerts.length == 0) {\n-                throw hc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n-                        \"No available local X.509 certificate\");\n+            List<X509Certificate> tmpCerts = new ArrayList<>(len);\n+\n+            if (pos instanceof X509Possession x509Pos\n+                    && x509Pos.popCerts != null\n+                    && x509Pos.popCerts.length == len) {\n+\n+                for (int i = 0; i < x509Pos.popCerts.length; i++) {\n+                    try {\n+                        byte[] encoded = x509Pos.popCerts[i].getEncoded();\n+                        if (certCheckSums.contains(getChecksum(encoded))) {\n+                            \/\/ Use certs from cache.\n+                            tmpCerts.add(\n+                                    X509Factory.cachedGetX509Cert(encoded));\n+                        } else {\n+                            break;\n+                        }\n+                    } catch (Exception e) {\n+                        throw new IOException(e);\n+                    }\n+                }\n@@ -441,7 +440,12 @@\n-            \/\/ Use certs from cache.\n-            for (int i = 0; i < localCerts.length; i++) {\n-                try {\n-                    localCerts[i] = X509Factory.cachedGetX509Cert(\n-                            localCerts[i].getEncoded());\n-                } catch (Exception e) {\n-                    throw new IOException(e);\n+            if (tmpCerts.size() == len) {\n+                this.localCerts = tmpCerts.toArray(new X509Certificate[len]);\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.finest(\"Restored \" + len\n+                            + \" local certificates from session ticket\");\n+                }\n+            } else {\n+                this.localCerts = null;\n+                this.invalidated = true;\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.warning(\"Local certificates can not be restored \"\n+                            + \"from session ticket\");\n@@ -499,3 +503,2 @@\n-            if (preSharedKey == null ||\n-                    preSharedKey.getAlgorithm() == null) {\n-                hos.putInt8(0);\n+            if (preSharedKey == null) {\n+                hos.putInt16(0);\n@@ -503,1 +506,0 @@\n-                hos.putBytes8(preSharedKey.getAlgorithm().getBytes());\n@@ -508,3 +510,2 @@\n-            if (getMasterSecret() == null ||\n-                    getMasterSecret().getAlgorithm() == null) {\n-                hos.putInt8(0);\n+            if (getMasterSecret() == null) {\n+                hos.putInt16(0);\n@@ -512,1 +513,0 @@\n-                hos.putBytes8(masterSecret.getAlgorithm().getBytes());\n@@ -576,1 +576,1 @@\n-        \/\/ Local certificates' algorithms.\n+        \/\/ Local certificates' algorithms and checksums.\n@@ -585,0 +585,1 @@\n+                hos.putInt32(getChecksum(c.getEncoded()));\n@@ -591,0 +592,6 @@\n+    private int getChecksum(byte[] input) {\n+        Adler32 adler32 = new Adler32();\n+        adler32.update(input);\n+        return (int) adler32.getValue();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":56,"deletions":49,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -224,6 +224,1 @@\n-                c.updateAAD(new byte[] {\n-                        (byte)(key.num >>> 24),\n-                        (byte)(key.num >>> 16),\n-                        (byte)(key.num >>> 8),\n-                        (byte)(key.num)}\n-                );\n+\n@@ -239,0 +234,3 @@\n+                    if (data == null) {\n+                        return null;\n+                    }\n@@ -242,0 +240,4 @@\n+                ByteBuffer aad = ByteBuffer.allocate(Integer.BYTES + 1);\n+                aad.putInt(key.num).put(compressed);\n+                c.updateAAD(aad);\n+\n@@ -262,1 +264,1 @@\n-        ByteBuffer decrypt(HandshakeContext hc) throws IOException {\n+        ByteBuffer decrypt(HandshakeContext hc) {\n@@ -277,6 +279,0 @@\n-                c.updateAAD(new byte[] {\n-                        (byte)(keyID >>> 24),\n-                        (byte)(keyID >>> 16),\n-                        (byte)(keyID >>> 8),\n-                        (byte)(keyID)}\n-                );\n@@ -285,2 +281,6 @@\n-                ByteBuffer out;\n-                out = ByteBuffer.allocate(data.remaining() - GCM_TAG_LEN \/ 8);\n+                ByteBuffer aad = ByteBuffer.allocate(Integer.BYTES + 1);\n+                aad.putInt(keyID).put(compressed);\n+                c.updateAAD(aad);\n+\n+                ByteBuffer out = ByteBuffer.allocate(\n+                        data.remaining() - GCM_TAG_LEN \/ 8);\n@@ -333,6 +333,1 @@\n-                final byte[] tmp = new byte[compressedLen * 3];\n-                int count = 0;\n-                int b;\n-                while ((b = gis.read()) >= 0) {\n-                    tmp[count++] = (byte) b;\n-                }\n+                byte[] out = gis.readAllBytes();\n@@ -342,1 +337,1 @@\n-                            + \"; decompressed bytes: \" + count);\n+                            + \"; decompressed bytes: \" + out.length);\n@@ -345,1 +340,1 @@\n-                return ByteBuffer.wrap(Arrays.copyOf(tmp, count));\n+                return ByteBuffer.wrap(out);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":18,"deletions":23,"binary":false,"changes":41,"status":"modified"}]}