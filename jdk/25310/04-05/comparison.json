{"files":[{"patch":"@@ -461,1 +461,3 @@\n-            \/\/ Make sure the list of supported signature algorithms matches\n+            \/\/ Make sure the list of supported signature algorithms matches.\n+            \/\/ HandshakeContext's localSupportedCertSignAlgs has been already\n+            \/\/ updated when we set the negotiated protocol.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -431,2 +431,0 @@\n-                        } else {\n-                            break;\n@@ -442,3 +440,4 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.finest(\"Restored \" + len\n-                            + \" local certificates from session ticket\");\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,session\")) {\n+                    SSLLogger.fine(\"Restored \" + len\n+                            + \" local certificates from session ticket\"\n+                            + \" for algorithms \" + Arrays.toString(certAlgs));\n@@ -449,1 +448,1 @@\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,session\")) {\n@@ -451,1 +450,2 @@\n-                            + \"from session ticket\");\n+                            + \"from session ticket \"\n+                            + \"for algorithms \" + Arrays.toString(certAlgs));\n@@ -592,1 +592,1 @@\n-    private int getChecksum(byte[] input) {\n+    private static int getChecksum(byte[] input) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-                    SSLLogger.finest(\"decompressed bytes: \" + decompressedLen\n+                    SSLLogger.fine(\"decompressed bytes: \" + decompressedLen\n@@ -328,1 +328,1 @@\n-                    SSLLogger.finest(\"compressed bytes: \" + compressedLen\n+                    SSLLogger.fine(\"compressed bytes: \" + compressedLen\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import sun.security.x509.X509CertImpl;\n@@ -60,1 +61,2 @@\n-        SIGNATURE_SCHEME\n+        SIGNATURE_SCHEME,\n+        LOCAL_CERTS\n@@ -74,0 +76,1 @@\n+        SSLSession firstSession;\n@@ -84,1 +87,1 @@\n-            connect(client, ssock, testMode, false);\n+            firstSession = connect(client, ssock, testMode, null);\n@@ -92,1 +95,1 @@\n-            secondSession = connect(client, ssock, testMode, true);\n+            secondSession = connect(client, ssock, testMode, firstSession);\n@@ -103,21 +106,22 @@\n-        case BASIC:\n-            \/\/ fail if session is not resumed\n-            if (secondSession.getCreationTime() > secondStartTime) {\n-                throw new RuntimeException(\"Session was not reused\");\n-            }\n-            break;\n-        case CLIENT_AUTH:\n-            \/\/ throws an exception if the client is not authenticated\n-            secondSession.getPeerCertificates();\n-            break;\n-        case VERSION_2_TO_3:\n-        case VERSION_3_TO_2:\n-        case CIPHER_SUITE:\n-        case SIGNATURE_SCHEME:\n-            \/\/ fail if a new session is not created\n-            if (secondSession.getCreationTime() <= secondStartTime) {\n-                throw new RuntimeException(\"Existing session was used\");\n-            }\n-            break;\n-        default:\n-            throw new RuntimeException(\"unknown mode: \" + testMode);\n+            case BASIC:\n+                \/\/ fail if session is not resumed\n+                if (secondSession.getCreationTime() > secondStartTime) {\n+                    throw new RuntimeException(\"Session was not reused\");\n+                }\n+                break;\n+            case CLIENT_AUTH:\n+                \/\/ throws an exception if the client is not authenticated\n+                secondSession.getPeerCertificates();\n+                break;\n+            case VERSION_2_TO_3:\n+            case VERSION_3_TO_2:\n+            case CIPHER_SUITE:\n+            case SIGNATURE_SCHEME:\n+            case LOCAL_CERTS:\n+                \/\/ fail if a new session is not created\n+                if (secondSession.getCreationTime() <= secondStartTime) {\n+                    throw new RuntimeException(\"Existing session was used\");\n+                }\n+                break;\n+            default:\n+                throw new RuntimeException(\"unknown mode: \" + testMode);\n@@ -156,1 +160,3 @@\n-        TestMode mode, boolean second) throws Exception {\n+            TestMode mode, SSLSession firstSession) throws Exception {\n+\n+        boolean second = firstSession != null;\n@@ -165,5 +171,34 @@\n-            case BASIC:\n-                \/\/ do nothing to ensure resumption works\n-                break;\n-            case CLIENT_AUTH:\n-                if (second) {\n+                case BASIC:\n+                    \/\/ do nothing to ensure resumption works\n+                    break;\n+                case CLIENT_AUTH:\n+                    if (second) {\n+                        params.setNeedClientAuth(true);\n+                    } else {\n+                        params.setNeedClientAuth(false);\n+                    }\n+                    break;\n+                case VERSION_2_TO_3:\n+                    if (second) {\n+                        params.setProtocols(new String[]{\"TLSv1.3\"});\n+                    } else {\n+                        params.setProtocols(new String[]{\"TLSv1.2\"});\n+                    }\n+                    break;\n+                case VERSION_3_TO_2:\n+                    if (second) {\n+                        params.setProtocols(new String[]{\"TLSv1.2\"});\n+                    } else {\n+                        params.setProtocols(new String[]{\"TLSv1.3\"});\n+                    }\n+                    break;\n+                case CIPHER_SUITE:\n+                    if (second) {\n+                        params.setCipherSuites(\n+                                new String[]{\"TLS_AES_128_GCM_SHA256\"});\n+                    } else {\n+                        params.setCipherSuites(\n+                                new String[]{\"TLS_AES_256_GCM_SHA384\"});\n+                    }\n+                    break;\n+                case SIGNATURE_SCHEME:\n@@ -171,39 +206,23 @@\n-                } else {\n-                    params.setNeedClientAuth(false);\n-                }\n-                break;\n-            case VERSION_2_TO_3:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                }\n-                break;\n-            case VERSION_3_TO_2:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                }\n-                break;\n-            case CIPHER_SUITE:\n-                if (second) {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_128_GCM_SHA256\"});\n-                } else {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_256_GCM_SHA384\"});\n-                }\n-                break;\n-            case SIGNATURE_SCHEME:\n-                params.setNeedClientAuth(true);\n-                AlgorithmConstraints constraints =\n-                    params.getAlgorithmConstraints();\n-                if (second) {\n-                    params.setAlgorithmConstraints(new NoSig(\"ecdsa\"));\n-                } else {\n-                    params.setAlgorithmConstraints(new NoSig(\"rsa\"));\n-                }\n-                break;\n-            default:\n-                throw new RuntimeException(\"unknown mode: \" + mode);\n+                    AlgorithmConstraints constraints =\n+                            params.getAlgorithmConstraints();\n+                    if (second) {\n+                        params.setAlgorithmConstraints(\n+                                new NoSig(\"ecdsa_secp384r1_sha384\"));\n+                    } else {\n+                        params.setAlgorithmConstraints(\n+                                new NoSig(\"ecdsa_secp521r1_sha512\"));\n+                    }\n+                    break;\n+                case LOCAL_CERTS:\n+                    if (second) {\n+                        \/\/ Add first session's certificate signature\n+                        \/\/ algorithm to constraints so local certificates\n+                        \/\/ can't be restored from the session ticket.\n+                        params.setAlgorithmConstraints(\n+                                new NoSig(X509CertImpl.toImpl((X509CertImpl)\n+                                                firstSession.getLocalCertificates()[0])\n+                                        .getSigAlgName()));\n+                    }\n+                    break;\n+                default:\n+                    throw new RuntimeException(\"unknown mode: \" + mode);\n@@ -225,1 +244,1 @@\n-            if (!second) {\n+            if (firstSession == null) {\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksServer.java","additions":90,"deletions":71,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8211018\n+ * @bug 8211018 8357033\n@@ -29,0 +29,1 @@\n+ * @modules java.base\/sun.security.x509\n@@ -36,0 +37,1 @@\n+ * @run main\/othervm -Djdk.tls.client.protocols=TLSv1.3 ResumeChecksServer LOCAL_CERTS\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksServerStateless.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}