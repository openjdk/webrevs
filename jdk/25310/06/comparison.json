{"files":[{"patch":"@@ -446,6 +446,0 @@\n-        \/\/ Make sure that the server handshake context's\n-        \/\/ localSupportedCertSignAlgs field is populated.  This is particularly\n-        \/\/ important when client authentication was used in an initial session,\n-        \/\/ and it is now being resumed.\n-        SignatureScheme.updateHandshakeLocalSupportedAlgs(shc);\n-\n@@ -467,1 +461,3 @@\n-            \/\/ Make sure the list of supported signature algorithms matches\n+            \/\/ Make sure the list of supported signature algorithms matches.\n+            \/\/ HandshakeContext's localSupportedCertSignAlgs has been already\n+            \/\/ updated when we set the negotiated protocol.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.zip.Adler32;\n@@ -32,1 +35,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -50,1 +52,0 @@\n-import javax.net.ssl.SSLException;\n@@ -55,0 +56,1 @@\n+import sun.security.ssl.X509Authentication.X509Possession;\n@@ -259,0 +261,2 @@\n+     * Re-assemble new session ticket.\n+     * <p>\n@@ -263,12 +267,8 @@\n-     * < 1 bytes > peerSupportedSignAlgs entries\n-     *   < 2 bytes per entries > peerSupportedSignAlgs\n-     * < 2 bytes > preSharedKey length\n-     * < length in bytes > preSharedKey\n-     * < 1 byte > pskIdentity length\n-     * < length in bytes > pskIdentity\n-     * < 1 byte > masterSecret length\n-     *   < 1 byte > masterSecret algorithm length\n-     *   < length in bytes > masterSecret algorithm\n-     *   < 2 bytes > masterSecretKey length\n-     *   < length in bytes> masterSecretKey\n-     * < 1 byte > useExtendedMasterSecret\n+     * select (protocolVersion)\n+     *   case TLS13Plus:\n+     *     < 2 bytes > preSharedKey length\n+     *     < length in bytes > preSharedKey\n+     *   case non-TLS13Plus:\n+     *     < 2 bytes > masterSecretKey length\n+     *     < length in bytes> masterSecretKey\n+     *     < 1 byte > useExtendedMasterSecret\n@@ -276,1 +276,1 @@\n-     * < length in bytes > identificationProtocol\n+     *   < length in bytes > identificationProtocol\n@@ -278,1 +278,1 @@\n-     * < length in bytes > serverNameIndication\n+     *   < length in bytes > serverNameIndication\n@@ -285,3 +285,0 @@\n-     * < 2 byte > status response length\n-     *   < 2 byte > status response entry length\n-     *   < length in byte > status response entry\n@@ -291,18 +288,7 @@\n-     * < 1 byte > Number of peerCerts entries\n-     *   < 4 byte > peerCert length\n-     *   < length in bytes > peerCert\n-     * < 1 byte > localCerts type (Cert, PSK, Anonymous)\n-     *   Certificate\n-     *     < 1 byte > Number of Certificate entries\n-     *       < 4 byte> Certificate length\n-     *       < length in bytes> Certificate\n-     *   PSK\n-     *     < 1 byte > Number of PSK entries\n-     *       < 1 bytes > PSK algorithm length\n-     *       < length in bytes > PSK algorithm string\n-     *       < 4 bytes > PSK key length\n-     *       < length in bytes> PSK key\n-     *       < 4 bytes > PSK identity length\n-     *       < length in bytes> PSK identity\n-     *   Anonymous\n-     *     < 1 byte >\n+     * < 1 byte > Number of Peer Certificate entries\n+     *   < 4 bytes > Peer certificate length\n+     *   < length in bytes> Peer certificate\n+     * < 1 byte > Number of Local Certificate entries\n+     *   < 1 byte > Local Certificate algorithm length\n+     *   < length in bytes> Local Certificate algorithm\n+     *   < 4 bytes > Certificate checksum\n@@ -312,0 +298,2 @@\n+        int len;\n+        byte[] b;\n@@ -324,3 +312,3 @@\n-        ArrayList<SignatureScheme> list = new ArrayList<>();\n-        int i = Record.getInt8(buf);\n-        while (i-- > 0) {\n+        List<SignatureScheme> list = new ArrayList<>();\n+        len = Record.getInt8(buf);\n+        while (len-- > 0) {\n@@ -332,12 +320,2 @@\n-        \/\/ Peer Supported signature algorithms\n-        i = Record.getInt8(buf);\n-        list.clear();\n-        while (i-- > 0) {\n-            list.add(SignatureScheme.valueOf(\n-                    Record.getInt16(buf)));\n-        }\n-        this.peerSupportedSignAlgs = Collections.unmodifiableCollection(list);\n-\n-        \/\/ PSK\n-        byte[] b = Record.getBytes16(buf);\n-        if (b.length > 0) {\n+        if (protocolVersion.useTLS13PlusSpec()) {\n+            \/\/ Pre-shared key algorithm\n@@ -345,4 +323,5 @@\n-            this.preSharedKey = new SecretKeySpec(b, \"TlsMasterSecret\");\n-        } else {\n-            this.preSharedKey = null;\n-        }\n+            if (b.length > 0) {\n+                this.preSharedKey = new SecretKeySpec(b, \"TlsMasterSecret\");\n+            } else {\n+                this.preSharedKey = null;\n+            }\n@@ -350,4 +329,1 @@\n-        \/\/ PSK identity\n-        b = Record.getBytes8(buf);\n-        if (b.length > 0) {\n-            this.pskIdentity = b;\n+            this.useExtendedMasterSecret = false;\n@@ -355,6 +331,1 @@\n-            this.pskIdentity = null;\n-        }\n-\n-        \/\/ Master secret length of secret key algorithm  (one byte)\n-        b = Record.getBytes8(buf);\n-        if (b.length > 0) {\n+            \/\/ Master secret key algorithm\n@@ -362,4 +333,5 @@\n-            this.masterSecret = new SecretKeySpec(b, \"TlsMasterSecret\");\n-        } else {\n-            this.masterSecret = null;\n-        }\n+            if (b.length > 0) {\n+                this.masterSecret = new SecretKeySpec(b, \"TlsMasterSecret\");\n+            } else {\n+                this.masterSecret = null;\n+            }\n@@ -367,2 +339,3 @@\n-        \/\/ Use extended master secret\n-        this.useExtendedMasterSecret = (Record.getInt8(buf) != 0);\n+            \/\/ Extended master secret usage.\n+            this.useExtendedMasterSecret = (Record.getInt8(buf) != 0);\n+        }\n@@ -387,1 +360,1 @@\n-        int len = Record.getInt16(buf);\n+        len = Record.getInt16(buf);\n@@ -404,14 +377,0 @@\n-        \/\/ Get Buffer sizes\n-\n-        \/\/ Status Response\n-        len = Record.getInt16(buf);\n-        if (len == 0) {\n-            statusResponses = Collections.emptyList();\n-        } else {\n-            statusResponses = new ArrayList<>();\n-        }\n-        while (len-- > 0) {\n-            b = Record.getBytes16(buf);\n-            statusResponses.add(b);\n-        }\n-\n@@ -427,3 +386,3 @@\n-        \/\/ Peer certs\n-        i = Record.getInt8(buf);\n-        if (i == 0) {\n+        \/\/ Peer certs.\n+        len = Record.getInt8(buf);\n+        if (len == 0) {\n@@ -432,3 +391,2 @@\n-            this.peerCerts = new X509Certificate[i];\n-            int j = 0;\n-            while (i > j) {\n+            this.peerCerts = new X509Certificate[len];\n+            for (int i = 0; len > i; i++) {\n@@ -438,1 +396,1 @@\n-                    this.peerCerts[j] = X509Factory.cachedGetX509Cert(b);\n+                    this.peerCerts[i] = X509Factory.cachedGetX509Cert(b);\n@@ -442,1 +400,0 @@\n-                j++;\n@@ -446,12 +403,22 @@\n-        \/\/ Get local certs of PSK\n-        switch (Record.getInt8(buf)) {\n-            case 0:\n-                break;\n-            case 1:\n-                \/\/ number of certs\n-                len = buf.get();\n-                this.localCerts = new X509Certificate[len];\n-                i = 0;\n-                while (len > i) {\n-                    b = new byte[buf.getInt()];\n-                    buf.get(b);\n+        \/\/ Restore local certificates if cert algorithm(s) present.\n+        len = Record.getInt8(buf);\n+        if (len == 0) {\n+            this.localCerts = null;\n+        } else {\n+            String[] certAlgs = new String[len];\n+            Set<Integer> certCheckSums = new HashSet<>(len);\n+\n+            for (int i = 0; len > i; i++) {\n+                certAlgs[i] = new String(Record.getBytes8(buf));\n+                certCheckSums.add(Record.getInt32(buf));\n+            }\n+\n+            SSLPossession pos = X509Authentication.createPossession(\n+                    hc, certAlgs);\n+            List<X509Certificate> tmpCerts = new ArrayList<>(len);\n+\n+            if (pos instanceof X509Possession x509Pos\n+                    && x509Pos.popCerts != null\n+                    && x509Pos.popCerts.length == len) {\n+\n+                for (int i = 0; i < x509Pos.popCerts.length; i++) {\n@@ -459,1 +426,6 @@\n-                        this.localCerts[i] = X509Factory.cachedGetX509Cert(b);\n+                        byte[] encoded = x509Pos.popCerts[i].getEncoded();\n+                        if (certCheckSums.contains(getChecksum(encoded))) {\n+                            \/\/ Use certs from cache.\n+                            tmpCerts.add(\n+                                    X509Factory.cachedGetX509Cert(encoded));\n+                        }\n@@ -463,1 +435,0 @@\n-                    i++;\n@@ -465,15 +436,16 @@\n-                break;\n-            case 2:\n-                \/\/ pre-shared key\n-                \/\/ Length of pre-shared key algorithm  (one byte)\n-                b = Record.getBytes8(buf);\n-                String alg = new String(b);\n-                \/\/ Get encoding\n-                b = Record.getBytes16(buf);\n-                this.preSharedKey = new SecretKeySpec(b, alg);\n-                \/\/ Get identity len\n-                i = Record.getInt8(buf);\n-                if (i > 0) {\n-                    this.pskIdentity = Record.getBytes8(buf);\n-                } else {\n-                    this.pskIdentity = null;\n+            }\n+\n+            if (tmpCerts.size() == len) {\n+                this.localCerts = tmpCerts.toArray(new X509Certificate[len]);\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,session\")) {\n+                    SSLLogger.fine(\"Restored \" + len\n+                            + \" local certificates from session ticket\"\n+                            + \" for algorithms \" + Arrays.toString(certAlgs));\n+                }\n+            } else {\n+                this.localCerts = null;\n+                this.invalidated = true;\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,session\")) {\n+                    SSLLogger.warning(\"Local certificates can not be restored \"\n+                            + \"from session ticket \"\n+                            + \"for algorithms \" + Arrays.toString(certAlgs));\n@@ -481,3 +453,1 @@\n-                break;\n-            default:\n-                throw new SSLException(\"Failed local certs of session.\");\n+            }\n@@ -486,1 +456,1 @@\n-        context = (SSLSessionContextImpl)\n+        this.context = (SSLSessionContextImpl)\n@@ -491,1 +461,0 @@\n-\n@@ -532,14 +501,6 @@\n-        \/\/ Peer Supported signature algorithms\n-        hos.putInt8(peerSupportedSignAlgs.size());\n-        for (SignatureScheme s : peerSupportedSignAlgs) {\n-            hos.putInt16(s.id);\n-        }\n-\n-        \/\/ PSK\n-        if (preSharedKey == null ||\n-                preSharedKey.getAlgorithm() == null) {\n-            hos.putInt16(0);\n-        } else {\n-            hos.putInt16(preSharedKey.getAlgorithm().length());\n-            if (preSharedKey.getAlgorithm().length() != 0) {\n-                hos.write(preSharedKey.getAlgorithm().getBytes());\n+        if (protocolVersion.useTLS13PlusSpec()) {\n+            \/\/ PSK\n+            if (preSharedKey == null) {\n+                hos.putInt16(0);\n+            } else {\n+                hos.putBytes16(preSharedKey.getEncoded());\n@@ -547,8 +508,0 @@\n-            b = preSharedKey.getEncoded();\n-            hos.putInt16(b.length);\n-            hos.write(b, 0, b.length);\n-        }\n-\n-        \/\/ PSK Identity\n-        if (pskIdentity == null) {\n-            hos.putInt8(0);\n@@ -556,12 +509,5 @@\n-            hos.putInt8(pskIdentity.length);\n-            hos.write(pskIdentity, 0, pskIdentity.length);\n-        }\n-\n-        \/\/ Master Secret\n-        if (getMasterSecret() == null ||\n-                getMasterSecret().getAlgorithm() == null) {\n-            hos.putInt8(0);\n-        } else {\n-            hos.putInt8(getMasterSecret().getAlgorithm().length());\n-            if (getMasterSecret().getAlgorithm().length() != 0) {\n-                hos.write(getMasterSecret().getAlgorithm().getBytes());\n+            \/\/ Master Secret\n+            if (getMasterSecret() == null) {\n+                hos.putInt16(0);\n+            } else {\n+                hos.putBytes16(masterSecret.getEncoded());\n@@ -569,4 +515,0 @@\n-            b = getMasterSecret().getEncoded();\n-            hos.putInt16(b.length);\n-            hos.write(b, 0, b.length);\n-        }\n@@ -574,1 +516,2 @@\n-        hos.putInt8(useExtendedMasterSecret ? 1 : 0);\n+            hos.putInt8(useExtendedMasterSecret ? 1 : 0);\n+        }\n@@ -612,9 +555,0 @@\n-        \/\/ Status Responses\n-        List<byte[]> list = getStatusResponses();\n-        int l = list.size();\n-        hos.putInt16(l);\n-        for (byte[] e : list) {\n-            hos.putInt16(e.length);\n-            hos.write(e);\n-        }\n-\n@@ -630,1 +564,1 @@\n-        \/\/ Peer cert\n+        \/\/ Peer certs.\n@@ -642,4 +576,6 @@\n-        \/\/ Client identity\n-        if (localCerts != null && localCerts.length > 0) {\n-            \/\/ certificate based\n-            hos.putInt8(1);\n+        \/\/ Local certificates' algorithms and checksums.\n+        \/\/ We don't include the complete local certificates in a session ticket\n+        \/\/ to decrease the size of ClientHello message.\n+        if (localCerts == null || localCerts.length == 0) {\n+            hos.putInt8(0);\n+        } else {\n@@ -648,3 +584,2 @@\n-                b = c.getEncoded();\n-                hos.putInt32(b.length);\n-                hos.writeBytes(b);\n+                hos.putBytes8(c.getPublicKey().getAlgorithm().getBytes());\n+                hos.putInt32(getChecksum(c.getEncoded()));\n@@ -652,13 +587,0 @@\n-        } else if (preSharedKey != null) {\n-            \/\/ pre-shared key\n-            hos.putInt8(2);\n-            hos.putInt8(preSharedKey.getAlgorithm().length());\n-            hos.write(preSharedKey.getAlgorithm().getBytes());\n-            b = preSharedKey.getEncoded();\n-            hos.putInt32(b.length);\n-            hos.writeBytes(b);\n-            hos.putInt32(pskIdentity.length);\n-            hos.writeBytes(pskIdentity);\n-        } else {\n-            \/\/ anonymous\n-            hos.putInt8(0);\n@@ -670,0 +592,6 @@\n+    private static int getChecksum(byte[] input) {\n+        Adler32 adler32 = new Adler32();\n+        adler32.update(input);\n+        return (int) adler32.getValue();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":126,"deletions":198,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n@@ -34,0 +36,2 @@\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.GZIPOutputStream;\n@@ -73,0 +77,3 @@\n+    \/\/ No need to compress a ticket if it can fit in a single packet.\n+    \/\/ Besides, small buffers often end up to be larger when compressed.\n+    static final int MIN_COMPRESS_SIZE = 600;\n@@ -199,1 +206,1 @@\n-        public byte[] encrypt(HandshakeContext hc, SSLSessionImpl session) {\n+        byte[] encrypt(HandshakeContext hc, SSLSessionImpl session) {\n@@ -216,6 +223,1 @@\n-                c.updateAAD(new byte[] {\n-                        (byte)(key.num >>> 24),\n-                        (byte)(key.num >>> 16),\n-                        (byte)(key.num >>> 8),\n-                        (byte)(key.num)}\n-                );\n+\n@@ -226,0 +228,12 @@\n+\n+                \/\/ Compress the session before encryption if needed.\n+                byte compressed = 0;\n+                if (data.length >= MIN_COMPRESS_SIZE) {\n+                    data = compress(data);\n+                    compressed = 1;\n+                }\n+\n+                ByteBuffer aad = ByteBuffer.allocate(Integer.BYTES + 1);\n+                aad.putInt(key.num).put(compressed);\n+                c.updateAAD(aad);\n+\n@@ -228,1 +242,1 @@\n-                        iv.length];\n+                        iv.length + 1];\n@@ -234,0 +248,1 @@\n+                result[Integer.BYTES + iv.length] = compressed;\n@@ -235,1 +250,1 @@\n-                        Integer.BYTES + iv.length, encrypted.length);\n+                        Integer.BYTES + iv.length + 1, encrypted.length);\n@@ -260,9 +275,8 @@\n-                c.updateAAD(new byte[] {\n-                        (byte)(keyID >>> 24),\n-                        (byte)(keyID >>> 16),\n-                        (byte)(keyID >>> 8),\n-                        (byte)(keyID)}\n-                );\n-\n-                ByteBuffer out;\n-                out = ByteBuffer.allocate(data.remaining() - GCM_TAG_LEN \/ 8);\n+\n+                byte compressed = data.get();\n+                ByteBuffer aad = ByteBuffer.allocate(Integer.BYTES + 1);\n+                aad.putInt(keyID).put(compressed);\n+                c.updateAAD(aad);\n+\n+                ByteBuffer out = ByteBuffer.allocate(\n+                        data.remaining() - GCM_TAG_LEN \/ 8);\n@@ -271,0 +285,6 @@\n+\n+                \/\/ Decompress the session after decryption if needed.\n+                if (compressed == 1) {\n+                    out = decompress(out);\n+                }\n+\n@@ -277,0 +297,1 @@\n+\n@@ -280,0 +301,35 @@\n+        private static byte[] compress(byte[] input) throws IOException {\n+            try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+                    GZIPOutputStream gos = new GZIPOutputStream(baos)) {\n+                final int decompressedLen = input.length;\n+                gos.write(input, 0, decompressedLen);\n+                gos.finish();\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"decompressed bytes: \" + decompressedLen\n+                            + \"; compressed bytes: \" + baos.size());\n+                }\n+\n+                return baos.toByteArray();\n+            }\n+        }\n+\n+        private static ByteBuffer decompress(ByteBuffer input)\n+                throws IOException {\n+            final int compressedLen = input.remaining();\n+            byte[] bytes = new byte[compressedLen];\n+            input.get(bytes);\n+\n+            try (GZIPInputStream gis = new GZIPInputStream(\n+                    new ByteArrayInputStream(bytes))) {\n+                byte[] out = gis.readAllBytes();\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"compressed bytes: \" + compressedLen\n+                            + \"; decompressed bytes: \" + out.length);\n+                }\n+\n+                return ByteBuffer.wrap(out);\n+            }\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":74,"deletions":18,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import sun.security.x509.X509CertImpl;\n@@ -60,1 +61,2 @@\n-        SIGNATURE_SCHEME\n+        SIGNATURE_SCHEME,\n+        LOCAL_CERTS\n@@ -74,0 +76,1 @@\n+        SSLSession firstSession;\n@@ -84,1 +87,1 @@\n-            connect(client, ssock, testMode, false);\n+            firstSession = connect(client, ssock, testMode, null);\n@@ -92,1 +95,1 @@\n-            secondSession = connect(client, ssock, testMode, true);\n+            secondSession = connect(client, ssock, testMode, firstSession);\n@@ -103,21 +106,22 @@\n-        case BASIC:\n-            \/\/ fail if session is not resumed\n-            if (secondSession.getCreationTime() > secondStartTime) {\n-                throw new RuntimeException(\"Session was not reused\");\n-            }\n-            break;\n-        case CLIENT_AUTH:\n-            \/\/ throws an exception if the client is not authenticated\n-            secondSession.getPeerCertificates();\n-            break;\n-        case VERSION_2_TO_3:\n-        case VERSION_3_TO_2:\n-        case CIPHER_SUITE:\n-        case SIGNATURE_SCHEME:\n-            \/\/ fail if a new session is not created\n-            if (secondSession.getCreationTime() <= secondStartTime) {\n-                throw new RuntimeException(\"Existing session was used\");\n-            }\n-            break;\n-        default:\n-            throw new RuntimeException(\"unknown mode: \" + testMode);\n+            case BASIC:\n+                \/\/ fail if session is not resumed\n+                if (secondSession.getCreationTime() > secondStartTime) {\n+                    throw new RuntimeException(\"Session was not reused\");\n+                }\n+                break;\n+            case CLIENT_AUTH:\n+                \/\/ throws an exception if the client is not authenticated\n+                secondSession.getPeerCertificates();\n+                break;\n+            case VERSION_2_TO_3:\n+            case VERSION_3_TO_2:\n+            case CIPHER_SUITE:\n+            case SIGNATURE_SCHEME:\n+            case LOCAL_CERTS:\n+                \/\/ fail if a new session is not created\n+                if (secondSession.getCreationTime() <= secondStartTime) {\n+                    throw new RuntimeException(\"Existing session was used\");\n+                }\n+                break;\n+            default:\n+                throw new RuntimeException(\"unknown mode: \" + testMode);\n@@ -156,1 +160,3 @@\n-        TestMode mode, boolean second) throws Exception {\n+            TestMode mode, SSLSession firstSession) throws Exception {\n+\n+        boolean second = firstSession != null;\n@@ -165,5 +171,34 @@\n-            case BASIC:\n-                \/\/ do nothing to ensure resumption works\n-                break;\n-            case CLIENT_AUTH:\n-                if (second) {\n+                case BASIC:\n+                    \/\/ do nothing to ensure resumption works\n+                    break;\n+                case CLIENT_AUTH:\n+                    if (second) {\n+                        params.setNeedClientAuth(true);\n+                    } else {\n+                        params.setNeedClientAuth(false);\n+                    }\n+                    break;\n+                case VERSION_2_TO_3:\n+                    if (second) {\n+                        params.setProtocols(new String[]{\"TLSv1.3\"});\n+                    } else {\n+                        params.setProtocols(new String[]{\"TLSv1.2\"});\n+                    }\n+                    break;\n+                case VERSION_3_TO_2:\n+                    if (second) {\n+                        params.setProtocols(new String[]{\"TLSv1.2\"});\n+                    } else {\n+                        params.setProtocols(new String[]{\"TLSv1.3\"});\n+                    }\n+                    break;\n+                case CIPHER_SUITE:\n+                    if (second) {\n+                        params.setCipherSuites(\n+                                new String[]{\"TLS_AES_128_GCM_SHA256\"});\n+                    } else {\n+                        params.setCipherSuites(\n+                                new String[]{\"TLS_AES_256_GCM_SHA384\"});\n+                    }\n+                    break;\n+                case SIGNATURE_SCHEME:\n@@ -171,39 +206,23 @@\n-                } else {\n-                    params.setNeedClientAuth(false);\n-                }\n-                break;\n-            case VERSION_2_TO_3:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                }\n-                break;\n-            case VERSION_3_TO_2:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                }\n-                break;\n-            case CIPHER_SUITE:\n-                if (second) {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_128_GCM_SHA256\"});\n-                } else {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_256_GCM_SHA384\"});\n-                }\n-                break;\n-            case SIGNATURE_SCHEME:\n-                params.setNeedClientAuth(true);\n-                AlgorithmConstraints constraints =\n-                    params.getAlgorithmConstraints();\n-                if (second) {\n-                    params.setAlgorithmConstraints(new NoSig(\"ecdsa\"));\n-                } else {\n-                    params.setAlgorithmConstraints(new NoSig(\"rsa\"));\n-                }\n-                break;\n-            default:\n-                throw new RuntimeException(\"unknown mode: \" + mode);\n+                    AlgorithmConstraints constraints =\n+                            params.getAlgorithmConstraints();\n+                    if (second) {\n+                        params.setAlgorithmConstraints(\n+                                new NoSig(\"ecdsa_secp384r1_sha384\"));\n+                    } else {\n+                        params.setAlgorithmConstraints(\n+                                new NoSig(\"ecdsa_secp521r1_sha512\"));\n+                    }\n+                    break;\n+                case LOCAL_CERTS:\n+                    if (second) {\n+                        \/\/ Add first session's certificate signature\n+                        \/\/ algorithm to constraints so local certificates\n+                        \/\/ can't be restored from the session ticket.\n+                        params.setAlgorithmConstraints(\n+                                new NoSig(X509CertImpl.toImpl((X509CertImpl)\n+                                                firstSession.getLocalCertificates()[0])\n+                                        .getSigAlgName()));\n+                    }\n+                    break;\n+                default:\n+                    throw new RuntimeException(\"unknown mode: \" + mode);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksServer.java","additions":89,"deletions":70,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8211018\n+ * @bug 8211018 8357033\n@@ -29,0 +29,1 @@\n+ * @modules java.base\/sun.security.x509\n@@ -36,0 +37,1 @@\n+ * @run main\/othervm -Djdk.tls.client.protocols=TLSv1.3 ResumeChecksServer LOCAL_CERTS\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksServerStateless.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}