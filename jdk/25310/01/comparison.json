{"files":[{"patch":"@@ -446,6 +446,0 @@\n-        \/\/ Make sure that the server handshake context's\n-        \/\/ localSupportedCertSignAlgs field is populated.  This is particularly\n-        \/\/ important when client authentication was used in an initial session,\n-        \/\/ and it is now being resumed.\n-        SignatureScheme.updateHandshakeLocalSupportedAlgs(shc);\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -50,1 +49,0 @@\n-import javax.net.ssl.SSLException;\n@@ -55,0 +53,1 @@\n+import sun.security.ssl.X509Authentication.X509Possession;\n@@ -259,0 +258,2 @@\n+     * Re-assemble new session ticket.\n+     * <p>\n@@ -263,12 +264,12 @@\n-     * < 1 bytes > peerSupportedSignAlgs entries\n-     *   < 2 bytes per entries > peerSupportedSignAlgs\n-     * < 2 bytes > preSharedKey length\n-     * < length in bytes > preSharedKey\n-     * < 1 byte > pskIdentity length\n-     * < length in bytes > pskIdentity\n-     * < 1 byte > masterSecret length\n-     *   < 1 byte > masterSecret algorithm length\n-     *   < length in bytes > masterSecret algorithm\n-     *   < 2 bytes > masterSecretKey length\n-     *   < length in bytes> masterSecretKey\n-     * < 1 byte > useExtendedMasterSecret\n+     * select (protocolVersion)\n+     *   case TLS13Plus:\n+     *     < 1 byte > preSharedKey algorithm length\n+     *     < length in bytes > preSharedKey algorithm\n+     *     < 2 bytes > preSharedKey length\n+     *     < length in bytes > preSharedKey\n+     *   case non-TLS13Plus:\n+     *     < 1 byte > masterSecret algorithm length\n+     *     < length in bytes > masterSecret algorithm\n+     *     < 2 bytes > masterSecretKey length\n+     *     < length in bytes> masterSecretKey\n+     *     < 1 byte > useExtendedMasterSecret\n@@ -276,1 +277,1 @@\n-     * < length in bytes > identificationProtocol\n+     *   < length in bytes > identificationProtocol\n@@ -278,1 +279,1 @@\n-     * < length in bytes > serverNameIndication\n+     *   < length in bytes > serverNameIndication\n@@ -285,3 +286,0 @@\n-     * < 2 byte > status response length\n-     *   < 2 byte > status response entry length\n-     *   < length in byte > status response entry\n@@ -291,18 +289,6 @@\n-     * < 1 byte > Number of peerCerts entries\n-     *   < 4 byte > peerCert length\n-     *   < length in bytes > peerCert\n-     * < 1 byte > localCerts type (Cert, PSK, Anonymous)\n-     *   Certificate\n-     *     < 1 byte > Number of Certificate entries\n-     *       < 4 byte> Certificate length\n-     *       < length in bytes> Certificate\n-     *   PSK\n-     *     < 1 byte > Number of PSK entries\n-     *       < 1 bytes > PSK algorithm length\n-     *       < length in bytes > PSK algorithm string\n-     *       < 4 bytes > PSK key length\n-     *       < length in bytes> PSK key\n-     *       < 4 bytes > PSK identity length\n-     *       < length in bytes> PSK identity\n-     *   Anonymous\n-     *     < 1 byte >\n+     * < 1 byte > Number of Peer Certificate entries\n+     *   < 4 bytes > Peer certificate length\n+     *   < length in bytes> Peer certificate\n+     * < 1 byte > Number of Local Certificate algorithms\n+     *   < 1 byte > Local Certificate algorithm length\n+     *   < length in bytes> Local Certificate algorithm\n@@ -312,0 +298,2 @@\n+        int len;\n+        byte[] b;\n@@ -324,3 +312,3 @@\n-        ArrayList<SignatureScheme> list = new ArrayList<>();\n-        int i = Record.getInt8(buf);\n-        while (i-- > 0) {\n+        List<SignatureScheme> list = new ArrayList<>();\n+        len = Record.getInt8(buf);\n+        while (len-- > 0) {\n@@ -332,17 +320,11 @@\n-        \/\/ Peer Supported signature algorithms\n-        i = Record.getInt8(buf);\n-        list.clear();\n-        while (i-- > 0) {\n-            list.add(SignatureScheme.valueOf(\n-                    Record.getInt16(buf)));\n-        }\n-        this.peerSupportedSignAlgs = Collections.unmodifiableCollection(list);\n-\n-        \/\/ PSK\n-        byte[] b = Record.getBytes16(buf);\n-        if (b.length > 0) {\n-            b = Record.getBytes16(buf);\n-            this.preSharedKey = new SecretKeySpec(b, \"TlsMasterSecret\");\n-        } else {\n-            this.preSharedKey = null;\n-        }\n+        if (protocolVersion.useTLS13PlusSpec()) {\n+            \/\/ Pre-shared key algorithm\n+            b = Record.getBytes8(buf);\n+            if (b.length > 0) {\n+                String alg = new String(b);\n+                \/\/ Pre-shared key\n+                b = Record.getBytes16(buf);\n+                this.preSharedKey = new SecretKeySpec(b, alg);\n+            } else {\n+                this.preSharedKey = null;\n+            }\n@@ -350,4 +332,1 @@\n-        \/\/ PSK identity\n-        b = Record.getBytes8(buf);\n-        if (b.length > 0) {\n-            this.pskIdentity = b;\n+            this.useExtendedMasterSecret = false;\n@@ -355,2 +334,10 @@\n-            this.pskIdentity = null;\n-        }\n+            \/\/ Master secret key algorithm\n+            b = Record.getBytes8(buf);\n+            if (b.length > 0) {\n+                String alg = new String(b);\n+                \/\/ Master secret key\n+                b = Record.getBytes16(buf);\n+                this.masterSecret = new SecretKeySpec(b, alg);\n+            } else {\n+                this.masterSecret = null;\n+            }\n@@ -358,7 +345,2 @@\n-        \/\/ Master secret length of secret key algorithm  (one byte)\n-        b = Record.getBytes8(buf);\n-        if (b.length > 0) {\n-            b = Record.getBytes16(buf);\n-            this.masterSecret = new SecretKeySpec(b, \"TlsMasterSecret\");\n-        } else {\n-            this.masterSecret = null;\n+            \/\/ Extended master secret usage.\n+            this.useExtendedMasterSecret = (Record.getInt8(buf) != 0);\n@@ -367,3 +349,0 @@\n-        \/\/ Use extended master secret\n-        this.useExtendedMasterSecret = (Record.getInt8(buf) != 0);\n-\n@@ -387,1 +366,1 @@\n-        int len = Record.getInt16(buf);\n+        len = Record.getInt16(buf);\n@@ -404,14 +383,0 @@\n-        \/\/ Get Buffer sizes\n-\n-        \/\/ Status Response\n-        len = Record.getInt16(buf);\n-        if (len == 0) {\n-            statusResponses = Collections.emptyList();\n-        } else {\n-            statusResponses = new ArrayList<>();\n-        }\n-        while (len-- > 0) {\n-            b = Record.getBytes16(buf);\n-            statusResponses.add(b);\n-        }\n-\n@@ -427,3 +392,3 @@\n-        \/\/ Peer certs\n-        i = Record.getInt8(buf);\n-        if (i == 0) {\n+        \/\/ Peer certs.\n+        len = Record.getInt8(buf);\n+        if (len == 0) {\n@@ -432,3 +397,2 @@\n-            this.peerCerts = new X509Certificate[i];\n-            int j = 0;\n-            while (i > j) {\n+            this.peerCerts = new X509Certificate[len];\n+            for (int i = 0; len > i; i++) {\n@@ -438,1 +402,1 @@\n-                    this.peerCerts[j] = X509Factory.cachedGetX509Cert(b);\n+                    this.peerCerts[i] = X509Factory.cachedGetX509Cert(b);\n@@ -442,1 +406,0 @@\n-                j++;\n@@ -446,34 +409,39 @@\n-        \/\/ Get local certs of PSK\n-        switch (Record.getInt8(buf)) {\n-            case 0:\n-                break;\n-            case 1:\n-                \/\/ number of certs\n-                len = buf.get();\n-                this.localCerts = new X509Certificate[len];\n-                i = 0;\n-                while (len > i) {\n-                    b = new byte[buf.getInt()];\n-                    buf.get(b);\n-                    try {\n-                        this.localCerts[i] = X509Factory.cachedGetX509Cert(b);\n-                    } catch (Exception e) {\n-                        throw new IOException(e);\n-                    }\n-                    i++;\n-                }\n-                break;\n-            case 2:\n-                \/\/ pre-shared key\n-                \/\/ Length of pre-shared key algorithm  (one byte)\n-                b = Record.getBytes8(buf);\n-                String alg = new String(b);\n-                \/\/ Get encoding\n-                b = Record.getBytes16(buf);\n-                this.preSharedKey = new SecretKeySpec(b, alg);\n-                \/\/ Get identity len\n-                i = Record.getInt8(buf);\n-                if (i > 0) {\n-                    this.pskIdentity = Record.getBytes8(buf);\n-                } else {\n-                    this.pskIdentity = null;\n+        \/\/ Load local certificates if cert algorithm(s) present.\n+        len = Record.getInt8(buf);\n+        if (len == 0) {\n+            this.localCerts = null;\n+        } else {\n+            String[] certAlgs = new String[len];\n+\n+            for (int i = 0; len > i; i++) {\n+                certAlgs[i] = new String(Record.getBytes8(buf));\n+            }\n+\n+            SSLPossession pos = X509Authentication.createPossession(\n+                    hc, certAlgs);\n+\n+            if (pos == null) {\n+                throw hc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No available certificates for algorithms: \"\n+                                + Arrays.toString(certAlgs));\n+            }\n+\n+            if (!(pos instanceof X509Possession x509Possession)) {\n+                throw hc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No available X.509 certificates for algorithms: \"\n+                                + Arrays.toString(certAlgs));\n+            }\n+\n+            localCerts = x509Possession.popCerts;\n+            if (localCerts == null || localCerts.length == 0) {\n+                throw hc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No available local X.509 certificate\");\n+            }\n+\n+            \/\/ Use certs from cache.\n+            for (int i = 0; i < localCerts.length; i++) {\n+                try {\n+                    localCerts[i] = X509Factory.cachedGetX509Cert(\n+                            localCerts[i].getEncoded());\n+                } catch (Exception e) {\n+                    throw new IOException(e);\n@@ -481,3 +449,1 @@\n-                break;\n-            default:\n-                throw new SSLException(\"Failed local certs of session.\");\n+            }\n@@ -486,1 +452,1 @@\n-        context = (SSLSessionContextImpl)\n+        this.context = (SSLSessionContextImpl)\n@@ -491,1 +457,0 @@\n-\n@@ -532,14 +497,8 @@\n-        \/\/ Peer Supported signature algorithms\n-        hos.putInt8(peerSupportedSignAlgs.size());\n-        for (SignatureScheme s : peerSupportedSignAlgs) {\n-            hos.putInt16(s.id);\n-        }\n-\n-        \/\/ PSK\n-        if (preSharedKey == null ||\n-                preSharedKey.getAlgorithm() == null) {\n-            hos.putInt16(0);\n-        } else {\n-            hos.putInt16(preSharedKey.getAlgorithm().length());\n-            if (preSharedKey.getAlgorithm().length() != 0) {\n-                hos.write(preSharedKey.getAlgorithm().getBytes());\n+        if (protocolVersion.useTLS13PlusSpec()) {\n+            \/\/ PSK\n+            if (preSharedKey == null ||\n+                    preSharedKey.getAlgorithm() == null) {\n+                hos.putInt8(0);\n+            } else {\n+                hos.putBytes8(preSharedKey.getAlgorithm().getBytes());\n+                hos.putBytes16(preSharedKey.getEncoded());\n@@ -547,17 +506,0 @@\n-            b = preSharedKey.getEncoded();\n-            hos.putInt16(b.length);\n-            hos.write(b, 0, b.length);\n-        }\n-\n-        \/\/ PSK Identity\n-        if (pskIdentity == null) {\n-            hos.putInt8(0);\n-        } else {\n-            hos.putInt8(pskIdentity.length);\n-            hos.write(pskIdentity, 0, pskIdentity.length);\n-        }\n-\n-        \/\/ Master Secret\n-        if (getMasterSecret() == null ||\n-                getMasterSecret().getAlgorithm() == null) {\n-            hos.putInt8(0);\n@@ -565,3 +507,7 @@\n-            hos.putInt8(getMasterSecret().getAlgorithm().length());\n-            if (getMasterSecret().getAlgorithm().length() != 0) {\n-                hos.write(getMasterSecret().getAlgorithm().getBytes());\n+            \/\/ Master Secret\n+            if (getMasterSecret() == null ||\n+                    getMasterSecret().getAlgorithm() == null) {\n+                hos.putInt8(0);\n+            } else {\n+                hos.putBytes8(masterSecret.getAlgorithm().getBytes());\n+                hos.putBytes16(masterSecret.getEncoded());\n@@ -569,4 +515,0 @@\n-            b = getMasterSecret().getEncoded();\n-            hos.putInt16(b.length);\n-            hos.write(b, 0, b.length);\n-        }\n@@ -574,1 +516,2 @@\n-        hos.putInt8(useExtendedMasterSecret ? 1 : 0);\n+            hos.putInt8(useExtendedMasterSecret ? 1 : 0);\n+        }\n@@ -612,9 +555,0 @@\n-        \/\/ Status Responses\n-        List<byte[]> list = getStatusResponses();\n-        int l = list.size();\n-        hos.putInt16(l);\n-        for (byte[] e : list) {\n-            hos.putInt16(e.length);\n-            hos.write(e);\n-        }\n-\n@@ -630,1 +564,1 @@\n-        \/\/ Peer cert\n+        \/\/ Peer certs.\n@@ -642,4 +576,6 @@\n-        \/\/ Client identity\n-        if (localCerts != null && localCerts.length > 0) {\n-            \/\/ certificate based\n-            hos.putInt8(1);\n+        \/\/ Local certificates' algorithms.\n+        \/\/ We don't include the complete local certificates in a session ticket\n+        \/\/ to decrease the size of ClientHello message.\n+        if (localCerts == null || localCerts.length == 0) {\n+            hos.putInt8(0);\n+        } else {\n@@ -648,3 +584,1 @@\n-                b = c.getEncoded();\n-                hos.putInt32(b.length);\n-                hos.writeBytes(b);\n+                hos.putBytes8(c.getPublicKey().getAlgorithm().getBytes());\n@@ -652,13 +586,0 @@\n-        } else if (preSharedKey != null) {\n-            \/\/ pre-shared key\n-            hos.putInt8(2);\n-            hos.putInt8(preSharedKey.getAlgorithm().length());\n-            hos.write(preSharedKey.getAlgorithm().getBytes());\n-            b = preSharedKey.getEncoded();\n-            hos.putInt32(b.length);\n-            hos.writeBytes(b);\n-            hos.putInt32(pskIdentity.length);\n-            hos.writeBytes(pskIdentity);\n-        } else {\n-            \/\/ anonymous\n-            hos.putInt8(0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":125,"deletions":204,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n@@ -33,0 +35,1 @@\n+import java.util.Arrays;\n@@ -34,0 +37,2 @@\n+import java.util.zip.GZIPInputStream;\n+import java.util.zip.GZIPOutputStream;\n@@ -73,0 +78,3 @@\n+    \/\/ No need to compress a ticket if it can fit in a single packet.\n+    \/\/ Besides, small buffers often end up to be larger when compressed.\n+    static final int MIN_COMPRESS_SIZE = 600;\n@@ -199,1 +207,1 @@\n-        public byte[] encrypt(HandshakeContext hc, SSLSessionImpl session) {\n+        byte[] encrypt(HandshakeContext hc, SSLSessionImpl session) {\n@@ -226,0 +234,8 @@\n+\n+                \/\/ Compress the session before encryption if needed.\n+                byte compressed = 0;\n+                if (data.length >= MIN_COMPRESS_SIZE) {\n+                    data = compress(data);\n+                    compressed = 1;\n+                }\n+\n@@ -228,1 +244,1 @@\n-                        iv.length];\n+                        iv.length + 1];\n@@ -234,0 +250,1 @@\n+                result[Integer.BYTES + iv.length] = compressed;\n@@ -235,1 +252,1 @@\n-                        Integer.BYTES + iv.length, encrypted.length);\n+                        Integer.BYTES + iv.length + 1, encrypted.length);\n@@ -245,1 +262,1 @@\n-        ByteBuffer decrypt(HandshakeContext hc) {\n+        ByteBuffer decrypt(HandshakeContext hc) throws IOException {\n@@ -267,0 +284,1 @@\n+                byte compressed = data.get();\n@@ -271,0 +289,6 @@\n+\n+                \/\/ Decompress the session after decryption if needed.\n+                if (compressed == 1) {\n+                    out = decompress(out);\n+                }\n+\n@@ -280,0 +304,51 @@\n+        private static byte[] compress(byte[] input) {\n+            try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+                    GZIPOutputStream gos = new GZIPOutputStream(baos)) {\n+                final int decompressedLen = input.length;\n+                gos.write(input, 0, decompressedLen);\n+                gos.finish();\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"decompressed bytes: \" + decompressedLen\n+                            + \"; compressed bytes: \" + baos.size());\n+                }\n+\n+                return baos.toByteArray();\n+            } catch (Exception e) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Compression failure: \" + e.getMessage());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        private static ByteBuffer decompress(ByteBuffer input) {\n+            final int compressedLen = input.remaining();\n+            byte[] bytes = new byte[compressedLen];\n+            input.get(bytes);\n+\n+            try (GZIPInputStream gis = new GZIPInputStream(\n+                    new ByteArrayInputStream(bytes))) {\n+                final byte[] tmp = new byte[compressedLen * 3];\n+                int count = 0;\n+                int b;\n+                while ((b = gis.read()) >= 0) {\n+                    tmp[count++] = (byte) b;\n+                }\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"compressed bytes: \" + compressedLen\n+                            + \"; decompressed bytes: \" + count);\n+                }\n+\n+                return ByteBuffer.wrap(Arrays.copyOf(tmp, count));\n+            } catch (Exception e) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.fine(\"Decompression failure: \" + e.getMessage());\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":79,"deletions":4,"binary":false,"changes":83,"status":"modified"}]}