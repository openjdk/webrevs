{"files":[{"patch":"@@ -174,0 +174,1 @@\n+  __ align(4, __ offset() + OFFSET_TO_PATCHABLE_DATA); \/\/ must align the following block which requires atomic updates\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,8 @@\n+\n+  static const int OFFSET_TO_PATCHABLE_DATA_INSTRUCTION = 6 + 6 + 6; \/\/ iihf(6) + iilf(6) + lg(6)\n+  static const int BARRIER_TOTAL_LENGTH = OFFSET_TO_PATCHABLE_DATA_INSTRUCTION + 6 + 6 + 2; \/\/ cfi(6) + larl(6) + bcr(2)\n+\n+  \/\/ first 2 bytes are for cfi instruction opcode and next 4 bytes will be the value\/data to be patched,\n+  \/\/ so we are skipping first 2 bytes and returning the address of value\/data field\n+  static const int OFFSET_TO_PATCHABLE_DATA = 6 + 6 + 6 + 2; \/\/ iihf(6) + iilf(6) + lg(6) + CFI_OPCODE(2)\n+\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -34,1 +35,0 @@\n-    static const int PATCHABLE_INSTRUCTION_OFFSET = 3*6; \/\/ bytes\n@@ -41,1 +41,3 @@\n-      address inst_addr = get_barrier_start_address() + PATCHABLE_INSTRUCTION_OFFSET;\n+      address start_address = get_barrier_start_address();\n+#ifdef ASSERT\n+      address inst_addr = start_address + BarrierSetAssembler::OFFSET_TO_PATCHABLE_DATA_INSTRUCTION;\n@@ -43,2 +45,6 @@\n-      DEBUG_ONLY(Assembler::is_z_cfi(*((long*)inst_addr)));\n-      return inst_addr + 2;\n+      unsigned long instr = 0;\n+      Assembler::get_instruction(inst_addr, &instr);\n+      assert(Assembler::is_z_cfi(instr), \"sanity check\");\n+#endif \/\/ ASSERT\n+\n+      return start_address + BarrierSetAssembler::OFFSET_TO_PATCHABLE_DATA;\n@@ -48,1 +54,1 @@\n-    static const int BARRIER_TOTAL_LENGTH = PATCHABLE_INSTRUCTION_OFFSET + 2*6 + 2; \/\/ bytes\n+    static const int BARRIER_TOTAL_LENGTH = BarrierSetAssembler::BARRIER_TOTAL_LENGTH;\n@@ -80,0 +86,1 @@\n+        unsigned long instr = 0;\n@@ -83,1 +90,1 @@\n-        MacroAssembler::is_load_const(\/* address *\/ start + offset); \/\/ two instructions\n+        assert(MacroAssembler::is_load_const(\/* address *\/ start + offset), \"sanity check\"); \/\/ two instructions\n@@ -87,1 +94,2 @@\n-        Assembler::is_z_lg(*((long*)(start + offset)));\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_lg(instr), \"sanity check\");\n@@ -90,1 +98,4 @@\n-        Assembler::is_z_cfi(*((long*)(start + offset)));\n+        \/\/ it will be assignment operation, So it doesn't matter what value is already present in instr\n+        \/\/ hence, no need to 0 it out.\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_cfi(instr), \"sanity check\");\n@@ -93,1 +104,2 @@\n-        Assembler::is_z_larl(*((long*)(start + offset)));\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_larl(instr), \"sanity check\");\n@@ -96,1 +108,2 @@\n-        Assembler::is_z_bcr(*((long*)(start + offset)));\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_bcr(instr), \"sanity check\");\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetNMethod_s390.cpp","additions":23,"deletions":10,"binary":false,"changes":33,"status":"modified"}]}