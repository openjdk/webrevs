{"files":[{"patch":"@@ -174,0 +174,1 @@\n+  __ align(4, __ offset() + BARRIER_TOTAL_LENGTH); \/\/ must align the following block which requires atomic updates\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+\n+  static const int OFFSET_TO_PATCHABLE_DATA_INSTRUCTION = 6 + 6 + 6; \/\/ iihf(6) + iilf(6) + lg(6)\n+  static const int BARRIER_TOTAL_LENGTH = OFFSET_TO_PATCHABLE_DATA_INSTRUCTION + 6 + 6 + 2; \/\/ cfi(6) + larl(6) + bcr(2)\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -34,1 +35,0 @@\n-    static const int PATCHABLE_INSTRUCTION_OFFSET = 3*6; \/\/ bytes\n@@ -41,1 +41,1 @@\n-      address inst_addr = get_barrier_start_address() + PATCHABLE_INSTRUCTION_OFFSET;\n+      address inst_addr = get_barrier_start_address() + BarrierSetAssembler::OFFSET_TO_PATCHABLE_DATA_INSTRUCTION;\n@@ -43,1 +43,7 @@\n-      DEBUG_ONLY(Assembler::is_z_cfi(*((long*)inst_addr)));\n+      unsigned long instr = 0;\n+      Assembler::get_instruction(inst_addr, &instr);\n+      assert(Assembler::is_z_cfi(instr), \"sanity check\");\n+\n+      \/\/ we are currently pointing to cfi instruction,\n+      \/\/ first 2 bytes are for instruction opcode and next 4 bytes will be the value\/data to be patched,\n+      \/\/ so we can skip the first 2 bytes and just return the value\/data\n@@ -48,1 +54,1 @@\n-    static const int BARRIER_TOTAL_LENGTH = PATCHABLE_INSTRUCTION_OFFSET + 2*6 + 2; \/\/ bytes\n+    static const int BARRIER_TOTAL_LENGTH = BarrierSetAssembler::BARRIER_TOTAL_LENGTH;\n@@ -80,0 +86,1 @@\n+        unsigned long instr = 0;\n@@ -83,1 +90,1 @@\n-        MacroAssembler::is_load_const(\/* address *\/ start + offset); \/\/ two instructions\n+        assert(MacroAssembler::is_load_const(\/* address *\/ start + offset), \"sanity check\"); \/\/ two instructions\n@@ -87,1 +94,2 @@\n-        Assembler::is_z_lg(*((long*)(start + offset)));\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_lg(instr), \"sanity check\");\n@@ -90,1 +98,4 @@\n-        Assembler::is_z_cfi(*((long*)(start + offset)));\n+        \/\/ it will be assignment operation, doesn't matter what's already there instr\n+        \/\/ hence, no need to 0 it out.\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_cfi(instr), \"sanity check\");\n@@ -93,1 +104,2 @@\n-        Assembler::is_z_larl(*((long*)(start + offset)));\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_larl(instr), \"sanity check\");\n@@ -96,1 +108,2 @@\n-        Assembler::is_z_bcr(*((long*)(start + offset)));\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_bcr(instr), \"sanity check\");\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetNMethod_s390.cpp","additions":22,"deletions":9,"binary":false,"changes":31,"status":"modified"}]}