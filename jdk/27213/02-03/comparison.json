{"files":[{"patch":"@@ -174,1 +174,1 @@\n-  __ align(4, __ offset() + PATCHABLE_BARRIER_VALUE_OFFSET); \/\/ must align the following block which requires atomic updates\n+  __ align(4, __ offset() + BARRIER_TOTAL_LENGTH); \/\/ must align the following block which requires atomic updates\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-  static const int PATCHABLE_SEQ_START_OFFSET = 3 * 6;\n-  static const int PATCHABLE_BARRIER_VALUE_OFFSET = PATCHABLE_SEQ_START_OFFSET + 2;\n+  static const int OFFSET_TO_PATCHABLE_DATA_INSTRUCTION = 6 + 6 + 6; \/\/ iihf(6) + iilf(6) + lg(6)\n+  static const int BARRIER_TOTAL_LENGTH = OFFSET_TO_PATCHABLE_DATA_INSTRUCTION + 6 + 6 + 2; \/\/ cfi(6) + larl(6) + bcr(2)\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-      address inst_addr = get_barrier_start_address() + BarrierSetAssembler::PATCHABLE_SEQ_START_OFFSET;\n+      address inst_addr = get_barrier_start_address() + BarrierSetAssembler::OFFSET_TO_PATCHABLE_DATA_INSTRUCTION;\n@@ -43,1 +43,7 @@\n-      DEBUG_ONLY(Assembler::is_z_cfi(*((long*)inst_addr)));\n+      unsigned long instr = 0;\n+      Assembler::get_instruction(inst_addr, &instr);\n+      assert(Assembler::is_z_cfi(instr), \"sanity check\");\n+\n+      \/\/ we are currently pointing to cfi instruction,\n+      \/\/ first 2 bytes are for instruction opcode and next 4 bytes will be the value\/data to be patched,\n+      \/\/ so we can skip the first 2 bytes and just return the value\/data\n@@ -48,1 +54,1 @@\n-    static const int BARRIER_TOTAL_LENGTH = BarrierSetAssembler::PATCHABLE_BARRIER_VALUE_OFFSET + 2*6; \/\/ bytes\n+    static const int BARRIER_TOTAL_LENGTH = BarrierSetAssembler::BARRIER_TOTAL_LENGTH;\n@@ -80,0 +86,1 @@\n+        unsigned long instr = 0;\n@@ -83,1 +90,1 @@\n-        MacroAssembler::is_load_const(\/* address *\/ start + offset); \/\/ two instructions\n+        assert(MacroAssembler::is_load_const(\/* address *\/ start + offset), \"sanity check\"); \/\/ two instructions\n@@ -87,1 +94,2 @@\n-        Assembler::is_z_lg(*((long*)(start + offset)));\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_lg(instr), \"sanity check\");\n@@ -90,1 +98,4 @@\n-        Assembler::is_z_cfi(*((long*)(start + offset)));\n+        \/\/ it will be assignment operation, doesn't matter what's already there instr\n+        \/\/ hence, no need to 0 it out.\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_cfi(instr), \"sanity check\");\n@@ -93,1 +104,2 @@\n-        Assembler::is_z_larl(*((long*)(start + offset)));\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_larl(instr), \"sanity check\");\n@@ -96,1 +108,2 @@\n-        Assembler::is_z_bcr(*((long*)(start + offset)));\n+        Assembler::get_instruction(start + offset, &instr);\n+        assert(Assembler::is_z_bcr(instr), \"sanity check\");\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetNMethod_s390.cpp","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"}]}