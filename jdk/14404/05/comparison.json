{"files":[{"patch":"@@ -53,0 +53,1 @@\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -61,1 +62,0 @@\n-import sun.util.locale.LocaleObjectCache;\n@@ -920,1 +920,1 @@\n-            return Cache.LOCALECACHE.get(baseloc);\n+            return LOCALE_CACHE.computeIfAbsent(baseloc, Locale::createLocale);\n@@ -923,1 +923,1 @@\n-            return Cache.LOCALECACHE.get(key);\n+            return LOCALE_CACHE.computeIfAbsent(key, Locale::createLocale);\n@@ -927,16 +927,7 @@\n-    private static class Cache extends LocaleObjectCache<Object, Locale> {\n-\n-        private static final Cache LOCALECACHE = new Cache();\n-\n-        private Cache() {\n-        }\n-\n-        @Override\n-        protected Locale createObject(Object key) {\n-            if (key instanceof BaseLocale) {\n-                return new Locale((BaseLocale)key, null);\n-            } else {\n-                LocaleKey lk = (LocaleKey)key;\n-                return new Locale(lk.base, lk.exts);\n-            }\n-        }\n+    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n+    private static Locale createLocale(Object key) {\n+        return switch (key) {\n+            case BaseLocale base -> new Locale(base, null);\n+            case LocaleKey lk -> new Locale(lk.base, lk.exts);\n+            default -> throw new InternalError(\"should not happen\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -74,1 +75,0 @@\n-import sun.util.locale.LocaleObjectCache;\n@@ -2870,22 +2870,21 @@\n-            return new ArrayList<>(CANDIDATES_CACHE.get(locale.getBaseLocale()));\n-        }\n-\n-        private static final CandidateListCache CANDIDATES_CACHE = new CandidateListCache();\n-\n-        private static class CandidateListCache extends LocaleObjectCache<BaseLocale, List<Locale>> {\n-            protected List<Locale> createObject(BaseLocale base) {\n-                String language = base.getLanguage();\n-                String script = base.getScript();\n-                String region = base.getRegion();\n-                String variant = base.getVariant();\n-\n-                \/\/ Special handling for Norwegian\n-                boolean isNorwegianBokmal = false;\n-                boolean isNorwegianNynorsk = false;\n-                if (language.equals(\"no\")) {\n-                    if (region.equals(\"NO\") && variant.equals(\"NY\")) {\n-                        variant = \"\";\n-                        isNorwegianNynorsk = true;\n-                    } else {\n-                        isNorwegianBokmal = true;\n-                    }\n+            return new ArrayList<>(CANDIDATES_CACHE.computeIfAbsent(locale.getBaseLocale(),\n+                    Control::createCandidateList));\n+        }\n+\n+        private static final ReferencedKeyMap<BaseLocale, List<Locale>> CANDIDATES_CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n+\n+        private static List<Locale> createCandidateList(BaseLocale base) {\n+            String language = base.getLanguage();\n+            String script = base.getScript();\n+            String region = base.getRegion();\n+            String variant = base.getVariant();\n+\n+            \/\/ Special handling for Norwegian\n+            boolean isNorwegianBokmal = false;\n+            boolean isNorwegianNynorsk = false;\n+            if (language.equals(\"no\")) {\n+                if (region.equals(\"NO\") && variant.equals(\"NY\")) {\n+                    variant = \"\";\n+                    isNorwegianNynorsk = true;\n+                } else {\n+                    isNorwegianBokmal = true;\n@@ -2893,13 +2892,12 @@\n-                if (language.equals(\"nb\") || isNorwegianBokmal) {\n-                    List<Locale> tmpList = getDefaultList(\"nb\", script, region, variant);\n-                    \/\/ Insert a locale replacing \"nb\" with \"no\" for every list entry with precedence\n-                    List<Locale> bokmalList = new ArrayList<>();\n-                    for (Locale l_nb : tmpList) {\n-                        var isRoot = l_nb.getLanguage().isEmpty();\n-                        var l_no = Locale.getInstance(isRoot ? \"\" : \"no\",\n-                                l_nb.getScript(), l_nb.getCountry(), l_nb.getVariant(), null);\n-                        bokmalList.add(isNorwegianBokmal ? l_no : l_nb);\n-                        if (isRoot) {\n-                            break;\n-                        }\n-                        bokmalList.add(isNorwegianBokmal ? l_nb : l_no);\n+            }\n+            if (language.equals(\"nb\") || isNorwegianBokmal) {\n+                List<Locale> tmpList = getDefaultList(\"nb\", script, region, variant);\n+                \/\/ Insert a locale replacing \"nb\" with \"no\" for every list entry with precedence\n+                List<Locale> bokmalList = new ArrayList<>();\n+                for (Locale l_nb : tmpList) {\n+                    var isRoot = l_nb.getLanguage().isEmpty();\n+                    var l_no = Locale.getInstance(isRoot ? \"\" : \"no\",\n+                            l_nb.getScript(), l_nb.getCountry(), l_nb.getVariant(), null);\n+                    bokmalList.add(isNorwegianBokmal ? l_no : l_nb);\n+                    if (isRoot) {\n+                        break;\n@@ -2907,9 +2905,1 @@\n-                    return bokmalList;\n-                } else if (language.equals(\"nn\") || isNorwegianNynorsk) {\n-                    \/\/ Insert no_NO_NY, no_NO, no after nn\n-                    List<Locale> nynorskList = getDefaultList(\"nn\", script, region, variant);\n-                    int idx = nynorskList.size() - 1;\n-                    nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"NY\"));\n-                    nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"\"));\n-                    nynorskList.add(idx++, Locale.getInstance(\"no\", \"\", \"\"));\n-                    return nynorskList;\n+                    bokmalList.add(isNorwegianBokmal ? l_nb : l_no);\n@@ -2917,9 +2907,18 @@\n-                \/\/ Special handling for Chinese\n-                else if (language.equals(\"zh\")) {\n-                    if (script.isEmpty() && !region.isEmpty()) {\n-                        \/\/ Supply script for users who want to use zh_Hans\/zh_Hant\n-                        \/\/ as bundle names (recommended for Java7+)\n-                        switch (region) {\n-                            case \"TW\", \"HK\", \"MO\" -> script = \"Hant\";\n-                            case \"CN\", \"SG\"       -> script = \"Hans\";\n-                        }\n+                return bokmalList;\n+            } else if (language.equals(\"nn\") || isNorwegianNynorsk) {\n+                \/\/ Insert no_NO_NY, no_NO, no after nn\n+                List<Locale> nynorskList = getDefaultList(\"nn\", script, region, variant);\n+                int idx = nynorskList.size() - 1;\n+                nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"NY\"));\n+                nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"\"));\n+                nynorskList.add(idx++, Locale.getInstance(\"no\", \"\", \"\"));\n+                return nynorskList;\n+            }\n+            \/\/ Special handling for Chinese\n+            else if (language.equals(\"zh\")) {\n+                if (script.isEmpty() && !region.isEmpty()) {\n+                    \/\/ Supply script for users who want to use zh_Hans\/zh_Hant\n+                    \/\/ as bundle names (recommended for Java7+)\n+                    switch (region) {\n+                        case \"TW\", \"HK\", \"MO\" -> script = \"Hant\";\n+                        case \"CN\", \"SG\"       -> script = \"Hans\";\n@@ -2928,2 +2927,0 @@\n-\n-                return getDefaultList(language, script, region, variant);\n@@ -2932,2 +2929,2 @@\n-            private static List<Locale> getDefaultList(String language, String script, String region, String variant) {\n-                List<String> variants = null;\n+            return getDefaultList(language, script, region, variant);\n+        }\n@@ -2935,7 +2932,9 @@\n-                if (!variant.isEmpty()) {\n-                    variants = new ArrayList<>();\n-                    int idx = variant.length();\n-                    while (idx != -1) {\n-                        variants.add(variant.substring(0, idx));\n-                        idx = variant.lastIndexOf('_', --idx);\n-                    }\n+        private static List<Locale> getDefaultList(String language, String script, String region, String variant) {\n+            List<String> variants = null;\n+\n+            if (!variant.isEmpty()) {\n+                variants = new ArrayList<>();\n+                int idx = variant.length();\n+                while (idx != -1) {\n+                    variants.add(variant.substring(0, idx));\n+                    idx = variant.lastIndexOf('_', --idx);\n@@ -2943,0 +2942,1 @@\n+            }\n@@ -2944,1 +2944,1 @@\n-                List<Locale> list = new ArrayList<>();\n+            List<Locale> list = new ArrayList<>();\n@@ -2946,7 +2946,3 @@\n-                if (variants != null) {\n-                    for (String v : variants) {\n-                        list.add(Locale.getInstance(language, script, region, v, null));\n-                    }\n-                }\n-                if (!region.isEmpty()) {\n-                    list.add(Locale.getInstance(language, script, region, \"\", null));\n+            if (variants != null) {\n+                for (String v : variants) {\n+                    list.add(Locale.getInstance(language, script, region, v, null));\n@@ -2954,11 +2950,14 @@\n-                if (!script.isEmpty()) {\n-                    list.add(Locale.getInstance(language, script, \"\", \"\", null));\n-                    \/\/ Special handling for Chinese\n-                    if (language.equals(\"zh\")) {\n-                        if (region.isEmpty()) {\n-                            \/\/ Supply region(country) for users who still package Chinese\n-                            \/\/ bundles using old convention.\n-                            switch (script) {\n-                                case \"Hans\" -> region = \"CN\";\n-                                case \"Hant\" -> region = \"TW\";\n-                            }\n+            }\n+            if (!region.isEmpty()) {\n+                list.add(Locale.getInstance(language, script, region, \"\", null));\n+            }\n+            if (!script.isEmpty()) {\n+                list.add(Locale.getInstance(language, script, \"\", \"\", null));\n+                \/\/ Special handling for Chinese\n+                if (language.equals(\"zh\")) {\n+                    if (region.isEmpty()) {\n+                        \/\/ Supply region(country) for users who still package Chinese\n+                        \/\/ bundles using old convention.\n+                        switch (script) {\n+                            case \"Hans\" -> region = \"CN\";\n+                            case \"Hant\" -> region = \"TW\";\n@@ -2967,0 +2966,1 @@\n+                }\n@@ -2968,9 +2968,5 @@\n-                    \/\/ With script, after truncating variant, region and script,\n-                    \/\/ start over without script.\n-                    if (variants != null) {\n-                        for (String v : variants) {\n-                            list.add(Locale.getInstance(language, \"\", region, v, null));\n-                        }\n-                    }\n-                    if (!region.isEmpty()) {\n-                        list.add(Locale.getInstance(language, \"\", region, \"\", null));\n+                \/\/ With script, after truncating variant, region and script,\n+                \/\/ start over without script.\n+                if (variants != null) {\n+                    for (String v : variants) {\n+                        list.add(Locale.getInstance(language, \"\", region, v, null));\n@@ -2979,2 +2975,2 @@\n-                if (!language.isEmpty()) {\n-                    list.add(Locale.getInstance(language, \"\", \"\", \"\", null));\n+                if (!region.isEmpty()) {\n+                    list.add(Locale.getInstance(language, \"\", region, \"\", null));\n@@ -2982,4 +2978,0 @@\n-                \/\/ Add root locale at the end\n-                list.add(Locale.ROOT);\n-\n-                return list;\n@@ -2987,0 +2979,7 @@\n+            if (!language.isEmpty()) {\n+                list.add(Locale.getInstance(language, \"\", \"\", \"\", null));\n+            }\n+            \/\/ Add root locale at the end\n+            list.add(Locale.ROOT);\n+\n+            return list;\n","filename":"src\/java.base\/share\/classes\/java\/util\/ResourceBundle.java","additions":98,"deletions":99,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -39,1 +40,1 @@\n-import java.lang.ref.SoftReference;\n+import java.util.Map;\n@@ -41,0 +42,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -45,19 +47,19 @@\n-    public static final byte ENGLISH = 0,\n-            FRENCH = 1,\n-            GERMAN = 2,\n-            ITALIAN = 3,\n-            JAPANESE = 4,\n-            KOREAN = 5,\n-            CHINESE = 6,\n-            SIMPLIFIED_CHINESE = 7,\n-            TRADITIONAL_CHINESE = 8,\n-            FRANCE = 9,\n-            GERMANY = 10,\n-            ITALY = 11,\n-            JAPAN = 12,\n-            KOREA = 13,\n-            UK = 14,\n-            US = 15,\n-            CANADA = 16,\n-            CANADA_FRENCH = 17,\n-            ROOT = 18,\n+    public static final byte ROOT = 0,\n+            ENGLISH = 1,\n+            US = 2,\n+            FRENCH = 3,\n+            GERMAN = 4,\n+            ITALIAN = 5,\n+            JAPANESE = 6,\n+            KOREAN = 7,\n+            CHINESE = 8,\n+            SIMPLIFIED_CHINESE = 9,\n+            TRADITIONAL_CHINESE = 10,\n+            FRANCE = 11,\n+            GERMANY = 12,\n+            ITALY = 13,\n+            JAPAN = 14,\n+            KOREA = 15,\n+            UK = 16,\n+            CANADA = 17,\n+            CANADA_FRENCH = 18,\n@@ -93,0 +95,3 @@\n+    \/\/ Non-normalized to normalized BaseLocale cache for saving costly normalizations\n+    private static final Map<BaseLocale, BaseLocale> CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n+\n@@ -110,15 +115,5 @@\n-    \/\/ This method must be called with normalize = false only when creating the\n-    \/\/ Locale.* constants and non-normalized BaseLocale$Keys used for lookup.\n-    private BaseLocale(String language, String script, String region, String variant,\n-                       boolean normalize) {\n-        if (normalize) {\n-            this.language = LocaleUtils.toLowerString(language).intern();\n-            this.script = LocaleUtils.toTitleString(script).intern();\n-            this.region = LocaleUtils.toUpperString(region).intern();\n-            this.variant = variant.intern();\n-        } else {\n-            this.language = language;\n-            this.script = script;\n-            this.region = region;\n-            this.variant = variant;\n-        }\n+    private BaseLocale(String language, String script, String region, String variant) {\n+        this.language = language;\n+        this.script = script;\n+        this.region = region;\n+        this.variant = variant;\n@@ -130,1 +125,1 @@\n-        return new BaseLocale(language, \"\", region, \"\", false);\n+        return new BaseLocale(language, \"\", region, \"\");\n@@ -156,2 +151,2 @@\n-                if (baseLocale.getLanguage().equals(language)\n-                        && baseLocale.getRegion().equals(region)) {\n+                if (baseLocale.language.equals(language)\n+                        && baseLocale.region.equals(region)) {\n@@ -168,2 +163,10 @@\n-        Key key = new Key(language, script, region, variant, false);\n-        return Cache.CACHE.get(key);\n+        \/\/ Obtain the \"normalized\" BaseLocale, using un-normalized\n+        \/\/ BaseLocale as the key. The returned \"normalized\" instance\n+        \/\/ can subsequently be used by the Locale instance which\n+        \/\/ guarantees the locale components are properly cased\/interned.\n+        return CACHE.computeIfAbsent(new BaseLocale(language, script, region, variant),\n+                (b) -> new BaseLocale(\n+                        LocaleUtils.toLowerString(b.language).intern(),\n+                        LocaleUtils.toTitleString(b.script).intern(),\n+                        LocaleUtils.toUpperString(b.region).intern(),\n+                        b.variant.intern()));\n@@ -202,2 +205,6 @@\n-        if (!(obj instanceof BaseLocale)) {\n-            return false;\n+        if (obj instanceof BaseLocale other) {\n+            return LocaleUtils.caseIgnoreMatch(other.language, language)\n+                && LocaleUtils.caseIgnoreMatch(other.region, region)\n+                && LocaleUtils.caseIgnoreMatch(other.script, script)\n+                \/\/ variant is case sensitive in JDK!\n+                && other.variant.equals(variant);\n@@ -205,5 +212,1 @@\n-        BaseLocale other = (BaseLocale)obj;\n-        return language == other.language\n-               && script == other.script\n-               && region == other.region\n-               && variant == other.variant;\n+        return false;\n@@ -234,49 +237,1 @@\n-            \/\/ Generating a hash value from language, script, region and variant\n-            h = language.hashCode();\n-            h = 31 * h + script.hashCode();\n-            h = 31 * h + region.hashCode();\n-            h = 31 * h + variant.hashCode();\n-            if (h != 0) {\n-                hash = h;\n-            }\n-        }\n-        return h;\n-    }\n-\n-    private static final class Key {\n-        \/**\n-         * Keep a SoftReference to the Key data if normalized (actually used\n-         * as a cache key) and not initialized via the constant creation path.\n-         *\n-         * This allows us to avoid creating SoftReferences on lookup Keys\n-         * (which are short-lived) and for Locales created via\n-         * Locale#createConstant.\n-         *\/\n-        private final SoftReference<BaseLocale> holderRef;\n-        private final BaseLocale holder;\n-\n-        private final boolean normalized;\n-        private final int hash;\n-\n-        private Key(String language, String script, String region,\n-                    String variant, boolean normalize) {\n-            BaseLocale locale = new BaseLocale(language, script, region, variant, normalize);\n-            this.normalized = normalize;\n-            if (normalized) {\n-                this.holderRef = new SoftReference<>(locale);\n-                this.holder = null;\n-            } else {\n-                this.holderRef = null;\n-                this.holder = locale;\n-            }\n-            this.hash = hashCode(locale);\n-        }\n-\n-        public int hashCode() {\n-            return hash;\n-        }\n-\n-        private int hashCode(BaseLocale locale) {\n-            int h = 0;\n-            String lang = locale.getLanguage();\n-            int len = lang.length();\n+            int len = language.length();\n@@ -284,1 +239,1 @@\n-                h = 31*h + LocaleUtils.toLower(lang.charAt(i));\n+                h = 31*h + LocaleUtils.toLower(language.charAt(i));\n@@ -286,2 +241,1 @@\n-            String scrt = locale.getScript();\n-            len = scrt.length();\n+            len = script.length();\n@@ -289,1 +243,1 @@\n-                h = 31*h + LocaleUtils.toLower(scrt.charAt(i));\n+                h = 31*h + LocaleUtils.toLower(script.charAt(i));\n@@ -291,2 +245,1 @@\n-            String regn = locale.getRegion();\n-            len = regn.length();\n+            len = region.length();\n@@ -294,1 +247,1 @@\n-                h = 31*h + LocaleUtils.toLower(regn.charAt(i));\n+                h = 31*h + LocaleUtils.toLower(region.charAt(i));\n@@ -296,2 +249,1 @@\n-            String vart = locale.getVariant();\n-            len = vart.length();\n+            len = variant.length();\n@@ -299,13 +251,1 @@\n-                h = 31*h + vart.charAt(i);\n-            }\n-            return h;\n-        }\n-\n-        private BaseLocale getBaseLocale() {\n-            return (holder == null) ? holderRef.get() : holder;\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (this == obj) {\n-                return true;\n+                h = 31*h + variant.charAt(i);\n@@ -313,18 +253,2 @@\n-            if (obj instanceof Key && this.hash == ((Key)obj).hash) {\n-                BaseLocale other = ((Key) obj).getBaseLocale();\n-                BaseLocale locale = this.getBaseLocale();\n-                if (other != null && locale != null\n-                    && LocaleUtils.caseIgnoreMatch(other.getLanguage(), locale.getLanguage())\n-                    && LocaleUtils.caseIgnoreMatch(other.getScript(), locale.getScript())\n-                    && LocaleUtils.caseIgnoreMatch(other.getRegion(), locale.getRegion())\n-                    \/\/ variant is case sensitive in JDK!\n-                    && other.getVariant().equals(locale.getVariant())) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        public static Key normalize(Key key) {\n-            if (key.normalized) {\n-                return key;\n+            if (h != 0) {\n+                hash = h;\n@@ -332,24 +256,0 @@\n-\n-            \/\/ Only normalized keys may be softly referencing the data holder\n-            assert (key.holder != null && key.holderRef == null);\n-            BaseLocale locale = key.holder;\n-            return new Key(locale.getLanguage(), locale.getScript(),\n-                    locale.getRegion(), locale.getVariant(), true);\n-        }\n-    }\n-\n-    private static class Cache extends LocaleObjectCache<Key, BaseLocale> {\n-\n-        private static final Cache CACHE = new Cache();\n-\n-        public Cache() {\n-        }\n-\n-        @Override\n-        protected Key normalizeKey(Key key) {\n-            return Key.normalize(key);\n-        }\n-\n-        @Override\n-        protected BaseLocale createObject(Key key) {\n-            return Key.normalize(key).getBaseLocale();\n@@ -357,0 +257,1 @@\n+        return h;\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":62,"deletions":161,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *******************************************************************************\n- * Copyright (C) 2009-2010, International Business Machines Corporation and    *\n- * others. All Rights Reserved.                                                *\n- *******************************************************************************\n- *\/\n-package sun.util.locale;\n-\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.SoftReference;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-public abstract class LocaleObjectCache<K, V> {\n-    private final ConcurrentMap<K, CacheEntry<K, V>> map;\n-    private final ReferenceQueue<V> queue = new ReferenceQueue<>();\n-\n-    public LocaleObjectCache() {\n-        this(16, 0.75f, 16);\n-    }\n-\n-    public LocaleObjectCache(int initialCapacity, float loadFactor, int concurrencyLevel) {\n-        map = new ConcurrentHashMap<>(initialCapacity, loadFactor, concurrencyLevel);\n-    }\n-\n-    public V get(K key) {\n-        V value = null;\n-\n-        cleanStaleEntries();\n-        CacheEntry<K, V> entry = map.get(key);\n-        if (entry != null) {\n-            value = entry.get();\n-        }\n-        if (value == null) {\n-            key = normalizeKey(key);\n-            V newVal = createObject(key);\n-            if (key == null || newVal == null) {\n-                \/\/ subclass must return non-null key\/value object\n-                return null;\n-            }\n-\n-            CacheEntry<K, V> newEntry = new CacheEntry<>(key, newVal, queue);\n-            entry = map.putIfAbsent(key, newEntry);\n-            if (entry == null) {\n-                value = newVal;\n-            } else {\n-                value = entry.get();\n-                if (value == null) {\n-                    map.put(key, newEntry);\n-                    value = newVal;\n-                }\n-            }\n-        }\n-        return value;\n-    }\n-\n-    protected V put(K key, V value) {\n-        CacheEntry<K, V> entry = new CacheEntry<>(key, value, queue);\n-        CacheEntry<K, V> oldEntry = map.put(key, entry);\n-        return (oldEntry == null) ? null : oldEntry.get();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void cleanStaleEntries() {\n-        CacheEntry<K, V> entry;\n-        while ((entry = (CacheEntry<K, V>)queue.poll()) != null) {\n-            map.remove(entry.getKey(), entry);\n-        }\n-    }\n-\n-    protected abstract V createObject(K key);\n-\n-    protected K normalizeKey(K key) {\n-        return key;\n-    }\n-\n-    private static class CacheEntry<K, V> extends SoftReference<V> {\n-        private K key;\n-\n-        CacheEntry(K key, V value, ReferenceQueue<V> queue) {\n-            super(value, queue);\n-            this.key = key;\n-        }\n-\n-        K getKey() {\n-            return key;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/LocaleObjectCache.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -151,0 +151,14 @@\n+\/*\n+ * @test id=iu-aggressive-comp\n+ * @summary Make sure Shenandoah can recover from humongous allocation fragmentation\n+ * @key randomness\n+ * @bug 8289220 8309622\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xlog:gc -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx1g -Xms1g -XX:ShenandoahTargetNumRegions=2048\n+ *      -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n+ *      -XX:+ShenandoahOOMDuringEvacALot -XX:+ShenandoahVerify -Xcomp\n+ *      TestAllocHumongousFragment\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocHumongousFragment.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Locale;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * This benchmark tests if caching of Locale objects works\n+ * correctly.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 4, time = 2)\n+@Measurement(iterations = 4, time = 2)\n+@Fork(value = 5)\n+public class LocaleCache {\n+    @Benchmark\n+    public void testForLanguageTag() {\n+        Locale previous = null;\n+        for (int count = 100; count > 0; count--) {\n+            var l = Locale.forLanguageTag(\"foo\");\n+            if (previous != null && previous != l) {\n+                throw new RuntimeException(\"Different Locale was created\");\n+            }\n+            previous = l;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testLocaleOf() {\n+        Locale previous = null;\n+        for (int count = 100; count > 0; count--) {\n+            var l = Locale.of(\"foo\");\n+            if (previous != null && previous != l) {\n+                throw new RuntimeException(\"Different Locale was created\");\n+            }\n+            previous = l;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/LocaleCache.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}