{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -63,1 +64,0 @@\n-import sun.util.locale.LocaleObjectCache;\n@@ -990,1 +990,1 @@\n-            return Cache.LOCALECACHE.get(baseloc);\n+            return LOCALE_CACHE.computeIfAbsent(baseloc, Locale::createLocale);\n@@ -993,1 +993,1 @@\n-            return Cache.LOCALECACHE.get(key);\n+            return LOCALE_CACHE.computeIfAbsent(key, Locale::createLocale);\n@@ -997,16 +997,7 @@\n-    private static class Cache extends LocaleObjectCache<Object, Locale> {\n-\n-        private static final Cache LOCALECACHE = new Cache();\n-\n-        private Cache() {\n-        }\n-\n-        @Override\n-        protected Locale createObject(Object key) {\n-            if (key instanceof BaseLocale) {\n-                return new Locale((BaseLocale)key, null);\n-            } else {\n-                LocaleKey lk = (LocaleKey)key;\n-                return new Locale(lk.base, lk.exts);\n-            }\n-        }\n+    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n+    private static Locale createLocale(Object key) {\n+        return switch (key) {\n+            case BaseLocale base -> new Locale(base, null);\n+            case LocaleKey lk -> new Locale(lk.base, lk.exts);\n+            default -> throw new InternalError(\"should not happen\");\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -74,1 +75,0 @@\n-import sun.util.locale.LocaleObjectCache;\n@@ -2870,22 +2870,21 @@\n-            return new ArrayList<>(CANDIDATES_CACHE.get(locale.getBaseLocale()));\n-        }\n-\n-        private static final CandidateListCache CANDIDATES_CACHE = new CandidateListCache();\n-\n-        private static class CandidateListCache extends LocaleObjectCache<BaseLocale, List<Locale>> {\n-            protected List<Locale> createObject(BaseLocale base) {\n-                String language = base.getLanguage();\n-                String script = base.getScript();\n-                String region = base.getRegion();\n-                String variant = base.getVariant();\n-\n-                \/\/ Special handling for Norwegian\n-                boolean isNorwegianBokmal = false;\n-                boolean isNorwegianNynorsk = false;\n-                if (language.equals(\"no\")) {\n-                    if (region.equals(\"NO\") && variant.equals(\"NY\")) {\n-                        variant = \"\";\n-                        isNorwegianNynorsk = true;\n-                    } else {\n-                        isNorwegianBokmal = true;\n-                    }\n+            return new ArrayList<>(CANDIDATES_CACHE.computeIfAbsent(locale.getBaseLocale(),\n+                    Control::createCandidateList));\n+        }\n+\n+        private static final ReferencedKeyMap<BaseLocale, List<Locale>> CANDIDATES_CACHE = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n+\n+        private static List<Locale> createCandidateList(BaseLocale base) {\n+            String language = base.getLanguage();\n+            String script = base.getScript();\n+            String region = base.getRegion();\n+            String variant = base.getVariant();\n+\n+            \/\/ Special handling for Norwegian\n+            boolean isNorwegianBokmal = false;\n+            boolean isNorwegianNynorsk = false;\n+            if (language.equals(\"no\")) {\n+                if (region.equals(\"NO\") && variant.equals(\"NY\")) {\n+                    variant = \"\";\n+                    isNorwegianNynorsk = true;\n+                } else {\n+                    isNorwegianBokmal = true;\n@@ -2893,13 +2892,12 @@\n-                if (language.equals(\"nb\") || isNorwegianBokmal) {\n-                    List<Locale> tmpList = getDefaultList(\"nb\", script, region, variant);\n-                    \/\/ Insert a locale replacing \"nb\" with \"no\" for every list entry with precedence\n-                    List<Locale> bokmalList = new ArrayList<>();\n-                    for (Locale l_nb : tmpList) {\n-                        var isRoot = l_nb.getLanguage().isEmpty();\n-                        var l_no = Locale.getInstance(isRoot ? \"\" : \"no\",\n-                                l_nb.getScript(), l_nb.getCountry(), l_nb.getVariant(), null);\n-                        bokmalList.add(isNorwegianBokmal ? l_no : l_nb);\n-                        if (isRoot) {\n-                            break;\n-                        }\n-                        bokmalList.add(isNorwegianBokmal ? l_nb : l_no);\n+            }\n+            if (language.equals(\"nb\") || isNorwegianBokmal) {\n+                List<Locale> tmpList = getDefaultList(\"nb\", script, region, variant);\n+                \/\/ Insert a locale replacing \"nb\" with \"no\" for every list entry with precedence\n+                List<Locale> bokmalList = new ArrayList<>();\n+                for (Locale l_nb : tmpList) {\n+                    var isRoot = l_nb.getLanguage().isEmpty();\n+                    var l_no = Locale.getInstance(isRoot ? \"\" : \"no\",\n+                            l_nb.getScript(), l_nb.getCountry(), l_nb.getVariant(), null);\n+                    bokmalList.add(isNorwegianBokmal ? l_no : l_nb);\n+                    if (isRoot) {\n+                        break;\n@@ -2907,9 +2905,1 @@\n-                    return bokmalList;\n-                } else if (language.equals(\"nn\") || isNorwegianNynorsk) {\n-                    \/\/ Insert no_NO_NY, no_NO, no after nn\n-                    List<Locale> nynorskList = getDefaultList(\"nn\", script, region, variant);\n-                    int idx = nynorskList.size() - 1;\n-                    nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"NY\"));\n-                    nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"\"));\n-                    nynorskList.add(idx++, Locale.getInstance(\"no\", \"\", \"\"));\n-                    return nynorskList;\n+                    bokmalList.add(isNorwegianBokmal ? l_nb : l_no);\n@@ -2917,9 +2907,18 @@\n-                \/\/ Special handling for Chinese\n-                else if (language.equals(\"zh\")) {\n-                    if (script.isEmpty() && !region.isEmpty()) {\n-                        \/\/ Supply script for users who want to use zh_Hans\/zh_Hant\n-                        \/\/ as bundle names (recommended for Java7+)\n-                        switch (region) {\n-                            case \"TW\", \"HK\", \"MO\" -> script = \"Hant\";\n-                            case \"CN\", \"SG\"       -> script = \"Hans\";\n-                        }\n+                return bokmalList;\n+            } else if (language.equals(\"nn\") || isNorwegianNynorsk) {\n+                \/\/ Insert no_NO_NY, no_NO, no after nn\n+                List<Locale> nynorskList = getDefaultList(\"nn\", script, region, variant);\n+                int idx = nynorskList.size() - 1;\n+                nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"NY\"));\n+                nynorskList.add(idx++, Locale.getInstance(\"no\", \"NO\", \"\"));\n+                nynorskList.add(idx++, Locale.getInstance(\"no\", \"\", \"\"));\n+                return nynorskList;\n+            }\n+            \/\/ Special handling for Chinese\n+            else if (language.equals(\"zh\")) {\n+                if (script.isEmpty() && !region.isEmpty()) {\n+                    \/\/ Supply script for users who want to use zh_Hans\/zh_Hant\n+                    \/\/ as bundle names (recommended for Java7+)\n+                    switch (region) {\n+                        case \"TW\", \"HK\", \"MO\" -> script = \"Hant\";\n+                        case \"CN\", \"SG\"       -> script = \"Hans\";\n@@ -2928,2 +2927,0 @@\n-\n-                return getDefaultList(language, script, region, variant);\n@@ -2932,2 +2929,2 @@\n-            private static List<Locale> getDefaultList(String language, String script, String region, String variant) {\n-                List<String> variants = null;\n+            return getDefaultList(language, script, region, variant);\n+        }\n@@ -2935,7 +2932,9 @@\n-                if (!variant.isEmpty()) {\n-                    variants = new ArrayList<>();\n-                    int idx = variant.length();\n-                    while (idx != -1) {\n-                        variants.add(variant.substring(0, idx));\n-                        idx = variant.lastIndexOf('_', --idx);\n-                    }\n+        private static List<Locale> getDefaultList(String language, String script, String region, String variant) {\n+            List<String> variants = null;\n+\n+            if (!variant.isEmpty()) {\n+                variants = new ArrayList<>();\n+                int idx = variant.length();\n+                while (idx != -1) {\n+                    variants.add(variant.substring(0, idx));\n+                    idx = variant.lastIndexOf('_', --idx);\n@@ -2943,0 +2942,1 @@\n+            }\n@@ -2944,1 +2944,1 @@\n-                List<Locale> list = new ArrayList<>();\n+            List<Locale> list = new ArrayList<>();\n@@ -2946,7 +2946,3 @@\n-                if (variants != null) {\n-                    for (String v : variants) {\n-                        list.add(Locale.getInstance(language, script, region, v, null));\n-                    }\n-                }\n-                if (!region.isEmpty()) {\n-                    list.add(Locale.getInstance(language, script, region, \"\", null));\n+            if (variants != null) {\n+                for (String v : variants) {\n+                    list.add(Locale.getInstance(language, script, region, v, null));\n@@ -2954,11 +2950,14 @@\n-                if (!script.isEmpty()) {\n-                    list.add(Locale.getInstance(language, script, \"\", \"\", null));\n-                    \/\/ Special handling for Chinese\n-                    if (language.equals(\"zh\")) {\n-                        if (region.isEmpty()) {\n-                            \/\/ Supply region(country) for users who still package Chinese\n-                            \/\/ bundles using old convention.\n-                            switch (script) {\n-                                case \"Hans\" -> region = \"CN\";\n-                                case \"Hant\" -> region = \"TW\";\n-                            }\n+            }\n+            if (!region.isEmpty()) {\n+                list.add(Locale.getInstance(language, script, region, \"\", null));\n+            }\n+            if (!script.isEmpty()) {\n+                list.add(Locale.getInstance(language, script, \"\", \"\", null));\n+                \/\/ Special handling for Chinese\n+                if (language.equals(\"zh\")) {\n+                    if (region.isEmpty()) {\n+                        \/\/ Supply region(country) for users who still package Chinese\n+                        \/\/ bundles using old convention.\n+                        switch (script) {\n+                            case \"Hans\" -> region = \"CN\";\n+                            case \"Hant\" -> region = \"TW\";\n@@ -2967,0 +2966,1 @@\n+                }\n@@ -2968,9 +2968,5 @@\n-                    \/\/ With script, after truncating variant, region and script,\n-                    \/\/ start over without script.\n-                    if (variants != null) {\n-                        for (String v : variants) {\n-                            list.add(Locale.getInstance(language, \"\", region, v, null));\n-                        }\n-                    }\n-                    if (!region.isEmpty()) {\n-                        list.add(Locale.getInstance(language, \"\", region, \"\", null));\n+                \/\/ With script, after truncating variant, region and script,\n+                \/\/ start over without script.\n+                if (variants != null) {\n+                    for (String v : variants) {\n+                        list.add(Locale.getInstance(language, \"\", region, v, null));\n@@ -2979,2 +2975,2 @@\n-                if (!language.isEmpty()) {\n-                    list.add(Locale.getInstance(language, \"\", \"\", \"\", null));\n+                if (!region.isEmpty()) {\n+                    list.add(Locale.getInstance(language, \"\", region, \"\", null));\n@@ -2982,4 +2978,0 @@\n-                \/\/ Add root locale at the end\n-                list.add(Locale.ROOT);\n-\n-                return list;\n@@ -2987,0 +2979,7 @@\n+            if (!language.isEmpty()) {\n+                list.add(Locale.getInstance(language, \"\", \"\", \"\", null));\n+            }\n+            \/\/ Add root locale at the end\n+            list.add(Locale.ROOT);\n+\n+            return list;\n","filename":"src\/java.base\/share\/classes\/java\/util\/ResourceBundle.java","additions":98,"deletions":99,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.internal.util.ReferencedKeySet;\n@@ -39,1 +40,0 @@\n-import java.lang.ref.SoftReference;\n@@ -41,0 +41,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -45,19 +46,19 @@\n-    public static final byte ENGLISH = 0,\n-            FRENCH = 1,\n-            GERMAN = 2,\n-            ITALIAN = 3,\n-            JAPANESE = 4,\n-            KOREAN = 5,\n-            CHINESE = 6,\n-            SIMPLIFIED_CHINESE = 7,\n-            TRADITIONAL_CHINESE = 8,\n-            FRANCE = 9,\n-            GERMANY = 10,\n-            ITALY = 11,\n-            JAPAN = 12,\n-            KOREA = 13,\n-            UK = 14,\n-            US = 15,\n-            CANADA = 16,\n-            CANADA_FRENCH = 17,\n-            ROOT = 18,\n+    public static final byte ROOT = 0,\n+            ENGLISH = 1,\n+            US = 2,\n+            FRENCH = 3,\n+            GERMAN = 4,\n+            ITALIAN = 5,\n+            JAPANESE = 6,\n+            KOREAN = 7,\n+            CHINESE = 8,\n+            SIMPLIFIED_CHINESE = 9,\n+            TRADITIONAL_CHINESE = 10,\n+            FRANCE = 11,\n+            GERMANY = 12,\n+            ITALY = 13,\n+            JAPAN = 14,\n+            KOREA = 15,\n+            UK = 16,\n+            CANADA = 17,\n+            CANADA_FRENCH = 18,\n@@ -93,0 +94,4 @@\n+    \/\/ Interned BaseLocale cache\n+    private static final ReferencedKeySet<BaseLocale> CACHE =\n+            ReferencedKeySet.create(true, ConcurrentHashMap::new);\n+\n@@ -110,15 +115,5 @@\n-    \/\/ This method must be called with normalize = false only when creating the\n-    \/\/ Locale.* constants and non-normalized BaseLocale$Keys used for lookup.\n-    private BaseLocale(String language, String script, String region, String variant,\n-                       boolean normalize) {\n-        if (normalize) {\n-            this.language = LocaleUtils.toLowerString(language).intern();\n-            this.script = LocaleUtils.toTitleString(script).intern();\n-            this.region = LocaleUtils.toUpperString(region).intern();\n-            this.variant = variant.intern();\n-        } else {\n-            this.language = language;\n-            this.script = script;\n-            this.region = region;\n-            this.variant = variant;\n-        }\n+    private BaseLocale(String language, String script, String region, String variant) {\n+        this.language = language;\n+        this.script = script;\n+        this.region = region;\n+        this.variant = variant;\n@@ -130,1 +125,1 @@\n-        return new BaseLocale(language, \"\", region, \"\", false);\n+        return new BaseLocale(language, \"\", region, \"\");\n@@ -156,2 +151,2 @@\n-                if (baseLocale.getLanguage().equals(language)\n-                        && baseLocale.getRegion().equals(region)) {\n+                if (baseLocale.language.equals(language)\n+                        && baseLocale.region.equals(region)) {\n@@ -168,2 +163,9 @@\n-        Key key = new Key(language, script, region, variant, false);\n-        return Cache.CACHE.get(key);\n+        \/\/ Obtain the \"interned\" BaseLocale from the cache. The returned\n+        \/\/ \"interned\" instance can subsequently be used by the Locale\n+        \/\/ instance which guarantees the locale components are properly cased\/interned.\n+        return CACHE.intern(new BaseLocale(language, script, region, variant),\n+            (b) -> new BaseLocale(\n+                LocaleUtils.toLowerString(b.language).intern(),\n+                LocaleUtils.toTitleString(b.script).intern(),\n+                LocaleUtils.toUpperString(b.region).intern(),\n+                b.variant.intern()));\n@@ -202,2 +204,6 @@\n-        if (!(obj instanceof BaseLocale)) {\n-            return false;\n+        if (obj instanceof BaseLocale other) {\n+            return LocaleUtils.caseIgnoreMatch(other.language, language)\n+                && LocaleUtils.caseIgnoreMatch(other.region, region)\n+                && LocaleUtils.caseIgnoreMatch(other.script, script)\n+                \/\/ variant is case sensitive in JDK!\n+                && other.variant.equals(variant);\n@@ -205,5 +211,1 @@\n-        BaseLocale other = (BaseLocale)obj;\n-        return language == other.language\n-               && script == other.script\n-               && region == other.region\n-               && variant == other.variant;\n+        return false;\n@@ -234,49 +236,1 @@\n-            \/\/ Generating a hash value from language, script, region and variant\n-            h = language.hashCode();\n-            h = 31 * h + script.hashCode();\n-            h = 31 * h + region.hashCode();\n-            h = 31 * h + variant.hashCode();\n-            if (h != 0) {\n-                hash = h;\n-            }\n-        }\n-        return h;\n-    }\n-\n-    private static final class Key {\n-        \/**\n-         * Keep a SoftReference to the Key data if normalized (actually used\n-         * as a cache key) and not initialized via the constant creation path.\n-         *\n-         * This allows us to avoid creating SoftReferences on lookup Keys\n-         * (which are short-lived) and for Locales created via\n-         * Locale#createConstant.\n-         *\/\n-        private final SoftReference<BaseLocale> holderRef;\n-        private final BaseLocale holder;\n-\n-        private final boolean normalized;\n-        private final int hash;\n-\n-        private Key(String language, String script, String region,\n-                    String variant, boolean normalize) {\n-            BaseLocale locale = new BaseLocale(language, script, region, variant, normalize);\n-            this.normalized = normalize;\n-            if (normalized) {\n-                this.holderRef = new SoftReference<>(locale);\n-                this.holder = null;\n-            } else {\n-                this.holderRef = null;\n-                this.holder = locale;\n-            }\n-            this.hash = hashCode(locale);\n-        }\n-\n-        public int hashCode() {\n-            return hash;\n-        }\n-\n-        private int hashCode(BaseLocale locale) {\n-            int h = 0;\n-            String lang = locale.getLanguage();\n-            int len = lang.length();\n+            int len = language.length();\n@@ -284,1 +238,1 @@\n-                h = 31*h + LocaleUtils.toLower(lang.charAt(i));\n+                h = 31*h + LocaleUtils.toLower(language.charAt(i));\n@@ -286,2 +240,1 @@\n-            String scrt = locale.getScript();\n-            len = scrt.length();\n+            len = script.length();\n@@ -289,1 +242,1 @@\n-                h = 31*h + LocaleUtils.toLower(scrt.charAt(i));\n+                h = 31*h + LocaleUtils.toLower(script.charAt(i));\n@@ -291,2 +244,1 @@\n-            String regn = locale.getRegion();\n-            len = regn.length();\n+            len = region.length();\n@@ -294,1 +246,1 @@\n-                h = 31*h + LocaleUtils.toLower(regn.charAt(i));\n+                h = 31*h + LocaleUtils.toLower(region.charAt(i));\n@@ -296,2 +248,1 @@\n-            String vart = locale.getVariant();\n-            len = vart.length();\n+            len = variant.length();\n@@ -299,13 +250,1 @@\n-                h = 31*h + vart.charAt(i);\n-            }\n-            return h;\n-        }\n-\n-        private BaseLocale getBaseLocale() {\n-            return (holder == null) ? holderRef.get() : holder;\n-        }\n-\n-        @Override\n-        public boolean equals(Object obj) {\n-            if (this == obj) {\n-                return true;\n+                h = 31*h + variant.charAt(i);\n@@ -313,18 +252,2 @@\n-            if (obj instanceof Key && this.hash == ((Key)obj).hash) {\n-                BaseLocale other = ((Key) obj).getBaseLocale();\n-                BaseLocale locale = this.getBaseLocale();\n-                if (other != null && locale != null\n-                    && LocaleUtils.caseIgnoreMatch(other.getLanguage(), locale.getLanguage())\n-                    && LocaleUtils.caseIgnoreMatch(other.getScript(), locale.getScript())\n-                    && LocaleUtils.caseIgnoreMatch(other.getRegion(), locale.getRegion())\n-                    \/\/ variant is case sensitive in JDK!\n-                    && other.getVariant().equals(locale.getVariant())) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        public static Key normalize(Key key) {\n-            if (key.normalized) {\n-                return key;\n+            if (h != 0) {\n+                hash = h;\n@@ -332,24 +255,0 @@\n-\n-            \/\/ Only normalized keys may be softly referencing the data holder\n-            assert (key.holder != null && key.holderRef == null);\n-            BaseLocale locale = key.holder;\n-            return new Key(locale.getLanguage(), locale.getScript(),\n-                    locale.getRegion(), locale.getVariant(), true);\n-        }\n-    }\n-\n-    private static class Cache extends LocaleObjectCache<Key, BaseLocale> {\n-\n-        private static final Cache CACHE = new Cache();\n-\n-        public Cache() {\n-        }\n-\n-        @Override\n-        protected Key normalizeKey(Key key) {\n-            return Key.normalize(key);\n-        }\n-\n-        @Override\n-        protected BaseLocale createObject(Key key) {\n-            return Key.normalize(key).getBaseLocale();\n@@ -357,0 +256,1 @@\n+        return h;\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":61,"deletions":161,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *******************************************************************************\n- * Copyright (C) 2009-2010, International Business Machines Corporation and    *\n- * others. All Rights Reserved.                                                *\n- *******************************************************************************\n- *\/\n-package sun.util.locale;\n-\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.SoftReference;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n-\n-public abstract class LocaleObjectCache<K, V> {\n-    private final ConcurrentMap<K, CacheEntry<K, V>> map;\n-    private final ReferenceQueue<V> queue = new ReferenceQueue<>();\n-\n-    public LocaleObjectCache() {\n-        this(16, 0.75f, 16);\n-    }\n-\n-    public LocaleObjectCache(int initialCapacity, float loadFactor, int concurrencyLevel) {\n-        map = new ConcurrentHashMap<>(initialCapacity, loadFactor, concurrencyLevel);\n-    }\n-\n-    public V get(K key) {\n-        V value = null;\n-\n-        cleanStaleEntries();\n-        CacheEntry<K, V> entry = map.get(key);\n-        if (entry != null) {\n-            value = entry.get();\n-        }\n-        if (value == null) {\n-            key = normalizeKey(key);\n-            V newVal = createObject(key);\n-            if (key == null || newVal == null) {\n-                \/\/ subclass must return non-null key\/value object\n-                return null;\n-            }\n-\n-            CacheEntry<K, V> newEntry = new CacheEntry<>(key, newVal, queue);\n-            entry = map.putIfAbsent(key, newEntry);\n-            if (entry == null) {\n-                value = newVal;\n-            } else {\n-                value = entry.get();\n-                if (value == null) {\n-                    map.put(key, newEntry);\n-                    value = newVal;\n-                }\n-            }\n-        }\n-        return value;\n-    }\n-\n-    protected V put(K key, V value) {\n-        CacheEntry<K, V> entry = new CacheEntry<>(key, value, queue);\n-        CacheEntry<K, V> oldEntry = map.put(key, entry);\n-        return (oldEntry == null) ? null : oldEntry.get();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void cleanStaleEntries() {\n-        CacheEntry<K, V> entry;\n-        while ((entry = (CacheEntry<K, V>)queue.poll()) != null) {\n-            map.remove(entry.getKey(), entry);\n-        }\n-    }\n-\n-    protected abstract V createObject(K key);\n-\n-    protected K normalizeKey(K key) {\n-        return key;\n-    }\n-\n-    private static class CacheEntry<K, V> extends SoftReference<V> {\n-        private final K key;\n-\n-        CacheEntry(K key, V value, ReferenceQueue<V> queue) {\n-            super(value, queue);\n-            this.key = key;\n-        }\n-\n-        K getKey() {\n-            return key;\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/LocaleObjectCache.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"}]}