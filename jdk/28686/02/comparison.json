{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,2 @@\n+       Address rsp = context.getRegisterAsAddress(AMD64ThreadContext.RSP);\n+       if (rsp == null) return null;\n@@ -93,1 +95,1 @@\n-       return new BsdAMD64CFrame(dbg, rbp, pc);\n+       return new BsdAMD64CFrame(dbg, rsp, rbp, pc);\n@@ -96,0 +98,2 @@\n+       Address sp = context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+       if (sp == null) return null;\n@@ -100,1 +104,1 @@\n-       return new BsdAARCH64CFrame(dbg, fp, pc);\n+       return new BsdAARCH64CFrame(dbg, sp, fp, pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdCDebugger.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import sun.jvm.hotspot.code.*;\n@@ -34,0 +35,2 @@\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.aarch64.*;\n@@ -36,1 +39,1 @@\n-   public BsdAARCH64CFrame(BsdDebugger dbg, Address fp, Address pc) {\n+   public BsdAARCH64CFrame(BsdDebugger dbg, Address sp, Address fp, Address pc) {\n@@ -38,0 +41,1 @@\n+      this.sp = sp;\n@@ -57,0 +61,1 @@\n+   @Override\n@@ -58,2 +63,2 @@\n-      AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();\n-      Address rsp = context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+      return sender(thread, null, null, null);\n+   }\n@@ -61,2 +66,13 @@\n-      if ((fp == null) || fp.lessThan(rsp)) {\n-        return null;\n+   @Override\n+   public CFrame sender(ThreadProxy thread, Address nextSP, Address nextFP, Address nextPC) {\n+      \/\/ Check fp\n+      \/\/ Skip if both nextFP and nextPC are given - do not need to load from fp.\n+      if (nextFP == null && nextPC == null) {\n+        if (fp == null) {\n+          return null;\n+        }\n+\n+        \/\/ Check alignment of fp\n+        if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+          return null;\n+        }\n@@ -65,2 +81,4 @@\n-      \/\/ Check alignment of fp\n-      if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+      if (nextFP == null) {\n+        nextFP = fp.getAddressAt(0);\n+      }\n+      if (nextFP == null) {\n@@ -70,3 +88,2 @@\n-      Address nextFP = fp.getAddressAt(0 * ADDRESS_SIZE);\n-      if (nextFP == null || nextFP.lessThanOrEqual(fp)) {\n-        return null;\n+      if (nextPC == null) {\n+        nextPC = fp.getAddressAt(ADDRESS_SIZE);\n@@ -74,1 +91,0 @@\n-      Address nextPC  = fp.getAddressAt(1 * ADDRESS_SIZE);\n@@ -78,1 +94,26 @@\n-      return new BsdAARCH64CFrame(dbg, nextFP, nextPC);\n+\n+      if (nextSP == null) {\n+        CodeCache cc = VM.getVM().getCodeCache();\n+        CodeBlob currentBlob = cc.findBlobUnsafe(pc());\n+\n+        \/\/ This case is different from HotSpot. See JDK-8371194 for details.\n+        if (currentBlob != null && (currentBlob.isContinuationStub() || currentBlob.isNativeMethod())) {\n+          \/\/ Use FP since it should always be valid for these cases.\n+          \/\/ TODO: These should be walked as Frames not CFrames.\n+          nextSP = fp.addOffsetTo(2 * ADDRESS_SIZE);\n+        } else {\n+          CodeBlob codeBlob = cc.findBlobUnsafe(nextPC);\n+          boolean useCodeBlob = codeBlob != null && codeBlob.getFrameSize() > 0;\n+          nextSP = useCodeBlob ? nextFP.addOffsetTo((2 * ADDRESS_SIZE) - codeBlob.getFrameSize()) : nextFP;\n+        }\n+      }\n+      if (nextSP == null) {\n+        return null;\n+      }\n+\n+      return new BsdAARCH64CFrame(dbg, nextSP, nextFP, nextPC);\n+   }\n+\n+   @Override\n+   public Frame toFrame() {\n+      return new AARCH64Frame(sp, fp, pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/aarch64\/BsdAARCH64CFrame.java","additions":54,"deletions":13,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.amd64.*;\n@@ -34,1 +36,1 @@\n-   public BsdAMD64CFrame(BsdDebugger dbg, Address rbp, Address rip) {\n+   public BsdAMD64CFrame(BsdDebugger dbg, Address rsp, Address rbp, Address rip) {\n@@ -36,0 +38,1 @@\n+      this.rsp = rsp;\n@@ -55,0 +58,1 @@\n+   @Override\n@@ -56,2 +60,2 @@\n-      AMD64ThreadContext context = (AMD64ThreadContext) thread.getContext();\n-      Address rsp = context.getRegisterAsAddress(AMD64ThreadContext.RSP);\n+      return sender(thread, null, null, null);\n+   }\n@@ -59,2 +63,13 @@\n-      if ( (rbp == null) || rbp.lessThan(rsp) ) {\n-        return null;\n+   @Override\n+   public CFrame sender(ThreadProxy thread, Address sp, Address fp, Address pc) {\n+      \/\/ Check fp\n+      \/\/ Skip if both fp and pc are given - do not need to load from rbp.\n+      if (fp == null && pc == null) {\n+        if (rbp == null) {\n+          return null;\n+        }\n+\n+        \/\/ Check alignment of rbp\n+        if (dbg.getAddressValue(rbp) % ADDRESS_SIZE != 0) {\n+          return null;\n+        }\n@@ -63,2 +78,2 @@\n-      \/\/ Check alignment of rbp\n-      if (dbg.getAddressValue(rbp) % ADDRESS_SIZE != 0) {\n+      Address nextRSP = sp != null ? sp : rbp.addOffsetTo(2 * ADDRESS_SIZE);\n+      if (nextRSP == null) {\n@@ -67,3 +82,2 @@\n-\n-      Address nextRBP = rbp.getAddressAt( 0 * ADDRESS_SIZE);\n-      if (nextRBP == null || nextRBP.lessThanOrEqual(rbp)) {\n+      Address nextRBP = fp != null ? fp : rbp.getAddressAt(0);\n+      if (nextRBP == null) {\n@@ -72,1 +86,1 @@\n-      Address nextPC  = rbp.getAddressAt( 1 * ADDRESS_SIZE);\n+      Address nextPC  = pc != null ? pc : rbp.getAddressAt(ADDRESS_SIZE);\n@@ -76,1 +90,6 @@\n-      return new BsdAMD64CFrame(dbg, nextRBP, nextPC);\n+      return new BsdAMD64CFrame(dbg, nextRSP, nextRBP, nextPC);\n+   }\n+\n+   @Override\n+   public Frame toFrame() {\n+      return new AMD64Frame(rsp, rbp, rip);\n@@ -81,0 +100,1 @@\n+   private Address rsp;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/amd64\/BsdAMD64CFrame.java","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"}]}