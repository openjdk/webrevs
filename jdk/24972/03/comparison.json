{"files":[{"patch":"@@ -553,0 +553,1 @@\n+    int min_count = (c1_only || c2_only) ? 1 : 2;\n@@ -563,1 +564,1 @@\n-      count = MAX2(log_cpu * loglog_cpu * 3 \/ 2, 2);\n+      count = MAX2(log_cpu * loglog_cpu * 3 \/ 2, min_count);\n@@ -577,1 +578,1 @@\n-        count = MAX2(max_count, c1_only ? 1 : 2);\n+        count = MAX2(max_count, min_count);\n@@ -596,1 +597,1 @@\n-      \/\/ No C2 compiler thread required\n+      \/\/ No C2 compiler threads are needed\n@@ -599,0 +600,1 @@\n+      \/\/ No C1 compiler threads are needed\n@@ -616,0 +618,3 @@\n+  } else {\n+    \/\/ Interpreter mode creates no compilers\n+    FLAG_SET_ERGO(CICompilerCount, 0);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib \/\n+ * @bug 8356000\n+ * @requires vm.flagless\n+ * @requires vm.bits == \"64\"\n+ * @run driver compiler.arguments.TestCompilerCounts\n+ *\/\n+\n+package compiler.arguments;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.function.Function;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.cli.CommandLineOptionTest;\n+\n+public class TestCompilerCounts {\n+\n+    \/\/ Try not to go over max CPU count on the machine, since we do not\n+    \/\/ know if the rest of runtime would accept it.\n+    \/\/ For local testing, feel free to override this to a larger value\n+    \/\/ if you want to see how heuristics works on even larger machines.\n+    static final int MAX_CPUS = Runtime.getRuntime().availableProcessors();\n+\n+    \/\/ Test at most 16 CPUs linearly, to limit test execution time.\n+    \/\/ After this limit, go for exponential steps.\n+    static final int MAX_LINEAR_CPUS = Math.min(16, MAX_CPUS);\n+\n+    public static void main(String[] args) throws Throwable {\n+        \/\/ CICompilerCount=0 is incorrect in default modes.\n+        fail(\"-XX:CICompilerCount=0\");\n+\n+        \/\/ Interpreter-only mode accepts all values, but sets 0 threads\n+        pass(0, \"-XX:CICompilerCount=1\", \"-XX:TieredStopAtLevel=0\");\n+\n+        \/\/ C1\/C2 only modes accept CICompilerCount=1\n+        pass(1, \"-XX:CICompilerCount=1\", \"-XX:TieredStopAtLevel=1\");\n+        pass(1, \"-XX:CICompilerCount=1\", \"-XX:TieredStopAtLevel=2\");\n+        pass(1, \"-XX:CICompilerCount=1\", \"-XX:TieredStopAtLevel=3\");\n+        pass(1, \"-XX:CICompilerCount=1\", \"-XX:-TieredCompilation\");\n+\n+        \/\/ C1+C2 modes need at least 2 threads\n+        fail(\"-XX:CICompilerCount=1\");\n+        fail(\"-XX:CICompilerCount=1\", \"-XX:TieredStopAtLevel=4\");\n+\n+        \/\/ Overriding the CICompilerCount overrides compiler counts hard.\n+        for (int count = 2; count <= MAX_CPUS; count += (count >= MAX_LINEAR_CPUS ? count : 1)) {\n+            String opt = \"-XX:CICompilerCount=\" + count;\n+\n+            \/\/ Interpreter-only mode always sets 0 threads\n+            pass(0, opt, \"-XX:TieredStopAtLevel=0\");\n+\n+            \/\/ All compiled modes accept reasonable CICompilerCount\n+            pass(count, opt);\n+            pass(count, opt, \"-XX:TieredStopAtLevel=1\");\n+            pass(count, opt, \"-XX:TieredStopAtLevel=2\");\n+            pass(count, opt, \"-XX:TieredStopAtLevel=3\");\n+            pass(count, opt, \"-XX:TieredStopAtLevel=4\");\n+            pass(count, opt, \"-XX:-TieredCompilation\");\n+        }\n+\n+        \/\/ Per CPU heuristics is disabled, we are going to set up defaults.\n+\n+        for (int cpus = 2; cpus <= MAX_CPUS; cpus += (cpus >= MAX_LINEAR_CPUS ? cpus : 1)) {\n+            String opt = \"-XX:ActiveProcessorCount=\" + cpus;\n+            String opt2 = \"-XX:-CICompilerCountPerCPU\";\n+\n+            \/\/ Interpreter-only mode always set 0 threads\n+            pass(0, opt, opt2, \"-XX:TieredStopAtLevel=0\");\n+\n+            \/\/ All compiled modes default to 2 threads, statically compiled in\n+            pass(2, opt, opt2);\n+            pass(2, opt, opt2, \"-XX:TieredStopAtLevel=1\");\n+            pass(2, opt, opt2, \"-XX:TieredStopAtLevel=2\");\n+            pass(2, opt, opt2, \"-XX:TieredStopAtLevel=3\");\n+            pass(2, opt, opt2, \"-XX:TieredStopAtLevel=4\");\n+            pass(2, opt, opt2, \"-XX:-TieredCompilation\");\n+        }\n+\n+        \/\/ Otherwise, we set CICompilerCount heuristically.\n+\n+        \/\/ Check hitting the lower values exactly first.\n+        for (int cpus = 1; cpus <= 3; cpus++) {\n+            String opt = \"-XX:ActiveProcessorCount=\" + cpus;\n+\n+            \/\/ Interpreter-only mode always set 0 threads\n+            pass(0, opt, \"-XX:TieredStopAtLevel=0\");\n+\n+            \/\/ Non-tiered modes set 1 thread\n+            pass(1, opt, \"-XX:TieredStopAtLevel=1\");\n+            pass(1, opt, \"-XX:TieredStopAtLevel=2\");\n+            pass(1, opt, \"-XX:TieredStopAtLevel=3\");\n+            pass(1, opt, \"-XX:-TieredCompilation\");\n+\n+            \/\/ Tiered modes set 2 threads\n+            pass(2, opt);\n+            pass(2, opt, \"-XX:TieredStopAtLevel=4\");\n+        }\n+\n+        \/\/ Check what heuristics sets past the trivial number of CPUs.\n+        for (int cpus = 4; cpus <= MAX_CPUS; cpus += (cpus >= MAX_LINEAR_CPUS ? cpus : 1)) {\n+            String opt = \"-XX:ActiveProcessorCount=\" + cpus;\n+\n+            \/\/ Interpreter-only mode always set 0 threads\n+            pass(0, opt, \"-XX:TieredStopAtLevel=0\");\n+\n+            \/\/ Non-tiered modes\n+            int nonTieredCount = heuristicCount(cpus, false);\n+            pass(nonTieredCount, opt, \"-XX:TieredStopAtLevel=1\");\n+            pass(nonTieredCount, opt, \"-XX:TieredStopAtLevel=2\");\n+            pass(nonTieredCount, opt, \"-XX:TieredStopAtLevel=3\");\n+            pass(nonTieredCount, opt, \"-XX:-TieredCompilation\");\n+\n+            \/\/ Tiered modes\n+            int tieredCount = heuristicCount(cpus, true);\n+            pass(tieredCount, opt);\n+            pass(tieredCount, opt, \"-XX:TieredStopAtLevel=4\");\n+\n+            \/\/ Also check that heuristics did not set up more threads than CPUs available\n+            Asserts.assertTrue(nonTieredCount <= cpus,\n+                \"Non-tiered count is larger than number of CPUs: \" + nonTieredCount + \" > \" + cpus);\n+            Asserts.assertTrue(tieredCount <= cpus,\n+                \"Tiered count is larger than number of CPUs: \" + tieredCount + \" > \" + cpus);\n+        }\n+    }\n+\n+    \/\/ Direct translation from CompilationPolicy::initialize:\n+    public static int heuristicCount(int cpus, boolean tiered) {\n+        int log_cpu = log2(cpus);\n+        int loglog_cpu = log2(Math.max(log_cpu, 1));\n+        int min_count = tiered ? 2 : 1;\n+        return Math.max(log_cpu * loglog_cpu * 3 \/ 2, min_count);\n+    }\n+\n+    public static int log2(int v) {\n+        return (int)(Math.log(v) \/ Math.log(2));\n+    }\n+\n+    public static void pass(int count, String... args) throws Throwable {\n+        CommandLineOptionTest.verifyOptionValueForSameVM(\"CICompilerCount\", \"\" + count, \"\", args);\n+    }\n+\n+    public static void fail(String... args) throws Throwable {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestCompilerCounts.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"}]}