{"files":[{"patch":"@@ -436,0 +436,1 @@\n+    int min_count = (c1_only || c2_only) ? 1 : 2;\n@@ -443,2 +444,0 @@\n-      int min_count = (c1_only || c2_only) ? 1 : 2;\n-      int active_cpus = os::active_processor_count();\n@@ -446,1 +445,1 @@\n-      int log_cpu = log2i(active_cpus);\n+      int log_cpu = log2i(os::active_processor_count());\n@@ -471,1 +470,0 @@\n-      assert((!c1_only && !c2_only) || count <= active_cpus, \"Too many threads: %d\", count);\n@@ -489,0 +487,1 @@\n+      \/\/ No C2 compiler threads are needed\n@@ -491,0 +490,1 @@\n+      \/\/ No C1 compiler threads are needed\n@@ -508,0 +508,3 @@\n+  } else {\n+    \/\/ Interpreter mode creates no compilers\n+    FLAG_SET_ERGO(CICompilerCount, 0);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,3 +29,1 @@\n- * @requires vm.debug\n- *\n- * @summary Test compiler counts selection, verified by internal assertions\n+ * @requires vm.bits == \"64\"\n@@ -41,0 +39,2 @@\n+import java.util.function.Function;\n+import jdk.test.lib.Asserts;\n@@ -43,0 +43,1 @@\n+import jdk.test.lib.cli.CommandLineOptionTest;\n@@ -46,8 +47,62 @@\n-    public static void main(String[] args) throws IOException {\n-        testWith(\"-XX:TieredStopAtLevel=0\");\n-        testWith(\"-XX:TieredStopAtLevel=1\");\n-        testWith(\"-XX:TieredStopAtLevel=2\");\n-        testWith(\"-XX:TieredStopAtLevel=3\");\n-        testWith(\"-XX:TieredStopAtLevel=4\");\n-        testWith(\"-XX:-TieredCompilation\");\n-    }\n+    \/\/ Try not to go over max CPU count on the machine, since we do not\n+    \/\/ know if the rest of runtime would accept it.\n+    \/\/ For local testing, feel free to override this to a larger value\n+    \/\/ if you want to see how heuristics works on even larger machines.\n+    static final int MAX_CPUS = Runtime.getRuntime().availableProcessors();\n+\n+    \/\/ Test at most 16 CPUs linearly, to limit test execution time.\n+    \/\/ After this limit, go for exponential steps.\n+    static final int MAX_LINEAR_CPUS = Math.min(16, MAX_CPUS);\n+\n+    public static void main(String[] args) throws Throwable {\n+        \/\/ CICompilerCount=0 is incorrect in default modes.\n+        fail(\"-XX:CICompilerCount=0\");\n+\n+        \/\/ Interpreter-only mode accepts all values, but sets 0 threads\n+        pass(0, \"-XX:CICompilerCount=1\", \"-XX:TieredStopAtLevel=0\");\n+\n+        \/\/ C1\/C2 only modes accept CICompilerCount=1\n+        pass(1, \"-XX:CICompilerCount=1\", \"-XX:TieredStopAtLevel=1\");\n+        pass(1, \"-XX:CICompilerCount=1\", \"-XX:TieredStopAtLevel=2\");\n+        pass(1, \"-XX:CICompilerCount=1\", \"-XX:TieredStopAtLevel=3\");\n+        pass(1, \"-XX:CICompilerCount=1\", \"-XX:-TieredCompilation\");\n+\n+        \/\/ C1+C2 modes need at least 2 threads\n+        fail(\"-XX:CICompilerCount=1\");\n+        fail(\"-XX:CICompilerCount=1\", \"-XX:TieredStopAtLevel=4\");\n+\n+        \/\/ Overriding the CICompilerCount overrides compiler counts hard.\n+        for (int count = 2; count <= MAX_CPUS; count += (count >= MAX_LINEAR_CPUS ? count : 1)) {\n+            String opt = \"-XX:CICompilerCount=\" + count;\n+\n+            \/\/ Interpreter-only mode always sets 0 threads\n+            pass(0, opt, \"-XX:TieredStopAtLevel=0\");\n+\n+            \/\/ All compiled modes accept reasonable CICompilerCount\n+            pass(count, opt);\n+            pass(count, opt, \"-XX:TieredStopAtLevel=1\");\n+            pass(count, opt, \"-XX:TieredStopAtLevel=2\");\n+            pass(count, opt, \"-XX:TieredStopAtLevel=3\");\n+            pass(count, opt, \"-XX:TieredStopAtLevel=4\");\n+            pass(count, opt, \"-XX:-TieredCompilation\");\n+        }\n+\n+        \/\/ Per CPU heuristics is disabled, we are going to set up defaults.\n+\n+        for (int cpus = 2; cpus <= MAX_CPUS; cpus += (cpus >= MAX_LINEAR_CPUS ? cpus : 1)) {\n+            String opt = \"-XX:ActiveProcessorCount=\" + cpus;\n+            String opt2 = \"-XX:-CICompilerCountPerCPU\";\n+\n+            \/\/ Interpreter-only mode always set 0 threads\n+            pass(0, opt, opt2, \"-XX:TieredStopAtLevel=0\");\n+\n+            \/\/ All compiled modes default to 2 threads, statically compiled in\n+            pass(2, opt, opt2);\n+            pass(2, opt, opt2, \"-XX:TieredStopAtLevel=1\");\n+            pass(2, opt, opt2, \"-XX:TieredStopAtLevel=2\");\n+            pass(2, opt, opt2, \"-XX:TieredStopAtLevel=3\");\n+            pass(2, opt, opt2, \"-XX:TieredStopAtLevel=4\");\n+            pass(2, opt, opt2, \"-XX:-TieredCompilation\");\n+        }\n+\n+        \/\/ Otherwise, we set CICompilerCount heuristically.\n@@ -55,10 +110,42 @@\n-    public static void testWith(String mode) throws IOException {\n-        for (int cpus = 1; cpus <= Runtime.getRuntime().availableProcessors(); cpus++) {\n-            String[] args = new String[] {\n-                mode,\n-                \"-XX:ActiveProcessorCount=\" + cpus,\n-                \"-version\"\n-            };\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n-            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-            output.shouldHaveExitValue(0);\n+        \/\/ Check hitting the lower values exactly first.\n+        for (int cpus = 1; cpus <= 3; cpus++) {\n+            String opt = \"-XX:ActiveProcessorCount=\" + cpus;\n+\n+            \/\/ Interpreter-only mode always set 0 threads\n+            pass(0, opt, \"-XX:TieredStopAtLevel=0\");\n+\n+            \/\/ Non-tiered modes set 1 thread\n+            pass(1, opt, \"-XX:TieredStopAtLevel=1\");\n+            pass(1, opt, \"-XX:TieredStopAtLevel=2\");\n+            pass(1, opt, \"-XX:TieredStopAtLevel=3\");\n+            pass(1, opt, \"-XX:-TieredCompilation\");\n+\n+            \/\/ Tiered modes set 2 threads\n+            pass(2, opt);\n+            pass(2, opt, \"-XX:TieredStopAtLevel=4\");\n+        }\n+\n+        \/\/ Check what heuristics sets past the trivial number of CPUs.\n+        for (int cpus = 4; cpus <= MAX_CPUS; cpus += (cpus >= MAX_LINEAR_CPUS ? cpus : 1)) {\n+            String opt = \"-XX:ActiveProcessorCount=\" + cpus;\n+\n+            \/\/ Interpreter-only mode always set 0 threads\n+            pass(0, opt, \"-XX:TieredStopAtLevel=0\");\n+\n+            \/\/ Non-tiered modes\n+            int nonTieredCount = heuristicCount(cpus, false);\n+            pass(nonTieredCount, opt, \"-XX:TieredStopAtLevel=1\");\n+            pass(nonTieredCount, opt, \"-XX:TieredStopAtLevel=2\");\n+            pass(nonTieredCount, opt, \"-XX:TieredStopAtLevel=3\");\n+            pass(nonTieredCount, opt, \"-XX:-TieredCompilation\");\n+\n+            \/\/ Tiered modes\n+            int tieredCount = heuristicCount(cpus, true);\n+            pass(tieredCount, opt);\n+            pass(tieredCount, opt, \"-XX:TieredStopAtLevel=4\");\n+\n+            \/\/ Also check that heuristics did not set up more threads than CPUs available\n+            Asserts.assertTrue(nonTieredCount <= cpus,\n+                \"Non-tiered count is larger than number of CPUs: \" + nonTieredCount + \" > \" + cpus);\n+            Asserts.assertTrue(tieredCount <= cpus,\n+                \"Tiered count is larger than number of CPUs: \" + tieredCount + \" > \" + cpus);\n@@ -68,0 +155,22 @@\n+    \/\/ Direct translation from CompilationPolicy::initialize:\n+    public static int heuristicCount(int cpus, boolean tiered) {\n+        int log_cpu = log2(cpus);\n+        int loglog_cpu = log2(Math.max(log_cpu, 1));\n+        int min_count = tiered ? 2 : 1;\n+        return Math.max(log_cpu * loglog_cpu * 3 \/ 2, min_count);\n+    }\n+\n+    public static int log2(int v) {\n+        return (int)(Math.log(v) \/ Math.log(2));\n+    }\n+\n+    public static void pass(int count, String... args) throws Throwable {\n+        CommandLineOptionTest.verifyOptionValueForSameVM(\"CICompilerCount\", \"\" + count, \"\", args);\n+    }\n+\n+    public static void fail(String... args) throws Throwable {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotHaveExitValue(0);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestCompilerCounts.java","additions":130,"deletions":21,"binary":false,"changes":151,"status":"modified"}]}