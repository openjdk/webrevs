{"files":[{"patch":"@@ -475,0 +475,2 @@\n+        \/\/ after 101 is handled we check for other 1xx responses\n+        cf = cf.thenCompose(this::ignore1xxResponse);\n@@ -479,0 +481,50 @@\n+    \/**\n+     * Checks whether the passed Response has a status code between 102 and 199 (both inclusive).\n+     * If so, then that {@code Response} is considered intermediate informational response and is\n+     * ignored by the client. This method then creates a new {@link CompletableFuture} which\n+     * completes when a subsequent response is sent by the server. Such newly constructed\n+     * {@link CompletableFuture} will not complete till a \"final\" response (one which doesn't have\n+     * a response code between 102 and 199 inclusive) is sent by the server. The returned\n+     * {@link CompletableFuture} is thus capable of handling multiple subsequent intermediate\n+     * informational responses from the server.\n+     * <p>\n+     * If the passed Response doesn't have a status code between 102 and 199 (both inclusive) then\n+     * this method immediately returns back a completed {@link CompletableFuture} with the passed\n+     * {@code Response}.\n+     * <\/p>\n+     *\n+     * @param rsp The response\n+     * @return A {@code CompletableFuture} with the final response from the server\n+     *\/\n+    private CompletableFuture<Response> ignore1xxResponse(final Response rsp) {\n+        final int statusCode = rsp.statusCode();\n+        \/\/ we ignore any response code which is 1xx.\n+        \/\/ For 100 (with the request configured to expect-continue) and 101, we handle it\n+        \/\/ specifically as defined in the RFC-9110, outside of this method.\n+        \/\/ As noted in RFC-9110, section 15.2.1, if response code is 100 and if the request wasn't\n+        \/\/ configured with expectContinue, then we ignore the 100 response and wait for the final\n+        \/\/ response (just like any other 1xx response)\n+        \/\/ Any other response code between 102 and 199 (both inclusive) aren't specified in the\n+        \/\/ \"HTTP semantics\" RFC-9110. The spec states that these 1xx response codes are informational\n+        \/\/ and interim and the client can choose to ignore them and continue to wait for the\n+        \/\/ final response (headers)\n+        if ((statusCode >= 102 && statusCode <= 199)\n+                || (statusCode == 100 && !request.expectContinue)) {\n+            Log.logTrace(\"Ignoring (1xx informational) response code {0}\", rsp.statusCode());\n+            if (debug.on()) {\n+                debug.log(\"Ignoring (1xx informational) response code \"\n+                        + rsp.statusCode());\n+            }\n+            assert exchImpl != null : \"Illegal state - current exchange isn't set\";\n+            \/\/ ignore this Response and wait again for the subsequent response headers\n+            final CompletableFuture<Response> cf = exchImpl.getResponseAsync(parentExecutor);\n+            \/\/ we recompose the CF again into the ignore1xxResponse check\/function because\n+            \/\/ the 1xx response is allowed to be sent multiple times for a request, before\n+            \/\/ a final response arrives\n+            return cf.thenCompose(this::ignore1xxResponse);\n+        } else {\n+            \/\/ return the already completed future\n+            return MinimalFuture.completedFuture(rsp);\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,343 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpTimeoutException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test\n+ * @bug 8292044\n+ * @summary Tests behaviour of HttpClient when server responds with 102 or 103 status codes\n+ * @modules java.base\/sun.net.www.http\n+ * java.net.http\/jdk.internal.net.http.common\n+ * java.net.http\/jdk.internal.net.http.frame\n+ * java.net.http\/jdk.internal.net.http.hpack\n+ * java.logging\n+ * jdk.httpserver\n+ * @library http2\/server\n+ * @build Http2TestServer HttpServerAdapters\n+ * @run testng\/othervm -Djdk.internal.httpclient.debug=true\n+ * *                   -Djdk.httpclient.HttpClient.log=headers,requests,responses,errors Response1xxTest\n+ *\/\n+public class Response1xxTest {\n+    private static final String EXPECTED_RSP_BODY = \"Hello World\";\n+\n+    private ServerSocket serverSocket;\n+    private Http11Server server;\n+    private String http1RequestURIBase;\n+\n+\n+    private HttpServerAdapters.HttpTestServer http2Server;\n+    private String http2RequestURIBase;\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        serverSocket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+        server = new Http11Server(serverSocket);\n+        new Thread(server).start();\n+        http1RequestURIBase = \"http:\/\/\" + serverSocket.getInetAddress().getHostAddress()\n+                + \":\" + serverSocket.getLocalPort();\n+\n+        http2Server = HttpServerAdapters.HttpTestServer.of(new Http2TestServer(\"localhost\", false, 0));\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/102\");\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/103\");\n+        http2Server.addHandler(new Http2Handler(), \"\/http2\/100\");\n+        http2Server.addHandler(new OnlyInformationalHandler(), \"\/http2\/only-informational\");\n+        http2RequestURIBase = \"http:\/\/\" + http2Server.serverAuthority() + \"\/http2\";\n+        http2Server.start();\n+        System.out.println(\"Started HTTP2 server at \" + http2Server.getAddress());\n+    }\n+\n+    @AfterClass\n+    public void teardown() throws Exception {\n+        if (server != null) {\n+            server.stop = true;\n+            System.out.println(\"(HTTP 1.1) Server stop requested\");\n+        }\n+        if (serverSocket != null) {\n+            serverSocket.close();\n+            System.out.println(\"Closed (HTTP 1.1) server socket\");\n+        }\n+        if (http2Server != null) {\n+            http2Server.stop();\n+            System.out.println(\"Stopped HTTP2 server\");\n+        }\n+    }\n+\n+    private static final class Http11Server implements Runnable {\n+        private static final int CONTENT_LENGTH = EXPECTED_RSP_BODY.getBytes(StandardCharsets.UTF_8).length;\n+\n+        private static final String HTTP_1_1_RSP_200 = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Content-Length: \" + CONTENT_LENGTH + \"\\r\\n\\r\\n\" +\n+                EXPECTED_RSP_BODY;\n+\n+        private static final String REQ_LINE_FOO = \"GET \/test\/foo HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_BAR = \"GET \/test\/bar HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_HELLO = \"GET \/test\/hello HTTP\/1.1\\r\\n\";\n+\n+\n+        private final ServerSocket serverSocket;\n+        private volatile boolean stop;\n+\n+        private Http11Server(final ServerSocket serverSocket) {\n+            this.serverSocket = serverSocket;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                System.out.println(\"Server running at \" + serverSocket);\n+                while (!stop) {\n+                    \/\/ accept a connection\n+                    final Socket socket = serverSocket.accept();\n+                    System.out.println(\"Accepted connection from client \" + socket);\n+                    \/\/ read request\n+                    final String requestLine;\n+                    try {\n+                        requestLine = readRequestLine(socket);\n+                    } catch (Throwable t) {\n+                        \/\/ ignore connections from potential rogue client\n+                        System.err.println(\"Ignoring connection\/request from client \" + socket\n+                                + \" due to exception:\");\n+                        t.printStackTrace();\n+                        \/\/ close the socket\n+                        safeClose(socket);\n+                        continue;\n+                    }\n+                    System.out.println(\"Received following request line from client \" + socket\n+                            + \" :\\n\" + requestLine);\n+                    final int informationalResponseCode;\n+                    if (requestLine.startsWith(REQ_LINE_FOO)) {\n+                        \/\/ we will send intermediate\/informational 102 response\n+                        informationalResponseCode = 102;\n+                    } else if (requestLine.startsWith(REQ_LINE_BAR)) {\n+                        \/\/ we will send intermediate\/informational 103 response\n+                        informationalResponseCode = 103;\n+                    } else if (requestLine.startsWith(REQ_LINE_HELLO)) {\n+                        \/\/ we will send intermediate\/informational 100 response\n+                        informationalResponseCode = 100;\n+                    } else {\n+                        \/\/ unexpected client. ignore and close the client\n+                        System.err.println(\"Ignoring unexpected request from client \" + socket);\n+                        safeClose(socket);\n+                        continue;\n+                    }\n+                    try (final OutputStream os = socket.getOutputStream()) {\n+                        \/\/ send informational response headers a few times (spec allows them to\n+                        \/\/ be sent multiple times)\n+                        for (int i = 0; i < 3; i++) {\n+                            \/\/ send 1xx response header\n+                            os.write((\"HTTP\/1.1 \" + informationalResponseCode + \"\\r\\n\\r\\n\")\n+                                    .getBytes(StandardCharsets.UTF_8));\n+                            os.flush();\n+                            System.out.println(\"Sent response code \" + informationalResponseCode\n+                                    + \" to client \" + socket);\n+                        }\n+                        \/\/ now send a final response\n+                        System.out.println(\"Now sending 200 response code to client \" + socket);\n+                        os.write(HTTP_1_1_RSP_200.getBytes(StandardCharsets.UTF_8));\n+                        os.flush();\n+                        System.out.println(\"Sent 200 response code to client \" + socket);\n+                    }\n+                }\n+            } catch (Throwable t) {\n+                System.err.println(\"Stopping server due to exception\");\n+                t.printStackTrace();\n+            }\n+        }\n+\n+        static String readRequestLine(final Socket sock) throws IOException {\n+            final InputStream is = sock.getInputStream();\n+            final StringBuilder sb = new StringBuilder(\"\");\n+            byte[] buf = new byte[1024];\n+            while (!sb.toString().endsWith(\"\\r\\n\\r\\n\")) {\n+                final int numRead = is.read(buf);\n+                if (numRead == -1) {\n+                    return sb.toString();\n+                }\n+                final String part = new String(buf, 0, numRead, StandardCharsets.ISO_8859_1);\n+                sb.append(part);\n+            }\n+            return sb.toString();\n+        }\n+\n+        private static void safeClose(final Socket socket) {\n+            try {\n+                socket.close();\n+            } catch (Throwable t) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    private static class Http2Handler implements HttpServerAdapters.HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpServerAdapters.HttpTestExchange exchange) throws IOException {\n+            final URI requestURI = exchange.getRequestURI();\n+            final int informationResponseCode;\n+            if (requestURI.getPath().endsWith(\"\/102\")) {\n+                informationResponseCode = 102;\n+            } else if (requestURI.getPath().endsWith(\"\/103\")) {\n+                informationResponseCode = 103;\n+            } else if (requestURI.getPath().endsWith(\"\/100\")) {\n+                informationResponseCode = 100;\n+            } else {\n+                \/\/ unexpected request\n+                System.err.println(\"Unexpected request \" + requestURI + \" from client \"\n+                        + exchange.getRemoteAddress());\n+                exchange.sendResponseHeaders(400, -1);\n+                return;\n+            }\n+            \/\/ send informational response headers a few times (spec allows them to\n+            \/\/ be sent multiple times)\n+            for (int i = 0; i < 3; i++) {\n+                exchange.sendResponseHeaders(informationResponseCode, -1);\n+                System.out.println(\"Sent \" + informationResponseCode + \" response code from H2 server\");\n+            }\n+            \/\/ now send 200 response\n+            try {\n+                final byte[] body = EXPECTED_RSP_BODY.getBytes(StandardCharsets.UTF_8);\n+                exchange.sendResponseHeaders(200, body.length);\n+                System.out.println(\"Sent 200 response from H2 server\");\n+                try (OutputStream os = exchange.getResponseBody()) {\n+                    os.write(body);\n+                }\n+                System.out.println(\"Sent response body from H2 server\");\n+            } catch (Throwable e) {\n+                System.err.println(\"Failed to send response from HTTP2 handler:\");\n+                e.printStackTrace();\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static class OnlyInformationalHandler implements HttpServerAdapters.HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpServerAdapters.HttpTestExchange exchange) throws IOException {\n+            \/\/ we only send informational response and then return\n+            for (int i = 0; i < 5; i++) {\n+                exchange.sendResponseHeaders(102, -1);\n+                System.out.println(\"Sent 102 response code from H2 server\");\n+                \/\/ wait for a while before sending again\n+                try {\n+                    Thread.sleep(2000);\n+                } catch (InterruptedException e) {\n+                    \/\/ just return\n+                    System.err.println(\"Handler thread interrupted\");\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests that when a HTTP\/1.1 server sends intermediate 1xx response codes and then the final\n+     * response, the client (internally) will ignore those intermediate informational response codes\n+     * and only return the final response to the application\n+     *\/\n+    @Test\n+    public void test1xxForHTTP11() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_1_1)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        final URI[] requestURIs = new URI[]{\n+                new URI(http1RequestURIBase + \"\/test\/foo\"),\n+                new URI(http1RequestURIBase + \"\/test\/bar\"),\n+                new URI(http1RequestURIBase + \"\/test\/hello\")};\n+        for (final URI requestURI : requestURIs) {\n+            final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+            System.out.println(\"Issuing request to \" + requestURI);\n+            final HttpResponse<String> response = client.send(request,\n+                    HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+            Assert.assertEquals(response.version(), HttpClient.Version.HTTP_1_1,\n+                    \"Unexpected HTTP version in response\");\n+            Assert.assertEquals(response.statusCode(), 200, \"Unexpected response code\");\n+            Assert.assertEquals(response.body(), EXPECTED_RSP_BODY, \"Unexpected response body\");\n+        }\n+    }\n+\n+    \/**\n+     * Tests that when a HTTP2 server sends intermediate 1xx response codes and then the final\n+     * response, the client (internally) will ignore those intermediate informational response codes\n+     * and only return the final response to the application\n+     *\/\n+    @Test\n+    public void test1xxForHTTP2() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_2)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        final URI[] requestURIs = new URI[]{\n+                new URI(http2RequestURIBase + \"\/102\"),\n+                new URI(http2RequestURIBase + \"\/103\"),\n+                new URI(http2RequestURIBase + \"\/100\")};\n+        for (final URI requestURI : requestURIs) {\n+            final HttpRequest request = HttpRequest.newBuilder(requestURI).build();\n+            System.out.println(\"Issuing request to \" + requestURI);\n+            final HttpResponse<String> response = client.send(request,\n+                    HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+            Assert.assertEquals(response.version(), HttpClient.Version.HTTP_2,\n+                    \"Unexpected HTTP version in response\");\n+            Assert.assertEquals(response.statusCode(), 200, \"Unexpected response code\");\n+            Assert.assertEquals(response.body(), EXPECTED_RSP_BODY, \"Unexpected response body\");\n+        }\n+    }\n+\n+\n+    \/**\n+     * Tests that when a request is issued with a specific request timeout and the server\n+     * responds with intermediate 1xx response code but doesn't respond with a final response within\n+     * the timeout duration, then the application fails with a request timeout\n+     *\/\n+    @Test\n+    public void test1xxRequestTimeout() throws Exception {\n+        final HttpClient client = HttpClient.newBuilder()\n+                .version(HttpClient.Version.HTTP_2)\n+                .proxy(HttpClient.Builder.NO_PROXY).build();\n+        final URI requestURI = new URI(http2RequestURIBase + \"\/only-informational\");\n+        final Duration requestTimeout = Duration.ofSeconds(2);\n+        final HttpRequest request = HttpRequest.newBuilder(requestURI).timeout(requestTimeout)\n+                .build();\n+        System.out.println(\"Issuing request to \" + requestURI);\n+        \/\/ we expect the request to timeout\n+        Assert.assertThrows(HttpTimeoutException.class, () -> {\n+            client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/Response1xxTest.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"added"}]}