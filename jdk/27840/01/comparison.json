{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import java.lang.ref.Cleaner;\n+import java.lang.ref.PhantomReference;\n@@ -80,1 +80,1 @@\n-     * Whole amount of time in milliseconds to wait for class loader to be reclaimed.\n+     * Phantom reference to the class loader.\n@@ -82,11 +82,1 @@\n-    private static final int WAIT_TIMEOUT = 15000;\n-\n-    \/**\n-     * Sleep time in milliseconds for the loop waiting for the class loader to be reclaimed.\n-     *\/\n-    private static final int WAIT_DELTA = 1000;\n-\n-    \/**\n-     * Has class loader been reclaimed or not.\n-     *\/\n-    volatile boolean is_reclaimed = false;\n+    private PhantomReference<Object> customClassLoaderPhantomRef = null;\n@@ -104,0 +94,8 @@\n+    \/**\n+     * Has class loader been reclaimed or not.\n+     *\/\n+    private boolean isClassLoaderReclaimed() {\n+        return customClassLoaderPhantomRef != null\n+            && customClassLoaderPhantomRef.refersTo(null);\n+    }\n+\n@@ -141,2 +139,1 @@\n-        \/\/ Register a Cleaner to inform us when the class loader has been reclaimed.\n-        Cleaner.create().register(customClassLoader, () -> { is_reclaimed = true; } );\n+        customClassLoaderPhantomRef = new PhantomReference<>(customClassLoader, null);\n@@ -157,2 +154,1 @@\n-        \/\/ Register a Cleaner to inform us when the class loader has been reclaimed.\n-        Cleaner.create().register(customClassLoader, () -> { is_reclaimed = true; } );\n+        customClassLoaderPhantomRef = new PhantomReference<>(customClassLoader, null);\n@@ -247,2 +243,0 @@\n-        is_reclaimed = false;\n-\n@@ -250,1 +244,0 @@\n-        long waitTimeout = (customClassLoader == null) ? 0 : WAIT_TIMEOUT;\n@@ -257,14 +250,0 @@\n-        \/\/ give GC chance to run and wait for receiving reclaim notification\n-        long timeToFinish = System.currentTimeMillis() + waitTimeout;\n-        while (!is_reclaimed && System.currentTimeMillis() < timeToFinish) {\n-            if (!stresser.continueExecution()) {\n-                return false;\n-            }\n-            try {\n-                \/\/ suspend thread for a while\n-                Thread.sleep(WAIT_DELTA);\n-            } catch (InterruptedException e) {\n-                throw new Failure(\"Unexpected InterruptedException while class unloading: \" + e);\n-            }\n-        }\n-\n@@ -272,1 +251,1 @@\n-        if (is_reclaimed) {\n+        if (isClassLoaderReclaimed()) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/ClassUnloader.java","additions":15,"deletions":36,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,2 +152,0 @@\n-    public static final int MAX_UNLOAD_ATTEMPS = 5;\n-\n@@ -157,2 +155,0 @@\n-        int unloadAttemps = 0;\n-\n@@ -160,5 +156,1 @@\n-            boolean wasUnloaded = false;\n-\n-            while (!wasUnloaded && (unloadAttemps++ < MAX_UNLOAD_ATTEMPS)) {\n-                wasUnloaded = classUnloader.unloadClass();\n-            }\n+            boolean wasUnloaded = classUnloader.unloadClass();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/AbstractDebuggeeTest.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"}]}