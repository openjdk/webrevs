{"files":[{"patch":"@@ -48,2 +48,0 @@\n-  _degenerated_cycles_in_a_row(0),\n-  _successful_cycles_in_a_row(0),\n@@ -202,1 +200,1 @@\n-  return _degenerated_cycles_in_a_row <= ShenandoahFullGCThreshold;\n+  return ShenandoahHeap::heap()->shenandoah_policy()->consecutive_degenerated_gc_count() <= ShenandoahFullGCThreshold;\n@@ -223,3 +221,0 @@\n-  _degenerated_cycles_in_a_row = 0;\n-  _successful_cycles_in_a_row++;\n-\n@@ -233,3 +228,0 @@\n-  _degenerated_cycles_in_a_row++;\n-  _successful_cycles_in_a_row = 0;\n-\n@@ -240,3 +232,0 @@\n-  _degenerated_cycles_in_a_row = 0;\n-  _successful_cycles_in_a_row++;\n-\n@@ -257,2 +246,1 @@\n-  if (!ClassUnloading) return false;\n-  return true;\n+  return ClassUnloading;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -83,3 +83,0 @@\n-  uint _degenerated_cycles_in_a_row;\n-  uint _successful_cycles_in_a_row;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  _abbreviated_concurrent_gcs(0),\n@@ -35,0 +36,1 @@\n+  _abbreviated_degenerated_gcs(0),\n@@ -36,0 +38,1 @@\n+  _consecutive_degenerated_gcs(0),\n@@ -42,2 +45,1 @@\n-  _implicit_full(0),\n-  _cycle_counter(0) {\n+  _implicit_full(0) {\n@@ -48,1 +50,0 @@\n-\n@@ -78,0 +79,1 @@\n+  _consecutive_degenerated_gcs = 0;\n@@ -81,1 +83,2 @@\n-void ShenandoahCollectorPolicy::record_success_concurrent() {\n+void ShenandoahCollectorPolicy::record_success_concurrent(bool is_abbreviated) {\n+  _consecutive_degenerated_gcs = 0;\n@@ -83,0 +86,3 @@\n+  if (is_abbreviated) {\n+    _abbreviated_concurrent_gcs++;\n+  }\n@@ -85,1 +91,1 @@\n-void ShenandoahCollectorPolicy::record_success_degenerated() {\n+void ShenandoahCollectorPolicy::record_success_degenerated(bool is_abbreviated) {\n@@ -87,0 +93,4 @@\n+  _consecutive_degenerated_gcs++;\n+  if (is_abbreviated) {\n+    _abbreviated_degenerated_gcs++;\n+  }\n@@ -90,0 +100,1 @@\n+  _consecutive_degenerated_gcs = 0;\n@@ -93,8 +104,0 @@\n-size_t ShenandoahCollectorPolicy::cycle_counter() const {\n-  return _cycle_counter;\n-}\n-\n-void ShenandoahCollectorPolicy::record_cycle_start() {\n-  _cycle_counter++;\n-}\n-\n@@ -113,1 +116,2 @@\n-  out->print_cr(\"to avoid Degenerated and Full GC cycles.\");\n+  out->print_cr(\"to avoid Degenerated and Full GC cycles. Abbreviated cycles are those which found\");\n+  out->print_cr(\"enough regions with no live objects to skip evacuation.\");\n@@ -116,3 +120,6 @@\n-  out->print_cr(SIZE_FORMAT_W(5) \" successful concurrent GCs\",         _success_concurrent_gcs);\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked explicitly\",           _explicit_concurrent);\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked implicitly\",           _implicit_concurrent);\n+  size_t completed_gcs = _success_full_gcs + _success_degenerated_gcs + _success_concurrent_gcs;\n+  out->print_cr(SIZE_FORMAT_W(5) \" Completed GCs\", completed_gcs);\n+  out->print_cr(SIZE_FORMAT_W(5) \" Successful Concurrent GCs (%.2f%%)\",  _success_concurrent_gcs, percent_of(_success_concurrent_gcs, completed_gcs));\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked explicitly (%.2f%%)\",    _explicit_concurrent, percent_of(_explicit_concurrent, _success_concurrent_gcs));\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked implicitly (%.2f%%)\",    _implicit_concurrent, percent_of(_implicit_concurrent, _success_concurrent_gcs));\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" abbreviated (%.2f%%)\",           _abbreviated_concurrent_gcs, percent_of(_abbreviated_concurrent_gcs, _success_concurrent_gcs));\n@@ -121,2 +128,5 @@\n-  out->print_cr(SIZE_FORMAT_W(5) \" Degenerated GCs\",                   _success_degenerated_gcs);\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" caused by allocation failure\", _alloc_failure_degenerated);\n+  size_t degenerated_gcs = _alloc_failure_degenerated_upgrade_to_full + _success_degenerated_gcs;\n+  out->print_cr(SIZE_FORMAT_W(5) \" Degenerated GCs (%.2f%%)\", degenerated_gcs, percent_of(degenerated_gcs, completed_gcs));\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" upgraded to Full GC (%.2f%%)\",          _alloc_failure_degenerated_upgrade_to_full, percent_of(_alloc_failure_degenerated_upgrade_to_full, degenerated_gcs));\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" caused by allocation failure (%.2f%%)\", _alloc_failure_degenerated, percent_of(_alloc_failure_degenerated, degenerated_gcs));\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" abbreviated (%.2f%%)\",                  _abbreviated_degenerated_gcs, percent_of(_abbreviated_degenerated_gcs, degenerated_gcs));\n@@ -129,1 +139,0 @@\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" upgraded to Full GC\",          _alloc_failure_degenerated_upgrade_to_full);\n@@ -132,5 +141,5 @@\n-  out->print_cr(SIZE_FORMAT_W(5) \" Full GCs\",                          _success_full_gcs + _alloc_failure_degenerated_upgrade_to_full);\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked explicitly\",           _explicit_full);\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked implicitly\",           _implicit_full);\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" caused by allocation failure\", _alloc_failure_full);\n-  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" upgraded from Degenerated GC\", _alloc_failure_degenerated_upgrade_to_full);\n+  out->print_cr(SIZE_FORMAT_W(5) \" Full GCs (%.2f%%)\",                          _success_full_gcs, percent_of(_success_full_gcs, completed_gcs));\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked explicitly (%.2f%%)\",           _explicit_full, percent_of(_explicit_full, _success_full_gcs));\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" invoked implicitly (%.2f%%)\",           _implicit_full, percent_of(_implicit_full, _success_full_gcs));\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" caused by allocation failure (%.2f%%)\", _alloc_failure_full, percent_of(_alloc_failure_full, _success_full_gcs));\n+  out->print_cr(\"  \" SIZE_FORMAT_W(5) \" upgraded from Degenerated GC (%.2f%%)\", _alloc_failure_degenerated_upgrade_to_full, percent_of(_alloc_failure_degenerated_upgrade_to_full, _success_full_gcs));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.cpp","additions":34,"deletions":25,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  size_t _abbreviated_concurrent_gcs;\n@@ -43,0 +44,1 @@\n+  size_t _abbreviated_degenerated_gcs;\n@@ -45,0 +47,1 @@\n+  uint _consecutive_degenerated_gcs;\n@@ -55,1 +58,0 @@\n-\n@@ -58,1 +60,0 @@\n-  size_t _cycle_counter;\n@@ -63,6 +64,7 @@\n-  \/\/ TODO: This is different from gc_end: that one encompasses one VM operation.\n-  \/\/ These two encompass the entire cycle.\n-  void record_cycle_start();\n-\n-  void record_success_concurrent();\n-  void record_success_degenerated();\n+  \/\/ A collection cycle may be \"abbreviated\" if Shenandoah finds a sufficient percentage\n+  \/\/ of regions that contain no live objects (ShenandoahImmediateThreshold). These cycles\n+  \/\/ end after final mark, skipping the evacuation and reference-updating phases. Such\n+  \/\/ cycles are very efficient and are worth tracking. Note that both degenerated and\n+  \/\/ concurrent cycles can be abbreviated.\n+  void record_success_concurrent(bool is_abbreviated);\n+  void record_success_degenerated(bool is_abbreviated);\n@@ -83,2 +85,0 @@\n-  size_t cycle_counter() const;\n-\n@@ -90,0 +90,7 @@\n+\n+  \/\/ If the heuristics find that the number of consecutive degenerated cycles is above\n+  \/\/ ShenandoahFullGCThreshold, then they will initiate a Full GC upon an allocation\n+  \/\/ failure.\n+  inline size_t consecutive_degenerated_gc_count() const {\n+    return _consecutive_degenerated_gcs;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectorPolicy.hpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -90,1 +90,2 @@\n-  _degen_point(ShenandoahDegenPoint::_degenerated_unset) {\n+  _degen_point(ShenandoahDegenPoint::_degenerated_unset),\n+  _abbreviated(false) {\n@@ -191,0 +192,1 @@\n+    _abbreviated = true;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+  bool                      _abbreviated;\n@@ -54,0 +55,3 @@\n+  \/\/ Return true if this cycle found enough immediate garbage to skip evacuation\n+  bool abbreviated() const { return _abbreviated; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-    heap->shenandoah_policy()->record_success_concurrent();\n+    heap->shenandoah_policy()->record_success_concurrent(gc.abbreviated());\n@@ -430,4 +430,0 @@\n-\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  heap->heuristics()->record_success_full();\n-  heap->shenandoah_policy()->record_success_full();\n@@ -444,4 +440,0 @@\n-\n-  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n-  heap->heuristics()->record_success_degenerated();\n-  heap->shenandoah_policy()->record_success_degenerated();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,1 +47,2 @@\n-  _degen_point(degen_point) {\n+  _degen_point(degen_point),\n+  _abbreviated(false) {\n@@ -196,0 +197,2 @@\n+      } else {\n+        _abbreviated = true;\n@@ -233,0 +236,2 @@\n+    heap->shenandoah_policy()->record_success_degenerated(_abbreviated);\n+    heap->heuristics()->record_success_degenerated();\n@@ -346,5 +351,1 @@\n-  log_info(gc)(\"Cannot finish degeneration, upgrading to Full GC\");\n-  ShenandoahHeap::heap()->shenandoah_policy()->record_degenerated_upgrade_to_full();\n-\n-  ShenandoahFullGC full_gc;\n-  full_gc.op_full(GCCause::_shenandoah_upgrade_to_full_gc);\n+  upgrade_to_full();\n@@ -354,3 +355,1 @@\n-  ShenandoahHeap::heap()->shenandoah_policy()->record_degenerated_upgrade_to_full();\n-  ShenandoahFullGC full_gc;\n-  full_gc.op_full(GCCause::_shenandoah_upgrade_to_full_gc);\n+  upgrade_to_full();\n@@ -376,0 +375,7 @@\n+\n+void ShenandoahDegenGC::upgrade_to_full() {\n+  log_info(gc)(\"Degenerated GC upgrading to Full GC\");\n+  ShenandoahHeap::heap()->shenandoah_policy()->record_degenerated_upgrade_to_full();\n+  ShenandoahFullGC full_gc;\n+  full_gc.op_full(GCCause::_shenandoah_upgrade_to_full_gc);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+  bool _abbreviated;\n@@ -51,0 +52,1 @@\n+\n@@ -61,0 +63,3 @@\n+  \/\/ Turns this degenerated cycle into a full gc without leaving the safepoint\n+  void upgrade_to_full();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n@@ -108,0 +109,2 @@\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n@@ -111,1 +114,1 @@\n-    ShenandoahHeap::heap()->notify_gc_progress();\n+    heap->notify_gc_progress();\n@@ -115,1 +118,1 @@\n-    ShenandoahHeap::heap()->notify_gc_no_progress();\n+    heap->notify_gc_no_progress();\n@@ -117,0 +120,4 @@\n+\n+  \/\/ Regardless if progress was made, we record that we completed a \"successful\" full GC.\n+  heap->heuristics()->record_success_full();\n+  heap->shenandoah_policy()->record_success_full();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  _heap->shenandoah_policy()->record_cycle_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}