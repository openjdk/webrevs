{"files":[{"patch":"@@ -837,1 +837,1 @@\n-  address requested_base = UseCompressedOops ? (address)CompressedOops::base() : (address)ArchiveHeapWriter::NOCOOPS_REQUESTED_BASE;\n+  address requested_base = UseCompressedOops ? ArchiveHeapWriter::narrow_oop_base() : (address)ArchiveHeapWriter::NOCOOPS_REQUESTED_BASE;\n@@ -839,1 +839,1 @@\n-  int requested_shift =  CompressedOops::shift();\n+  int requested_shift = ArchiveHeapWriter::narrow_oop_shift();\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-\/\/ The following are offsets from buffer_bottom()\n+bool ArchiveHeapWriter::_is_writing_deterministic_heap = false;\n@@ -95,0 +95,44 @@\n+\n+    if (CDSConfig::old_cds_flags_used() && !CDSConfig::is_dumping_aot_linked_classes() && UseG1GC) {\n+      \/\/ In general, the contents of AOT caches (or CDS archives) are not deterministic: all\n+      \/\/ Java programs are multi-threaded (the JDK spawns internal threads), so two training runs\n+      \/\/ will collect two profiles that differ due to timing and execution order.\n+      \/\/\n+      \/\/ Therefore, we don't try to make the archived heap contents deterministic. There's only\n+      \/\/ one exception -- we want JDK builds to be reproducible, so we need to make the\n+      \/\/ lib\/server\/classes*.jsa files deterministic. Here we check for the options\n+      \/\/ that are used by make\/Images.gmk to generate these files:\n+      \/\/\n+      \/\/     * \"old\" cds flag (-Xshare:dump) is used\n+      \/\/     * -XX:+AOTClassLinking is *not* used\n+      \/\/     * -XX:+UseG1GC is used.\n+      \/\/\n+      \/\/ The logics here must match make\/Images.gmk.\n+      _is_writing_deterministic_heap = true;\n+    }\n+  }\n+}\n+\n+\/\/ For ArchiveHeapWriter::narrow_oop_{mode, base, shift}(), see comments\n+\/\/ in ArchiveHeapWriter::set_requested_address_range(),\n+CompressedOops::Mode ArchiveHeapWriter::narrow_oop_mode() {\n+  if (is_writing_deterministic_heap()) {\n+    return CompressedOops::UnscaledNarrowOop;\n+  } else {\n+    return CompressedOops::mode();\n+  }\n+}\n+\n+address ArchiveHeapWriter::narrow_oop_base() {\n+  if (is_writing_deterministic_heap()) {\n+    return (address)0;\n+  } else {\n+    return CompressedOops::base();\n+  }\n+}\n+\n+int ArchiveHeapWriter::narrow_oop_shift() {\n+  if (is_writing_deterministic_heap()) {\n+    return 0;\n+  } else {\n+    return CompressedOops::shift();\n@@ -112,1 +156,1 @@\n-  set_requested_address(heap_info);\n+  set_requested_address_range(heap_info);\n@@ -513,1 +557,25 @@\n-void ArchiveHeapWriter::set_requested_address(ArchiveHeapInfo* info) {\n+\/\/ Set the range [_requested_bottom, _requested_top), the requested address range of all\n+\/\/ the archived heap objects in the production run.\n+\/\/\n+\/\/ (1) UseCompressedOops == true && !is_writing_deterministic_heap()\n+\/\/\n+\/\/     The archived objects are stored using the COOPS encoding of the assembly phase.\n+\/\/     We pick a range within the heap used by the assembly phase.\n+\/\/\n+\/\/     In the production run, if different COOPS encodings are used:\n+\/\/         - The heap contents needs to be relocated.\n+\/\/         - AOTCodeCache will be disabled.\n+\/\/\n+\/\/ (2) UseCompressedOops == true && is_writing_deterministic_heap()\n+\/\/\n+\/\/     We always use zero-based, zero-shift encoding. _requested_top is aligned to 0x10000000.\n+\/\/\n+\/\/ (3) UseCompressedOops == false:\n+\/\/\n+\/\/     In the production run, the heap range is usually picked (randomly) by the OS, so we\n+\/\/     will almost always need to perform relocation, regardless of how we pick the requested\n+\/\/     address range.\n+\/\/\n+\/\/     So we just hard code it to NOCOOPS_REQUESTED_BASE.\n+\/\/\n+void ArchiveHeapWriter::set_requested_address_range(ArchiveHeapInfo* info) {\n@@ -521,0 +589,4 @@\n+      \/\/ For G1, pick the range at the top of the current heap. If the exact same heap sizes\n+      \/\/ are used in the production run, it's likely that we can map the archived objects\n+      \/\/ at the requested location to avoid relocation.\n+      size_t alignment = MAX2(G1HeapRegion::GrainBytes, (size_t)MIN_GC_REGION_ALIGNMENT);\n@@ -522,0 +594,8 @@\n+      if (is_writing_deterministic_heap()) {\n+        \/\/ This ensures that all requested addresses can be encoded with zero shifts. Also,\n+        \/\/ If the production run uses a small heap (e.g., -Xmx256m), it's likely that\n+        \/\/ we can map the archived objects at the requested location to avoid relocation.\n+        heap_end = (address)0x100000000;\n+      }\n+      heap_end = align_up(heap_end, alignment);\n+\n@@ -523,2 +603,5 @@\n-      _requested_bottom = align_down(heap_end - heap_region_byte_size, G1HeapRegion::GrainBytes);\n-      _requested_bottom = align_down(_requested_bottom, MIN_GC_REGION_ALIGNMENT);\n+      if (align_up(heap_region_byte_size, alignment) >= (size_t)heap_end) {\n+        log_error(aot, heap)(\"cached heap space is too large: %zu bytes\", heap_region_byte_size);\n+        AOTMetaspace::unrecoverable_writing_error();\n+      }\n+      _requested_bottom = align_down(heap_end - heap_region_byte_size, alignment);\n@@ -601,0 +684,2 @@\n+\n+    \/\/ the requested address of the referent\n@@ -602,1 +687,8 @@\n-    store_requested_oop_in_buffer<T>(field_addr_in_buffer, request_referent);\n+    if (UseCompressedOops && is_writing_deterministic_heap()) {\n+      \/\/ We use zero-based, 0-shift encoding, so the narrowOop is just the lower\n+      \/\/ 32 bits of request_referent\n+      intptr_t addr = cast_from_oop<intptr_t>(request_referent);\n+      *((narrowOop*)field_addr_in_buffer) = checked_cast<narrowOop>(addr);\n+    } else {\n+      store_requested_oop_in_buffer<T>(field_addr_in_buffer, request_referent);\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":98,"deletions":6,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/compressedOops.hpp\"\n@@ -90,1 +91,2 @@\n-  \/\/ The requested address is implemented differently depending on UseCompressedOops:\n+  \/\/ The requested address of an archived object is essentially its buffered_addr + delta,\n+  \/\/ where delta is (_requested_bottom - buffer_bottom());\n@@ -92,18 +94,2 @@\n-  \/\/ UseCompressedOops == true:\n-  \/\/   The archived objects are stored assuming that the runtime COOPS compression\n-  \/\/   scheme is exactly the same as in dump time (or else a more expensive runtime relocation\n-  \/\/   would be needed.)\n-  \/\/\n-  \/\/   At dump time, we assume that the runtime heap range is exactly the same as\n-  \/\/   in dump time. The requested addresses of the archived objects are chosen such that\n-  \/\/   they would occupy the top end of a G1 heap (TBD when dumping is supported by other\n-  \/\/   collectors. See JDK-8298614).\n-  \/\/\n-  \/\/ UseCompressedOops == false:\n-  \/\/   At runtime, the heap range is usually picked (randomly) by the OS, so we will almost always\n-  \/\/   need to perform relocation. Hence, the goal of the \"requested address\" is to ensure that\n-  \/\/   the contents of the archived objects are deterministic. I.e., the oop fields of archived\n-  \/\/   objects will always point to deterministic addresses.\n-  \/\/\n-  \/\/   For G1, the archived heap is written such that the lowest archived object is placed\n-  \/\/   at NOCOOPS_REQUESTED_BASE. (TBD after JDK-8298614).\n+  \/\/ The requested addresses of all archived objects are within [_requested_bottom, _requested_top).\n+  \/\/ See ArchiveHeapWriter::set_requested_address_range() for more info.\n@@ -120,0 +106,9 @@\n+  \/\/ The heap contents are required to be deterministic when dumping \"old\" CDS archives, in order\n+  \/\/ to support reproducible lib\/server\/classes*.jsa when building the JDK.\n+  static bool is_writing_deterministic_heap() { return _is_writing_deterministic_heap; }\n+\n+  \/\/ The oop encoding used by the archived heap objects.\n+  static CompressedOops::Mode narrow_oop_mode();\n+  static address narrow_oop_base();\n+  static int narrow_oop_shift();\n+\n@@ -127,0 +122,1 @@\n+  static bool _is_writing_deterministic_heap;\n@@ -136,2 +132,2 @@\n-  static address _requested_bottom;\n-  static address _requested_top;\n+  static address _requested_bottom; \/\/ The requested address of the lowest archived heap object\n+  static address _requested_top;    \/\/ The exclusive end of the highest archived heap object\n@@ -205,1 +201,1 @@\n-  static void set_requested_address(ArchiveHeapInfo* info);\n+  static void set_requested_address_range(ArchiveHeapInfo* info);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -220,3 +220,3 @@\n-    _narrow_oop_mode = CompressedOops::mode();\n-    _narrow_oop_base = CompressedOops::base();\n-    _narrow_oop_shift = CompressedOops::shift();\n+    _narrow_oop_mode = ArchiveHeapWriter::narrow_oop_mode();\n+    _narrow_oop_base = ArchiveHeapWriter::narrow_oop_base();\n+    _narrow_oop_shift = ArchiveHeapWriter::narrow_oop_shift();\n@@ -901,1 +901,1 @@\n-      mapping_offset = (size_t)((address)requested_base - CompressedOops::base());\n+      mapping_offset = (size_t)((address)requested_base - ArchiveHeapWriter::narrow_oop_base());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-runtime\/cds\/DeterministicDump.java 8363986 macosx-x64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}