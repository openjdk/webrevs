{"files":[{"patch":"@@ -42,1 +42,1 @@\n-\/\/ ArchiveHeapWriter uses [2] to create an image of the archived heap.\n+\/\/ HeapShared uses [2] to create an image of the archived heap.\n","filename":"src\/hotspot\/share\/cds\/aotArtifactFinder.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -799,1 +799,1 @@\n-  address requested_base = UseCompressedOops ? (address)CompressedOops::base() : (address)AOTMappedHeapWriter::NOCOOPS_REQUESTED_BASE;\n+  address requested_base = UseCompressedOops ? AOTMappedHeapWriter::narrow_oop_base() : (address)AOTMappedHeapWriter::NOCOOPS_REQUESTED_BASE;\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-\/\/ The following are offsets from buffer_bottom()\n+bool AOTMappedHeapWriter::_is_writing_deterministic_heap = false;\n@@ -77,1 +77,1 @@\n-      size_t,    \/\/ offset of a filler from ArchiveHeapWriter::buffer_bottom()\n+      size_t,    \/\/ offset of a filler from AOTMappedHeapWriter::buffer_bottom()\n@@ -99,0 +99,39 @@\n+\n+    if (CDSConfig::old_cds_flags_used()) {\n+      \/\/ With the old CDS workflow, we can guatantee determninistic output: given\n+      \/\/ the same classlist file, we can generate the same static CDS archive.\n+      \/\/ To ensure determinism, we always use the same compressed oop encoding\n+      \/\/ (zero-based, no shift). See set_requested_address_range().\n+      _is_writing_deterministic_heap = true;\n+    } else {\n+      \/\/ Determninistic output is not supported by the new AOT workflow, so\n+      \/\/ we don't force the (zero-based, no shift) encoding. This way, it is more\n+      \/\/ likely that we can avoid oop relocation in the production run.\n+      _is_writing_deterministic_heap = false;\n+    }\n+  }\n+}\n+\n+\/\/ For AOTMappedHeapWriter::narrow_oop_{mode, base, shift}(), see comments\n+\/\/ in AOTMappedHeapWriter::set_requested_address_range(),\n+CompressedOops::Mode AOTMappedHeapWriter::narrow_oop_mode() {\n+  if (is_writing_deterministic_heap()) {\n+    return CompressedOops::UnscaledNarrowOop;\n+  } else {\n+    return CompressedOops::mode();\n+  }\n+}\n+\n+address AOTMappedHeapWriter::narrow_oop_base() {\n+  if (is_writing_deterministic_heap()) {\n+    return (address)0;\n+  } else {\n+    return CompressedOops::base();\n+  }\n+}\n+\n+int AOTMappedHeapWriter::narrow_oop_shift() {\n+  if (is_writing_deterministic_heap()) {\n+    return 0;\n+  } else {\n+    return CompressedOops::shift();\n@@ -119,1 +158,1 @@\n-  set_requested_address(heap_info);\n+  set_requested_address_range(heap_info);\n@@ -539,1 +578,24 @@\n-void AOTMappedHeapWriter::set_requested_address(ArchiveMappedHeapInfo* info) {\n+\/\/ Set the range [_requested_bottom, _requested_top), the requested address range of all\n+\/\/ the archived heap objects in the production run.\n+\/\/\n+\/\/ (1) UseCompressedOops == true && !is_writing_deterministic_heap()\n+\/\/\n+\/\/     The archived objects are stored using the COOPS encoding of the assembly phase.\n+\/\/     We pick a range within the heap used by the assembly phase.\n+\/\/\n+\/\/     In the production run, if different COOPS encodings are used:\n+\/\/         - The heap contents needs to be relocated.\n+\/\/\n+\/\/ (2) UseCompressedOops == true && is_writing_deterministic_heap()\n+\/\/\n+\/\/     We always use zero-based, zero-shift encoding. _requested_top is aligned to 0x10000000.\n+\/\/\n+\/\/ (3) UseCompressedOops == false:\n+\/\/\n+\/\/     In the production run, the heap range is usually picked (randomly) by the OS, so we\n+\/\/     will almost always need to perform relocation, regardless of how we pick the requested\n+\/\/     address range.\n+\/\/\n+\/\/     So we just hard code it to NOCOOPS_REQUESTED_BASE.\n+\/\/\n+void AOTMappedHeapWriter::set_requested_address_range(ArchiveMappedHeapInfo* info) {\n@@ -546,1 +608,19 @@\n-    if (UseG1GC) {\n+    if (is_writing_deterministic_heap()) {\n+      \/\/ Pick a heap range so that requested addresses can be encoded with zero-base\/no shift.\n+      \/\/ We align the requested bottom to at least 1 MB: if the production run uses G1 with a small\n+      \/\/ heap (e.g., -Xmx256m), it's likely that we can map the archived objects at the\n+      \/\/ requested location to avoid relocation.\n+      \/\/\n+      \/\/ For other collectors or larger heaps, relocation is unavoidable, but is usually\n+      \/\/ quite cheap. If you really want to avoid relocation, use the AOT workflow instead.\n+      address heap_end = (address)0x100000000;\n+      size_t alignment = MAX2(MIN_GC_REGION_ALIGNMENT, 1024 * 1024);\n+      if (align_up(heap_region_byte_size, alignment) >= (size_t)heap_end) {\n+        log_error(aot, heap)(\"cached heap space is too large: %zu bytes\", heap_region_byte_size);\n+        AOTMetaspace::unrecoverable_writing_error();\n+      }\n+      _requested_bottom = align_down(heap_end - heap_region_byte_size, alignment);\n+    } else if (UseG1GC) {\n+      \/\/ For G1, pick the range at the top of the current heap. If the exact same heap sizes\n+      \/\/ are used in the production run, it's likely that we can map the archived objects\n+      \/\/ at the requested location to avoid relocation.\n@@ -615,1 +695,8 @@\n-  store_requested_oop_in_buffer<T>(field_addr_in_buffer, request_referent);\n+  if (UseCompressedOops && is_writing_deterministic_heap()) {\n+    \/\/ We use zero-based, 0-shift encoding, so the narrowOop is just the lower\n+    \/\/ 32 bits of request_referent\n+    intptr_t addr = cast_from_oop<intptr_t>(request_referent);\n+    *((narrowOop*)field_addr_in_buffer) = checked_cast<narrowOop>(addr);\n+  } else {\n+    store_requested_oop_in_buffer<T>(field_addr_in_buffer, request_referent);\n+  }\n@@ -921,3 +1008,3 @@\n-  address requested_base = UseCompressedOops ? (address)CompressedOops::base() : (address)AOTMappedHeapWriter::NOCOOPS_REQUESTED_BASE;\n-  address requested_start = UseCompressedOops ? buffered_addr_to_requested_addr(buffer_start) : requested_base;\n-  int requested_shift =  CompressedOops::shift();\n+  address requested_base = UseCompressedOops ? AOTMappedHeapWriter::narrow_oop_base() : (address)AOTMappedHeapWriter::NOCOOPS_REQUESTED_BASE;\n+  address requested_start = UseCompressedOops ? AOTMappedHeapWriter::buffered_addr_to_requested_addr(buffer_start) : requested_base;\n+  int requested_shift = AOTMappedHeapWriter::narrow_oop_shift();\n","filename":"src\/hotspot\/share\/cds\/aotMappedHeapWriter.cpp","additions":96,"deletions":9,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/compressedOops.hpp\"\n@@ -74,1 +75,1 @@\n-  \/\/   ArchiveHeapWriter::_buffer, which is a GrowableArray that sits outside of\n+  \/\/   AOTMappedHeapWriter::_buffer, which is a GrowableArray that sits outside of\n@@ -84,1 +85,2 @@\n-  \/\/ The requested address is implemented differently depending on UseCompressedOops:\n+  \/\/ The requested address of an archived object is essentially its buffered_addr + delta,\n+  \/\/ where delta is (_requested_bottom - buffer_bottom());\n@@ -86,18 +88,2 @@\n-  \/\/ UseCompressedOops == true:\n-  \/\/   The archived objects are stored assuming that the runtime COOPS compression\n-  \/\/   scheme is exactly the same as in dump time (or else a more expensive runtime relocation\n-  \/\/   would be needed.)\n-  \/\/\n-  \/\/   At dump time, we assume that the runtime heap range is exactly the same as\n-  \/\/   in dump time. The requested addresses of the archived objects are chosen such that\n-  \/\/   they would occupy the top end of a G1 heap (TBD when dumping is supported by other\n-  \/\/   collectors. See JDK-8298614).\n-  \/\/\n-  \/\/ UseCompressedOops == false:\n-  \/\/   At runtime, the heap range is usually picked (randomly) by the OS, so we will almost always\n-  \/\/   need to perform relocation. Hence, the goal of the \"requested address\" is to ensure that\n-  \/\/   the contents of the archived objects are deterministic. I.e., the oop fields of archived\n-  \/\/   objects will always point to deterministic addresses.\n-  \/\/\n-  \/\/   For G1, the archived heap is written such that the lowest archived object is placed\n-  \/\/   at NOCOOPS_REQUESTED_BASE. (TBD after JDK-8298614).\n+  \/\/ The requested addresses of all archived objects are within [_requested_bottom, _requested_top).\n+  \/\/ See AOTMappedHeapWriter::set_requested_address_range() for more info.\n@@ -114,0 +100,9 @@\n+  \/\/ The heap contents are required to be deterministic when dumping \"old\" CDS archives, in order\n+  \/\/ to support reproducible lib\/server\/classes*.jsa when building the JDK.\n+  static bool is_writing_deterministic_heap() { return _is_writing_deterministic_heap; }\n+\n+  \/\/ The oop encoding used by the archived heap objects.\n+  static CompressedOops::Mode narrow_oop_mode();\n+  static address narrow_oop_base();\n+  static int narrow_oop_shift();\n+\n@@ -124,0 +119,1 @@\n+  static bool _is_writing_deterministic_heap;\n@@ -133,2 +129,2 @@\n-  static address _requested_bottom;\n-  static address _requested_top;\n+  static address _requested_bottom; \/\/ The requested address of the lowest archived heap object\n+  static address _requested_top;    \/\/ The exclusive end of the highest archived heap object\n@@ -141,1 +137,1 @@\n-  \/\/ See comments near the body of ArchiveHeapWriter::compare_objs_by_oop_fields().\n+  \/\/ See comments near the body of AOTMappedHeapWriter::compare_objs_by_oop_fields().\n@@ -203,1 +199,1 @@\n-  static void set_requested_address(ArchiveMappedHeapInfo* info);\n+  static void set_requested_address_range(ArchiveMappedHeapInfo* info);\n","filename":"src\/hotspot\/share\/cds\/aotMappedHeapWriter.hpp","additions":20,"deletions":24,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -221,3 +221,3 @@\n-    _narrow_oop_mode = CompressedOops::mode();\n-    _narrow_oop_base = CompressedOops::base();\n-    _narrow_oop_shift = CompressedOops::shift();\n+    _narrow_oop_mode = AOTMappedHeapWriter::narrow_oop_mode();\n+    _narrow_oop_base = AOTMappedHeapWriter::narrow_oop_base();\n+    _narrow_oop_shift = AOTMappedHeapWriter::narrow_oop_shift();\n@@ -914,1 +914,1 @@\n-        mapping_offset = (size_t)((address)requested_base - CompressedOops::base());\n+        mapping_offset = (size_t)((address)requested_base - AOTMappedHeapWriter::narrow_oop_base());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-    \/\/ The location of this object inside ArchiveHeapWriter::_buffer\n+    \/\/ The location of this object inside {AOTMappedHeapWriter, AOTStreamedHeapWriter}::_buffer\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-runtime\/cds\/DeterministicDump.java 8363986 macosx-x64,macosx-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}