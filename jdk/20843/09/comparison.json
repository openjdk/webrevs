{"files":[{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotClassLinker.hpp\"\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n+#include \"cds\/aotLinkedClassTable.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.inline.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"cds\/lambdaFormInvokers.inline.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/dictionary.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/constantPool.inline.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+\n+AOTClassLinker::ClassesTable* AOTClassLinker::_vm_classes = nullptr;\n+AOTClassLinker::ClassesTable* AOTClassLinker::_candidates = nullptr;\n+GrowableArrayCHeap<InstanceKlass*, mtClassShared>* AOTClassLinker::_sorted_candidates = nullptr;\n+\n+#ifdef ASSERT\n+bool AOTClassLinker::is_initialized() {\n+  assert(CDSConfig::is_dumping_archive(), \"AOTClassLinker is for CDS dumping only\");\n+  return _vm_classes != nullptr;\n+}\n+#endif\n+\n+void AOTClassLinker::initialize() {\n+  assert(!is_initialized(), \"sanity\");\n+\n+  _vm_classes = new (mtClass)ClassesTable();\n+  _candidates = new (mtClass)ClassesTable();\n+  _sorted_candidates = new GrowableArrayCHeap<InstanceKlass*, mtClassShared>(1000);\n+\n+  for (auto id : EnumRange<vmClassID>{}) {\n+    add_vm_class(vmClasses::klass_at(id));\n+  }\n+\n+  assert(is_initialized(), \"sanity\");\n+\n+  AOTConstantPoolResolver::initialize();\n+}\n+\n+void AOTClassLinker::dispose() {\n+  assert(is_initialized(), \"sanity\");\n+\n+  delete _vm_classes;\n+  delete _candidates;\n+  delete _sorted_candidates;\n+  _vm_classes = nullptr;\n+  _candidates = nullptr;\n+  _sorted_candidates = nullptr;\n+\n+  assert(!is_initialized(), \"sanity\");\n+\n+  AOTConstantPoolResolver::dispose();\n+}\n+\n+bool AOTClassLinker::is_vm_class(InstanceKlass* ik) {\n+  assert(is_initialized(), \"sanity\");\n+  return (_vm_classes->get(ik) != nullptr);\n+}\n+\n+void AOTClassLinker::add_vm_class(InstanceKlass* ik) {\n+  assert(is_initialized(), \"sanity\");\n+  bool created;\n+  _vm_classes->put_if_absent(ik, &created);\n+  if (created) {\n+    add_candidate(ik);\n+    InstanceKlass* super = ik->java_super();\n+    if (super != nullptr) {\n+      add_vm_class(super);\n+    }\n+    Array<InstanceKlass*>* ifs = ik->local_interfaces();\n+    for (int i = 0; i < ifs->length(); i++) {\n+      add_vm_class(ifs->at(i));\n+    }\n+  }\n+}\n+\n+bool AOTClassLinker::is_candidate(InstanceKlass* ik) {\n+  return (_candidates->get(ik) != nullptr);\n+}\n+\n+void AOTClassLinker::add_candidate(InstanceKlass* ik) {\n+  _candidates->put_when_absent(ik, true);\n+  _sorted_candidates->append(ik);\n+}\n+\n+bool AOTClassLinker::try_add_candidate(InstanceKlass* ik) {\n+  assert(is_initialized(), \"sanity\");\n+  assert(CDSConfig::is_dumping_aot_linked_classes(), \"sanity\");\n+\n+  if (!SystemDictionaryShared::is_builtin(ik)) {\n+    return false;\n+  }\n+\n+  if (is_candidate(ik)) { \/\/ already checked.\n+    return true;\n+  }\n+\n+  if (ik->is_hidden()) {\n+    return false;\n+  }\n+\n+  InstanceKlass* s = ik->java_super();\n+  if (s != nullptr && !try_add_candidate(s)) {\n+    return false;\n+  }\n+\n+  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+  int num_interfaces = interfaces->length();\n+  for (int index = 0; index < num_interfaces; index++) {\n+    InstanceKlass* intf = interfaces->at(index);\n+    if (!try_add_candidate(intf)) {\n+      return false;\n+    }\n+  }\n+\n+  add_candidate(ik);\n+\n+  if (log_is_enabled(Info, cds, aot, link)) {\n+    ResourceMark rm;\n+    log_info(cds, aot, link)(\"%s %s\", class_category_name(ik), ik->external_name());\n+  }\n+\n+  return true;\n+}\n+\n+void AOTClassLinker::add_candidates() {\n+  assert_at_safepoint();\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+    for (GrowableArrayIterator<Klass*> it = klasses->begin(); it != klasses->end(); ++it) {\n+      Klass* k = *it;\n+      if (k->is_instance_klass()) {\n+        try_add_candidate(InstanceKlass::cast(k));\n+      }\n+    }\n+  }\n+}\n+\n+void AOTClassLinker::write_to_archive() {\n+  assert(is_initialized(), \"sanity\");\n+  assert_at_safepoint();\n+\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    AOTLinkedClassTable* table = AOTLinkedClassTable::get(CDSConfig::is_dumping_static_archive());\n+    table->set_boot(write_classes(nullptr, true));\n+    table->set_boot2(write_classes(nullptr, false));\n+    table->set_platform(write_classes(SystemDictionary::java_platform_loader(), false));\n+    table->set_app(write_classes(SystemDictionary::java_system_loader(), false));\n+  }\n+}\n+\n+Array<InstanceKlass*>* AOTClassLinker::write_classes(oop class_loader, bool is_javabase) {\n+  ResourceMark rm;\n+  GrowableArray<InstanceKlass*> list;\n+\n+  for (int i = 0; i < _sorted_candidates->length(); i++) {\n+    InstanceKlass* ik = _sorted_candidates->at(i);\n+    if (ik->class_loader() != class_loader) {\n+      continue;\n+    }\n+    if ((ik->module() == ModuleEntryTable::javabase_moduleEntry()) != is_javabase) {\n+      continue;\n+    }\n+\n+    if (ik->is_shared() && CDSConfig::is_dumping_dynamic_archive()) {\n+      if (CDSConfig::is_using_aot_linked_classes()) {\n+        \/\/ This class was recorded as AOT-linked for the base archive,\n+        \/\/ so there's no need to do so again for the dynamic archive.\n+      } else {\n+        list.append(ik);\n+      }\n+    } else {\n+      list.append(ArchiveBuilder::current()->get_buffered_addr(ik));\n+    }\n+  }\n+\n+  if (list.length() == 0) {\n+    return nullptr;\n+  } else {\n+    const char* category = class_category_name(list.at(0));\n+    log_info(cds, aot, link)(\"written %d class(es) for category %s\", list.length(), category);\n+    return ArchiveUtils::archive_array(&list);\n+  }\n+}\n+\n+int AOTClassLinker::num_platform_initiated_classes() {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ AOTLinkedClassBulkLoader will initiate loading of all public boot classes in the platform loader.\n+    return count_public_classes(nullptr);\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+int AOTClassLinker::num_app_initiated_classes() {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ AOTLinkedClassBulkLoader will initiate loading of all public boot\/platform classes in the app loader.\n+    return count_public_classes(nullptr) + count_public_classes(SystemDictionary::java_platform_loader());\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+int AOTClassLinker::count_public_classes(oop loader) {\n+  int n = 0;\n+  for (int i = 0; i < _sorted_candidates->length(); i++) {\n+    InstanceKlass* ik = _sorted_candidates->at(i);\n+    if (ik->is_public() && !ik->is_hidden() && ik->class_loader() == loader) {\n+      n++;\n+    }\n+  }\n+\n+  return n;\n+}\n+\n+\/\/ Used in logging: \"boot1\", \"boot2\", \"plat\", \"app\" and \"unreg\", or \"array\"\n+const char* AOTClassLinker::class_category_name(Klass* k) {\n+  if (ArchiveBuilder::is_active() && ArchiveBuilder::current()->is_in_buffer_space(k)) {\n+    k = ArchiveBuilder::current()->get_source_addr(k);\n+  }\n+\n+  if (k->is_array_klass()) {\n+    return \"array\";\n+  } else {\n+    oop loader = k->class_loader();\n+    if (loader == nullptr) {\n+      if (k->module() != nullptr &&\n+          k->module()->name() != nullptr &&\n+          k->module()->name()->equals(\"java.base\")) {\n+        return \"boot1\"; \/\/ boot classes in java.base are loaded in the 1st phase\n+      } else {\n+        return \"boot2\"; \/\/ boot classes outside of java.base are loaded in the 2nd phase phase\n+      }\n+    } else {\n+      if (loader == SystemDictionary::java_platform_loader()) {\n+        return \"plat\";\n+      } else if (loader == SystemDictionary::java_system_loader()) {\n+        return \"app\";\n+      } else {\n+        return \"unreg\";\n+      }\n+    }\n+  }\n+}\n+\n+const char* AOTClassLinker::class_category_name(AOTLinkedClassCategory category) {\n+  switch (category) {\n+  case AOTLinkedClassCategory::BOOT1:\n+    return \"boot1\";\n+  case AOTLinkedClassCategory::BOOT2:\n+    return \"boot2\";\n+  case AOTLinkedClassCategory::PLATFORM:\n+    return \"plat\";\n+  case AOTLinkedClassCategory::APP:\n+    return \"app\";\n+  case AOTLinkedClassCategory::UNREGISTERED:\n+  default:\n+      return \"unreg\";\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTCLASSLINKER_HPP\n+#define SHARE_CDS_AOTCLASSLINKER_HPP\n+\n+#include \"interpreter\/bytecodes.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class AOTLinkedClassTable;\n+class InstanceKlass;\n+class SerializeClosure;\n+template <typename T> class Array;\n+enum class AOTLinkedClassCategory : int;\n+\n+\/\/ AOTClassLinker is used during the AOTCache Assembly Phase.\n+\/\/ It links eligible classes before they are written into the AOTCache\n+\/\/\n+\/\/ The classes linked by AOTClassLinker are recorded in an AOTLinkedClassTable,\n+\/\/ which is also written into the AOTCache.\n+\/\/\n+\/\/ AOTClassLinker is enabled by the -XX:+AOTClassLinking option. If this option\n+\/\/ is disabled, an empty AOTLinkedClassTable will be included in the AOTCache.\n+\/\/\n+\/\/ For each class C in the AOTLinkedClassTable, the following properties for C\n+\/\/ are assigned by AOTClassLinker and cannot be changed thereafter.\n+\/\/     - The CodeSource for C\n+\/\/     - The bytecodes in C\n+\/\/     - The supertypes of C\n+\/\/     - The ClassLoader, Package and Module of C\n+\/\/     - The visibility of C\n+\/\/\n+\/\/ During an Production Run, the JVM can use an AOTCache with an AOTLinkedClassTable\n+\/\/ only if it's guaranteed to produce the same results for the above set of properties\n+\/\/ for each class C in the AOTLinkedClassTable.\n+\/\/\n+\/\/ For example,\n+\/\/     - C may be loaded from a different CodeSource when the CLASSPATH is changed.\n+\/\/     - Some JVMTI agent may allow the bytecodes of C to be modified.\n+\/\/     - C may be made invisible by module options such as --add-modules\n+\/\/ In such situations, the JVM will refuse to load the AOTCache.\n+\/\/\n+class AOTClassLinker :  AllStatic {\n+  static const int TABLE_SIZE = 15889; \/\/ prime number\n+  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n+\n+  \/\/ Classes loaded inside vmClasses::resolve_all()\n+  static ClassesTable* _vm_classes;\n+\n+  \/\/ Classes that should be automatically loaded into system dictionary at VM start-up\n+  static ClassesTable* _candidates;\n+\n+  \/\/ Sorted list such that super types come first.\n+  static GrowableArrayCHeap<InstanceKlass*, mtClassShared>* _sorted_candidates;\n+\n+  DEBUG_ONLY(static bool is_initialized());\n+\n+  static void add_vm_class(InstanceKlass* ik);\n+  static void add_candidate(InstanceKlass* ik);\n+\n+  static Array<InstanceKlass*>* write_classes(oop class_loader, bool is_javabase);\n+  static int count_public_classes(oop loader);\n+\n+public:\n+  static void initialize();\n+  static void add_candidates();\n+  static void write_to_archive();\n+  static void dispose();\n+\n+  \/\/ Is this class resolved as part of vmClasses::resolve_all()?\n+  static bool is_vm_class(InstanceKlass* ik);\n+\n+  \/\/ When CDS is enabled, is ik guatanteed to be linked at deployment time (and\n+  \/\/ cannot be replaced by JVMTI, etc)?\n+  \/\/ This is a necessary (but not sufficient) condition for keeping a direct pointer\n+  \/\/ to ik in AOT-computed data (such as ConstantPool entries in archived classes,\n+  \/\/ or in AOT-compiled code).\n+  static bool is_candidate(InstanceKlass* ik);\n+\n+  \/\/ Request that ik be added to the candidates table. This will return true only if\n+  \/\/ ik is allowed to be aot-linked.\n+  static bool try_add_candidate(InstanceKlass* ik);\n+\n+  static int num_app_initiated_classes();\n+  static int num_platform_initiated_classes();\n+\n+  \/\/ Used in logging: \"boot1\", \"boot2\", \"plat\", \"app\" and \"unreg\";\n+  static const char* class_category_name(AOTLinkedClassCategory category);\n+  static const char* class_category_name(Klass* k);\n+};\n+\n+\/\/ AOT-linked classes are divided into different categories and are loaded\n+\/\/ in two phases during the production run.\n+enum class AOTLinkedClassCategory : int {\n+  BOOT1,       \/\/ Only java.base classes are loaded in the 1st phase\n+  BOOT2,       \/\/ All boots classes that not in java.base are loaded in the 2nd phase\n+  PLATFORM,\n+  APP,    \n+  UNREGISTERED \/\/ classes loaded outside of the boot\/platform\/app loaders; currently not supported by AOTClassLinker\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTCLASSLINKER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.hpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassLinker.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"cds\/regeneratedClasses.hpp\"\n@@ -42,20 +42,0 @@\n-AOTConstantPoolResolver::ClassesTable* AOTConstantPoolResolver::_vm_classes = nullptr;\n-\n-bool AOTConstantPoolResolver::is_vm_class(InstanceKlass* ik) {\n-  return (_vm_classes->get(ik) != nullptr);\n-}\n-\n-void AOTConstantPoolResolver::add_one_vm_class(InstanceKlass* ik) {\n-  bool created;\n-  _vm_classes->put_if_absent(ik, &created);\n-  if (created) {\n-    InstanceKlass* super = ik->java_super();\n-    if (super != nullptr) {\n-      add_one_vm_class(super);\n-    }\n-    Array<InstanceKlass*>* ifs = ik->local_interfaces();\n-    for (int i = 0; i < ifs->length(); i++) {\n-      add_one_vm_class(ifs->at(i));\n-    }\n-  }\n-}\n@@ -64,2 +44,1 @@\n-  assert(_vm_classes == nullptr, \"must be\");\n-  _vm_classes = new (mtClass)ClassesTable();\n+  assert(_processed_classes == nullptr, \"must be\");\n@@ -67,3 +46,0 @@\n-  for (auto id : EnumRange<vmClassID>{}) {\n-    add_one_vm_class(vmClasses::klass_at(id));\n-  }\n@@ -73,2 +49,1 @@\n-  assert(_vm_classes != nullptr, \"must be\");\n-  delete _vm_classes;\n+  assert(_processed_classes != nullptr, \"must be\");\n@@ -76,1 +51,0 @@\n-  _vm_classes = nullptr;\n@@ -136,1 +110,7 @@\n-    if (is_vm_class(ik)) {\n+    if (CDSConfig::is_dumping_aot_linked_classes()) {\n+      if (AOTClassLinker::is_candidate(ik)) {\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    } else if (AOTClassLinker::is_vm_class(ik)) {\n@@ -145,0 +125,2 @@\n+    } else {\n+      return false;\n@@ -152,0 +134,2 @@\n+    } else {\n+      return false;\n@@ -155,0 +139,2 @@\n+  } else {\n+    return false;\n@@ -156,2 +142,0 @@\n-\n-  return false;\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":16,"deletions":32,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, 15889, AnyObj::C_HEAP, mtClassShared> ;\n+  static const int TABLE_SIZE = 15889; \/\/ prime number\n+  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared> ;\n@@ -57,3 +58,0 @@\n-  static ClassesTable* _vm_classes;\n-\n-  static void add_one_vm_class(InstanceKlass* ik);\n@@ -62,0 +60,3 @@\n+  template <typename T> static bool is_in_archivebuilder_buffer(T p) {\n+    return is_in_archivebuilder_buffer((address)(p));\n+  }\n@@ -65,4 +66,0 @@\n-  template <typename T>\n-  static bool is_in_archivebuilder_buffer(T p) {\n-    return is_in_archivebuilder_buffer((address)(p));\n-  }\n@@ -85,5 +82,0 @@\n-  \/\/ Is this class resolved as part of vmClasses::resolve_all()? If so, these\n-  \/\/ classes are guatanteed to be loaded at runtime (and cannot be replaced by JVMTI)\n-  \/\/ when CDS is enabled. Therefore, we can safely keep a direct reference to these\n-  \/\/ classes.\n-  static bool is_vm_class(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotClassLinker.hpp\"\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n+#include \"cds\/aotLinkedClassTable.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+\n+void AOTLinkedClassBulkLoader::serialize(SerializeClosure* soc, bool is_static_archive) {\n+  AOTLinkedClassTable::get(is_static_archive)->serialize(soc);\n+}\n+\n+void AOTLinkedClassBulkLoader::load_javabase_classes(JavaThread* current) {\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"sanity\");\n+  load_classes_in_loader(current, AOTLinkedClassCategory::BOOT1, nullptr); \/\/ only java.base classes\n+}\n+\n+void AOTLinkedClassBulkLoader::load_non_javabase_classes(JavaThread* current) {\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"sanity\");\n+\n+  \/\/ is_using_aot_linked_classes() requires is_using_full_module_graph(). As a result,\n+  \/\/ the platform\/system class loader should already have been initialized as part\n+  \/\/ of the FMG support.\n+  assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n+  assert(SystemDictionary::java_platform_loader() != nullptr, \"must be\");\n+  assert(SystemDictionary::java_system_loader() != nullptr,   \"must be\");\n+\n+  load_classes_in_loader(current, AOTLinkedClassCategory::BOOT2, nullptr); \/\/ all boot classes outside of java.base\n+  load_classes_in_loader(current, AOTLinkedClassCategory::PLATFORM, SystemDictionary::java_platform_loader());\n+  load_classes_in_loader(current, AOTLinkedClassCategory::APP, SystemDictionary::java_system_loader());\n+}\n+\n+void AOTLinkedClassBulkLoader::load_classes_in_loader(JavaThread* current, AOTLinkedClassCategory class_category, oop class_loader_oop) {\n+  ExceptionMark em(current);\n+  ResourceMark rm(current);\n+  HandleMark hm(current);\n+\n+  load_classes_in_loader_impl(class_category, class_loader_oop, current);\n+  if (current->has_pending_exception()) {\n+    \/\/ We cannot continue, as we might have loaded some of the aot-linked classes, which\n+    \/\/ may have dangling C++ pointers to other aot-linked classes that we have failed to load.\n+    if (current->pending_exception()->is_a(vmClasses::OutOfMemoryError_klass())) {\n+      log_error(cds)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n+                     SIZE_FORMAT \"M\", MaxHeapSize\/M);\n+    } else {\n+      log_error(cds)(\"%s: %s\", current->pending_exception()->klass()->external_name(),\n+                     java_lang_String::as_utf8_string(java_lang_Throwable::message(current->pending_exception())));\n+    }\n+    vm_exit_during_initialization(\"Unexpected exception when loading aot-linked classes.\");\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::load_classes_in_loader_impl(AOTLinkedClassCategory class_category, oop class_loader_oop, TRAPS) {\n+  if (!CDSConfig::is_using_aot_linked_classes()) {\n+    return;\n+  }\n+\n+  Handle h_loader(THREAD, class_loader_oop);\n+  load_table(AOTLinkedClassTable::for_static_archive(),  class_category, h_loader, CHECK);\n+  load_table(AOTLinkedClassTable::for_dynamic_archive(), class_category, h_loader, CHECK);\n+\n+  if (Universe::is_fully_initialized() && VerifyDuringStartup) {\n+    \/\/ Make sure we're still in a clean slate.\n+    VM_Verify verify_op;\n+    VMThread::execute(&verify_op);\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::load_table(AOTLinkedClassTable* table, AOTLinkedClassCategory class_category, Handle loader, TRAPS) {\n+  if (class_category != AOTLinkedClassCategory::BOOT1) {\n+    assert(Universe::is_module_initialized(), \"sanity\");\n+  }\n+\n+  const char* category_name = AOTClassLinker::class_category_name(class_category);\n+  switch (class_category) {\n+  case AOTLinkedClassCategory::BOOT1:\n+    load_classes_impl(class_category, table->boot(), category_name, loader, CHECK);\n+    break;\n+\n+  case AOTLinkedClassCategory::BOOT2:\n+    load_classes_impl(class_category, table->boot2(), category_name, loader, CHECK);\n+    break;\n+\n+  case AOTLinkedClassCategory::PLATFORM:\n+    {\n+      initiate_loading(THREAD, category_name, loader, table->boot());\n+      initiate_loading(THREAD, category_name, loader, table->boot2());\n+      load_classes_impl(class_category, table->platform(), category_name, loader, CHECK);\n+    }\n+    break;\n+  case AOTLinkedClassCategory::APP:\n+    {\n+      initiate_loading(THREAD, category_name, loader, table->boot());\n+      initiate_loading(THREAD, category_name, loader, table->boot2());\n+      initiate_loading(THREAD, category_name, loader, table->platform());\n+      load_classes_impl(class_category, table->app(), category_name, loader, CHECK);\n+    }\n+    break;\n+  case AOTLinkedClassCategory::UNREGISTERED:\n+    ShouldNotReachHere(); \/\/ Currently aot-linked classes are not supported for this category.\n+    break;\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::load_classes_impl(AOTLinkedClassCategory class_category, Array<InstanceKlass*>* classes,\n+                                                 const char* category_name, Handle loader, TRAPS) {\n+  if (classes == nullptr) {\n+    return;\n+  }\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(loader());\n+\n+  for (int i = 0; i < classes->length(); i++) {\n+    InstanceKlass* ik = classes->at(i);\n+    if (log_is_enabled(Info, cds, aot, load)) {\n+      ResourceMark rm(THREAD);\n+      log_info(cds, aot, load)(\"%-5s %s%s%s\", category_name, ik->external_name(),\n+                               ik->is_loaded() ? \" (already loaded)\" : \"\",\n+                               ik->is_hidden() ? \" (hidden)\" : \"\");\n+    }\n+\n+    if (!ik->is_loaded()) {\n+      if (ik->is_hidden()) {\n+        \/\/ TODO: AOTClassLinking is not implemented for hidden class until JDK-8293336\n+        ShouldNotReachHere();\n+      } else {\n+        InstanceKlass* actual;\n+        if (loader_data == ClassLoaderData::the_null_class_loader_data()) {\n+          actual = SystemDictionary::load_instance_class(ik->name(), loader, CHECK);\n+        } else {\n+          actual = SystemDictionaryShared::find_or_load_shared_class(ik->name(), loader, CHECK);\n+        }\n+\n+        if (actual != ik) {\n+          ResourceMark rm(THREAD);\n+          log_error(cds)(\"Unable to resolve %s class from CDS archive: %s\", category_name, ik->external_name());\n+          log_error(cds)(\"Expected: \" INTPTR_FORMAT \", actual: \" INTPTR_FORMAT, p2i(ik), p2i(actual));\n+          log_error(cds)(\"JVMTI class retransformation is not supported when archive was generated with -XX:+AOTClassLinking.\");\n+          MetaspaceShared::unrecoverable_loading_error();\n+        }\n+        assert(actual->is_loaded(), \"must be\");\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Initiate loading of the <classes> in the <initiating_loader>. The <classes> should have already been loaded\n+\/\/ by a parent loader of the <initiating_loader>. This is necessary for handling pre-resolved CP entries.\n+\/\/\n+\/\/ For example, we initiate the loading of java\/lang\/String in the AppClassLoader. This will allow\n+\/\/ any App classes to have a pre-resolved ConstantPool entry that references java\/lang\/String.\n+\/\/\n+\/\/ TODO: we can limit the number of initiated classes to only those that are actually referenced by\n+\/\/ AOT-linked classes loaded by <initiating_loader>.\n+void AOTLinkedClassBulkLoader::initiate_loading(JavaThread* current, const char* category_name,\n+                                                Handle initiating_loader, Array<InstanceKlass*>* classes) {\n+  if (classes == nullptr) {\n+    return;\n+  }\n+\n+  assert(initiating_loader() == SystemDictionary::java_platform_loader() ||\n+         initiating_loader() == SystemDictionary::java_system_loader(), \"must be\");\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(initiating_loader());\n+  MonitorLocker mu1(SystemDictionary_lock);\n+\n+  for (int i = 0; i < classes->length(); i++) {\n+    InstanceKlass* ik = classes->at(i);\n+    assert(ik->is_loaded(), \"must have already been loaded by a parent loader\");\n+    assert(ik->class_loader() != initiating_loader(), \"must be a parent loader\");\n+    assert(ik->class_loader() == nullptr ||\n+           ik->class_loader() == SystemDictionary::java_platform_loader(), \"must be\");\n+    if (ik->is_public() && !ik->is_hidden()) {\n+      if (log_is_enabled(Info, cds, aot, load)) {\n+        ResourceMark rm(current);\n+        const char* defining_loader = (ik->class_loader() == nullptr ? \"boot\" : \"plat\");\n+        log_info(cds, aot, load)(\"%s %s (initiated, defined by %s)\", category_name, ik->external_name(),\n+                                 defining_loader);\n+      }\n+      SystemDictionary::add_to_initiating_loader(current, ik, loader_data);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTLINKEDCLASSBULKLOADER_HPP\n+#define SHARE_CDS_AOTLINKEDCLASSBULKLOADER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class AOTLinkedClassTable;\n+class ClassLoaderData;\n+class InstanceKlass;\n+class SerializeClosure;\n+template <typename T> class Array;\n+enum class AOTLinkedClassCategory : int;\n+\n+\/\/ During a Production Run, the AOTLinkedClassBulkLoader loads all classes from\n+\/\/ a AOTLinkedClassTable into their respective ClassLoaders. This happens very early\n+\/\/ in the JVM bootstrap stage, before any application code is executed.\n+\/\/\n+class AOTLinkedClassBulkLoader :  AllStatic {\n+  static void load_classes_in_loader(JavaThread* current, AOTLinkedClassCategory class_category, oop class_loader_oop);\n+  static void load_classes_in_loader_impl(AOTLinkedClassCategory class_category, oop class_loader_oop, TRAPS);\n+  static void load_table(AOTLinkedClassTable* table, AOTLinkedClassCategory class_category, Handle loader, TRAPS);\n+  static void initiate_loading(JavaThread* current, const char* category, Handle initiating_loader, Array<InstanceKlass*>* classes);\n+  static void load_classes_impl(AOTLinkedClassCategory class_category, Array<InstanceKlass*>* classes,\n+                                const char* category_name, Handle loader, TRAPS);\n+\n+public:\n+  static void serialize(SerializeClosure* soc, bool is_static_archive) NOT_CDS_RETURN;\n+\n+  static void load_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void load_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTLINKEDCLASSBULKLOADER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotLinkedClassTable.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/serializeClosure.hpp\"\n+#include \"oops\/array.hpp\"\n+\n+AOTLinkedClassTable AOTLinkedClassTable::_for_static_archive;\n+AOTLinkedClassTable AOTLinkedClassTable::_for_dynamic_archive;\n+\n+void AOTLinkedClassTable::serialize(SerializeClosure* soc) {\n+  soc->do_ptr((void**)&_boot);\n+  soc->do_ptr((void**)&_boot2);\n+  soc->do_ptr((void**)&_platform);\n+  soc->do_ptr((void**)&_app);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTLINKEDCLASSTABLE_HPP\n+#define SHARE_CDS_AOTLINKEDCLASSTABLE_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+template <typename T> class Array;\n+class InstanceKlass;\n+class SerializeClosure;\n+\n+\/\/ Classes to be buik-loaded, in the \"linked\" state, at VM bootstrap.\n+\/\/\n+\/\/ AOTLinkedClassTable is produced by AOTClassLinker when an AOTCache is assembled.\n+\/\/\n+\/\/ AOTLinkedClassTable is consumed by AOTLinkedClassBulkLoader when an AOTCache is used\n+\/\/ in a production run.\n+\/\/\n+class AOTLinkedClassTable {\n+  \/\/ The VM may load up to 2 CDS archives -- static and dynamic. Each\n+  \/\/ archive can have its own AOTLinkedClassTable.\n+  static AOTLinkedClassTable _for_static_archive;\n+  static AOTLinkedClassTable _for_dynamic_archive;\n+\n+  Array<InstanceKlass*>* _boot;  \/\/ only java.base classes\n+  Array<InstanceKlass*>* _boot2; \/\/ boot classes in other modules\n+  Array<InstanceKlass*>* _platform;\n+  Array<InstanceKlass*>* _app;\n+\n+public:\n+  AOTLinkedClassTable() :\n+    _boot(nullptr), _boot2(nullptr),\n+    _platform(nullptr), _app(nullptr) {}\n+\n+  static AOTLinkedClassTable* for_static_archive()  { return &_for_static_archive; }\n+  static AOTLinkedClassTable* for_dynamic_archive() { return &_for_dynamic_archive; }\n+\n+  static AOTLinkedClassTable* get(bool is_static_archive) {\n+    return is_static_archive ? for_static_archive() : for_dynamic_archive();\n+  }\n+\n+  Array<InstanceKlass*>* boot()     const { return _boot;     }\n+  Array<InstanceKlass*>* boot2()    const { return _boot2;    }\n+  Array<InstanceKlass*>* platform() const { return _platform; }\n+  Array<InstanceKlass*>* app()      const { return _app;      }\n+\n+  void set_boot    (Array<InstanceKlass*>* value) { _boot     = value; }\n+  void set_boot2   (Array<InstanceKlass*>* value) { _boot2    = value; }\n+  void set_platform(Array<InstanceKlass*>* value) { _platform = value; }\n+  void set_app     (Array<InstanceKlass*>* value) { _app      = value; }\n+\n+  void serialize(SerializeClosure* soc);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTLINKEDCLASSTABLE_HPP\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.hpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"cds\/aotClassLinker.hpp\"\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -285,0 +287,2 @@\n+\n+  AOTClassLinker::add_candidates();\n@@ -311,0 +315,9 @@\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ This is difficult to estimate when dumping the dynamic archive, as the\n+    \/\/ AOTLinkedClassTable may need to contain classes in the static archive as well.\n+    \/\/\n+    \/\/ Just give a generous estimate for now. We will remove estimate_archive_size()\n+    \/\/ in JDK-8340416\n+    _estimated_hashtable_bytes += 20 * 1024 * 1024;\n+  }\n+\n@@ -424,0 +437,2 @@\n+\n+  remember_embedded_pointer_in_enclosing_obj(ref);\n@@ -428,1 +443,0 @@\n-  remember_embedded_pointer_in_enclosing_obj(ref);\n@@ -755,0 +769,8 @@\n+#define ADD_COUNT(x) \\\n+  x += 1; \\\n+  x ## _a += aotlinked ? 1 : 0;\n+\n+#define DECLARE_INSTANCE_KLASS_COUNTER(x) \\\n+  int x = 0; \\\n+  int x ## _a = 0;\n+\n@@ -756,5 +778,8 @@\n-  int num_instance_klasses = 0;\n-  int num_boot_klasses = 0;\n-  int num_platform_klasses = 0;\n-  int num_app_klasses = 0;\n-  int num_hidden_klasses = 0;\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_instance_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_boot_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_vm_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_platform_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_app_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_hidden_klasses);\n+\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_unregistered_klasses);\n@@ -762,1 +787,0 @@\n-  int num_unregistered_klasses = 0;\n@@ -766,0 +790,5 @@\n+  int boot_unlinked = 0;\n+  int platform_unlinked = 0;\n+  int app_unlinked = 0;\n+  int unreg_unlinked = 0;\n+\n@@ -781,0 +810,1 @@\n+    const char* aotlinked_msg = \"\";\n@@ -794,1 +824,0 @@\n-      num_instance_klasses ++;\n@@ -796,1 +825,25 @@\n-      if (ik->is_shared_boot_class()) {\n+      InstanceKlass* src_ik = get_source_addr(ik);\n+      bool aotlinked = AOTClassLinker::is_candidate(src_ik);\n+      ADD_COUNT(num_instance_klasses);\n+      if (CDSConfig::is_dumping_dynamic_archive()) {\n+        \/\/ For static dump, class loader type are already set.\n+        ik->assign_class_loader_type();\n+      }\n+      if (ik->is_hidden()) {\n+        ADD_COUNT(num_hidden_klasses);\n+        hidden = \" hidden\";\n+        oop loader = k->class_loader();\n+        if (loader == nullptr) {\n+          type = \"boot\";\n+          ADD_COUNT(num_boot_klasses);\n+        } else if (loader == SystemDictionary::java_platform_loader()) {\n+          type = \"plat\";\n+          ADD_COUNT(num_platform_klasses);\n+        } else if (loader == SystemDictionary::java_system_loader()) {\n+          type = \"app\";\n+          ADD_COUNT(num_app_klasses);\n+        } else {\n+          type = \"bad\";\n+          assert(0, \"shouldn't happen\");\n+        }\n+      } else if (ik->is_shared_boot_class()) {\n@@ -798,1 +851,1 @@\n-        num_boot_klasses ++;\n+        ADD_COUNT(num_boot_klasses);\n@@ -801,1 +854,1 @@\n-        num_platform_klasses ++;\n+        ADD_COUNT(num_platform_klasses);\n@@ -804,1 +857,1 @@\n-        num_app_klasses ++;\n+        ADD_COUNT(num_app_klasses);\n@@ -808,1 +861,5 @@\n-        num_unregistered_klasses ++;\n+        ADD_COUNT(num_unregistered_klasses);\n+      }\n+\n+      if (AOTClassLinker::is_vm_class(src_ik)) {\n+        ADD_COUNT(num_vm_klasses);\n@@ -813,1 +870,10 @@\n-        unlinked = \" ** unlinked\";\n+        unlinked = \" unlinked\";\n+        if (ik->is_shared_boot_class()) {\n+          boot_unlinked ++;\n+        } else if (ik->is_shared_platform_class()) {\n+          platform_unlinked ++;\n+        } else if (ik->is_shared_app_class()) {\n+          app_unlinked ++;\n+        } else {\n+          unreg_unlinked ++;\n+        }\n@@ -816,4 +882,0 @@\n-      if (ik->is_hidden()) {\n-        num_hidden_klasses ++;\n-        hidden = \" ** hidden\";\n-      }\n@@ -822,1 +884,4 @@\n-        generated = \" ** generated\";\n+        generated = \" generated\";\n+      }\n+      if (aotlinked) {\n+        aotlinked_msg = \" aot-linked\";\n@@ -824,0 +889,1 @@\n+\n@@ -830,1 +896,1 @@\n-      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s\", i,\n+      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s%s\", i,\n@@ -832,1 +898,1 @@\n-                            hidden, unlinked, generated);\n+                            hidden, unlinked, generated, aotlinked_msg);\n@@ -836,0 +902,3 @@\n+#define STATS_FORMAT    \"= %5d, aot-linked = %5d\"\n+#define STATS_PARAMS(x) num_ ## x, num_ ## x ## _a\n+\n@@ -837,7 +906,9 @@\n-  log_info(cds)(\"    instance classes   = %5d\", num_instance_klasses);\n-  log_info(cds)(\"      boot             = %5d\", num_boot_klasses);\n-  log_info(cds)(\"      app              = %5d\", num_app_klasses);\n-  log_info(cds)(\"      platform         = %5d\", num_platform_klasses);\n-  log_info(cds)(\"      unregistered     = %5d\", num_unregistered_klasses);\n-  log_info(cds)(\"      (hidden)         = %5d\", num_hidden_klasses);\n-  log_info(cds)(\"      (unlinked)       = %5d\", num_unlinked_klasses);\n+  log_info(cds)(\"    instance classes   \" STATS_FORMAT, STATS_PARAMS(instance_klasses));\n+  log_info(cds)(\"      boot             \" STATS_FORMAT, STATS_PARAMS(boot_klasses));\n+  log_info(cds)(\"        vm             \" STATS_FORMAT, STATS_PARAMS(vm_klasses));\n+  log_info(cds)(\"      platform         \" STATS_FORMAT, STATS_PARAMS(platform_klasses));\n+  log_info(cds)(\"      app              \" STATS_FORMAT, STATS_PARAMS(app_klasses));\n+  log_info(cds)(\"      unregistered     \" STATS_FORMAT, STATS_PARAMS(unregistered_klasses));\n+  log_info(cds)(\"      (hidden)         \" STATS_FORMAT, STATS_PARAMS(hidden_klasses));\n+  log_info(cds)(\"      (unlinked)       = %5d, boot = %d, plat = %d, app = %d, unreg = %d\",\n+                num_unlinked_klasses, boot_unlinked, platform_unlinked, app_unlinked, unreg_unlinked);\n@@ -848,0 +919,3 @@\n+#undef STATS_FORMAT\n+#undef STATS_PARAMS\n+\n@@ -855,0 +929,1 @@\n+  AOTLinkedClassBulkLoader::serialize(soc, false);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":103,"deletions":28,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-    return (buffer_bottom() <= p && p < buffer_top());\n+    return (buffer_bottom() != nullptr && buffer_bottom() <= p && p < buffer_top());\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/klass.inline.hpp\"\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+template<class E> class Array;\n+template<class E> class GrowableArray;\n+\n@@ -251,0 +254,2 @@\n+\n+  template <typename T> static Array<T>* archive_array(GrowableArray<T>* tmp_array);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,4 @@\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"oops\/array.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n@@ -50,0 +54,15 @@\n+\/\/ Returns the address of an Array<T> that's allocated in the ArchiveBuilder \"buffer\" space.\n+template <typename T>\n+Array<T>* ArchiveUtils::archive_array(GrowableArray<T>* tmp_array) {\n+  Array<T>* archived_array = ArchiveBuilder::new_ro_array<T>(tmp_array->length());\n+  for (int i = 0; i < tmp_array->length(); i++) {\n+    archived_array->at_put(i, tmp_array->at(i));\n+    if (std::is_pointer<T>::value) {\n+      ArchivePtrMarker::mark_pointer(archived_array->adr_at(i));\n+    }\n+  }\n+\n+  return archived_array;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.inline.hpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+bool CDSConfig::_has_aot_linked_classes = false;\n@@ -533,0 +534,20 @@\n+\n+bool CDSConfig::is_dumping_aot_linked_classes() {\n+  if (is_dumping_dynamic_archive()) {\n+    return is_using_full_module_graph() && AOTClassLinking;\n+  } else if (is_dumping_static_archive()) {\n+    return is_dumping_full_module_graph() && AOTClassLinking;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool CDSConfig::is_using_aot_linked_classes() {\n+  \/\/ Make sure we have the exact same module graph as in the assembly phase, or else\n+  \/\/ some aot-linked classes may not be visible so cannot be loaded.\n+  return is_using_full_module_graph() && _has_aot_linked_classes;\n+}\n+\n+void CDSConfig::set_has_aot_linked_classes(bool has_aot_linked_classes) {\n+  _has_aot_linked_classes |= has_aot_linked_classes;\n+}\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+  static bool _has_aot_linked_classes;\n@@ -94,0 +95,4 @@\n+  static bool is_dumping_aot_linked_classes()                NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_using_aot_linked_classes()                  NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void set_has_aot_linked_classes(bool has_aot_linked_classes) NOT_CDS_JAVA_HEAP_RETURN;\n+\n@@ -105,1 +110,1 @@\n-  static bool   is_dumping_heap()                            NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_dumping_heap()                              NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n-  \/* These are aliases of -Xshare:dump, -XX:SharedArchiveFile=..., etc. *\/  \\\n-  \/* See CDSConfig::check_flag_aliases().                               *\/  \\\n+  \/* The following 3 flags are aliases of -Xshare:dump,                 *\/  \\\n+  \/* -XX:SharedArchiveFile=..., etc. See CDSConfig::check_flag_aliases()*\/  \\\n@@ -112,0 +112,5 @@\n+                                                                            \\\n+  product(bool, AOTClassLinking, false,                                     \\\n+          \"Load\/link all archived classes for the boot\/platform\/app \"       \\\n+          \"loaders before application main\")                                \\\n+\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassLinker.hpp\"\n@@ -117,0 +118,2 @@\n+  msg.info(\"Platform loader initiated classes = %5d\", AOTClassLinker::num_platform_initiated_classes());\n+  msg.info(\"App      loader initiated classes = %5d\", AOTClassLinker::num_app_initiated_classes());\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"cds\/aotConstantPoolResolver.hpp\"\n+#include \"cds\/aotClassLinker.hpp\"\n@@ -138,0 +138,5 @@\n+    sort_methods();\n+\n+    log_info(cds)(\"Make classes shareable\");\n+    make_klasses_shareable();\n+\n@@ -150,0 +155,1 @@\n+      AOTClassLinker::write_to_archive();\n@@ -158,5 +164,0 @@\n-    sort_methods();\n-\n-    log_info(cds)(\"Make classes shareable\");\n-    make_klasses_shareable();\n-\n@@ -237,1 +238,1 @@\n-  AOTConstantPoolResolver::dispose();\n+  AOTClassLinker::dispose();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+  _has_aot_linked_classes = CDSConfig::is_dumping_aot_linked_classes();\n@@ -301,0 +302,1 @@\n+  st->print_cr(\"- has_aot_linked_classes          %d\", _has_aot_linked_classes);\n@@ -1018,1 +1020,3 @@\n-  validate_non_existent_class_paths();\n+  if (!validate_non_existent_class_paths()) {\n+    return false;\n+  }\n@@ -1034,1 +1038,1 @@\n-void FileMapInfo::validate_non_existent_class_paths() {\n+bool FileMapInfo::validate_non_existent_class_paths() {\n@@ -1047,3 +1051,9 @@\n-      log_warning(cds)(\"Archived non-system classes are disabled because the \"\n-              \"file %s exists\", ent->name());\n-      header()->set_has_platform_or_app_classes(false);\n+      if (header()->has_aot_linked_classes()) {\n+        log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used because the \"\n+                       \"file %s exists\", ent->name());\n+        return false;\n+      } else {\n+        log_warning(cds)(\"Archived non-system classes are disabled because the \"\n+                         \"file %s exists\", ent->name());\n+        header()->set_has_platform_or_app_classes(false);\n+      }\n@@ -1052,0 +1062,2 @@\n+\n+  return true;\n@@ -2034,1 +2046,10 @@\n-    CDSConfig::stop_using_full_module_graph();\n+    if (CDSConfig::is_using_aot_linked_classes()) {\n+      \/\/ It's too late to recover -- we have already committed to use the archived metaspace objects, but\n+      \/\/ the archived heap objects cannot be loaded, so we don't have the archived FMG to guarantee that\n+      \/\/ all AOT-linked classes are visible.\n+      \/\/\n+      \/\/ We get here because the heap is too small. The app will fail anyway. So let's quit.\n+      MetaspaceShared::unrecoverable_loading_error(\"CDS archive has aot-linked classes but the archived \"\n+                                                   \"heap objects cannot be loaded. Try increasing your heap size.\");\n+    }\n+    CDSConfig::stop_using_full_module_graph(\"archive heap loading failed\");\n@@ -2363,0 +2384,22 @@\n+bool FileMapInfo::validate_aot_class_linking() {\n+  \/\/ These checks need to be done after FileMapInfo::initialize(), which gets called before Universe::heap()\n+  \/\/ is available.\n+  if (header()->has_aot_linked_classes()) {\n+    CDSConfig::set_has_aot_linked_classes(true);\n+    if (JvmtiExport::should_post_class_file_load_hook()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\");\n+      return false;\n+    }\n+    if (JvmtiExport::has_early_vmstart_env()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when JVMTI early vm start is in use.\");\n+      return false;\n+    }\n+    if (!CDSConfig::is_using_full_module_graph()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when archived full module graph is not used.\");\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n@@ -2412,0 +2455,5 @@\n+    if (has_aot_linked_classes()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when the \"\n+                     \"java.system.class.loader property is specified.\");\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":54,"deletions":6,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+  bool   _has_aot_linked_classes;       \/\/ Was the CDS archive created with -XX:+AOTClassLinking\n@@ -271,0 +272,1 @@\n+  bool has_aot_linked_classes()            const { return _has_aot_linked_classes; }\n@@ -484,1 +486,2 @@\n-  void validate_non_existent_class_paths();\n+  bool validate_non_existent_class_paths();\n+  bool validate_aot_class_linking();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,9 @@\n+  if (CDSConfig::is_dumping_dynamic_archive() && CDSConfig::is_dumping_aot_linked_classes() &&\n+      CDSConfig::is_using_aot_linked_classes()) {\n+    \/\/ The base archive may have some pre-resolved CP entries that point to the lambda form holder\n+    \/\/ classes in the base archive. If we generate new versions of these classes, those CP entries\n+    \/\/ will be pointing to invalid classes.\n+    log_info(cds)(\"Base archive already has aot-linked lambda form holder classes. Cannot regenerate.\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassLinker.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -396,1 +398,1 @@\n-\n+  AOTLinkedClassBulkLoader::serialize(soc, true);\n@@ -498,0 +500,1 @@\n+  AOTClassLinker::write_to_archive();\n@@ -610,1 +613,1 @@\n-  AOTConstantPoolResolver::initialize();\n+  AOTClassLinker::initialize();\n@@ -1446,0 +1449,4 @@\n+  if (!mapinfo->validate_aot_class_linking()) {\n+    return MAP_ARCHIVE_OTHER_FAILURE;\n+  }\n+\n@@ -1526,0 +1533,12 @@\n+  LogStreamHandle(Info, cds) lsh;\n+  if (lsh.is_enabled()) {\n+    lsh.print(\"Using AOT-linked classes: %s (static archive: %s aot-linked classes\",\n+              CDSConfig::is_using_aot_linked_classes() ? \"true\" : \"false\",\n+              static_mapinfo->header()->has_aot_linked_classes() ? \"has\" : \"no\");\n+    if (dynamic_mapinfo != nullptr) {\n+      lsh.print(\", dynamic archive: %s aot-linked classes\",\n+                dynamic_mapinfo->header()->has_aot_linked_classes() ? \"has\" : \"no\");\n+    }\n+    lsh.print_cr(\")\");\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+    OTHER = 0,\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -137,3 +137,3 @@\n-  if (_java_system_loader.is_empty()) {\n-    oop system_loader = get_system_class_loader_impl(CHECK);\n-    _java_system_loader = OopHandle(Universe::vm_global(), system_loader);\n+  if (_java_platform_loader.is_empty()) {\n+    oop platform_loader = get_platform_class_loader_impl(CHECK);\n+    _java_platform_loader = OopHandle(Universe::vm_global(), platform_loader);\n@@ -145,2 +145,2 @@\n-      oop system_loader = get_system_class_loader_impl(CHECK);\n-      assert(_java_system_loader.resolve() == system_loader, \"must be\");\n+      oop platform_loader = get_platform_class_loader_impl(CHECK);\n+      assert(_java_platform_loader.resolve() == platform_loader, \"must be\");\n@@ -150,3 +150,3 @@\n-  if (_java_platform_loader.is_empty()) {\n-    oop platform_loader = get_platform_class_loader_impl(CHECK);\n-    _java_platform_loader = OopHandle(Universe::vm_global(), platform_loader);\n+  if (_java_system_loader.is_empty()) {\n+    oop system_loader = get_system_class_loader_impl(CHECK);\n+    _java_system_loader = OopHandle(Universe::vm_global(), system_loader);\n@@ -158,2 +158,2 @@\n-      oop platform_loader = get_platform_class_loader_impl(CHECK);\n-      assert(_java_platform_loader.resolve() == platform_loader, \"must be\");\n+      oop system_loader = get_system_class_loader_impl(CHECK);\n+      assert(_java_system_loader.resolve() == system_loader, \"must be\");\n@@ -1722,0 +1722,17 @@\n+#if INCLUDE_CDS\n+\/\/ Indicate that loader_data has initiated the loading of class k, which\n+\/\/ has already been defined by a parent loader.\n+\/\/ This API should be used only by AOTLinkedClassBulkLoader\n+void SystemDictionary::add_to_initiating_loader(JavaThread* current,\n+                                                InstanceKlass* k,\n+                                                ClassLoaderData* loader_data) {\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"must be\");\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  Symbol* name  = k->name();\n+  Dictionary* dictionary = loader_data->dictionary();\n+  assert(k->is_loaded(), \"must be\");\n+  assert(k->class_loader_data() != loader_data, \"only for classes defined by a parent loader\");\n+  assert(dictionary->find_class(current, name) == nullptr, \"sanity\");\n+  dictionary->add_klass(current, name, k);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  friend class AOTLinkedClassBulkLoader;\n@@ -296,0 +297,2 @@\n+  static void add_to_initiating_loader(JavaThread* current, InstanceKlass* k,\n+                                       ClassLoaderData* loader_data) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -223,0 +224,3 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::load_javabase_classes(THREAD);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  LOG_TAG(aot) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-      log.print(\"    %s\", name->as_C_string());\n+      log.print(\" => %s\", name->as_C_string());\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -439,1 +439,1 @@\n-        log.print(\"%s field  CP entry [%3d]: %s %s %s.%s:%s\",\n+        log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s\",\n@@ -443,1 +443,0 @@\n-                  (archived ? \"=>\" : \"  \"),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2709,0 +2709,12 @@\n+\n+int InstanceKlass::shared_class_loader_type() const {\n+  if (is_shared_boot_class()) {\n+    return ClassLoader::BOOT_LOADER;\n+  } else if (is_shared_platform_class()) {\n+    return ClassLoader::PLATFORM_LOADER;\n+  } else if (is_shared_app_class()) {\n+    return ClassLoader::APP_LOADER;\n+  } else {\n+    return ClassLoader::OTHER;\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -323,0 +323,1 @@\n+  int  shared_class_loader_type() const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1076,0 +1076,10 @@\n+}\n+\n+bool JvmtiExport::has_early_vmstart_env() {\n+  JvmtiEnvIterator it;\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n+    if (env->early_vmstart_env()) {\n+      return true;\n+    }\n+  }\n+  return false;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -374,0 +374,1 @@\n+  static bool has_early_vmstart_env() NOT_JVMTI_RETURN_(false);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -735,0 +736,4 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::load_non_javabase_classes(THREAD);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+    vm.cds.supports.aot.class.linking \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -437,0 +437,1 @@\n+ -runtime\/cds\/appcds\/applications \\\n@@ -450,0 +451,1 @@\n+ -runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java \\\n@@ -454,0 +456,1 @@\n+ -runtime\/cds\/appcds\/CommandLineFlagCombo.java \\\n@@ -520,0 +523,33 @@\n+# Run CDS tests with -XX:+AOTClassLinking. This should include most CDS tests, except for\n+# those that rely on redefining classes that are already archived.\n+hotspot_aot_classlinking = \\\n+  runtime\/cds \\\n+ -runtime\/cds\/appcds\/aotClassLinking \\\n+ -runtime\/cds\/appcds\/cacheObject\/ArchivedIntegerCacheTest.java \\\n+ -runtime\/cds\/appcds\/cacheObject\/ArchivedModuleCompareTest.java \\\n+ -runtime\/cds\/appcds\/CDSandJFR.java \\\n+ -runtime\/cds\/appcds\/customLoader\/HelloCustom_JFR.java \\\n+ -runtime\/cds\/appcds\/customLoader\/ParallelTestMultiFP.java \\\n+ -runtime\/cds\/appcds\/customLoader\/ParallelTestSingleFP.java \\\n+ -runtime\/cds\/appcds\/customLoader\/SameNameInTwoLoadersTest.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/LambdaInBaseArchive.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/classpathtests\/EmptyClassInBootClassPath.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/JigsawOptionsCombo.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/overridetests\/OverrideTests.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/RedefineClassesInModuleGraph.java \\\n+ -runtime\/cds\/appcds\/JvmtiAddPath.java \\\n+ -runtime\/cds\/appcds\/jvmti \\\n+ -runtime\/cds\/appcds\/loaderConstraints\/LoaderConstraintsTest.java \\\n+ -runtime\/cds\/appcds\/redefineClass \\\n+ -runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java \\\n+ -runtime\/cds\/appcds\/RewriteBytecodesTest.java \\\n+ -runtime\/cds\/appcds\/SpecifySysLoaderProp.java \\\n+ -runtime\/cds\/appcds\/TestSerialGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestWithProfiler.java \\\n+ -runtime\/cds\/serviceability\/ReplaceCriticalClassesForSubgraphs.java \\\n+ -runtime\/cds\/serviceability\/ReplaceCriticalClasses.java \\\n+ -runtime\/cds\/serviceability\/transformRelatedClasses\/TransformInterfaceAndImplementor.java \\\n+ -runtime\/cds\/serviceability\/transformRelatedClasses\/TransformSuperAndSubClasses.java \\\n+ -runtime\/cds\/serviceability\/transformRelatedClasses\/TransformSuperSubTwoPckgs.java\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,1 @@\n-    TestCommon.run(\n+    CDSTestUtils.Result result = TestCommon.run(\n@@ -123,4 +123,11 @@\n-        \"CpAttr6\")\n-      .assertNormalExit(output -> {\n-          output.shouldMatch(\"Archived non-system classes are disabled because the file .*cpattrX.jar exists\");\n-        });\n+        \"CpAttr6\");\n+    if (CDSTestUtils.isAOTClassLinkingEnabled()) {\n+        result.assertAbnormalExit(output -> {\n+                output.shouldMatch(\"CDS archive has aot-linked classes. It cannot be used because the file .*cpattrX.jar exists\");\n+            });\n+\n+    } else {\n+        result.assertNormalExit(output -> {\n+                output.shouldMatch(\"Archived non-system classes are disabled because the file .*cpattrX.jar exists\");\n+            });\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ClassPathAttr.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+                                     \"|(CDS archive has aot-linked classes but the archived heap objects cannot be loaded)\" +\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestParallelGCWithCDS.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.flagless\n+ * @summary Disable CDS when incompatible options related to AOTClassLinking are used\n+ * @library \/test\/jdk\/lib\/testlibrary\n+ *          \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build Hello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar Hello\n+ * @run driver AOTClassLinkingVMOptions\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class AOTClassLinkingVMOptions {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+\n+    static int testCaseNum = 0;\n+    static void testCase(String s) {\n+        testCaseNum++;\n+        System.out.println(\"Test case \" + testCaseNum + \": \" + s);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        TestCommon.testDump(appJar, TestCommon.list(\"Hello\"),\n+                            \"-XX:+AOTClassLinking\");\n+\n+        testCase(\"Archived full module graph must be enabled at runtime\");\n+        TestCommon.run(\"-cp\", appJar, \"-Djdk.module.validation=1\", \"Hello\")\n+            .assertAbnormalExit(\"CDS archive has aot-linked classes.\" +\n+                                \" It cannot be used when archived full module graph is not used\");\n+\n+        testCase(\"Cannot use -Djava.system.class.loader\");\n+        TestCommon.run(\"-cp\", appJar, \"-Djava.system.class.loader=dummy\", \"Hello\")\n+            .assertAbnormalExit(\"CDS archive has aot-linked classes.\" +\n+                                \" It cannot be used when the java.system.class.loader property is specified.\");\n+\n+        \/\/ NOTE: tests for ClassFileLoadHook + AOTClassLinking is in\n+        \/\/ ..\/jvmti\/ClassFileLoadHookTest.java\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/AOTClassLinkingVMOptions.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ AOT-linked classes are loaded during VM bootstrap by the C++ class AOTLinkedClassBulkLoader.\n+\/\/ Make sure that the Module, Package, CodeSource and ProtectionDomain of these classes are\n+\/\/ set up properly.\n+\n+\/*\n+ * @test id=static\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build InitiatingLoaderTester\n+ * @build BulkLoaderTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar BulkLoaderTestApp.jar BulkLoaderTestApp MyUtil InitiatingLoaderTester\n+ * @run driver BulkLoaderTest STATIC\n+ *\/\n+\n+\/*\n+ * @test id=dynamic\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build InitiatingLoaderTester\n+ * @build BulkLoaderTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar BulkLoaderTestApp.jar BulkLoaderTestApp MyUtil InitiatingLoaderTester\n+ * @run driver BulkLoaderTest DYNAMIC\n+ *\/\n+\n+import java.io.File;\n+import java.lang.StackWalker.StackFrame;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.Set;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BulkLoaderTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"BulkLoaderTestApp.jar\");\n+    static final String mainClass = \"BulkLoaderTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester t = new Tester();\n+\n+        \/\/ Run with archived FMG loaded\n+        t.run(args);\n+\n+        \/\/ Run with an extra classpath -- archived FMG can still load.\n+        {\n+            String extraVmArgs[] = {\n+                \"-cp\",\n+                appJar + File.pathSeparator + \"foobar.jar\"\n+            };\n+            OutputAnalyzer out = t.productionRun(extraVmArgs);\n+            out.shouldHaveExitValue(0);\n+        }\n+\n+        \/\/ Run without archived FMG -- fail to load\n+        {\n+            String extraVmArgs[] = {\n+                \"-Xshare:on\",\n+                \"-Xlog:cds\",\n+                \"-Djdk.module.showModuleResolution=true\"\n+            };\n+            t.setCheckExitValue(false);\n+            OutputAnalyzer out = t.productionRun(extraVmArgs);\n+            out.shouldHaveExitValue(1);\n+            out.shouldContain(\"CDS archive has aot-linked classes. It cannot be used when archived full module graph is not used.\");\n+            t.setCheckExitValue(true);\n+        }\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"-Xlog:cds,cds+aot+load\",\n+                \"-XX:+AOTClassLinking\",\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+            };\n+        }\n+    }\n+}\n+\n+class BulkLoaderTestApp {\n+    static String allPerms = \"null.*<no principals>.*java.security.Permissions.*,*java.security.AllPermission.*<all permissions>.*<all actions>\";\n+\n+    public static void main(String args[]) throws Exception {\n+        checkClasses();\n+        checkInitiatingLoader();\n+    }\n+\n+    \/\/ Check the ClassLoader\/Module\/Package\/ProtectionDomain\/CodeSource of classes that are aot-linked\n+    static void checkClasses() throws Exception {\n+        check(String.class,\n+              \"null\",  \/\/ loader\n+              \"module java.base\",\n+              \"package java.lang\",\n+              \"null\",\n+              allPerms);\n+\n+        check(Class.forName(\"sun.util.logging.internal.LoggingProviderImpl\"),\n+              \"null\",\n+              \"module java.logging\",\n+              \"package sun.util.logging.internal\",\n+              \"null\",\n+              allPerms);\n+\n+\n+        check(javax.tools.FileObject.class,\n+              \"^jdk.internal.loader.ClassLoaders[$]PlatformClassLoader@\",\n+              \"module java.compiler\",\n+              \"package javax.tools\",\n+              \"jrt:\/java.compiler <no signer certificates>\",\n+              \"jdk.internal.loader.ClassLoaders[$]PlatformClassLoader.*<no principals>.*java.security.Permissions.*\"\n+              + \"java.lang.RuntimePermission.*accessSystemModules\");\n+\n+        check(BulkLoaderTestApp.class,\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader@\",\n+              \"^unnamed module @\",\n+              \"package \",\n+              \"file:.*BulkLoaderTestApp.jar <no signer certificates>\",\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader.*<no principals>.*java.security.Permissions.*\"\n+              + \"java.io.FilePermission.*BulkLoaderTestApp.jar.*read\");\n+\n+        check(Class.forName(\"com.sun.tools.javac.Main\"),\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader@\",\n+              \"module jdk.compiler\",\n+              \"package com.sun.tools.javac\",\n+              \"jrt:\/jdk.compiler <no signer certificates>\",\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader.*<no principals>.*java.security.Permissions.*\"\n+              + \"java.lang.RuntimePermission.*accessSystemModules\");\n+\n+        doit(() -> {\n+            Class<?> lambdaClass = MyUtil.getCallerClass(1);\n+            check(lambdaClass,\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader@\",\n+              \"unnamed module\",\n+              \"package \",\n+              \"file:.*BulkLoaderTestApp.jar <no signer certificates>\",\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader.*<no principals>.*java.security.Permissions.*\"\n+              + \"java.io.FilePermission.*BulkLoaderTestApp.jar.*read\");\n+\n+          });\n+    }\n+\n+    static void check(Class c, String loader, String module, String pkg, String codeSource, String protectionDomain) {\n+        System.out.println(\"====================================================================\");\n+        System.out.println(c.getName() + \", loader  = \" + c.getClassLoader());\n+        System.out.println(c.getName() + \", module  = \" + c.getModule());\n+        System.out.println(c.getName() + \", package = \" + c.getPackage());\n+        System.out.println(c.getName() + \", CS      = \" + c.getProtectionDomain().getCodeSource());\n+        System.out.println(c.getName() + \", PD      = \" + c.getProtectionDomain());\n+\n+        expectMatch(\"\" + c.getClassLoader(), loader);\n+        expectMatch(\"\" + c.getModule(), module);\n+        expectSame(\"\" + c.getPackage(), pkg);\n+        expectMatch(\"\" + c.getProtectionDomain().getCodeSource(), codeSource);\n+        expectMatch(\"\" + c.getProtectionDomain(), protectionDomain);\n+    }\n+\n+    static void expectSame(String a, String b) {\n+        if (!a.equals(b)) {\n+            throw new RuntimeException(\"Expected \\\"\" + b + \"\\\" but got \\\"\" + a + \"\\\"\");\n+        }\n+    }\n+    static void expectMatch(String string, String pattern) {\n+        Matcher matcher = Pattern.compile(pattern, Pattern.DOTALL).matcher(string);\n+        if (!matcher.find()) {\n+            throw new RuntimeException(\"Expected pattern \\\"\" + pattern + \"\\\" but got \\\"\" + string + \"\\\"\");\n+        }\n+    }\n+\n+    static void doit(Runnable t) {\n+        t.run();\n+    }\n+\n+    static void checkInitiatingLoader() throws Exception {\n+        try {\n+            InitiatingLoaderTester.tryAccess();\n+        } catch (IllegalAccessError t) {\n+            if (t.getMessage().contains(\"cannot access class jdk.internal.misc.Unsafe (in module java.base)\")) {\n+                System.out.println(\"Expected exception:\");\n+                t.printStackTrace(System.out);\n+                \/\/ Class.forName() should still work. We just can't resolve it in CP entries.\n+                Class<?> c = Class.forName(\"jdk.internal.misc.Unsafe\");\n+                System.out.println(\"App loader can still resolve by name: \" + c);\n+                return;\n+            }\n+            throw new RuntimeException(\"Unexpected exception\", t);\n+        }\n+\n+        throw new RuntimeException(\"Should not have succeeded\");\n+    }\n+}\n+\n+class MyUtil {\n+    \/\/ depth is 0-based -- i.e., depth==0 returns the class of the immediate caller of getCallerClass\n+    static Class<?> getCallerClass(int depth) {\n+        \/\/ Need to add the frame of the getCallerClass -- so the immediate caller (depth==0) of this method\n+        \/\/ is at stack.get(1) == stack.get(depth+1);\n+        StackWalker walker = StackWalker.getInstance(\n+            Set.of(StackWalker.Option.RETAIN_CLASS_REFERENCE,\n+                   StackWalker.Option.SHOW_HIDDEN_FRAMES));\n+        List<StackFrame> stack = walker.walk(s -> s.limit(depth+2).collect(Collectors.toList()));\n+        return stack.get(depth+1).getDeclaringClass();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+\n+\n+class InitiatingLoaderTester {\n+    public static Object tryAccess() {\n+        return jdk.internal.misc.Unsafe.getUnsafe();\n+    }\n+}\n+\n+\n+\n+*\/\n+\n+\n+super class InitiatingLoaderTester\n+    version 66:0\n+{\n+  Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+  {\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+  }\n+  public static Method tryAccess:\"()Ljava\/lang\/Object;\"\n+    stack 2 locals 0\n+  {\n+        invokestatic    Method jdk\/internal\/misc\/Unsafe.\"getUnsafe\":\"()Ljdk\/internal\/misc\/Unsafe;\";\n+        areturn;\n+  }\n+\n+} \/\/ end Class InitiatingLoaderTester\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/InitiatingLoaderTester.jasm","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-            .shouldContain(\"unreg OldClass ** unlinked\");\n+            .shouldContain(\"unreg OldClass unlinked\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/CustomClassListDump.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,18 @@\n+\n+        \/\/ JEP 483: if dumped with -XX:+AOTClassLinking, cannot use archive when CFLH\n+        TestCommon.testDump(appJar, sharedClasses, useWb, \"-XX:+AOTClassLinking\");\n+        out = TestCommon.exec(appJar,\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+WhiteBoxAPI\", useWb,\n+                \"-agentlib:SimpleClassFileLoadHook=LoadMe,beforeHook,after_Hook\",\n+                \"-Xlog:cds\",\n+                \"ClassFileLoadHook\",\n+                \"\" + ClassFileLoadHook.TestCaseId.SHARING_ON_CFLH_ON);\n+        if (out.contains(\"Using AOT-linked classes: false (static archive: no aot-linked classes\")) {\n+            \/\/ JTREG is executed with VM options that do not support -XX:+AOTClassLinking, so\n+            \/\/ the static archive was not created with aot-linked classes.\n+            out.shouldHaveExitValue(0);\n+        } else {\n+            out.shouldContain(\"CDS archive has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\");\n+            out.shouldNotHaveExitValue(0);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/ClassFileLoadHookTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires vm.cds.supports.aot.class.linking\n@@ -45,0 +46,1 @@\n+    static boolean aotClassLinking;\n@@ -46,1 +48,6 @@\n-        \/\/ dump class list\n+        test(false);\n+        test(true);\n+    }\n+\n+    static void test(boolean testMode) throws Exception {\n+        aotClassLinking = testMode;\n@@ -56,0 +63,6 @@\n+        if (aotClassLinking) {\n+            opts.addPrefix(\"-XX:+AOTClassLinking\");\n+        } else {\n+            opts.addPrefix(\"-XX:-AOTClassLinking\");\n+        }\n+\n@@ -60,1 +73,1 @@\n-            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\")\n+            .shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\"))\n@@ -63,2 +76,2 @@\n-            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsApp app => java\/lang\/Object boot\")\n-            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsBar app => ResolvedConstantsFoo app\")\n+            .shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => java\/lang\/Object boot\"))\n+            .shouldMatch(ALWAYS(\"klass.* ResolvedConstantsBar app => ResolvedConstantsFoo app\"))\n@@ -67,1 +80,1 @@\n-            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsApp app => java\/lang\/Runnable boot\")\n+            .shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => java\/lang\/Runnable boot\"))\n@@ -69,5 +82,6 @@\n-            \/\/ java\/lang\/System is in the root loader but ResolvedConstantsApp is loaded by the app loader.\n-            \/\/ Even though System is in the vmClasses list, when ResolvedConstantsApp looks up\n-            \/\/ \"java\/lang\/System\" in its ConstantPool, the app loader may not have resolved the System\n-            \/\/ class yet (i.e., there's no initiaited class entry for System in the app loader's dictionary)\n-            .shouldMatch(\"cds,resolve.*reverted klass.* ResolvedConstantsApp .*java\/lang\/System\")\n+            \/\/ Without -XX:+AOTClassLinking:\n+            \/\/   java\/lang\/System is in the boot loader but ResolvedConstantsApp is loaded by the app loader.\n+            \/\/   Even though System is in the vmClasses list, when ResolvedConstantsApp looks up\n+            \/\/   \"java\/lang\/System\" in its ConstantPool, the app loader may not have resolved the System\n+            \/\/   class yet (i.e., there's no initiaited class entry for System in the app loader's dictionary)\n+            .shouldMatch(AOTLINK_ONLY(\"klass.* ResolvedConstantsApp .*java\/lang\/System\"))\n@@ -78,3 +92,4 @@\n-            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsBar => ResolvedConstantsBar.b:I\")\n-            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsBar => ResolvedConstantsBar.a:I\")\n-            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsBar => ResolvedConstantsFoo.a:I\")\n+            .shouldMatch(ALWAYS(\"field.* ResolvedConstantsBar => ResolvedConstantsBar.b:I\"))\n+            .shouldMatch(ALWAYS(\"field.* ResolvedConstantsBar => ResolvedConstantsBar.a:I\"))\n+            .shouldMatch(ALWAYS(\"field.* ResolvedConstantsBar => ResolvedConstantsFoo.a:I\"))\n+            .shouldMatch(ALWAYS(\"field.* ResolvedConstantsFoo => ResolvedConstantsFoo.a:I\"))\n@@ -82,4 +97,3 @@\n-            \/\/ Do not resolve field references to child classes\n-            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsFoo => ResolvedConstantsFoo.a:I\")\n-            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsFoo    ResolvedConstantsBar.a:I\")\n-            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsFoo    ResolvedConstantsBar.b:I\")\n+            \/\/ Resolve field references to child classes ONLY when using -XX:+AOTClassLinking\n+            .shouldMatch(AOTLINK_ONLY(\"field.* ResolvedConstantsFoo => ResolvedConstantsBar.a:I\"))\n+            .shouldMatch(AOTLINK_ONLY(\"field.* ResolvedConstantsFoo => ResolvedConstantsBar.b:I\"))\n@@ -87,3 +101,3 @@\n-            \/\/ Do not resolve field references to unrelated classes\n-            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsApp    ResolvedConstantsBar.a:I\")\n-            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsApp    ResolvedConstantsBar.b:I\")\n+            \/\/ Resolve field references to unrelated classes ONLY when using -XX:+AOTClassLinking\n+            .shouldMatch(AOTLINK_ONLY(\"field.* ResolvedConstantsApp => ResolvedConstantsBar.a:I\"))\n+            .shouldMatch(AOTLINK_ONLY(\"field.* ResolvedConstantsApp => ResolvedConstantsBar.b:I\"))\n@@ -94,1 +108,1 @@\n-            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp ResolvedConstantsApp.<init>:\")\n+            .shouldMatch(ALWAYS(\"method.* ResolvedConstantsApp ResolvedConstantsApp.<init>:\"))\n@@ -96,1 +110,1 @@\n-            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp java\/lang\/Object.<init>:\")\n+            .shouldMatch(ALWAYS(\"method.* ResolvedConstantsApp java\/lang\/Object.<init>:\"))\n@@ -99,1 +113,1 @@\n-            .shouldMatch(\"cds,resolve.*archived interface method .* ResolvedConstantsApp java\/lang\/Runnable.run:\")\n+            .shouldMatch(ALWAYS(\"interface method .* ResolvedConstantsApp java\/lang\/Runnable.run:\"))\n@@ -102,3 +116,3 @@\n-            .shouldMatch(\"archived method.*: ResolvedConstantsBar ResolvedConstantsBar.doBar:\")\n-            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.privateInstanceCall:\")\n-            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.publicInstanceCall:\")\n+            .shouldMatch(ALWAYS(\"method.*: ResolvedConstantsBar ResolvedConstantsBar.doBar:\"))\n+            .shouldMatch(ALWAYS(\"method.*: ResolvedConstantsApp ResolvedConstantsApp.privateInstanceCall:\"))\n+            .shouldMatch(ALWAYS(\"method.*: ResolvedConstantsApp ResolvedConstantsApp.publicInstanceCall:\"))\n@@ -107,1 +121,1 @@\n-            .shouldNotMatch(\" archived method CP entry.*: ResolvedConstantsApp ResolvedConstantsApp.staticCall:\")\n+            .shouldNotMatch(ALWAYS(\"method.*: ResolvedConstantsApp ResolvedConstantsApp.staticCall:\"))\n@@ -110,1 +124,1 @@\n-            .shouldMatch(\" archived method CP entry.*: ResolvedConstantsBar ResolvedConstantsFoo.doBar:\")\n+            .shouldMatch(ALWAYS(\"method.*: ResolvedConstantsBar ResolvedConstantsFoo.doBar:\"))\n@@ -112,1 +126,1 @@\n-            \/\/ App class cannot resolve references to methods in boot classes:\n+            \/\/ Without -XX:+AOTClassLinking App class cannot resolve references to methods in boot classes:\n@@ -117,4 +131,2 @@\n-            \/\/\n-            \/\/    This will be addressed in JDK-8315737.\n-            .shouldMatch(\"reverted method.*: ResolvedConstantsApp java\/io\/PrintStream.println:\")\n-            .shouldMatch(\"reverted method.*: ResolvedConstantsBar java\/lang\/Class.getName:\")\n+            .shouldMatch(AOTLINK_ONLY(\"method.*: ResolvedConstantsApp java\/io\/PrintStream.println:\"))\n+            .shouldMatch(AOTLINK_ONLY(\"method.*: ResolvedConstantsBar java\/lang\/Class.getName:\"))\n@@ -122,2 +134,2 @@\n-            \/\/ Should not resolve methods in unrelated classes.\n-            .shouldMatch(\"reverted method.*: ResolvedConstantsApp ResolvedConstantsBar.doit:\")\n+            \/\/ Resole resolve methods in unrelated classes ONLY when using -XX:+AOTClassLinking\n+            .shouldMatch(AOTLINK_ONLY(\"method.*: ResolvedConstantsApp ResolvedConstantsBar.doit:\"))\n@@ -128,0 +140,12 @@\n+\n+    static String ALWAYS(String s) {\n+        return \"cds,resolve.*archived \" + s;\n+    }\n+\n+    static String AOTLINK_ONLY(String s) {\n+        if (aotClassLinking) {\n+            return ALWAYS(s);\n+        } else {\n+            return \"cds,resolve.*reverted \" + s;\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":59,"deletions":35,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+        map.put(\"vm.cds.supports.aot.class.linking\", this::vmCDSSupportsAOTClassLinking);\n@@ -469,0 +470,8 @@\n+    \/**\n+     * @return true if this VM can support the -XX:AOTClassLinking option\n+     *\/\n+    protected String vmCDSSupportsAOTClassLinking() {\n+      \/\/ Currently, the VM supports AOTClassLinking as long as it's able to write archived java heap.\n+      return vmCDSCanWriteArchivedJavaHeap();\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jtreg.SkippedException;\n@@ -45,1 +46,1 @@\n-    private final String productionRunLog;\n+    private int numProductionRuns = 0;\n@@ -48,0 +49,4 @@\n+        if (CDSTestUtils.DYNAMIC_DUMP) {\n+            throw new jtreg.SkippedException(\"Tests based on CDSAppTester should be excluded when -Dtest.dynamic.cds.archive is specified\");\n+        }\n+\n@@ -56,1 +61,8 @@\n-        productionRunLog = name() + \".production.log\";\n+    }\n+\n+    private String productionRunLog() {\n+        if (numProductionRuns == 0) {\n+            return name() + \".production.log\";\n+        } else {\n+            return name() + \".production.\" + numProductionRuns + \".log\";\n+        }\n@@ -100,0 +112,5 @@\n+    private boolean checkExitValue = true;\n+\n+    public final void setCheckExitValue(boolean b) {\n+        checkExitValue = b;\n+    }\n@@ -137,1 +154,3 @@\n-        output.shouldHaveExitValue(0);\n+        if (checkExitValue) {\n+            output.shouldHaveExitValue(0);\n+        }\n@@ -192,0 +211,10 @@\n+        return productionRun(null, null);\n+    }\n+\n+    public OutputAnalyzer productionRun(String[] extraVmArgs) throws Exception {\n+        return productionRun(extraVmArgs, null);\n+    }\n+\n+    \/\/ After calling run(String[]), you can call this method to run the app again, with the AOTCache\n+    \/\/ using different args to the VM and application.\n+    public OutputAnalyzer productionRun(String[] extraVmArgs, String[] extraAppArgs) throws Exception {\n@@ -194,0 +223,2 @@\n+                                                   \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                   \"-XX:VerifyArchivedFields=2\", \/\/ make sure archived heap objects are good.\n@@ -195,1 +226,1 @@\n-                                                   logToFile(productionRunLog, \"cds\"));\n+                                                   logToFile(productionRunLog(), \"cds\"));\n@@ -203,0 +234,4 @@\n+        if (extraVmArgs != null) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, extraVmArgs);\n+        }\n+\n@@ -204,1 +239,8 @@\n-        return executeAndCheck(cmdLine, runMode, productionRunLog);\n+\n+        if (extraAppArgs != null) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, extraAppArgs);\n+        }\n+\n+        OutputAnalyzer out = executeAndCheck(cmdLine, runMode, productionRunLog());\n+        numProductionRuns ++;\n+        return out;\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":47,"deletions":5,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -862,0 +862,15 @@\n+\n+    \/\/ Some tests were initially written without the knowledge of -XX:+AOTClassLinking. These tests need to\n+    \/\/ be adjusted if -XX:+AOTClassLinking is specified in jtreg -vmoptions or -javaoptions:\n+    public static boolean isAOTClassLinkingEnabled() {\n+        String vmopts = System.getProperty(\"test.vm.opts\");\n+        String javaopts = System.getProperty(\"test.java.opts\");\n+        if (vmopts != null && vmopts.contains(\"-XX:+AOTClassLinking\")) {\n+            return true;\n+        }\n+        if (javaopts != null && javaopts.contains(\"-XX:+AOTClassLinking\")) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"}]}