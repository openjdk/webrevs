{"files":[{"patch":"@@ -1,691 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.net.http.hpack;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-\n-import static java.lang.String.format;\n-\n-\/**\n- * Huffman coding table.\n- *\n- * <p> Instances of this class are safe for use by multiple threads.\n- *\n- * @since 9\n- *\/\n-public final class NaiveHuffman {\n-\n-    \/\/ TODO: check if reset is done in both reader and writer\n-\n-    static final class Reader implements Huffman.Reader {\n-\n-        private Node curr; \/\/ position in the trie\n-        private int len;   \/\/ length of the path from the root to 'curr'\n-        private int p;     \/\/ byte probe\n-\n-        {\n-            reset();\n-        }\n-\n-        @Override\n-        public void read(ByteBuffer source,\n-                         Appendable destination,\n-                         boolean isLast) throws IOException {\n-            read(source, destination, true, isLast);\n-        }\n-\n-        \/\/ Takes 'isLast' rather than returns whether the reading is done or\n-        \/\/ not, for more informative exceptions.\n-        void read(ByteBuffer source,\n-                  Appendable destination,\n-                  boolean reportEOS, \/* reportEOS is exposed for tests *\/\n-                  boolean isLast) throws IOException {\n-            Node c = curr;\n-            int l = len;\n-            \/*\n-               Since ByteBuffer is itself stateful, its position is\n-               remembered here NOT as a part of Reader's state,\n-               but to set it back in the case of a failure\n-             *\/\n-            int pos = source.position();\n-\n-            while (source.hasRemaining()) {\n-                int d = source.get();\n-                for (; p != 0; p >>= 1) {\n-                    c = c.getChild(p & d);\n-                    l++;\n-                    if (c.isLeaf()) {\n-                        if (reportEOS && c.isEOSPath) {\n-                            throw new IOException(\"Encountered EOS\");\n-                        }\n-                        char ch;\n-                        try {\n-                            ch = c.getChar();\n-                        } catch (IllegalStateException e) {\n-                            source.position(pos); \/\/ do we need this?\n-                            throw new IOException(e);\n-                        }\n-                        try {\n-                            destination.append(ch);\n-                        } catch (IOException e) {\n-                            source.position(pos); \/\/ do we need this?\n-                            throw e;\n-                        }\n-                        c = INSTANCE.root;\n-                        l = 0;\n-                    }\n-                    curr = c;\n-                    len = l;\n-                }\n-                resetProbe();\n-                pos++;\n-            }\n-            if (!isLast) {\n-                return; \/\/ it's too early to jump to any conclusions, let's wait\n-            }\n-            if (c.isLeaf()) {\n-                return; \/\/ it's perfectly ok, no extra padding bits\n-            }\n-            if (c.isEOSPath && len <= 7) {\n-                return; \/\/ it's ok, some extra padding bits\n-            }\n-            if (c.isEOSPath) {\n-                throw new IOException(\n-                        \"Padding is too long (len=\" + len + \") \" +\n-                                \"or unexpected end of data\");\n-            }\n-            throw new IOException(\n-                    \"Not a EOS prefix padding or unexpected end of data\");\n-        }\n-\n-        @Override\n-        public void reset() {\n-            curr = INSTANCE.root;\n-            len = 0;\n-            resetProbe();\n-        }\n-\n-        private void resetProbe() {\n-            p = 0x80;\n-        }\n-    }\n-\n-    static final class Writer implements Huffman.Writer {\n-\n-        private int pos;       \/\/ position in 'source'\n-        private int avail = 8; \/\/ number of least significant bits available in 'curr'\n-        private int curr;      \/\/ next byte to put to the destination\n-        private int rem;       \/\/ number of least significant bits in 'code' yet to be processed\n-        private int code;      \/\/ current code being written\n-\n-        private CharSequence source;\n-        private int end;\n-\n-        @Override\n-        public Writer from(CharSequence input, int start, int end) {\n-            if (start < 0 || end < 0 || end > input.length() || start > end) {\n-                throw new IndexOutOfBoundsException(\n-                        String.format(\"input.length()=%s, start=%s, end=%s\",\n-                                      input.length(), start, end));\n-            }\n-            pos = start;\n-            this.end = end;\n-            this.source = input;\n-            return this;\n-        }\n-\n-        @Override\n-        public boolean write(ByteBuffer destination) {\n-            for (; pos < end; pos++) {\n-                if (rem == 0) {\n-                    Code desc = INSTANCE.codeOf(source.charAt(pos));\n-                    rem = desc.length;\n-                    code = desc.code;\n-                }\n-                while (rem > 0) {\n-                    if (rem < avail) {\n-                        curr |= (code << (avail - rem));\n-                        avail -= rem;\n-                        rem = 0;\n-                    } else {\n-                        int c = (curr | (code >>> (rem - avail)));\n-                        if (destination.hasRemaining()) {\n-                            destination.put((byte) c);\n-                        } else {\n-                            return false;\n-                        }\n-                        curr = c;\n-                        code <<= (32 - rem + avail);  \/\/ throw written bits off the cliff (is this Sparta?)\n-                        code >>>= (32 - rem + avail); \/\/ return to the position\n-                        rem -= avail;\n-                        curr = 0;\n-                        avail = 8;\n-                    }\n-                }\n-            }\n-\n-            if (avail < 8) { \/\/ have to pad\n-                if (destination.hasRemaining()) {\n-                    destination.put((byte) (curr | (INSTANCE.EOS.code >>> (INSTANCE.EOS.length - avail))));\n-                    avail = 8;\n-                } else {\n-                    return false;\n-                }\n-            }\n-\n-            return true;\n-        }\n-\n-        @Override\n-        public Writer reset() {\n-            source = null;\n-            end = -1;\n-            pos = -1;\n-            avail = 8;\n-            curr = 0;\n-            code = 0;\n-            return this;\n-        }\n-\n-        @Override\n-        public int lengthOf(CharSequence value, int start, int end) {\n-            return INSTANCE.lengthOf(value, start, end);\n-        }\n-    }\n-\n-    \/**\n-     * Shared instance.\n-     *\/\n-    public static final NaiveHuffman INSTANCE = new NaiveHuffman();\n-\n-    private final Code EOS = new Code(0x3fffffff, 30);\n-    private final Code[] codes = new Code[257];\n-    private final Node root = new Node() {\n-        @Override\n-        public String toString() { return \"root\"; }\n-    };\n-\n-    \/\/ TODO: consider builder and immutable trie\n-    private NaiveHuffman() {\n-        \/\/ @formatter:off\n-        addChar(0,   0x1ff8,     13);\n-        addChar(1,   0x7fffd8,   23);\n-        addChar(2,   0xfffffe2,  28);\n-        addChar(3,   0xfffffe3,  28);\n-        addChar(4,   0xfffffe4,  28);\n-        addChar(5,   0xfffffe5,  28);\n-        addChar(6,   0xfffffe6,  28);\n-        addChar(7,   0xfffffe7,  28);\n-        addChar(8,   0xfffffe8,  28);\n-        addChar(9,   0xffffea,   24);\n-        addChar(10,  0x3ffffffc, 30);\n-        addChar(11,  0xfffffe9,  28);\n-        addChar(12,  0xfffffea,  28);\n-        addChar(13,  0x3ffffffd, 30);\n-        addChar(14,  0xfffffeb,  28);\n-        addChar(15,  0xfffffec,  28);\n-        addChar(16,  0xfffffed,  28);\n-        addChar(17,  0xfffffee,  28);\n-        addChar(18,  0xfffffef,  28);\n-        addChar(19,  0xffffff0,  28);\n-        addChar(20,  0xffffff1,  28);\n-        addChar(21,  0xffffff2,  28);\n-        addChar(22,  0x3ffffffe, 30);\n-        addChar(23,  0xffffff3,  28);\n-        addChar(24,  0xffffff4,  28);\n-        addChar(25,  0xffffff5,  28);\n-        addChar(26,  0xffffff6,  28);\n-        addChar(27,  0xffffff7,  28);\n-        addChar(28,  0xffffff8,  28);\n-        addChar(29,  0xffffff9,  28);\n-        addChar(30,  0xffffffa,  28);\n-        addChar(31,  0xffffffb,  28);\n-        addChar(32,  0x14,        6);\n-        addChar(33,  0x3f8,      10);\n-        addChar(34,  0x3f9,      10);\n-        addChar(35,  0xffa,      12);\n-        addChar(36,  0x1ff9,     13);\n-        addChar(37,  0x15,        6);\n-        addChar(38,  0xf8,        8);\n-        addChar(39,  0x7fa,      11);\n-        addChar(40,  0x3fa,      10);\n-        addChar(41,  0x3fb,      10);\n-        addChar(42,  0xf9,        8);\n-        addChar(43,  0x7fb,      11);\n-        addChar(44,  0xfa,        8);\n-        addChar(45,  0x16,        6);\n-        addChar(46,  0x17,        6);\n-        addChar(47,  0x18,        6);\n-        addChar(48,  0x0,         5);\n-        addChar(49,  0x1,         5);\n-        addChar(50,  0x2,         5);\n-        addChar(51,  0x19,        6);\n-        addChar(52,  0x1a,        6);\n-        addChar(53,  0x1b,        6);\n-        addChar(54,  0x1c,        6);\n-        addChar(55,  0x1d,        6);\n-        addChar(56,  0x1e,        6);\n-        addChar(57,  0x1f,        6);\n-        addChar(58,  0x5c,        7);\n-        addChar(59,  0xfb,        8);\n-        addChar(60,  0x7ffc,     15);\n-        addChar(61,  0x20,        6);\n-        addChar(62,  0xffb,      12);\n-        addChar(63,  0x3fc,      10);\n-        addChar(64,  0x1ffa,     13);\n-        addChar(65,  0x21,        6);\n-        addChar(66,  0x5d,        7);\n-        addChar(67,  0x5e,        7);\n-        addChar(68,  0x5f,        7);\n-        addChar(69,  0x60,        7);\n-        addChar(70,  0x61,        7);\n-        addChar(71,  0x62,        7);\n-        addChar(72,  0x63,        7);\n-        addChar(73,  0x64,        7);\n-        addChar(74,  0x65,        7);\n-        addChar(75,  0x66,        7);\n-        addChar(76,  0x67,        7);\n-        addChar(77,  0x68,        7);\n-        addChar(78,  0x69,        7);\n-        addChar(79,  0x6a,        7);\n-        addChar(80,  0x6b,        7);\n-        addChar(81,  0x6c,        7);\n-        addChar(82,  0x6d,        7);\n-        addChar(83,  0x6e,        7);\n-        addChar(84,  0x6f,        7);\n-        addChar(85,  0x70,        7);\n-        addChar(86,  0x71,        7);\n-        addChar(87,  0x72,        7);\n-        addChar(88,  0xfc,        8);\n-        addChar(89,  0x73,        7);\n-        addChar(90,  0xfd,        8);\n-        addChar(91,  0x1ffb,     13);\n-        addChar(92,  0x7fff0,    19);\n-        addChar(93,  0x1ffc,     13);\n-        addChar(94,  0x3ffc,     14);\n-        addChar(95,  0x22,        6);\n-        addChar(96,  0x7ffd,     15);\n-        addChar(97,  0x3,         5);\n-        addChar(98,  0x23,        6);\n-        addChar(99,  0x4,         5);\n-        addChar(100, 0x24,        6);\n-        addChar(101, 0x5,         5);\n-        addChar(102, 0x25,        6);\n-        addChar(103, 0x26,        6);\n-        addChar(104, 0x27,        6);\n-        addChar(105, 0x6,         5);\n-        addChar(106, 0x74,        7);\n-        addChar(107, 0x75,        7);\n-        addChar(108, 0x28,        6);\n-        addChar(109, 0x29,        6);\n-        addChar(110, 0x2a,        6);\n-        addChar(111, 0x7,         5);\n-        addChar(112, 0x2b,        6);\n-        addChar(113, 0x76,        7);\n-        addChar(114, 0x2c,        6);\n-        addChar(115, 0x8,         5);\n-        addChar(116, 0x9,         5);\n-        addChar(117, 0x2d,        6);\n-        addChar(118, 0x77,        7);\n-        addChar(119, 0x78,        7);\n-        addChar(120, 0x79,        7);\n-        addChar(121, 0x7a,        7);\n-        addChar(122, 0x7b,        7);\n-        addChar(123, 0x7ffe,     15);\n-        addChar(124, 0x7fc,      11);\n-        addChar(125, 0x3ffd,     14);\n-        addChar(126, 0x1ffd,     13);\n-        addChar(127, 0xffffffc,  28);\n-        addChar(128, 0xfffe6,    20);\n-        addChar(129, 0x3fffd2,   22);\n-        addChar(130, 0xfffe7,    20);\n-        addChar(131, 0xfffe8,    20);\n-        addChar(132, 0x3fffd3,   22);\n-        addChar(133, 0x3fffd4,   22);\n-        addChar(134, 0x3fffd5,   22);\n-        addChar(135, 0x7fffd9,   23);\n-        addChar(136, 0x3fffd6,   22);\n-        addChar(137, 0x7fffda,   23);\n-        addChar(138, 0x7fffdb,   23);\n-        addChar(139, 0x7fffdc,   23);\n-        addChar(140, 0x7fffdd,   23);\n-        addChar(141, 0x7fffde,   23);\n-        addChar(142, 0xffffeb,   24);\n-        addChar(143, 0x7fffdf,   23);\n-        addChar(144, 0xffffec,   24);\n-        addChar(145, 0xffffed,   24);\n-        addChar(146, 0x3fffd7,   22);\n-        addChar(147, 0x7fffe0,   23);\n-        addChar(148, 0xffffee,   24);\n-        addChar(149, 0x7fffe1,   23);\n-        addChar(150, 0x7fffe2,   23);\n-        addChar(151, 0x7fffe3,   23);\n-        addChar(152, 0x7fffe4,   23);\n-        addChar(153, 0x1fffdc,   21);\n-        addChar(154, 0x3fffd8,   22);\n-        addChar(155, 0x7fffe5,   23);\n-        addChar(156, 0x3fffd9,   22);\n-        addChar(157, 0x7fffe6,   23);\n-        addChar(158, 0x7fffe7,   23);\n-        addChar(159, 0xffffef,   24);\n-        addChar(160, 0x3fffda,   22);\n-        addChar(161, 0x1fffdd,   21);\n-        addChar(162, 0xfffe9,    20);\n-        addChar(163, 0x3fffdb,   22);\n-        addChar(164, 0x3fffdc,   22);\n-        addChar(165, 0x7fffe8,   23);\n-        addChar(166, 0x7fffe9,   23);\n-        addChar(167, 0x1fffde,   21);\n-        addChar(168, 0x7fffea,   23);\n-        addChar(169, 0x3fffdd,   22);\n-        addChar(170, 0x3fffde,   22);\n-        addChar(171, 0xfffff0,   24);\n-        addChar(172, 0x1fffdf,   21);\n-        addChar(173, 0x3fffdf,   22);\n-        addChar(174, 0x7fffeb,   23);\n-        addChar(175, 0x7fffec,   23);\n-        addChar(176, 0x1fffe0,   21);\n-        addChar(177, 0x1fffe1,   21);\n-        addChar(178, 0x3fffe0,   22);\n-        addChar(179, 0x1fffe2,   21);\n-        addChar(180, 0x7fffed,   23);\n-        addChar(181, 0x3fffe1,   22);\n-        addChar(182, 0x7fffee,   23);\n-        addChar(183, 0x7fffef,   23);\n-        addChar(184, 0xfffea,    20);\n-        addChar(185, 0x3fffe2,   22);\n-        addChar(186, 0x3fffe3,   22);\n-        addChar(187, 0x3fffe4,   22);\n-        addChar(188, 0x7ffff0,   23);\n-        addChar(189, 0x3fffe5,   22);\n-        addChar(190, 0x3fffe6,   22);\n-        addChar(191, 0x7ffff1,   23);\n-        addChar(192, 0x3ffffe0,  26);\n-        addChar(193, 0x3ffffe1,  26);\n-        addChar(194, 0xfffeb,    20);\n-        addChar(195, 0x7fff1,    19);\n-        addChar(196, 0x3fffe7,   22);\n-        addChar(197, 0x7ffff2,   23);\n-        addChar(198, 0x3fffe8,   22);\n-        addChar(199, 0x1ffffec,  25);\n-        addChar(200, 0x3ffffe2,  26);\n-        addChar(201, 0x3ffffe3,  26);\n-        addChar(202, 0x3ffffe4,  26);\n-        addChar(203, 0x7ffffde,  27);\n-        addChar(204, 0x7ffffdf,  27);\n-        addChar(205, 0x3ffffe5,  26);\n-        addChar(206, 0xfffff1,   24);\n-        addChar(207, 0x1ffffed,  25);\n-        addChar(208, 0x7fff2,    19);\n-        addChar(209, 0x1fffe3,   21);\n-        addChar(210, 0x3ffffe6,  26);\n-        addChar(211, 0x7ffffe0,  27);\n-        addChar(212, 0x7ffffe1,  27);\n-        addChar(213, 0x3ffffe7,  26);\n-        addChar(214, 0x7ffffe2,  27);\n-        addChar(215, 0xfffff2,   24);\n-        addChar(216, 0x1fffe4,   21);\n-        addChar(217, 0x1fffe5,   21);\n-        addChar(218, 0x3ffffe8,  26);\n-        addChar(219, 0x3ffffe9,  26);\n-        addChar(220, 0xffffffd,  28);\n-        addChar(221, 0x7ffffe3,  27);\n-        addChar(222, 0x7ffffe4,  27);\n-        addChar(223, 0x7ffffe5,  27);\n-        addChar(224, 0xfffec,    20);\n-        addChar(225, 0xfffff3,   24);\n-        addChar(226, 0xfffed,    20);\n-        addChar(227, 0x1fffe6,   21);\n-        addChar(228, 0x3fffe9,   22);\n-        addChar(229, 0x1fffe7,   21);\n-        addChar(230, 0x1fffe8,   21);\n-        addChar(231, 0x7ffff3,   23);\n-        addChar(232, 0x3fffea,   22);\n-        addChar(233, 0x3fffeb,   22);\n-        addChar(234, 0x1ffffee,  25);\n-        addChar(235, 0x1ffffef,  25);\n-        addChar(236, 0xfffff4,   24);\n-        addChar(237, 0xfffff5,   24);\n-        addChar(238, 0x3ffffea,  26);\n-        addChar(239, 0x7ffff4,   23);\n-        addChar(240, 0x3ffffeb,  26);\n-        addChar(241, 0x7ffffe6,  27);\n-        addChar(242, 0x3ffffec,  26);\n-        addChar(243, 0x3ffffed,  26);\n-        addChar(244, 0x7ffffe7,  27);\n-        addChar(245, 0x7ffffe8,  27);\n-        addChar(246, 0x7ffffe9,  27);\n-        addChar(247, 0x7ffffea,  27);\n-        addChar(248, 0x7ffffeb,  27);\n-        addChar(249, 0xffffffe,  28);\n-        addChar(250, 0x7ffffec,  27);\n-        addChar(251, 0x7ffffed,  27);\n-        addChar(252, 0x7ffffee,  27);\n-        addChar(253, 0x7ffffef,  27);\n-        addChar(254, 0x7fffff0,  27);\n-        addChar(255, 0x3ffffee,  26);\n-        addEOS (256, EOS.code,   EOS.length);\n-        \/\/ @formatter:on\n-    }\n-\n-\n-    \/**\n-     * Calculates the number of bytes required to represent the given {@code\n-     * CharSequence} with the Huffman coding.\n-     *\n-     * @param value\n-     *         characters\n-     *\n-     * @return number of bytes\n-     *\n-     * @throws NullPointerException\n-     *         if the value is null\n-     *\/\n-    public int lengthOf(CharSequence value) {\n-        return lengthOf(value, 0, value.length());\n-    }\n-\n-    \/**\n-     * Calculates the number of bytes required to represent a subsequence of the\n-     * given {@code CharSequence} with the Huffman coding.\n-     *\n-     * @param value\n-     *         characters\n-     * @param start\n-     *         the start index, inclusive\n-     * @param end\n-     *         the end index, exclusive\n-     *\n-     * @return number of bytes\n-     *\n-     * @throws NullPointerException\n-     *         if the value is null\n-     * @throws IndexOutOfBoundsException\n-     *         if any invocation of {@code value.charAt(i)}, where\n-     *         {@code start <= i < end} would throw an IndexOutOfBoundsException\n-     *\/\n-    public int lengthOf(CharSequence value, int start, int end) {\n-        int len = 0;\n-        for (int i = start; i < end; i++) {\n-            char c = value.charAt(i);\n-            len += INSTANCE.codeOf(c).length;\n-        }\n-        \/\/ Integer division with ceiling, assumption:\n-        assert (len \/ 8 + (len % 8 != 0 ? 1 : 0)) == (len + 7) \/ 8 : len;\n-        return (len + 7) \/ 8;\n-    }\n-\n-    private void addChar(int c, int code, int bitLength) {\n-        addLeaf(c, code, bitLength, false);\n-        codes[c] = new Code(code, bitLength);\n-    }\n-\n-    private void addEOS(int c, int code, int bitLength) {\n-        addLeaf(c, code, bitLength, true);\n-        codes[c] = new Code(code, bitLength);\n-    }\n-\n-    private void addLeaf(int c, int code, int bitLength, boolean isEOS) {\n-        if (bitLength < 1) {\n-            throw new IllegalArgumentException(\"bitLength < 1\");\n-        }\n-        Node curr = root;\n-        for (int p = 1 << bitLength - 1; p != 0 && !curr.isLeaf(); p = p >> 1) {\n-            curr.isEOSPath |= isEOS; \/\/ If it's already true, it can't become false\n-            curr = curr.addChildIfAbsent(p & code);\n-        }\n-        curr.isEOSPath |= isEOS; \/\/ The last one needs to have this property as well\n-        if (curr.isLeaf()) {\n-            throw new IllegalStateException(\"Specified code is already taken\");\n-        }\n-        curr.setChar((char) c);\n-    }\n-\n-    private Code codeOf(char c) {\n-        if (c > 255) {\n-            throw new IllegalArgumentException(\"char=\" + ((int) c));\n-        }\n-        return codes[c];\n-    }\n-\n-    \/\/\n-    \/\/ For debugging\/testing purposes\n-    \/\/\n-    Node getRoot() {\n-        return root;\n-    }\n-\n-    \/\/\n-    \/\/ Guarantees:\n-    \/\/\n-    \/\/  if (isLeaf() == true) => getChar() is a legal call\n-    \/\/  if (isLeaf() == false) => getChild(i) is a legal call (though it can\n-    \/\/                                                           return null)\n-    \/\/\n-    static class Node {\n-\n-        Node left;\n-        Node right;\n-        boolean isEOSPath;\n-\n-        boolean charIsSet;\n-        char c;\n-\n-        Node getChild(int selector) {\n-            if (isLeaf()) {\n-                throw new IllegalStateException(\"This is a leaf node\");\n-            }\n-            Node result = selector == 0 ? left : right;\n-            if (result == null) {\n-                throw new IllegalStateException(format(\n-                        \"Node doesn't have a child (selector=%s)\", selector));\n-            }\n-            return result;\n-        }\n-\n-        boolean isLeaf() {\n-            return charIsSet;\n-        }\n-\n-        char getChar() {\n-            if (!isLeaf()) {\n-                throw new IllegalStateException(\"This node is not a leaf node\");\n-            }\n-            return c;\n-        }\n-\n-        void setChar(char c) {\n-            if (charIsSet) {\n-                throw new IllegalStateException(\n-                        \"This node has been taken already\");\n-            }\n-            if (left != null || right != null) {\n-                throw new IllegalStateException(\"The node cannot be made \"\n-                                                        + \"a leaf as it's already has a child\");\n-            }\n-            this.c = c;\n-            charIsSet = true;\n-        }\n-\n-        Node addChildIfAbsent(int i) {\n-            if (charIsSet) {\n-                throw new IllegalStateException(\"The node cannot have a child \"\n-                                                        + \"as it's already a leaf node\");\n-            }\n-            Node child;\n-            if (i == 0) {\n-                if ((child = left) == null) {\n-                    child = left = new Node();\n-                }\n-            } else {\n-                if ((child = right) == null) {\n-                    child = right = new Node();\n-                }\n-            }\n-            return child;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            if (isLeaf()) {\n-                if (isEOSPath) {\n-                    return \"EOS\";\n-                } else {\n-                    return format(\"char: (%3s) '%s'\", (int) c, c);\n-                }\n-            }\n-            return \"\/\\\\\";\n-        }\n-    }\n-\n-    \/\/ TODO: value-based class?\n-    \/\/ FIXME: can we re-use Node instead of this class?\n-    private static final class Code {\n-\n-        final int code;\n-        final int length;\n-\n-        private Code(int code, int length) {\n-            this.code = code;\n-            this.length = length;\n-        }\n-\n-        public int getCode() {\n-            return code;\n-        }\n-\n-        public int getLength() {\n-            return length;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            long p = 1 << length;\n-            return Long.toBinaryString(code + p).substring(1)\n-                    + \", length=\" + length;\n-        }\n-    }\n-}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/hpack\/NaiveHuffman.java","additions":0,"deletions":691,"binary":false,"changes":691,"status":"deleted"}]}