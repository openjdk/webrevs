{"files":[{"patch":"@@ -0,0 +1,604 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n+import com.sun.tools.javac.code.*;\n+import com.sun.tools.javac.tree.*;\n+import com.sun.tools.javac.util.*;\n+\n+import com.sun.tools.javac.code.Symbol.*;\n+import com.sun.tools.javac.tree.JCTree.*;\n+\n+import com.sun.tools.javac.code.Kinds.Kind;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+\/** A class to compute exhaustiveness of set of switch cases.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class ExhaustivenessComputer {\n+    protected static final Context.Key<ExhaustivenessComputer> exhaustivenessKey = new Context.Key<>();\n+\n+    private final Symtab syms;\n+    private final Types types;\n+    private final Check chk;\n+    private final Infer infer;\n+\n+    public static ExhaustivenessComputer instance(Context context) {\n+        ExhaustivenessComputer instance = context.get(exhaustivenessKey);\n+        if (instance == null)\n+            instance = new ExhaustivenessComputer(context);\n+        return instance;\n+    }\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected ExhaustivenessComputer(Context context) {\n+        context.put(exhaustivenessKey, this);\n+        syms = Symtab.instance(context);\n+        types = Types.instance(context);\n+        chk = Check.instance(context);\n+        infer = Infer.instance(context);\n+    }\n+\n+    public boolean exhausts(JCExpression selector, List<JCCase> cases) {\n+        Set<PatternDescription> patternSet = new HashSet<>();\n+        Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n+        Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n+        for (JCCase c : cases) {\n+            if (!TreeInfo.unguardedCase(c))\n+                continue;\n+\n+            for (var l : c.labels) {\n+                if (l instanceof JCPatternCaseLabel patternLabel) {\n+                    for (Type component : components(selector.type)) {\n+                        patternSet.add(makePatternDescription(component, patternLabel.pat));\n+                    }\n+                } else if (l instanceof JCConstantCaseLabel constantLabel) {\n+                    if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n+                        Object value = ((JCLiteral) constantLabel.expr).value;\n+                        booleanLiterals.remove(value);\n+                    } else {\n+                        Symbol s = TreeInfo.symbol(constantLabel.expr);\n+                        if (s != null && s.isEnum()) {\n+                            enum2Constants.computeIfAbsent(s.owner, x -> {\n+                                Set<Symbol> result = new HashSet<>();\n+                                s.owner.members()\n+                                        .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n+                                        .forEach(result::add);\n+                                return result;\n+                            }).remove(s);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n+            return true;\n+        }\n+\n+        for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n+            if (e.getValue().isEmpty()) {\n+                patternSet.add(new BindingPattern(e.getKey().type));\n+            }\n+        }\n+        Set<PatternDescription> patterns = patternSet;\n+        boolean useHashes = true;\n+        try {\n+            boolean repeat = true;\n+            while (repeat) {\n+                Set<PatternDescription> updatedPatterns;\n+                updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n+                updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n+                updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+                repeat = !updatedPatterns.equals(patterns);\n+                if (checkCovered(selector.type, patterns)) {\n+                    return true;\n+                }\n+                if (!repeat) {\n+                    \/\/there may be situation like:\n+                    \/\/class B permits S1, S2\n+                    \/\/patterns: R(S1, B), R(S2, S2)\n+                    \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n+                    \/\/but hashing in reduceNestedPatterns will not allow that\n+                    \/\/disable the use of hashing, and use subtyping in\n+                    \/\/reduceNestedPatterns to handle situations like this:\n+                    repeat = useHashes;\n+                    useHashes = false;\n+                } else {\n+                    \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n+                    \/\/is enabled, as the hashing speeds up the process significantly:\n+                    useHashes = true;\n+                }\n+                patterns = updatedPatterns;\n+            }\n+            return checkCovered(selector.type, patterns);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(selector.pos(), cf);\n+            return true; \/\/error recovery\n+        }\n+    }\n+\n+    private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n+        for (Type seltypeComponent : components(seltype)) {\n+            for (PatternDescription pd : patterns) {\n+                if(isBpCovered(seltypeComponent, pd)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private List<Type> components(Type seltype) {\n+        return switch (seltype.getTag()) {\n+            case CLASS -> {\n+                if (seltype.isCompound()) {\n+                    if (seltype.isIntersection()) {\n+                        yield ((Type.IntersectionClassType) seltype).getComponents()\n+                                                                    .stream()\n+                                                                    .flatMap(t -> components(t).stream())\n+                                                                    .collect(List.collector());\n+                    }\n+                    yield List.nil();\n+                }\n+                yield List.of(types.erasure(seltype));\n+            }\n+            case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n+            default -> List.of(types.erasure(seltype));\n+        };\n+    }\n+\n+    \/* In a set of patterns, search for a sub-set of binding patterns that\n+     * in combination exhaust their sealed supertype. If such a sub-set\n+     * is found, it is removed, and replaced with a binding pattern\n+     * for the sealed supertype.\n+     *\/\n+    private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n+        Set<Symbol> existingBindings = patterns.stream()\n+                                               .filter(pd -> pd instanceof BindingPattern)\n+                                               .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                               .collect(Collectors.toSet());\n+\n+        for (PatternDescription pdOne : patterns) {\n+            if (pdOne instanceof BindingPattern bpOne) {\n+                Set<PatternDescription> toAdd = new HashSet<>();\n+\n+                for (Type sup : types.directSupertypes(bpOne.type)) {\n+                    ClassSymbol clazz = (ClassSymbol) types.erasure(sup).tsym;\n+\n+                    clazz.complete();\n+\n+                    if (clazz.isSealed() && clazz.isAbstract() &&\n+                        \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n+                        !existingBindings.contains(clazz)) {\n+                        ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n+                        \/\/do not reduce to types unrelated to the selector type:\n+                        Type clazzErasure = types.erasure(clazz.type);\n+                        if (components(selectorType).stream()\n+                                                    .map(types::erasure)\n+                                                    .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                            continue;\n+                        }\n+\n+                        Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n+                            Type instantiated;\n+                            if (csym.type.allparams().isEmpty()) {\n+                                instantiated = csym.type;\n+                            } else {\n+                                instantiated = infer.instantiatePatternType(selectorType, csym);\n+                            }\n+\n+                            return instantiated != null && types.isCastable(selectorType, instantiated);\n+                        });\n+\n+                        for (PatternDescription pdOther : patterns) {\n+                            if (pdOther instanceof BindingPattern bpOther) {\n+                                Set<Symbol> currentPermittedSubTypes =\n+                                        allPermittedSubTypes(bpOther.type.tsym, s -> true);\n+\n+                                PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n+                                    Symbol perm = it.next();\n+\n+                                    for (Symbol currentPermitted : currentPermittedSubTypes) {\n+                                        if (types.isSubtype(types.erasure(currentPermitted.type),\n+                                                            types.erasure(perm.type))) {\n+                                            it.remove();\n+                                            continue PERMITTED;\n+                                        }\n+                                    }\n+                                    if (types.isSubtype(types.erasure(perm.type),\n+                                                        types.erasure(bpOther.type))) {\n+                                        it.remove();\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                        if (permitted.isEmpty()) {\n+                            toAdd.add(new BindingPattern(clazz.type));\n+                        }\n+                    }\n+                }\n+\n+                if (!toAdd.isEmpty()) {\n+                    Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n+                    newPatterns.addAll(toAdd);\n+                    return newPatterns;\n+                }\n+            }\n+        }\n+        return patterns;\n+    }\n+\n+    private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n+        Set<Symbol> permitted = new HashSet<>();\n+        List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n+\n+        while (permittedSubtypesClosure.nonEmpty()) {\n+            ClassSymbol current = permittedSubtypesClosure.head;\n+\n+            permittedSubtypesClosure = permittedSubtypesClosure.tail;\n+\n+            current.complete();\n+\n+            if (current.isSealed() && current.isAbstract()) {\n+                for (Type t : current.getPermittedSubclasses()) {\n+                    ClassSymbol csym = (ClassSymbol) t.tsym;\n+\n+                    if (accept.test(csym)) {\n+                        permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n+                        permitted.add(csym);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return permitted;\n+    }\n+\n+    private List<ClassSymbol> baseClasses(TypeSymbol root) {\n+        if (root instanceof ClassSymbol clazz) {\n+            return List.of(clazz);\n+        } else if (root instanceof TypeVariableSymbol tvar) {\n+            ListBuffer<ClassSymbol> result = new ListBuffer<>();\n+            for (Type bound : tvar.getBounds()) {\n+                result.appendList(baseClasses(bound.tsym));\n+            }\n+            return result.toList();\n+        } else {\n+            return List.nil();\n+        }\n+    }\n+\n+    \/* Among the set of patterns, find sub-set of patterns such:\n+     * $record($prefix$, $nested, $suffix$)\n+     * Where $record, $prefix$ and $suffix$ is the same for each pattern\n+     * in the set, and the patterns only differ in one \"column\" in\n+     * the $nested pattern.\n+     * Then, the set of $nested patterns is taken, and passed recursively\n+     * to reduceNestedPatterns and to reduceBindingPatterns, to\n+     * simplify the pattern. If that succeeds, the original found sub-set\n+     * of patterns is replaced with a new set of patterns of the form:\n+     * $record($prefix$, $resultOfReduction, $suffix$)\n+     *\n+     * useHashes: when true, patterns will be subject to exact equivalence;\n+     *            when false, two binding patterns will be considered equivalent\n+     *            if one of them is more generic than the other one;\n+     *            when false, the processing will be significantly slower,\n+     *            as pattern hashes cannot be used to speed up the matching process\n+     *\/\n+    private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n+                                                         boolean useHashes) {\n+        \/* implementation note:\n+         * finding a sub-set of patterns that only differ in a single\n+         * column is time-consuming task, so this method speeds it up by:\n+         * - group the patterns by their record class\n+         * - for each column (nested pattern) do:\n+         * -- group patterns by their hash\n+         * -- in each such by-hash group, find sub-sets that only differ in\n+         *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n+         *    on patterns in the chosen column, as described above\n+         *\/\n+        var groupByRecordClass =\n+                patterns.stream()\n+                        .filter(pd -> pd instanceof RecordPattern)\n+                        .map(pd -> (RecordPattern) pd)\n+                        .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n+\n+        for (var e : groupByRecordClass.entrySet()) {\n+            int nestedPatternsCount = e.getKey().getRecordComponents().size();\n+            Set<RecordPattern> current = new HashSet<>(e.getValue());\n+\n+            for (int mismatchingCandidate = 0;\n+                 mismatchingCandidate < nestedPatternsCount;\n+                 mismatchingCandidate++) {\n+                int mismatchingCandidateFin = mismatchingCandidate;\n+                var groupEquivalenceCandidates =\n+                        current\n+                         .stream()\n+                         \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+                         .filter(pd -> pd.nested.length == nestedPatternsCount)\n+                         .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n+                for (var candidates : groupEquivalenceCandidates.values()) {\n+                    var candidatesArr = candidates.toArray(RecordPattern[]::new);\n+\n+                    for (int firstCandidate = 0;\n+                         firstCandidate < candidatesArr.length;\n+                         firstCandidate++) {\n+                        RecordPattern rpOne = candidatesArr[firstCandidate];\n+                        ListBuffer<RecordPattern> join = new ListBuffer<>();\n+\n+                        join.append(rpOne);\n+\n+                        NEXT_PATTERN: for (int nextCandidate = 0;\n+                                           nextCandidate < candidatesArr.length;\n+                                           nextCandidate++) {\n+                            if (firstCandidate == nextCandidate) {\n+                                continue;\n+                            }\n+\n+                            RecordPattern rpOther = candidatesArr[nextCandidate];\n+                            if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n+                                for (int i = 0; i < rpOne.nested.length; i++) {\n+                                    if (i != mismatchingCandidate) {\n+                                        if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n+                                            if (useHashes ||\n+                                                \/\/when not using hashes,\n+                                                \/\/check if rpOne.nested[i] is\n+                                                \/\/a subtype of rpOther.nested[i]:\n+                                                !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n+                                                !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n+                                                !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n+                                                continue NEXT_PATTERN;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                join.append(rpOther);\n+                            }\n+                        }\n+\n+                        var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n+                        var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n+\n+                        updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+                        updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+                        updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n+\n+                        if (!nestedPatterns.equals(updatedPatterns)) {\n+                            if (useHashes) {\n+                                current.removeAll(join);\n+                            }\n+\n+                            for (PatternDescription nested : updatedPatterns) {\n+                                PatternDescription[] newNested =\n+                                        Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                                newNested[mismatchingCandidateFin] = nested;\n+                                current.add(new RecordPattern(rpOne.recordType(),\n+                                                                rpOne.fullComponentTypes(),\n+                                                                newNested));\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (!current.equals(new HashSet<>(e.getValue()))) {\n+                Set<PatternDescription> result = new HashSet<>(patterns);\n+                result.removeAll(e.getValue());\n+                result.addAll(current);\n+                return result;\n+            }\n+        }\n+        return patterns;\n+    }\n+\n+    \/* In the set of patterns, find those for which, given:\n+     * $record($nested1, $nested2, ...)\n+     * all the $nestedX pattern cover the given record component,\n+     * and replace those with a simple binding pattern over $record.\n+     *\/\n+    private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n+        var newPatterns = new HashSet<PatternDescription>();\n+        boolean modified = false;\n+        for (PatternDescription pd : patterns) {\n+            if (pd instanceof RecordPattern rpOne) {\n+                PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n+                if (reducedPattern != rpOne) {\n+                    newPatterns.add(reducedPattern);\n+                    modified = true;\n+                    continue;\n+                }\n+            }\n+            newPatterns.add(pd);\n+        }\n+        return modified ? newPatterns : patterns;\n+    }\n+\n+    private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n+        if (pattern instanceof RecordPattern rpOne) {\n+            Type[] componentType = rpOne.fullComponentTypes();\n+            \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+            if (componentType.length != rpOne.nested.length) {\n+                return pattern;\n+            }\n+            PatternDescription[] reducedNestedPatterns = null;\n+            boolean covered = true;\n+            for (int i = 0; i < componentType.length; i++) {\n+                PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n+                if (newNested != rpOne.nested[i]) {\n+                    if (reducedNestedPatterns == null) {\n+                        reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                    }\n+                    reducedNestedPatterns[i] = newNested;\n+                }\n+\n+                covered &= checkCovered(componentType[i], List.of(newNested));\n+            }\n+            if (covered) {\n+                return new BindingPattern(rpOne.recordType);\n+            } else if (reducedNestedPatterns != null) {\n+                return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+            }\n+        }\n+        return pattern;\n+    }\n+\n+    private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n+        Set<Symbol> existingBindings = patterns.stream()\n+                                               .filter(pd -> pd instanceof BindingPattern)\n+                                               .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                               .collect(Collectors.toSet());\n+        Set<PatternDescription> result = new HashSet<>(patterns);\n+\n+        for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n+            PatternDescription pd = it.next();\n+            if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n+                it.remove();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n+        if (newNested instanceof BindingPattern bp) {\n+            Type seltype = types.erasure(componentType);\n+            Type pattype = types.erasure(bp.type);\n+\n+            return seltype.isPrimitive() ?\n+                    types.isUnconditionallyExact(seltype, pattype) :\n+                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n+        }\n+        return false;\n+    }\n+\n+    sealed interface PatternDescription { }\n+    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n+        if (pattern instanceof JCBindingPattern binding) {\n+            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n+                    ? selectorType : binding.type;\n+            return new BindingPattern(type);\n+        } else if (pattern instanceof JCRecordPattern record) {\n+            Type[] componentTypes;\n+\n+            if (!record.type.isErroneous()) {\n+                componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n+                        .map(r -> types.memberType(record.type, r))\n+                        .toArray(s -> new Type[s]);\n+            }\n+            else {\n+                componentTypes = record.nested.map(t -> types.createErrorType(t.type)).toArray(s -> new Type[s]);;\n+            }\n+\n+            PatternDescription[] nestedDescriptions =\n+                    new PatternDescription[record.nested.size()];\n+            int i = 0;\n+            for (List<JCPattern> it = record.nested;\n+                 it.nonEmpty();\n+                 it = it.tail, i++) {\n+                Type componentType = i < componentTypes.length ? componentTypes[i]\n+                                                               : syms.errType;\n+                nestedDescriptions[i] = makePatternDescription(types.erasure(componentType), it.head);\n+            }\n+            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n+        } else if (pattern instanceof JCAnyPattern) {\n+            return new BindingPattern(selectorType);\n+        } else {\n+            throw Assert.error();\n+        }\n+    }\n+    record BindingPattern(Type type) implements PatternDescription {\n+        @Override\n+        public int hashCode() {\n+            return type.tsym.hashCode();\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof BindingPattern other &&\n+                    type.tsym == other.type.tsym;\n+        }\n+        @Override\n+        public String toString() {\n+            return type.tsym + \" _\";\n+        }\n+    }\n+    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+\n+        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n+            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return _hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof RecordPattern other &&\n+                    recordType.tsym == other.recordType.tsym &&\n+                    Arrays.equals(nested, other.nested);\n+        }\n+\n+        public int hashCode(int excludeComponent) {\n+            return hashCode(excludeComponent, recordType, nested);\n+        }\n+\n+        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n+            int hash = 5;\n+            hash =  41 * hash + recordType.tsym.hashCode();\n+            for (int  i = 0; i < nested.length; i++) {\n+                if (i != excludeComponent) {\n+                    hash = 41 * hash + nested[i].hashCode();\n+                }\n+            }\n+            return hash;\n+        }\n+        @Override\n+        public String toString() {\n+            return recordType.tsym + \"(\" + Arrays.stream(nested)\n+                    .map(pd -> pd.toString())\n+                    .collect(Collectors.joining(\", \")) + \")\";\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":604,"deletions":0,"binary":false,"changes":604,"status":"added"},{"patch":"@@ -30,2 +30,0 @@\n-import java.util.Map;\n-import java.util.Map.Entry;\n@@ -33,2 +31,0 @@\n-import java.util.HashSet;\n-import java.util.Set;\n@@ -54,1 +50,0 @@\n-import com.sun.tools.javac.code.Kinds.Kind;\n@@ -56,1 +51,0 @@\n-import com.sun.tools.javac.code.Type.TypeVar;\n@@ -62,6 +56,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import static java.util.stream.Collectors.groupingBy;\n@@ -216,0 +204,1 @@\n+    private final ExhaustivenessComputer exhaustiveness;\n@@ -217,1 +206,0 @@\n-    private final Infer infer;\n@@ -339,1 +327,0 @@\n-        infer = Infer.instance(context);\n@@ -342,1 +329,1 @@\n-        Source source = Source.instance(context);\n+        exhaustiveness = ExhaustivenessComputer.instance(context);\n@@ -712,1 +699,1 @@\n-                tree.isExhaustive |= exhausts(tree.selector, tree.cases);\n+                tree.isExhaustive |= exhaustiveness.exhausts(tree.selector, tree.cases);\n@@ -751,1 +738,1 @@\n-                tree.isExhaustive = exhausts(tree.selector, tree.cases);\n+                tree.isExhaustive = exhaustiveness.exhausts(tree.selector, tree.cases);\n@@ -761,423 +748,0 @@\n-        private boolean exhausts(JCExpression selector, List<JCCase> cases) {\n-            Set<PatternDescription> patternSet = new HashSet<>();\n-            Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n-            Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n-            for (JCCase c : cases) {\n-                if (!TreeInfo.unguardedCase(c))\n-                    continue;\n-\n-                for (var l : c.labels) {\n-                    if (l instanceof JCPatternCaseLabel patternLabel) {\n-                        for (Type component : components(selector.type)) {\n-                            patternSet.add(makePatternDescription(component, patternLabel.pat));\n-                        }\n-                    } else if (l instanceof JCConstantCaseLabel constantLabel) {\n-                        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n-                            Object value = ((JCLiteral) constantLabel.expr).value;\n-                            booleanLiterals.remove(value);\n-                        } else {\n-                            Symbol s = TreeInfo.symbol(constantLabel.expr);\n-                            if (s != null && s.isEnum()) {\n-                                enum2Constants.computeIfAbsent(s.owner, x -> {\n-                                    Set<Symbol> result = new HashSet<>();\n-                                    s.owner.members()\n-                                            .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n-                                            .forEach(result::add);\n-                                    return result;\n-                                }).remove(s);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n-            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n-                return true;\n-            }\n-\n-            for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n-                if (e.getValue().isEmpty()) {\n-                    patternSet.add(new BindingPattern(e.getKey().type));\n-                }\n-            }\n-            Set<PatternDescription> patterns = patternSet;\n-            boolean useHashes = true;\n-            try {\n-                boolean repeat = true;\n-                while (repeat) {\n-                    Set<PatternDescription> updatedPatterns;\n-                    updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n-                    updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n-                    updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                    updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                    repeat = !updatedPatterns.equals(patterns);\n-                    if (checkCovered(selector.type, patterns)) {\n-                        return true;\n-                    }\n-                    if (!repeat) {\n-                        \/\/there may be situation like:\n-                        \/\/class B permits S1, S2\n-                        \/\/patterns: R(S1, B), R(S2, S2)\n-                        \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n-                        \/\/but hashing in reduceNestedPatterns will not allow that\n-                        \/\/disable the use of hashing, and use subtyping in\n-                        \/\/reduceNestedPatterns to handle situations like this:\n-                        repeat = useHashes;\n-                        useHashes = false;\n-                    } else {\n-                        \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n-                        \/\/is enabled, as the hashing speeds up the process significantly:\n-                        useHashes = true;\n-                    }\n-                    patterns = updatedPatterns;\n-                }\n-                return checkCovered(selector.type, patterns);\n-            } catch (CompletionFailure cf) {\n-                chk.completionError(selector.pos(), cf);\n-                return true; \/\/error recovery\n-            }\n-        }\n-\n-        private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n-            for (Type seltypeComponent : components(seltype)) {\n-                for (PatternDescription pd : patterns) {\n-                    if(isBpCovered(seltypeComponent, pd)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        }\n-\n-        private List<Type> components(Type seltype) {\n-            return switch (seltype.getTag()) {\n-                case CLASS -> {\n-                    if (seltype.isCompound()) {\n-                        if (seltype.isIntersection()) {\n-                            yield ((Type.IntersectionClassType) seltype).getComponents()\n-                                                                        .stream()\n-                                                                        .flatMap(t -> components(t).stream())\n-                                                                        .collect(List.collector());\n-                        }\n-                        yield List.nil();\n-                    }\n-                    yield List.of(types.erasure(seltype));\n-                }\n-                case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n-                default -> List.of(types.erasure(seltype));\n-            };\n-        }\n-\n-        \/* In a set of patterns, search for a sub-set of binding patterns that\n-         * in combination exhaust their sealed supertype. If such a sub-set\n-         * is found, it is removed, and replaced with a binding pattern\n-         * for the sealed supertype.\n-         *\/\n-        private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n-            Set<Symbol> existingBindings = patterns.stream()\n-                                                   .filter(pd -> pd instanceof BindingPattern)\n-                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n-                                                   .collect(Collectors.toSet());\n-\n-            for (PatternDescription pdOne : patterns) {\n-                if (pdOne instanceof BindingPattern bpOne) {\n-                    Set<PatternDescription> toAdd = new HashSet<>();\n-\n-                    for (Type sup : types.directSupertypes(bpOne.type)) {\n-                        ClassSymbol clazz = (ClassSymbol) types.erasure(sup).tsym;\n-\n-                        clazz.complete();\n-\n-                        if (clazz.isSealed() && clazz.isAbstract() &&\n-                            \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n-                            !existingBindings.contains(clazz)) {\n-                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n-                            \/\/do not reduce to types unrelated to the selector type:\n-                            Type clazzErasure = types.erasure(clazz.type);\n-                            if (components(selectorType).stream()\n-                                                        .map(types::erasure)\n-                                                        .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n-                                continue;\n-                            }\n-\n-                            Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n-                                Type instantiated;\n-                                if (csym.type.allparams().isEmpty()) {\n-                                    instantiated = csym.type;\n-                                } else {\n-                                    instantiated = infer.instantiatePatternType(selectorType, csym);\n-                                }\n-\n-                                return instantiated != null && types.isCastable(selectorType, instantiated);\n-                            });\n-\n-                            for (PatternDescription pdOther : patterns) {\n-                                if (pdOther instanceof BindingPattern bpOther) {\n-                                    Set<Symbol> currentPermittedSubTypes =\n-                                            allPermittedSubTypes(bpOther.type.tsym, s -> true);\n-\n-                                    PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n-                                        Symbol perm = it.next();\n-\n-                                        for (Symbol currentPermitted : currentPermittedSubTypes) {\n-                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n-                                                                types.erasure(perm.type))) {\n-                                                it.remove();\n-                                                continue PERMITTED;\n-                                            }\n-                                        }\n-                                        if (types.isSubtype(types.erasure(perm.type),\n-                                                            types.erasure(bpOther.type))) {\n-                                            it.remove();\n-                                        }\n-                                    }\n-                                }\n-                            }\n-\n-                            if (permitted.isEmpty()) {\n-                                toAdd.add(new BindingPattern(clazz.type));\n-                            }\n-                        }\n-                    }\n-\n-                    if (!toAdd.isEmpty()) {\n-                        Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n-                        newPatterns.addAll(toAdd);\n-                        return newPatterns;\n-                    }\n-                }\n-            }\n-            return patterns;\n-        }\n-\n-        private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n-            Set<Symbol> permitted = new HashSet<>();\n-            List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n-\n-            while (permittedSubtypesClosure.nonEmpty()) {\n-                ClassSymbol current = permittedSubtypesClosure.head;\n-\n-                permittedSubtypesClosure = permittedSubtypesClosure.tail;\n-\n-                current.complete();\n-\n-                if (current.isSealed() && current.isAbstract()) {\n-                    for (Type t : current.getPermittedSubclasses()) {\n-                        ClassSymbol csym = (ClassSymbol) t.tsym;\n-\n-                        if (accept.test(csym)) {\n-                            permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n-                            permitted.add(csym);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            return permitted;\n-        }\n-\n-        private List<ClassSymbol> baseClasses(TypeSymbol root) {\n-            if (root instanceof ClassSymbol clazz) {\n-                return List.of(clazz);\n-            } else if (root instanceof TypeVariableSymbol tvar) {\n-                ListBuffer<ClassSymbol> result = new ListBuffer<>();\n-                for (Type bound : tvar.getBounds()) {\n-                    result.appendList(baseClasses(bound.tsym));\n-                }\n-                return result.toList();\n-            } else {\n-                return List.nil();\n-            }\n-        }\n-\n-        \/* Among the set of patterns, find sub-set of patterns such:\n-         * $record($prefix$, $nested, $suffix$)\n-         * Where $record, $prefix$ and $suffix$ is the same for each pattern\n-         * in the set, and the patterns only differ in one \"column\" in\n-         * the $nested pattern.\n-         * Then, the set of $nested patterns is taken, and passed recursively\n-         * to reduceNestedPatterns and to reduceBindingPatterns, to\n-         * simplify the pattern. If that succeeds, the original found sub-set\n-         * of patterns is replaced with a new set of patterns of the form:\n-         * $record($prefix$, $resultOfReduction, $suffix$)\n-         *\n-         * useHashes: when true, patterns will be subject to exact equivalence;\n-         *            when false, two binding patterns will be considered equivalent\n-         *            if one of them is more generic than the other one;\n-         *            when false, the processing will be significantly slower,\n-         *            as pattern hashes cannot be used to speed up the matching process\n-         *\/\n-        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n-                                                             boolean useHashes) {\n-            \/* implementation note:\n-             * finding a sub-set of patterns that only differ in a single\n-             * column is time-consuming task, so this method speeds it up by:\n-             * - group the patterns by their record class\n-             * - for each column (nested pattern) do:\n-             * -- group patterns by their hash\n-             * -- in each such by-hash group, find sub-sets that only differ in\n-             *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n-             *    on patterns in the chosen column, as described above\n-             *\/\n-            var groupByRecordClass =\n-                    patterns.stream()\n-                            .filter(pd -> pd instanceof RecordPattern)\n-                            .map(pd -> (RecordPattern) pd)\n-                            .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n-\n-            for (var e : groupByRecordClass.entrySet()) {\n-                int nestedPatternsCount = e.getKey().getRecordComponents().size();\n-                Set<RecordPattern> current = new HashSet<>(e.getValue());\n-\n-                for (int mismatchingCandidate = 0;\n-                     mismatchingCandidate < nestedPatternsCount;\n-                     mismatchingCandidate++) {\n-                    int mismatchingCandidateFin = mismatchingCandidate;\n-                    var groupEquivalenceCandidates =\n-                            current\n-                             .stream()\n-                             \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n-                             .filter(pd -> pd.nested.length == nestedPatternsCount)\n-                             .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n-                    for (var candidates : groupEquivalenceCandidates.values()) {\n-                        var candidatesArr = candidates.toArray(RecordPattern[]::new);\n-\n-                        for (int firstCandidate = 0;\n-                             firstCandidate < candidatesArr.length;\n-                             firstCandidate++) {\n-                            RecordPattern rpOne = candidatesArr[firstCandidate];\n-                            ListBuffer<RecordPattern> join = new ListBuffer<>();\n-\n-                            join.append(rpOne);\n-\n-                            NEXT_PATTERN: for (int nextCandidate = 0;\n-                                               nextCandidate < candidatesArr.length;\n-                                               nextCandidate++) {\n-                                if (firstCandidate == nextCandidate) {\n-                                    continue;\n-                                }\n-\n-                                RecordPattern rpOther = candidatesArr[nextCandidate];\n-                                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                                    for (int i = 0; i < rpOne.nested.length; i++) {\n-                                        if (i != mismatchingCandidate) {\n-                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                                if (useHashes ||\n-                                                    \/\/when not using hashes,\n-                                                    \/\/check if rpOne.nested[i] is\n-                                                    \/\/a subtype of rpOther.nested[i]:\n-                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n-                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n-                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n-                                                    continue NEXT_PATTERN;\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                    join.append(rpOther);\n-                                }\n-                            }\n-\n-                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n-                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n-\n-                            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                            updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n-\n-                            if (!nestedPatterns.equals(updatedPatterns)) {\n-                                if (useHashes) {\n-                                    current.removeAll(join);\n-                                }\n-\n-                                for (PatternDescription nested : updatedPatterns) {\n-                                    PatternDescription[] newNested =\n-                                            Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                    newNested[mismatchingCandidateFin] = nested;\n-                                    current.add(new RecordPattern(rpOne.recordType(),\n-                                                                    rpOne.fullComponentTypes(),\n-                                                                    newNested));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if (!current.equals(new HashSet<>(e.getValue()))) {\n-                    Set<PatternDescription> result = new HashSet<>(patterns);\n-                    result.removeAll(e.getValue());\n-                    result.addAll(current);\n-                    return result;\n-                }\n-            }\n-            return patterns;\n-        }\n-\n-        \/* In the set of patterns, find those for which, given:\n-         * $record($nested1, $nested2, ...)\n-         * all the $nestedX pattern cover the given record component,\n-         * and replace those with a simple binding pattern over $record.\n-         *\/\n-        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n-            var newPatterns = new HashSet<PatternDescription>();\n-            boolean modified = false;\n-            for (PatternDescription pd : patterns) {\n-                if (pd instanceof RecordPattern rpOne) {\n-                    PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n-                    if (reducedPattern != rpOne) {\n-                        newPatterns.add(reducedPattern);\n-                        modified = true;\n-                        continue;\n-                    }\n-                }\n-                newPatterns.add(pd);\n-            }\n-            return modified ? newPatterns : patterns;\n-        }\n-\n-        private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n-            if (pattern instanceof RecordPattern rpOne) {\n-                Type[] componentType = rpOne.fullComponentTypes();\n-                \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n-                if (componentType.length != rpOne.nested.length) {\n-                    return pattern;\n-                }\n-                PatternDescription[] reducedNestedPatterns = null;\n-                boolean covered = true;\n-                for (int i = 0; i < componentType.length; i++) {\n-                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n-                    if (newNested != rpOne.nested[i]) {\n-                        if (reducedNestedPatterns == null) {\n-                            reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                        }\n-                        reducedNestedPatterns[i] = newNested;\n-                    }\n-\n-                    covered &= checkCovered(componentType[i], List.of(newNested));\n-                }\n-                if (covered) {\n-                    return new BindingPattern(rpOne.recordType);\n-                } else if (reducedNestedPatterns != null) {\n-                    return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n-                }\n-            }\n-            return pattern;\n-        }\n-\n-        private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n-            Set<Symbol> existingBindings = patterns.stream()\n-                                                   .filter(pd -> pd instanceof BindingPattern)\n-                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n-                                                   .collect(Collectors.toSet());\n-            Set<PatternDescription> result = new HashSet<>(patterns);\n-\n-            for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n-                PatternDescription pd = it.next();\n-                if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n-                    it.remove();\n-                }\n-            }\n-\n-            return result;\n-        }\n-\n@@ -1329,12 +893,0 @@\n-    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n-        if (newNested instanceof BindingPattern bp) {\n-            Type seltype = types.erasure(componentType);\n-            Type pattype = types.erasure(bp.type);\n-\n-            return seltype.isPrimitive() ?\n-                    types.isUnconditionallyExact(seltype, pattype) :\n-                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n-        }\n-        return false;\n-    }\n-\n@@ -3476,89 +3028,0 @@\n-    sealed interface PatternDescription { }\n-    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n-        if (pattern instanceof JCBindingPattern binding) {\n-            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n-                    ? selectorType : binding.type;\n-            return new BindingPattern(type);\n-        } else if (pattern instanceof JCRecordPattern record) {\n-            Type[] componentTypes;\n-\n-            if (!record.type.isErroneous()) {\n-                componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n-                        .map(r -> types.memberType(record.type, r))\n-                        .toArray(s -> new Type[s]);\n-            }\n-            else {\n-                componentTypes = record.nested.map(t -> types.createErrorType(t.type)).toArray(s -> new Type[s]);;\n-            }\n-\n-            PatternDescription[] nestedDescriptions =\n-                    new PatternDescription[record.nested.size()];\n-            int i = 0;\n-            for (List<JCPattern> it = record.nested;\n-                 it.nonEmpty();\n-                 it = it.tail, i++) {\n-                Type componentType = i < componentTypes.length ? componentTypes[i]\n-                                                               : syms.errType;\n-                nestedDescriptions[i] = makePatternDescription(types.erasure(componentType), it.head);\n-            }\n-            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n-        } else if (pattern instanceof JCAnyPattern) {\n-            return new BindingPattern(selectorType);\n-        } else {\n-            throw Assert.error();\n-        }\n-    }\n-    record BindingPattern(Type type) implements PatternDescription {\n-        @Override\n-        public int hashCode() {\n-            return type.tsym.hashCode();\n-        }\n-        @Override\n-        public boolean equals(Object o) {\n-            return o instanceof BindingPattern other &&\n-                    type.tsym == other.type.tsym;\n-        }\n-        @Override\n-        public String toString() {\n-            return type.tsym + \" _\";\n-        }\n-    }\n-    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n-\n-        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n-            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return _hashCode;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            return o instanceof RecordPattern other &&\n-                    recordType.tsym == other.recordType.tsym &&\n-                    Arrays.equals(nested, other.nested);\n-        }\n-\n-        public int hashCode(int excludeComponent) {\n-            return hashCode(excludeComponent, recordType, nested);\n-        }\n-\n-        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n-            int hash = 5;\n-            hash =  41 * hash + recordType.tsym.hashCode();\n-            for (int  i = 0; i < nested.length; i++) {\n-                if (i != excludeComponent) {\n-                    hash = 41 * hash + nested[i].hashCode();\n-                }\n-            }\n-            return hash;\n-        }\n-        @Override\n-        public String toString() {\n-            return recordType.tsym + \"(\" + Arrays.stream(nested)\n-                    .map(pd -> pd.toString())\n-                    .collect(Collectors.joining(\", \")) + \")\";\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":4,"deletions":541,"binary":false,"changes":545,"status":"modified"}]}