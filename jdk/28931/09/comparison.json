{"files":[{"patch":"@@ -34,8 +34,7 @@\n-$(eval $(call SetupJdkLibrary, BUILD_LIBJAAS, \\\n-    NAME := jaas, \\\n-    OPTIMIZATION := LOW, \\\n-    EXTRA_HEADER_DIRS := java.base:libjava, \\\n-    LIBS_windows := advapi32.lib mpr.lib netapi32.lib user32.lib, \\\n-))\n-\n-TARGETS += $(BUILD_LIBJAAS)\n+ifeq ($(call isTargetOs, windows), true)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBJAAS, \\\n+      NAME := jaas, \\\n+      OPTIMIZATION := LOW, \\\n+      EXTRA_HEADER_DIRS := java.base:libjava, \\\n+      LIBS_windows := advapi32.lib mpr.lib netapi32.lib user32.lib, \\\n+  ))\n@@ -43,0 +42,2 @@\n+  TARGETS += $(BUILD_LIBJAAS)\n+endif\n","filename":"make\/modules\/jdk.security.auth\/Lib.gmk","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -277,1 +277,2 @@\n-        jdk.net;\n+        jdk.net,\n+        jdk.security.auth;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.io.IOException;\n@@ -37,0 +36,1 @@\n+import jdk.internal.util.OperatingSystem;\n@@ -124,1 +124,8 @@\n-        long[] unixGroups = null;\n+        \/\/ Fail immediately on Windows to avoid cygwin-like functions\n+        \/\/ being loaded, which are not supported.\n+        if (OperatingSystem.isWindows()) {\n+            throw new FailedLoginException\n+                    (\"Failed in attempt to import \" +\n+                            \"the underlying system identity information\" +\n+                            \" on \" + System.getProperty(\"os.name\"));\n+        }\n@@ -128,1 +135,3 @@\n-        } catch (UnsatisfiedLinkError ule) {\n+        } catch (ExceptionInInitializerError | UnsatisfiedLinkError ule) {\n+            \/\/ Errors could happen in either static blocks or the constructor,\n+            \/\/ both have a cause.\n@@ -130,1 +139,1 @@\n-            throw new FailedLoginException\n+            var error = new FailedLoginException\n@@ -134,0 +143,4 @@\n+            if (ule.getCause() != null) {\n+                error.initCause(ule.getCause());\n+            }\n+            throw error;\n@@ -138,0 +151,1 @@\n+        long[] unixGroups = null;\n@@ -153,3 +167,5 @@\n-            unixGroups = ss.getGroups();\n-            for (int i = 0; i < unixGroups.length; i++) {\n-                System.out.println(\"\\t\\t\\tsupp gid = \" + unixGroups[i]);\n+            System.out.println(\"\\t\\t\\tusername = \" + ss.getUsername());\n+            if (unixGroups != null) {\n+                for (int i = 0; i < unixGroups.length; i++) {\n+                    System.out.println(\"\\t\\t\\tsupp gid = \" + unixGroups[i]);\n+                }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/UnixLoginModule.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,18 @@\n+import jdk.internal.util.Architecture;\n+import jdk.internal.util.OperatingSystem;\n+\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+\n@@ -34,0 +52,1 @@\n+@SuppressWarnings(\"restricted\")\n@@ -36,5 +55,3 @@\n-    private native void getUnixInfo();\n-\n-    \/\/ Warning: the following 4 fields are used by Unix.c\n-\n-    \/** The current username. *\/\n+    \/**\n+     * The current username.\n+     *\/\n@@ -43,1 +60,3 @@\n-    \/** The current user ID. *\/\n+    \/**\n+     * The current user ID.\n+     *\/\n@@ -46,1 +65,3 @@\n-    \/** The current group ID. *\/\n+    \/**\n+     * The current group ID.\n+     *\/\n@@ -49,1 +70,3 @@\n-    \/** The current list of groups. *\/\n+    \/**\n+     * The current list of groups.\n+     *\/\n@@ -52,0 +75,76 @@\n+    private static final Linker LINKER = Linker.nativeLinker();\n+    private static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n+            .or(LINKER.defaultLookup());\n+\n+    private static final ValueLayout.OfByte C_CHAR\n+            = (ValueLayout.OfByte) LINKER.canonicalLayouts().get(\"char\");\n+    private static final ValueLayout.OfInt C_INT\n+            = (ValueLayout.OfInt) LINKER.canonicalLayouts().get(\"int\");\n+    private static final ValueLayout.OfLong C_LONG\n+            = (ValueLayout.OfLong) LINKER.canonicalLayouts().get(\"long\");\n+    private static final AddressLayout C_POINTER\n+            = ((AddressLayout) LINKER.canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n+    private static final ValueLayout C_SIZE_T\n+            = (ValueLayout) LINKER.canonicalLayouts().get(\"size_t\");\n+\n+    private static final StructLayout CAPTURE_STATE_LAYOUT\n+            = Linker.Option.captureStateLayout();\n+    private static final VarHandle VH_errno = CAPTURE_STATE_LAYOUT.varHandle(\n+            MemoryLayout.PathElement.groupElement(\"errno\"));\n+\n+    private static final MethodHandle MH_strerror\n+            = LINKER.downcallHandle(SYMBOL_LOOKUP.findOrThrow(\"strerror\"),\n+                    FunctionDescriptor.of(C_POINTER, C_INT));\n+\n+    private static final MethodHandle MH_getgroups\n+            = LINKER.downcallHandle(SYMBOL_LOOKUP.findOrThrow(\"getgroups\"),\n+                    FunctionDescriptor.of(C_INT, C_INT, C_POINTER),\n+                    Linker.Option.captureCallState(\"errno\"));\n+    private static final MethodHandle MH_getuid\n+            = LINKER.downcallHandle(SYMBOL_LOOKUP.findOrThrow(\"getuid\"),\n+                    FunctionDescriptor.of(C_INT));\n+\n+    \/\/ Some architectures require appropriate zero or sign extension to 64 bit.\n+    \/\/ Use long directly before https:\/\/bugs.openjdk.org\/browse\/JDK-8336664 is resolved.\n+    private static final boolean calling_convention_requires_int_as_long\n+            = Architecture.isPPC64() || Architecture.isPPC64LE() || Architecture.isS390();\n+\n+    \/\/ getpwuid_r does not work on AIX, instead we use another similar function\n+    \/\/ extern int _posix_getpwuid_r(uid_t, struct passwd *, char *, int, struct passwd **)\n+    private static final MethodHandle MH_getpwuid_r\n+            = LINKER.downcallHandle(SYMBOL_LOOKUP.findOrThrow(\n+                            OperatingSystem.isAix() ? \"_posix_getpwuid_r\" : \"getpwuid_r\"),\n+                    FunctionDescriptor.of(C_INT,\n+                            calling_convention_requires_int_as_long ? C_LONG : C_INT,\n+                            C_POINTER, C_POINTER,\n+                            OperatingSystem.isAix() ? C_INT : C_SIZE_T,\n+                            C_POINTER));\n+\n+    private static final GroupLayout ML_passwd = MemoryLayout.structLayout(\n+            C_POINTER.withName(\"pw_name\"),\n+            C_POINTER.withName(\"pw_passwd\"),\n+            C_INT.withName(\"pw_uid\"),\n+            C_INT.withName(\"pw_gid\"),\n+            \/\/ Different platforms have different fields in `struct passwd`.\n+            \/\/ While we don't need those fields here, the struct needs to be\n+            \/\/ big enough to avoid buffer overflow when `getpwuid_r` is called.\n+            MemoryLayout.paddingLayout(100));\n+\n+    private static final VarHandle VH_pw_uid\n+            = ML_passwd.varHandle(groupElement(\"pw_uid\"));\n+    private static final VarHandle VH_pw_gid\n+            = ML_passwd.varHandle(groupElement(\"pw_gid\"));\n+    private static final VarHandle VH_pw_name\n+            = ML_passwd.varHandle(groupElement(\"pw_name\"));\n+\n+    \/\/ The buffer size for the getpwuid_r function:\n+    \/\/ 1. sysconf(_SC_GETPW_R_SIZE_MAX) on macOS is 4096 and 1024 on Linux,\n+    \/\/    so we choose a bigger one.\n+    \/\/ 2. We do not call sysconf() here because even _SC_GETPW_R_SIZE_MAX\n+    \/\/    could be different on different platforms.\n+    \/\/ 3. We choose int instead of long because the buffer_size argument\n+    \/\/    might be `int` or `long` and converting from `long` to `int`\n+    \/\/    requires an explicit cast.\n+    private static final int GETPW_R_SIZE_MAX = 4096;\n+\n@@ -56,1 +155,0 @@\n-    @SuppressWarnings(\"restricted\")\n@@ -58,2 +156,60 @@\n-        System.loadLibrary(\"jaas\");\n-        getUnixInfo();\n+        \/\/ The FFM code has only been tested on multiple platforms\n+        \/\/ (including macOS, Linux, AIX, etc) and might fail on other\n+        \/\/ *nix systems. Especially, the `passwd` struct could be defined\n+        \/\/ differently. I've checked several and an extra 100 chars at the\n+        \/\/ end seems enough.\n+        try (Arena scope = Arena.ofConfined()) {\n+            MemorySegment capturedState = scope.allocate(CAPTURE_STATE_LAYOUT);\n+            int groupnum = (int) MH_getgroups.invokeExact(capturedState, 0, MemorySegment.NULL);\n+            if (groupnum == -1) {\n+                throw new RuntimeException(\"getgroups returns \" + groupnum);\n+            }\n+\n+            var gs = scope.allocate(C_INT, groupnum);\n+            groupnum = (int) MH_getgroups.invokeExact(capturedState, groupnum, gs);\n+            if (groupnum == -1) {\n+                var errno = (int) VH_errno.get(capturedState, 0L);\n+                var errMsg = (MemorySegment) MH_strerror.invokeExact(errno);\n+                throw new RuntimeException(\"getgroups returns \" + groupnum\n+                        + \". Reason: \" + errMsg.reinterpret(Long.MAX_VALUE).getString(0));\n+            }\n+\n+            groups = new long[groupnum];\n+            for (int i = 0; i < groupnum; i++) {\n+                groups[i] = Integer.toUnsignedLong(gs.getAtIndex(C_INT, i));\n+            }\n+\n+            var pwd = scope.allocate(ML_passwd);\n+            var result = scope.allocate(C_POINTER);\n+            var buffer = scope.allocate(GETPW_R_SIZE_MAX);\n+\n+            long tmpUid = Integer.toUnsignedLong((int) MH_getuid.invokeExact());\n+\n+            \/\/ Do not call invokeExact because the type of buffer_size is not\n+            \/\/ always long in the underlying system.\n+            int out;\n+            if (calling_convention_requires_int_as_long) {\n+                out = (int) MH_getpwuid_r.invoke(\n+                        tmpUid, pwd, buffer, GETPW_R_SIZE_MAX, result);\n+            } else {\n+                out = (int) MH_getpwuid_r.invoke(\n+                        (int) tmpUid, pwd, buffer, GETPW_R_SIZE_MAX, result);\n+            }\n+            if (out != 0) {\n+                \/\/ If ERANGE (Result too large) is detected in a new platform,\n+                \/\/ consider adjusting GETPW_R_SIZE_MAX.\n+                var err = (MemorySegment) MH_strerror.invokeExact(out);\n+                throw new RuntimeException(err.reinterpret(Long.MAX_VALUE).getString(0));\n+            } else if (result.get(ValueLayout.ADDRESS, 0).equals(MemorySegment.NULL)) {\n+                throw new RuntimeException(\"the requested entry is not found\");\n+            } else {\n+                \/\/ uid_t and gid_t were defined unsigned.\n+                uid = Integer.toUnsignedLong((int) VH_pw_uid.get(pwd, 0L));\n+                gid = Integer.toUnsignedLong((int) VH_pw_gid.get(pwd, 0L));\n+                username = ((MemorySegment) VH_pw_name.get(pwd, 0L)).getString(0);\n+            }\n+        } catch (Throwable t) {\n+            var error = new UnsatisfiedLinkError(\"FFM calls failed\");\n+            error.initCause(t);\n+            throw error;\n+        }\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/UnixSystem.java","additions":168,"deletions":12,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include \"jni_util.h\"\n-#include \"com_sun_security_auth_module_UnixSystem.h\"\n-#include <stdio.h>\n-#include <sys\/types.h>\n-#include <unistd.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include <pwd.h>\n-\n-\/*\n- * Declare library specific JNI_Onload entry if static build\n- *\/\n-DEF_STATIC_JNI_OnLoad\n-\n-JNIEXPORT void JNICALL\n-Java_com_sun_security_auth_module_UnixSystem_getUnixInfo\n-                                                (JNIEnv *env, jobject obj) {\n-\n-    int i;\n-    char pwd_buf[1024];\n-    struct passwd *pwd = NULL;\n-    struct passwd resbuf;\n-    jfieldID userNameID;\n-    jfieldID userID;\n-    jfieldID groupID;\n-    jfieldID supplementaryGroupID;\n-\n-    jstring jstr;\n-    jlongArray jgroups;\n-    jlong *jgroupsAsArray;\n-    jsize numSuppGroups;\n-    gid_t *groups;\n-    jclass cls;\n-\n-    numSuppGroups = getgroups(0, NULL);\n-    if (numSuppGroups == -1) {\n-        return;\n-    }\n-    groups = (gid_t *)calloc(numSuppGroups, sizeof(gid_t));\n-    if (groups == NULL) {\n-        jclass cls = (*env)->FindClass(env,\"java\/lang\/OutOfMemoryError\");\n-        if (cls != NULL) {\n-            (*env)->ThrowNew(env, cls, NULL);\n-        }\n-        return;\n-    }\n-\n-    cls = (*env)->GetObjectClass(env, obj);\n-\n-    supplementaryGroupID = (*env)->GetFieldID(env, cls, \"groups\", \"[J\");\n-    if (supplementaryGroupID == 0) {\n-        goto cleanUpAndReturn;\n-    }\n-\n-    if (getgroups(numSuppGroups, groups) != -1) {\n-        jgroups = (*env)->NewLongArray(env, numSuppGroups);\n-        if (jgroups == NULL) {\n-            goto cleanUpAndReturn;\n-        }\n-        jgroupsAsArray = (*env)->GetLongArrayElements(env, jgroups, 0);\n-        if (jgroupsAsArray == NULL) {\n-            goto cleanUpAndReturn;\n-        }\n-        for (i = 0; i < numSuppGroups; i++) {\n-            jgroupsAsArray[i] = groups[i];\n-        }\n-        (*env)->ReleaseLongArrayElements(env, jgroups, jgroupsAsArray, 0);\n-        (*env)->SetObjectField(env, obj, supplementaryGroupID, jgroups);\n-    }\n-\n-    userNameID = (*env)->GetFieldID(env, cls, \"username\", \"Ljava\/lang\/String;\");\n-    if (userNameID == 0) {\n-        goto cleanUpAndReturn;\n-    }\n-\n-    userID = (*env)->GetFieldID(env, cls, \"uid\", \"J\");\n-    if (userID == 0) {\n-        goto cleanUpAndReturn;\n-    }\n-\n-    groupID = (*env)->GetFieldID(env, cls, \"gid\", \"J\");\n-    if (groupID == 0) {\n-        goto cleanUpAndReturn;\n-    }\n-\n-    memset(pwd_buf, 0, sizeof(pwd_buf));\n-    if (getpwuid_r(getuid(), &resbuf, pwd_buf, sizeof(pwd_buf), &pwd) == 0 &&\n-            pwd != NULL) {\n-        (*env)->SetLongField(env, obj, userID, pwd->pw_uid);\n-        (*env)->SetLongField(env, obj, groupID, pwd->pw_gid);\n-        jstr = (*env)->NewStringUTF(env, pwd->pw_name);\n-        if (jstr == NULL) {\n-            goto cleanUpAndReturn;\n-        }\n-        (*env)->SetObjectField(env, obj, userNameID, jstr);\n-    } else {\n-        (*env)->SetLongField(env, obj, userID, getuid());\n-        (*env)->SetLongField(env, obj, groupID, getgid());\n-    }\n-cleanUpAndReturn:\n-    free(groups);\n-    return;\n-}\n","filename":"src\/jdk.security.auth\/unix\/native\/libjaas\/Unix.c","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -30,0 +31,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -42,1 +45,1 @@\n-        login(\"cross-platform\",\n+        login(true, \"cross-platform\",\n@@ -45,2 +48,2 @@\n-        login(\"windows\", NT_MODULE, \"required\");\n-        login(\"unix\", UNIX_MODULE, \"required\");\n+        login(OperatingSystem.isWindows(), \"windows\", NT_MODULE, \"required\");\n+        login(!OperatingSystem.isWindows(), \"unix\", UNIX_MODULE, \"required\");\n@@ -49,1 +52,1 @@\n-    static void login(String test, String... conf) throws Exception {\n+    static void login(boolean shouldSucceed, String test, String... conf) throws Exception {\n@@ -71,0 +74,3 @@\n+            if (!shouldSucceed) {\n+                throw new RuntimeException(\"Should not succeed\");\n+            }\n@@ -72,0 +78,3 @@\n+            if (shouldSucceed) {\n+                throw new RuntimeException(\"Should succeed\");\n+            }\n@@ -73,1 +82,1 @@\n-            if(e.getMessage().startsWith(\"Failed in attempt to import\")) {\n+            if (e.getMessage().startsWith(\"Failed in attempt to import\")) {\n@@ -76,0 +85,2 @@\n+            } else {\n+                throw new RuntimeException(\"Unexpected error\", e);\n","filename":"test\/jdk\/com\/sun\/security\/auth\/module\/AllPlatforms.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"}]}