{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -87,2 +89,2 @@\n-    private static final ValueLayout.OfLong C_SIZE_T\n-            = (ValueLayout.OfLong) LINKER.canonicalLayouts().get(\"size_t\");\n+    private static final ValueLayout C_SIZE_T\n+            = (ValueLayout) LINKER.canonicalLayouts().get(\"size_t\");\n@@ -90,1 +92,0 @@\n-    private static Linker.Option ccs = Linker.Option.captureCallState(\"errno\");\n@@ -101,1 +102,2 @@\n-                    FunctionDescriptor.of(C_INT, C_INT, C_POINTER), ccs);\n+                    FunctionDescriptor.of(C_INT, C_INT, C_POINTER),\n+                    Linker.Option.captureCallState(\"errno\"));\n@@ -108,0 +110,3 @@\n+\n+    \/\/ getpwuid_r does not work on AIX, instead we use another similar function\n+    \/\/ extern int _posix_getpwuid_r(uid_t, struct passwd *, char *, int, struct passwd **)\n@@ -109,1 +114,2 @@\n-            .downcallHandle(SYMBOL_LOOKUP.findOrThrow(\"getpwuid_r\"),\n+            .downcallHandle(SYMBOL_LOOKUP.findOrThrow(\n+                            OperatingSystem.isAix() ? \"_posix_getpwuid_r\" : \"getpwuid_r\"),\n@@ -111,1 +117,2 @@\n-                            C_SIZE_T, C_POINTER));\n+                            OperatingSystem.isAix() ? C_INT : C_SIZE_T,\n+                            C_POINTER));\n@@ -121,1 +128,1 @@\n-            MemoryLayout.sequenceLayout(100, C_CHAR).withName(\"dummy\"));\n+            MemoryLayout.paddingLayout(100));\n@@ -136,4 +143,9 @@\n-    \/\/ sysconf(_SC_GETPW_R_SIZE_MAX) on macOS is 4096 and 1024 on Linux.\n-    \/\/ Not calling sysconf() here because _SC_GETPW_R_SIZE_MAX is different\n-    \/\/ on different platforms.\n-    private static final long GETPW_R_SIZE_MAX = 4096L;\n+    \/\/ The buffer size for the getpwuid_r function:\n+    \/\/ 1. sysconf(_SC_GETPW_R_SIZE_MAX) on macOS is 4096 and 1024 on Linux,\n+    \/\/    so we choose a bigger one.\n+    \/\/ 2. We do not call sysconf() here because even _SC_GETPW_R_SIZE_MAX\n+    \/\/    could be different on different platforms.\n+    \/\/ 3. We choose int instead of long because the buffer_size argument\n+    \/\/    might be `int` or `long` and converting from `long` to `int`\n+    \/\/    requires an explicit cast.\n+    private static final int GETPW_R_SIZE_MAX = 4096;\n@@ -164,1 +176,1 @@\n-                groups[i] = gs.getAtIndex(C_INT, i);\n+                groups[i] = Integer.toUnsignedLong(gs.getAtIndex(C_INT, i));\n@@ -171,2 +183,2 @@\n-            \/\/ Do not call invokeExact because GETPW_R_SIZE_MAX is not\n-            \/\/ always size_t on the system.\n+            \/\/ Do not call invokeExact because the type of buffer_size is not\n+            \/\/ always long in the underlying system.\n@@ -177,0 +189,2 @@\n+                    \/\/ If ERANGE (Result too large) is detected in a new platform,\n+                    \/\/ consider adjusting GETPW_R_SIZE_MAX.\n@@ -182,2 +196,2 @@\n-                uid = tmpUid;\n-                gid = (int)getgid.invokeExact();\n+                uid = Integer.toUnsignedLong(tmpUid);\n+                gid = Integer.toUnsignedLong((int)getgid.invokeExact());\n@@ -186,2 +200,3 @@\n-                uid = pwd.get(pw_uid_layout, pw_uid_offset);\n-                gid = pwd.get(pw_gid_layout, pw_gid_offset);\n+                \/\/ uid_t and gid_t were defined unsigned.\n+                uid = Integer.toUnsignedLong(pwd.get(pw_uid_layout, pw_uid_offset));\n+                gid = Integer.toUnsignedLong(pwd.get(pw_gid_layout, pw_gid_offset));\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/UnixSystem.java","additions":33,"deletions":18,"binary":false,"changes":51,"status":"modified"}]}