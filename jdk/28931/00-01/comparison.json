{"files":[{"patch":"@@ -123,2 +123,0 @@\n-        long[] unixGroups = null;\n-\n@@ -126,0 +124,8 @@\n+            \/\/ TODO: Shall we fail early for unsupported systems?\n+            \/\/ 1. If it's Windows, we should fail immediately to avoid\n+            \/\/    cygwin-like functions being loaded, which are not supported\n+            \/\/    and could have a different `long`.\n+            \/\/ 2. The FFM code has only been tested on macOS and Linux and\n+            \/\/    might fail on other *nix systems. Especially, the `passwd`\n+            \/\/    struct could be defined differently, although I've checked\n+            \/\/    several and an extra 100 chars at the end seems enough.\n@@ -127,1 +133,3 @@\n-        } catch (UnsatisfiedLinkError ule) {\n+        } catch (ExceptionInInitializerError | UnsatisfiedLinkError ule) {\n+            \/\/ Errors could happen in either static blocks or the constructor,\n+            \/\/ both have a cause.\n@@ -141,0 +149,1 @@\n+        long[] unixGroups = null;\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/UnixLoginModule.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import jdk.internal.ffi.generated.jaas_unix.passwd;\n-\n+import java.lang.foreign.AddressLayout;\n@@ -31,0 +30,4 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n@@ -32,0 +35,1 @@\n+import java.lang.foreign.SymbolLookup;\n@@ -33,0 +37,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -34,1 +39,1 @@\n-import static jdk.internal.ffi.generated.jaas_unix.jaas_unix_h.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n@@ -42,0 +47,1 @@\n+@SuppressWarnings(\"restricted\")\n@@ -44,1 +50,3 @@\n-    \/** The current username. *\/\n+    \/**\n+     * The current username.\n+     *\/\n@@ -47,1 +55,3 @@\n-    \/** The current user ID. *\/\n+    \/**\n+     * The current user ID.\n+     *\/\n@@ -50,1 +60,3 @@\n-    \/** The current group ID. *\/\n+    \/**\n+     * The current group ID.\n+     *\/\n@@ -53,1 +65,3 @@\n-    \/** The current list of groups. *\/\n+    \/**\n+     * The current list of groups.\n+     *\/\n@@ -56,0 +70,54 @@\n+    private static final Linker LINKER = Linker.nativeLinker();\n+    private static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n+            .or(LINKER.defaultLookup());\n+\n+    private static final ValueLayout.OfByte C_CHAR\n+            = (ValueLayout.OfByte) LINKER.canonicalLayouts().get(\"char\");\n+    private static final ValueLayout.OfInt C_INT\n+            = (ValueLayout.OfInt) LINKER.canonicalLayouts().get(\"int\");\n+    private static final AddressLayout C_POINTER\n+            = ((AddressLayout) LINKER.canonicalLayouts().get(\"void*\"))\n+            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n+    private static final ValueLayout.OfLong C_LONG\n+            = (ValueLayout.OfLong) LINKER.canonicalLayouts().get(\"long\");\n+\n+    private static final MethodHandle getgroups = LINKER\n+            .downcallHandle(SYMBOL_LOOKUP.findOrThrow(\"getgroups\"),\n+                    FunctionDescriptor.of(C_INT, C_INT, C_POINTER));\n+    private static final MethodHandle getuid = LINKER\n+            .downcallHandle(SYMBOL_LOOKUP.findOrThrow(\"getuid\"),\n+                    FunctionDescriptor.of(C_INT));\n+    private static final MethodHandle getgid = LINKER\n+            .downcallHandle(SYMBOL_LOOKUP.findOrThrow(\"getgid\"),\n+                    FunctionDescriptor.of(C_INT));\n+    private static final MethodHandle getpwuid_r = LINKER\n+            .downcallHandle(SYMBOL_LOOKUP.findOrThrow(\"getpwuid_r\"),\n+                    FunctionDescriptor.of(C_INT, C_INT, C_POINTER, C_POINTER,\n+                            C_LONG, C_POINTER));\n+\n+    private static final GroupLayout passwd_layout = MemoryLayout.structLayout(\n+            C_POINTER.withName(\"pw_name\"),\n+            C_POINTER.withName(\"pw_passwd\"),\n+            C_INT.withName(\"pw_uid\"),\n+            C_INT.withName(\"pw_gid\"),\n+            \/\/ Different platforms have different fields in `struct passwd`.\n+            \/\/ While we don't need those fields here, the struct needs to be\n+            \/\/ big enough to avoid buffer overflow when `getpwuid_r` is called.\n+            MemoryLayout.sequenceLayout(100, C_CHAR).withName(\"dummy\"));\n+\n+    private static final ValueLayout.OfInt pw_uid_layout\n+            = (ValueLayout.OfInt) passwd_layout.select(groupElement(\"pw_uid\"));\n+    private static final long pw_uid_offset\n+            = passwd_layout.byteOffset(groupElement(\"pw_uid\"));\n+    private static final ValueLayout.OfInt pw_gid_layout\n+            = (ValueLayout.OfInt) passwd_layout.select(groupElement(\"pw_gid\"));\n+    private static final long pw_gid_offset\n+            = passwd_layout.byteOffset(groupElement(\"pw_gid\"));\n+    private static final AddressLayout pw_name_layout\n+            = (AddressLayout) passwd_layout.select(groupElement(\"pw_name\"));\n+    private static final long pw_name_offset\n+            = passwd_layout.byteOffset(groupElement(\"pw_name\"));\n+\n+    \/\/ sysconf(_SC_GETPW_R_SIZE_MAX) on macOS is 4096 and 1024 on Linux\n+    private static final long GETPW_R_SIZE_MAX = 4096L;\n+\n@@ -62,1 +130,1 @@\n-            int groupnum = getgroups(0, MemorySegment.NULL);\n+            int groupnum = (int) getgroups.invokeExact(0, MemorySegment.NULL);\n@@ -67,2 +135,2 @@\n-            var gs = scope.allocate(gid_t, groupnum);\n-            groupnum = getgroups(groupnum, gs);\n+            var gs = scope.allocate(C_INT, groupnum);\n+            groupnum = (int) getgroups.invokeExact(groupnum, gs);\n@@ -75,1 +143,1 @@\n-                groups[i] = gs.getAtIndex(gid_t, i);\n+                groups[i] = gs.getAtIndex(C_INT, i);\n@@ -78,1 +146,1 @@\n-            var resbuf = passwd.allocate(scope);\n+            var resbuf = scope.allocate(passwd_layout);\n@@ -80,7 +148,12 @@\n-            var pwd_buf = scope.allocate(1024);\n-            int out = getpwuid_r(getuid(), resbuf, pwd_buf, pwd_buf.byteSize(), pwd);\n-            if (out != 0) {\n-                throw new RuntimeException(\"getpwuid_r returns \" + out);\n-            }\n-            if (pwd.get(ValueLayout.ADDRESS, 0).equals(MemorySegment.NULL)) {\n-                throw new RuntimeException(\"getpwuid_r returns NULL result\");\n+            var pwd_buf = scope.allocate(GETPW_R_SIZE_MAX);\n+            var tmpUid = (int)getuid.invokeExact();\n+            int out = (int) getpwuid_r.invokeExact(\n+                    tmpUid, resbuf, pwd_buf, GETPW_R_SIZE_MAX, pwd);\n+            if (out != 0 || pwd.get(ValueLayout.ADDRESS, 0).equals(MemorySegment.NULL)) {\n+                uid = tmpUid;\n+                gid = (int)getgid.invokeExact();\n+                username = null;\n+            } else {\n+                uid = resbuf.get(pw_uid_layout, pw_uid_offset);\n+                gid = resbuf.get(pw_gid_layout, pw_gid_offset);\n+                username = resbuf.get(pw_name_layout, pw_name_offset).getString(0);\n@@ -88,3 +161,0 @@\n-            uid = passwd.pw_uid(resbuf);\n-            gid = passwd.pw_gid(resbuf);\n-            username = passwd.pw_name(resbuf).getString(0);\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/UnixSystem.java","additions":92,"deletions":22,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package jdk.internal.ffi.generated.jaas_unix;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-@SuppressWarnings(\"restricted\")\n-public class jaas_unix_h$shared {\n-\n-    jaas_unix_h$shared() {\n-        \/\/ Should not be called directly\n-    }\n-\n-    public static final ValueLayout.OfBoolean C_BOOL = (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n-    public static final ValueLayout.OfByte C_CHAR =(ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n-    public static final ValueLayout.OfShort C_SHORT = (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n-    public static final ValueLayout.OfInt C_INT = (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n-    public static final ValueLayout.OfLong C_LONG_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n-    public static final ValueLayout.OfFloat C_FLOAT = (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n-    public static final ValueLayout.OfDouble C_DOUBLE = (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n-    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n-            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, C_CHAR));\n-    public static final ValueLayout.OfLong C_LONG = (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n-\n-    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n-\n-    static void traceDowncall(String name, Object... args) {\n-         String traceArgs = Arrays.stream(args)\n-                       .map(Object::toString)\n-                       .collect(Collectors.joining(\", \"));\n-         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n-    }\n-\n-    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-        try {\n-            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MemoryLayout align(MemoryLayout layout, long align) {\n-        return switch (layout) {\n-            case PaddingLayout p -> p;\n-            case ValueLayout v -> v.withByteAlignment(align);\n-            case GroupLayout g -> {\n-                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n-                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n-                yield g instanceof StructLayout ?\n-                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n-            }\n-            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n-        };\n-    }\n-}\n","filename":"src\/jdk.security.auth\/share\/classes\/jdk\/internal\/ffi\/generated\/jaas_unix\/jaas_unix_h$shared.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,299 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package jdk.internal.ffi.generated.jaas_unix;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-@SuppressWarnings(\"restricted\")\n-public class jaas_unix_h extends jaas_unix_h$shared {\n-\n-    jaas_unix_h() {\n-        \/\/ Should not be called directly\n-    }\n-\n-    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n-\n-    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n-            .or(Linker.nativeLinker().defaultLookup());\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * typedef __darwin_gid_t gid_t\n-     * }\n-     *\/\n-    public static final OfInt gid_t = jaas_unix_h.C_INT;\n-\n-    private static class getgid {\n-        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n-            jaas_unix_h.C_INT    );\n-\n-        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"getgid\");\n-\n-        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n-    }\n-\n-    \/**\n-     * Function descriptor for:\n-     * {@snippet lang=c :\n-     * gid_t getgid(void)\n-     * }\n-     *\/\n-    public static FunctionDescriptor getgid$descriptor() {\n-        return getgid.DESC;\n-    }\n-\n-    \/**\n-     * Downcall method handle for:\n-     * {@snippet lang=c :\n-     * gid_t getgid(void)\n-     * }\n-     *\/\n-    public static MethodHandle getgid$handle() {\n-        return getgid.HANDLE;\n-    }\n-\n-    \/**\n-     * Address for:\n-     * {@snippet lang=c :\n-     * gid_t getgid(void)\n-     * }\n-     *\/\n-    public static MemorySegment getgid$address() {\n-        return getgid.ADDR;\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * gid_t getgid(void)\n-     * }\n-     *\/\n-    public static int getgid() {\n-        var mh$ = getgid.HANDLE;\n-        try {\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"getgid\");\n-            }\n-            return (int)mh$.invokeExact();\n-        } catch (Error | RuntimeException ex) {\n-           throw ex;\n-        } catch (Throwable ex$) {\n-           throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-\n-    private static class getgroups {\n-        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n-            jaas_unix_h.C_INT,\n-            jaas_unix_h.C_INT,\n-            jaas_unix_h.C_POINTER\n-        );\n-\n-        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"getgroups\");\n-\n-        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n-    }\n-\n-    \/**\n-     * Function descriptor for:\n-     * {@snippet lang=c :\n-     * int getgroups(int __gidsetsize, gid_t[])\n-     * }\n-     *\/\n-    public static FunctionDescriptor getgroups$descriptor() {\n-        return getgroups.DESC;\n-    }\n-\n-    \/**\n-     * Downcall method handle for:\n-     * {@snippet lang=c :\n-     * int getgroups(int __gidsetsize, gid_t[])\n-     * }\n-     *\/\n-    public static MethodHandle getgroups$handle() {\n-        return getgroups.HANDLE;\n-    }\n-\n-    \/**\n-     * Address for:\n-     * {@snippet lang=c :\n-     * int getgroups(int __gidsetsize, gid_t[])\n-     * }\n-     *\/\n-    public static MemorySegment getgroups$address() {\n-        return getgroups.ADDR;\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * int getgroups(int __gidsetsize, gid_t[])\n-     * }\n-     *\/\n-    public static int getgroups(int __gidsetsize, MemorySegment x1) {\n-        var mh$ = getgroups.HANDLE;\n-        try {\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"getgroups\", __gidsetsize, x1);\n-            }\n-            return (int)mh$.invokeExact(__gidsetsize, x1);\n-        } catch (Error | RuntimeException ex) {\n-           throw ex;\n-        } catch (Throwable ex$) {\n-           throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-\n-    private static class getuid {\n-        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n-            jaas_unix_h.C_INT    );\n-\n-        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"getuid\");\n-\n-        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n-    }\n-\n-    \/**\n-     * Function descriptor for:\n-     * {@snippet lang=c :\n-     * uid_t getuid(void)\n-     * }\n-     *\/\n-    public static FunctionDescriptor getuid$descriptor() {\n-        return getuid.DESC;\n-    }\n-\n-    \/**\n-     * Downcall method handle for:\n-     * {@snippet lang=c :\n-     * uid_t getuid(void)\n-     * }\n-     *\/\n-    public static MethodHandle getuid$handle() {\n-        return getuid.HANDLE;\n-    }\n-\n-    \/**\n-     * Address for:\n-     * {@snippet lang=c :\n-     * uid_t getuid(void)\n-     * }\n-     *\/\n-    public static MemorySegment getuid$address() {\n-        return getuid.ADDR;\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * uid_t getuid(void)\n-     * }\n-     *\/\n-    public static int getuid() {\n-        var mh$ = getuid.HANDLE;\n-        try {\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"getuid\");\n-            }\n-            return (int)mh$.invokeExact();\n-        } catch (Error | RuntimeException ex) {\n-           throw ex;\n-        } catch (Throwable ex$) {\n-           throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-\n-    private static class getpwuid_r {\n-        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n-            jaas_unix_h.C_INT,\n-            jaas_unix_h.C_INT,\n-            jaas_unix_h.C_POINTER,\n-            jaas_unix_h.C_POINTER,\n-            jaas_unix_h.C_LONG,\n-            jaas_unix_h.C_POINTER\n-        );\n-\n-        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"getpwuid_r\");\n-\n-        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n-    }\n-\n-    \/**\n-     * Function descriptor for:\n-     * {@snippet lang=c :\n-     * int getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **)\n-     * }\n-     *\/\n-    public static FunctionDescriptor getpwuid_r$descriptor() {\n-        return getpwuid_r.DESC;\n-    }\n-\n-    \/**\n-     * Downcall method handle for:\n-     * {@snippet lang=c :\n-     * int getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **)\n-     * }\n-     *\/\n-    public static MethodHandle getpwuid_r$handle() {\n-        return getpwuid_r.HANDLE;\n-    }\n-\n-    \/**\n-     * Address for:\n-     * {@snippet lang=c :\n-     * int getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **)\n-     * }\n-     *\/\n-    public static MemorySegment getpwuid_r$address() {\n-        return getpwuid_r.ADDR;\n-    }\n-\n-    \/**\n-     * {@snippet lang=c :\n-     * int getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **)\n-     * }\n-     *\/\n-    public static int getpwuid_r(int x0, MemorySegment x1, MemorySegment x2, long x3, MemorySegment x4) {\n-        var mh$ = getpwuid_r.HANDLE;\n-        try {\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"getpwuid_r\", x0, x1, x2, x3, x4);\n-            }\n-            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);\n-        } catch (Error | RuntimeException ex) {\n-           throw ex;\n-        } catch (Throwable ex$) {\n-           throw new AssertionError(\"should not reach here\", ex$);\n-        }\n-    }\n-}\n","filename":"src\/jdk.security.auth\/share\/classes\/jdk\/internal\/ffi\/generated\/jaas_unix\/jaas_unix_h.java","additions":0,"deletions":299,"binary":false,"changes":299,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Defines native structures for JAAS {@code UnixLoginModule}.\n- * Generated with the following jextract command:\n- * {@snippet lang = \"Shell Script\":\n- *\n- *  HEADER_NAME=jaas_unix.h\n- *   echo \"#include <unistd.h> \" > $HEADER_NAME\n- *   echo \"#include <spwd.h>\" >> $HEADER_NAME\n- *\n- *\n- * jextract --target-package jdk.internal.ffi.generated.jaas_unix \\\n- *    --include-function getgroups \\\n- *    --include-function getpwuid_r \\\n- *    --include-function getuid \\\n- *    --include-function getgid \\\n- *    --include-typedef gid_t \\\n- *    --include-struct passwd \\\n- *    $HEADER_NAME\n- * }\n- * The classes in this package were generated on macOS. The result is mostly\n- * the same when generated on Linux. The biggest difference is that Linux has\n- * fewer fields in the middle of the `passwd` struct. This difference does not\n- * affect usage, as only fields common to both platforms at the beginning are\n- * accessed in the {@link com.sun.security.auth.module.UnixSystem} class.\n- *\/\n-package jdk.internal.ffi.generated.jaas_unix;\n","filename":"src\/jdk.security.auth\/share\/classes\/jdk\/internal\/ffi\/generated\/jaas_unix\/package-info.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,566 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package jdk.internal.ffi.generated.jaas_unix;\n-\n-import java.lang.invoke.*;\n-import java.lang.foreign.*;\n-import java.nio.ByteOrder;\n-import java.util.*;\n-import java.util.function.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-\n-\/**\n- * {@snippet lang=c :\n- * struct passwd {\n- *     char *pw_name;\n- *     char *pw_passwd;\n- *     uid_t pw_uid;\n- *     gid_t pw_gid;\n- *     __darwin_time_t pw_change;\n- *     char *pw_class;\n- *     char *pw_gecos;\n- *     char *pw_dir;\n- *     char *pw_shell;\n- *     __darwin_time_t pw_expire;\n- * }\n- * }\n- *\/\n-@SuppressWarnings(\"restricted\")\n-public class passwd {\n-\n-    passwd() {\n-        \/\/ Should not be called directly\n-    }\n-\n-    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(\n-        jaas_unix_h.C_POINTER.withName(\"pw_name\"),\n-        jaas_unix_h.C_POINTER.withName(\"pw_passwd\"),\n-        jaas_unix_h.C_INT.withName(\"pw_uid\"),\n-        jaas_unix_h.C_INT.withName(\"pw_gid\"),\n-        jaas_unix_h.C_LONG.withName(\"pw_change\"),\n-        jaas_unix_h.C_POINTER.withName(\"pw_class\"),\n-        jaas_unix_h.C_POINTER.withName(\"pw_gecos\"),\n-        jaas_unix_h.C_POINTER.withName(\"pw_dir\"),\n-        jaas_unix_h.C_POINTER.withName(\"pw_shell\"),\n-        jaas_unix_h.C_LONG.withName(\"pw_expire\")\n-    ).withName(\"passwd\");\n-\n-    \/**\n-     * The layout of this struct\n-     *\/\n-    public static final GroupLayout layout() {\n-        return $LAYOUT;\n-    }\n-\n-    private static final AddressLayout pw_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"pw_name\"));\n-\n-    \/**\n-     * Layout for field:\n-     * {@snippet lang=c :\n-     * char *pw_name\n-     * }\n-     *\/\n-    public static final AddressLayout pw_name$layout() {\n-        return pw_name$LAYOUT;\n-    }\n-\n-    private static final long pw_name$OFFSET = $LAYOUT.byteOffset(groupElement(\"pw_name\"));\n-\n-    \/**\n-     * Offset for field:\n-     * {@snippet lang=c :\n-     * char *pw_name\n-     * }\n-     *\/\n-    public static final long pw_name$offset() {\n-        return pw_name$OFFSET;\n-    }\n-\n-    \/**\n-     * Getter for field:\n-     * {@snippet lang=c :\n-     * char *pw_name\n-     * }\n-     *\/\n-    public static MemorySegment pw_name(MemorySegment struct) {\n-        return struct.get(pw_name$LAYOUT, pw_name$OFFSET);\n-    }\n-\n-    \/**\n-     * Setter for field:\n-     * {@snippet lang=c :\n-     * char *pw_name\n-     * }\n-     *\/\n-    public static void pw_name(MemorySegment struct, MemorySegment fieldValue) {\n-        struct.set(pw_name$LAYOUT, pw_name$OFFSET, fieldValue);\n-    }\n-\n-    private static final AddressLayout pw_passwd$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"pw_passwd\"));\n-\n-    \/**\n-     * Layout for field:\n-     * {@snippet lang=c :\n-     * char *pw_passwd\n-     * }\n-     *\/\n-    public static final AddressLayout pw_passwd$layout() {\n-        return pw_passwd$LAYOUT;\n-    }\n-\n-    private static final long pw_passwd$OFFSET = $LAYOUT.byteOffset(groupElement(\"pw_passwd\"));\n-\n-    \/**\n-     * Offset for field:\n-     * {@snippet lang=c :\n-     * char *pw_passwd\n-     * }\n-     *\/\n-    public static final long pw_passwd$offset() {\n-        return pw_passwd$OFFSET;\n-    }\n-\n-    \/**\n-     * Getter for field:\n-     * {@snippet lang=c :\n-     * char *pw_passwd\n-     * }\n-     *\/\n-    public static MemorySegment pw_passwd(MemorySegment struct) {\n-        return struct.get(pw_passwd$LAYOUT, pw_passwd$OFFSET);\n-    }\n-\n-    \/**\n-     * Setter for field:\n-     * {@snippet lang=c :\n-     * char *pw_passwd\n-     * }\n-     *\/\n-    public static void pw_passwd(MemorySegment struct, MemorySegment fieldValue) {\n-        struct.set(pw_passwd$LAYOUT, pw_passwd$OFFSET, fieldValue);\n-    }\n-\n-    private static final OfInt pw_uid$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"pw_uid\"));\n-\n-    \/**\n-     * Layout for field:\n-     * {@snippet lang=c :\n-     * uid_t pw_uid\n-     * }\n-     *\/\n-    public static final OfInt pw_uid$layout() {\n-        return pw_uid$LAYOUT;\n-    }\n-\n-    private static final long pw_uid$OFFSET = $LAYOUT.byteOffset(groupElement(\"pw_uid\"));\n-\n-    \/**\n-     * Offset for field:\n-     * {@snippet lang=c :\n-     * uid_t pw_uid\n-     * }\n-     *\/\n-    public static final long pw_uid$offset() {\n-        return pw_uid$OFFSET;\n-    }\n-\n-    \/**\n-     * Getter for field:\n-     * {@snippet lang=c :\n-     * uid_t pw_uid\n-     * }\n-     *\/\n-    public static int pw_uid(MemorySegment struct) {\n-        return struct.get(pw_uid$LAYOUT, pw_uid$OFFSET);\n-    }\n-\n-    \/**\n-     * Setter for field:\n-     * {@snippet lang=c :\n-     * uid_t pw_uid\n-     * }\n-     *\/\n-    public static void pw_uid(MemorySegment struct, int fieldValue) {\n-        struct.set(pw_uid$LAYOUT, pw_uid$OFFSET, fieldValue);\n-    }\n-\n-    private static final OfInt pw_gid$LAYOUT = (OfInt)$LAYOUT.select(groupElement(\"pw_gid\"));\n-\n-    \/**\n-     * Layout for field:\n-     * {@snippet lang=c :\n-     * gid_t pw_gid\n-     * }\n-     *\/\n-    public static final OfInt pw_gid$layout() {\n-        return pw_gid$LAYOUT;\n-    }\n-\n-    private static final long pw_gid$OFFSET = $LAYOUT.byteOffset(groupElement(\"pw_gid\"));\n-\n-    \/**\n-     * Offset for field:\n-     * {@snippet lang=c :\n-     * gid_t pw_gid\n-     * }\n-     *\/\n-    public static final long pw_gid$offset() {\n-        return pw_gid$OFFSET;\n-    }\n-\n-    \/**\n-     * Getter for field:\n-     * {@snippet lang=c :\n-     * gid_t pw_gid\n-     * }\n-     *\/\n-    public static int pw_gid(MemorySegment struct) {\n-        return struct.get(pw_gid$LAYOUT, pw_gid$OFFSET);\n-    }\n-\n-    \/**\n-     * Setter for field:\n-     * {@snippet lang=c :\n-     * gid_t pw_gid\n-     * }\n-     *\/\n-    public static void pw_gid(MemorySegment struct, int fieldValue) {\n-        struct.set(pw_gid$LAYOUT, pw_gid$OFFSET, fieldValue);\n-    }\n-\n-    private static final OfLong pw_change$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"pw_change\"));\n-\n-    \/**\n-     * Layout for field:\n-     * {@snippet lang=c :\n-     * __darwin_time_t pw_change\n-     * }\n-     *\/\n-    public static final OfLong pw_change$layout() {\n-        return pw_change$LAYOUT;\n-    }\n-\n-    private static final long pw_change$OFFSET = $LAYOUT.byteOffset(groupElement(\"pw_change\"));\n-\n-    \/**\n-     * Offset for field:\n-     * {@snippet lang=c :\n-     * __darwin_time_t pw_change\n-     * }\n-     *\/\n-    public static final long pw_change$offset() {\n-        return pw_change$OFFSET;\n-    }\n-\n-    \/**\n-     * Getter for field:\n-     * {@snippet lang=c :\n-     * __darwin_time_t pw_change\n-     * }\n-     *\/\n-    public static long pw_change(MemorySegment struct) {\n-        return struct.get(pw_change$LAYOUT, pw_change$OFFSET);\n-    }\n-\n-    \/**\n-     * Setter for field:\n-     * {@snippet lang=c :\n-     * __darwin_time_t pw_change\n-     * }\n-     *\/\n-    public static void pw_change(MemorySegment struct, long fieldValue) {\n-        struct.set(pw_change$LAYOUT, pw_change$OFFSET, fieldValue);\n-    }\n-\n-    private static final AddressLayout pw_class$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"pw_class\"));\n-\n-    \/**\n-     * Layout for field:\n-     * {@snippet lang=c :\n-     * char *pw_class\n-     * }\n-     *\/\n-    public static final AddressLayout pw_class$layout() {\n-        return pw_class$LAYOUT;\n-    }\n-\n-    private static final long pw_class$OFFSET = $LAYOUT.byteOffset(groupElement(\"pw_class\"));\n-\n-    \/**\n-     * Offset for field:\n-     * {@snippet lang=c :\n-     * char *pw_class\n-     * }\n-     *\/\n-    public static final long pw_class$offset() {\n-        return pw_class$OFFSET;\n-    }\n-\n-    \/**\n-     * Getter for field:\n-     * {@snippet lang=c :\n-     * char *pw_class\n-     * }\n-     *\/\n-    public static MemorySegment pw_class(MemorySegment struct) {\n-        return struct.get(pw_class$LAYOUT, pw_class$OFFSET);\n-    }\n-\n-    \/**\n-     * Setter for field:\n-     * {@snippet lang=c :\n-     * char *pw_class\n-     * }\n-     *\/\n-    public static void pw_class(MemorySegment struct, MemorySegment fieldValue) {\n-        struct.set(pw_class$LAYOUT, pw_class$OFFSET, fieldValue);\n-    }\n-\n-    private static final AddressLayout pw_gecos$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"pw_gecos\"));\n-\n-    \/**\n-     * Layout for field:\n-     * {@snippet lang=c :\n-     * char *pw_gecos\n-     * }\n-     *\/\n-    public static final AddressLayout pw_gecos$layout() {\n-        return pw_gecos$LAYOUT;\n-    }\n-\n-    private static final long pw_gecos$OFFSET = $LAYOUT.byteOffset(groupElement(\"pw_gecos\"));\n-\n-    \/**\n-     * Offset for field:\n-     * {@snippet lang=c :\n-     * char *pw_gecos\n-     * }\n-     *\/\n-    public static final long pw_gecos$offset() {\n-        return pw_gecos$OFFSET;\n-    }\n-\n-    \/**\n-     * Getter for field:\n-     * {@snippet lang=c :\n-     * char *pw_gecos\n-     * }\n-     *\/\n-    public static MemorySegment pw_gecos(MemorySegment struct) {\n-        return struct.get(pw_gecos$LAYOUT, pw_gecos$OFFSET);\n-    }\n-\n-    \/**\n-     * Setter for field:\n-     * {@snippet lang=c :\n-     * char *pw_gecos\n-     * }\n-     *\/\n-    public static void pw_gecos(MemorySegment struct, MemorySegment fieldValue) {\n-        struct.set(pw_gecos$LAYOUT, pw_gecos$OFFSET, fieldValue);\n-    }\n-\n-    private static final AddressLayout pw_dir$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"pw_dir\"));\n-\n-    \/**\n-     * Layout for field:\n-     * {@snippet lang=c :\n-     * char *pw_dir\n-     * }\n-     *\/\n-    public static final AddressLayout pw_dir$layout() {\n-        return pw_dir$LAYOUT;\n-    }\n-\n-    private static final long pw_dir$OFFSET = $LAYOUT.byteOffset(groupElement(\"pw_dir\"));\n-\n-    \/**\n-     * Offset for field:\n-     * {@snippet lang=c :\n-     * char *pw_dir\n-     * }\n-     *\/\n-    public static final long pw_dir$offset() {\n-        return pw_dir$OFFSET;\n-    }\n-\n-    \/**\n-     * Getter for field:\n-     * {@snippet lang=c :\n-     * char *pw_dir\n-     * }\n-     *\/\n-    public static MemorySegment pw_dir(MemorySegment struct) {\n-        return struct.get(pw_dir$LAYOUT, pw_dir$OFFSET);\n-    }\n-\n-    \/**\n-     * Setter for field:\n-     * {@snippet lang=c :\n-     * char *pw_dir\n-     * }\n-     *\/\n-    public static void pw_dir(MemorySegment struct, MemorySegment fieldValue) {\n-        struct.set(pw_dir$LAYOUT, pw_dir$OFFSET, fieldValue);\n-    }\n-\n-    private static final AddressLayout pw_shell$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement(\"pw_shell\"));\n-\n-    \/**\n-     * Layout for field:\n-     * {@snippet lang=c :\n-     * char *pw_shell\n-     * }\n-     *\/\n-    public static final AddressLayout pw_shell$layout() {\n-        return pw_shell$LAYOUT;\n-    }\n-\n-    private static final long pw_shell$OFFSET = $LAYOUT.byteOffset(groupElement(\"pw_shell\"));\n-\n-    \/**\n-     * Offset for field:\n-     * {@snippet lang=c :\n-     * char *pw_shell\n-     * }\n-     *\/\n-    public static final long pw_shell$offset() {\n-        return pw_shell$OFFSET;\n-    }\n-\n-    \/**\n-     * Getter for field:\n-     * {@snippet lang=c :\n-     * char *pw_shell\n-     * }\n-     *\/\n-    public static MemorySegment pw_shell(MemorySegment struct) {\n-        return struct.get(pw_shell$LAYOUT, pw_shell$OFFSET);\n-    }\n-\n-    \/**\n-     * Setter for field:\n-     * {@snippet lang=c :\n-     * char *pw_shell\n-     * }\n-     *\/\n-    public static void pw_shell(MemorySegment struct, MemorySegment fieldValue) {\n-        struct.set(pw_shell$LAYOUT, pw_shell$OFFSET, fieldValue);\n-    }\n-\n-    private static final OfLong pw_expire$LAYOUT = (OfLong)$LAYOUT.select(groupElement(\"pw_expire\"));\n-\n-    \/**\n-     * Layout for field:\n-     * {@snippet lang=c :\n-     * __darwin_time_t pw_expire\n-     * }\n-     *\/\n-    public static final OfLong pw_expire$layout() {\n-        return pw_expire$LAYOUT;\n-    }\n-\n-    private static final long pw_expire$OFFSET = $LAYOUT.byteOffset(groupElement(\"pw_expire\"));\n-\n-    \/**\n-     * Offset for field:\n-     * {@snippet lang=c :\n-     * __darwin_time_t pw_expire\n-     * }\n-     *\/\n-    public static final long pw_expire$offset() {\n-        return pw_expire$OFFSET;\n-    }\n-\n-    \/**\n-     * Getter for field:\n-     * {@snippet lang=c :\n-     * __darwin_time_t pw_expire\n-     * }\n-     *\/\n-    public static long pw_expire(MemorySegment struct) {\n-        return struct.get(pw_expire$LAYOUT, pw_expire$OFFSET);\n-    }\n-\n-    \/**\n-     * Setter for field:\n-     * {@snippet lang=c :\n-     * __darwin_time_t pw_expire\n-     * }\n-     *\/\n-    public static void pw_expire(MemorySegment struct, long fieldValue) {\n-        struct.set(pw_expire$LAYOUT, pw_expire$OFFSET, fieldValue);\n-    }\n-\n-    \/**\n-     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.\n-     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}\n-     *\/\n-    public static MemorySegment asSlice(MemorySegment array, long index) {\n-        return array.asSlice(layout().byteSize() * index);\n-    }\n-\n-    \/**\n-     * The size (in bytes) of this struct\n-     *\/\n-    public static long sizeof() { return layout().byteSize(); }\n-\n-    \/**\n-     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}\n-     *\/\n-    public static MemorySegment allocate(SegmentAllocator allocator) {\n-        return allocator.allocate(layout());\n-    }\n-\n-    \/**\n-     * Allocate an array of size {@code elementCount} using {@code allocator}.\n-     * The returned segment has size {@code elementCount * layout().byteSize()}.\n-     *\/\n-    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {\n-        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));\n-    }\n-\n-    \/**\n-     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n-     * The returned segment has size {@code layout().byteSize()}\n-     *\/\n-    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {\n-        return reinterpret(addr, 1, arena, cleanup);\n-    }\n-\n-    \/**\n-     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).\n-     * The returned segment has size {@code elementCount * layout().byteSize()}\n-     *\/\n-    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {\n-        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);\n-    }\n-}\n","filename":"src\/jdk.security.auth\/share\/classes\/jdk\/internal\/ffi\/generated\/jaas_unix\/passwd.java","additions":0,"deletions":566,"binary":false,"changes":566,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/jdk.internal.util\n@@ -30,0 +31,2 @@\n+import jdk.internal.util.OperatingSystem;\n+\n@@ -42,1 +45,1 @@\n-        login(\"cross-platform\",\n+        login(true, \"cross-platform\",\n@@ -45,2 +48,2 @@\n-        login(\"windows\", NT_MODULE, \"required\");\n-        login(\"unix\", UNIX_MODULE, \"required\");\n+        login(OperatingSystem.isWindows(), \"windows\", NT_MODULE, \"required\");\n+        login(!OperatingSystem.isWindows(), \"unix\", UNIX_MODULE, \"required\");\n@@ -49,1 +52,1 @@\n-    static void login(String test, String... conf) throws Exception {\n+    static void login(boolean shouldSucceed, String test, String... conf) throws Exception {\n@@ -71,0 +74,3 @@\n+            if (!shouldSucceed) {\n+                throw new RuntimeException(\"Should not succeed\");\n+            }\n@@ -72,0 +78,3 @@\n+            if (shouldSucceed) {\n+                throw new RuntimeException(\"Should succeed\");\n+            }\n","filename":"test\/jdk\/com\/sun\/security\/auth\/module\/AllPlatforms.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"}]}