{"files":[{"patch":"@@ -2666,0 +2666,3 @@\n+  \/\/ If the global gc state has been changed, but hasn't yet been propagated to all threads, then\n+  \/\/ the global gc state is the correct value. Once the gc state has been synchronized with all threads,\n+  \/\/ _gc_state_changed will be toggled to false and we need to use the thread local state.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -367,0 +367,2 @@\n+  \/\/ However, in some cases (init update refs, e.g.), the gc state may change concurrently\n+  \/\/ and will be propagated to all threads by a handshake operation.\n@@ -370,0 +372,1 @@\n+  \/\/ This returns the raw value of the singular, global gc state.\n@@ -371,0 +374,5 @@\n+\n+  \/\/ Compares the given state against either the global gc state, or the thread local state.\n+  \/\/ The global gc state may change on a safepoint and is the correct value to use until\n+  \/\/ the global gc state has been propagated to all threads (after which, this method will\n+  \/\/ compare against the thread local state).\n@@ -374,3 +382,3 @@\n-  \/\/ It is primarily intended to support quick access at barriers. All threads are\n-  \/\/ updated because in some cases the control thread or the vm thread may need to\n-  \/\/ execute the load reference barrier.\n+  \/\/ The thread local gc state is primarily intended to support quick access at barriers.\n+  \/\/ All threads are updated because in some cases the control thread or the vm thread may\n+  \/\/ need to execute the load reference barrier.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"}]}