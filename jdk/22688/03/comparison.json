{"files":[{"patch":"@@ -70,2 +70,1 @@\n-    assert(_heap->is_evacuation_in_progress(),\n-           \"evac should be in progress\");\n+    assert(_heap->is_evacuation_in_progress(), \"evac should be in progress\");\n@@ -89,2 +88,2 @@\n-  if (_heap->has_forwarded_objects() &&\n-      _heap->in_collection_set(obj)) { \/\/ Subsumes null-check\n+  if (_heap->has_forwarded_objects() && _heap->in_collection_set(obj)) {\n+    \/\/ Subsumes null-check\n@@ -384,1 +383,1 @@\n-  assert(HAS_FWD == _heap->has_forwarded_objects() || (_heap->gc_state() & ShenandoahHeap::OLD_MARKING) != 0,\n+  assert(HAS_FWD == _heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(),\n@@ -421,1 +420,1 @@\n-  int gc_state = _heap->gc_state();\n+  char gc_state = ShenandoahThreadLocalData::gc_state(Thread::current());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -98,2 +98,1 @@\n-  int gc_state = _heap->gc_state();\n-  if ((gc_state & ShenandoahHeap::EVACUATION) != 0) {\n+  if (_heap->is_evacuation_in_progress()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetClone.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,0 +195,3 @@\n+    \/\/ Evacuation is complete, retire gc labs\n+    heap->concurrent_prepare_for_update_refs();\n+\n@@ -196,1 +199,4 @@\n-    vmop_entry_init_updaterefs();\n+    if (ShenandoahVerify || ShenandoahPacing) {\n+      vmop_entry_init_updaterefs();\n+    }\n+\n@@ -751,4 +757,0 @@\n-\n-      if (VerifyAfterGC) {\n-        Universe::verify();\n-      }\n@@ -923,2 +925,2 @@\n-    \/\/ cleanup the weak oops in CLD and determinate nmethod's unloading state, so that we\n-    \/\/ can cleanup immediate garbage sooner.\n+    \/\/ clean up the weak oops in CLD and determine nmethod's unloading state, so that we\n+    \/\/ can clean up immediate garbage sooner.\n@@ -950,15 +952,4 @@\n-  {\n-    ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_work);\n-    ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_weak_roots_work);\n-    ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots_work);\n-    heap->workers()->run_task(&task);\n-  }\n-\n-  \/\/ Perform handshake to flush out dead oops\n-  {\n-    ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_rendezvous);\n-    heap->rendezvous_threads(\"Shenandoah Concurrent Weak Roots\");\n-  }\n-  \/\/ We can only toggle concurrent_weak_root_in_progress flag\n-  \/\/ at a safepoint, so that mutators see a consistent\n-  \/\/ value. The flag will be cleared at the next safepoint.\n+  ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_work);\n+  ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_weak_roots_work);\n+  ShenandoahConcurrentWeakRootsEvacUpdateTask task(ShenandoahPhaseTimings::conc_weak_roots_work);\n+  heap->workers()->run_task(&task);\n@@ -1061,4 +1052,0 @@\n-  heap->set_evacuation_in_progress(false);\n-  heap->set_concurrent_weak_root_in_progress(false);\n-  heap->prepare_update_heap_references(true \/*concurrent*\/);\n-  heap->set_update_refs_in_progress(true);\n@@ -1181,0 +1168,4 @@\n+\n+  if (VerifyAfterGC) {\n+    Universe::verify();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":17,"deletions":26,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1001,0 +1001,2 @@\n+    \/\/ We cannot use this region for allocation when weak roots are in progress because the collector may need\n+    \/\/ to reference unmarked oops during concurrent classunloading.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+#include \"runtime\/threads.hpp\"\n@@ -647,1 +648,0 @@\n-    assert(thread->is_Worker_thread(), \"Only worker thread expected\");\n@@ -666,0 +666,3 @@\n+\n+  \/\/ Note that the safepoint workers may require gclabs if the threads are used to create a heap dump\n+  \/\/ during a concurrent evacuation phase.\n@@ -1193,0 +1196,56 @@\n+class ShenandoahRetireGCLABClosure : public ThreadClosure {\n+private:\n+  bool const _resize;\n+public:\n+  explicit ShenandoahRetireGCLABClosure(bool resize) : _resize(resize) {}\n+  void do_thread(Thread* thread) override {\n+    PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);\n+    assert(gclab != nullptr, \"GCLAB should be initialized for %s\", thread->name());\n+    gclab->retire();\n+    if (_resize && ShenandoahThreadLocalData::gclab_size(thread) > 0) {\n+      ShenandoahThreadLocalData::set_gclab_size(thread, 0);\n+    }\n+\n+    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n+      PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n+      assert(plab != nullptr, \"PLAB should be initialized for %s\", thread->name());\n+\n+      \/\/ There are two reasons to retire all plabs between old-gen evacuation passes.\n+      \/\/  1. We need to make the plab memory parsable by remembered-set scanning.\n+      \/\/  2. We need to establish a trustworthy UpdateWaterMark value within each old-gen heap region\n+      ShenandoahGenerationalHeap::heap()->retire_plab(plab, thread);\n+      if (_resize && ShenandoahThreadLocalData::plab_size(thread) > 0) {\n+        ShenandoahThreadLocalData::set_plab_size(thread, 0);\n+      }\n+    }\n+  }\n+};\n+\n+class ShenandoahGCStatePropagator : public ThreadClosure {\n+public:\n+  explicit ShenandoahGCStatePropagator(char gc_state) : _gc_state(gc_state) {}\n+\n+  void do_thread(Thread* thread) override {\n+    ShenandoahThreadLocalData::set_gc_state(thread, _gc_state);\n+  }\n+private:\n+  char _gc_state;\n+};\n+\n+class ShenandoahPrepareForUpdateRefs : public HandshakeClosure {\n+public:\n+  explicit ShenandoahPrepareForUpdateRefs(char gc_state) :\n+    HandshakeClosure(\"Shenandoah Prepare for Update Refs\"),\n+    _retire(ResizeTLAB), _propagator(gc_state) {}\n+\n+  void do_thread(Thread* thread) override {\n+    _propagator.do_thread(thread);\n+    if (ShenandoahThreadLocalData::gclab(thread) != nullptr) {\n+      _retire.do_thread(thread);\n+    }\n+  }\n+private:\n+  ShenandoahRetireGCLABClosure _retire;\n+  ShenandoahGCStatePropagator _propagator;\n+};\n+\n@@ -1198,0 +1257,19 @@\n+void ShenandoahHeap::concurrent_prepare_for_update_refs() {\n+  \/\/ It's possible that evacuation succeeded, but we could still be cancelled when we get here.\n+  \/\/ A cancellation at this point means the degenerated cycle must resume from update-refs.\n+  set_gc_state_concurrent(EVACUATION, false);\n+  set_gc_state_concurrent(WEAK_ROOTS, false);\n+  set_gc_state_concurrent(UPDATEREFS, true);\n+\n+  \/\/ This will propagate the gc state and retire gclabs and plabs for threads that require it.\n+  ShenandoahPrepareForUpdateRefs prepare_for_update_refs(_gc_state.raw_value());\n+\n+  \/\/ The handshake won't touch non-java threads, so do those separately.\n+  Threads::non_java_threads_do(&prepare_for_update_refs);\n+\n+  \/\/ Now retire gclabs and plabs and propagate gc_state for mutator threads\n+  Handshake::execute(&prepare_for_update_refs);\n+\n+  _update_refs_iterator.reset();\n+}\n+\n@@ -1352,28 +1430,0 @@\n-class ShenandoahRetireGCLABClosure : public ThreadClosure {\n-private:\n-  bool const _resize;\n-public:\n-  ShenandoahRetireGCLABClosure(bool resize) : _resize(resize) {}\n-  void do_thread(Thread* thread) {\n-    PLAB* gclab = ShenandoahThreadLocalData::gclab(thread);\n-    assert(gclab != nullptr, \"GCLAB should be initialized for %s\", thread->name());\n-    gclab->retire();\n-    if (_resize && ShenandoahThreadLocalData::gclab_size(thread) > 0) {\n-      ShenandoahThreadLocalData::set_gclab_size(thread, 0);\n-    }\n-\n-    if (ShenandoahHeap::heap()->mode()->is_generational()) {\n-      PLAB* plab = ShenandoahThreadLocalData::plab(thread);\n-      assert(plab != nullptr, \"PLAB should be initialized for %s\", thread->name());\n-\n-      \/\/ There are two reasons to retire all plabs between old-gen evacuation passes.\n-      \/\/  1. We need to make the plab memory parsable by remembered-set scanning.\n-      \/\/  2. We need to establish a trustworthy UpdateWaterMark value within each old-gen heap region\n-      ShenandoahGenerationalHeap::heap()->retire_plab(plab, thread);\n-      if (_resize && ShenandoahThreadLocalData::plab_size(thread) > 0) {\n-        ShenandoahThreadLocalData::set_plab_size(thread, 0);\n-      }\n-    }\n-  }\n-};\n-\n@@ -1392,0 +1442,4 @@\n+\n+  if (safepoint_workers() != nullptr) {\n+    safepoint_workers()->threads_do(&cl);\n+  }\n@@ -1427,0 +1481,1 @@\n+\n@@ -1936,1 +1991,1 @@\n-void ShenandoahHeap::propagate_gc_state_to_java_threads() {\n+void ShenandoahHeap::propagate_gc_state_to_all_threads() {\n@@ -1939,0 +1994,2 @@\n+    ShenandoahGCStatePropagator propagator(_gc_state.raw_value());\n+    Threads::threads_do(&propagator);\n@@ -1940,4 +1997,0 @@\n-    char state = gc_state();\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {\n-      ShenandoahThreadLocalData::set_gc_state(t, state);\n-    }\n@@ -1947,1 +2000,1 @@\n-void ShenandoahHeap::set_gc_state(uint mask, bool value) {\n+void ShenandoahHeap::set_gc_state_at_safepoint(uint mask, bool value) {\n@@ -1953,0 +2006,4 @@\n+void ShenandoahHeap::set_gc_state_concurrent(uint mask, bool value) {\n+  _gc_state.set_cond(mask, value);\n+}\n+\n@@ -1964,1 +2021,1 @@\n-  set_gc_state(mask, in_progress);\n+  set_gc_state_at_safepoint(mask, in_progress);\n@@ -1980,1 +2037,1 @@\n-    set_gc_state(OLD_MARKING, in_progress);\n+    set_gc_state_at_safepoint(OLD_MARKING, in_progress);\n@@ -1982,1 +2039,1 @@\n-    set_gc_state(MARKING | OLD_MARKING, in_progress);\n+    set_gc_state_at_safepoint(MARKING | OLD_MARKING, in_progress);\n@@ -2009,1 +2066,1 @@\n-  set_gc_state(EVACUATION, in_progress);\n+  set_gc_state_at_safepoint(EVACUATION, in_progress);\n@@ -2021,1 +2078,1 @@\n-  set_gc_state(WEAK_ROOTS, cond);\n+  set_gc_state_at_safepoint(WEAK_ROOTS, cond);\n@@ -2168,1 +2225,1 @@\n-  set_gc_state(HAS_FORWARDED, cond);\n+  set_gc_state_at_safepoint(HAS_FORWARDED, cond);\n@@ -2208,1 +2265,1 @@\n-  set_gc_state(UPDATEREFS, in_progress);\n+  set_gc_state_at_safepoint(UPDATEREFS, in_progress);\n@@ -2613,0 +2670,8 @@\n+bool ShenandoahHeap::is_gc_state(GCState state) const {\n+  \/\/ If the global gc state has been changed, but hasn't yet been propagated to all threads, then\n+  \/\/ the global gc state is the correct value. Once the gc state has been synchronized with all threads,\n+  \/\/ _gc_state_changed will be toggled to false and we need to use the thread local state.\n+  return _gc_state_changed ? _gc_state.is_set(state) : ShenandoahThreadLocalData::is_gc_state(state);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":107,"deletions":42,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -366,2 +366,8 @@\n-  \/\/ This updates the singlular, global gc state. This must happen on a safepoint.\n-  void set_gc_state(uint mask, bool value);\n+  \/\/ This updates the singular, global gc state. This call must happen on a safepoint.\n+  void set_gc_state_at_safepoint(uint mask, bool value);\n+\n+  \/\/ This also updates the global gc state, but does not need to be called on a safepoint.\n+  \/\/ Critically, this method will _not_ flag that the global gc state has changed and threads\n+  \/\/ will continue to use their thread local copy. This is expected to be used in conjunction\n+  \/\/ with a handshake operation to propagate the new gc state.\n+  void set_gc_state_concurrent(uint mask, bool value);\n@@ -370,0 +376,1 @@\n+  \/\/ This returns the raw value of the singular, global gc state.\n@@ -372,3 +379,13 @@\n-  \/\/ This copies the global gc state into a thread local variable for java threads.\n-  \/\/ It is primarily intended to support quick access at barriers.\n-  void propagate_gc_state_to_java_threads();\n+  \/\/ Compares the given state against either the global gc state, or the thread local state.\n+  \/\/ The global gc state may change on a safepoint and is the correct value to use until\n+  \/\/ the global gc state has been propagated to all threads (after which, this method will\n+  \/\/ compare against the thread local state). The thread local gc state may also be changed\n+  \/\/ by a handshake operation, in which case, this function continues using the updated thread\n+  \/\/ local value.\n+  bool is_gc_state(GCState state) const;\n+\n+  \/\/ This copies the global gc state into a thread local variable for all threads.\n+  \/\/ The thread local gc state is primarily intended to support quick access at barriers.\n+  \/\/ All threads are updated because in some cases the control thread or the vm thread may\n+  \/\/ need to execute the load reference barrier.\n+  void propagate_gc_state_to_all_threads();\n@@ -377,1 +394,1 @@\n-  \/\/ a safepoint and that any changes were propagated to java threads after the safepoint.\n+  \/\/ a safepoint and that any changes were propagated to threads after the safepoint.\n@@ -397,1 +414,0 @@\n-  inline bool is_stable() const;\n@@ -399,1 +415,0 @@\n-\n@@ -467,0 +482,4 @@\n+\n+  \/\/ Retires LABs used for evacuation\n+  void concurrent_prepare_for_update_refs();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -67,4 +67,0 @@\n-inline bool ShenandoahHeap::has_forwarded_objects() const {\n-  return _gc_state.is_set(HAS_FORWARDED);\n-}\n-\n@@ -453,2 +449,2 @@\n-inline bool ShenandoahHeap::is_stable() const {\n-  return _gc_state.is_clear();\n+inline bool ShenandoahHeap::is_idle() const {\n+  return _gc_state_changed ? _gc_state.is_clear() : ShenandoahThreadLocalData::gc_state(Thread::current()) == 0;\n@@ -457,2 +453,2 @@\n-inline bool ShenandoahHeap::is_idle() const {\n-  return _gc_state.is_unset(MARKING | EVACUATION | UPDATEREFS);\n+inline bool ShenandoahHeap::has_forwarded_objects() const {\n+  return is_gc_state(HAS_FORWARDED);\n@@ -462,1 +458,1 @@\n-  return _gc_state.is_set(MARKING);\n+  return is_gc_state(MARKING);\n@@ -466,1 +462,1 @@\n-  return _gc_state.is_set(YOUNG_MARKING);\n+  return is_gc_state(YOUNG_MARKING);\n@@ -470,1 +466,1 @@\n-  return _gc_state.is_set(OLD_MARKING);\n+  return is_gc_state(OLD_MARKING);\n@@ -474,1 +470,9 @@\n-  return _gc_state.is_set(EVACUATION);\n+  return is_gc_state(EVACUATION);\n+}\n+\n+inline bool ShenandoahHeap::is_update_refs_in_progress() const {\n+  return is_gc_state(UPDATEREFS);\n+}\n+\n+inline bool ShenandoahHeap::is_concurrent_weak_root_in_progress() const {\n+  return is_gc_state(WEAK_ROOTS);\n@@ -489,4 +493,0 @@\n-inline bool ShenandoahHeap::is_update_refs_in_progress() const {\n-  return _gc_state.is_set(UPDATEREFS);\n-}\n-\n@@ -501,4 +501,0 @@\n-inline bool ShenandoahHeap::is_concurrent_weak_root_in_progress() const {\n-  return _gc_state.is_set(WEAK_ROOTS);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-  if (heap->is_concurrent_mark_in_progress() || heap->is_full_gc_in_progress()) {\n+  if (heap->is_concurrent_mark_in_progress() || heap->is_concurrent_weak_root_in_progress() || heap->is_full_gc_in_progress()) {\n@@ -153,1 +153,1 @@\n-  assert(heap->is_idle(), \"What is it doing?\");\n+  assert(heap->is_idle(), \"Unexpected gc_state: %d\", heap->gc_state());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegionCounters.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-    assert(thread->is_Java_thread(), \"GC state is only synchronized to java threads\");\n@@ -118,0 +117,8 @@\n+  static bool is_gc_state(Thread* thread, ShenandoahHeap::GCState state) {\n+    return (gc_state(thread) & state) != 0;\n+  }\n+\n+  static bool is_gc_state(ShenandoahHeap::GCState state) {\n+    return is_gc_state(Thread::current(), state);\n+  }\n+\n@@ -119,1 +126,0 @@\n-    assert (thread->is_Java_thread() || thread->is_Worker_thread(), \"Only Java and GC worker threads are allowed to get GCLABs\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -92,1 +92,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -99,1 +99,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -106,1 +106,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -113,1 +113,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -120,1 +120,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n@@ -127,1 +127,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -799,1 +799,1 @@\n-  ShenandoahHeap::heap()->propagate_gc_state_to_java_threads();\n+  ShenandoahHeap::heap()->propagate_gc_state_to_all_threads();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}