{"files":[{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.lang.ref.Reference;\n+import java.util.Enumeration;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.lib.hprof.model.JavaClass;\n+import jdk.test.lib.hprof.model.JavaHeapObject;\n+import jdk.test.lib.hprof.model.JavaObject;\n+import jdk.test.lib.hprof.model.JavaValueArray;\n+import jdk.test.lib.hprof.model.JavaThing;\n+import jdk.test.lib.hprof.model.Snapshot;\n+import jdk.test.lib.hprof.parser.Reader;\n+\n+\/**\n+ * @test\n+ * @bug 8316778\n+ * @library \/test\/lib\n+ * @run main HprofTest\n+ *\/\n+\n+class HprofTestTarg extends LingeredApp {\n+    \/\/ Array of primitive types\n+    int[] intArray = new int[2];\n+    \/\/ String\n+    String str = \"test_string\";\n+\n+    public static void main(String[] args) {\n+        HprofTestTarg testObj = new HprofTestTarg();\n+\n+        LingeredApp.main(args);\n+\n+        Reference.reachabilityFence(testObj);\n+    }\n+\n+}\n+\n+\n+public class HprofTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        File dumpFile = new File(\"Myheapdump.hprof\");\n+        createDump(dumpFile);\n+        test(dumpFile);\n+    }\n+\n+    private static void createDump(File dumpFile) throws Exception {\n+        LingeredApp theApp = null;\n+        try {\n+            theApp = new HprofTestTarg();\n+\n+            LingeredApp.startApp(theApp);\n+\n+            \/\/jcmd <pid> GC.heap_dump <file_path>\n+            JDKToolLauncher launcher = JDKToolLauncher\n+                    .createUsingTestJDK(\"jcmd\")\n+                    .addToolArg(Long.toString(theApp.getPid()))\n+                    .addToolArg(\"GC.heap_dump\")\n+                    .addToolArg(dumpFile.getAbsolutePath());\n+            Process p = ProcessTools.startProcess(\"jcmd\", new ProcessBuilder(launcher.getCommand()));\n+            while (!p.waitFor(5, TimeUnit.SECONDS)) {\n+                if (!theApp.getProcess().isAlive()) {\n+                    log(\"ERROR: target VM died, killing jcmd...\");\n+                    p.destroyForcibly();\n+                    throw new Exception(\"Target VM died\");\n+                }\n+            }\n+\n+            if (p.exitValue() != 0) {\n+                throw new Exception(\"Jcmd exited with code \" + p.exitValue());\n+            }\n+        } finally {\n+            LingeredApp.stopApp(theApp);\n+        }\n+    }\n+\n+    private static void test(File dumpFile) throws Exception {\n+        Asserts.assertTrue(dumpFile.exists(), \"Heap dump file not found.\");\n+\n+        log(\"Reading \" + dumpFile + \"...\");\n+        try (Snapshot snapshot = Reader.readFile(dumpFile.getPath(), true, 0)) {\n+            log(\"Resolving snapshot...\");\n+            snapshot.resolve(true);\n+            log(\"Snapshot resolved.\");\n+\n+            JavaObject testObj = getTestObject(snapshot);\n+            testPrimitiveArray(testObj);\n+            testString(testObj);\n+        }\n+\n+    }\n+\n+    \/\/ verifies JavaValueArray.valueString does not throw\n+    \/\/ \"invalid array element type\" exception\n+    private static void testPrimitiveArray(JavaObject obj) {\n+        JavaHeapObject field = getObjectField(obj, \"intArray\");\n+        Asserts.assertTrue(field instanceof JavaValueArray);\n+        log(\"int array: \" + ((JavaValueArray)field).valueString());\n+    }\n+\n+    \/\/ verifies JavaObject.toString returns String value\n+    private static void testString(JavaObject obj) {\n+        JavaHeapObject field = getObjectField(obj, \"str\");\n+        Asserts.assertTrue(field instanceof JavaObject);\n+        JavaObject javaObj = (JavaObject)field;\n+        Asserts.assertTrue(javaObj.getClazz().isString());\n+        log(\"string: \" + javaObj.toString());\n+        assert(javaObj.toString().contains(new HprofTestTarg().str));\n+    }\n+\n+\n+    private static JavaHeapObject getObjectField(JavaObject obj, String fieldName) {\n+        JavaThing thing = obj.getField(fieldName);\n+        \/\/ only non-primitive types are supported\n+        return (JavaHeapObject)thing;\n+    }\n+\n+    \/\/ gets test HprofTestTarg\n+    private static JavaObject getTestObject(Snapshot snapshot) {\n+        String testClassName = HprofTestTarg.class.getName();\n+        JavaHeapObject testObject = getObjects(snapshot, testClassName).nextElement();\n+        Asserts.assertTrue(testObject instanceof JavaObject);\n+        return (JavaObject)testObject;\n+    }\n+\n+    \/\/ finds all objects of the specified type\n+    private static Enumeration<JavaHeapObject> getObjects(Snapshot snapshot, String className) {\n+        log(\"Looking for '\" + className + \"' objects...\");\n+        JavaClass jClass = snapshot.findClass(className);\n+        if (jClass == null) {\n+            throw new RuntimeException(\"Class '\" + className + \"' not found\");\n+        }\n+        int instanceCount = jClass.getInstancesCount(false);\n+        if (instanceCount < 1) {\n+            throw new RuntimeException(\"Not instances of '\" + className + \"' found\");\n+        }\n+        log(\"Found \" + instanceCount + \" instance(s).\");\n+        return jClass.getInstances(false);\n+    }\n+\n+    private static void log(Object s) {\n+        System.out.println(s);\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/hprof\/HprofTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,1 @@\n-                return ((JavaValueArray)value).valueString();\n+                return ((JavaValueArray)value).valueAsString();\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaObject.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,2 +69,2 @@\n-            case T_BYTE:\n-            case T_BOOLEAN:\n+            case 'B':\n+            case 'Z':\n@@ -72,2 +72,2 @@\n-            case T_CHAR:\n-            case T_SHORT:\n+            case 'C':\n+            case 'S':\n@@ -75,2 +75,2 @@\n-            case T_INT:\n-            case T_FLOAT:\n+            case 'I':\n+            case 'F':\n@@ -78,2 +78,2 @@\n-            case T_LONG:\n-            case T_DOUBLE:\n+            case 'J':\n+            case 'D':\n@@ -350,0 +350,14 @@\n+\n+    \/\/ Tries to represent the value as string (used by JavaObject.toString).\n+    public String valueAsString() {\n+        if (getElementType() == 'B')  {\n+            JavaThing[] things = getValue();\n+            byte[] bytes = new byte[things.length];\n+            for (int i = 0; i < things.length; i++) {\n+                bytes[i] = ((JavaByte)things[i]).value;\n+            }\n+            return new String(bytes);\n+        }\n+        \/\/ fallback\n+        return valueString();\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/hprof\/model\/JavaValueArray.java","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"}]}