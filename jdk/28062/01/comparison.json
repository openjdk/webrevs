{"files":[{"patch":"@@ -276,1 +276,1 @@\n-        hi = (1UL << bitcount) - 1;\n+        hi = (1ULL << bitcount) - 1;\n@@ -379,1 +379,1 @@\n-        hi = MIN2((jlong)((1UL << result_bit_width) - 1L), hi);\n+        hi = MIN2((jlong)((1ULL << result_bit_width) - 1L), hi);\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8350896\n+ * @bug 8350896 8370459\n@@ -65,2 +65,4 @@\n-    public final int BOUND_LO_I = GEN_I.next();\n-    public final int BOUND_HI_I = GEN_I.next();\n+    public final int BOUND1_LO_I = GEN_I.next();\n+    public final int BOUND2_LO_I = GEN_I.next();\n+    public final int BOUND1_HI_I = GEN_I.next();\n+    public final int BOUND2_HI_I = GEN_I.next();\n@@ -68,2 +70,4 @@\n-    public final long BOUND_LO_L = GEN_L.next();\n-    public final long BOUND_HI_L = GEN_L.next();\n+    public final long BOUND1_LO_L = GEN_L.next();\n+    public final long BOUND2_LO_L = GEN_L.next();\n+    public final long BOUND1_HI_L = GEN_L.next();\n+    public final long BOUND2_HI_L = GEN_L.next();\n@@ -330,1 +334,2 @@\n-        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        src = Math.max(BOUND1_LO_I, Math.min(src, BOUND1_HI_I));\n+        mask = Math.max(BOUND2_LO_I, Math.min(mask, BOUND2_HI_I));\n@@ -363,1 +368,2 @@\n-        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        src = Math.max(BOUND1_LO_I, Math.min(src, BOUND1_HI_I));\n+        mask = Math.max(BOUND2_LO_I, Math.min(mask, BOUND2_HI_I));\n@@ -414,1 +420,2 @@\n-        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        src = Math.max(BOUND1_LO_I, Math.min(src, BOUND1_HI_I));\n+        mask = Math.max(BOUND2_LO_I, Math.min(mask, BOUND2_HI_I));\n@@ -447,1 +454,2 @@\n-        src = Math.max(BOUND_LO_I, Math.min(src, BOUND_HI_I));\n+        src = Math.max(BOUND1_LO_I, Math.min(src, BOUND1_HI_I));\n+        mask = Math.max(BOUND2_LO_I, Math.min(mask, BOUND2_HI_I));\n@@ -498,1 +506,2 @@\n-        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        src = Math.max(BOUND1_LO_L, Math.min(src, BOUND1_HI_L));\n+        mask = Math.max(BOUND2_LO_L, Math.min(mask, BOUND2_HI_L));\n@@ -531,1 +540,2 @@\n-        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        src = Math.max(BOUND1_LO_L, Math.min(src, BOUND1_HI_L));\n+        mask = Math.max(BOUND2_LO_L, Math.min(mask, BOUND2_HI_L));\n@@ -582,1 +592,2 @@\n-        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        src = Math.max(BOUND1_LO_L, Math.min(src, BOUND1_HI_L));\n+        mask = Math.max(BOUND2_LO_L, Math.min(mask, BOUND2_HI_L));\n@@ -615,1 +626,2 @@\n-        src = Math.max(BOUND_LO_L, Math.min(src, BOUND_HI_L));\n+        src = Math.max(BOUND1_LO_L, Math.min(src, BOUND1_HI_L));\n+        mask = Math.max(BOUND2_LO_L, Math.min(mask, BOUND2_HI_L));\n@@ -664,0 +676,84 @@\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public static long test20(int x) {\n+        \/\/ Analysis of when this is used to produce wrong results on Windows:\n+        \/\/\n+        \/\/ src  = -2683206580L = ffff_ffff_6011_844c\n+        \/\/ mask = 0..maxuint, at runtime: 4294950911 = 0xffff_bfff\n+        \/\/\n+        \/\/ Hence we go to the B) case of CompressBits in bitshuffle_value\n+        \/\/\n+        \/\/ mask_bit_width = 64\n+        \/\/ clz = 32\n+        \/\/ result_bit_width = 32\n+        \/\/\n+        \/\/ So we have result_bit_width < mask_bit_width\n+        \/\/\n+        \/\/ And we do:\n+        \/\/ lo = result_bit_width == mask_bit_width ? lo : 0L;\n+        \/\/ -> lo = 0\n+        \/\/\n+        \/\/ And we do:\n+        \/\/ hi = MIN2((jlong)((1UL << result_bit_width) - 1L), hi);\n+        \/\/\n+        \/\/ But watch out: on windows 1UL is only a 32 bit value. Intended was probably 1ULL.\n+        \/\/ So when we calculate \"1UL << 32\", we just get 1. And so then hi would be 0 now.\n+        \/\/ If we instead did \"1ULL << 32\", we would get 0x1_0000_0000, and hi = 0xffff_ffff.\n+        \/\/\n+        \/\/ We create type [lo, hi]:\n+        \/\/ Windows: [0, 0]           -> constant zero\n+        \/\/ correct:  [0, 0xffff_ffff] -> does not constant fold. At runtime: 0x3008_c44c\n+        return Long.compress(-2683206580L, Integer.toUnsignedLong(x));\n+    }\n+\n+    @DontCompile\n+    public static long test20_interpreted(int x) {\n+        return Long.compress(-2683206580L, Integer.toUnsignedLong(x));\n+    }\n+\n+    @Run (test = \"test20\")\n+    public void run20() {\n+        for (int i = 0; i < 100; i++) {\n+            int arg = GEN_I.next();\n+\n+            long actual = test20(arg);\n+            long expected = test20_interpreted(arg);\n+            Asserts.assertEQ(actual, expected);\n+        }\n+    }\n+\n+    @Test\n+    @IR (counts = { IRNode.COMPRESS_BITS, \" >0 \" }, applyIfCPUFeature = { \"bmi2\", \"true\" })\n+    public static long test21(long x) {\n+        \/\/ Analysis of when this is used to produce wrong results on Windows:\n+        \/\/\n+        \/\/ Very similar to case in test20, but this time we go into the A) case.\n+        \/\/\n+        \/\/ maskcon = 0xffff_ffff\n+        \/\/ bitcount = 32\n+        \/\/\n+        \/\/ And now the problematic part:\n+        \/\/ hi = (1UL << bitcount) - 1;\n+        \/\/\n+        \/\/ On Windows, this becomes 0 (but it should be 0xffff_ffff).\n+        \/\/ Hence, the range wrongly collapses to [0, 0], and the CompressBits node\n+        \/\/ is wrongly replaced with a zero constant.\n+        return Long.compress(x, 0xffff_ffffL);\n+    }\n+\n+    @DontCompile\n+    public static long test21_interpreted(long x) {\n+        return Long.compress(x, 0xffff_ffffL);\n+    }\n+\n+    @Run (test = \"test21\")\n+    public void run21() {\n+        for (int i = 0; i < 100; i++) {\n+            int arg = GEN_I.next();\n+\n+            long actual = test21(arg);\n+            long expected = test21_interpreted(arg);\n+            Asserts.assertEQ(actual, expected);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBitCompressValueTransform.java","additions":109,"deletions":13,"binary":false,"changes":122,"status":"modified"}]}