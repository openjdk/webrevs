{"files":[{"patch":"@@ -2326,0 +2326,1 @@\n+  INSN(vandn_vx,   0b1010111, 0b100, 0b000001);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1190,0 +1190,64 @@\n+instruct vand_notI_vx(vReg dst, vReg src1, iRegIorL2I src2, immI_M1 m1) %{\n+  predicate(UseZvbb);\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (AndV src1 (Replicate (XorI src2 m1))));\n+  format %{ \"vand_notI_vx $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg),\n+                as_Register($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL_vx(vReg dst, vReg src1, iRegL src2, immL_M1 m1) %{\n+  predicate(UseZvbb);\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst (AndV src1 (Replicate (XorL src2 m1))));\n+  format %{ \"vand_notL_vx $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst$$reg),\n+                as_VectorRegister($src1$$reg),\n+                as_Register($src2$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notI_vx_masked(vReg dst_src1, iRegIorL2I src2, immI_M1 m1, vRegMask_V0 v0) %{\n+  predicate(UseZvbb);\n+  predicate(Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_BYTE ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (Replicate (XorI src2 m1))) v0));\n+  format %{ \"vand_notI_vx_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_Register($src2$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vand_notL_vx_masked(vReg dst_src1, iRegL src2, immL_M1 m1, vRegMask_V0 v0) %{\n+  predicate(UseZvbb);\n+  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n+  match(Set dst_src1 (AndV (Binary dst_src1 (Replicate (XorL src2 m1))) v0));\n+  format %{ \"vand_notL_vx_masked $dst_src1, $dst_src1, $src2, $v0\" %}\n+  ins_encode %{\n+    __ vsetvli_helper(T_LONG, Matcher::vector_length(this));\n+    __ vandn_vx(as_VectorRegister($dst_src1$$reg),\n+                as_VectorRegister($dst_src1$$reg),\n+                as_Register($src2$$reg),\n+                Assembler::v0_t);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2139,0 +2139,20 @@\n+    public static final String RISCV_VAND_NOTI_VX = PREFIX + \"RISCV_VAND_NOTI_VX\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTI_VX, \"vand_notI_vx\");\n+    }\n+\n+    public static final String RISCV_VAND_NOTL_VX = PREFIX + \"RISCV_VAND_NOTL_VX\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTL_VX, \"vand_notL_vx\");\n+    }\n+\n+    public static final String RISCV_VAND_NOTI_VX_MASKED = PREFIX + \"RISCV_VAND_NOTI_VX_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTI_VX_MASKED, \"vand_notI_vx_masked\");\n+    }\n+\n+    public static final String RISCV_VAND_NOTL_VX_MASKED = PREFIX + \"RISCV_VAND_NOTL_VX_MASKED\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(RISCV_VAND_NOTL_VX_MASKED, \"vand_notL_vx_masked\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -157,0 +157,62 @@\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.RISCV_VAND_NOTI_VX, \" >= 1\" }, applyIfPlatform = {\"riscv64\", \"true\"})\n+    public static void testAllBitsSetVectorRegI() {\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        int bs = ib[0];\n+        av.not().lanewise(VectorOperators.AND_NOT, bs).intoArray(ir, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals((~ia[i]) & (~bs), ir[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.RISCV_VAND_NOTL_VX, \" >= 1\" }, applyIfPlatform = {\"riscv64\", \"true\"})\n+    public static void testAllBitsSetVectorRegL() {\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        long bs = lb[0];\n+        av.not().lanewise(VectorOperators.AND_NOT, bs).intoArray(lr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            Asserts.assertEquals((~la[i]) & (~bs), lr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.RISCV_VAND_NOTI_VX_MASKED, \" >= 1\" }, applyIfPlatform = {\"riscv64\", \"true\"})\n+    public static void testAllBitsSetVectorRegIMask() {\n+        VectorMask<Integer> avm = VectorMask.fromArray(I_SPECIES, ma, 0);\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        int bs = ib[0];\n+        av.not().lanewise(VectorOperators.AND_NOT, bs, avm).intoArray(ir, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            if (ma[i] == true) {\n+                Asserts.assertEquals((~ia[i]) & (~bs), ir[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.RISCV_VAND_NOTL_VX_MASKED, \" >= 1\" }, applyIfPlatform = {\"riscv64\", \"true\"})\n+    public static void testAllBitsSetVectorRegLMask() {\n+        VectorMask<Long> avm = VectorMask.fromArray(L_SPECIES, ma, 0);\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        long bs = lb[0];\n+        av.not().lanewise(VectorOperators.AND_NOT, bs, avm).intoArray(lr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            if (ma[i] == true) {\n+                Asserts.assertEquals((~la[i]) & (~bs), lr[i]);\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/AllBitsSetVectorMatchRuleTest.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"}]}