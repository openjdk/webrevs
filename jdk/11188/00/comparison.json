{"files":[{"patch":"@@ -1799,2 +1799,3 @@\n-        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-        slow_path = &stub->slow_path();\n+        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+        Compile::current()->output()->add_stub(stub);\n+        slow_path = &stub->entry();\n@@ -1882,1 +1883,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/c2_CodeStubs.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+\n+#define __ masm.\n+\n+void C2SafepointPollStub::emit(C2_MacroAssembler& masm) {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  RuntimeAddress callback_addr(stub);\n+\n+  __ bind(entry());\n+  InternalAddress safepoint_pc(masm.pc() - masm.offset() + _safepoint_offset);\n+  __ adr(rscratch1, safepoint_pc);\n+  __ str(rscratch1, Address(rthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(callback_addr);\n+}\n+\n+void C2EntryBarrierStub::emit(C2_MacroAssembler& masm) {\n+  __ bind(entry());\n+  __ movptr(rscratch1, (uintptr_t) StubRoutines::aarch64::method_entry_barrier());\n+  __ blr(rscratch1);\n+  __ b(continuation());\n+\n+  __ bind(guard());\n+  __ relocate(entry_guard_Relocation::spec());\n+  __ emit_int32(0);   \/\/ nmethod guard value\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_CodeStubs_aarch64.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -48,15 +48,0 @@\n-void C2_MacroAssembler::emit_entry_barrier_stub(C2EntryBarrierStub* stub) {\n-  bind(stub->slow_path());\n-  movptr(rscratch1, (uintptr_t) StubRoutines::aarch64::method_entry_barrier());\n-  blr(rscratch1);\n-  b(stub->continuation());\n-\n-  bind(stub->guard());\n-  relocate(entry_guard_Relocation::spec());\n-  emit_int32(0);   \/\/ nmethod guard value\n-}\n-\n-int C2_MacroAssembler::entry_barrier_stub_size() {\n-  return 4 * 6;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"opto\/compile.hpp\"\n-#include \"opto\/node.hpp\"\n-#include \"opto\/output.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-\n-#define __ masm.\n-void C2SafepointPollStubTable::emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n-         \"polling page return stub not created yet\");\n-  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n-  RuntimeAddress callback_addr(stub);\n-\n-  __ bind(entry->_stub_label);\n-  InternalAddress safepoint_pc(masm.pc() - masm.offset() + entry->_safepoint_offset);\n-  __ adr(rscratch1, safepoint_pc);\n-  __ str(rscratch1, Address(rthread, JavaThread::saved_exception_pc_offset()));\n-  __ far_jump(callback_addr);\n-}\n-#undef __\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_safepointPollStubTable_aarch64.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/c2_CodeStubs.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+\n+#define __ masm.\n+\n+void C2SafepointPollStub::emit(C2_MacroAssembler& masm) {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  __ bind(entry());\n+  \/\/ Using pc relative address computation.\n+  {\n+    Label next_pc;\n+    __ bl(next_pc);\n+    __ bind(next_pc);\n+  }\n+  int current_offset = __ offset();\n+  \/\/ Code size should not depend on offset: see _stub_size computation in output.cpp\n+  __ load_const32(R12, _safepoint_offset - current_offset);\n+  __ mflr(R0);\n+  __ add(R12, R12, R0);\n+  __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n+\n+  __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n+  __ mtctr(R0);\n+  __ bctr();\n+}\n+#undef __\n","filename":"src\/hotspot\/cpu\/ppc\/c2_CodeStubs_ppc.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"macroAssembler_ppc.inline.hpp\"\n-#include \"opto\/compile.hpp\"\n-#include \"opto\/node.hpp\"\n-#include \"opto\/output.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-\n-#define __ masm.\n-void C2SafepointPollStubTable::emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n-         \"polling page return stub not created yet\");\n-  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n-  __ bind(entry->_stub_label);\n-  \/\/ Using pc relative address computation.\n-  {\n-    Label next_pc;\n-    __ bl(next_pc);\n-    __ bind(next_pc);\n-  }\n-  int current_offset = __ offset();\n-  \/\/ Code size should not depend on offset: see _stub_size computation in output.cpp\n-  __ load_const32(R12, entry->_safepoint_offset - current_offset);\n-  __ mflr(R0);\n-  __ add(R12, R12, R0);\n-  __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n-\n-  __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n-  __ mtctr(R0);\n-  __ bctr();\n-}\n-#undef __\n","filename":"src\/hotspot\/cpu\/ppc\/c2_safepointPollStubTable_ppc.cpp","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -986,0 +986,1 @@\n+#include \"opto\/c2_CodeStubs.hpp\"\n@@ -1619,1 +1620,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/c2_CodeStubs.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+\n+#define __ masm.\n+\n+void C2SafepointPollStub::emit(C2_MacroAssembler& masm) {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+  RuntimeAddress callback_addr(stub);\n+\n+  __ bind(entry());\n+  InternalAddress safepoint_pc(__ pc() - __ offset() + _safepoint_offset);\n+  __ relocate(safepoint_pc.rspec(), [&] {\n+    __ la(t0, safepoint_pc.target());\n+  });\n+  __ sd(t0, Address(xthread, JavaThread::saved_exception_pc_offset()));\n+  __ far_jump(callback_addr);\n+}\n+\n+void C2EntryBarrierStub::emit(C2_MacroAssembler& masm) {\n+  Assembler::IncompressibleRegion ir(&masm); \/\/ Fixed length\n+\n+  \/\/ make guard value 4-byte aligned so that it can be accessed by atomic instructions on riscv\n+  int alignment_bytes = __ align(4);\n+\n+  __ bind(entry());\n+\n+  int32_t offset = 0;\n+  __ movptr(t0, StubRoutines::riscv::method_entry_barrier(), offset);\n+  __ jalr(ra, t0, offset);\n+  __ j(continuation());\n+\n+  __ bind(guard());\n+  __ relocate(entry_guard_Relocation::spec());\n+  __ assert_alignment(__ pc());\n+  __ emit_int32(0);  \/\/ nmethod guard value\n+  \/\/ make sure the stub with a fixed code size\n+  if (alignment_bytes == 2) {\n+    assert(UseRVC, \"bad alignment\");\n+    __ c_nop();\n+  } else {\n+    assert(alignment_bytes == 0, \"bad alignment\");\n+    __ nop();\n+  }\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/riscv\/c2_CodeStubs_riscv.cpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -246,31 +246,0 @@\n-void C2_MacroAssembler::emit_entry_barrier_stub(C2EntryBarrierStub* stub) {\n-  IncompressibleRegion ir(this);  \/\/ Fixed length: see C2_MacroAssembler::entry_barrier_stub_size()\n-\n-  \/\/ make guard value 4-byte aligned so that it can be accessed by atomic instructions on riscv\n-  int alignment_bytes = align(4);\n-\n-  bind(stub->slow_path());\n-\n-  int32_t offset = 0;\n-  movptr(t0, StubRoutines::riscv::method_entry_barrier(), offset);\n-  jalr(ra, t0, offset);\n-  j(stub->continuation());\n-\n-  bind(stub->guard());\n-  relocate(entry_guard_Relocation::spec());\n-  assert_alignment(pc());\n-  emit_int32(0);  \/\/ nmethod guard value\n-  \/\/ make sure the stub with a fixed code size\n-  if (alignment_bytes == 2) {\n-    assert(UseRVC, \"bad alignment\");\n-    c_nop();\n-  } else {\n-    assert(alignment_bytes == 0, \"bad alignment\");\n-    nop();\n-  }\n-}\n-\n-int C2_MacroAssembler::entry_barrier_stub_size() {\n-  return 8 * 4 + 4; \/\/ 4 bytes for alignment margin\n-}\n-\n@@ -1728,1 +1697,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"opto\/compile.hpp\"\n-#include \"opto\/node.hpp\"\n-#include \"opto\/output.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-\n-#define __ masm.\n-void C2SafepointPollStubTable::emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n-         \"polling page return stub not created yet\");\n-  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-  RuntimeAddress callback_addr(stub);\n-\n-  __ bind(entry->_stub_label);\n-  InternalAddress safepoint_pc(__ pc() - __ offset() + entry->_safepoint_offset);\n-  __ relocate(safepoint_pc.rspec(), [&] {\n-    __ la(t0, safepoint_pc.target());\n-  });\n-  __ sd(t0, Address(xthread, JavaThread::saved_exception_pc_offset()));\n-  __ far_jump(callback_addr);\n-}\n-#undef __\n","filename":"src\/hotspot\/cpu\/riscv\/c2_safepointPollStubTable_riscv.cpp","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1362,2 +1362,3 @@\n-        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-        slow_path = &stub->slow_path();\n+        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+        Compile::current()->output()->add_stub(stub);\n+        slow_path = &stub->entry();\n@@ -1444,1 +1445,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/c2_CodeStubs.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+\n+#define __ masm.\n+\n+void C2SafepointPollStub::emit(C2_MacroAssembler& masm) {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  RuntimeAddress callback_addr(stub);\n+\n+  __ bind(entry());\n+  InternalAddress safepoint_pc(masm.pc() - masm.offset() + _safepoint_offset);\n+#ifdef _LP64\n+  __ lea(rscratch1, safepoint_pc);\n+  __ movptr(Address(r15_thread, JavaThread::saved_exception_pc_offset()), rscratch1);\n+#else\n+  const Register tmp1 = rcx;\n+  const Register tmp2 = rdx;\n+  __ push(tmp1);\n+  __ push(tmp2);\n+\n+  __ lea(tmp1, safepoint_pc);\n+  __ get_thread(tmp2);\n+  __ movptr(Address(tmp2, JavaThread::saved_exception_pc_offset()), tmp1);\n+\n+  __ pop(tmp2);\n+  __ pop(tmp1);\n+#endif\n+  __ jump(callback_addr);\n+}\n+\n+void C2EntryBarrierStub::emit(C2_MacroAssembler& masm) {\n+  __ bind(entry());\n+  __ call(RuntimeAddress(StubRoutines::x86::method_entry_barrier()));\n+  __ jmp(continuation(), false \/* maybe_short *\/);\n+}\n+\n+#undef __\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -141,2 +141,3 @@\n-        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-        slow_path = &stub->slow_path();\n+        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+        Compile::current()->output()->add_stub(stub);\n+        slow_path = &stub->entry();\n@@ -154,10 +155,0 @@\n-void C2_MacroAssembler::emit_entry_barrier_stub(C2EntryBarrierStub* stub) {\n-  bind(stub->slow_path());\n-  call(RuntimeAddress(StubRoutines::x86::method_entry_barrier()));\n-  jmp(stub->continuation(), false \/* maybe_short *\/);\n-}\n-\n-int C2_MacroAssembler::entry_barrier_stub_size() {\n-  return 10;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"opto\/compile.hpp\"\n-#include \"opto\/node.hpp\"\n-#include \"opto\/output.hpp\"\n-#include \"runtime\/sharedRuntime.hpp\"\n-\n-#define __ masm.\n-void C2SafepointPollStubTable::emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n-         \"polling page return stub not created yet\");\n-  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n-\n-  RuntimeAddress callback_addr(stub);\n-\n-  __ bind(entry->_stub_label);\n-  InternalAddress safepoint_pc(masm.pc() - masm.offset() + entry->_safepoint_offset);\n-#ifdef _LP64\n-  __ lea(rscratch1, safepoint_pc);\n-  __ movptr(Address(r15_thread, JavaThread::saved_exception_pc_offset()), rscratch1);\n-#else\n-  const Register tmp1 = rcx;\n-  const Register tmp2 = rdx;\n-  __ push(tmp1);\n-  __ push(tmp2);\n-\n-  __ lea(tmp1, safepoint_pc);\n-  __ get_thread(tmp2);\n-  __ movptr(Address(tmp2, JavaThread::saved_exception_pc_offset()), tmp1);\n-\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-#endif\n-  __ jump(callback_addr);\n-}\n-#undef __\n","filename":"src\/hotspot\/cpu\/x86\/c2_safepointPollStubTable_x86.cpp","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -711,1 +711,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1023,1 +1023,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"opto\/c2_CodeStubs.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/output.hpp\"\n+\n+volatile int C2SafepointPollStub::_stub_size = 0;\n+volatile int C2EntryBarrierStub::_stub_size = 0;\n+\n+int C2CodeStub::measure_stub_size(C2CodeStub& stub) {\n+  Compile* const C = Compile::current();\n+  BufferBlob* const blob = C->output()->scratch_buffer_blob();\n+  CodeBuffer cb(blob->content_begin(), C->output()->scratch_buffer_code_size());\n+  C2_MacroAssembler masm(&cb);\n+  stub.emit(masm);\n+  stub.reinit_labels();\n+  return cb.insts_size();\n+}\n+\n+int C2CodeStub::stub_size(volatile int* stub_size) {\n+  int size = Atomic::load(stub_size);\n+\n+  if (size != 0) {\n+    return size;\n+  }\n+\n+  size = measure_stub_size(*this);\n+  Atomic::store(stub_size, size);\n+  return size;\n+}\n+\n+C2CodeStubList::C2CodeStubList() :\n+  _stubs(Compile::current()->comp_arena(), 2, 0, NULL) {}\n+\n+int C2CodeStubList::measure_code_size() const {\n+  int size = 0;\n+  for (int i = _stubs.length() - 1; i >= 0; i--) {\n+    C2CodeStub* stub = _stubs.at(i);\n+    size += stub->size();\n+  }\n+  return size;\n+}\n+\n+void C2CodeStubList::emit(CodeBuffer& cb) {\n+  C2_MacroAssembler masm(&cb);\n+  for (int i = _stubs.length() - 1; i >= 0; i--) {\n+    \/\/ Make sure there is enough space in the code buffer\n+    if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n+    }\n+\n+    C2CodeStub* stub = _stubs.at(i);\n+    stub->emit(masm);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"asm\/assembler.hpp\"\n+#include \"asm\/codeBuffer.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"opto\/c2_MacroAssembler.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+#ifndef SHARE_OPTO_C2_CODESTUBS_HPP\n+#define SHARE_OPTO_C2_CODESTUBS_HPP\n+\n+class C2CodeStub : public ArenaObj {\n+private:\n+  Label _entry;\n+  Label _continuation;\n+\n+protected:\n+  C2CodeStub() :\n+    _entry(),\n+    _continuation() {}\n+\n+  \/\/ A helper to determine the size of a stub implementation.\n+  \/\/ It is recommended to call this only once and cache the\n+  \/\/ result in a static field.\n+  static int measure_stub_size(C2CodeStub& stub);\n+\n+  int stub_size(volatile int* stub_size);\n+public:\n+  Label& entry()        { return _entry; }\n+  Label& continuation() { return _continuation; }\n+  virtual void emit(C2_MacroAssembler& masm) = 0;\n+  virtual int size() = 0;\n+  virtual void reinit_labels() {\n+    _entry.init();\n+    _continuation.init();\n+  }\n+};\n+\n+class C2CodeStubList {\n+private:\n+  GrowableArray<C2CodeStub*> _stubs;\n+public:\n+  C2CodeStubList();\n+\n+  void add_stub(C2CodeStub* stub) { _stubs.append(stub); }\n+  int  measure_code_size() const;\n+  void emit(CodeBuffer& cb);\n+};\n+\n+class C2SafepointPollStub : public C2CodeStub {\n+private:\n+  static volatile int _stub_size;\n+  uintptr_t _safepoint_offset;\n+public:\n+  C2SafepointPollStub(uintptr_t safepoint_offset) :\n+    _safepoint_offset(safepoint_offset) {}\n+  int size() { return stub_size(&_stub_size); }\n+  void emit(C2_MacroAssembler& masm);\n+};\n+\n+\/\/ We move non-hot code of the nmethod entry barrier to an out-of-line stub\n+class C2EntryBarrierStub: public C2CodeStub {\n+  static volatile int _stub_size;\n+  Label _guard; \/\/ Used on AArch64 and RISCV\n+\n+public:\n+  C2EntryBarrierStub() : C2CodeStub(),\n+    _guard() {}\n+\n+  Label& guard() { return _guard; }\n+\n+  int size() { return stub_size(&_stub_size); }\n+  void emit(C2_MacroAssembler& masm);\n+\n+  virtual void reinit_labels() {\n+    C2CodeStub::reinit_labels();\n+    _guard.init();\n+  }\n+};\n+\n+#endif \/\/ SHARE_OPTO_C2_CODESTUBS_HPP\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/opto\/c2_MacroAssembler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -221,104 +221,0 @@\n-volatile int C2SafepointPollStubTable::_stub_size = 0;\n-\n-Label& C2SafepointPollStubTable::add_safepoint(uintptr_t safepoint_offset) {\n-  C2SafepointPollStub* entry = new (Compile::current()->comp_arena()) C2SafepointPollStub(safepoint_offset);\n-  _safepoints.append(entry);\n-  return entry->_stub_label;\n-}\n-\n-void C2SafepointPollStubTable::emit(CodeBuffer& cb) {\n-  MacroAssembler masm(&cb);\n-  for (int i = _safepoints.length() - 1; i >= 0; i--) {\n-    \/\/ Make sure there is enough space in the code buffer\n-    if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n-      ciEnv::current()->record_failure(\"CodeCache is full\");\n-      return;\n-    }\n-\n-    C2SafepointPollStub* entry = _safepoints.at(i);\n-    emit_stub(masm, entry);\n-  }\n-}\n-\n-int C2SafepointPollStubTable::stub_size_lazy() const {\n-  int size = Atomic::load(&_stub_size);\n-\n-  if (size != 0) {\n-    return size;\n-  }\n-\n-  Compile* const C = Compile::current();\n-  BufferBlob* const blob = C->output()->scratch_buffer_blob();\n-  CodeBuffer cb(blob->content_begin(), C->output()->scratch_buffer_code_size());\n-  MacroAssembler masm(&cb);\n-  C2SafepointPollStub* entry = _safepoints.at(0);\n-  emit_stub(masm, entry);\n-  size += cb.insts_size();\n-\n-  Atomic::store(&_stub_size, size);\n-\n-  return size;\n-}\n-\n-int C2SafepointPollStubTable::estimate_stub_size() const {\n-  if (_safepoints.length() == 0) {\n-    return 0;\n-  }\n-\n-  int result = stub_size_lazy() * _safepoints.length();\n-\n-#ifdef ASSERT\n-  Compile* const C = Compile::current();\n-  BufferBlob* const blob = C->output()->scratch_buffer_blob();\n-  int size = 0;\n-\n-  for (int i = _safepoints.length() - 1; i >= 0; i--) {\n-    CodeBuffer cb(blob->content_begin(), C->output()->scratch_buffer_code_size());\n-    MacroAssembler masm(&cb);\n-    C2SafepointPollStub* entry = _safepoints.at(i);\n-    emit_stub(masm, entry);\n-    size += cb.insts_size();\n-  }\n-  assert(size == result, \"stubs should not have variable size\");\n-#endif\n-\n-  return result;\n-}\n-\n-\/\/ Nmethod entry barrier stubs\n-C2EntryBarrierStub* C2EntryBarrierStubTable::add_entry_barrier() {\n-  assert(_stub == NULL, \"There can only be one entry barrier stub\");\n-  _stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n-  return _stub;\n-}\n-\n-void C2EntryBarrierStubTable::emit(CodeBuffer& cb) {\n-  if (_stub == NULL) {\n-    \/\/ No stub - nothing to do\n-    return;\n-  }\n-\n-  C2_MacroAssembler masm(&cb);\n-  \/\/ Make sure there is enough space in the code buffer\n-  if (cb.insts()->maybe_expand_to_ensure_remaining(PhaseOutput::MAX_inst_size) && cb.blob() == NULL) {\n-    ciEnv::current()->record_failure(\"CodeCache is full\");\n-    return;\n-  }\n-\n-  intptr_t before = masm.offset();\n-  masm.emit_entry_barrier_stub(_stub);\n-  intptr_t after = masm.offset();\n-  int actual_size = (int)(after - before);\n-  int expected_size = masm.entry_barrier_stub_size();\n-  assert(actual_size == expected_size, \"Estimated size is wrong, expected %d, was %d\", expected_size, actual_size);\n-}\n-\n-int C2EntryBarrierStubTable::estimate_stub_size() const {\n-  if (BarrierSet::barrier_set()->barrier_set_nmethod() == NULL) {\n-    \/\/ No nmethod entry barrier?\n-    return 0;\n-  }\n-\n-  return C2_MacroAssembler::entry_barrier_stub_size();\n-}\n-\n@@ -331,2 +227,1 @@\n-    _safepoint_poll_table(),\n-    _entry_barrier_table(),\n+    _stub_list(),\n@@ -1352,2 +1247,1 @@\n-  stub_req += safepoint_poll_table()->estimate_stub_size();\n-  stub_req += entry_barrier_table()->estimate_stub_size();\n+  stub_req += _stub_list.measure_code_size();\n@@ -1860,6 +1754,2 @@\n-  \/\/ Fill in stubs for calling the runtime from safepoint polls.\n-  safepoint_poll_table()->emit(*cb);\n-  if (C->failing())  return;\n-\n-  \/\/ Fill in stubs for calling the runtime from nmethod entries.\n-  entry_barrier_table()->emit(*cb);\n+  \/\/ Fill in stubs.\n+  _stub_list.emit(*cb);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":4,"deletions":114,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"opto\/c2_CodeStubs.hpp\"\n@@ -76,69 +77,0 @@\n-class C2SafepointPollStubTable {\n-private:\n-  struct C2SafepointPollStub: public ArenaObj {\n-    uintptr_t _safepoint_offset;\n-    Label     _stub_label;\n-    Label     _trampoline_label;\n-    C2SafepointPollStub(uintptr_t safepoint_offset) :\n-      _safepoint_offset(safepoint_offset),\n-      _stub_label(),\n-      _trampoline_label() {}\n-  };\n-\n-  GrowableArray<C2SafepointPollStub*> _safepoints;\n-\n-  static volatile int _stub_size;\n-\n-  void emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const;\n-\n-  \/\/ The selection logic below relieves the need to add dummy files to unsupported platforms.\n-  template <bool enabled>\n-  typename EnableIf<enabled>::type\n-  select_emit_stub(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-    emit_stub_impl(masm, entry);\n-  }\n-\n-  template <bool enabled>\n-  typename EnableIf<!enabled>::type\n-  select_emit_stub(MacroAssembler& masm, C2SafepointPollStub* entry) const {}\n-\n-  void emit_stub(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n-    select_emit_stub<VM_Version::supports_stack_watermark_barrier()>(masm, entry);\n-  }\n-\n-  int stub_size_lazy() const;\n-\n-public:\n-  Label& add_safepoint(uintptr_t safepoint_offset);\n-  int estimate_stub_size() const;\n-  void emit(CodeBuffer& cb);\n-};\n-\n-\/\/ We move non-hot code of the nmethod entry barrier to an out-of-line stub\n-class C2EntryBarrierStub: public ArenaObj {\n-  Label _slow_path;\n-  Label _continuation;\n-  Label _guard; \/\/ Used on AArch64 and RISCV\n-\n-public:\n-  C2EntryBarrierStub() :\n-    _slow_path(),\n-    _continuation(),\n-    _guard() {}\n-\n-  Label& slow_path() { return _slow_path; }\n-  Label& continuation() { return _continuation; }\n-  Label& guard() { return _guard; }\n-\n-};\n-\n-class C2EntryBarrierStubTable {\n-  C2EntryBarrierStub* _stub;\n-\n-public:\n-  C2EntryBarrierStubTable() : _stub(NULL) {}\n-  C2EntryBarrierStub* add_entry_barrier();\n-  int estimate_stub_size() const;\n-  void emit(CodeBuffer& cb);\n-};\n-\n@@ -153,2 +85,1 @@\n-  C2SafepointPollStubTable _safepoint_poll_table;\/\/ Table for safepoint polls\n-  C2EntryBarrierStubTable _entry_barrier_table;  \/\/ Table for entry barrier stubs\n+  C2CodeStubList          _stub_list;            \/\/ List of code stubs\n@@ -202,5 +133,2 @@\n-  \/\/ Safepoint poll table\n-  C2SafepointPollStubTable* safepoint_poll_table() { return &_safepoint_poll_table; }\n-\n-  \/\/ Entry barrier table\n-  C2EntryBarrierStubTable* entry_barrier_table() { return &_entry_barrier_table; }\n+  \/\/ Code stubs list\n+  void add_stub(C2CodeStub* stub) { _stub_list.add_stub(stub); }\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":4,"deletions":76,"binary":false,"changes":80,"status":"modified"}]}