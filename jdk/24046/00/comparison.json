{"files":[{"patch":"@@ -50,0 +50,1 @@\n+Array<ClassPathZipEntry*>* AOTClassLocationConfig::_dumptime_jar_files = nullptr;\n@@ -482,0 +483,7 @@\n+  _dumptime_jar_files = MetadataFactory::new_array<ClassPathZipEntry*>(ClassLoaderData::the_null_class_loader_data(),\n+                                                                       tmp_array.length(), CHECK);\n+  for (int i = 1; i < tmp_array.length(); i++) {\n+    ClassPathZipEntry* jar_file = ClassLoader::create_class_path_zip_entry(tmp_array.at(i)->path());\n+    _dumptime_jar_files->at_put(i, jar_file); \/\/ may be null if the path is not a valid JAR file\n+  }\n+\n@@ -696,0 +704,21 @@\n+\/\/ It's possible to use reflection+setAccessible to call into ClassLoader::defineClass() to\n+\/\/ pretend that a dynamically generated class comes from a JAR file in the classpath.\n+\/\/ Detect such classes and exclude them from the archive.\n+void AOTClassLocationConfig::check_invalid_classpath_index(int classpath_index, InstanceKlass* ik) {\n+  if (1 <= classpath_index && classpath_index < length()) {\n+    ClassPathZipEntry *zip = _dumptime_jar_files->at(classpath_index);\n+    if (zip != nullptr) {\n+      JavaThread* current = JavaThread::current();\n+      ResourceMark rm(current);\n+      const char* const class_name = ik->name()->as_C_string();\n+      const char* const file_name = ClassLoader::file_name_for_class_name(class_name,\n+                                                                          ik->name()->utf8_length());\n+      if (!zip->has_entry(current, file_name)) {\n+        log_warning(cds)(\"class %s cannot be archived because it was not define from %s as claimed\",\n+                         class_name, zip->name());\n+        ik->set_shared_classpath_index(-1);\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/aotClassLocation.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class ClassPathZipEntry;\n@@ -142,0 +143,2 @@\n+  static Array<ClassPathZipEntry*>* _dumptime_jar_files;\n+\n@@ -266,0 +269,2 @@\n+\n+  void check_invalid_classpath_index(int classpath_index, InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/cds\/aotClassLocation.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -308,0 +308,14 @@\n+bool ClassPathZipEntry::has_entry(JavaThread* current, const char* name) {\n+  ThreadToNativeFromVM ttn(current);\n+  \/\/ check whether zip archive contains name\n+  jint name_len;\n+  jint filesize;\n+  jzentry* entry = ZipLibrary::find_entry(_zip, name, &filesize, &name_len);\n+  if (entry == nullptr) {\n+    return false;\n+  } else {\n+     ZipLibrary::free_entry(_zip, entry);\n+    return true;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+  bool has_entry(JavaThread* current, const char* name);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,0 +103,4 @@\n+\n+  if (CDSConfig::is_dumping_preimage_static_archive() || CDSConfig::is_dumping_dynamic_archive()) {\n+    AOTClassLocationConfig::dumptime()->check_invalid_classpath_index(classpath_index, result);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+typedef void(*ZIP_FreeEntry_t)(jzfile *zip, jzentry *entry);\n@@ -46,0 +47,1 @@\n+static ZIP_FreeEntry_t ZIP_FreeEntry = nullptr;\n@@ -82,0 +84,1 @@\n+  ZIP_FreeEntry = CAST_TO_FN_PTR(ZIP_FreeEntry_t, dll_lookup(\"ZIP_FreeEntry\", path, vm_exit_on_failure));\n@@ -179,0 +182,6 @@\n+void ZipLibrary::free_entry(jzfile* zip, jzentry* entry) {\n+  initialize();\n+  assert(ZIP_FreeEntry != nullptr, \"invariant\");\n+  ZIP_FreeEntry(zip, entry);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/zipLibrary.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+  static void free_entry(jzfile* zip, jzentry* entry);\n","filename":"src\/hotspot\/share\/utilities\/zipLibrary.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1119,1 +1119,1 @@\n-void\n+JNIEXPORT void\n","filename":"src\/java.base\/share\/native\/libzip\/zip_util.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,1 +279,1 @@\n-void\n+JNIEXPORT void\n","filename":"src\/java.base\/share\/native\/libzip\/zip_util.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test Do not cache classes that are loaded from a fake location.\n+ * @bug 8352001\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build FakeCodeLocation\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar FakeCodeLocationApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller ClassNotInJar1 ClassNotInJar2\n+ * @run driver FakeCodeLocation\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InaccessibleObjectException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.ProtectionDomain;\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.StringArrayUtils;\n+\n+public class FakeCodeLocation {\n+    static final String appJar = \"app.jar\";\n+    static final String mainClass = FakeCodeLocationApp.class.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        (new Tester(false)).run(new String[] {\"STATIC\"});\n+        (new Tester(true )).run(new String[] {\"STATIC\"});\n+        (new Tester(false)).run(new String[] {\"AOT\"});\n+        (new Tester(true )).run(new String[] {\"AOT\"});\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        boolean addOpen;;\n+        public Tester(boolean addOpen) {\n+            super(mainClass);\n+            this.addOpen = addOpen;\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            String[] args = new String[] {\n+                \"-Xlog:cds\",\n+                \"-Xlog:cds+class=debug\",\n+                \"-Xlog:class+load\",\n+            };\n+            if (addOpen) {\n+                args = StringArrayUtils.concat(args, \"--add-opens\", \"java.base\/java.lang=ALL-UNNAMED\", \"-XX:-AOTClassLinking\");\n+            }\n+            return args;\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+                addOpen ? \"hasAddedOpen\" : \"hasNotAddedOpen\",\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (isDumping(runMode)) {\n+                out.shouldMatch(\"cds,class.* FakeCodeLocationApp\");\n+                out.shouldNotMatch(\"cds,class.* ClassNotInJar1\");\n+                out.shouldNotMatch(\"cds,class.* ClassNotInJar2\");\n+            }\n+\n+            if (runMode.isProductionRun()) {\n+                out.shouldMatch(\"class,load.* FakeCodeLocationApp .*source: shared objects file\");\n+                out.shouldNotMatch(\"class,load.* ClassNotInJar1 .*source: shared objects file\");\n+                out.shouldNotMatch(\"class,load.* ClassNotInJar2 .*source: shared objects file\");\n+            }\n+        }\n+    }\n+}\n+\n+class FakeCodeLocationApp {\n+    static boolean hasAddedOpen;\n+\n+    public static void main(String args[]) throws Exception {\n+        hasAddedOpen = args[0].equals(\"hasAddedOpen\");\n+        testWithLookup();\n+        testWithSetAccessible();\n+    }\n+\n+    \/\/ Define a class using Lookup.defineClass(). The ClassFileParser should see \"__JVM_DefineClass__\"\n+    \/\/ as the source location, so this class will be excluded, as the location is not supported.\n+    static void testWithLookup() throws Exception {\n+        byte[] data = Files.readAllBytes(Paths.get(\"ClassNotInJar1.class\"));\n+        Class c = MethodHandles.lookup().defineClass(data);\n+        System.out.println(c.getProtectionDomain());\n+        System.out.println(c.getProtectionDomain().getCodeSource());\n+    }\n+\n+    \/\/ Use setAccessible to call into ClassLoader.defineClass(). In this case, the ClassFileParser\n+    \/\/ sees \"app.jar\" as the source location, but the app.jar doesn't contain this class file, so we\n+    \/\/ should exclude this class.\n+    static void testWithSetAccessible() throws Exception {\n+        Method m = ClassLoader.class.getDeclaredMethod(\"defineClass\", String.class, byte[].class, int.class, int.class, ProtectionDomain.class);\n+        System.out.println(m);\n+        try {\n+            m.setAccessible(true);\n+            if (!hasAddedOpen) {\n+                throw new RuntimeException(\"setAccessible() should have failed because '--add-opens java.base\/java.lang=ALL-UNNAMED' was not specified\");\n+            }\n+        } catch (InaccessibleObjectException t) {\n+            if (hasAddedOpen) {\n+                throw new RuntimeException(\"setAccessible() failed even though '--add-opens java.base\/java.lang=ALL-UNNAMED' was specified\");\n+            } else {\n+                System.out.println(\"\\n\\nExpected: \" + t);\n+                t.printStackTrace(System.out);\n+                return;\n+            }\n+        }\n+\n+        ProtectionDomain pd = FakeCodeLocationApp.class.getProtectionDomain();\n+        ClassLoader appLoader = FakeCodeLocationApp.class.getClassLoader();\n+        byte[] data = Files.readAllBytes(Paths.get(\"ClassNotInJar2.class\"));\n+        Class c = null;\n+        try {\n+            c = (Class)m.invoke(appLoader, \"ClassNotInJar2\", data, 0, data.length, pd);\n+        } catch (Throwable t) {\n+            System.out.println(t);\n+            t.printStackTrace(System.out);\n+            return;\n+        }\n+\n+        System.out.println(c);\n+        System.out.println(c.getProtectionDomain());\n+        System.out.println(c.getProtectionDomain().getCodeSource());\n+    }\n+}\n+\n+class ClassNotInJar1 {}\n+\n+class ClassNotInJar2 {}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/FakeCodeLocation.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"}]}