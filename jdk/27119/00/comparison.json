{"files":[{"patch":"@@ -2588,5 +2588,0 @@\n-void LIR_Assembler::emit_delay(LIR_OpDelay*) {\n-  Unimplemented();\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3284,1 +3284,1 @@\n-    single_instruction_with_delay_slot;\n+    single_instruction;\n@@ -3289,1 +3289,1 @@\n-    single_instruction_with_delay_slot;\n+    single_instruction;\n@@ -3295,1 +3295,1 @@\n-    single_instruction_with_delay_slot;\n+    single_instruction;\n@@ -3326,1 +3326,1 @@\n-    single_instruction; has_delay_slot;\n+    single_instruction;\n@@ -3333,1 +3333,1 @@\n-    single_instruction; has_delay_slot;\n+    single_instruction;\n@@ -3376,8 +3376,0 @@\n-\/\/ Perform a compare, then move conditionally in a branch delay slot.\n-pipe_class min_max( iRegI src2, iRegI srcdst ) %{\n-    src2   : E(read);\n-    srcdst : E(read);\n-    IALU   : R;\n-    BR     : R;\n-%}\n-\n@@ -9056,1 +9048,1 @@\n-      \"        STR.ge $zero,[$base+$temp]\\t! delay slot\"\n+      \"        STR.ge $zero,[$base+$temp]\\n\"\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2555,5 +2555,0 @@\n-void LIR_Assembler::emit_delay(LIR_OpDelay*) {\n-  Unimplemented();\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2750,5 +2750,0 @@\n-void LIR_Assembler::emit_delay(LIR_OpDelay* op) {\n-  Unimplemented();\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1593,2 +1593,0 @@\n-void LIR_Assembler::emit_delay(LIR_OpDelay*) { Unimplemented(); }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2819,4 +2819,0 @@\n-void LIR_Assembler::emit_delay(LIR_OpDelay* op) {\n-  ShouldNotCallThis(); \/\/ There are no delay slots on ZARCH_64.\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3004,5 +3004,0 @@\n-void LIR_Assembler::emit_delay(LIR_OpDelay*) {\n-  Unimplemented();\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1392,7 +1392,2 @@\n-          skipws();\n-          if (_curchar == ';') {\n-            next_char(); skipws();\n-          }\n-\n-          pipeline->_branchHasDelaySlot = true;\n-          continue;\n+          parse_err(SYNERR, \"Using obsolete token, branch_has_delay_slot\");\n+          break;\n@@ -1765,10 +1760,2 @@\n-      skipws();\n-      if (_curchar != ';') {\n-        parse_err(SYNERR, \"missing \\\";\\\" in latency definition\\n\");\n-        return;\n-      }\n-\n-      pipe_class->setInstructionCount(1);\n-      pipe_class->setBranchDelay(true);\n-      next_char(); skipws();\n-      continue;\n+      parse_err(SYNERR, \"Using obsolete token, %s\", ident);\n+      return;\n@@ -1834,9 +1821,2 @@\n-      skipws();\n-      if (_curchar != ';') {\n-        parse_err(SYNERR, \"missing \\\";\\\" after \\\"has_delay_slot\\\"\\n\");\n-        return;\n-      }\n-\n-      pipe_class->setBranchDelay(true);\n-      next_char(); skipws();\n-      continue;\n+      parse_err(SYNERR, \"Using obsolete token, %s\", ident);\n+      return;\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":6,"deletions":26,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -515,1 +515,0 @@\n-  ,  _branchHasDelaySlot    (false)\n@@ -549,2 +548,0 @@\n-  if (_branchHasDelaySlot)\n-    fprintf(fp,\", branch has delay slot\");\n@@ -640,1 +637,0 @@\n-  , _has_branch_delay_slot(false)\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -390,1 +390,0 @@\n-  bool       _branchHasDelaySlot; \/\/ Indicates that branches have delay slot instructions\n@@ -502,1 +501,0 @@\n-  bool              _has_branch_delay_slot; \/\/ Has branch delay slot as last instruction\n@@ -521,1 +519,0 @@\n-  void setBranchDelay(bool s)        { _has_branch_delay_slot = s; }\n@@ -527,1 +524,0 @@\n-  bool hasBranchDelay()     const { return _has_branch_delay_slot; }\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -797,2 +797,2 @@\n-  fprintf(fp_cpp, \"static const Pipeline pipeline_class_Zero_Instructions(0, 0, true, 0, 0, false, false, false, false, nullptr, nullptr, nullptr, Pipeline_Use(0, 0, 0, nullptr));\\n\\n\");\n-  fprintf(fp_cpp, \"static const Pipeline pipeline_class_Unknown_Instructions(0, 0, true, 0, 0, false, true, true, false, nullptr, nullptr, nullptr, Pipeline_Use(0, 0, 0, nullptr));\\n\\n\");\n+  fprintf(fp_cpp, \"static const Pipeline pipeline_class_Zero_Instructions(0, 0, true, 0, 0, false, false, false, nullptr, nullptr, nullptr, Pipeline_Use(0, 0, 0, nullptr));\\n\\n\");\n+  fprintf(fp_cpp, \"static const Pipeline pipeline_class_Unknown_Instructions(0, 0, true, 0, 0, true, true, false, nullptr, nullptr, nullptr, Pipeline_Use(0, 0, 0, nullptr));\\n\\n\");\n@@ -898,1 +898,1 @@\n-    fprintf(fp_cpp, \", %d, %s, %d, %d, %s, %s, %s, %s,\\n\",\n+    fprintf(fp_cpp, \", %d, %s, %d, %d, %s, %s, %s,\\n\",\n@@ -903,1 +903,0 @@\n-      pipeclass->hasBranchDelay() ? \"true\" : \"false\",\n@@ -982,10 +981,0 @@\n-  fprintf(fp_cpp, \"  static const char * bundle_flags[] = {\\n\");\n-  fprintf(fp_cpp, \"    \\\"\\\",\\n\");\n-  fprintf(fp_cpp, \"    \\\"use nop delay\\\",\\n\");\n-  fprintf(fp_cpp, \"    \\\"use unconditional delay\\\",\\n\");\n-  fprintf(fp_cpp, \"    \\\"use conditional delay\\\",\\n\");\n-  fprintf(fp_cpp, \"    \\\"used in conditional delay\\\",\\n\");\n-  fprintf(fp_cpp, \"    \\\"used in unconditional delay\\\",\\n\");\n-  fprintf(fp_cpp, \"    \\\"used in all conditional delays\\\",\\n\");\n-  fprintf(fp_cpp, \"  };\\n\\n\");\n-\n@@ -1006,4 +995,0 @@\n-  fprintf(fp_cpp, \"  if (_flags) {\\n\");\n-  fprintf(fp_cpp, \"    st->print(\\\"%%s\\\", bundle_flags[_flags]);\\n\");\n-  fprintf(fp_cpp, \"    needs_comma = true;\\n\");\n-  fprintf(fp_cpp, \"  };\\n\");\n@@ -1011,1 +996,1 @@\n-  fprintf(fp_cpp, \"    st->print(\\\"%%s%%d instr%%s\\\", needs_comma ? \\\", \\\" : \\\"\\\", instr_count(), instr_count() != 1 ? \\\"s\\\" : \\\"\\\");\\n\");\n+  fprintf(fp_cpp, \"    st->print(\\\"%%d instr%%s\\\", instr_count(), instr_count() != 1 ? \\\"s\\\" : \\\"\\\");\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -938,2 +938,0 @@\n-  fprintf(fp_hpp, \"    _branch_has_delay_slot = %d,\\n\",\n-    _pipeline->_branchHasDelaySlot ? 1 : 0);\n@@ -986,1 +984,0 @@\n-  fprintf(fp_hpp, \"  const bool                            _has_branch_delay;\\n\");\n@@ -1001,1 +998,0 @@\n-  fprintf(fp_hpp, \"           bool                            has_branch_delay,\\n\");\n@@ -1014,1 +1010,0 @@\n-  fprintf(fp_hpp, \"  , _has_branch_delay(has_branch_delay)\\n\");\n@@ -1049,2 +1044,0 @@\n-  fprintf(fp_hpp, \"  bool hasBranchDelay() const {\\n\");\n-  fprintf(fp_hpp, \"    return (_has_branch_delay); }\\n\\n\");\n@@ -1074,14 +1067,1 @@\n-  fprintf(fp_hpp, \"  enum {\\n\");\n-  fprintf(fp_hpp, \"    _unused_delay                   = 0x%x,\\n\", 0);\n-  fprintf(fp_hpp, \"    _use_nop_delay                  = 0x%x,\\n\", 1);\n-  fprintf(fp_hpp, \"    _use_unconditional_delay        = 0x%x,\\n\", 2);\n-  fprintf(fp_hpp, \"    _use_conditional_delay          = 0x%x,\\n\", 3);\n-  fprintf(fp_hpp, \"    _used_in_conditional_delay      = 0x%x,\\n\", 4);\n-  fprintf(fp_hpp, \"    _used_in_unconditional_delay    = 0x%x,\\n\", 5);\n-  fprintf(fp_hpp, \"    _used_in_all_conditional_delays = 0x%x,\\n\", 6);\n-  fprintf(fp_hpp, \"\\n\");\n-  fprintf(fp_hpp, \"    _use_delay                      = 0x%x,\\n\", 3);\n-  fprintf(fp_hpp, \"    _used_in_delay                  = 0x%x\\n\",  4);\n-  fprintf(fp_hpp, \"  };\\n\\n\");\n-  fprintf(fp_hpp, \"  uint _flags          : 3,\\n\");\n-  fprintf(fp_hpp, \"       _starts_bundle  : 1,\\n\");\n+  fprintf(fp_hpp, \"  uint _starts_bundle  : 1,\\n\");\n@@ -1091,1 +1071,1 @@\n-  fprintf(fp_hpp, \"  Bundle() : _flags(_unused_delay), _starts_bundle(0), _instr_count(0), _resources_used(0) {}\\n\\n\");\n+  fprintf(fp_hpp, \"  Bundle() : _starts_bundle(0), _instr_count(0), _resources_used(0) {}\\n\\n\");\n@@ -1094,1 +1074,0 @@\n-  fprintf(fp_hpp, \"  void clear_usage() { _flags = _unused_delay; }\\n\");\n@@ -1097,1 +1076,0 @@\n-  fprintf(fp_hpp, \"  uint flags() const { return (_flags); }\\n\");\n@@ -1102,16 +1080,0 @@\n-  fprintf(fp_hpp, \"  void set_use_nop_delay() { _flags = _use_nop_delay; }\\n\");\n-  fprintf(fp_hpp, \"  void set_use_unconditional_delay() { _flags = _use_unconditional_delay; }\\n\");\n-  fprintf(fp_hpp, \"  void set_use_conditional_delay() { _flags = _use_conditional_delay; }\\n\");\n-  fprintf(fp_hpp, \"  void set_used_in_unconditional_delay() { _flags = _used_in_unconditional_delay; }\\n\");\n-  fprintf(fp_hpp, \"  void set_used_in_conditional_delay() { _flags = _used_in_conditional_delay; }\\n\");\n-  fprintf(fp_hpp, \"  void set_used_in_all_conditional_delays() { _flags = _used_in_all_conditional_delays; }\\n\");\n-\n-  fprintf(fp_hpp, \"  bool use_nop_delay() { return (_flags == _use_nop_delay); }\\n\");\n-  fprintf(fp_hpp, \"  bool use_unconditional_delay() { return (_flags == _use_unconditional_delay); }\\n\");\n-  fprintf(fp_hpp, \"  bool use_conditional_delay() { return (_flags == _use_conditional_delay); }\\n\");\n-  fprintf(fp_hpp, \"  bool used_in_unconditional_delay() { return (_flags == _used_in_unconditional_delay); }\\n\");\n-  fprintf(fp_hpp, \"  bool used_in_conditional_delay() { return (_flags == _used_in_conditional_delay); }\\n\");\n-  fprintf(fp_hpp, \"  bool used_in_all_conditional_delays() { return (_flags == _used_in_all_conditional_delays); }\\n\");\n-  fprintf(fp_hpp, \"  bool use_delay() { return ((_flags & _use_delay) != 0); }\\n\");\n-  fprintf(fp_hpp, \"  bool used_in_delay() { return ((_flags & _used_in_delay) != 0); }\\n\\n\");\n-\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":2,"deletions":40,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -803,9 +803,0 @@\n-\/\/ LIR_OpDelay\n-    case lir_delay_slot: {\n-      assert(op->as_OpDelay() != nullptr, \"must be\");\n-      LIR_OpDelay* opDelay = (LIR_OpDelay*)op;\n-\n-      visit(opDelay->delay_op());\n-      break;\n-    }\n-\n@@ -1076,4 +1067,0 @@\n-void LIR_OpDelay::emit_code(LIR_Assembler* masm) {\n-  masm->emit_delay(this);\n-}\n-\n@@ -1764,2 +1751,0 @@\n-     \/\/ LIR_OpDelay\n-     case lir_delay_slot:            s = \"delay\";         break;\n@@ -2047,5 +2032,0 @@\n-void LIR_OpDelay::print_instr(outputStream* out) const {\n-  _op->print_on(out);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -882,1 +882,0 @@\n-class    LIR_OpDelay;\n@@ -988,3 +987,0 @@\n-  , begin_delay_slot\n-    , lir_delay_slot\n-  , end_delay_slot\n@@ -1127,1 +1123,0 @@\n-  virtual LIR_OpDelay* as_OpDelay() { return nullptr; }\n@@ -1889,19 +1884,0 @@\n-class LIR_OpDelay: public LIR_Op {\n- friend class LIR_OpVisitState;\n-\n- private:\n-  LIR_Op* _op;\n-\n- public:\n-  LIR_OpDelay(LIR_Op* op, CodeEmitInfo* info):\n-    LIR_Op(lir_delay_slot, LIR_OprFact::illegalOpr, info),\n-    _op(op) {\n-    assert(op->code() == lir_nop, \"should be filling with nops\");\n-  }\n-  virtual void emit_code(LIR_Assembler* masm);\n-  virtual LIR_OpDelay* as_OpDelay() { return this; }\n-  void print_instr(outputStream* out) const PRODUCT_RETURN;\n-  LIR_Op* delay_op() const { return _op; }\n-  CodeEmitInfo* call_info() const { return info(); }\n-};\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -197,2 +197,1 @@\n-             handler->entry_code()->instructions_list()->last()->code() == lir_branch ||\n-             handler->entry_code()->instructions_list()->last()->code() == lir_delay_slot, \"last operation must be branch\");\n+             handler->entry_code()->instructions_list()->last()->code() == lir_branch, \"last operation must be branch\");\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,2 +157,1 @@\n-  \/\/ any last minute peephole optimizations are performed here.  In\n-  \/\/ particular sparc uses this for delay slot filling.\n+  \/\/ any last minute peephole optimizations are performed here.\n@@ -207,1 +206,0 @@\n-  void emit_delay(LIR_OpDelay* op);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -189,2 +189,1 @@\n-\/\/   the call (e.g., offset zero), it is adjusted to point after the call and\n-\/\/   any associated machine-specific delay slot.\n+\/\/   the call (e.g., offset zero), it is adjusted to point after the call.\n@@ -1112,1 +1111,0 @@\n-  \/\/ (This has the effect of bringing in the call's delay slot on SPARC.)\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,6 +109,0 @@\n-  \/\/ Use this for an unconditional branch delay slot\n-  Node *_unconditional_delay_slot;\n-\n-  \/\/ Pointer to a Nop\n-  MachNopNode *_nop;\n-\n@@ -131,3 +125,0 @@\n-  \/\/ Destructor\n-  NOT_PRODUCT( ~Scheduling(); )\n-\n@@ -197,2 +188,0 @@\n-  uint _branches, _unconditional_delays;\n-\n@@ -200,1 +189,0 @@\n-  static uint _total_branches, _total_unconditional_delays;\n@@ -1475,1 +1463,0 @@\n-  Node* delay_slot = nullptr;\n@@ -1514,9 +1501,0 @@\n-      \/\/ See if delay slots are supported\n-      if (valid_bundle_info(n) && node_bundling(n)->used_in_unconditional_delay()) {\n-        assert(delay_slot == nullptr, \"no use of delay slot node\");\n-        assert(n->size(C->regalloc()) == Pipeline::instr_unit_size(), \"delay slot instruction wrong size\");\n-\n-        delay_slot = n;\n-        continue;\n-      }\n-\n@@ -1541,3 +1519,0 @@\n-        \/\/ A padding may be needed again since a previous instruction\n-        \/\/ could be moved to delay slot.\n-\n@@ -1616,1 +1591,1 @@\n-          \/\/ Try to replace long branch if delay slot is not used,\n+          \/\/ Try to replace long branch,\n@@ -1619,4 +1594,1 @@\n-          bool delay_slot_is_used = valid_bundle_info(n) &&\n-                                    C->output()->node_bundling(n)->use_unconditional_delay();\n-          if (!delay_slot_is_used && mach->may_be_short_branch()) {\n-            assert(delay_slot == nullptr, \"not expecting delay slot node\");\n+          if (mach->may_be_short_branch()) {\n@@ -1756,38 +1728,0 @@\n-      \/\/ See if this instruction has a delay slot\n-      if (valid_bundle_info(n) && node_bundling(n)->use_unconditional_delay()) {\n-        guarantee(delay_slot != nullptr, \"expecting delay slot node\");\n-\n-        \/\/ Back up 1 instruction\n-        masm->code()->set_insts_end(masm->code()->insts_end() - Pipeline::instr_unit_size());\n-\n-        \/\/ Save the offset for the listing\n-#if defined(SUPPORT_OPTO_ASSEMBLY)\n-        if ((node_offsets != nullptr) && (delay_slot->_idx < node_offset_limit)) {\n-          node_offsets[delay_slot->_idx] = masm->offset();\n-        }\n-#endif\n-\n-        \/\/ Support a SafePoint in the delay slot\n-        if (delay_slot->is_MachSafePoint()) {\n-          MachNode *mach = delay_slot->as_Mach();\n-          \/\/ !!!!! Stubs only need an oopmap right now, so bail out\n-          if (!mach->is_MachCall() && mach->as_MachSafePoint()->jvms()->method() == nullptr) {\n-            \/\/ Write the oopmap directly to the code blob??!!\n-            delay_slot = nullptr;\n-            continue;\n-          }\n-\n-          int adjusted_offset = current_offset - Pipeline::instr_unit_size();\n-          non_safepoints.observe_safepoint(mach->as_MachSafePoint()->jvms(),\n-                                           adjusted_offset);\n-          \/\/ Generate an OopMap entry\n-          Process_OopMap_Node(mach, adjusted_offset);\n-        }\n-\n-        \/\/ Insert the delay slot instruction\n-        delay_slot->emit(masm, C->regalloc());\n-\n-        \/\/ Don't reuse it\n-        delay_slot = nullptr;\n-      }\n-\n@@ -2034,2 +1968,0 @@\n-uint Scheduling::_total_branches = 0;\n-uint Scheduling::_total_unconditional_delays = 0;\n@@ -2053,4 +1985,0 @@\n-#ifndef PRODUCT\n-        , _branches(0)\n-        , _unconditional_delays(0)\n-#endif\n@@ -2058,3 +1986,0 @@\n-  \/\/ Create a MachNopNode\n-  _nop = new MachNopNode();\n-\n@@ -2090,8 +2015,0 @@\n-#ifndef PRODUCT\n-\/\/ Scheduling destructor\n-Scheduling::~Scheduling() {\n-  _total_branches             += _branches;\n-  _total_unconditional_delays += _unconditional_delays;\n-}\n-#endif\n-\n@@ -2202,9 +2119,0 @@\n-  \/\/ If this is the unconditional delay instruction, then it fits\n-  if (n == _unconditional_delay_slot) {\n-#ifndef PRODUCT\n-    if (_cfg->C->trace_opto_output())\n-      tty->print(\"#     NodeFitsInBundle [%4d]: TRUE; is in unconditional delay slot\\n\", n->_idx);\n-#endif\n-    return (true);\n-  }\n-\n@@ -2226,2 +2134,0 @@\n-  else if (node_pipeline->hasBranchDelay() && !_unconditional_delay_slot)\n-    instruction_count++;\n@@ -2439,93 +2345,0 @@\n-  \/\/ Check for instructions to be placed in the delay slot. We\n-  \/\/ do this before we actually schedule the current instruction,\n-  \/\/ because the delay slot follows the current instruction.\n-  if (Pipeline::_branch_has_delay_slot &&\n-      node_pipeline->hasBranchDelay() &&\n-      !_unconditional_delay_slot) {\n-\n-    uint siz = _available.size();\n-\n-    \/\/ Conditional branches can support an instruction that\n-    \/\/ is unconditionally executed and not dependent by the\n-    \/\/ branch, OR a conditionally executed instruction if\n-    \/\/ the branch is taken.  In practice, this means that\n-    \/\/ the first instruction at the branch target is\n-    \/\/ copied to the delay slot, and the branch goes to\n-    \/\/ the instruction after that at the branch target\n-    if ( n->is_MachBranch() ) {\n-\n-      assert( !n->is_MachNullCheck(), \"should not look for delay slot for Null Check\" );\n-      assert( !n->is_Catch(),         \"should not look for delay slot for Catch\" );\n-\n-#ifndef PRODUCT\n-      _branches++;\n-#endif\n-\n-      \/\/ At least 1 instruction is on the available list\n-      \/\/ that is not dependent on the branch\n-      for (uint i = 0; i < siz; i++) {\n-        Node *d = _available[i];\n-        const Pipeline *avail_pipeline = d->pipeline();\n-\n-        \/\/ Don't allow safepoints in the branch shadow, that will\n-        \/\/ cause a number of difficulties\n-        if ( avail_pipeline->instructionCount() == 1 &&\n-             !avail_pipeline->hasMultipleBundles() &&\n-             !avail_pipeline->hasBranchDelay() &&\n-             Pipeline::instr_has_unit_size() &&\n-             d->size(_regalloc) == Pipeline::instr_unit_size() &&\n-             NodeFitsInBundle(d) &&\n-             !node_bundling(d)->used_in_delay()) {\n-\n-          if (d->is_Mach() && !d->is_MachSafePoint()) {\n-            \/\/ A node that fits in the delay slot was found, so we need to\n-            \/\/ set the appropriate bits in the bundle pipeline information so\n-            \/\/ that it correctly indicates resource usage.  Later, when we\n-            \/\/ attempt to add this instruction to the bundle, we will skip\n-            \/\/ setting the resource usage.\n-            _unconditional_delay_slot = d;\n-            node_bundling(n)->set_use_unconditional_delay();\n-            node_bundling(d)->set_used_in_unconditional_delay();\n-            _bundle_use.add_usage(avail_pipeline->resourceUse());\n-            _current_latency[d->_idx] = _bundle_cycle_number;\n-            _next_node = d;\n-            ++_bundle_instr_count;\n-#ifndef PRODUCT\n-            _unconditional_delays++;\n-#endif\n-            break;\n-          }\n-        }\n-      }\n-    }\n-\n-    \/\/ No delay slot, add a nop to the usage\n-    if (!_unconditional_delay_slot) {\n-      \/\/ See if adding an instruction in the delay slot will overflow\n-      \/\/ the bundle.\n-      if (!NodeFitsInBundle(_nop)) {\n-#ifndef PRODUCT\n-        if (_cfg->C->trace_opto_output())\n-          tty->print(\"#  *** STEP(1 instruction for delay slot) ***\\n\");\n-#endif\n-        step(1);\n-      }\n-\n-      _bundle_use.add_usage(_nop->pipeline()->resourceUse());\n-      _next_node = _nop;\n-      ++_bundle_instr_count;\n-    }\n-\n-    \/\/ See if the instruction in the delay slot requires a\n-    \/\/ step of the bundles\n-    if (!NodeFitsInBundle(n)) {\n-#ifndef PRODUCT\n-      if (_cfg->C->trace_opto_output())\n-        tty->print(\"#  *** STEP(branch won't fit) ***\\n\");\n-#endif\n-      \/\/ Update the state information\n-      _bundle_instr_count = 0;\n-      _bundle_cycle_number += 1;\n-      _bundle_use.step(1);\n-    }\n-  }\n@@ -2559,5 +2372,2 @@\n-  \/\/ If this was placed in the delay slot, ignore it\n-  if (n != _unconditional_delay_slot) {\n-\n-    if (delay == 0) {\n-      if (node_pipeline->hasMultipleBundles()) {\n+  if (delay == 0) {\n+    if (node_pipeline->hasMultipleBundles()) {\n@@ -2565,2 +2375,2 @@\n-        if (_cfg->C->trace_opto_output())\n-          tty->print(\"#  *** STEP(multiple instructions) ***\\n\");\n+      if (_cfg->C->trace_opto_output())\n+        tty->print(\"#  *** STEP(multiple instructions) ***\\n\");\n@@ -2568,2 +2378,2 @@\n-        step(1);\n-      }\n+      step(1);\n+    }\n@@ -2571,1 +2381,1 @@\n-      else if (instruction_count + _bundle_instr_count > Pipeline::_max_instrs_per_cycle) {\n+    else if (instruction_count + _bundle_instr_count > Pipeline::_max_instrs_per_cycle) {\n@@ -2573,4 +2383,4 @@\n-        if (_cfg->C->trace_opto_output())\n-          tty->print(\"#  *** STEP(%d >= %d instructions) ***\\n\",\n-                     instruction_count + _bundle_instr_count,\n-                     Pipeline::_max_instrs_per_cycle);\n+      if (_cfg->C->trace_opto_output())\n+        tty->print(\"#  *** STEP(%d >= %d instructions) ***\\n\",\n+                   instruction_count + _bundle_instr_count,\n+                   Pipeline::_max_instrs_per_cycle);\n@@ -2578,2 +2388,1 @@\n-        step(1);\n-      }\n+      step(1);\n@@ -2581,0 +2390,1 @@\n+  }\n@@ -2582,5 +2392,2 @@\n-    if (node_pipeline->hasBranchDelay() && !_unconditional_delay_slot)\n-      _bundle_instr_count++;\n-\n-    \/\/ Set the node's latency\n-    _current_latency[n->_idx] = _bundle_cycle_number;\n+  \/\/ Set the node's latency\n+  _current_latency[n->_idx] = _bundle_cycle_number;\n@@ -2588,3 +2395,3 @@\n-    \/\/ Now merge the functional unit information\n-    if (instruction_count > 0 || !node_pipeline->mayHaveNoCode())\n-      _bundle_use.add_usage(node_usage);\n+  \/\/ Now merge the functional unit information\n+  if (instruction_count > 0 || !node_pipeline->mayHaveNoCode())\n+    _bundle_use.add_usage(node_usage);\n@@ -2592,2 +2399,2 @@\n-    \/\/ Increment the number of instructions in this bundle\n-    _bundle_instr_count += instruction_count;\n+  \/\/ Increment the number of instructions in this bundle\n+  _bundle_instr_count += instruction_count;\n@@ -2595,4 +2402,3 @@\n-    \/\/ Remember this node for later\n-    if (n->is_Mach())\n-      _next_node = n;\n-  }\n+  \/\/ Remember this node for later\n+  if (n->is_Mach())\n+    _next_node = n;\n@@ -2650,3 +2456,0 @@\n-  \/\/ No delay slot specified\n-  _unconditional_delay_slot = nullptr;\n-\n@@ -2770,5 +2573,1 @@\n-    \/\/ might schedule.  _bb_end points just after last schedulable inst.  We\n-    \/\/ normally schedule conditional branches (despite them being forced last\n-    \/\/ in the block), because they have delay slots we can fill.  Calls all\n-    \/\/ have their delay slots filled in the template expansions, so we don't\n-    \/\/ bother scheduling them.\n+    \/\/ might schedule.  _bb_end points just after last schedulable inst.\n@@ -2840,1 +2639,1 @@\n-          if (bundle->instr_count() > 0 || bundle->flags() > 0) {\n+          if (bundle->instr_count() > 0) {\n@@ -3276,10 +3075,0 @@\n-  \/\/ Print the number of branch shadows filled\n-  if (Pipeline::_branch_has_delay_slot) {\n-    tty->print(\"Of %d branches, %d had unconditional delay slots filled\",\n-               _total_branches, _total_unconditional_delays);\n-    if (_total_branches > 0)\n-      tty->print(\", for %.2f%%\",\n-                 ((double)_total_unconditional_delays) \/ ((double)_total_branches) * 100.0);\n-    tty->print(\"\\n\");\n-  }\n-\n@@ -3575,1 +3364,0 @@\n-    Node *delay = nullptr;\n@@ -3584,4 +3372,0 @@\n-        if (bundle->used_in_unconditional_delay()) {\n-          delay = n;\n-          continue;\n-        }\n@@ -3620,23 +3404,0 @@\n-      \/\/ If we have an instruction with a delay slot, and have seen a delay,\n-      \/\/ then back up and print it\n-      if (valid_bundle_info(n) && node_bundling(n)->use_unconditional_delay()) {\n-        \/\/ Coverity finding - Explicit null dereferenced.\n-        guarantee(delay != nullptr, \"no unconditional delay instruction\");\n-        if (WizardMode) delay->dump();\n-\n-        if (node_bundling(delay)->starts_bundle())\n-          starts_bundle = '+';\n-        if ((pcs != nullptr) && (n->_idx < pc_limit)) {\n-          pc = pcs[n->_idx];\n-          st->print(\"%*.*x\", pc_digits, pc_digits, pc);\n-        } else {\n-          st->fill_to(pc_digits);\n-        }\n-        st->print(\" %c \", starts_bundle);\n-        starts_bundle = ' ';\n-        st->fill_to(prefix_len);\n-        delay->format(C->regalloc(), st);\n-        st->cr();\n-        delay = nullptr;\n-      }\n-\n@@ -3651,1 +3412,0 @@\n-    assert(cut_short || delay == nullptr, \"no unconditional delay branch\");\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":27,"deletions":267,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -3516,2 +3516,0 @@\n-        \/\/ scope_desc_near() must be used, instead of scope_desc_at() because on\n-        \/\/ SPARC, the pcDesc can be on the delay slot after the call instruction.\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}