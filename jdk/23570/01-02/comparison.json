{"files":[{"patch":"@@ -889,1 +889,1 @@\n-\/\/ Class for vector register v18\n+\/\/ Class for vector register V18\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -252,3 +252,3 @@\n-      \/\/ Currently, as we support only vector sizes of 8B and 16B, we disable this operation for\n-      \/\/ T_LONG and T_DOUBLE on Neon as \"mul\" does not support 2D arrangement. However, these\n-      \/\/ types are supported on machines with UseSVE == 2.\n+      \/\/ This operation is disabled for doubles and longs on machines with SVE < 2 and instead\n+      \/\/ the default VectorRearrange + VectorBlend is generated as the performance of the default\n+      \/\/ implementation was slightly better\/similar than the implementaion for SelectFromTwoVector.\n@@ -7168,2 +7168,7 @@\n-instruct vselect_from_two_vectors_SIFNeon(vReg dst, vReg_V17 src1, vReg_V18 src2,\n-                                          vReg index, vReg tmp1, vReg tmp2) %{\n+\/\/ Both the match rules for SelectFromTwoVector reserve V17 and V18 vector registers for src1 and src2.\n+\/\/ The Neon and SVE2 tbl instruction for two vector lookup requires both the source vectors to be\n+\/\/ consective. As registers V0-V7 are reserved for arguments, V8-V15 are non-volatile (used for preserving\n+\/\/ values across function calls and usually used for long-lived values), we can use any two volatile\n+\/\/ registers between V16-V31.\n+instruct vselect_from_two_vectors_HS_Neon(vReg dst, vReg_V17 src1, vReg_V18 src2,\n+                                          vReg index, vReg tmp1) %{\n@@ -7174,2 +7179,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n-  format %{ \"vselect_from_two_vectors_SIF $dst, $src1, $src2, $index\\t# vector (4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1, $tmp2\" %}\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors_HS_Neon $dst, $src1, $src2, $index\\t# vector (4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n@@ -7179,1 +7184,1 @@\n-    __ select_from_two_vectors_SIFNeon($dst$$FloatRegister, $src1$$FloatRegister,\n+    __ select_from_two_vectors_HS_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n@@ -7181,2 +7186,1 @@\n-                                       $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n-                                       bt, length_in_bytes);\n+                                       $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n@@ -7187,1 +7191,1 @@\n-instruct vselect_from_two_vectors(vReg dst, vReg_V17 src1, vReg_V18 src2, vReg index) %{\n+instruct vselect_from_two_vectors(vReg dst, vReg_V17 src1, vReg_V18 src2, vReg index, vReg tmp1) %{\n@@ -7191,1 +7195,2 @@\n-  format %{ \"vselect_from_two_vectors $dst, $src1, $src2, $index\" %}\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n@@ -7196,1 +7201,1 @@\n-                               $index$$FloatRegister, bt, length_in_bytes);\n+                               $index$$FloatRegister, $tmp1$$FloatRegister, bt, length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -242,3 +242,3 @@\n-      \/\/ Currently, as we support only vector sizes of 8B and 16B, we disable this operation for\n-      \/\/ T_LONG and T_DOUBLE on Neon as \"mul\" does not support 2D arrangement. However, these\n-      \/\/ types are supported on machines with UseSVE == 2.\n+      \/\/ This operation is disabled for doubles and longs on machines with SVE < 2 and instead\n+      \/\/ the default VectorRearrange + VectorBlend is generated as the performance of the default\n+      \/\/ implementation was slightly better\/similar than the implementaion for SelectFromTwoVector.\n@@ -5150,2 +5150,7 @@\n-instruct vselect_from_two_vectors_SIFNeon(vReg dst, vReg_V17 src1, vReg_V18 src2,\n-                                          vReg index, vReg tmp1, vReg tmp2) %{\n+\/\/ Both the match rules for SelectFromTwoVector reserve V17 and V18 vector registers for src1 and src2.\n+\/\/ The Neon and SVE2 tbl instruction for two vector lookup requires both the source vectors to be\n+\/\/ consective. As registers V0-V7 are reserved for arguments, V8-V15 are non-volatile (used for preserving\n+\/\/ values across function calls and usually used for long-lived values), we can use any two volatile\n+\/\/ registers between V16-V31.\n+instruct vselect_from_two_vectors_HS_Neon(vReg dst, vReg_V17 src1, vReg_V18 src2,\n+                                          vReg index, vReg tmp1) %{\n@@ -5156,2 +5161,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n-  format %{ \"vselect_from_two_vectors_SIF $dst, $src1, $src2, $index\\t# vector (4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1, $tmp2\" %}\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors_HS_Neon $dst, $src1, $src2, $index\\t# vector (4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n@@ -5161,1 +5166,1 @@\n-    __ select_from_two_vectors_SIFNeon($dst$$FloatRegister, $src1$$FloatRegister,\n+    __ select_from_two_vectors_HS_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n@@ -5163,2 +5168,1 @@\n-                                       $tmp1$$FloatRegister, $tmp2$$FloatRegister,\n-                                       bt, length_in_bytes);\n+                                       $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n@@ -5169,1 +5173,1 @@\n-instruct vselect_from_two_vectors(vReg dst, vReg_V17 src1, vReg_V18 src2, vReg index) %{\n+instruct vselect_from_two_vectors(vReg dst, vReg_V17 src1, vReg_V18 src2, vReg index, vReg tmp1) %{\n@@ -5173,1 +5177,2 @@\n-  format %{ \"vselect_from_two_vectors $dst, $src1, $src2, $index\" %}\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n@@ -5178,1 +5183,1 @@\n-                               $index$$FloatRegister, bt, length_in_bytes);\n+                               $index$$FloatRegister, $tmp1$$FloatRegister, bt, length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -4298,2 +4298,2 @@\n-  void sve2_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn1,\n-                FloatRegister Zn2, FloatRegister Zm) {\n+  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn1,\n+               FloatRegister Zn2, FloatRegister Zm) {\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2857,1 +2857,1 @@\n-void C2_MacroAssembler::select_from_two_vectors_SIFNeon(FloatRegister dst, FloatRegister src1,\n+void C2_MacroAssembler::select_from_two_vectors_HS_Neon(FloatRegister dst, FloatRegister src1,\n@@ -2859,3 +2859,3 @@\n-                                                        FloatRegister tmp1, FloatRegister tmp2,\n-                                                        BasicType bt, unsigned vector_length_in_bytes) {\n-  assert_different_registers(src1, src2, tmp1, tmp2);\n+                                                        FloatRegister tmp1, BasicType bt, bool isQ) {\n+\n+  assert_different_registers(dst, src1, src2, tmp1);\n@@ -2863,1 +2863,3 @@\n-  assert(vector_length_in_bytes == 8 || vector_length_in_bytes == 16, \"unsupported vector length\");\n+\n+  SIMD_Arrangement size1 = isQ ? T16B : T8B;\n+  SIMD_Arrangement size2 = esize2arrangement((uint)type2aelembytes(bt), isQ);\n@@ -2869,1 +2871,1 @@\n-  \/\/ the indices can range from [0, 7].\n+  \/\/ the indices can range from [0, 8).\n@@ -2872,4 +2874,4 @@\n-  \/\/ Move a constant 0x0100 in every 2B of tmp2 - tmp2 = [0x0100, 0x0100, 0x0100, 0x0100]\n-  \/\/ Multiply index vector with tmp1 to yield - dst = [0x0404, 0x0b0b, 0x0202, 0x0000]\n-  \/\/ Add the multiplied result to the vector in tmp2 to obtain the byte level\n-  \/\/ offsets - dst = [0x0504, 0x0c0b, 0x0302, 0x0100]\n+  \/\/ Multiply index vector with tmp1 to yield - dst = [0x0404, 0x0a0a, 0x0202, 0x0000]\n+  \/\/ Move a constant 0x0100 in every 2B of tmp1 - tmp1 = [0x0100, 0x0100, 0x0100, 0x0100]\n+  \/\/ Add the multiplied result to the vector in tmp1 to obtain the byte level\n+  \/\/ offsets - dst = [0x0504, 0x0b0a, 0x0302, 0x0100]\n@@ -2878,6 +2880,0 @@\n-  SIMD_Arrangement size1 = vector_length_in_bytes == 16 ? T16B : T8B;\n-  SIMD_Arrangement size2 = vector_length_in_bytes == 16 ? T8H  : T4H;\n-  if (bt == T_INT || bt == T_FLOAT) {\n-    size2 = vector_length_in_bytes == 16 ? T4S : T2S;\n-  }\n-\n@@ -2887,1 +2883,4 @@\n-      mov(tmp2, size2, 0x0100);\n+      mulv(dst, size2, index, tmp1);\n+      mov(tmp1, size2, 0x0100);\n+      addv(dst, size1, dst, tmp1); \/\/ \"dst\" now contains the processed index elements\n+                                   \/\/ to select a set of 2B\n@@ -2894,1 +2893,4 @@\n-      mov(tmp2, size2, 0x03020100);\n+      mulv(dst, size2, index, tmp1);\n+      mov(tmp1, size2, 0x03020100);\n+      addv(dst, size1, dst, tmp1); \/\/ \"dst\" now contains the processed index elements\n+                                   \/\/ to select a set of 4B\n@@ -2899,3 +2901,0 @@\n-  mulv(dst, size2, index, tmp1);\n-  addv(dst, size1, dst, tmp2); \/\/ \"dst\" now contains the processed index elements\n-                               \/\/ to select a set of bytes (2B\/4B) depending on the datatype\n@@ -2903,7 +2902,1 @@\n-  if (vector_length_in_bytes == 8) {\n-    \/\/ We need to fit both the source vectors (src1, src2) in a 128-bit register as the\n-    \/\/ Neon \"tbl\" instruction supports only looking up 16B vectors and use the Neon \"tbl\"\n-    \/\/ instruction with one vector lookup\n-    ins(src1, D, src2, 1, 0);\n-    tbl(dst, size1, src1, 1, dst);\n-  } else {\n+  if (isQ) {\n@@ -2911,1 +2904,0 @@\n-    assert(vector_length_in_bytes == 16, \"must be\");\n@@ -2913,0 +2905,7 @@\n+  } else {  \/\/ vector length == 8\n+    \/\/ We need to fit both the source vectors (src1, src2) in a 128-bit register as the\n+    \/\/ Neon \"tbl\" instruction supports only looking up 16B vectors. We then use the Neon \"tbl\"\n+    \/\/ instruction with one vector lookup\n+    ins(tmp1, D, src1, 0, 0);\n+    ins(tmp1, D, src2, 1, 0);\n+    tbl(dst, size1, tmp1, 1, dst);\n@@ -2918,1 +2917,2 @@\n-                                                BasicType bt, unsigned vector_length_in_bytes) {\n+                                                FloatRegister tmp1, BasicType bt,\n+                                                unsigned vector_length_in_bytes) {\n@@ -2920,2 +2920,3 @@\n-    ins(src1, D, src2, 1, 0);\n-    tbl(dst, T8B, src1, 1, index);\n+    ins(tmp1, D, src1, 0, 0);\n+    ins(tmp1, D, src2, 1, 0);\n+    tbl(dst, T8B, tmp1, 1, index);\n@@ -2927,1 +2928,1 @@\n-    sve2_tbl(dst, size, src1, src2, index);\n+    sve_tbl(dst, size, src1, src2, index);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":34,"deletions":33,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -197,3 +197,3 @@\n-  void select_from_two_vectors_SIFNeon(FloatRegister dst, FloatRegister src1, FloatRegister src2,\n-                                       FloatRegister index, FloatRegister tmp1, FloatRegister tmp2,\n-                                       BasicType bt, unsigned length_in_bytes);\n+  void select_from_two_vectors_HS_Neon(FloatRegister dst, FloatRegister src1, FloatRegister src2,\n+                                       FloatRegister index, FloatRegister tmp1, BasicType bt,\n+                                       bool isQ);\n@@ -202,1 +202,2 @@\n-                               FloatRegister index, BasicType bt, unsigned length_in_bytes);\n+                               FloatRegister index, FloatRegister tmp1, BasicType bt,\n+                               unsigned length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2090,1 +2090,4 @@\n-                        [\"tbl\",      \"__ sve2_tbl(z16, __ S, z17, z18, z16);\",             \"tbl\\tz16.s, {z17.s, z18.s}, z16.s\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ B, z17, z18, z16);\",              \"tbl\\tz16.b, {z17.b, z18.b}, z16.b\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ H, z17, z18, z16);\",              \"tbl\\tz16.h, {z17.h, z18.h}, z16.h\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ S, z17, z18, z16);\",              \"tbl\\tz16.s, {z17.s, z18.s}, z16.s\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ D, z17, z18, z16);\",              \"tbl\\tz16.d, {z17.d, z18.d}, z16.d\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1102,1 +1102,4 @@\n-    __ sve2_tbl(z16, __ S, z17, z18, z16);             \/\/       tbl     z16.s, {z17.s, z18.s}, z16.s\n+    __ sve_tbl(z16, __ B, z17, z18, z16);              \/\/       tbl     z16.b, {z17.b, z18.b}, z16.b\n+    __ sve_tbl(z16, __ H, z17, z18, z16);              \/\/       tbl     z16.h, {z17.h, z18.h}, z16.h\n+    __ sve_tbl(z16, __ S, z17, z18, z16);              \/\/       tbl     z16.s, {z17.s, z18.s}, z16.s\n+    __ sve_tbl(z16, __ D, z17, z18, z16);              \/\/       tbl     z16.d, {z17.d, z18.d}, z16.d\n@@ -1441,7 +1444,7 @@\n-    0x14000000,     0x17ffffd7,     0x140004b0,     0x94000000,\n-    0x97ffffd4,     0x940004ad,     0x3400000a,     0x34fffa2a,\n-    0x3400954a,     0x35000008,     0x35fff9c8,     0x350094e8,\n-    0xb400000b,     0xb4fff96b,     0xb400948b,     0xb500001d,\n-    0xb5fff91d,     0xb500943d,     0x10000013,     0x10fff8b3,\n-    0x100093d3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36309356,     0x3758000c,     0x375ff7cc,     0x375892ec,\n+    0x14000000,     0x17ffffd7,     0x140004b3,     0x94000000,\n+    0x97ffffd4,     0x940004b0,     0x3400000a,     0x34fffa2a,\n+    0x340095aa,     0x35000008,     0x35fff9c8,     0x35009548,\n+    0xb400000b,     0xb4fff96b,     0xb40094eb,     0xb500001d,\n+    0xb5fff91d,     0xb500949d,     0x10000013,     0x10fff8b3,\n+    0x10009433,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363093b6,     0x3758000c,     0x375ff7cc,     0x3758934c,\n@@ -1452,13 +1455,13 @@\n-    0x540090c0,     0x54000001,     0x54fff541,     0x54009061,\n-    0x54000002,     0x54fff4e2,     0x54009002,     0x54000002,\n-    0x54fff482,     0x54008fa2,     0x54000003,     0x54fff423,\n-    0x54008f43,     0x54000003,     0x54fff3c3,     0x54008ee3,\n-    0x54000004,     0x54fff364,     0x54008e84,     0x54000005,\n-    0x54fff305,     0x54008e25,     0x54000006,     0x54fff2a6,\n-    0x54008dc6,     0x54000007,     0x54fff247,     0x54008d67,\n-    0x54000008,     0x54fff1e8,     0x54008d08,     0x54000009,\n-    0x54fff189,     0x54008ca9,     0x5400000a,     0x54fff12a,\n-    0x54008c4a,     0x5400000b,     0x54fff0cb,     0x54008beb,\n-    0x5400000c,     0x54fff06c,     0x54008b8c,     0x5400000d,\n-    0x54fff00d,     0x54008b2d,     0x5400000e,     0x54ffefae,\n-    0x54008ace,     0x5400000f,     0x54ffef4f,     0x54008a6f,\n+    0x54009120,     0x54000001,     0x54fff541,     0x540090c1,\n+    0x54000002,     0x54fff4e2,     0x54009062,     0x54000002,\n+    0x54fff482,     0x54009002,     0x54000003,     0x54fff423,\n+    0x54008fa3,     0x54000003,     0x54fff3c3,     0x54008f43,\n+    0x54000004,     0x54fff364,     0x54008ee4,     0x54000005,\n+    0x54fff305,     0x54008e85,     0x54000006,     0x54fff2a6,\n+    0x54008e26,     0x54000007,     0x54fff247,     0x54008dc7,\n+    0x54000008,     0x54fff1e8,     0x54008d68,     0x54000009,\n+    0x54fff189,     0x54008d09,     0x5400000a,     0x54fff12a,\n+    0x54008caa,     0x5400000b,     0x54fff0cb,     0x54008c4b,\n+    0x5400000c,     0x54fff06c,     0x54008bec,     0x5400000d,\n+    0x54fff00d,     0x54008b8d,     0x5400000e,     0x54ffefae,\n+    0x54008b2e,     0x5400000f,     0x54ffef4f,     0x54008acf,\n@@ -1671,71 +1674,72 @@\n-    0x05b23230,     0x05b02a30,     0x853040af,     0xc5b040af,\n-    0xe57080af,     0xe5b080af,     0x25034440,     0x254054c4,\n-    0x25034640,     0x25415a05,     0x25834440,     0x25c54489,\n-    0x250b5d3a,     0x2550dc20,     0x2518e3e1,     0x2518e021,\n-    0x2518e0a1,     0x2518e121,     0x2518e1a1,     0x2558e3e2,\n-    0x2558e042,     0x2558e0c2,     0x2558e142,     0x2598e3e3,\n-    0x2598e063,     0x2598e0e3,     0x2598e163,     0x25d8e3e4,\n-    0x25d8e084,     0x25d8e104,     0x25d8e184,     0x2518e407,\n-    0x05214800,     0x05614800,     0x05a14800,     0x05e14800,\n-    0x05214c00,     0x05614c00,     0x05a14c00,     0x05e14c00,\n-    0x05304001,     0x05314001,     0x05a18610,     0x05e18610,\n-    0x05271e11,     0x6545e891,     0x6585e891,     0x65c5e891,\n-    0x6545c891,     0x6585c891,     0x65c5c891,     0x45b0c210,\n-    0x45f1c231,     0x1e601000,     0x1e603000,     0x1e621000,\n-    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,\n-    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,\n-    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,\n-    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,\n-    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,\n-    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,\n-    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,\n-    0x1e7e3000,     0xf8268267,     0xf82d023c,     0xf8301046,\n-    0xf83d2083,     0xf8263290,     0xf82d528c,     0xf8284299,\n-    0xf8337160,     0xf8386286,     0xf8bf820e,     0xf8a600e0,\n-    0xf8af1353,     0xf8a922ea,     0xf8b53396,     0xf8a251e3,\n-    0xf8b340f4,     0xf8a470fd,     0xf8a06209,     0xf8f48097,\n-    0xf8f002ea,     0xf8eb10d9,     0xf8ff21b0,     0xf8f7302c,\n-    0xf8ee52a9,     0xf8f041fa,     0xf8e471e4,     0xf8e863c6,\n-    0xf864823d,     0xf87d013a,     0xf86f1162,     0xf87d20e3,\n-    0xf86132bb,     0xf870510e,     0xf8704336,     0xf86572b4,\n-    0xf8706217,     0xb83e8294,     0xb8200264,     0xb8381284,\n-    0xb8242358,     0xb8333102,     0xb828530e,     0xb83042df,\n-    0xb824703f,     0xb82a6194,     0xb8a080e9,     0xb8b80090,\n-    0xb8bb1146,     0xb8bb21b8,     0xb8b032df,     0xb8b653f4,\n-    0xb8bd41c9,     0xb8b47287,     0xb8bc6169,     0xb8ee828c,\n-    0xb8e10138,     0xb8f3126d,     0xb8f020b0,     0xb8e03183,\n-    0xb8e851ef,     0xb8f041e4,     0xb8fe7005,     0xb8ea6376,\n-    0xb8638120,     0xb873015d,     0xb8781284,     0xb86723b8,\n-    0xb86e3175,     0xb87b51ed,     0xb87f41d1,     0xb863721e,\n-    0xb87660f4,     0xce216874,     0xce104533,     0xce648c15,\n-    0xce8e3302,     0xce6e82ab,     0xce6c87d1,     0xcec08063,\n-    0xce638937,     0x25e0c358,     0x25a1c7d3,     0x0580785a,\n-    0x05426328,     0x05009892,     0x25a0cc29,     0x2561cec8,\n-    0x058044b3,     0x05401c99,     0x05006b49,     0x25e0d6f7,\n-    0x2561c528,     0x0583c8bc,     0x0542522f,     0x05001ec0,\n-    0x25e0de65,     0x25a1c113,     0x05803cad,     0x0540f3c0,\n-    0x0500ab15,     0x2560c28c,     0x2561d7c0,     0x05801ed7,\n-    0x0542633b,     0x05003696,     0x2560d4b4,     0x25e1c918,\n-    0x058021ff,     0x05400e15,     0x0500f3de,     0x0473025a,\n-    0x04bd05ab,     0x658e0025,     0x658a08e2,     0x659a0493,\n-    0x043e1062,     0x04f418b4,     0x046d15bd,     0x04611fce,\n-    0x04d6a07c,     0x04001929,     0x041a09da,     0x04d098f4,\n-    0x04db10d4,     0x0459a3ad,     0x041aa029,     0x041919fb,\n-    0x04d39e24,     0x04118302,     0x04101dba,     0x04d7ae16,\n-    0x04dea571,     0x04180210,     0x05e786fc,     0x05e4915c,\n-    0x04881cf1,     0x044a0f04,     0x04090969,     0x048b16c4,\n-    0x044101e4,     0x04dcbf44,     0x65809745,     0x658d833f,\n-    0x65c68468,     0x65c79b07,     0x65829e38,     0x049dafca,\n-    0x6582bba8,     0x65c0b7ff,     0x65c1b4e0,     0x658dbadd,\n-    0x65819a9d,     0x65ed9246,     0x65b30815,     0x65e6263c,\n-    0x65eebb94,     0x65bad14e,     0x65efe178,     0x65fc5697,\n-    0x65e07f14,     0x040c55a6,     0x04977f4d,     0x043d3046,\n-    0x04b733a0,     0x046830a4,     0x04ed322d,     0x05686948,\n-    0x05bd6c13,     0x65c88ef0,     0x450db3d7,     0x4540b6d9,\n-    0x043e3979,     0x445896ce,     0x445a9005,     0x44d98069,\n-    0x445b87ae,     0x04da348e,     0x04982edb,     0x0499397f,\n-    0x0408338c,     0x04ca309c,     0x65c721e6,     0x65c63641,\n-    0x65982882,     0x04812b8b,     0x0e251083,     0x4e3712d5,\n-    0x0e61101f,     0x4e6d118b,     0x0eba1338,     0x4eb712d5,\n-    0x2e31120f,     0x6e2e11ac,     0x2e6810e6,     0x6e6f11cd,\n-    0x2eaa1128,     0x6eb1120f,\n+    0x05b23230,     0x05302a30,     0x05702a30,     0x05b02a30,\n+    0x05f02a30,     0x853040af,     0xc5b040af,     0xe57080af,\n+    0xe5b080af,     0x25034440,     0x254054c4,     0x25034640,\n+    0x25415a05,     0x25834440,     0x25c54489,     0x250b5d3a,\n+    0x2550dc20,     0x2518e3e1,     0x2518e021,     0x2518e0a1,\n+    0x2518e121,     0x2518e1a1,     0x2558e3e2,     0x2558e042,\n+    0x2558e0c2,     0x2558e142,     0x2598e3e3,     0x2598e063,\n+    0x2598e0e3,     0x2598e163,     0x25d8e3e4,     0x25d8e084,\n+    0x25d8e104,     0x25d8e184,     0x2518e407,     0x05214800,\n+    0x05614800,     0x05a14800,     0x05e14800,     0x05214c00,\n+    0x05614c00,     0x05a14c00,     0x05e14c00,     0x05304001,\n+    0x05314001,     0x05a18610,     0x05e18610,     0x05271e11,\n+    0x6545e891,     0x6585e891,     0x65c5e891,     0x6545c891,\n+    0x6585c891,     0x65c5c891,     0x45b0c210,     0x45f1c231,\n+    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,\n+    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,\n+    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,\n+    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,\n+    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,\n+    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,\n+    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,\n+    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,\n+    0xf8268267,     0xf82d023c,     0xf8301046,     0xf83d2083,\n+    0xf8263290,     0xf82d528c,     0xf8284299,     0xf8337160,\n+    0xf8386286,     0xf8bf820e,     0xf8a600e0,     0xf8af1353,\n+    0xf8a922ea,     0xf8b53396,     0xf8a251e3,     0xf8b340f4,\n+    0xf8a470fd,     0xf8a06209,     0xf8f48097,     0xf8f002ea,\n+    0xf8eb10d9,     0xf8ff21b0,     0xf8f7302c,     0xf8ee52a9,\n+    0xf8f041fa,     0xf8e471e4,     0xf8e863c6,     0xf864823d,\n+    0xf87d013a,     0xf86f1162,     0xf87d20e3,     0xf86132bb,\n+    0xf870510e,     0xf8704336,     0xf86572b4,     0xf8706217,\n+    0xb83e8294,     0xb8200264,     0xb8381284,     0xb8242358,\n+    0xb8333102,     0xb828530e,     0xb83042df,     0xb824703f,\n+    0xb82a6194,     0xb8a080e9,     0xb8b80090,     0xb8bb1146,\n+    0xb8bb21b8,     0xb8b032df,     0xb8b653f4,     0xb8bd41c9,\n+    0xb8b47287,     0xb8bc6169,     0xb8ee828c,     0xb8e10138,\n+    0xb8f3126d,     0xb8f020b0,     0xb8e03183,     0xb8e851ef,\n+    0xb8f041e4,     0xb8fe7005,     0xb8ea6376,     0xb8638120,\n+    0xb873015d,     0xb8781284,     0xb86723b8,     0xb86e3175,\n+    0xb87b51ed,     0xb87f41d1,     0xb863721e,     0xb87660f4,\n+    0xce216874,     0xce104533,     0xce648c15,     0xce8e3302,\n+    0xce6e82ab,     0xce6c87d1,     0xcec08063,     0xce638937,\n+    0x25e0c358,     0x25a1c7d3,     0x0580785a,     0x05426328,\n+    0x05009892,     0x25a0cc29,     0x2561cec8,     0x058044b3,\n+    0x05401c99,     0x05006b49,     0x25e0d6f7,     0x2561c528,\n+    0x0583c8bc,     0x0542522f,     0x05001ec0,     0x25e0de65,\n+    0x25a1c113,     0x05803cad,     0x0540f3c0,     0x0500ab15,\n+    0x2560c28c,     0x2561d7c0,     0x05801ed7,     0x0542633b,\n+    0x05003696,     0x2560d4b4,     0x25e1c918,     0x058021ff,\n+    0x05400e15,     0x0500f3de,     0x0473025a,     0x04bd05ab,\n+    0x658e0025,     0x658a08e2,     0x659a0493,     0x043e1062,\n+    0x04f418b4,     0x046d15bd,     0x04611fce,     0x04d6a07c,\n+    0x04001929,     0x041a09da,     0x04d098f4,     0x04db10d4,\n+    0x0459a3ad,     0x041aa029,     0x041919fb,     0x04d39e24,\n+    0x04118302,     0x04101dba,     0x04d7ae16,     0x04dea571,\n+    0x04180210,     0x05e786fc,     0x05e4915c,     0x04881cf1,\n+    0x044a0f04,     0x04090969,     0x048b16c4,     0x044101e4,\n+    0x04dcbf44,     0x65809745,     0x658d833f,     0x65c68468,\n+    0x65c79b07,     0x65829e38,     0x049dafca,     0x6582bba8,\n+    0x65c0b7ff,     0x65c1b4e0,     0x658dbadd,     0x65819a9d,\n+    0x65ed9246,     0x65b30815,     0x65e6263c,     0x65eebb94,\n+    0x65bad14e,     0x65efe178,     0x65fc5697,     0x65e07f14,\n+    0x040c55a6,     0x04977f4d,     0x043d3046,     0x04b733a0,\n+    0x046830a4,     0x04ed322d,     0x05686948,     0x05bd6c13,\n+    0x65c88ef0,     0x450db3d7,     0x4540b6d9,     0x043e3979,\n+    0x445896ce,     0x445a9005,     0x44d98069,     0x445b87ae,\n+    0x04da348e,     0x04982edb,     0x0499397f,     0x0408338c,\n+    0x04ca309c,     0x65c721e6,     0x65c63641,     0x65982882,\n+    0x04812b8b,     0x0e251083,     0x4e3712d5,     0x0e61101f,\n+    0x4e6d118b,     0x0eba1338,     0x4eb712d5,     0x2e31120f,\n+    0x6e2e11ac,     0x2e6810e6,     0x6e6f11cd,     0x2eaa1128,\n+    0x6eb1120f,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":96,"deletions":92,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -2830,0 +2830,30 @@\n+    public static final String SELECT_FROM_TWO_VECTOR_VB = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VB\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VB, \"SelectFromTwoVector\", TYPE_BYTE);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VS = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VS\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VS, \"SelectFromTwoVector\", TYPE_SHORT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VI = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VI, \"SelectFromTwoVector\", TYPE_INT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VF = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VF\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VF, \"SelectFromTwoVector\", TYPE_FLOAT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VD = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VD\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VD, \"SelectFromTwoVector\", TYPE_DOUBLE);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VL = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VL\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VL, \"SelectFromTwoVector\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,453 @@\n+\/*\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+\n+import jdk.incubator.vector.*;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\/**\n+ * @test\n+ * @bug 8348868\n+ * @library \/test\/lib \/\n+ * @summary Verify that SelectFromTwoVector IR node is correctly being\n+ *          generated for Neon and SVE\n+ * @modules jdk.incubator.vector\n+ * @run driver compiler.vectorapi.TestSelectFromTwoVectorOp\n+ *\/\n+\n+public class TestSelectFromTwoVectorOp {\n+    private static final int SIZE = 1024;\n+    private static final Generators random = Generators.G;\n+\n+    private static byte[] ba;\n+    private static byte[] bb;\n+    private static byte[] bres;\n+    private static byte[][] bindex;\n+\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static short[] sres;\n+    private static short[][] sindex;\n+\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ires;\n+    private static int[][] iindex;\n+\n+    private static float[] fa;\n+    private static float[] fb;\n+    private static float[] fres;\n+    private static float[][] findex;\n+\n+    private static long[] la;\n+    private static long[] lb;\n+    private static long[] lres;\n+    private static long[][] lindex;\n+\n+    private static double[] da;\n+    private static double[] db;\n+    private static double[] dres;\n+    private static double[][] dindex;\n+\n+    \/\/ Stores the possible number of elements that can be\n+    \/\/ held in various vector sizes\/shapes\n+    private static int [] nums = {2, 4, 8, 16, 32, 64};\n+\n+   static {\n+        ba   = new byte[SIZE];\n+        bb   = new byte[SIZE];\n+        bres = new byte[SIZE];\n+        bindex = new byte[4][SIZE];\n+\n+        sa   = new short[SIZE];\n+        sb   = new short[SIZE];\n+        sres = new short[SIZE];\n+        sindex = new short[4][SIZE];\n+\n+        ia   = new int[SIZE];\n+        ib   = new int[SIZE];\n+        ires = new int[SIZE];\n+        iindex = new int[4][SIZE];\n+\n+        fa   = new float[SIZE];\n+        fb   = new float[SIZE];\n+        fres = new float[SIZE];\n+        findex = new float[4][SIZE];\n+\n+        la   = new long[SIZE];\n+        lb   = new long[SIZE];\n+        lres = new long[SIZE];\n+        lindex = new long[3][SIZE];\n+\n+        da   = new double[SIZE];\n+        db   = new double[SIZE];\n+        dres = new double[SIZE];\n+        dindex = new double[3][SIZE];\n+\n+        \/\/ Populate the indices\n+        for (int i = 0; i < bindex.length; i++) {\n+            bindex[i] = new byte[SIZE];\n+            sindex[i] = new short[SIZE];\n+            iindex[i] = new int[SIZE];\n+            findex[i] = new float[SIZE];\n+\n+            \/\/ The index array contains indices in the range of [0, vector_length * 2)\n+            Generator<Integer> byteGen1 = random.uniformInts(0, (nums[i + 2] * 2) - 1);\n+            Generator<Integer> shortGen1 = random.uniformInts(0, (nums[i + 1] * 2) - 1);\n+\n+            for (int j = 0; j < SIZE; j++) {\n+                bindex[i][j] = byteGen1.next().byteValue();\n+                sindex[i][j] = shortGen1.next().shortValue();\n+            }\n+\n+            if (i < dindex.length) {\n+              dindex[i] = new double[SIZE];\n+              lindex[i] = new long[SIZE];\n+\n+              random.fill(random.uniformDoubles(0, (double) ((nums[i] * 2) - 1)), dindex[i]);\n+              random.fill(random.uniformLongs(0, (long) ((nums[i] * 2) - 1)), lindex[i]);\n+            }\n+\n+            random.fill(random.uniformInts(0, (nums[i] * 2) - 1), iindex[i]);\n+            random.fill(random.uniformFloats(0, (float)((nums[i] * 2) - 1)), findex[i]);\n+        }\n+\n+        \/\/ Populate the sources\n+        Generator<Integer> byteGen = random.uniformInts(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+        Generator<Integer> shortGen = random.uniformInts(Short.MIN_VALUE, Short.MAX_VALUE);\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            ba[i] = byteGen.next().byteValue();\n+            bb[i] = byteGen.next().byteValue();\n+\n+            sa[i] = shortGen.next().shortValue();\n+            sb[i] = shortGen.next().shortValue();\n+        }\n+\n+        random.fill(random.ints(), ia);\n+        random.fill(random.ints(), ib);\n+        random.fill(random.floats(), fa);\n+        random.fill(random.floats(), fb);\n+        random.fill(random.longs(), la);\n+        random.fill(random.longs(), lb);\n+        random.fill(random.doubles(), da);\n+        random.fill(random.doubles(), db);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Bytes\n+    @ForceInline\n+    public static void ByteSelectFromTwoVectorKernel(VectorSpecies SPECIES, byte[] ba,\n+                                                     byte[] bb, byte[] bindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ba.length); i += SPECIES.length()) {\n+            ByteVector.fromArray(SPECIES, bindex, i)\n+                .selectFrom(ByteVector.fromArray(SPECIES, ba, i),\n+                            ByteVector.fromArray(SPECIES, bb, i))\n+                .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void selectFromTwoVector_Byte64() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_64, ba, bb, bindex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void selectFromTwoVector_Byte128() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_128, ba, bb, bindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_32},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_32, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Byte256() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_256, ba, bb, bindex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_64},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_64, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Byte512() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_512, ba, bb, bindex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Shorts\n+    @ForceInline\n+    public static void ShortSelectFromTwoVectorKernel(VectorSpecies SPECIES, short[] sa,\n+                                                      short[] sb, short[] sindex) {\n+        for (int i = 0; i < SPECIES.loopBound(sa.length); i += SPECIES.length()) {\n+            ShortVector.fromArray(SPECIES, sindex, i)\n+                .selectFrom(ShortVector.fromArray(SPECIES, sa, i),\n+                            ShortVector.fromArray(SPECIES, sb, i))\n+                .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void selectFromTwoVector_Short64() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_64, sa, sb, sindex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"})\n+    public static void selectFromTwoVector_Short128() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_128, sa, sb, sindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_16},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Short256() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_256, sa, sb, sindex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_32},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_32, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Short512() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_512, sa, sb, sindex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Ints\n+    @ForceInline\n+    public static void IntSelectFromTwoVectorKernel(VectorSpecies SPECIES, int[] ia,\n+                                                    int[] ib, int[] iindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            IntVector.fromArray(SPECIES, iindex, i)\n+                .selectFrom(IntVector.fromArray(SPECIES, ia, i),\n+                            IntVector.fromArray(SPECIES, ib, i))\n+                .intoArray(ires, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void selectFromTwoVector_Int64() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_64, ia, ib, iindex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"})\n+    public static void selectFromTwoVector_Int128() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_128, ia, ib, iindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Int256() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_256, ia, ib, iindex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_16},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Int512() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_512, ia, ib, iindex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Floats\n+    @ForceInline\n+    public static void FloatSelectFromTwoVectorKernel(VectorSpecies SPECIES, float[] fa,\n+                                                      float[] fb, float[] findex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            FloatVector.fromArray(SPECIES, findex, i)\n+                .selectFrom(FloatVector.fromArray(SPECIES, fa, i),\n+                            FloatVector.fromArray(SPECIES, fb, i))\n+                .intoArray(fres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void selectFromTwoVector_Float64() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_64, fa, fb, findex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"})\n+    public static void selectFromTwoVector_Float128() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_128, fa, fb, findex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Float256() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_256, fa, fb, findex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_16},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Float512() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_512, fa, fb, findex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Doubles\n+    @ForceInline\n+    public static void DoubleSelectFromTwoVectorKernel(VectorSpecies SPECIES, double[] da,\n+                                                       double[] db, double[] dindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            DoubleVector.fromArray(SPECIES, dindex, i)\n+                .selectFrom(DoubleVector.fromArray(SPECIES, da, i),\n+                            DoubleVector.fromArray(SPECIES, db, i))\n+                .intoArray(dres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_2},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"})\n+    public static void selectFromTwoVector_Double128() {\n+        DoubleSelectFromTwoVectorKernel(DoubleVector.SPECIES_128, da, db, dindex[0]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_4},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Double256() {\n+        DoubleSelectFromTwoVectorKernel(DoubleVector.SPECIES_256, da, db, dindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Double512() {\n+        DoubleSelectFromTwoVectorKernel(DoubleVector.SPECIES_512, da, db, dindex[2]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Longs\n+    @ForceInline\n+    public static void LongSelectFromTwoVectorKernel(VectorSpecies SPECIES, long[] la,\n+                                                     long[] lb, long[] lindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            LongVector.fromArray(SPECIES, lindex, i)\n+                .selectFrom(LongVector.fromArray(SPECIES, la, i),\n+                            LongVector.fromArray(SPECIES, lb, i))\n+                .intoArray(lres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_2},\n+    applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"})\n+    public static void selectFromTwoVector_Long128() {\n+        LongSelectFromTwoVectorKernel(LongVector.SPECIES_128, la, lb, lindex[0]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_4},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Long256() {\n+        LongSelectFromTwoVectorKernel(LongVector.SPECIES_256, la, lb, lindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Long512() {\n+        LongSelectFromTwoVectorKernel(LongVector.SPECIES_512, la, lb, lindex[2]);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestSelectFromTwoVectorOp.java","additions":453,"deletions":0,"binary":false,"changes":453,"status":"added"}]}