{"files":[{"patch":"@@ -884,0 +884,40 @@\n+\/\/ Class for vector register V10\n+reg_class v10_veca_reg(\n+    V10, V10_H, V10_J, V10_K\n+);\n+\n+\/\/ Class for vector register V11\n+reg_class v11_veca_reg(\n+    V11, V11_H, V11_J, V11_K\n+);\n+\n+\/\/ Class for vector register V12\n+reg_class v12_veca_reg(\n+    V12, V12_H, V12_J, V12_K\n+);\n+\n+\/\/ Class for vector register V13\n+reg_class v13_veca_reg(\n+    V13, V13_H, V13_J, V13_K\n+);\n+\n+\/\/ Class for vector register V17\n+reg_class v17_veca_reg(\n+    V17, V17_H, V17_J, V17_K\n+);\n+\n+\/\/ Class for vector register V18\n+reg_class v18_veca_reg(\n+    V18, V18_H, V18_J, V18_K\n+);\n+\n+\/\/ Class for vector register V23\n+reg_class v23_veca_reg(\n+    V23, V23_H, V23_J, V23_K\n+);\n+\n+\/\/ Class for vector register V24\n+reg_class v24_veca_reg(\n+    V24, V24_H, V24_J, V24_K\n+);\n+\n@@ -4972,0 +5012,80 @@\n+operand vReg_V10()\n+%{\n+  constraint(ALLOC_IN_RC(v10_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V11()\n+%{\n+  constraint(ALLOC_IN_RC(v11_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V12()\n+%{\n+  constraint(ALLOC_IN_RC(v12_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V13()\n+%{\n+  constraint(ALLOC_IN_RC(v13_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V17()\n+%{\n+  constraint(ALLOC_IN_RC(v17_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V18()\n+%{\n+  constraint(ALLOC_IN_RC(v18_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V23()\n+%{\n+  constraint(ALLOC_IN_RC(v23_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V24()\n+%{\n+  constraint(ALLOC_IN_RC(v24_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -260,0 +260,19 @@\n+      case Op_SelectFromTwoVector:\n+        \/\/ The \"tbl\" instruction for two vector table is supported only in Neon and SVE2. Return\n+        \/\/ false if vector length > 16B but supported SVE version < 2.\n+        \/\/ For vector length of 16B, generate SVE2 \"tbl\" instruction if SVE2 is supported, else\n+        \/\/ generate Neon \"tbl\" instruction to select from two vectors.\n+        \/\/ This operation is disabled for doubles and longs on machines with SVE < 2 and instead\n+        \/\/ the default VectorRearrange + VectorBlend is generated as the performance of the default\n+        \/\/ implementation was slightly better\/similar than the implementation for SelectFromTwoVector.\n+        if (UseSVE < 2 && (type2aelembytes(bt) == 8 || length_in_bytes > 16)) {\n+          return false;\n+        }\n+\n+        \/\/ Because the SVE2 \"tbl\" instruction is unpredicated and partial operations cannot be generated\n+        \/\/ using masks, we currently disable this operation on machines where length_in_bytes <\n+        \/\/ MaxVectorSize on that machine with the only exception of 8B vector length.\n+        if (UseSVE == 2 && length_in_bytes > 8 && length_in_bytes < MaxVectorSize) {\n+          return false;\n+        }\n+        break;\n@@ -7175,0 +7194,69 @@\n+\n+\/\/ ------------------------------------- SelectFromTwoVector ------------------------------------\n+\/\/ The Neon and SVE2 tbl instruction for two vector lookup requires both the source vectors to be\n+\/\/ consecutive. The match rules for SelectFromTwoVector reserve two consecutive vector registers\n+\/\/ for src1 and src2.\n+\/\/ Four combinations of vector registers for vselect_from_two_vectors are chosen at random\n+\/\/ (two from volatile and two from non-volatile set) which gives more freedom to the register\n+\/\/ allocator to choose the best pair of source registers at that point.\n+\n+\n+instruct vselect_from_two_vectors_10_11(vReg dst, vReg_V10 src1, vReg_V11 src2,\n+                                        vReg index, vReg tmp) %{\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_10_11 $dst, $src1, $src2, $index\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister,\n+                               $src2$$FloatRegister, $index$$FloatRegister,\n+                               $tmp$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_12_13(vReg dst, vReg_V12 src1, vReg_V13 src2,\n+                                        vReg index, vReg tmp) %{\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_12_13 $dst, $src1, $src2, $index\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister,\n+                               $src2$$FloatRegister, $index$$FloatRegister,\n+                               $tmp$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_17_18(vReg dst, vReg_V17 src1, vReg_V18 src2,\n+                                        vReg index, vReg tmp) %{\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_17_18 $dst, $src1, $src2, $index\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister,\n+                               $src2$$FloatRegister, $index$$FloatRegister,\n+                               $tmp$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_23_24(vReg dst, vReg_V23 src1, vReg_V24 src2,\n+                                        vReg index, vReg tmp) %{\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_23_24 $dst, $src1, $src2, $index\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister,\n+                               $src2$$FloatRegister, $index$$FloatRegister,\n+                               $tmp$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -250,0 +250,19 @@\n+      case Op_SelectFromTwoVector:\n+        \/\/ The \"tbl\" instruction for two vector table is supported only in Neon and SVE2. Return\n+        \/\/ false if vector length > 16B but supported SVE version < 2.\n+        \/\/ For vector length of 16B, generate SVE2 \"tbl\" instruction if SVE2 is supported, else\n+        \/\/ generate Neon \"tbl\" instruction to select from two vectors.\n+        \/\/ This operation is disabled for doubles and longs on machines with SVE < 2 and instead\n+        \/\/ the default VectorRearrange + VectorBlend is generated as the performance of the default\n+        \/\/ implementation was slightly better\/similar than the implementation for SelectFromTwoVector.\n+        if (UseSVE < 2 && (type2aelembytes(bt) == 8 || length_in_bytes > 16)) {\n+          return false;\n+        }\n+\n+        \/\/ Because the SVE2 \"tbl\" instruction is unpredicated and partial operations cannot be generated\n+        \/\/ using masks, we currently disable this operation on machines where length_in_bytes <\n+        \/\/ MaxVectorSize on that machine with the only exception of 8B vector length.\n+        if (UseSVE == 2 && length_in_bytes > 8 && length_in_bytes < MaxVectorSize) {\n+          return false;\n+        }\n+        break;\n@@ -5157,0 +5176,32 @@\n+\n+\/\/ ------------------------------------- SelectFromTwoVector ------------------------------------\n+\/\/ The Neon and SVE2 tbl instruction for two vector lookup requires both the source vectors to be\n+\/\/ consecutive. The match rules for SelectFromTwoVector reserve two consecutive vector registers\n+\/\/ for src1 and src2.\n+\/\/ Four combinations of vector registers for vselect_from_two_vectors are chosen at random\n+\/\/ (two from volatile and two from non-volatile set) which gives more freedom to the register\n+\/\/ allocator to choose the best pair of source registers at that point.\n+dnl\n+dnl SELECT_FROM_TWO_VECTORS($1,        $2        )\n+dnl SELECT_FROM_TWO_VECTORS(first_reg, second_reg)\n+define(`SELECT_FROM_TWO_VECTORS', `\n+instruct vselect_from_two_vectors_$1_$2(vReg dst, vReg_V$1 src1, vReg_V$2 src2,\n+                                        vReg index, vReg tmp) %{\n+  effect(TEMP_DEF dst, TEMP tmp);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_$1_$2 $dst, $src1, $src2, $index\\t# KILL $tmp\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister,\n+                               $src2$$FloatRegister, $index$$FloatRegister,\n+                               $tmp$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\n+SELECT_FROM_TWO_VECTORS(10, 11)\n+SELECT_FROM_TWO_VECTORS(12, 13)\n+SELECT_FROM_TWO_VECTORS(17, 18)\n+SELECT_FROM_TWO_VECTORS(23, 24)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -4234,2 +4234,2 @@\n-  \/\/ SVE programmable table lookup\/permute using vector of element indices\n-  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) {\n+private:\n+  void _sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, unsigned reg_count, FloatRegister Zm) {\n@@ -4238,0 +4238,6 @@\n+    \/\/ Only supports one or two vector lookup. One vector lookup was introduced in SVE1\n+    \/\/ and two vector lookup in SVE2\n+    assert(0 < reg_count && reg_count <= 2, \"invalid number of registers\");\n+\n+    int op11 = (reg_count == 1) ? 0b10 : 0b01;\n+\n@@ -4239,1 +4245,12 @@\n-    f(0b001100, 15, 10), rf(Zn, 5), rf(Zd, 0);\n+    f(0b001, 15, 13), f(op11, 12, 11), f(0b0, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+public:\n+  \/\/ SVE\/SVE2 Programmable table lookup in one or two vector table (zeroing)\n+  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) {\n+    _sve_tbl(Zd, T, Zn, 1, Zm);\n+  }\n+\n+  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn1, FloatRegister Zn2, FloatRegister Zm) {\n+    assert(Zn1->successor() == Zn2, \"invalid order of registers\");\n+    _sve_tbl(Zd, T, Zn1, 2, Zm);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2861,0 +2861,121 @@\n+\n+\/\/ Selects elements from two source vectors (src1, src2) based on index values in the index register\n+\/\/ using Neon instructions and places it in the destination vector element corresponding to the\n+\/\/ index vector element. Each index in the index register must be in the range - [0, 2 * NUM_ELEM),\n+\/\/ where NUM_ELEM is the number of BasicType elements per vector.\n+\/\/ If idx < NUM_ELEM --> selects src1[idx] (idx is an element of the index register)\n+\/\/ Otherwise, selects src2[idx – NUM_ELEM]\n+void C2_MacroAssembler::select_from_two_vectors_neon(FloatRegister dst, FloatRegister src1,\n+                                                     FloatRegister src2, FloatRegister index,\n+                                                     FloatRegister tmp, unsigned vector_length_in_bytes) {\n+  assert_different_registers(dst, src1, src2, tmp);\n+  SIMD_Arrangement size = vector_length_in_bytes == 16 ? T16B : T8B;\n+\n+  if (vector_length_in_bytes == 16) {\n+    assert(UseSVE <= 1, \"sve must be <= 1\");\n+    assert(src1->successor() == src2, \"Source registers must be ordered\");\n+    \/\/ If the vector length is 16B, then use the Neon \"tbl\" instruction with two vector table\n+    tbl(dst, size, src1, 2, index);\n+  } else { \/\/ vector length == 8\n+    assert(UseSVE == 0, \"must be Neon only\");\n+    \/\/ We need to fit both the source vectors (src1, src2) in a 128-bit register because the\n+    \/\/ Neon \"tbl\" instruction supports only looking up 16B vectors. We then use the Neon \"tbl\"\n+    \/\/ instruction with one vector lookup\n+    ins(tmp, D, src1, 0, 0);\n+    ins(tmp, D, src2, 1, 0);\n+    tbl(dst, size, tmp, 1, index);\n+  }\n+}\n+\n+\/\/ Selects elements from two source vectors (src1, src2) based on index values in the index register\n+\/\/ using SVE\/SVE2 instructions and places it in the destination vector element corresponding to the\n+\/\/ index vector element. Each index in the index register must be in the range - [0, 2 * NUM_ELEM),\n+\/\/ where NUM_ELEM is the number of BasicType elements per vector.\n+\/\/ If idx < NUM_ELEM --> selects src1[idx] (idx is an element of the index register)\n+\/\/ Otherwise, selects src2[idx – NUM_ELEM]\n+void C2_MacroAssembler::select_from_two_vectors_sve(FloatRegister dst, FloatRegister src1,\n+                                                    FloatRegister src2, FloatRegister index,\n+                                                    FloatRegister tmp, SIMD_RegVariant T,\n+                                                    unsigned vector_length_in_bytes) {\n+  assert_different_registers(dst, src1, src2, index, tmp);\n+\n+  if (vector_length_in_bytes == 8) {\n+    \/\/ We need to fit both the source vectors (src1, src2) in a single vector register because the\n+    \/\/ SVE \"tbl\" instruction is unpredicated and works on the entire vector which can lead to\n+    \/\/ incorrect results if each source vector is only partially filled. We then use the SVE \"tbl\"\n+    \/\/ instruction with one vector lookup\n+    assert(UseSVE >= 1, \"sve must be >= 1\");\n+    ins(tmp, D, src1, 0, 0);\n+    ins(tmp, D, src2, 1, 0);\n+    sve_tbl(dst, T, tmp, index);\n+  } else {  \/\/ UseSVE == 2 and vector_length_in_bytes > 8\n+    \/\/ If the vector length is > 8, then use the SVE2 \"tbl\" instruction with the two vector table.\n+    \/\/ The assertion - vector_length_in_bytes == MaxVectorSize ensures that this operation\n+    \/\/ is not executed on machines where vector_length_in_bytes < MaxVectorSize\n+    \/\/ with the only exception of 8B vector length.\n+    assert(UseSVE == 2 && vector_length_in_bytes == MaxVectorSize, \"must be\");\n+    assert(src1->successor() == src2, \"Source registers must be ordered\");\n+    sve_tbl(dst, T, src1, src2, index);\n+  }\n+}\n+\n+void C2_MacroAssembler::select_from_two_vectors(FloatRegister dst, FloatRegister src1,\n+                                                FloatRegister src2, FloatRegister index,\n+                                                FloatRegister tmp, BasicType bt,\n+                                                unsigned vector_length_in_bytes) {\n+\n+  assert_different_registers(dst, src1, src2, index, tmp);\n+\n+  \/\/ The cases that can reach this method are -\n+  \/\/ - UseSVE = 0, vector_length_in_bytes = 8 or 16\n+  \/\/ - UseSVE = 1, vector_length_in_bytes = 8 or 16\n+  \/\/ - UseSVE = 2, vector_length_in_bytes >= 8\n+  \/\/\n+  \/\/ SVE\/SVE2 tbl instructions are generated when UseSVE = 1 with vector_length_in_bytes = 8\n+  \/\/ and UseSVE = 2 with vector_length_in_bytes >= 8\n+  \/\/\n+  \/\/ Neon instructions are generated when UseSVE = 0 with vector_length_in_bytes = 8 or 16 and\n+  \/\/ UseSVE = 1 with vector_length_in_bytes = 16\n+\n+  if ((UseSVE == 1 && vector_length_in_bytes == 8) || UseSVE == 2) {\n+    SIMD_RegVariant T = elemType_to_regVariant(bt);\n+    select_from_two_vectors_sve(dst, src1, src2, index, tmp, T, vector_length_in_bytes);\n+    return;\n+  }\n+\n+  \/\/ The only BasicTypes that can reach here are T_SHORT, T_BYTE, T_INT and T_FLOAT\n+  assert(bt != T_DOUBLE && bt != T_LONG, \"unsupported basic type\");\n+  assert(vector_length_in_bytes <= 16, \"length_in_bytes must be <= 16\");\n+\n+  bool isQ = vector_length_in_bytes == 16;\n+\n+  SIMD_Arrangement size1 = isQ ? T16B : T8B;\n+  SIMD_Arrangement size2 = esize2arrangement((uint)type2aelembytes(bt), isQ);\n+\n+  \/\/ Neon \"tbl\" instruction only supports byte tables, so we need to look at chunks of\n+  \/\/ 2B for selecting shorts or chunks of 4B for selecting ints\/floats from the table.\n+  \/\/ The index values in \"index\" register are in the range of [0, 2 * NUM_ELEM) where NUM_ELEM\n+  \/\/ is the number of elements that can fit in a vector. For ex. for T_SHORT with 64-bit vector length,\n+  \/\/ the indices can range from [0, 8).\n+  \/\/ As an example with 64-bit vector length and T_SHORT type - let index = [2, 5, 1, 0]\n+  \/\/ Move a constant 0x02 in every byte of tmp - tmp = [0x0202, 0x0202, 0x0202, 0x0202]\n+  \/\/ Multiply index vector with tmp to yield - dst = [0x0404, 0x0a0a, 0x0202, 0x0000]\n+  \/\/ Move a constant 0x0100 in every 2B of tmp - tmp = [0x0100, 0x0100, 0x0100, 0x0100]\n+  \/\/ Add the multiplied result to the vector in tmp to obtain the byte level\n+  \/\/ offsets - dst = [0x0504, 0x0b0a, 0x0302, 0x0100]\n+  \/\/ Use these offsets in the \"tbl\" instruction to select chunks of 2B.\n+\n+  if (bt == T_BYTE) {\n+    select_from_two_vectors_neon(dst, src1, src2, index, tmp, vector_length_in_bytes);\n+  } else {\n+    int elem_size = (bt == T_SHORT) ? 2 : 4;\n+    uint64_t tbl_offset = (bt == T_SHORT) ? 0x0100u : 0x03020100u;\n+\n+    mov(tmp, size1, elem_size);\n+    mulv(dst, size2, index, tmp);\n+    mov(tmp, size2, tbl_offset);\n+    addv(dst, size1, dst, tmp); \/\/ \"dst\" now contains the processed index elements\n+                                \/\/ to select a set of 2B\/4B\n+    select_from_two_vectors_neon(dst, src1, src2, dst, tmp, vector_length_in_bytes);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":121,"deletions":0,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -37,0 +37,9 @@\n+  void select_from_two_vectors_neon(FloatRegister dst, FloatRegister src1,\n+                                    FloatRegister src2, FloatRegister index,\n+                                    FloatRegister tmp, unsigned vector_length_in_bytes);\n+\n+  void select_from_two_vectors_sve(FloatRegister dst, FloatRegister src1,\n+                                   FloatRegister src2, FloatRegister index,\n+                                   FloatRegister tmp, SIMD_RegVariant T,\n+                                   unsigned vector_length_in_bytes);\n+\n@@ -196,0 +205,5 @@\n+  \/\/ Select from a table of two vectors\n+  void select_from_two_vectors(FloatRegister dst, FloatRegister src1, FloatRegister src2,\n+                               FloatRegister index, FloatRegister tmp, BasicType bt,\n+                               unsigned vector_length_in_bytes);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1834,1 +1834,4 @@\n-       if (size_in_bits < 128 || (size_in_bits < 512 && !VM_Version::supports_avx512vl())) {\n+       if (size_in_bits < 128) {\n+         return false;\n+       }\n+       if ((size_in_bits < 512 && !VM_Version::supports_avx512vl())) {\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2709,0 +2709,3 @@\n+  \/\/ Check if the platform requires a VectorLoadShuffle node to be generated\n+  bool need_load_shuffle = Matcher::vector_rearrange_requires_load_shuffle(index_elem_bt, num_elem);\n+\n@@ -2718,1 +2721,1 @@\n-        !arch_supports_vector(Op_VectorLoadShuffle, num_elem, index_elem_bt, VecMaskNotUsed) ||\n+        (need_load_shuffle && !arch_supports_vector(Op_VectorLoadShuffle, num_elem, index_elem_bt, VecMaskNotUsed)) ||\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2090,0 +2090,4 @@\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ B, z17, z18, z16);\",              \"tbl\\tz16.b, {z17.b, z18.b}, z16.b\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ H, z17, z18, z16);\",              \"tbl\\tz16.h, {z17.h, z18.h}, z16.h\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ S, z17, z18, z16);\",              \"tbl\\tz16.s, {z17.s, z18.s}, z16.s\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ D, z17, z18, z16);\",              \"tbl\\tz16.d, {z17.d, z18.d}, z16.d\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1103,0 +1103,4 @@\n+    __ sve_tbl(z16, __ B, z17, z18, z16);              \/\/       tbl     z16.b, {z17.b, z18.b}, z16.b\n+    __ sve_tbl(z16, __ H, z17, z18, z16);              \/\/       tbl     z16.h, {z17.h, z18.h}, z16.h\n+    __ sve_tbl(z16, __ S, z17, z18, z16);              \/\/       tbl     z16.s, {z17.s, z18.s}, z16.s\n+    __ sve_tbl(z16, __ D, z17, z18, z16);              \/\/       tbl     z16.d, {z17.d, z18.d}, z16.d\n@@ -1441,7 +1445,7 @@\n-    0x14000000,     0x17ffffd7,     0x140004b0,     0x94000000,\n-    0x97ffffd4,     0x940004ad,     0x3400000a,     0x34fffa2a,\n-    0x3400954a,     0x35000008,     0x35fff9c8,     0x350094e8,\n-    0xb400000b,     0xb4fff96b,     0xb400948b,     0xb500001d,\n-    0xb5fff91d,     0xb500943d,     0x10000013,     0x10fff8b3,\n-    0x100093d3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36309356,     0x3758000c,     0x375ff7cc,     0x375892ec,\n+    0x14000000,     0x17ffffd7,     0x140004b4,     0x94000000,\n+    0x97ffffd4,     0x940004b1,     0x3400000a,     0x34fffa2a,\n+    0x340095ca,     0x35000008,     0x35fff9c8,     0x35009568,\n+    0xb400000b,     0xb4fff96b,     0xb400950b,     0xb500001d,\n+    0xb5fff91d,     0xb50094bd,     0x10000013,     0x10fff8b3,\n+    0x10009453,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363093d6,     0x3758000c,     0x375ff7cc,     0x3758936c,\n@@ -1452,13 +1456,13 @@\n-    0x540090c0,     0x54000001,     0x54fff541,     0x54009061,\n-    0x54000002,     0x54fff4e2,     0x54009002,     0x54000002,\n-    0x54fff482,     0x54008fa2,     0x54000003,     0x54fff423,\n-    0x54008f43,     0x54000003,     0x54fff3c3,     0x54008ee3,\n-    0x54000004,     0x54fff364,     0x54008e84,     0x54000005,\n-    0x54fff305,     0x54008e25,     0x54000006,     0x54fff2a6,\n-    0x54008dc6,     0x54000007,     0x54fff247,     0x54008d67,\n-    0x54000008,     0x54fff1e8,     0x54008d08,     0x54000009,\n-    0x54fff189,     0x54008ca9,     0x5400000a,     0x54fff12a,\n-    0x54008c4a,     0x5400000b,     0x54fff0cb,     0x54008beb,\n-    0x5400000c,     0x54fff06c,     0x54008b8c,     0x5400000d,\n-    0x54fff00d,     0x54008b2d,     0x5400000e,     0x54ffefae,\n-    0x54008ace,     0x5400000f,     0x54ffef4f,     0x54008a6f,\n+    0x54009140,     0x54000001,     0x54fff541,     0x540090e1,\n+    0x54000002,     0x54fff4e2,     0x54009082,     0x54000002,\n+    0x54fff482,     0x54009022,     0x54000003,     0x54fff423,\n+    0x54008fc3,     0x54000003,     0x54fff3c3,     0x54008f63,\n+    0x54000004,     0x54fff364,     0x54008f04,     0x54000005,\n+    0x54fff305,     0x54008ea5,     0x54000006,     0x54fff2a6,\n+    0x54008e46,     0x54000007,     0x54fff247,     0x54008de7,\n+    0x54000008,     0x54fff1e8,     0x54008d88,     0x54000009,\n+    0x54fff189,     0x54008d29,     0x5400000a,     0x54fff12a,\n+    0x54008cca,     0x5400000b,     0x54fff0cb,     0x54008c6b,\n+    0x5400000c,     0x54fff06c,     0x54008c0c,     0x5400000d,\n+    0x54fff00d,     0x54008bad,     0x5400000e,     0x54ffefae,\n+    0x54008b4e,     0x5400000f,     0x54ffef4f,     0x54008aef,\n@@ -1671,1 +1675,2 @@\n-    0x0568aca7,     0x05b23230,     0x853040af,     0xc5b040af,\n+    0x0568aca7,     0x05b23230,     0x05302a30,     0x05702a30,\n+    0x05b02a30,     0x05f02a30,     0x853040af,     0xc5b040af,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2849,0 +2849,30 @@\n+    public static final String SELECT_FROM_TWO_VECTOR_VB = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VB\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VB, \"SelectFromTwoVector\", TYPE_BYTE);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VS = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VS\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VS, \"SelectFromTwoVector\", TYPE_SHORT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VI = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VI, \"SelectFromTwoVector\", TYPE_INT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VF = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VF\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VF, \"SelectFromTwoVector\", TYPE_FLOAT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VD = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VD\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VD, \"SelectFromTwoVector\", TYPE_DOUBLE);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VL = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VL\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VL, \"SelectFromTwoVector\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+        \"avx512_vbmi\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,486 @@\n+\/*\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+\n+import jdk.incubator.vector.*;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\/**\n+ * @test\n+ * @bug 8348868\n+ * @library \/test\/lib \/\n+ * @summary Verify that SelectFromTwoVector IR node is correctly being\n+ *          generated on aarch64 and x86\n+ * @modules jdk.incubator.vector\n+ * @run driver compiler.vectorapi.TestSelectFromTwoVectorOp\n+ *\/\n+\n+public class TestSelectFromTwoVectorOp {\n+    private static final int SIZE = 1024;\n+    private static final Generators random = Generators.G;\n+\n+    private static byte[] ba;\n+    private static byte[] bb;\n+    private static byte[] bres;\n+    private static byte[][] bindex;\n+\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static short[] sres;\n+    private static short[][] sindex;\n+\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ires;\n+    private static int[][] iindex;\n+\n+    private static float[] fa;\n+    private static float[] fb;\n+    private static float[] fres;\n+    private static float[][] findex;\n+\n+    private static long[] la;\n+    private static long[] lb;\n+    private static long[] lres;\n+    private static long[][] lindex;\n+\n+    private static double[] da;\n+    private static double[] db;\n+    private static double[] dres;\n+    private static double[][] dindex;\n+\n+    \/\/ Stores the possible number of elements that can be\n+    \/\/ held in various vector sizes\/shapes\n+    private static int [] nums = {2, 4, 8, 16, 32, 64};\n+\n+   static {\n+        ba   = new byte[SIZE];\n+        bb   = new byte[SIZE];\n+        bres = new byte[SIZE];\n+        bindex = new byte[4][SIZE];\n+\n+        sa   = new short[SIZE];\n+        sb   = new short[SIZE];\n+        sres = new short[SIZE];\n+        sindex = new short[4][SIZE];\n+\n+        ia   = new int[SIZE];\n+        ib   = new int[SIZE];\n+        ires = new int[SIZE];\n+        iindex = new int[4][SIZE];\n+\n+        fa   = new float[SIZE];\n+        fb   = new float[SIZE];\n+        fres = new float[SIZE];\n+        findex = new float[4][SIZE];\n+\n+        la   = new long[SIZE];\n+        lb   = new long[SIZE];\n+        lres = new long[SIZE];\n+        lindex = new long[3][SIZE];\n+\n+        da   = new double[SIZE];\n+        db   = new double[SIZE];\n+        dres = new double[SIZE];\n+        dindex = new double[3][SIZE];\n+\n+        \/\/ Populate the indices\n+        for (int i = 0; i < bindex.length; i++) {\n+            bindex[i] = new byte[SIZE];\n+            sindex[i] = new short[SIZE];\n+            iindex[i] = new int[SIZE];\n+            findex[i] = new float[SIZE];\n+\n+            \/\/ The index array contains indices in the range of [0, vector_length * 2)\n+            Generator<Integer> byteGen1 = random.uniformInts(0, (nums[i + 2] * 2) - 1);\n+            Generator<Integer> shortGen1 = random.uniformInts(0, (nums[i + 1] * 2) - 1);\n+\n+            for (int j = 0; j < SIZE; j++) {\n+                bindex[i][j] = byteGen1.next().byteValue();\n+                sindex[i][j] = shortGen1.next().shortValue();\n+            }\n+\n+            if (i < dindex.length) {\n+              dindex[i] = new double[SIZE];\n+              lindex[i] = new long[SIZE];\n+\n+              random.fill(random.uniformDoubles(0, (double) ((nums[i] * 2) - 1)), dindex[i]);\n+              random.fill(random.uniformLongs(0, (long) ((nums[i] * 2) - 1)), lindex[i]);\n+            }\n+\n+            random.fill(random.uniformInts(0, (nums[i] * 2) - 1), iindex[i]);\n+            random.fill(random.uniformFloats(0, (float)((nums[i] * 2) - 1)), findex[i]);\n+        }\n+\n+        \/\/ Populate the sources\n+        Generator<Integer> byteGen = random.uniformInts(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+        Generator<Integer> shortGen = random.uniformInts(Short.MIN_VALUE, Short.MAX_VALUE);\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            ba[i] = byteGen.next().byteValue();\n+            bb[i] = byteGen.next().byteValue();\n+\n+            sa[i] = shortGen.next().shortValue();\n+            sb[i] = shortGen.next().shortValue();\n+        }\n+\n+        random.fill(random.ints(), ia);\n+        random.fill(random.ints(), ib);\n+        random.fill(random.floats(), fa);\n+        random.fill(random.floats(), fb);\n+        random.fill(random.longs(), la);\n+        random.fill(random.longs(), lb);\n+        random.fill(random.doubles(), da);\n+        random.fill(random.doubles(), db);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Bytes\n+    @ForceInline\n+    public static void ByteSelectFromTwoVectorKernel(VectorSpecies SPECIES, byte[] ba,\n+                                                     byte[] bb, byte[] bindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ba.length); i += SPECIES.length()) {\n+            ByteVector.fromArray(SPECIES, bindex, i)\n+                .selectFrom(ByteVector.fromArray(SPECIES, ba, i),\n+                            ByteVector.fromArray(SPECIES, bb, i))\n+                .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"})\n+    public static void selectFromTwoVector_Byte64() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_64, ba, bb, bindex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeatureAnd = {\"avx512_vbmi\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    public static void selectFromTwoVector_Byte128() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_128, ba, bb, bindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_32},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_32, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_32, \">0\"},\n+        applyIfCPUFeatureAnd = {\"avx512_vbmi\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Byte256() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_256, ba, bb, bindex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_64},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_64, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_64, \">0\"},\n+        applyIfCPUFeatureAnd = {\"avx512_vbmi\", \"true\", \"avx512f\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Byte512() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_512, ba, bb, bindex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Shorts\n+    @ForceInline\n+    public static void ShortSelectFromTwoVectorKernel(VectorSpecies SPECIES, short[] sa,\n+                                                      short[] sb, short[] sindex) {\n+        for (int i = 0; i < SPECIES.loopBound(sa.length); i += SPECIES.length()) {\n+            ShortVector.fromArray(SPECIES, sindex, i)\n+                .selectFrom(ShortVector.fromArray(SPECIES, sa, i),\n+                            ShortVector.fromArray(SPECIES, sb, i))\n+                .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"})\n+    public static void selectFromTwoVector_Short64() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_64, sa, sb, sindex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeatureAnd = {\"avx512bw\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    public static void selectFromTwoVector_Short128() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_128, sa, sb, sindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_16},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeatureAnd = {\"avx512bw\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Short256() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_256, sa, sb, sindex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_32},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_32, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_32, \">0\"},\n+        applyIfCPUFeatureAnd = {\"avx512bw\", \"true\", \"avx512f\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Short512() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_512, sa, sb, sindex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Ints\n+    @ForceInline\n+    public static void IntSelectFromTwoVectorKernel(VectorSpecies SPECIES, int[] ia,\n+                                                    int[] ib, int[] iindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            IntVector.fromArray(SPECIES, iindex, i)\n+                .selectFrom(IntVector.fromArray(SPECIES, ia, i),\n+                            IntVector.fromArray(SPECIES, ib, i))\n+                .intoArray(ires, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"})\n+    public static void selectFromTwoVector_Int64() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_64, ia, ib, iindex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    public static void selectFromTwoVector_Int128() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_128, ia, ib, iindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Int256() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_256, ia, ib, iindex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_16},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512f\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Int512() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_512, ia, ib, iindex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Floats\n+    @ForceInline\n+    public static void FloatSelectFromTwoVectorKernel(VectorSpecies SPECIES, float[] fa,\n+                                                      float[] fb, float[] findex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            FloatVector.fromArray(SPECIES, findex, i)\n+                .selectFrom(FloatVector.fromArray(SPECIES, fa, i),\n+                            FloatVector.fromArray(SPECIES, fb, i))\n+                .intoArray(fres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeatureOr = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"})\n+    public static void selectFromTwoVector_Float64() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_64, fa, fb, findex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    public static void selectFromTwoVector_Float128() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_128, fa, fb, findex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Float256() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_256, fa, fb, findex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_16},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512f\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Float512() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_512, fa, fb, findex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Doubles\n+    @ForceInline\n+    public static void DoubleSelectFromTwoVectorKernel(VectorSpecies SPECIES, double[] da,\n+                                                       double[] db, double[] dindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            DoubleVector.fromArray(SPECIES, dindex, i)\n+                .selectFrom(DoubleVector.fromArray(SPECIES, da, i),\n+                            DoubleVector.fromArray(SPECIES, db, i))\n+                .intoArray(dres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_2},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    public static void selectFromTwoVector_Double128() {\n+        DoubleSelectFromTwoVectorKernel(DoubleVector.SPECIES_128, da, db, dindex[0]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_4},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Double256() {\n+        DoubleSelectFromTwoVectorKernel(DoubleVector.SPECIES_256, da, db, dindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512f\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Double512() {\n+        DoubleSelectFromTwoVectorKernel(DoubleVector.SPECIES_512, da, db, dindex[2]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Longs\n+    @ForceInline\n+    public static void LongSelectFromTwoVectorKernel(VectorSpecies SPECIES, long[] la,\n+                                                     long[] lb, long[] lindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            LongVector.fromArray(SPECIES, lindex, i)\n+                .selectFrom(LongVector.fromArray(SPECIES, la, i),\n+                            LongVector.fromArray(SPECIES, lb, i))\n+                .intoArray(lres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_2},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=16\"})\n+    public static void selectFromTwoVector_Long128() {\n+        LongSelectFromTwoVectorKernel(LongVector.SPECIES_128, la, lb, lindex[0]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_4},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512vl\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Long256() {\n+        LongSelectFromTwoVectorKernel(LongVector.SPECIES_256, la, lb, lindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeatureOr = {\"sve2\", \"true\", \"avx512f\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Long512() {\n+        LongSelectFromTwoVectorKernel(LongVector.SPECIES_512, la, lb, lindex[2]);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestSelectFromTwoVectorOp.java","additions":486,"deletions":0,"binary":false,"changes":486,"status":"added"}]}