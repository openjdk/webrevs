{"files":[{"patch":"@@ -884,0 +884,40 @@\n+\/\/ Class for vector register V10\n+reg_class v10_veca_reg(\n+    V10, V10_H, V10_J, V10_K\n+);\n+\n+\/\/ Class for vector register V11\n+reg_class v11_veca_reg(\n+    V11, V11_H, V11_J, V11_K\n+);\n+\n+\/\/ Class for vector register V12\n+reg_class v12_veca_reg(\n+    V12, V12_H, V12_J, V12_K\n+);\n+\n+\/\/ Class for vector register V13\n+reg_class v13_veca_reg(\n+    V13, V13_H, V13_J, V13_K\n+);\n+\n+\/\/ Class for vector register V17\n+reg_class v17_veca_reg(\n+    V17, V17_H, V17_J, V17_K\n+);\n+\n+\/\/ Class for vector register V18\n+reg_class v18_veca_reg(\n+    V18, V18_H, V18_J, V18_K\n+);\n+\n+\/\/ Class for vector register V23\n+reg_class v23_veca_reg(\n+    V23, V23_H, V23_J, V23_K\n+);\n+\n+\/\/ Class for vector register V24\n+reg_class v24_veca_reg(\n+    V24, V24_H, V24_J, V24_K\n+);\n+\n@@ -4977,0 +5017,80 @@\n+operand vReg_V10()\n+%{\n+  constraint(ALLOC_IN_RC(v10_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V11()\n+%{\n+  constraint(ALLOC_IN_RC(v11_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V12()\n+%{\n+  constraint(ALLOC_IN_RC(v12_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V13()\n+%{\n+  constraint(ALLOC_IN_RC(v13_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V17()\n+%{\n+  constraint(ALLOC_IN_RC(v17_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V18()\n+%{\n+  constraint(ALLOC_IN_RC(v18_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V23()\n+%{\n+  constraint(ALLOC_IN_RC(v23_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V24()\n+%{\n+  constraint(ALLOC_IN_RC(v24_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -248,0 +248,19 @@\n+      case Op_SelectFromTwoVector:\n+        \/\/ The \"tbl\" instruction for two vector table is supported only in Neon and SVE2. Return\n+        \/\/ false if vector length > 16B but supported SVE version < 2.\n+        \/\/ For vector length of 16B, generate SVE2 \"tbl\" instruction if SVE2 is supported, else\n+        \/\/ generate Neon \"tbl\" instruction to select from two vectors.\n+        \/\/ This operation is disabled for doubles and longs on machines with SVE < 2 and instead\n+        \/\/ the default VectorRearrange + VectorBlend is generated as the performance of the default\n+        \/\/ implementation was slightly better\/similar than the implementation for SelectFromTwoVector.\n+        if (UseSVE < 2 && (type2aelembytes(bt) == 8 || length_in_bytes > 16)) {\n+          return false;\n+        }\n+\n+        \/\/ Because the SVE2 \"tbl\" instruction is unpredicated and partial operations cannot be generated\n+        \/\/ using masks, we currently disable this operation on machines where length_in_bytes <\n+        \/\/ MaxVectorSize on that machine with the only exception of 8B vector length.\n+        if (UseSVE == 2 && length_in_bytes > 8 && length_in_bytes < MaxVectorSize) {\n+          return false;\n+        }\n+        break;\n@@ -5105,1 +5124,1 @@\n-      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, $tmp$$FloatRegister);\n+      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, 1, $tmp$$FloatRegister);\n@@ -6665,1 +6684,1 @@\n-                 $src$$FloatRegister, $shuffle$$FloatRegister);\n+                 $src$$FloatRegister, 1, $shuffle$$FloatRegister);\n@@ -7088,1 +7107,1 @@\n-    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, $dst$$FloatRegister);\n+    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, 1, $dst$$FloatRegister);\n@@ -7153,0 +7172,141 @@\n+\n+\/\/ ------------------------------------- SelectFromTwoVector ------------------------------------\n+\/\/ The Neon and SVE2 tbl instruction for two vector lookup requires both the source vectors to be\n+\/\/ consecutive. The match rules for SelectFromTwoVector reserve two consecutive vector registers\n+\/\/ for src1 and src2.\n+\/\/ Four combinations of vector registers each for vselect_from_two_vectors_HS_Neon and\n+\/\/ vselect_from_two_vectors are chosen at random (two from volatile and two from non-volatile set)\n+\/\/ which gives more freedom to the register allocator to choose the best pair of source registers\n+\/\/ at that point.\n+\n+\/\/ ----------------------------------- SelectFromTwoVector Neon ---------------------------------\n+\n+instruct vselect_from_two_vectors_Neon_10_11(vReg dst, vReg_V10 src1, vReg_V11 src2,\n+                                             vReg index, vReg tmp1) %{\n+  predicate(UseSVE == 0 || (UseSVE == 1 && Matcher::vector_length_in_bytes(n) == 16));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_Neon_10_11 $dst, $src1, $src2, $index\\t# vector (8B\/16B\/4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                    $src2$$FloatRegister,$index$$FloatRegister,\n+                                    $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_Neon_12_13(vReg dst, vReg_V12 src1, vReg_V13 src2,\n+                                             vReg index, vReg tmp1) %{\n+  predicate(UseSVE == 0 || (UseSVE == 1 && Matcher::vector_length_in_bytes(n) == 16));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_Neon_12_13 $dst, $src1, $src2, $index\\t# vector (8B\/16B\/4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                    $src2$$FloatRegister,$index$$FloatRegister,\n+                                    $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_Neon_17_18(vReg dst, vReg_V17 src1, vReg_V18 src2,\n+                                             vReg index, vReg tmp1) %{\n+  predicate(UseSVE == 0 || (UseSVE == 1 && Matcher::vector_length_in_bytes(n) == 16));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_Neon_17_18 $dst, $src1, $src2, $index\\t# vector (8B\/16B\/4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                    $src2$$FloatRegister,$index$$FloatRegister,\n+                                    $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_Neon_23_24(vReg dst, vReg_V23 src1, vReg_V24 src2,\n+                                             vReg index, vReg tmp1) %{\n+  predicate(UseSVE == 0 || (UseSVE == 1 && Matcher::vector_length_in_bytes(n) == 16));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_Neon_23_24 $dst, $src1, $src2, $index\\t# vector (8B\/16B\/4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                    $src2$$FloatRegister,$index$$FloatRegister,\n+                                    $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ----------------------------------- SelectFromTwoVector SVE ----------------------------------\n+\n+instruct vselect_from_two_vectors_SVE_10_11(vReg dst, vReg_V10 src1, vReg_V11 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate((UseSVE == 1 && Matcher::vector_length_in_bytes(n) == 8) || UseSVE == 2);\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_SVE_10_11 $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_SVE($dst$$FloatRegister, $src1$$FloatRegister,\n+                                   $src2$$FloatRegister,$index$$FloatRegister,\n+                                   $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_SVE_12_13(vReg dst, vReg_V12 src1, vReg_V13 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate((UseSVE == 1 && Matcher::vector_length_in_bytes(n) == 8) || UseSVE == 2);\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_SVE_12_13 $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_SVE($dst$$FloatRegister, $src1$$FloatRegister,\n+                                   $src2$$FloatRegister,$index$$FloatRegister,\n+                                   $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_SVE_17_18(vReg dst, vReg_V17 src1, vReg_V18 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate((UseSVE == 1 && Matcher::vector_length_in_bytes(n) == 8) || UseSVE == 2);\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_SVE_17_18 $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_SVE($dst$$FloatRegister, $src1$$FloatRegister,\n+                                   $src2$$FloatRegister,$index$$FloatRegister,\n+                                   $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_SVE_23_24(vReg dst, vReg_V23 src1, vReg_V24 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate((UseSVE == 1 && Matcher::vector_length_in_bytes(n) == 8) || UseSVE == 2);\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_SVE_23_24 $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_SVE($dst$$FloatRegister, $src1$$FloatRegister,\n+                                   $src2$$FloatRegister,$index$$FloatRegister,\n+                                   $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":163,"deletions":3,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -238,0 +238,19 @@\n+      case Op_SelectFromTwoVector:\n+        \/\/ The \"tbl\" instruction for two vector table is supported only in Neon and SVE2. Return\n+        \/\/ false if vector length > 16B but supported SVE version < 2.\n+        \/\/ For vector length of 16B, generate SVE2 \"tbl\" instruction if SVE2 is supported, else\n+        \/\/ generate Neon \"tbl\" instruction to select from two vectors.\n+        \/\/ This operation is disabled for doubles and longs on machines with SVE < 2 and instead\n+        \/\/ the default VectorRearrange + VectorBlend is generated as the performance of the default\n+        \/\/ implementation was slightly better\/similar than the implementation for SelectFromTwoVector.\n+        if (UseSVE < 2 && (type2aelembytes(bt) == 8 || length_in_bytes > 16)) {\n+          return false;\n+        }\n+\n+        \/\/ Because the SVE2 \"tbl\" instruction is unpredicated and partial operations cannot be generated\n+        \/\/ using masks, we currently disable this operation on machines where length_in_bytes <\n+        \/\/ MaxVectorSize on that machine with the only exception of 8B vector length.\n+        if (UseSVE == 2 && length_in_bytes > 8 && length_in_bytes < MaxVectorSize) {\n+          return false;\n+        }\n+        break;\n@@ -3368,1 +3387,1 @@\n-      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, $tmp$$FloatRegister);\n+      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, 1, $tmp$$FloatRegister);\n@@ -4675,1 +4694,1 @@\n-                 $src$$FloatRegister, $shuffle$$FloatRegister);\n+                 $src$$FloatRegister, 1, $shuffle$$FloatRegister);\n@@ -5076,1 +5095,1 @@\n-    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, $dst$$FloatRegister);\n+    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, 1, $dst$$FloatRegister);\n@@ -5135,0 +5154,61 @@\n+\n+\/\/ ------------------------------------- SelectFromTwoVector ------------------------------------\n+\/\/ The Neon and SVE2 tbl instruction for two vector lookup requires both the source vectors to be\n+\/\/ consecutive. The match rules for SelectFromTwoVector reserve two consecutive vector registers\n+\/\/ for src1 and src2.\n+\/\/ Four combinations of vector registers each for vselect_from_two_vectors_HS_Neon and\n+\/\/ vselect_from_two_vectors are chosen at random (two from volatile and two from non-volatile set)\n+\/\/ which gives more freedom to the register allocator to choose the best pair of source registers\n+\/\/ at that point.\n+dnl\n+dnl SELECT_FROM_TWO_VECTORS_NEON($1,        $2        )\n+dnl SELECT_FROM_TWO_VECTORS_NEON(first_reg, second_reg)\n+define(`SELECT_FROM_TWO_VECTORS_NEON', `\n+instruct vselect_from_two_vectors_Neon_$1_$2(vReg dst, vReg_V$1 src1, vReg_V$2 src2,\n+                                             vReg index, vReg tmp1) %{\n+  predicate(UseSVE == 0 || (UseSVE == 1 && Matcher::vector_length_in_bytes(n) == 16));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_Neon_$1_$2 $dst, $src1, $src2, $index\\t# vector (8B\/16B\/4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                    $src2$$FloatRegister,$index$$FloatRegister,\n+                                    $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\n+dnl\n+dnl SELECT_FROM_TWO_VECTORS_SVE($1,        $2        )\n+dnl SELECT_FROM_TWO_VECTORS_SVE(first_reg, second_reg)\n+define(`SELECT_FROM_TWO_VECTORS_SVE', `\n+instruct vselect_from_two_vectors_SVE_$1_$2(vReg dst, vReg_V$1 src1, vReg_V$2 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate((UseSVE == 1 && Matcher::vector_length_in_bytes(n) == 8) || UseSVE == 2);\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  format %{ \"vselect_from_two_vectors_SVE_$1_$2 $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_SVE($dst$$FloatRegister, $src1$$FloatRegister,\n+                                   $src2$$FloatRegister,$index$$FloatRegister,\n+                                   $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ----------------------------------- SelectFromTwoVector Neon ---------------------------------\n+SELECT_FROM_TWO_VECTORS_NEON(10, 11)\n+SELECT_FROM_TWO_VECTORS_NEON(12, 13)\n+SELECT_FROM_TWO_VECTORS_NEON(17, 18)\n+SELECT_FROM_TWO_VECTORS_NEON(23, 24)\n+\n+\/\/ ----------------------------------- SelectFromTwoVector SVE ----------------------------------\n+SELECT_FROM_TWO_VECTORS_SVE(10, 11)\n+SELECT_FROM_TWO_VECTORS_SVE(12, 13)\n+SELECT_FROM_TWO_VECTORS_SVE(17, 18)\n+SELECT_FROM_TWO_VECTORS_SVE(23, 24)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":83,"deletions":3,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -4230,2 +4230,2 @@\n-  \/\/ SVE programmable table lookup\/permute using vector of element indices\n-  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) {\n+  \/\/ SVE\/SVE2 Programmable table lookup in one or two vector table (zeroing)\n+  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, unsigned reg_count, FloatRegister Zm) {\n@@ -4234,0 +4234,4 @@\n+    \/\/ Only supports one or two vector lookup. One vector lookup was introduced in SVE1\n+    \/\/ and two vector lookup in SVE2\n+    assert(0 < reg_count && reg_count <= 2, \"invalid number of registers\");\n+    int op11 = (reg_count == 1) ? 0b10 : 0b01;\n@@ -4235,1 +4239,1 @@\n-    f(0b001100, 15, 10), rf(Zn, 5), rf(Zd, 0);\n+    f(0b001, 15, 13), f(op11, 12, 11), f(0b0, 10), rf(Zn, 5), rf(Zd, 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2456,1 +2456,1 @@\n-  sve_tbl(vtmp1, H, vtmp1, vtmp2);\n+  sve_tbl(vtmp1, H, vtmp1, 1, vtmp2);\n@@ -2513,1 +2513,1 @@\n-  sve_tbl(vtmp1, B, vtmp1, vtmp2);\n+  sve_tbl(vtmp1, B, vtmp1, 1, vtmp2);\n@@ -2856,0 +2856,85 @@\n+\n+void C2_MacroAssembler::select_from_two_vectors_Neon(FloatRegister dst, FloatRegister src1,\n+                                                     FloatRegister src2, FloatRegister index,\n+                                                     FloatRegister tmp1, BasicType bt, bool isQ) {\n+\n+  assert_different_registers(dst, src1, src2, index, tmp1);\n+\n+  \/\/ The only BasicTypes that can reach here are T_SHORT, T_BYTE, T_INT and T_FLOAT\n+  assert(bt != T_DOUBLE || bt != T_LONG, \"unsupported basic type\");\n+\n+  assert(UseSVE < 2, \"must be either 0 or 1\");\n+\n+  SIMD_Arrangement size1 = isQ ? T16B : T8B;\n+  SIMD_Arrangement size2 = esize2arrangement((uint)type2aelembytes(bt), isQ);\n+\n+  \/\/ Neon \"tbl\" instruction only supports byte tables, so we need to look at chunks of\n+  \/\/ 2B for selecting shorts or chunks of 4B for selecting ints\/floats from the table.\n+  \/\/ The index values in \"index\" register are in the range of [0, 2 * NUM_ELEM) where NUM_ELEM\n+  \/\/ is the number of elements that can fit in a vector. For ex. for T_SHORT with 64-bit vector length,\n+  \/\/ the indices can range from [0, 8).\n+  \/\/ As an example with 64-bit vector length and T_SHORT type - let index = [2, 5, 1, 0]\n+  \/\/ Move a constant 0x02 in every byte of tmp1 - tmp1 = [0x0202, 0x0202, 0x0202, 0x0202]\n+  \/\/ Multiply index vector with tmp1 to yield - dst = [0x0404, 0x0a0a, 0x0202, 0x0000]\n+  \/\/ Move a constant 0x0100 in every 2B of tmp1 - tmp1 = [0x0100, 0x0100, 0x0100, 0x0100]\n+  \/\/ Add the multiplied result to the vector in tmp1 to obtain the byte level\n+  \/\/ offsets - dst = [0x0504, 0x0b0a, 0x0302, 0x0100]\n+  \/\/ Use these offsets in the \"tbl\" instruction to select chunks of 2B.\n+\n+  bool is_byte = (bt == T_BYTE);\n+\n+  if (is_byte) {\n+    if (isQ) {\n+      assert(UseSVE <= 1, \"sve must be <= 1\");\n+      \/\/ If the vector length is 16B, then use the Neon \"tbl\" instruction with two vector table\n+      tbl(dst, size1, src1, 2, index);\n+    } else { \/\/ vector length == 8\n+      assert(UseSVE == 0, \"must be Neon only\");\n+      \/\/ We need to fit both the source vectors (src1, src2) in a 128-bit register because the\n+      \/\/ Neon \"tbl\" instruction supports only looking up 16B vectors. We then use the Neon \"tbl\"\n+      \/\/ instruction with one vector lookup\n+      ins(tmp1, D, src1, 0, 0);\n+      ins(tmp1, D, src2, 1, 0);\n+      tbl(dst, size1, tmp1, 1, index);\n+    }\n+  } else {\n+    int elemSize = (bt == T_SHORT) ? 2 : 4;\n+    uint64_t tblOffset = (bt == T_SHORT) ? 0x0100u : 0x03020100u;\n+\n+    mov(tmp1, size1, elemSize);\n+    mulv(dst, size2, index, tmp1);\n+    mov(tmp1, size2, tblOffset);\n+    addv(dst, size1, dst, tmp1); \/\/ \"dst\" now contains the processed index elements\n+                                 \/\/ to select a set of 2B\/4B\n+    if (isQ) {\n+      assert(UseSVE <= 1, \"sve must be <= 1\");\n+      \/\/ If the vector length is 16B, then use the Neon \"tbl\" instruction with two vector table\n+      tbl(dst, size1, src1, 2, dst);\n+    } else {  \/\/ vector length == 8\n+      \/\/ We need to fit both the source vectors (src1, src2) in a 128-bit register because the\n+      \/\/ Neon \"tbl\" instruction supports only looking up 16B vectors. We then use the Neon \"tbl\"\n+      \/\/ instruction with one vector lookup\n+      assert(UseSVE == 0, \"must be Neon only\");\n+      ins(tmp1, D, src1, 0, 0);\n+      ins(tmp1, D, src2, 1, 0);\n+      tbl(dst, size1, tmp1, 1, dst);\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::select_from_two_vectors_SVE(FloatRegister dst, FloatRegister src1,\n+                                                    FloatRegister src2, FloatRegister index,\n+                                                    FloatRegister tmp1, BasicType bt,\n+                                                    unsigned vector_length_in_bytes) {\n+  SIMD_RegVariant size = elemType_to_regVariant(bt);\n+\n+  if (vector_length_in_bytes == 8) {\n+    assert(UseSVE >= 1, \"sve must be >= 1\");\n+    ins(tmp1, D, src1, 0, 0);\n+    ins(tmp1, D, src2, 1, 0);\n+    sve_tbl(dst, size, tmp1, 1, index);\n+  } else {  \/\/ UseSVE == 2 and vector_length_in_bytes > 8\n+  assert(UseSVE == 2, \"must be sve2\");\n+  sve_tbl(dst, size, src1, 2, index);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":87,"deletions":2,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -196,0 +196,8 @@\n+  \/\/ Select from a table of two vectors\n+  void select_from_two_vectors_Neon(FloatRegister dst, FloatRegister src1, FloatRegister src2,\n+                                    FloatRegister index, FloatRegister tmp1, BasicType bt,\n+                                    bool isQ);\n+\n+  void select_from_two_vectors_SVE(FloatRegister dst, FloatRegister src1, FloatRegister src2,\n+                                   FloatRegister index, FloatRegister tmp1, BasicType bt,\n+                                   unsigned length_in_bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2742,0 +2742,3 @@\n+  \/\/ Check if the platform requires a VectorLoadShuffle node to be generated\n+  bool need_load_shuffle = Matcher::vector_rearrange_requires_load_shuffle(index_elem_bt, num_elem);\n+\n@@ -2751,1 +2754,1 @@\n-        !arch_supports_vector(Op_VectorLoadShuffle, num_elem, index_elem_bt, VecMaskNotUsed) ||\n+        (need_load_shuffle && !arch_supports_vector(Op_VectorLoadShuffle, num_elem, index_elem_bt, VecMaskNotUsed)) ||\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2089,1 +2089,5 @@\n-                        [\"tbl\",      \"__ sve_tbl(z16, __ S, z17, z18);\",                   \"tbl\\tz16.s, {z17.s}, z18.s\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ S, z17, 1, z18);\",                \"tbl\\tz16.s, {z17.s}, z18.s\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ B, z17, 2, z16);\",                \"tbl\\tz16.b, {z17.b, z18.b}, z16.b\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ H, z17, 2, z16);\",                \"tbl\\tz16.h, {z17.h, z18.h}, z16.h\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ S, z17, 2, z16);\",                \"tbl\\tz16.s, {z17.s, z18.s}, z16.s\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ D, z17, 2, z16);\",                \"tbl\\tz16.d, {z17.d, z18.d}, z16.d\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1101,1 +1101,5 @@\n-    __ sve_tbl(z16, __ S, z17, z18);                   \/\/       tbl     z16.s, {z17.s}, z18.s\n+    __ sve_tbl(z16, __ S, z17, 1, z18);                \/\/       tbl     z16.s, {z17.s}, z18.s\n+    __ sve_tbl(z16, __ B, z17, 2, z16);                \/\/       tbl     z16.b, {z17.b, z18.b}, z16.b\n+    __ sve_tbl(z16, __ H, z17, 2, z16);                \/\/       tbl     z16.h, {z17.h, z18.h}, z16.h\n+    __ sve_tbl(z16, __ S, z17, 2, z16);                \/\/       tbl     z16.s, {z17.s, z18.s}, z16.s\n+    __ sve_tbl(z16, __ D, z17, 2, z16);                \/\/       tbl     z16.d, {z17.d, z18.d}, z16.d\n@@ -1440,7 +1444,7 @@\n-    0x14000000,     0x17ffffd7,     0x140004af,     0x94000000,\n-    0x97ffffd4,     0x940004ac,     0x3400000a,     0x34fffa2a,\n-    0x3400952a,     0x35000008,     0x35fff9c8,     0x350094c8,\n-    0xb400000b,     0xb4fff96b,     0xb400946b,     0xb500001d,\n-    0xb5fff91d,     0xb500941d,     0x10000013,     0x10fff8b3,\n-    0x100093b3,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36309336,     0x3758000c,     0x375ff7cc,     0x375892cc,\n+    0x14000000,     0x17ffffd7,     0x140004b3,     0x94000000,\n+    0x97ffffd4,     0x940004b0,     0x3400000a,     0x34fffa2a,\n+    0x340095aa,     0x35000008,     0x35fff9c8,     0x35009548,\n+    0xb400000b,     0xb4fff96b,     0xb40094eb,     0xb500001d,\n+    0xb5fff91d,     0xb500949d,     0x10000013,     0x10fff8b3,\n+    0x10009433,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363093b6,     0x3758000c,     0x375ff7cc,     0x3758934c,\n@@ -1451,13 +1455,13 @@\n-    0x540090a0,     0x54000001,     0x54fff541,     0x54009041,\n-    0x54000002,     0x54fff4e2,     0x54008fe2,     0x54000002,\n-    0x54fff482,     0x54008f82,     0x54000003,     0x54fff423,\n-    0x54008f23,     0x54000003,     0x54fff3c3,     0x54008ec3,\n-    0x54000004,     0x54fff364,     0x54008e64,     0x54000005,\n-    0x54fff305,     0x54008e05,     0x54000006,     0x54fff2a6,\n-    0x54008da6,     0x54000007,     0x54fff247,     0x54008d47,\n-    0x54000008,     0x54fff1e8,     0x54008ce8,     0x54000009,\n-    0x54fff189,     0x54008c89,     0x5400000a,     0x54fff12a,\n-    0x54008c2a,     0x5400000b,     0x54fff0cb,     0x54008bcb,\n-    0x5400000c,     0x54fff06c,     0x54008b6c,     0x5400000d,\n-    0x54fff00d,     0x54008b0d,     0x5400000e,     0x54ffefae,\n-    0x54008aae,     0x5400000f,     0x54ffef4f,     0x54008a4f,\n+    0x54009120,     0x54000001,     0x54fff541,     0x540090c1,\n+    0x54000002,     0x54fff4e2,     0x54009062,     0x54000002,\n+    0x54fff482,     0x54009002,     0x54000003,     0x54fff423,\n+    0x54008fa3,     0x54000003,     0x54fff3c3,     0x54008f43,\n+    0x54000004,     0x54fff364,     0x54008ee4,     0x54000005,\n+    0x54fff305,     0x54008e85,     0x54000006,     0x54fff2a6,\n+    0x54008e26,     0x54000007,     0x54fff247,     0x54008dc7,\n+    0x54000008,     0x54fff1e8,     0x54008d68,     0x54000009,\n+    0x54fff189,     0x54008d09,     0x5400000a,     0x54fff12a,\n+    0x54008caa,     0x5400000b,     0x54fff0cb,     0x54008c4b,\n+    0x5400000c,     0x54fff06c,     0x54008bec,     0x5400000d,\n+    0x54fff00d,     0x54008b8d,     0x5400000e,     0x54ffefae,\n+    0x54008b2e,     0x5400000f,     0x54ffef4f,     0x54008acf,\n@@ -1670,1 +1674,2 @@\n-    0x05b23230,     0x853040af,     0xc5b040af,     0xe57080af,\n+    0x05b23230,     0x05302a30,     0x05702a30,     0x05b02a30,\n+    0x05f02a30,     0x853040af,     0xc5b040af,     0xe57080af,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2830,0 +2830,30 @@\n+    public static final String SELECT_FROM_TWO_VECTOR_VB = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VB\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VB, \"SelectFromTwoVector\", TYPE_BYTE);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VS = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VS\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VS, \"SelectFromTwoVector\", TYPE_SHORT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VI = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VI\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VI, \"SelectFromTwoVector\", TYPE_INT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VF = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VF\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VF, \"SelectFromTwoVector\", TYPE_FLOAT);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VD = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VD\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VD, \"SelectFromTwoVector\", TYPE_DOUBLE);\n+    }\n+\n+    public static final String SELECT_FROM_TWO_VECTOR_VL = VECTOR_PREFIX + \"SELECT_FROM_TWO_VECTOR_VL\" + POSTFIX;\n+    static {\n+        vectorNode(SELECT_FROM_TWO_VECTOR_VL, \"SelectFromTwoVector\", TYPE_LONG);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,453 @@\n+\/*\n+ * Copyright (c) 2025, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+\n+import jdk.incubator.vector.*;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.Random;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\/**\n+ * @test\n+ * @bug 8348868\n+ * @library \/test\/lib \/\n+ * @summary Verify that SelectFromTwoVector IR node is correctly being\n+ *          generated for Neon and SVE\n+ * @modules jdk.incubator.vector\n+ * @run driver compiler.vectorapi.TestSelectFromTwoVectorOp\n+ *\/\n+\n+public class TestSelectFromTwoVectorOp {\n+    private static final int SIZE = 1024;\n+    private static final Generators random = Generators.G;\n+\n+    private static byte[] ba;\n+    private static byte[] bb;\n+    private static byte[] bres;\n+    private static byte[][] bindex;\n+\n+    private static short[] sa;\n+    private static short[] sb;\n+    private static short[] sres;\n+    private static short[][] sindex;\n+\n+    private static int[] ia;\n+    private static int[] ib;\n+    private static int[] ires;\n+    private static int[][] iindex;\n+\n+    private static float[] fa;\n+    private static float[] fb;\n+    private static float[] fres;\n+    private static float[][] findex;\n+\n+    private static long[] la;\n+    private static long[] lb;\n+    private static long[] lres;\n+    private static long[][] lindex;\n+\n+    private static double[] da;\n+    private static double[] db;\n+    private static double[] dres;\n+    private static double[][] dindex;\n+\n+    \/\/ Stores the possible number of elements that can be\n+    \/\/ held in various vector sizes\/shapes\n+    private static int [] nums = {2, 4, 8, 16, 32, 64};\n+\n+   static {\n+        ba   = new byte[SIZE];\n+        bb   = new byte[SIZE];\n+        bres = new byte[SIZE];\n+        bindex = new byte[4][SIZE];\n+\n+        sa   = new short[SIZE];\n+        sb   = new short[SIZE];\n+        sres = new short[SIZE];\n+        sindex = new short[4][SIZE];\n+\n+        ia   = new int[SIZE];\n+        ib   = new int[SIZE];\n+        ires = new int[SIZE];\n+        iindex = new int[4][SIZE];\n+\n+        fa   = new float[SIZE];\n+        fb   = new float[SIZE];\n+        fres = new float[SIZE];\n+        findex = new float[4][SIZE];\n+\n+        la   = new long[SIZE];\n+        lb   = new long[SIZE];\n+        lres = new long[SIZE];\n+        lindex = new long[3][SIZE];\n+\n+        da   = new double[SIZE];\n+        db   = new double[SIZE];\n+        dres = new double[SIZE];\n+        dindex = new double[3][SIZE];\n+\n+        \/\/ Populate the indices\n+        for (int i = 0; i < bindex.length; i++) {\n+            bindex[i] = new byte[SIZE];\n+            sindex[i] = new short[SIZE];\n+            iindex[i] = new int[SIZE];\n+            findex[i] = new float[SIZE];\n+\n+            \/\/ The index array contains indices in the range of [0, vector_length * 2)\n+            Generator<Integer> byteGen1 = random.uniformInts(0, (nums[i + 2] * 2) - 1);\n+            Generator<Integer> shortGen1 = random.uniformInts(0, (nums[i + 1] * 2) - 1);\n+\n+            for (int j = 0; j < SIZE; j++) {\n+                bindex[i][j] = byteGen1.next().byteValue();\n+                sindex[i][j] = shortGen1.next().shortValue();\n+            }\n+\n+            if (i < dindex.length) {\n+              dindex[i] = new double[SIZE];\n+              lindex[i] = new long[SIZE];\n+\n+              random.fill(random.uniformDoubles(0, (double) ((nums[i] * 2) - 1)), dindex[i]);\n+              random.fill(random.uniformLongs(0, (long) ((nums[i] * 2) - 1)), lindex[i]);\n+            }\n+\n+            random.fill(random.uniformInts(0, (nums[i] * 2) - 1), iindex[i]);\n+            random.fill(random.uniformFloats(0, (float)((nums[i] * 2) - 1)), findex[i]);\n+        }\n+\n+        \/\/ Populate the sources\n+        Generator<Integer> byteGen = random.uniformInts(Byte.MIN_VALUE, Byte.MAX_VALUE);\n+        Generator<Integer> shortGen = random.uniformInts(Short.MIN_VALUE, Short.MAX_VALUE);\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            ba[i] = byteGen.next().byteValue();\n+            bb[i] = byteGen.next().byteValue();\n+\n+            sa[i] = shortGen.next().shortValue();\n+            sb[i] = shortGen.next().shortValue();\n+        }\n+\n+        random.fill(random.ints(), ia);\n+        random.fill(random.ints(), ib);\n+        random.fill(random.floats(), fa);\n+        random.fill(random.floats(), fb);\n+        random.fill(random.longs(), la);\n+        random.fill(random.longs(), lb);\n+        random.fill(random.doubles(), da);\n+        random.fill(random.doubles(), db);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Bytes\n+    @ForceInline\n+    public static void ByteSelectFromTwoVectorKernel(VectorSpecies SPECIES, byte[] ba,\n+                                                     byte[] bb, byte[] bindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ba.length); i += SPECIES.length()) {\n+            ByteVector.fromArray(SPECIES, bindex, i)\n+                .selectFrom(ByteVector.fromArray(SPECIES, ba, i),\n+                            ByteVector.fromArray(SPECIES, bb, i))\n+                .intoArray(bres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void selectFromTwoVector_Byte64() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_64, ba, bb, bindex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void selectFromTwoVector_Byte128() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_128, ba, bb, bindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_32},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_32, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Byte256() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_256, ba, bb, bindex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_64},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VB, IRNode.VECTOR_SIZE_64, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Byte512() {\n+        ByteSelectFromTwoVectorKernel(ByteVector.SPECIES_512, ba, bb, bindex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Shorts\n+    @ForceInline\n+    public static void ShortSelectFromTwoVectorKernel(VectorSpecies SPECIES, short[] sa,\n+                                                      short[] sb, short[] sindex) {\n+        for (int i = 0; i < SPECIES.loopBound(sa.length); i += SPECIES.length()) {\n+            ShortVector.fromArray(SPECIES, sindex, i)\n+                .selectFrom(ShortVector.fromArray(SPECIES, sa, i),\n+                            ShortVector.fromArray(SPECIES, sb, i))\n+                .intoArray(sres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void selectFromTwoVector_Short64() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_64, sa, sb, sindex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"})\n+    public static void selectFromTwoVector_Short128() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_128, sa, sb, sindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_16},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Short256() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_256, sa, sb, sindex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_32},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VS, IRNode.VECTOR_SIZE_32, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Short512() {\n+        ShortSelectFromTwoVectorKernel(ShortVector.SPECIES_512, sa, sb, sindex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Ints\n+    @ForceInline\n+    public static void IntSelectFromTwoVectorKernel(VectorSpecies SPECIES, int[] ia,\n+                                                    int[] ib, int[] iindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            IntVector.fromArray(SPECIES, iindex, i)\n+                .selectFrom(IntVector.fromArray(SPECIES, ia, i),\n+                            IntVector.fromArray(SPECIES, ib, i))\n+                .intoArray(ires, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void selectFromTwoVector_Int64() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_64, ia, ib, iindex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"})\n+    public static void selectFromTwoVector_Int128() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_128, ia, ib, iindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Int256() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_256, ia, ib, iindex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_16},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VI, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Int512() {\n+        IntSelectFromTwoVectorKernel(IntVector.SPECIES_512, ia, ib, iindex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Floats\n+    @ForceInline\n+    public static void FloatSelectFromTwoVectorKernel(VectorSpecies SPECIES, float[] fa,\n+                                                      float[] fb, float[] findex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            FloatVector.fromArray(SPECIES, findex, i)\n+                .selectFrom(FloatVector.fromArray(SPECIES, fa, i),\n+                            FloatVector.fromArray(SPECIES, fb, i))\n+                .intoArray(fres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void selectFromTwoVector_Float64() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_64, fa, fb, findex[0]);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"})\n+    public static void selectFromTwoVector_Float128() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_128, fa, fb, findex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Float256() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_256, fa, fb, findex[2]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_16},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VF, IRNode.VECTOR_SIZE_16, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Float512() {\n+        FloatSelectFromTwoVectorKernel(FloatVector.SPECIES_512, fa, fb, findex[3]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Doubles\n+    @ForceInline\n+    public static void DoubleSelectFromTwoVectorKernel(VectorSpecies SPECIES, double[] da,\n+                                                       double[] db, double[] dindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            DoubleVector.fromArray(SPECIES, dindex, i)\n+                .selectFrom(DoubleVector.fromArray(SPECIES, da, i),\n+                            DoubleVector.fromArray(SPECIES, db, i))\n+                .intoArray(dres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_2},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"})\n+    public static void selectFromTwoVector_Double128() {\n+        DoubleSelectFromTwoVectorKernel(DoubleVector.SPECIES_128, da, db, dindex[0]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_4},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Double256() {\n+        DoubleSelectFromTwoVectorKernel(DoubleVector.SPECIES_256, da, db, dindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VD, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Double512() {\n+        DoubleSelectFromTwoVectorKernel(DoubleVector.SPECIES_512, da, db, dindex[2]);\n+    }\n+\n+    \/\/ Test SelectFromTwoVector operation for Longs\n+    @ForceInline\n+    public static void LongSelectFromTwoVectorKernel(VectorSpecies SPECIES, long[] la,\n+                                                     long[] lb, long[] lindex) {\n+        for (int i = 0; i < SPECIES.loopBound(ia.length); i += SPECIES.length()) {\n+            LongVector.fromArray(SPECIES, lindex, i)\n+                .selectFrom(LongVector.fromArray(SPECIES, la, i),\n+                            LongVector.fromArray(SPECIES, lb, i))\n+                .intoArray(lres, i);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_2},\n+    applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_2, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"})\n+    public static void selectFromTwoVector_Long128() {\n+        LongSelectFromTwoVectorKernel(LongVector.SPECIES_128, la, lb, lindex[0]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_4},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_4, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"})\n+    public static void selectFromTwoVector_Long256() {\n+        LongSelectFromTwoVectorKernel(LongVector.SPECIES_256, la, lb, lindex[1]);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_8},\n+        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve2\", \"false\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    @IR(counts = {IRNode.SELECT_FROM_TWO_VECTOR_VL, IRNode.VECTOR_SIZE_8, \">0\"},\n+        applyIfCPUFeature = {\"sve2\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \">=64\"})\n+    public static void selectFromTwoVector_Long512() {\n+        LongSelectFromTwoVectorKernel(LongVector.SPECIES_512, la, lb, lindex[2]);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestSelectFromTwoVectorOp.java","additions":453,"deletions":0,"binary":false,"changes":453,"status":"added"}]}