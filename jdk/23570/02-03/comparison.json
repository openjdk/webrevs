{"files":[{"patch":"@@ -884,0 +884,20 @@\n+\/\/ Class for vector register V10\n+reg_class v10_veca_reg(\n+    V10, V10_H, V10_J, V10_K\n+);\n+\n+\/\/ Class for vector register V11\n+reg_class v11_veca_reg(\n+    V11, V11_H, V11_J, V11_K\n+);\n+\n+\/\/ Class for vector register V12\n+reg_class v12_veca_reg(\n+    V12, V12_H, V12_J, V12_K\n+);\n+\n+\/\/ Class for vector register V13\n+reg_class v13_veca_reg(\n+    V13, V13_H, V13_J, V18_K\n+);\n+\n@@ -894,0 +914,10 @@\n+\/\/ Class for vector register V23\n+reg_class v23_veca_reg(\n+    V23, V23_H, V23_J, V23_K\n+);\n+\n+\/\/ Class for vector register V24\n+reg_class v24_veca_reg(\n+    V24, V24_H, V24_J, V24_K\n+);\n+\n@@ -4987,0 +5017,40 @@\n+operand vReg_V10()\n+%{\n+  constraint(ALLOC_IN_RC(v10_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V11()\n+%{\n+  constraint(ALLOC_IN_RC(v11_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V12()\n+%{\n+  constraint(ALLOC_IN_RC(v12_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V13()\n+%{\n+  constraint(ALLOC_IN_RC(v13_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -5007,0 +5077,20 @@\n+operand vReg_V23()\n+%{\n+  constraint(ALLOC_IN_RC(v23_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand vReg_V24()\n+%{\n+  constraint(ALLOC_IN_RC(v24_veca_reg));\n+  match(vReg);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -255,0 +255,3 @@\n+      \/\/ As the SVE2 \"tbl\" instruction in unpredicated and partial operations cannot be generated\n+      \/\/ using masks, we currently disable this operation on machines where length_in_bytes <\n+      \/\/ MaxVectorSize on that machine with the only exception of 8B vector length.\n@@ -256,2 +259,3 @@\n-        if (UseSVE < 2 && (type2aelembytes(bt) == 8 || length_in_bytes > 16)) {\n-        return false;\n+        if ((UseSVE < 2 && (type2aelembytes(bt) == 8 || length_in_bytes > 16)) ||\n+            (UseSVE == 2 && length_in_bytes > 8 && length_in_bytes < MaxVectorSize )) {\n+          return false;\n@@ -5117,1 +5121,1 @@\n-      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, $tmp$$FloatRegister);\n+      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, 1, $tmp$$FloatRegister);\n@@ -6677,1 +6681,1 @@\n-                 $src$$FloatRegister, $shuffle$$FloatRegister);\n+                 $src$$FloatRegister, 1, $shuffle$$FloatRegister);\n@@ -7100,1 +7104,1 @@\n-    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, $dst$$FloatRegister);\n+    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, 1, $dst$$FloatRegister);\n@@ -7168,1 +7172,0 @@\n-\/\/ Both the match rules for SelectFromTwoVector reserve V17 and V18 vector registers for src1 and src2.\n@@ -7170,7 +7173,61 @@\n-\/\/ consective. As registers V0-V7 are reserved for arguments, V8-V15 are non-volatile (used for preserving\n-\/\/ values across function calls and usually used for long-lived values), we can use any two volatile\n-\/\/ registers between V16-V31.\n-instruct vselect_from_two_vectors_HS_Neon(vReg dst, vReg_V17 src1, vReg_V18 src2,\n-                                          vReg index, vReg tmp1) %{\n-  predicate((Matcher::vector_element_basic_type(n) == T_SHORT ||\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4) &&\n+\/\/ consecutive. The match rules for SelectFromTwoVector reserve two consecutive vector registers\n+\/\/ for src1 and src2.\n+\/\/ Four combinations of vector registers each for vselect_from_two_vectors_HS_Neon and\n+\/\/ vselect_from_two_vectors are chosen at random (two from volatile and two from non-volatile set)\n+\/\/ which gives more freedom to the register allocator to choose the best pair of source registers\n+\/\/ at that point.\n+\n+instruct vselect_from_two_vectors_HS_Neon_1(vReg dst, vReg_V10 src1, vReg_V11 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_BYTE &&\n+            (UseSVE < 2 || Matcher::vector_length_in_bytes(n) < 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors_HS_Neon $dst, $src1, $src2, $index\\t# vector (4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_HS_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                       $src2$$FloatRegister,$index$$FloatRegister,\n+                                       $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_HS_Neon_2(vReg dst, vReg_V12 src1, vReg_V13 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_BYTE &&\n+            (UseSVE < 2 || Matcher::vector_length_in_bytes(n) < 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors_HS_Neon $dst, $src1, $src2, $index\\t# vector (4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_HS_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                       $src2$$FloatRegister,$index$$FloatRegister,\n+                                       $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_HS_Neon_3(vReg dst, vReg_V17 src1, vReg_V18 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_BYTE &&\n+            (UseSVE < 2 || Matcher::vector_length_in_bytes(n) < 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors_HS_Neon $dst, $src1, $src2, $index\\t# vector (4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_HS_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                       $src2$$FloatRegister,$index$$FloatRegister,\n+                                       $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_HS_Neon_4(vReg dst, vReg_V23 src1, vReg_V24 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_BYTE &&\n@@ -7191,1 +7248,46 @@\n-instruct vselect_from_two_vectors(vReg dst, vReg_V17 src1, vReg_V18 src2, vReg index, vReg tmp1) %{\n+instruct vselect_from_two_vectors_1(vReg dst, vReg_V10 src1, vReg_V11 src2, vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+           (UseSVE == 2 && Matcher::vector_length_in_bytes(n) >= 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                               $index$$FloatRegister, $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_2(vReg dst, vReg_V12 src1, vReg_V13 src2, vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+           (UseSVE == 2 && Matcher::vector_length_in_bytes(n) >= 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                               $index$$FloatRegister, $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_3(vReg dst, vReg_V17 src1, vReg_V18 src2, vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+           (UseSVE == 2 && Matcher::vector_length_in_bytes(n) >= 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                               $index$$FloatRegister, $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_4(vReg dst, vReg_V23 src1, vReg_V24 src2, vReg index, vReg tmp1) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":116,"deletions":14,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -245,0 +245,3 @@\n+      \/\/ As the SVE2 \"tbl\" instruction in unpredicated and partial operations cannot be generated\n+      \/\/ using masks, we currently disable this operation on machines where length_in_bytes <\n+      \/\/ MaxVectorSize on that machine with the only exception of 8B vector length.\n@@ -246,2 +249,3 @@\n-        if (UseSVE < 2 && (type2aelembytes(bt) == 8 || length_in_bytes > 16)) {\n-        return false;\n+        if ((UseSVE < 2 && (type2aelembytes(bt) == 8 || length_in_bytes > 16)) ||\n+            (UseSVE == 2 && length_in_bytes > 8 && length_in_bytes < MaxVectorSize )) {\n+          return false;\n@@ -3380,1 +3384,1 @@\n-      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, $tmp$$FloatRegister);\n+      __ sve_tbl($tmp$$FloatRegister, __ B, $src$$FloatRegister, 1, $tmp$$FloatRegister);\n@@ -4687,1 +4691,1 @@\n-                 $src$$FloatRegister, $shuffle$$FloatRegister);\n+                 $src$$FloatRegister, 1, $shuffle$$FloatRegister);\n@@ -5088,1 +5092,1 @@\n-    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, $dst$$FloatRegister);\n+    __ sve_tbl($dst$$FloatRegister, size, $src$$FloatRegister, 1, $dst$$FloatRegister);\n@@ -5150,1 +5154,0 @@\n-\/\/ Both the match rules for SelectFromTwoVector reserve V17 and V18 vector registers for src1 and src2.\n@@ -5152,7 +5155,61 @@\n-\/\/ consective. As registers V0-V7 are reserved for arguments, V8-V15 are non-volatile (used for preserving\n-\/\/ values across function calls and usually used for long-lived values), we can use any two volatile\n-\/\/ registers between V16-V31.\n-instruct vselect_from_two_vectors_HS_Neon(vReg dst, vReg_V17 src1, vReg_V18 src2,\n-                                          vReg index, vReg tmp1) %{\n-  predicate((Matcher::vector_element_basic_type(n) == T_SHORT ||\n-            type2aelembytes(Matcher::vector_element_basic_type(n)) == 4) &&\n+\/\/ consecutive. The match rules for SelectFromTwoVector reserve two consecutive vector registers\n+\/\/ for src1 and src2.\n+\/\/ Four combinations of vector registers each for vselect_from_two_vectors_HS_Neon and\n+\/\/ vselect_from_two_vectors are chosen at random (two from volatile and two from non-volatile set)\n+\/\/ which gives more freedom to the register allocator to choose the best pair of source registers\n+\/\/ at that point.\n+\n+instruct vselect_from_two_vectors_HS_Neon_1(vReg dst, vReg_V10 src1, vReg_V11 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_BYTE &&\n+            (UseSVE < 2 || Matcher::vector_length_in_bytes(n) < 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors_HS_Neon $dst, $src1, $src2, $index\\t# vector (4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_HS_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                       $src2$$FloatRegister,$index$$FloatRegister,\n+                                       $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_HS_Neon_2(vReg dst, vReg_V12 src1, vReg_V13 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_BYTE &&\n+            (UseSVE < 2 || Matcher::vector_length_in_bytes(n) < 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors_HS_Neon $dst, $src1, $src2, $index\\t# vector (4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_HS_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                       $src2$$FloatRegister,$index$$FloatRegister,\n+                                       $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_HS_Neon_3(vReg dst, vReg_V17 src1, vReg_V18 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_BYTE &&\n+            (UseSVE < 2 || Matcher::vector_length_in_bytes(n) < 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors_HS_Neon $dst, $src1, $src2, $index\\t# vector (4S\/8S\/2I\/4I\/2F\/4F). KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors_HS_Neon($dst$$FloatRegister, $src1$$FloatRegister,\n+                                       $src2$$FloatRegister,$index$$FloatRegister,\n+                                       $tmp1$$FloatRegister, bt, \/* isQ *\/ length_in_bytes == 16);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_HS_Neon_4(vReg dst, vReg_V23 src1, vReg_V24 src2,\n+                                            vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) != T_BYTE &&\n@@ -5173,1 +5230,46 @@\n-instruct vselect_from_two_vectors(vReg dst, vReg_V17 src1, vReg_V18 src2, vReg index, vReg tmp1) %{\n+instruct vselect_from_two_vectors_1(vReg dst, vReg_V10 src1, vReg_V11 src2, vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+           (UseSVE == 2 && Matcher::vector_length_in_bytes(n) >= 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                               $index$$FloatRegister, $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_2(vReg dst, vReg_V12 src1, vReg_V13 src2, vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+           (UseSVE == 2 && Matcher::vector_length_in_bytes(n) >= 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                               $index$$FloatRegister, $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_3(vReg dst, vReg_V17 src1, vReg_V18 src2, vReg index, vReg tmp1) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE ||\n+           (UseSVE == 2 && Matcher::vector_length_in_bytes(n) >= 16));\n+  match(Set dst (SelectFromTwoVector (Binary index src1) src2));\n+  effect(TEMP_DEF dst, TEMP tmp1);\n+  format %{ \"vselect_from_two_vectors $dst, $src1, $src2, $index\\t# KILL $tmp1\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n+    __ select_from_two_vectors($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                               $index$$FloatRegister, $tmp1$$FloatRegister, bt, length_in_bytes);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vselect_from_two_vectors_4(vReg dst, vReg_V23 src1, vReg_V24 src2, vReg index, vReg tmp1) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":116,"deletions":14,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -4230,2 +4230,2 @@\n-  \/\/ SVE programmable table lookup\/permute using vector of element indices\n-  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, FloatRegister Zm) {\n+  \/\/ SVE\/SVE2 Programmable table lookup in one or two vector table (zeroing)\n+  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, unsigned registers, FloatRegister Zm) {\n@@ -4234,0 +4234,4 @@\n+    \/\/ Only supports one or two vector lookup. One vector lookup was introduced in SVE1\n+    \/\/ and two vector lookup in SVE2\n+    assert(0 < registers && registers <= 2, \"invalid number of registers\");\n+    int op1 = (registers == 1) ? 0b10 : 0b01;\n@@ -4235,1 +4239,1 @@\n-    f(0b001100, 15, 10), rf(Zn, 5), rf(Zd, 0);\n+    f(0b001, 15, 13), f(op1, 12, 11), f(0b0, 10), rf(Zn, 5), rf(Zd, 0);\n@@ -4297,10 +4301,0 @@\n-  \/\/ SVE2 programmable table lookup in two vector table\n-  void sve_tbl(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn1,\n-               FloatRegister Zn2, FloatRegister Zm) {\n-    starti;\n-    assert(T != Q, \"invalid size\");\n-    assert(Zn1->successor() == Zn2, \"invalid order of registers\");\n-    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);\n-    f(0b001010, 15, 10), rf(Zn1, 5), rf(Zd, 0);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2456,1 +2456,1 @@\n-  sve_tbl(vtmp1, H, vtmp1, vtmp2);\n+  sve_tbl(vtmp1, H, vtmp1, 1, vtmp2);\n@@ -2513,1 +2513,1 @@\n-  sve_tbl(vtmp1, B, vtmp1, vtmp2);\n+  sve_tbl(vtmp1, B, vtmp1, 1, vtmp2);\n@@ -2861,1 +2861,1 @@\n-  assert_different_registers(dst, src1, src2, tmp1);\n+  assert_different_registers(dst, src1, src2, index, tmp1);\n@@ -2880,29 +2880,32 @@\n-  switch (bt) {\n-    case T_SHORT:\n-      mov(tmp1, size1, 0x02);\n-      mulv(dst, size2, index, tmp1);\n-      mov(tmp1, size2, 0x0100);\n-      addv(dst, size1, dst, tmp1); \/\/ \"dst\" now contains the processed index elements\n-                                   \/\/ to select a set of 2B\n-      break;\n-    case T_INT:\n-    case T_FLOAT:\n-      \/\/ Similarly, for int\/float the index values for the \"tbl\" instruction are computed to\n-      \/\/ select chunks of 4B for every int\/float element\n-      mov(tmp1, size1, 0x04);\n-      mulv(dst, size2, index, tmp1);\n-      mov(tmp1, size2, 0x03020100);\n-      addv(dst, size1, dst, tmp1); \/\/ \"dst\" now contains the processed index elements\n-                                   \/\/ to select a set of 4B\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-\n-  if (isQ) {\n-    \/\/ If the vector length is 16B, then use the Neon \"tbl\" instruction with two vector table\n-    tbl(dst, size1, src1, 2, dst);\n-  } else {  \/\/ vector length == 8\n-    \/\/ We need to fit both the source vectors (src1, src2) in a 128-bit register as the\n-    \/\/ Neon \"tbl\" instruction supports only looking up 16B vectors. We then use the Neon \"tbl\"\n-    \/\/ instruction with one vector lookup\n+  \/\/ The cases that can reach this method are -\n+  \/\/ UseSVE == 0, vector length = 8, 16\n+  \/\/ UseSVE == 1, vector length = 8, 16\n+  \/\/ UseSVE == 2, vector length = 8\n+  \/\/\n+  \/\/ Generate Neon tbl when UseSVE == 0 or UseSVE == 1 with vector length of 16B\n+\n+  bool useNeon = (UseSVE == 0) || (UseSVE == 1 && isQ);\n+\n+  if (useNeon) {\n+    int elemSize = (bt == T_SHORT) ? 2 : 4;\n+    uint64_t tblOffset = (bt == T_SHORT) ? 0x0100u : 0x03020100u;\n+\n+    mov(tmp1, size1, elemSize);\n+    mulv(dst, size2, index, tmp1);\n+    mov(tmp1, size2, tblOffset);\n+    addv(dst, size1, dst, tmp1); \/\/ \"dst\" now contains the processed index elements\n+                                 \/\/ to select a set of 2B\/4B\n+\n+    if (isQ) {\n+      \/\/ If the vector length is 16B, then use the Neon \"tbl\" instruction with two vector table\n+      tbl(dst, size1, src1, 2, dst);\n+    } else {  \/\/ vector length == 8\n+      \/\/ We need to fit both the source vectors (src1, src2) in a 128-bit register because the\n+      \/\/ Neon \"tbl\" instruction supports only looking up 16B vectors. We then use the Neon \"tbl\"\n+      \/\/ instruction with one vector lookup\n+      ins(tmp1, D, src1, 0, 0);\n+      ins(tmp1, D, src2, 1, 0);\n+      tbl(dst, size1, tmp1, 1, dst);\n+    }\n+    \/\/ Generate tbl one vector lookup (SVE1) when UseSVE >= 1 and vector length == 8\n+  } else if (UseSVE >= 1 && !isQ) {\n@@ -2911,1 +2914,1 @@\n-    tbl(dst, size1, tmp1, 1, dst);\n+    sve_tbl(dst, elemType_to_regVariant(bt), tmp1, 1, index);\n@@ -2928,1 +2931,1 @@\n-    sve_tbl(dst, size, src1, src2, index);\n+    sve_tbl(dst, size, src1, 2, index);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":37,"deletions":34,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2089,5 +2089,5 @@\n-                        [\"tbl\",      \"__ sve_tbl(z16, __ S, z17, z18);\",                   \"tbl\\tz16.s, {z17.s}, z18.s\"],\n-                        [\"tbl\",      \"__ sve_tbl(z16, __ B, z17, z18, z16);\",              \"tbl\\tz16.b, {z17.b, z18.b}, z16.b\"],\n-                        [\"tbl\",      \"__ sve_tbl(z16, __ H, z17, z18, z16);\",              \"tbl\\tz16.h, {z17.h, z18.h}, z16.h\"],\n-                        [\"tbl\",      \"__ sve_tbl(z16, __ S, z17, z18, z16);\",              \"tbl\\tz16.s, {z17.s, z18.s}, z16.s\"],\n-                        [\"tbl\",      \"__ sve_tbl(z16, __ D, z17, z18, z16);\",              \"tbl\\tz16.d, {z17.d, z18.d}, z16.d\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ S, z17, 1, z18);\",                \"tbl\\tz16.s, {z17.s}, z18.s\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ B, z17, 2, z16);\",                \"tbl\\tz16.b, {z17.b, z18.b}, z16.b\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ H, z17, 2, z16);\",                \"tbl\\tz16.h, {z17.h, z18.h}, z16.h\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ S, z17, 2, z16);\",                \"tbl\\tz16.s, {z17.s, z18.s}, z16.s\"],\n+                        [\"tbl\",      \"__ sve_tbl(z16, __ D, z17, 2, z16);\",                \"tbl\\tz16.d, {z17.d, z18.d}, z16.d\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1101,5 +1101,5 @@\n-    __ sve_tbl(z16, __ S, z17, z18);                   \/\/       tbl     z16.s, {z17.s}, z18.s\n-    __ sve_tbl(z16, __ B, z17, z18, z16);              \/\/       tbl     z16.b, {z17.b, z18.b}, z16.b\n-    __ sve_tbl(z16, __ H, z17, z18, z16);              \/\/       tbl     z16.h, {z17.h, z18.h}, z16.h\n-    __ sve_tbl(z16, __ S, z17, z18, z16);              \/\/       tbl     z16.s, {z17.s, z18.s}, z16.s\n-    __ sve_tbl(z16, __ D, z17, z18, z16);              \/\/       tbl     z16.d, {z17.d, z18.d}, z16.d\n+    __ sve_tbl(z16, __ S, z17, 1, z18);                \/\/       tbl     z16.s, {z17.s}, z18.s\n+    __ sve_tbl(z16, __ B, z17, 2, z16);                \/\/       tbl     z16.b, {z17.b, z18.b}, z16.b\n+    __ sve_tbl(z16, __ H, z17, 2, z16);                \/\/       tbl     z16.h, {z17.h, z18.h}, z16.h\n+    __ sve_tbl(z16, __ S, z17, 2, z16);                \/\/       tbl     z16.s, {z17.s, z18.s}, z16.s\n+    __ sve_tbl(z16, __ D, z17, 2, z16);                \/\/       tbl     z16.d, {z17.d, z18.d}, z16.d\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}