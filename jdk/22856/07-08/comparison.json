{"files":[{"patch":"@@ -163,0 +163,4 @@\n+        tests.put(\"testMemorySegmentIInvarL3da\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3da(data, 1, 2, 3, RANGE-200);\n+        });\n@@ -167,0 +171,4 @@\n+        tests.put(\"testMemorySegmentIInvarL3d2a\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3d2a(data, 1, 2, 3, RANGE-200);\n+        });\n@@ -175,0 +183,4 @@\n+        tests.put(\"testMemorySegmentIInvarL3ea\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3ea(data, 1, 2, 3, RANGE-200);\n+        });\n@@ -195,0 +207,4 @@\n+        tests.put(\"testMemorySegmentLInvarL3da\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3da(data, 1, 2, 3, RANGE-200);\n+        });\n@@ -199,0 +215,4 @@\n+        tests.put(\"testMemorySegmentLInvarL3d2a\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3d2a(data, 1, 2, 3, RANGE-200);\n+        });\n@@ -207,0 +227,4 @@\n+        tests.put(\"testMemorySegmentLInvarL3ea\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n+          return testMemorySegmentLInvarL3ea(data, 1, 2, 3, RANGE-200);\n+        });\n@@ -245,0 +269,1 @@\n+                 \"testMemorySegmentIInvarL3da\",\n@@ -246,0 +271,1 @@\n+                 \"testMemorySegmentIInvarL3d2a\",\n@@ -248,0 +274,1 @@\n+                 \"testMemorySegmentIInvarL3ea\",\n@@ -253,0 +280,1 @@\n+                 \"testMemorySegmentLInvarL3da\",\n@@ -254,0 +282,1 @@\n+                 \"testMemorySegmentLInvarL3d2a\",\n@@ -256,0 +285,1 @@\n+                 \"testMemorySegmentLInvarL3ea\",\n@@ -683,0 +713,18 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 10\",\n+                  IRNode.STORE_VECTOR,  \"= 10\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentIInvarL3d(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3 - invar1); \/\/ equivalent\n+        for (int i = 0; i < size; i+=2) {\n+            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 0);\n+            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + i2 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i2 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n@@ -687,0 +735,1 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n@@ -690,1 +739,1 @@\n-    static Object[] testMemorySegmentIInvarL3d(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentIInvarL3da(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n@@ -702,0 +751,17 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 10\",\n+                  IRNode.STORE_VECTOR,  \"= 10\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentIInvarL3d2(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        for (int i = 0; i < size; i+=2) {\n+            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 0);\n+            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n@@ -706,0 +772,1 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n@@ -709,1 +776,1 @@\n-    static Object[] testMemorySegmentIInvarL3d2(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentIInvarL3d2a(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n@@ -738,0 +805,18 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 10\",\n+                  IRNode.STORE_VECTOR,  \"= 10\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    static Object[] testMemorySegmentIInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3) - (long)(invar1); \/\/ not equivalent\n+        for (int i = 0; i < size; i+=2) {\n+            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 0);\n+            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + i2 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i2 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n@@ -741,0 +826,1 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n@@ -746,1 +832,1 @@\n-    static Object[] testMemorySegmentIInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentIInvarL3ea(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n@@ -828,2 +914,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 4\",\n+                  IRNode.STORE_VECTOR,  \"= 4\"},\n@@ -831,0 +917,1 @@\n+        applyIf = {\"AlignVector\", \"false\"},\n@@ -850,0 +937,21 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Would be nice if it vectorized.\n+    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    static Object[] testMemorySegmentLInvarL3da(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3 - invar1); \/\/ equivalent\n+        for (int i = 0; i < size; i+=2) {\n+            long v0 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0);\n+            long v1 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 4\",\n+                  IRNode.STORE_VECTOR,  \"= 4\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n@@ -864,0 +972,19 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Would be nice if it vectorized.\n+    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    static Object[] testMemorySegmentLInvarL3d2a(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        for (int i = 0; i < size; i+=2) {\n+            long v0 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0);\n+            long v1 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n@@ -882,0 +1009,19 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 4\",\n+                  IRNode.STORE_VECTOR,  \"= 4\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ FAILS: should be ok to vectorize, but does not. Investigate in JDK-8331659.\n+    static Object[] testMemorySegmentLInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3) - (long)(invar1); \/\/ not equivalent\n+        for (int i = 0; i < size; i+=2) {\n+            long v0 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0);\n+            long v1 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n@@ -886,0 +1032,1 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n@@ -888,1 +1035,1 @@\n-    static Object[] testMemorySegmentLInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentLInvarL3ea(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java","additions":153,"deletions":6,"binary":false,"changes":159,"status":"modified"}]}