[{"commit":{"message":"indent"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java"}],"sha":"397cf15f9a780d75c4743bbc67f094d69d7cfe23"},{"commit":{"message":"consistently label failing cases due to Align requirements."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java"}],"sha":"e5beda4e24ef0af12c27bc0aa5eca501113fdc3a"},{"commit":{"message":"Apply suggestions from code review\n\nCo-authored-by: Emanuel Peter <emanuel.peter@oracle.com>"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java"}],"sha":"ed2191896b3a1fbba588d35ce2813ae1d652c0ca"},{"commit":{"message":"disable `|` . comments."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopulateIndex.java"}],"sha":"cd1c8a1207c9791d65b6ce2b467bdbbde3979289"},{"commit":{"message":"\"should never vectorize\" only holds for long[] input."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java"}],"sha":"a421aec7750d141fa5dc817e7296fa3bb1d8bbb1"},{"commit":{"message":"completely disable IR rule"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopulateIndex.java"}],"sha":"2ce808d0da704f463e1c245225227cc3b0310698"},{"commit":{"message":"You can have two @IR rules with different applyIfs."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java"}],"sha":"bcdd6f8fae053171a792b2149f73024e7a840f19"},{"commit":{"message":"expect vectorization of i|7 instead of i&7\ni&7 variant expect \"= 0\"."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopulateIndex.java"}],"sha":"419292b6fd3b33162b8a629c1af326b4430825fd"},{"commit":{"message":"TestEquivalentInvariants: split scenarios that differ by 'AlignVector'\n\nThree variants (3d 3d2 3e) start vectorizing with -XX:-AlignVector, whereas they remain unvectorized under -XX:+AlignVector. Constrain these to AlignVector=false, and add 3 new variants (suffix 'a') with AlignVector=true.\n\nSpecial attention to 3e: it says\n    \/\/ Should never vectorize, since i1 and i2 are not guaranteed to be adjacent\n    \/\/ invar2 + invar3 could overflow, and the address be valid with and without overflow.\n    \/\/ So both addresses are valid, and not adjacent.\nbut now it does vectorize."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java"}],"sha":"442e6c85dca7f4d01c39b434050299a69ba8cbe9"},{"commit":{"message":"undo assertion and mask shift amount ourselves.\nwe cannot rely on `maskShiftAmount` having run in all cases"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"a8c3a6b8b5aff4615b8593d1ecbe7d9aa45b34d1"},{"commit":{"message":"Merge branch 'openjdk:master' into mernst\/JDK-8346664"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"},{"filename":"src\/hotspot\/share\/opto\/mulnode.hpp"}],"sha":"490cc2fb8a89688f0f740f2d9c058aca16ff3328"},{"commit":{"message":"make the check more clear: shift >= mask_width"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"272267c2070dc1b192dfdbec3c5927f526761177"},{"commit":{"message":"fully randomized"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java"}],"sha":"4849477fdd4b0a5d5ff1a3b5580874d8a09d29fc"},{"commit":{"message":"JLS: only the lower bits of the shift are taken into account (aka we don't assert)."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java"}],"sha":"ff10ac2cce8299e6265fa77bc8ad05476aafb6d9"},{"commit":{"message":"(c)"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.hpp"}],"sha":"c9a6545f5d31181b55259b345da06c16b82db3f1"},{"commit":{"message":"(c)"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java"}],"sha":"f839e5fd47e972be025231b9f0b26bd76e5fb638"},{"commit":{"message":"Assert that MulNode::Ideal already masks constant shift amounts for us.\nAvoid accidental zero mask breaking test."},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java"}],"sha":"541e44c627b860ebd016496900fe2a34c692bee1"},{"commit":{"message":"\"element\"."},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java"}],"sha":"35afeb0fa7f7f800972db8e2e7fff82afb44b8ea"},{"commit":{"message":"avoid redundant comment"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"cbe61651d4651a37a50f3d722b1fa4dd63a82a2f"},{"commit":{"message":"addConstNonConstMaskLong"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java"}],"sha":"9d3ca069d28e46cfc604aa5af6856ac004331882"},{"commit":{"message":"randomize, test \"(j + const) & nonconst_mask\"."},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java"}],"sha":"6df13fff11c2efc9fcd86ccec3fcf0857949a16e"},{"commit":{"message":"naming, comment"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"e0f44b4decf02e722a9f2c84b597090eedae302d"},{"commit":{"message":"comment readability"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"15558464d5438d97cf545f7f63b1cbf30e070af4"},{"commit":{"message":"consistently use bt"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"2a79c24ada6c7b5dfe68aa7f73da258e4baea73f"},{"commit":{"message":"--more null checks"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"df79a96b36efbd3756874cf63417b3131fc83671"},{"commit":{"message":"counter"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java"}],"sha":"cabc0d85dd81a65e4de430bd11f35eac5a7f35de"},{"commit":{"message":"T != X"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"ba2f82b855bd9b1d70af3b89972f95a1486bcc5a"},{"commit":{"message":"undo method reordering"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"bc3c4f03f3675ca23e8d3c3aa3a487e44c7b5e3d"},{"commit":{"message":"review:\n* make helpers static\n* remove null checks\n* separate test cases\n* naming \/ reword comments\n\nreadability:\n* move reverse checks to (some) callsites"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"},{"filename":"src\/hotspot\/share\/opto\/mulnode.hpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java"}],"sha":"2b8da62aa217ac13fa7d9cc3a84912430834f4c1"},{"commit":{"message":"C2: optimize constant addends in masked sums\n\nExtends the optimization of masked sums introduced in #6697 to cover constant values, which currently break the optimization.\n\nSuch constant values arise in an expression of the following form, for example from MemorySegmentImpl#isAlignedForElement:\n\n(base + (index + 1) << 8) & 255\n=> MulNode\n(base + (index << 8 + 256)) & 255\n=> AddNode\n((base + index << 8) + 256) & 255\n\nCurrently, \"256\" is not being recognized as a shifted value. This PR enables:\n\n((base + index << 8) + 256) & 255\n=> MulNode\n(base + index << 8) & 255\n=> MulNode (PR #6697)\nbase & 255"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"},{"filename":"src\/hotspot\/share\/opto\/mulnode.hpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java"}],"sha":"bd77da8bf9889f00b7e2055c0020148ab5d60e31"}]