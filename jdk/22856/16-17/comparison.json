{"files":[{"patch":"@@ -2078,0 +2078,1 @@\n+  \/\/ Pattern: expr = (x << shift)\n@@ -2079,2 +2080,2 @@\n-    const TypeInt* rhs_t = phase->type(expr->in(2))->isa_int();\n-    if (rhs_t == nullptr || !rhs_t->is_con()) {\n+    const TypeInt* shift_t = phase->type(expr->in(2))->isa_int();\n+    if (shift_t == nullptr || !shift_t->is_con()) {\n@@ -2089,2 +2090,2 @@\n-\/\/ Checks whether expr is neutral wrt addition under mask, i.e.\n-\/\/ an expression of the form (AndX (T+expr) mask) can be simplified to (AndX T mask).\n+\/\/ Checks whether expr is neutral element (zero) under mask. We have:\n+\/\/   (AndX expr mask)\n@@ -2092,10 +2093,13 @@\n-\/\/ Specifically, this holds for the following cases,\n-\/\/ when the shift value N is large enough to zero out\n-\/\/ all the set positions of the and-mask M:\n-\/\/   (AndI (LShiftI _ #N) #M)\n-\/\/   (AndL (LShiftL _ #N) #M)\n-\/\/   (AndL (ConvI2L (LShiftI _ #N)) #M)\n-\/\/ including equivalent constant operands:\n-\/\/   (AndI (ConI (_ << #N)) #M)\n-\/\/   (AndL (ConL (_ << #N)) #M)\n-\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n+\/\/\n+\/\/ We split the bits of expr into MSB and LSB, where LSB represents\n+\/\/ all trailing zeros of expr:\n+\/\/   MSB    LSB\n+\/\/   mmmmmm 0000000000\n+\/\/\n+\/\/ We check if the mask has no one bits in the corresponding higher\n+\/\/ bits, i.e. if the number of trailing zeros is larger or equal to the\n+\/\/ bit width of the expr, i.e. if the number of leading zeros for mask\n+\/\/ is greater or equal to the number of bits in MSB:\n+\/\/   000000 00000eeee -> (AndX expr mask) = 0                 -> return true\n+\/\/   0000ee eeeeeeeeee -> (AndX expr mask) = 0000xx 0000000000 -> return false\n+\/\/\n@@ -2108,0 +2112,1 @@\n+  \/\/ When the mask is negative, it has the most significant bit set.\n@@ -2113,1 +2118,6 @@\n-  jint mask_bit_width = mask_t->hi_as_long() == 0 ? 0 : (BitsPerLong - count_leading_zeros(mask_t->hi_as_long()));\n+  \/\/ Is the mask always zero?\n+  if (mask_t->hi_as_long() == 0) {\n+    assert(mask_t->lo_as_long() == 0, \"checked earlier\");\n+    return true;\n+  }\n+  jint mask_bit_width =  BitsPerLong - count_leading_zeros(mask_t->hi_as_long());\n@@ -2117,5 +2127,8 @@\n-\/\/ Given an expression (AndX (AddX v1 v2) mask)\n-\/\/ determine if the AndX must always produce (AndX v1 mask),\n-\/\/ because v2 is zero wrt addition under mask.\n-\/\/ Because the AddX operands can come in either\n-\/\/ order, we check for both orders.\n+\/\/ Pattern:\n+\/\/   (AndX (AddX add1 add2) mask)\n+\/\/\n+\/\/ Assume:\n+\/\/   (AndX add1 mask) == 0\n+\/\/\n+\/\/ ... prove why we know that we can return:\n+\/\/   (AndX add2 mask)\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"}]}