{"files":[{"patch":"@@ -695,0 +695,2 @@\n+static bool AndIL_is_zero_element_under_mask(const PhaseGVN* phase, const Node* expr, const Node* mask, BasicType bt);\n+\n@@ -696,2 +698,2 @@\n-  \/\/ patterns similar to (v << 2) & 3\n-  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_INT, true)) {\n+  if (AndIL_is_zero_element_under_mask(phase, in(1), in(2), T_INT) ||\n+      AndIL_is_zero_element_under_mask(phase, in(2), in(1), T_INT)) {\n@@ -743,2 +745,2 @@\n-  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-  Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n+  \/\/ Simplify (v1 + v2) & mask to v1 & mask or v2 & mask when possible.\n+  Node* progress = AndIL_sum_and_mask(phase, T_INT);\n@@ -827,2 +829,2 @@\n-  \/\/ patterns similar to (v << 2) & 3\n-  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_LONG, true)) {\n+  if (AndIL_is_zero_element_under_mask(phase, in(1), in(2), T_LONG) ||\n+      AndIL_is_zero_element_under_mask(phase, in(2), in(1), T_LONG)) {\n@@ -875,2 +877,2 @@\n-  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-  Node* progress = AndIL_add_shift_and_mask(phase, T_LONG);\n+  \/\/ Simplify (v1 + v2) & mask to v1 & mask or v2 & mask when possible.\n+  Node* progress = AndIL_sum_and_mask(phase, T_LONG);\n@@ -2099,24 +2101,8 @@\n-\/\/ Given an expression (AndX shift mask) or (AndX mask shift),\n-\/\/ determine if the AndX must always produce zero, because the\n-\/\/ the shift (x<<N) is bitwise disjoint from the mask #M.\n-\/\/ The X in AndX must be I or L, depending on bt.\n-\/\/ Specifically, the following cases fold to zero,\n-\/\/ when the shift value N is large enough to zero out\n-\/\/ all the set positions of the and-mask M.\n-\/\/   (AndI (LShiftI _ #N) #M) => #0\n-\/\/   (AndL (LShiftL _ #N) #M) => #0\n-\/\/   (AndL (ConvI2L (LShiftI _ #N)) #M) => #0\n-\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n-\/\/ Because the optimization might work for a non-constant\n-\/\/ mask M, we check the AndX for both operand orders.\n-bool MulNode::AndIL_shift_and_mask_is_always_zero(PhaseGVN* phase, Node* shift, Node* mask, BasicType bt, bool check_reverse) {\n-  if (mask == nullptr || shift == nullptr) {\n-    return false;\n-  }\n-  const TypeInteger* mask_t = phase->type(mask)->isa_integer(bt);\n-  if (mask_t == nullptr || phase->type(shift)->isa_integer(bt) == nullptr) {\n-    return false;\n-  }\n-  shift = shift->uncast();\n-  if (shift == nullptr) {\n-    return false;\n+\/\/------------------------------ Sum & Mask ------------------------------\n+\n+\/\/ Returns a lower bound on the number of trailing zeros in expr.\n+static jint AndIL_min_trailing_zeros(const PhaseGVN* phase, const Node* expr, BasicType bt) {\n+  expr = expr->uncast();\n+  const TypeInteger* type = phase->type(expr)->isa_integer(bt);\n+  if (type == nullptr) {\n+    return 0;\n@@ -2124,2 +2110,4 @@\n-  if (phase->type(shift)->isa_integer(bt) == nullptr) {\n-    return false;\n+\n+  if (type->is_con()) {\n+    jlong con = type->get_con_as_long(bt);\n+    return con == 0L ? (type2aelembytes(bt) * BitsPerByte) : count_trailing_zeros(con);\n@@ -2127,2 +2115,3 @@\n-  BasicType shift_bt = bt;\n-  if (bt == T_LONG && shift->Opcode() == Op_ConvI2L) {\n+\n+  if (expr->Opcode() == Op_ConvI2L) {\n+    expr = expr->in(1)->uncast();\n@@ -2130,15 +2119,1 @@\n-    Node* val = shift->in(1);\n-    if (val == nullptr) {\n-      return false;\n-    }\n-    val = val->uncast();\n-    if (val == nullptr) {\n-      return false;\n-    }\n-    if (val->Opcode() == Op_LShiftI) {\n-      shift_bt = T_INT;\n-      shift = val;\n-      if (phase->type(shift)->isa_integer(bt) == nullptr) {\n-        return false;\n-      }\n-    }\n+    type = phase->type(expr)->isa_int();\n@@ -2146,6 +2121,6 @@\n-  if (shift->Opcode() != Op_LShift(shift_bt)) {\n-    if (check_reverse &&\n-        (mask->Opcode() == Op_LShift(bt) ||\n-         (bt == T_LONG && mask->Opcode() == Op_ConvI2L))) {\n-      \/\/ try it the other way around\n-      return AndIL_shift_and_mask_is_always_zero(phase, mask, shift, bt, false);\n+\n+  \/\/ Pattern: expr = (x << shift)\n+  if (expr->Opcode() == Op_LShift(bt)) {\n+    const TypeInt* shift_t = phase->type(expr->in(2))->isa_int();\n+    if (shift_t == nullptr || !shift_t->is_con()) {\n+      return 0;\n@@ -2153,5 +2128,6 @@\n-    return false;\n-  }\n-  Node* shift2 = shift->in(2);\n-  if (shift2 == nullptr) {\n-    return false;\n+    \/\/ We need to truncate the shift, as it may not have been canonicalized yet.\n+    \/\/ T_INT:  0..31 -> shift_mask = 4 * 8 - 1 = 31\n+    \/\/ T_LONG: 0..63 -> shift_mask = 8 * 8 - 1 = 63\n+    \/\/ (JLS: \"Shift Operators\")\n+    jint shift_mask = type2aelembytes(bt) * BitsPerByte - 1;\n+    return shift_t->get_con() & shift_mask;\n@@ -2159,2 +2135,48 @@\n-  const Type* shift2_t = phase->type(shift2);\n-  if (!shift2_t->isa_int() || !shift2_t->is_int()->is_con()) {\n+\n+  return 0;\n+}\n+\n+\/\/ Checks whether expr is neutral additive element (zero) under mask,\n+\/\/ i.e. whether an expression of the form:\n+\/\/   (AndX (AddX (expr addend) mask)\n+\/\/   (expr + addend) & mask\n+\/\/ is equivalent to\n+\/\/   (AndX addend mask)\n+\/\/   addend & mask\n+\/\/ for any addend.\n+\/\/ (The X in AndX must be I or L, depending on bt).\n+\/\/\n+\/\/ We check for the sufficient condition when the lowest set bit in expr is higher than\n+\/\/ the highest set bit in mask, i.e.:\n+\/\/ expr: eeeeee0000000000000\n+\/\/ mask: 000000mmmmmmmmmmmmm\n+\/\/             <--w bits--->\n+\/\/ We do not test for other cases.\n+\/\/\n+\/\/ Correctness:\n+\/\/   Given \"expr\" with at least \"w\" trailing zeros,\n+\/\/   let \"mod = 2^w\", \"suffix_mask = mod - 1\"\n+\/\/\n+\/\/   Since \"mask\" only has bits set where \"suffix_mask\" does, we have:\n+\/\/     mask = suffix_mask & mask     (SUFFIX_MASK)\n+\/\/\n+\/\/   And since expr only has bits set above w, and suffix_mask only below:\n+\/\/     expr & suffix_mask == 0     (NO_BIT_OVERLAP)\n+\/\/\n+\/\/   From unsigned modular arithmetic (with unsigned modulo %), and since mod is\n+\/\/   a power of 2, and we are computing in a ring of powers of 2, we know that\n+\/\/     (x + y) % mod         = (x % mod         + y) % mod\n+\/\/     (x + y) & suffix_mask = (x & suffix_mask + y) & suffix_mask       (MOD_ARITH)\n+\/\/\n+\/\/   We can now prove the equality:\n+\/\/     (expr               + addend)               & mask\n+\/\/   = (expr               + addend) & suffix_mask & mask    (SUFFIX_MASK)\n+\/\/   = (expr & suffix_mask + addend) & suffix_mask & mask    (MOD_ARITH)\n+\/\/   = (0                  + addend) & suffix_mask & mask    (NO_BIT_OVERLAP)\n+\/\/   =                       addend                & mask    (SUFFIX_MASK)\n+\/\/\n+\/\/ Hence, an expr with at least w trailing zeros is a neutral additive element under any mask with bit width w.\n+static bool AndIL_is_zero_element_under_mask(const PhaseGVN* phase, const Node* expr, const Node* mask, BasicType bt) {\n+  \/\/ When the mask is negative, it has the most significant bit set.\n+  const TypeInteger* mask_t = phase->type(mask)->isa_integer(bt);\n+  if (mask_t == nullptr || mask_t->lo_as_long() < 0) {\n@@ -2164,3 +2186,4 @@\n-  jint shift_con = shift2_t->is_int()->get_con() & ((shift_bt == T_INT ? BitsPerJavaInteger : BitsPerJavaLong) - 1);\n-  if ((((jlong)1) << shift_con) > mask_t->hi_as_long() && mask_t->lo_as_long() >= 0) {\n-    return true;\n+  \/\/ When the mask is constant zero, we defer to MulNode::Value to eliminate the entire AndX operation.\n+  if (mask_t->hi_as_long() == 0) {\n+    assert(mask_t->lo_as_long() == 0, \"checked earlier\");\n+    return false;\n@@ -2169,1 +2192,3 @@\n-  return false;\n+  jint mask_bit_width = BitsPerLong - count_leading_zeros(mask_t->hi_as_long());\n+  jint expr_trailing_zeros = AndIL_min_trailing_zeros(phase, expr, bt);\n+  return expr_trailing_zeros >= mask_bit_width;\n@@ -2172,15 +2197,5 @@\n-\/\/ Given an expression (AndX (AddX v1 (LShiftX v2 #N)) #M)\n-\/\/ determine if the AndX must always produce (AndX v1 #M),\n-\/\/ because the shift (v2<<N) is bitwise disjoint from the mask #M.\n-\/\/ The X in AndX will be I or L, depending on bt.\n-\/\/ Specifically, the following cases fold,\n-\/\/ when the shift value N is large enough to zero out\n-\/\/ all the set positions of the and-mask M.\n-\/\/   (AndI (AddI v1 (LShiftI _ #N)) #M) => (AndI v1 #M)\n-\/\/   (AndL (AddI v1 (LShiftL _ #N)) #M) => (AndL v1 #M)\n-\/\/   (AndL (AddL v1 (ConvI2L (LShiftI _ #N))) #M) => (AndL v1 #M)\n-\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n-\/\/ Because the optimization might work for a non-constant\n-\/\/ mask M, and because the AddX operands can come in either\n-\/\/ order, we check for every operand order.\n-Node* MulNode::AndIL_add_shift_and_mask(PhaseGVN* phase, BasicType bt) {\n+\/\/ Reduces the pattern:\n+\/\/   (AndX (AddX add1 add2) mask)\n+\/\/ to\n+\/\/   (AndX add1 mask), if add2 is neutral wrt mask (see above), and vice versa.\n+Node* MulNode::AndIL_sum_and_mask(PhaseGVN* phase, BasicType bt) {\n@@ -2189,3 +2204,0 @@\n-  if (add == nullptr || mask == nullptr) {\n-    return nullptr;\n-  }\n@@ -2203,8 +2215,6 @@\n-    if (add1 != nullptr && add2 != nullptr) {\n-      if (AndIL_shift_and_mask_is_always_zero(phase, add1, mask, bt, false)) {\n-        set_req_X(addidx, add2, phase);\n-        return this;\n-      } else if (AndIL_shift_and_mask_is_always_zero(phase, add2, mask, bt, false)) {\n-        set_req_X(addidx, add1, phase);\n-        return this;\n-      }\n+    if (AndIL_is_zero_element_under_mask(phase, add1, mask, bt)) {\n+      set_req_X(addidx, add2, phase);\n+      return this;\n+    } else if (AndIL_is_zero_element_under_mask(phase, add2, mask, bt)) {\n+      set_req_X(addidx, add1, phase);\n+      return this;\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":104,"deletions":94,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-  static bool AndIL_shift_and_mask_is_always_zero(PhaseGVN* phase, Node* shift, Node* mask, BasicType bt, bool check_reverse);\n-  Node* AndIL_add_shift_and_mask(PhaseGVN* phase, BasicType bt);\n+protected:\n+  Node* AndIL_sum_and_mask(PhaseGVN* phase, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2025, Red Hat, Inc. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @bug 8277850 8278949 8285793\n+ * @bug 8277850 8278949 8285793 8346664\n@@ -46,0 +46,37 @@\n+    \/\/ any X << INT_MASK_WIDTH is zero under any INT_MASK\n+    static final int INT_MASK_WIDTH = 1 + RANDOM.nextInt(30);\n+    static final int INT_MAX_MASK = (1 << INT_MASK_WIDTH) - 1;\n+    static final int INT_MASK = 1 + RANDOM.nextInt(INT_MAX_MASK);\n+    static final int INT_MASK2 = 1 + RANDOM.nextInt(INT_MAX_MASK);\n+    static final int INT_ZERO_CONST = RANDOM.nextInt() << INT_MASK_WIDTH;\n+\n+    static final int INT_RANDOM_CONST = RANDOM.nextInt();\n+    static final int INT_RANDOM_SHIFT = RANDOM.nextInt();\n+    static final int INT_RANDOM_MASK = RANDOM.nextInt();\n+\n+    \/\/ any X << LONG_MASK_WIDTH is zero under any LONG_MASK\n+    static final int LONG_MASK_WIDTH = 1 + RANDOM.nextInt(62);\n+    static final long LONG_MAX_MASK = (1L << LONG_MASK_WIDTH) - 1;\n+    static final long LONG_MASK = 1 + RANDOM.nextLong(LONG_MAX_MASK);\n+    static final long LONG_MASK2 = 1 + RANDOM.nextLong(LONG_MAX_MASK);\n+    static final long LONG_ZERO_CONST = RANDOM.nextLong() << LONG_MASK_WIDTH;\n+\n+    static final long LONG_RANDOM_CONST = RANDOM.nextLong();\n+    static final long LONG_RANDOM_SHIFT = RANDOM.nextLong();\n+    static final long LONG_RANDOM_MASK = RANDOM.nextLong();\n+\n+    @Test\n+    public static int intSumAndMask(int i, int j) {\n+        return (j + i << INT_RANDOM_SHIFT + INT_RANDOM_CONST) & INT_RANDOM_MASK;\n+    }\n+\n+    @Run(test = { \"intSumAndMask\" })\n+    public static void checkIntSumAndMask() {\n+        int j = RANDOM.nextInt();\n+        int i = RANDOM.nextInt();\n+        int res = intSumAndMask(i, j);\n+        if (res != ((j + i << INT_RANDOM_SHIFT + INT_RANDOM_CONST) & INT_RANDOM_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -50,1 +87,1 @@\n-        return (i << 2) & 3; \/\/ transformed to: return 0;\n+        return (i << INT_MASK_WIDTH) & INT_MASK; \/\/ transformed to: return 0;\n@@ -60,0 +97,15 @@\n+    @Test\n+    public static long longSumAndMask(long i, long j) {\n+        return (j + i << LONG_RANDOM_SHIFT + LONG_RANDOM_CONST) & LONG_RANDOM_MASK;\n+    }\n+\n+    @Run(test = { \"longSumAndMask\" })\n+    public static void checkLongSumAndMask() {\n+        long j = RANDOM.nextLong();\n+        long i = RANDOM.nextLong();\n+        long res = longSumAndMask(i, j);\n+        if (res != ((j + i << LONG_RANDOM_SHIFT + LONG_RANDOM_CONST) & LONG_RANDOM_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -64,1 +116,1 @@\n-        return (i << 2) & 3; \/\/ transformed to: return 0;\n+        return (i << LONG_MASK_WIDTH) & LONG_MASK; \/\/ transformed to: return 0;\n@@ -84,1 +136,1 @@\n-            mask = 3;\n+            mask = INT_MASK;\n@@ -86,1 +138,1 @@\n-            mask = 1;\n+            mask = INT_MASK2;\n@@ -88,1 +140,1 @@\n-        return mask & (i << 2); \/\/ transformed to: return 0;\n+        return mask & (i << INT_MASK_WIDTH); \/\/ transformed to: return 0;\n@@ -105,1 +157,1 @@\n-            mask = 3;\n+            mask = LONG_MASK;\n@@ -107,1 +159,1 @@\n-            mask = 1;\n+            mask = LONG_MASK2;\n@@ -109,1 +161,1 @@\n-        return mask & (i << 2); \/\/ transformed to: return 0;\n+        return mask & (i << LONG_MASK_WIDTH); \/\/ transformed to: return 0;\n@@ -123,1 +175,1 @@\n-        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -131,1 +183,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -136,0 +188,31 @@\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I, IRNode.LSHIFT_I })\n+    public static int addShiftPlusConstMaskInt(int i, int j) {\n+        return (j + ((i + INT_RANDOM_CONST) << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n+    }\n+\n+    @Run(test = \"addShiftPlusConstMaskInt\")\n+    public static void addShiftPlusConstMaskInt_runner() {\n+        int i = RANDOM.nextInt();\n+        int j = RANDOM.nextInt();\n+        int res = addShiftPlusConstMaskInt(i, j);\n+        if (res != (j & INT_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"2\", IRNode.LSHIFT_I, \"1\" })\n+    public static int addShiftPlusConstDisjointMaskInt(int i, int j) {\n+        return (j + ((i + 5) << 2)) & 32; \/\/ NOT transformed even though (5<<2) & 32 == 0\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    public static int addShiftPlusConstOverlyLargeShift(int i, int j) {\n+        return (j + i << 129) & 32; \/\/ NOT transformed, only lower 5 bits of shift count.\n+    }\n+\n@@ -143,1 +226,1 @@\n-            mask = 3;\n+            mask = INT_MASK;\n@@ -145,1 +228,1 @@\n-            mask = 1;\n+            mask = INT_MASK2;\n@@ -147,1 +230,1 @@\n-        return mask & (j + (i << 2)); \/\/ transformed to: return j & mask;\n+        return mask & (j + (i << INT_MASK_WIDTH)); \/\/ transformed to: return j & mask;\n@@ -155,1 +238,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -159,1 +242,28 @@\n-        if (res != (j & 1)) {\n+        if (res != (j & INT_MASK2)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I })\n+    public static int addConstNonConstMaskInt(int j, boolean flag) {\n+        int mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = INT_MASK;\n+        } else {\n+            mask = INT_MASK2;\n+        }\n+        return mask & (j + INT_ZERO_CONST); \/\/ transformed to: return j & mask;\n+    }\n+\n+    @Run(test = \"addConstNonConstMaskInt\")\n+    public static void addConstNonConstMaskInt_runner() {\n+        int j = RANDOM.nextInt();\n+        int res = addConstNonConstMaskInt(j, true);\n+        if (res != (j & INT_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+        res = addConstNonConstMaskInt(j, false);\n+        if (res != (j & INT_MASK2)) {\n@@ -168,1 +278,1 @@\n-        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + (i << LONG_MASK_WIDTH)) & LONG_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -176,1 +286,18 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & LONG_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L, IRNode.LSHIFT_L })\n+    public static long addShiftPlusConstMaskLong(long i, long j) {\n+        return (j + ((i + LONG_RANDOM_CONST) << LONG_MASK_WIDTH)) & LONG_MASK; \/\/ transformed to: return j & LONG_MASK;\n+    }\n+\n+    @Run(test = \"addShiftPlusConstMaskLong\")\n+    public static void addShiftPlusConstMaskLong_runner() {\n+        long i = RANDOM.nextLong();\n+        long j = RANDOM.nextLong();\n+        long res = addShiftPlusConstMaskLong(i, j);\n+        if (res != (j & LONG_MASK)) {\n@@ -185,1 +312,1 @@\n-        int mask;\n+        long mask;\n@@ -188,1 +315,1 @@\n-            mask = 3;\n+            mask = LONG_MASK;\n@@ -190,1 +317,1 @@\n-            mask = 1;\n+            mask = LONG_MASK2;\n@@ -192,1 +319,1 @@\n-        return mask & (j + (i << 2)); \/\/ transformed to: return j & mask;\n+        return mask & (j + (i << LONG_MASK_WIDTH)); \/\/ transformed to: return j & mask\n@@ -200,1 +327,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & LONG_MASK)) {\n@@ -204,1 +331,28 @@\n-        if (res != (j & 1)) {\n+        if (res != (j & LONG_MASK2)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L })\n+    public static long addConstNonConstMaskLong(long j, boolean flag) {\n+        long mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = LONG_MASK;\n+        } else {\n+            mask = LONG_MASK2;\n+        }\n+        return mask & (j + LONG_ZERO_CONST); \/\/ transformed to: return j & mask;\n+    }\n+\n+    @Run(test = \"addConstNonConstMaskLong\")\n+    public static void addConstNonConstMaskLong_runner() {\n+        long j = RANDOM.nextLong();\n+        long res = addConstNonConstMaskLong(j, true);\n+        if (res != (j & LONG_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+        res = addConstNonConstMaskLong(j, false);\n+        if (res != (j & LONG_MASK2)) {\n@@ -213,1 +367,1 @@\n-        return ((j << 2) + (i << 2)) & 3; \/\/ transformed to: return 0;\n+        return ((j << INT_MASK_WIDTH) + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -227,1 +381,1 @@\n-        return ((j << 2) + (i << 2)) & 3; \/\/ transformed to: return 0;\n+        return ((j << INT_MASK_WIDTH) + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -242,1 +396,1 @@\n-        int add1 = (i << 2);\n+        int add1 = (i << INT_MASK_WIDTH);\n@@ -244,1 +398,1 @@\n-        return (add1 + add2) & 3; \/\/ transformed to: return j & 3;\n+        return (add1 + add2) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -252,1 +406,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -261,1 +415,1 @@\n-        long add1 = (i << 2);\n+        long add1 = (i << LONG_MASK_WIDTH);\n@@ -263,1 +417,1 @@\n-        return (add1 + add2) & 3; \/\/ transformed to: return j & 3;\n+        return (add1 + add2) & LONG_MASK; \/\/ transformed to: return j & LONG_MASK;\n@@ -271,1 +425,1 @@\n-        if (res != (((long)j) & 3)) {\n+        if (res != (((long) j) & LONG_MASK)) {\n@@ -280,1 +434,1 @@\n-        return ((long)(i << 2)) & 3; \/\/ transformed to: return 0;\n+        return ((long) (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -297,1 +451,1 @@\n-            mask = 3;\n+            mask = INT_MASK;\n@@ -299,1 +453,1 @@\n-            mask = 1;\n+            mask = INT_MASK2;\n@@ -301,1 +455,1 @@\n-        return mask & ((long)(i << 2)); \/\/ transformed to: return 0;\n+        return mask & ((long) (i << INT_MASK_WIDTH)); \/\/ transformed to: return 0;\n@@ -315,1 +469,1 @@\n-        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -323,1 +477,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -332,1 +486,1 @@\n-        return (((long)(j << 2)) + ((long)(i << 2))) & 3; \/\/ transformed to: return 0;\n+        return (((long) (j << INT_MASK_WIDTH)) + ((long) (i << INT_MASK_WIDTH))) & INT_MASK; \/\/ transformed to: return 0;\n@@ -345,1 +499,1 @@\n-        return Objects.checkIndex(i << 2, length) & 3; \/\/ transformed to: return 0;\n+        return Objects.checkIndex(i << INT_MASK_WIDTH, length) & INT_MASK; \/\/ transformed to: return 0;\n@@ -350,2 +504,2 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int res = shiftMaskIntCheckIndex(i, (i << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int res = shiftMaskIntCheckIndex(i, (i << INT_MASK_WIDTH) + 1);\n@@ -360,1 +514,1 @@\n-        return Objects.checkIndex(i << 2, length) & 3; \/\/ transformed to: return 0;\n+        return Objects.checkIndex(i << LONG_MASK_WIDTH, length) & LONG_MASK; \/\/ transformed to: return 0;\n@@ -365,2 +519,2 @@\n-        long i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = shiftMaskLongCheckIndex(i, (i << 2) + 1);\n+        long i = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n+        long res = shiftMaskLongCheckIndex(i, (i << LONG_MASK_WIDTH) + 1);\n@@ -376,1 +530,1 @@\n-        return (j + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -381,1 +535,1 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n@@ -383,2 +537,2 @@\n-        int res = addShiftMaskIntCheckIndex(i, j, (i << 2) + 1);\n-        if (res != (j & 3)) {\n+        int res = addShiftMaskIntCheckIndex(i, j, (i << INT_MASK_WIDTH) + 1);\n+        if (res != (j & INT_MASK)) {\n@@ -393,1 +547,1 @@\n-        return (j + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + Objects.checkIndex(i << LONG_MASK_WIDTH, length)) & LONG_MASK; \/\/ transformed to: return j & LONG_MASK;\n@@ -398,1 +552,1 @@\n-        long i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n+        long i = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n@@ -400,2 +554,2 @@\n-        long res = addShiftMaskLongCheckIndex(i, j, (i << 2) + 1);\n-        if (res != (j & 3)) {\n+        long res = addShiftMaskLongCheckIndex(i, j, (i << LONG_MASK_WIDTH) + 1);\n+        if (res != (j & LONG_MASK)) {\n@@ -409,1 +563,1 @@\n-        return (Objects.checkIndex(j << 2, length) + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return 0;\n+        return (Objects.checkIndex(j << INT_MASK_WIDTH, length) + Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -415,3 +569,3 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int res = addShiftMaskIntCheckIndex2(i, j, (Integer.max(i, j) << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int res = addShiftMaskIntCheckIndex2(i, j, (Integer.max(i, j) << INT_MASK_WIDTH) + 1);\n@@ -426,1 +580,1 @@\n-        return (Objects.checkIndex(j << 2, length) + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return 0;\n+        return (Objects.checkIndex(j << LONG_MASK_WIDTH, length) + Objects.checkIndex(i << LONG_MASK_WIDTH, length)) & LONG_MASK; \/\/ transformed to: return 0;\n@@ -431,3 +585,3 @@\n-        long i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = addShiftMaskLongCheckIndex2(i, j, (Long.max(i, j) << 2) + 1);\n+        long i = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n+        long j = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n+        long res = addShiftMaskLongCheckIndex2(i, j, (Long.max(i, j) << LONG_MASK_WIDTH) + 1);\n@@ -442,1 +596,1 @@\n-        return ((long)Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return 0;\n+        return ((long) Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -447,2 +601,2 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = shiftConvMaskCheckIndex(i, (i << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        long res = shiftConvMaskCheckIndex(i, (i << INT_MASK_WIDTH) + 1);\n@@ -458,1 +612,1 @@\n-        return (j + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -463,1 +617,1 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n@@ -465,2 +619,2 @@\n-        long res = addShiftConvMaskCheckIndex(i, j, (i << 2) + 1);\n-        if (res != (j & 3)) {\n+        long res = addShiftConvMaskCheckIndex(i, j, (i << INT_MASK_WIDTH) + 1);\n+        if (res != (j & INT_MASK)) {\n@@ -474,1 +628,1 @@\n-        return (((long)Objects.checkIndex(j << 2, length)) + ((long)Objects.checkIndex(i << 2, length))) & 3; \/\/ transformed to: return 0;\n+        return (((long) Objects.checkIndex(j << INT_MASK_WIDTH, length)) + ((long) Objects.checkIndex(i << INT_MASK_WIDTH, length))) & INT_MASK; \/\/ transformed to: return 0;\n@@ -479,3 +633,3 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = addShiftConvMaskCheckIndex2(i, j, (Integer.max(i, j) << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        long res = addShiftConvMaskCheckIndex2(i, j, (Integer.max(i, j) << INT_MASK_WIDTH) + 1);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java","additions":227,"deletions":73,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          MemorySegment data = MemorySegment.ofArray(aL.clone());\n@@ -179,0 +179,4 @@\n+        tests.put(\"testMemorySegmentIInvarL3g\", () -> {\n+          MemorySegment data = MemorySegment.ofArray(aI.clone());\n+          return testMemorySegmentIInvarL3g(data, 1, 2, 3, RANGE-200);\n+        });\n@@ -249,0 +253,1 @@\n+                 \"testMemorySegmentIInvarL3g\",\n@@ -684,0 +689,5 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -687,0 +697,1 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n@@ -688,2 +699,1 @@\n-    \/\/ Would be nice if it vectorized.\n-    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    \/\/ With AlignVector (strict alignment requirements): we cannot prove that the invariants are alignable -> no vectorization.\n@@ -703,0 +713,5 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -706,0 +721,1 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n@@ -707,2 +723,1 @@\n-    \/\/ Would be nice if it vectorized.\n-    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    \/\/ With AlignVector (strict alignment requirements): we cannot prove that the invariants are alignable -> no vectorization.\n@@ -738,0 +753,25 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ With AlignVector (strict alignment requirements): we cannot prove that the invariants are alignable -> no vectorization.\n+    static Object[] testMemorySegmentIInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+        long i1 = (long)(-invar1 + invar2 + invar3);\n+        long i2 = (long)(invar2 + invar3) - (long)(invar1); \/\/ not equivalent\n+        for (int i = 0; i < size; i+=2) {\n+            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 0);\n+            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + i2 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 0, v0 + 1);\n+            m.setAtIndex(ValueLayout.JAVA_INT, i + i2 + 1, v1 + 1);\n+        }\n+        return new Object[]{ m };\n+    }\n+\n+    \/\/ Same as testMemorySegmentIInvarL3e, but with long[] input.\n@@ -746,1 +786,1 @@\n-    static Object[] testMemorySegmentIInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentIInvarL3f(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n@@ -765,1 +805,1 @@\n-    static Object[] testMemorySegmentIInvarL3f(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n+    static Object[] testMemorySegmentIInvarL3g(MemorySegment m, long invar1, long invar2, long invar3, int size) {\n@@ -828,0 +868,5 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -831,0 +876,1 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n@@ -832,2 +878,1 @@\n-    \/\/ Would be nice if it vectorized.\n-    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    \/\/ With AlignVector (strict alignment requirements): we cannot prove that the invariants are alignable -> no vectorization.\n@@ -847,0 +892,5 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -850,0 +900,1 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n@@ -851,2 +902,1 @@\n-    \/\/ Would be nice if it vectorized.\n-    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    \/\/ With AlignVector (strict alignment requirements): we cannot prove that the invariants are alignable -> no vectorization.\n@@ -883,0 +933,5 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -886,0 +941,1 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n@@ -887,1 +943,1 @@\n-    \/\/ FAILS: should be ok to vectorize, but does not. Investigate in JDK-8331659.\n+    \/\/ With AlignVector (strict alignment requirements): we cannot prove that the invariants are alignable -> no vectorization.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java","additions":68,"deletions":12,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-    @IR(counts = {IRNode.POPULATE_INDEX, \"> 0\"})\n+    \/\/ Does not vectorize, possibly because the OrI is pushed through the Phi, see also JDK-8348096.\n@@ -84,1 +84,1 @@\n-            dst[i] = src[i] * (i & 7);\n+            dst[i] = src[i] * (i | 7);\n@@ -91,1 +91,1 @@\n-            int expected = src[i] * (i & 7);\n+            int expected = src[i] * (i | 7);\n@@ -115,0 +115,22 @@\n+\n+    @Test\n+    \/\/ Does not vectorize: due to sum-under-mask optimization.\n+    \/\/ (i+0) & 7, (i+1) & 7 ... (i+8) & 7 ....  -> PopulateIndex\n+    \/\/ becomes\n+    \/\/ (i+0) & 7, (i+1) & 7 ... (i+0) & 7 .... -> pattern broken\n+    \/\/ See JDK-8349128.\n+    public void exprWithIndex3() {\n+        for (int i = 0; i < count; i++) {\n+            dst[i] = src[i] * (i & 7);\n+        }\n+        checkResultExprWithIndex3();\n+    }\n+\n+    public void checkResultExprWithIndex3() {\n+        for (int i = 0; i < count; i++) {\n+            int expected = src[i] * (i & 7);\n+            if (dst[i] != expected) {\n+                throw new RuntimeException(\"Invalid result: dst[\" + i + \"] = \" + dst[i] + \" != \" + expected);\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopulateIndex.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"}]}