{"files":[{"patch":"@@ -672,0 +672,2 @@\n+static bool AndIL_is_zero_element_under_mask(const PhaseGVN* phase, const Node* expr, const Node* mask, BasicType bt);\n+\n@@ -673,2 +675,2 @@\n-  \/\/ patterns similar to (v << 2) & 3\n-  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_INT, true)) {\n+  if (AndIL_is_zero_element_under_mask(phase, in(1), in(2), T_INT) ||\n+      AndIL_is_zero_element_under_mask(phase, in(2), in(1), T_INT)) {\n@@ -720,2 +722,2 @@\n-  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-  Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n+  \/\/ Simplify (v1 + v2) & mask to v1 & mask or v2 & mask when possible.\n+  Node* progress = AndIL_sum_and_mask(phase, T_INT);\n@@ -804,2 +806,2 @@\n-  \/\/ patterns similar to (v << 2) & 3\n-  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_LONG, true)) {\n+  if (AndIL_is_zero_element_under_mask(phase, in(1), in(2), T_LONG) ||\n+      AndIL_is_zero_element_under_mask(phase, in(2), in(1), T_LONG)) {\n@@ -852,2 +854,2 @@\n-  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-  Node* progress = AndIL_add_shift_and_mask(phase, T_LONG);\n+  \/\/ Simplify (v1 + v2) & mask to v1 & mask or v2 & mask when possible.\n+  Node* progress = AndIL_sum_and_mask(phase, T_LONG);\n@@ -2054,24 +2056,9 @@\n-\/\/ Given an expression (AndX shift mask) or (AndX mask shift),\n-\/\/ determine if the AndX must always produce zero, because the\n-\/\/ the shift (x<<N) is bitwise disjoint from the mask #M.\n-\/\/ The X in AndX must be I or L, depending on bt.\n-\/\/ Specifically, the following cases fold to zero,\n-\/\/ when the shift value N is large enough to zero out\n-\/\/ all the set positions of the and-mask M.\n-\/\/   (AndI (LShiftI _ #N) #M) => #0\n-\/\/   (AndL (LShiftL _ #N) #M) => #0\n-\/\/   (AndL (ConvI2L (LShiftI _ #N)) #M) => #0\n-\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n-\/\/ Because the optimization might work for a non-constant\n-\/\/ mask M, we check the AndX for both operand orders.\n-bool MulNode::AndIL_shift_and_mask_is_always_zero(PhaseGVN* phase, Node* shift, Node* mask, BasicType bt, bool check_reverse) {\n-  if (mask == nullptr || shift == nullptr) {\n-    return false;\n-  }\n-  const TypeInteger* mask_t = phase->type(mask)->isa_integer(bt);\n-  if (mask_t == nullptr || phase->type(shift)->isa_integer(bt) == nullptr) {\n-    return false;\n-  }\n-  shift = shift->uncast();\n-  if (shift == nullptr) {\n-    return false;\n+\/\/------------------------------ Sum & Mask ------------------------------\n+\n+\/\/ Returns a lower bound on the number of trailing zeros in expr, or -1 if the number\n+\/\/ cannot be determined.\n+static jint AndIL_min_trailing_zeros(const PhaseGVN* phase, const Node* expr, BasicType bt) {\n+  expr = expr->uncast();\n+  const TypeInteger* type = phase->type(expr)->isa_integer(bt);\n+  if (type == nullptr) {\n+    return -1;\n@@ -2079,2 +2066,4 @@\n-  if (phase->type(shift)->isa_integer(bt) == nullptr) {\n-    return false;\n+\n+  if (type->is_con()) {\n+    long con = type->get_con_as_long(bt);\n+    return con == 0L ? (type2aelembytes(bt) * BitsPerByte) : count_trailing_zeros(con);\n@@ -2082,2 +2071,3 @@\n-  BasicType shift_bt = bt;\n-  if (bt == T_LONG && shift->Opcode() == Op_ConvI2L) {\n+\n+  if (expr->Opcode() == Op_ConvI2L) {\n+    expr = expr->in(1)->uncast();\n@@ -2085,15 +2075,1 @@\n-    Node* val = shift->in(1);\n-    if (val == nullptr) {\n-      return false;\n-    }\n-    val = val->uncast();\n-    if (val == nullptr) {\n-      return false;\n-    }\n-    if (val->Opcode() == Op_LShiftI) {\n-      shift_bt = T_INT;\n-      shift = val;\n-      if (phase->type(shift)->isa_integer(bt) == nullptr) {\n-        return false;\n-      }\n-    }\n+    type = phase->type(expr)->isa_int();\n@@ -2101,6 +2077,5 @@\n-  if (shift->Opcode() != Op_LShift(shift_bt)) {\n-    if (check_reverse &&\n-        (mask->Opcode() == Op_LShift(bt) ||\n-         (bt == T_LONG && mask->Opcode() == Op_ConvI2L))) {\n-      \/\/ try it the other way around\n-      return AndIL_shift_and_mask_is_always_zero(phase, mask, shift, bt, false);\n+\n+  if (expr->Opcode() == Op_LShift(bt)) {\n+    const TypeInt* rhs_t = phase->type(expr->in(2))->isa_int();\n+    if (rhs_t == nullptr || !rhs_t->is_con()) {\n+      return -1;\n@@ -2108,5 +2083,1 @@\n-    return false;\n-  }\n-  Node* shift2 = shift->in(2);\n-  if (shift2 == nullptr) {\n-    return false;\n+    return rhs_t->get_con() & (type2aelembytes(bt) * BitsPerByte - 1);\n@@ -2114,2 +2085,20 @@\n-  const Type* shift2_t = phase->type(shift2);\n-  if (!shift2_t->isa_int() || !shift2_t->is_int()->is_con()) {\n+\n+  return -1;\n+}\n+\n+\/\/ Checks whether expr is neutral wrt addition under mask, i.e.\n+\/\/ an expression of the form (AndX (T+expr) mask) can be simplified to (AndX T mask).\n+\/\/ The X in AndX must be I or L, depending on bt.\n+\/\/ Specifically, this holds for the following cases,\n+\/\/ when the shift value N is large enough to zero out\n+\/\/ all the set positions of the and-mask M:\n+\/\/   (AndI (LShiftI _ #N) #M)\n+\/\/   (AndL (LShiftL _ #N) #M)\n+\/\/   (AndL (ConvI2L (LShiftI _ #N)) #M)\n+\/\/ including equivalent constant operands:\n+\/\/   (AndI (ConI (_ << #N)) #M)\n+\/\/   (AndL (ConL (_ << #N)) #M)\n+\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n+static bool AndIL_is_zero_element_under_mask(const PhaseGVN* phase, const Node* expr, const Node* mask, BasicType bt) {\n+  jint expr_trailing_zeros = AndIL_min_trailing_zeros(phase, expr, bt);\n+  if (expr_trailing_zeros < 0) {\n@@ -2119,3 +2108,3 @@\n-  jint shift_con = shift2_t->is_int()->get_con() & ((shift_bt == T_INT ? BitsPerJavaInteger : BitsPerJavaLong) - 1);\n-  if ((((jlong)1) << shift_con) > mask_t->hi_as_long() && mask_t->lo_as_long() >= 0) {\n-    return true;\n+  const TypeInteger* mask_t = phase->type(mask)->isa_integer(bt);\n+  if (mask_t == nullptr || mask_t->lo_as_long() < 0) {\n+    return false;\n@@ -2124,1 +2113,2 @@\n-  return false;\n+  jint mask_bit_width = mask_t->hi_as_long() == 0 ? 0 : (BitsPerLong - count_leading_zeros(mask_t->hi_as_long()));\n+  return expr_trailing_zeros >= mask_bit_width;\n@@ -2127,15 +2117,6 @@\n-\/\/ Given an expression (AndX (AddX v1 (LShiftX v2 #N)) #M)\n-\/\/ determine if the AndX must always produce (AndX v1 #M),\n-\/\/ because the shift (v2<<N) is bitwise disjoint from the mask #M.\n-\/\/ The X in AndX will be I or L, depending on bt.\n-\/\/ Specifically, the following cases fold,\n-\/\/ when the shift value N is large enough to zero out\n-\/\/ all the set positions of the and-mask M.\n-\/\/   (AndI (AddI v1 (LShiftI _ #N)) #M) => (AndI v1 #M)\n-\/\/   (AndL (AddI v1 (LShiftL _ #N)) #M) => (AndL v1 #M)\n-\/\/   (AndL (AddL v1 (ConvI2L (LShiftI _ #N))) #M) => (AndL v1 #M)\n-\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n-\/\/ Because the optimization might work for a non-constant\n-\/\/ mask M, and because the AddX operands can come in either\n-\/\/ order, we check for every operand order.\n-Node* MulNode::AndIL_add_shift_and_mask(PhaseGVN* phase, BasicType bt) {\n+\/\/ Given an expression (AndX (AddX v1 v2) mask)\n+\/\/ determine if the AndX must always produce (AndX v1 mask),\n+\/\/ because v2 is zero wrt addition under mask.\n+\/\/ Because the AddX operands can come in either\n+\/\/ order, we check for both orders.\n+Node* MulNode::AndIL_sum_and_mask(PhaseGVN* phase, BasicType bt) {\n@@ -2144,3 +2125,0 @@\n-  if (add == nullptr || mask == nullptr) {\n-    return nullptr;\n-  }\n@@ -2158,8 +2136,6 @@\n-    if (add1 != nullptr && add2 != nullptr) {\n-      if (AndIL_shift_and_mask_is_always_zero(phase, add1, mask, bt, false)) {\n-        set_req_X(addidx, add2, phase);\n-        return this;\n-      } else if (AndIL_shift_and_mask_is_always_zero(phase, add2, mask, bt, false)) {\n-        set_req_X(addidx, add1, phase);\n-        return this;\n-      }\n+    if (AndIL_is_zero_element_under_mask(phase, add1, mask, bt)) {\n+      set_req_X(addidx, add2, phase);\n+      return this;\n+    } else if (AndIL_is_zero_element_under_mask(phase, add2, mask, bt)) {\n+      set_req_X(addidx, add1, phase);\n+      return this;\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":70,"deletions":94,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-  static bool AndIL_shift_and_mask_is_always_zero(PhaseGVN* phase, Node* shift, Node* mask, BasicType bt, bool check_reverse);\n-  Node* AndIL_add_shift_and_mask(PhaseGVN* phase, BasicType bt);\n+protected:\n+  Node* AndIL_sum_and_mask(PhaseGVN* phase, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2025, Red Hat, Inc. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @bug 8277850 8278949 8285793\n+ * @bug 8277850 8278949 8285793 8346664\n@@ -46,0 +46,37 @@\n+    \/\/ any X << INT_MASK_WIDTH is zero under any INT_MASK\n+    static final int INT_MASK_WIDTH = 1 + RANDOM.nextInt(30);\n+    static final int INT_MAX_MASK = (1 << INT_MASK_WIDTH) - 1;\n+    static final int INT_MASK = 1 + RANDOM.nextInt(INT_MAX_MASK);\n+    static final int INT_MASK2 = 1 + RANDOM.nextInt(INT_MAX_MASK);\n+    static final int INT_ZERO_CONST = RANDOM.nextInt() << INT_MASK_WIDTH;\n+\n+    static final int INT_RANDOM_CONST = RANDOM.nextInt();\n+    static final int INT_RANDOM_SHIFT = RANDOM.nextInt();\n+    static final int INT_RANDOM_MASK = RANDOM.nextInt();\n+\n+    \/\/ any X << LONG_MASK_WIDTH is zero under any LONG_MASK\n+    static final int LONG_MASK_WIDTH = 1 + RANDOM.nextInt(62);\n+    static final long LONG_MAX_MASK = (1L << LONG_MASK_WIDTH) - 1;\n+    static final long LONG_MASK = 1 + RANDOM.nextLong(LONG_MAX_MASK);\n+    static final long LONG_MASK2 = 1 + RANDOM.nextLong(LONG_MAX_MASK);\n+    static final long LONG_ZERO_CONST = RANDOM.nextLong() << LONG_MASK_WIDTH;\n+\n+    static final long LONG_RANDOM_CONST = RANDOM.nextLong();\n+    static final long LONG_RANDOM_SHIFT = RANDOM.nextLong();\n+    static final long LONG_RANDOM_MASK = RANDOM.nextLong();\n+\n+    @Test\n+    public static int intSumAndMask(int i, int j) {\n+        return (j + i << INT_RANDOM_SHIFT + INT_RANDOM_CONST) & INT_RANDOM_MASK;\n+    }\n+\n+    @Run(test = { \"intSumAndMask\" })\n+    public static void checkIntSumAndMask() {\n+        int j = RANDOM.nextInt();\n+        int i = RANDOM.nextInt();\n+        int res = intSumAndMask(i, j);\n+        if (res != ((j + i << INT_RANDOM_SHIFT + INT_RANDOM_CONST) & INT_RANDOM_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -50,1 +87,1 @@\n-        return (i << 2) & 3; \/\/ transformed to: return 0;\n+        return (i << INT_MASK_WIDTH) & INT_MASK; \/\/ transformed to: return 0;\n@@ -60,0 +97,15 @@\n+    @Test\n+    public static long longSumAndMask(long i, long j) {\n+        return (j + i << LONG_RANDOM_SHIFT + LONG_RANDOM_CONST) & LONG_RANDOM_MASK;\n+    }\n+\n+    @Run(test = { \"longSumAndMask\" })\n+    public static void checkLongSumAndMask() {\n+        long j = RANDOM.nextLong();\n+        long i = RANDOM.nextLong();\n+        long res = longSumAndMask(i, j);\n+        if (res != ((j + i << LONG_RANDOM_SHIFT + LONG_RANDOM_CONST) & LONG_RANDOM_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -64,1 +116,1 @@\n-        return (i << 2) & 3; \/\/ transformed to: return 0;\n+        return (i << LONG_MASK_WIDTH) & LONG_MASK; \/\/ transformed to: return 0;\n@@ -84,1 +136,1 @@\n-            mask = 3;\n+            mask = INT_MASK;\n@@ -86,1 +138,1 @@\n-            mask = 1;\n+            mask = INT_MASK2;\n@@ -88,1 +140,1 @@\n-        return mask & (i << 2); \/\/ transformed to: return 0;\n+        return mask & (i << INT_MASK_WIDTH); \/\/ transformed to: return 0;\n@@ -105,1 +157,1 @@\n-            mask = 3;\n+            mask = LONG_MASK;\n@@ -107,1 +159,1 @@\n-            mask = 1;\n+            mask = LONG_MASK2;\n@@ -109,1 +161,1 @@\n-        return mask & (i << 2); \/\/ transformed to: return 0;\n+        return mask & (i << LONG_MASK_WIDTH); \/\/ transformed to: return 0;\n@@ -123,1 +175,1 @@\n-        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -131,1 +183,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -136,0 +188,31 @@\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I, IRNode.LSHIFT_I })\n+    public static int addShiftPlusConstMaskInt(int i, int j) {\n+        return (j + ((i + INT_RANDOM_CONST) << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n+    }\n+\n+    @Run(test = \"addShiftPlusConstMaskInt\")\n+    public static void addShiftPlusConstMaskInt_runner() {\n+        int i = RANDOM.nextInt();\n+        int j = RANDOM.nextInt();\n+        int res = addShiftPlusConstMaskInt(i, j);\n+        if (res != (j & INT_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"2\", IRNode.LSHIFT_I, \"1\" })\n+    public static int addShiftPlusConstDisjointMaskInt(int i, int j) {\n+        return (j + ((i + 5) << 2)) & 32; \/\/ NOT transformed even though (5<<2) & 32 == 0\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    public static int addShiftPlusConstOverlyLargeShift(int i, int j) {\n+        return (j + i << 129) & 32; \/\/ NOT transformed, only lower 5 bits of shift count.\n+    }\n+\n@@ -143,1 +226,1 @@\n-            mask = 3;\n+            mask = INT_MASK;\n@@ -145,1 +228,1 @@\n-            mask = 1;\n+            mask = INT_MASK2;\n@@ -147,1 +230,1 @@\n-        return mask & (j + (i << 2)); \/\/ transformed to: return j & mask;\n+        return mask & (j + (i << INT_MASK_WIDTH)); \/\/ transformed to: return j & mask;\n@@ -155,1 +238,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -159,1 +242,28 @@\n-        if (res != (j & 1)) {\n+        if (res != (j & INT_MASK2)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I })\n+    public static int addConstNonConstMaskInt(int j, boolean flag) {\n+        int mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = INT_MASK;\n+        } else {\n+            mask = INT_MASK2;\n+        }\n+        return mask & (j + INT_ZERO_CONST); \/\/ transformed to: return j & mask;\n+    }\n+\n+    @Run(test = \"addConstNonConstMaskInt\")\n+    public static void addConstNonConstMaskInt_runner() {\n+        int j = RANDOM.nextInt();\n+        int res = addConstNonConstMaskInt(j, true);\n+        if (res != (j & INT_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+        res = addConstNonConstMaskInt(j, false);\n+        if (res != (j & INT_MASK2)) {\n@@ -168,1 +278,1 @@\n-        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + (i << LONG_MASK_WIDTH)) & LONG_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -176,1 +286,18 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & LONG_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L, IRNode.LSHIFT_L })\n+    public static long addShiftPlusConstMaskLong(long i, long j) {\n+        return (j + ((i + LONG_RANDOM_CONST) << LONG_MASK_WIDTH)) & LONG_MASK; \/\/ transformed to: return j & LONG_MASK;\n+    }\n+\n+    @Run(test = \"addShiftPlusConstMaskLong\")\n+    public static void addShiftPlusConstMaskLong_runner() {\n+        long i = RANDOM.nextLong();\n+        long j = RANDOM.nextLong();\n+        long res = addShiftPlusConstMaskLong(i, j);\n+        if (res != (j & LONG_MASK)) {\n@@ -185,1 +312,1 @@\n-        int mask;\n+        long mask;\n@@ -188,1 +315,1 @@\n-            mask = 3;\n+            mask = LONG_MASK;\n@@ -190,1 +317,1 @@\n-            mask = 1;\n+            mask = LONG_MASK2;\n@@ -192,1 +319,1 @@\n-        return mask & (j + (i << 2)); \/\/ transformed to: return j & mask;\n+        return mask & (j + (i << LONG_MASK_WIDTH)); \/\/ transformed to: return j & mask\n@@ -200,1 +327,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & LONG_MASK)) {\n@@ -204,1 +331,28 @@\n-        if (res != (j & 1)) {\n+        if (res != (j & LONG_MASK2)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L })\n+    public static long addConstNonConstMaskLong(long j, boolean flag) {\n+        long mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = LONG_MASK;\n+        } else {\n+            mask = LONG_MASK2;\n+        }\n+        return mask & (j + LONG_ZERO_CONST); \/\/ transformed to: return j & mask;\n+    }\n+\n+    @Run(test = \"addConstNonConstMaskLong\")\n+    public static void addConstNonConstMaskLong_runner() {\n+        long j = RANDOM.nextLong();\n+        long res = addConstNonConstMaskLong(j, true);\n+        if (res != (j & LONG_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+        res = addConstNonConstMaskLong(j, false);\n+        if (res != (j & LONG_MASK2)) {\n@@ -213,1 +367,1 @@\n-        return ((j << 2) + (i << 2)) & 3; \/\/ transformed to: return 0;\n+        return ((j << INT_MASK_WIDTH) + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -227,1 +381,1 @@\n-        return ((j << 2) + (i << 2)) & 3; \/\/ transformed to: return 0;\n+        return ((j << INT_MASK_WIDTH) + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -242,1 +396,1 @@\n-        int add1 = (i << 2);\n+        int add1 = (i << INT_MASK_WIDTH);\n@@ -244,1 +398,1 @@\n-        return (add1 + add2) & 3; \/\/ transformed to: return j & 3;\n+        return (add1 + add2) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -252,1 +406,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -261,1 +415,1 @@\n-        long add1 = (i << 2);\n+        long add1 = (i << LONG_MASK_WIDTH);\n@@ -263,1 +417,1 @@\n-        return (add1 + add2) & 3; \/\/ transformed to: return j & 3;\n+        return (add1 + add2) & LONG_MASK; \/\/ transformed to: return j & LONG_MASK;\n@@ -271,1 +425,1 @@\n-        if (res != (((long)j) & 3)) {\n+        if (res != (((long) j) & LONG_MASK)) {\n@@ -280,1 +434,1 @@\n-        return ((long)(i << 2)) & 3; \/\/ transformed to: return 0;\n+        return ((long) (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -297,1 +451,1 @@\n-            mask = 3;\n+            mask = INT_MASK;\n@@ -299,1 +453,1 @@\n-            mask = 1;\n+            mask = INT_MASK2;\n@@ -301,1 +455,1 @@\n-        return mask & ((long)(i << 2)); \/\/ transformed to: return 0;\n+        return mask & ((long) (i << INT_MASK_WIDTH)); \/\/ transformed to: return 0;\n@@ -315,1 +469,1 @@\n-        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -323,1 +477,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -332,1 +486,1 @@\n-        return (((long)(j << 2)) + ((long)(i << 2))) & 3; \/\/ transformed to: return 0;\n+        return (((long) (j << INT_MASK_WIDTH)) + ((long) (i << INT_MASK_WIDTH))) & INT_MASK; \/\/ transformed to: return 0;\n@@ -345,1 +499,1 @@\n-        return Objects.checkIndex(i << 2, length) & 3; \/\/ transformed to: return 0;\n+        return Objects.checkIndex(i << INT_MASK_WIDTH, length) & INT_MASK; \/\/ transformed to: return 0;\n@@ -350,2 +504,2 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int res = shiftMaskIntCheckIndex(i, (i << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int res = shiftMaskIntCheckIndex(i, (i << INT_MASK_WIDTH) + 1);\n@@ -360,1 +514,1 @@\n-        return Objects.checkIndex(i << 2, length) & 3; \/\/ transformed to: return 0;\n+        return Objects.checkIndex(i << LONG_MASK_WIDTH, length) & LONG_MASK; \/\/ transformed to: return 0;\n@@ -365,2 +519,2 @@\n-        long i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = shiftMaskLongCheckIndex(i, (i << 2) + 1);\n+        long i = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n+        long res = shiftMaskLongCheckIndex(i, (i << LONG_MASK_WIDTH) + 1);\n@@ -376,1 +530,1 @@\n-        return (j + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -381,1 +535,1 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n@@ -383,2 +537,2 @@\n-        int res = addShiftMaskIntCheckIndex(i, j, (i << 2) + 1);\n-        if (res != (j & 3)) {\n+        int res = addShiftMaskIntCheckIndex(i, j, (i << INT_MASK_WIDTH) + 1);\n+        if (res != (j & INT_MASK)) {\n@@ -393,1 +547,1 @@\n-        return (j + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + Objects.checkIndex(i << LONG_MASK_WIDTH, length)) & LONG_MASK; \/\/ transformed to: return j & LONG_MASK;\n@@ -398,1 +552,1 @@\n-        long i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n+        long i = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n@@ -400,2 +554,2 @@\n-        long res = addShiftMaskLongCheckIndex(i, j, (i << 2) + 1);\n-        if (res != (j & 3)) {\n+        long res = addShiftMaskLongCheckIndex(i, j, (i << LONG_MASK_WIDTH) + 1);\n+        if (res != (j & LONG_MASK)) {\n@@ -409,1 +563,1 @@\n-        return (Objects.checkIndex(j << 2, length) + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return 0;\n+        return (Objects.checkIndex(j << INT_MASK_WIDTH, length) + Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -415,3 +569,3 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int res = addShiftMaskIntCheckIndex2(i, j, (Integer.max(i, j) << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int res = addShiftMaskIntCheckIndex2(i, j, (Integer.max(i, j) << INT_MASK_WIDTH) + 1);\n@@ -426,1 +580,1 @@\n-        return (Objects.checkIndex(j << 2, length) + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return 0;\n+        return (Objects.checkIndex(j << LONG_MASK_WIDTH, length) + Objects.checkIndex(i << LONG_MASK_WIDTH, length)) & LONG_MASK; \/\/ transformed to: return 0;\n@@ -431,3 +585,3 @@\n-        long i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = addShiftMaskLongCheckIndex2(i, j, (Long.max(i, j) << 2) + 1);\n+        long i = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n+        long j = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n+        long res = addShiftMaskLongCheckIndex2(i, j, (Long.max(i, j) << LONG_MASK_WIDTH) + 1);\n@@ -442,1 +596,1 @@\n-        return ((long)Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return 0;\n+        return ((long) Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -447,2 +601,2 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = shiftConvMaskCheckIndex(i, (i << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        long res = shiftConvMaskCheckIndex(i, (i << INT_MASK_WIDTH) + 1);\n@@ -458,1 +612,1 @@\n-        return (j + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -463,1 +617,1 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n@@ -465,2 +619,2 @@\n-        long res = addShiftConvMaskCheckIndex(i, j, (i << 2) + 1);\n-        if (res != (j & 3)) {\n+        long res = addShiftConvMaskCheckIndex(i, j, (i << INT_MASK_WIDTH) + 1);\n+        if (res != (j & INT_MASK)) {\n@@ -474,1 +628,1 @@\n-        return (((long)Objects.checkIndex(j << 2, length)) + ((long)Objects.checkIndex(i << 2, length))) & 3; \/\/ transformed to: return 0;\n+        return (((long) Objects.checkIndex(j << INT_MASK_WIDTH, length)) + ((long) Objects.checkIndex(i << INT_MASK_WIDTH, length))) & INT_MASK; \/\/ transformed to: return 0;\n@@ -479,3 +633,3 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = addShiftConvMaskCheckIndex2(i, j, (Integer.max(i, j) << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        long res = addShiftConvMaskCheckIndex2(i, j, (Integer.max(i, j) << INT_MASK_WIDTH) + 1);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java","additions":227,"deletions":73,"binary":false,"changes":300,"status":"modified"}]}