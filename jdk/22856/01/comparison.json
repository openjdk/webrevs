{"files":[{"patch":"@@ -673,0 +673,2 @@\n+static bool AndIL_is_zero_element_under_mask(const PhaseGVN* phase, const Node* expr, const Node* mask, BasicType bt);\n+\n@@ -674,2 +676,2 @@\n-  \/\/ patterns similar to (v << 2) & 3\n-  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_INT, true)) {\n+  if (AndIL_is_zero_element_under_mask(phase, in(1), in(2), T_INT) ||\n+      AndIL_is_zero_element_under_mask(phase, in(2), in(1), T_INT)) {\n@@ -721,2 +723,2 @@\n-  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-  Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n+  \/\/ Simplify (v1 + v2) & mask to v1 & mask or v2 & mask when possible.\n+  Node* progress = AndIL_sum_and_mask(phase, T_INT);\n@@ -805,2 +807,2 @@\n-  \/\/ patterns similar to (v << 2) & 3\n-  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_LONG, true)) {\n+  if (AndIL_is_zero_element_under_mask(phase, in(1), in(2), T_LONG) ||\n+      AndIL_is_zero_element_under_mask(phase, in(2), in(1), T_LONG)) {\n@@ -853,2 +855,2 @@\n-  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-  Node* progress = AndIL_add_shift_and_mask(phase, T_LONG);\n+  \/\/ Simplify (v1 + v2) & mask to v1 & mask or v2 & mask when possible.\n+  Node* progress = AndIL_sum_and_mask(phase, T_LONG);\n@@ -2055,24 +2057,8 @@\n-\/\/ Given an expression (AndX shift mask) or (AndX mask shift),\n-\/\/ determine if the AndX must always produce zero, because the\n-\/\/ the shift (x<<N) is bitwise disjoint from the mask #M.\n-\/\/ The X in AndX must be I or L, depending on bt.\n-\/\/ Specifically, the following cases fold to zero,\n-\/\/ when the shift value N is large enough to zero out\n-\/\/ all the set positions of the and-mask M.\n-\/\/   (AndI (LShiftI _ #N) #M) => #0\n-\/\/   (AndL (LShiftL _ #N) #M) => #0\n-\/\/   (AndL (ConvI2L (LShiftI _ #N)) #M) => #0\n-\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n-\/\/ Because the optimization might work for a non-constant\n-\/\/ mask M, we check the AndX for both operand orders.\n-bool MulNode::AndIL_shift_and_mask_is_always_zero(PhaseGVN* phase, Node* shift, Node* mask, BasicType bt, bool check_reverse) {\n-  if (mask == nullptr || shift == nullptr) {\n-    return false;\n-  }\n-  const TypeInteger* mask_t = phase->type(mask)->isa_integer(bt);\n-  if (mask_t == nullptr || phase->type(shift)->isa_integer(bt) == nullptr) {\n-    return false;\n-  }\n-  shift = shift->uncast();\n-  if (shift == nullptr) {\n-    return false;\n+\/\/------------------------------ Sum & Mask ------------------------------\n+\n+\/\/ Returns a lower bound on the number of trailing zeros in expr.\n+static jint AndIL_min_trailing_zeros(const PhaseGVN* phase, const Node* expr, BasicType bt) {\n+  expr = expr->uncast();\n+  const TypeInteger* type = phase->type(expr)->isa_integer(bt);\n+  if (type == nullptr) {\n+    return 0;\n@@ -2080,2 +2066,4 @@\n-  if (phase->type(shift)->isa_integer(bt) == nullptr) {\n-    return false;\n+\n+  if (type->is_con()) {\n+    long con = type->get_con_as_long(bt);\n+    return con == 0L ? (type2aelembytes(bt) * BitsPerByte) : count_trailing_zeros(con);\n@@ -2083,2 +2071,3 @@\n-  BasicType shift_bt = bt;\n-  if (bt == T_LONG && shift->Opcode() == Op_ConvI2L) {\n+\n+  if (expr->Opcode() == Op_ConvI2L) {\n+    expr = expr->in(1)->uncast();\n@@ -2086,32 +2075,1 @@\n-    Node* val = shift->in(1);\n-    if (val == nullptr) {\n-      return false;\n-    }\n-    val = val->uncast();\n-    if (val == nullptr) {\n-      return false;\n-    }\n-    if (val->Opcode() == Op_LShiftI) {\n-      shift_bt = T_INT;\n-      shift = val;\n-      if (phase->type(shift)->isa_integer(bt) == nullptr) {\n-        return false;\n-      }\n-    }\n-  }\n-  if (shift->Opcode() != Op_LShift(shift_bt)) {\n-    if (check_reverse &&\n-        (mask->Opcode() == Op_LShift(bt) ||\n-         (bt == T_LONG && mask->Opcode() == Op_ConvI2L))) {\n-      \/\/ try it the other way around\n-      return AndIL_shift_and_mask_is_always_zero(phase, mask, shift, bt, false);\n-    }\n-    return false;\n-  }\n-  Node* shift2 = shift->in(2);\n-  if (shift2 == nullptr) {\n-    return false;\n-  }\n-  const Type* shift2_t = phase->type(shift2);\n-  if (!shift2_t->isa_int() || !shift2_t->is_int()->is_con()) {\n-    return false;\n+    type = phase->type(expr)->isa_int();\n@@ -2120,3 +2078,9 @@\n-  jint shift_con = shift2_t->is_int()->get_con() & ((shift_bt == T_INT ? BitsPerJavaInteger : BitsPerJavaLong) - 1);\n-  if ((((jlong)1) << shift_con) > mask_t->hi_as_long() && mask_t->lo_as_long() >= 0) {\n-    return true;\n+  if (expr->Opcode() == Op_LShift(bt)) {\n+    const TypeInt* rhs_t = phase->type(expr->in(2))->isa_int();\n+    if (rhs_t == nullptr || !rhs_t->is_con()) {\n+      return 0;\n+    }\n+    long shift = rhs_t->get_con();\n+    assert(shift >= 0 && shift < type2aelembytes(bt) * BitsPerByte,\n+           \"shift amount should have been masked already: %ld\", shift);\n+    return shift;\n@@ -2125,1 +2089,1 @@\n-  return false;\n+  return 0;\n@@ -2128,5 +2092,4 @@\n-\/\/ Given an expression (AndX (AddX v1 (LShiftX v2 #N)) #M)\n-\/\/ determine if the AndX must always produce (AndX v1 #M),\n-\/\/ because the shift (v2<<N) is bitwise disjoint from the mask #M.\n-\/\/ The X in AndX will be I or L, depending on bt.\n-\/\/ Specifically, the following cases fold,\n+\/\/ Checks whether expr is neutral wrt addition under mask, i.e.\n+\/\/ an expression of the form (AndX (T+expr) mask) can be simplified to (AndX T mask).\n+\/\/ The X in AndX must be I or L, depending on bt.\n+\/\/ Specifically, this holds for the following cases,\n@@ -2134,4 +2097,7 @@\n-\/\/ all the set positions of the and-mask M.\n-\/\/   (AndI (AddI v1 (LShiftI _ #N)) #M) => (AndI v1 #M)\n-\/\/   (AndL (AddI v1 (LShiftL _ #N)) #M) => (AndL v1 #M)\n-\/\/   (AndL (AddL v1 (ConvI2L (LShiftI _ #N))) #M) => (AndL v1 #M)\n+\/\/ all the set positions of the and-mask M:\n+\/\/   (AndI (LShiftI _ #N) #M)\n+\/\/   (AndL (LShiftL _ #N) #M)\n+\/\/   (AndL (ConvI2L (LShiftI _ #N)) #M)\n+\/\/ including equivalent constant operands:\n+\/\/   (AndI (ConI (_ << #N)) #M)\n+\/\/   (AndL (ConL (_ << #N)) #M)\n@@ -2139,4 +2105,16 @@\n-\/\/ Because the optimization might work for a non-constant\n-\/\/ mask M, and because the AddX operands can come in either\n-\/\/ order, we check for every operand order.\n-Node* MulNode::AndIL_add_shift_and_mask(PhaseGVN* phase, BasicType bt) {\n+static bool AndIL_is_zero_element_under_mask(const PhaseGVN* phase, const Node* expr, const Node* mask, BasicType bt) {\n+  const TypeInteger* mask_t = phase->type(mask)->isa_integer(bt);\n+  if (mask_t == nullptr) {\n+    return false;\n+  }\n+\n+  jint zeros = AndIL_min_trailing_zeros(phase, expr, bt);\n+  return zeros > 0 && ((((jlong)1) << zeros) > mask_t->hi_as_long() && mask_t->lo_as_long() >= 0);\n+}\n+\n+\/\/ Given an expression (AndX (AddX v1 v2) mask)\n+\/\/ determine if the AndX must always produce (AndX v1 mask),\n+\/\/ because v2 is zero wrt addition under mask.\n+\/\/ Because the AddX operands can come in either\n+\/\/ order, we check for both orders.\n+Node* MulNode::AndIL_sum_and_mask(PhaseGVN* phase, BasicType bt) {\n@@ -2145,3 +2123,0 @@\n-  if (add == nullptr || mask == nullptr) {\n-    return nullptr;\n-  }\n@@ -2159,8 +2134,6 @@\n-    if (add1 != nullptr && add2 != nullptr) {\n-      if (AndIL_shift_and_mask_is_always_zero(phase, add1, mask, bt, false)) {\n-        set_req_X(addidx, add2, phase);\n-        return this;\n-      } else if (AndIL_shift_and_mask_is_always_zero(phase, add2, mask, bt, false)) {\n-        set_req_X(addidx, add1, phase);\n-        return this;\n-      }\n+    if (AndIL_is_zero_element_under_mask(phase, add1, mask, bt)) {\n+      set_req_X(addidx, add2, phase);\n+      return this;\n+    } else if (AndIL_is_zero_element_under_mask(phase, add2, mask, bt)) {\n+      set_req_X(addidx, add1, phase);\n+      return this;\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":69,"deletions":96,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-  static bool AndIL_shift_and_mask_is_always_zero(PhaseGVN* phase, Node* shift, Node* mask, BasicType bt, bool check_reverse);\n-  Node* AndIL_add_shift_and_mask(PhaseGVN* phase, BasicType bt);\n+protected:\n+  Node* AndIL_sum_and_mask(PhaseGVN* phase, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @bug 8277850 8278949 8285793\n+ * @bug 8277850 8278949 8285793 8346664\n@@ -46,0 +46,16 @@\n+    \/\/ any X << INT_MASK_WIDTH is zero under any INT_MASK\n+    static final int INT_MASK_WIDTH = 1 + RANDOM.nextInt(30);\n+    static final int INT_MAX_MASK = (1 << INT_MASK_WIDTH) - 1;\n+    static final int INT_MASK = 1 + RANDOM.nextInt(INT_MAX_MASK);\n+    static final int INT_MASK2 = 1 + RANDOM.nextInt(INT_MAX_MASK);\n+    static final int INT_ZERO_CONST = RANDOM.nextInt() << INT_MASK_WIDTH;\n+\n+    \/\/ any X << LONG_MASK_WIDTH is zero under any LONG_MASK\n+    static final int LONG_MASK_WIDTH = 1 + RANDOM.nextInt(62);\n+    static final long LONG_MAX_MASK = (1L << LONG_MASK_WIDTH) - 1;\n+    static final long LONG_MASK = 1 + RANDOM.nextLong(LONG_MAX_MASK);\n+    static final long LONG_MASK2 = 1 + RANDOM.nextLong(LONG_MAX_MASK);\n+    static final long LONG_ZERO_CONST = RANDOM.nextLong() << LONG_MASK_WIDTH;\n+\n+    static final int ADD_CONST = RANDOM.nextInt();\n+\n@@ -50,1 +66,1 @@\n-        return (i << 2) & 3; \/\/ transformed to: return 0;\n+        return (i << INT_MASK_WIDTH) & INT_MASK; \/\/ transformed to: return 0;\n@@ -64,1 +80,1 @@\n-        return (i << 2) & 3; \/\/ transformed to: return 0;\n+        return (i << LONG_MASK_WIDTH) & LONG_MASK; \/\/ transformed to: return 0;\n@@ -84,1 +100,1 @@\n-            mask = 3;\n+            mask = INT_MASK;\n@@ -86,1 +102,1 @@\n-            mask = 1;\n+            mask = INT_MASK2;\n@@ -88,1 +104,1 @@\n-        return mask & (i << 2); \/\/ transformed to: return 0;\n+        return mask & (i << INT_MASK_WIDTH); \/\/ transformed to: return 0;\n@@ -105,1 +121,1 @@\n-            mask = 3;\n+            mask = LONG_MASK;\n@@ -107,1 +123,1 @@\n-            mask = 1;\n+            mask = LONG_MASK2;\n@@ -109,1 +125,1 @@\n-        return mask & (i << 2); \/\/ transformed to: return 0;\n+        return mask & (i << LONG_MASK_WIDTH); \/\/ transformed to: return 0;\n@@ -123,1 +139,1 @@\n-        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -131,1 +147,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -136,0 +152,24 @@\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I, IRNode.LSHIFT_I })\n+    public static int addShiftPlusConstMaskInt(int i, int j) {\n+        return (j + ((i + ADD_CONST) << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n+    }\n+\n+    @Run(test = \"addShiftPlusConstMaskInt\")\n+    public static void addShiftPlusConstMaskInt_runner() {\n+        int i = RANDOM.nextInt();\n+        int j = RANDOM.nextInt();\n+        int res = addShiftPlusConstMaskInt(i, j);\n+        if (res != (j & INT_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(counts = { IRNode.ADD_I, \"2\", IRNode.LSHIFT_I, \"1\" })\n+    public static int addShiftPlusConstDisjointMaskInt(int i, int j) {\n+        return (j + ((i + 5) << 2)) & 32; \/\/ NOT transformed even though (5<<2) & 32 == 0\n+    }\n+\n@@ -143,1 +183,1 @@\n-            mask = 3;\n+            mask = INT_MASK;\n@@ -145,1 +185,1 @@\n-            mask = 1;\n+            mask = INT_MASK2;\n@@ -147,1 +187,1 @@\n-        return mask & (j + (i << 2)); \/\/ transformed to: return j & mask;\n+        return mask & (j + (i << INT_MASK_WIDTH)); \/\/ transformed to: return j & mask;\n@@ -155,1 +195,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -159,1 +199,28 @@\n-        if (res != (j & 1)) {\n+        if (res != (j & INT_MASK2)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I })\n+    public static int addConstNonConstMaskInt(int j, boolean flag) {\n+        int mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = INT_MASK;\n+        } else {\n+            mask = INT_MASK2;\n+        }\n+        return mask & (j + INT_ZERO_CONST); \/\/ transformed to: return j & mask;\n+    }\n+\n+    @Run(test = \"addConstNonConstMaskInt\")\n+    public static void addConstNonConstMaskInt_runner() {\n+        int j = RANDOM.nextInt();\n+        int res = addConstNonConstMaskInt(j, true);\n+        if (res != (j & INT_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+        res = addConstNonConstMaskInt(j, false);\n+        if (res != (j & INT_MASK2)) {\n@@ -168,1 +235,1 @@\n-        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + (i << LONG_MASK_WIDTH)) & LONG_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -176,1 +243,18 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & LONG_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L, IRNode.LSHIFT_L })\n+    public static long addShiftPlusConstMaskLong(long i, long j) {\n+        return (j + ((i - 5) << LONG_MASK_WIDTH)) & LONG_MASK; \/\/ transformed to: return j & INT_MASK;\n+    }\n+\n+    @Run(test = \"addShiftPlusConstMaskLong\")\n+    public static void addShiftPlusConstMaskLong_runner() {\n+        long i = RANDOM.nextLong();\n+        long j = RANDOM.nextLong();\n+        long res = addShiftPlusConstMaskLong(i, j);\n+        if (res != (j & LONG_MASK)) {\n@@ -185,1 +269,1 @@\n-        int mask;\n+        long mask;\n@@ -188,1 +272,1 @@\n-            mask = 3;\n+            mask = LONG_MASK;\n@@ -190,1 +274,1 @@\n-            mask = 1;\n+            mask = LONG_MASK2;\n@@ -192,1 +276,1 @@\n-        return mask & (j + (i << 2)); \/\/ transformed to: return j & mask;\n+        return mask & (j + (i << LONG_MASK_WIDTH)); \/\/ transformed to: return j & mask\n@@ -200,1 +284,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & LONG_MASK)) {\n@@ -204,1 +288,28 @@\n-        if (res != (j & 1)) {\n+        if (res != (j & LONG_MASK2)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L })\n+    public static long addConstNonConstMaskLong(long j, boolean flag) {\n+        long mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = LONG_MASK;\n+        } else {\n+            mask = LONG_MASK2;\n+        }\n+        return mask & (j + LONG_ZERO_CONST); \/\/ transformed to: return j & mask;\n+    }\n+\n+    @Run(test = \"addConstNonConstMaskLong\")\n+    public static void addConstNonConstMaskLong_runner() {\n+        long j = RANDOM.nextLong();\n+        long res = addConstNonConstMaskLong(j, true);\n+        if (res != (j & LONG_MASK)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+        res = addConstNonConstMaskLong(j, false);\n+        if (res != (j & LONG_MASK2)) {\n@@ -213,1 +324,1 @@\n-        return ((j << 2) + (i << 2)) & 3; \/\/ transformed to: return 0;\n+        return ((j << INT_MASK_WIDTH) + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -227,1 +338,1 @@\n-        return ((j << 2) + (i << 2)) & 3; \/\/ transformed to: return 0;\n+        return ((j << INT_MASK_WIDTH) + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -242,1 +353,1 @@\n-        int add1 = (i << 2);\n+        int add1 = (i << INT_MASK_WIDTH);\n@@ -244,1 +355,1 @@\n-        return (add1 + add2) & 3; \/\/ transformed to: return j & 3;\n+        return (add1 + add2) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -252,1 +363,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -261,1 +372,1 @@\n-        long add1 = (i << 2);\n+        long add1 = (i << LONG_MASK_WIDTH);\n@@ -263,1 +374,1 @@\n-        return (add1 + add2) & 3; \/\/ transformed to: return j & 3;\n+        return (add1 + add2) & LONG_MASK; \/\/ transformed to: return j & LONG_MASK;\n@@ -271,1 +382,1 @@\n-        if (res != (((long)j) & 3)) {\n+        if (res != (((long) j) & LONG_MASK)) {\n@@ -280,1 +391,1 @@\n-        return ((long)(i << 2)) & 3; \/\/ transformed to: return 0;\n+        return ((long) (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -297,1 +408,1 @@\n-            mask = 3;\n+            mask = INT_MASK;\n@@ -299,1 +410,1 @@\n-            mask = 1;\n+            mask = INT_MASK2;\n@@ -301,1 +412,1 @@\n-        return mask & ((long)(i << 2)); \/\/ transformed to: return 0;\n+        return mask & ((long) (i << INT_MASK_WIDTH)); \/\/ transformed to: return 0;\n@@ -315,1 +426,1 @@\n-        return (j + (i << 2)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + (i << INT_MASK_WIDTH)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -323,1 +434,1 @@\n-        if (res != (j & 3)) {\n+        if (res != (j & INT_MASK)) {\n@@ -332,1 +443,1 @@\n-        return (((long)(j << 2)) + ((long)(i << 2))) & 3; \/\/ transformed to: return 0;\n+        return (((long) (j << INT_MASK_WIDTH)) + ((long) (i << INT_MASK_WIDTH))) & INT_MASK; \/\/ transformed to: return 0;\n@@ -345,1 +456,1 @@\n-        return Objects.checkIndex(i << 2, length) & 3; \/\/ transformed to: return 0;\n+        return Objects.checkIndex(i << INT_MASK_WIDTH, length) & INT_MASK; \/\/ transformed to: return 0;\n@@ -350,2 +461,2 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int res = shiftMaskIntCheckIndex(i, (i << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int res = shiftMaskIntCheckIndex(i, (i << INT_MASK_WIDTH) + 1);\n@@ -360,1 +471,1 @@\n-        return Objects.checkIndex(i << 2, length) & 3; \/\/ transformed to: return 0;\n+        return Objects.checkIndex(i << LONG_MASK_WIDTH, length) & LONG_MASK; \/\/ transformed to: return 0;\n@@ -365,2 +476,2 @@\n-        long i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = shiftMaskLongCheckIndex(i, (i << 2) + 1);\n+        long i = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n+        long res = shiftMaskLongCheckIndex(i, (i << LONG_MASK_WIDTH) + 1);\n@@ -376,1 +487,1 @@\n-        return (j + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -381,1 +492,1 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n@@ -383,2 +494,2 @@\n-        int res = addShiftMaskIntCheckIndex(i, j, (i << 2) + 1);\n-        if (res != (j & 3)) {\n+        int res = addShiftMaskIntCheckIndex(i, j, (i << INT_MASK_WIDTH) + 1);\n+        if (res != (j & INT_MASK)) {\n@@ -393,1 +504,1 @@\n-        return (j + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + Objects.checkIndex(i << LONG_MASK_WIDTH, length)) & LONG_MASK; \/\/ transformed to: return j & LONG_MASK;\n@@ -398,1 +509,1 @@\n-        long i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n+        long i = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n@@ -400,2 +511,2 @@\n-        long res = addShiftMaskLongCheckIndex(i, j, (i << 2) + 1);\n-        if (res != (j & 3)) {\n+        long res = addShiftMaskLongCheckIndex(i, j, (i << LONG_MASK_WIDTH) + 1);\n+        if (res != (j & LONG_MASK)) {\n@@ -409,1 +520,1 @@\n-        return (Objects.checkIndex(j << 2, length) + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return 0;\n+        return (Objects.checkIndex(j << INT_MASK_WIDTH, length) + Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -415,3 +526,3 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int res = addShiftMaskIntCheckIndex2(i, j, (Integer.max(i, j) << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int res = addShiftMaskIntCheckIndex2(i, j, (Integer.max(i, j) << INT_MASK_WIDTH) + 1);\n@@ -426,1 +537,1 @@\n-        return (Objects.checkIndex(j << 2, length) + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return 0;\n+        return (Objects.checkIndex(j << LONG_MASK_WIDTH, length) + Objects.checkIndex(i << LONG_MASK_WIDTH, length)) & LONG_MASK; \/\/ transformed to: return 0;\n@@ -431,3 +542,3 @@\n-        long i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = addShiftMaskLongCheckIndex2(i, j, (Long.max(i, j) << 2) + 1);\n+        long i = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n+        long j = RANDOM.nextLong((Long.MAX_VALUE - 1) >> LONG_MASK_WIDTH);\n+        long res = addShiftMaskLongCheckIndex2(i, j, (Long.max(i, j) << LONG_MASK_WIDTH) + 1);\n@@ -442,1 +553,1 @@\n-        return ((long)Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return 0;\n+        return ((long) Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return 0;\n@@ -447,2 +558,2 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = shiftConvMaskCheckIndex(i, (i << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        long res = shiftConvMaskCheckIndex(i, (i << INT_MASK_WIDTH) + 1);\n@@ -458,1 +569,1 @@\n-        return (j + Objects.checkIndex(i << 2, length)) & 3; \/\/ transformed to: return j & 3;\n+        return (j + Objects.checkIndex(i << INT_MASK_WIDTH, length)) & INT_MASK; \/\/ transformed to: return j & INT_MASK;\n@@ -463,1 +574,1 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n@@ -465,2 +576,2 @@\n-        long res = addShiftConvMaskCheckIndex(i, j, (i << 2) + 1);\n-        if (res != (j & 3)) {\n+        long res = addShiftConvMaskCheckIndex(i, j, (i << INT_MASK_WIDTH) + 1);\n+        if (res != (j & INT_MASK)) {\n@@ -474,1 +585,1 @@\n-        return (((long)Objects.checkIndex(j << 2, length)) + ((long)Objects.checkIndex(i << 2, length))) & 3; \/\/ transformed to: return 0;\n+        return (((long) Objects.checkIndex(j << INT_MASK_WIDTH, length)) + ((long) Objects.checkIndex(i << INT_MASK_WIDTH, length))) & INT_MASK; \/\/ transformed to: return 0;\n@@ -479,3 +590,3 @@\n-        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> 2);\n-        long res = addShiftConvMaskCheckIndex2(i, j, (Integer.max(i, j) << 2) + 1);\n+        int i = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        int j = RANDOM.nextInt((Integer.MAX_VALUE - 1) >> INT_MASK_WIDTH);\n+        long res = addShiftConvMaskCheckIndex2(i, j, (Integer.max(i, j) << INT_MASK_WIDTH) + 1);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java","additions":183,"deletions":72,"binary":false,"changes":255,"status":"modified"}]}