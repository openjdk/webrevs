{"files":[{"patch":"@@ -2058,2 +2058,1 @@\n-\/\/ Returns a lower bound on the number of trailing zeros in expr, or -1 if the number\n-\/\/ cannot be determined.\n+\/\/ Returns a lower bound on the number of trailing zeros in expr.\n@@ -2064,1 +2063,1 @@\n-    return -1;\n+    return 0;\n@@ -2082,1 +2081,1 @@\n-      return -1;\n+      return 0;\n@@ -2084,1 +2083,6 @@\n-    return rhs_t->get_con() & (type2aelembytes(bt) * BitsPerByte - 1);\n+    \/\/ We need to truncate the shift, as it may not have been canonicalized yet.\n+    \/\/ T_INT:  0..31 -> shift_mask = 4 * 8 - 1 = 31\n+    \/\/ T_LONG: 0..63 -> shift_mask = 8 * 8 - 1 = 63\n+    \/\/ (JLS: \"Shift Operators\")\n+    jint shift_mask = type2aelembytes(bt) * BitsPerByte - 1;\n+    return shift_t->get_con() & shift_mask;\n@@ -2087,1 +2091,1 @@\n-  return -1;\n+  return 0;\n@@ -2090,3 +2094,7 @@\n-\/\/ Checks whether expr is neutral element (zero) under mask. We have:\n-\/\/   (AndX expr mask)\n-\/\/ The X in AndX must be I or L, depending on bt.\n+\/\/ Checks whether expr is neutral additive element (zero) under mask,\n+\/\/ i.e. whether an expression of the form:\n+\/\/   (AndX (AddX (expr addend) mask)\n+\/\/ is equivalent to\n+\/\/   (AndX addend mask)\n+\/\/ for any addend.\n+\/\/ (The X in AndX must be I or L, depending on bt).\n@@ -2094,4 +2102,5 @@\n-\/\/ We split the bits of expr into MSB and LSB, where LSB represents\n-\/\/ all trailing zeros of expr:\n-\/\/   MSB    LSB\n-\/\/   mmmmmm 0000000000\n+\/\/ We check for the sufficient condition when the lowest set bit in expr is higher than\n+\/\/ the highest set bit in mask, i.e.:\n+\/\/ expr: eeeeee0000000000000\n+\/\/ mask: 000000mmmmmmmmmmmmm\n+\/\/ We do not test for other cases.\n@@ -2099,6 +2108,4 @@\n-\/\/ We check if the mask has no one bits in the corresponding higher\n-\/\/ bits, i.e. if the number of trailing zeros is larger or equal to the\n-\/\/ bit width of the expr, i.e. if the number of leading zeros for mask\n-\/\/ is greater or equal to the number of bits in MSB:\n-\/\/   000000 00000eeee -> (AndX expr mask) = 0                 -> return true\n-\/\/   0000ee eeeeeeeeee -> (AndX expr mask) = 0000xx 0000000000 -> return false\n+\/\/ Correctness:\n+\/\/ When mask is of the form 1111111 (2^m - 1) and expr has at least m trailing zeros,\n+\/\/ then expr is a multiple of 2^m. (AndX sum mask) is equivalent to sum % (2^m) and any multiple\n+\/\/ of the modulus is congruent with zero modulo 2^m (https:\/\/en.wikipedia.org\/wiki\/Modular_arithmetic).\n@@ -2106,0 +2113,6 @@\n+\/\/ This extends to when lower bits in mask are unset:\n+\/\/ if (AndX (AddX expr addend) 2^m-1) == (AndX addend 2^m-1) for any addend, then also\n+\/\/    (AndX (AddX expr addend)  mask) == (AndX addend  mask) for any addend, provided mask's MSB is at most m.\n+\/\/\n+\/\/ We therefore need to only compare the position of the LSB in expr against the position\n+\/\/ of the MSB in mask.\n@@ -2107,5 +2120,0 @@\n-  jint expr_trailing_zeros = AndIL_min_trailing_zeros(phase, expr, bt);\n-  if (expr_trailing_zeros < 0) {\n-    return false;\n-  }\n-\n@@ -2118,1 +2126,1 @@\n-  \/\/ Is the mask always zero?\n+  \/\/ When the mask is constant zero, we defer to MulNode::Value to eliminate the entire AndX operation.\n@@ -2121,1 +2129,1 @@\n-    return true;\n+    return false;\n@@ -2123,1 +2131,3 @@\n-  jint mask_bit_width =  BitsPerLong - count_leading_zeros(mask_t->hi_as_long());\n+\n+  jint mask_bit_width = BitsPerLong - count_leading_zeros(mask_t->hi_as_long());\n+  jint expr_trailing_zeros = AndIL_min_trailing_zeros(phase, expr, bt);\n@@ -2127,1 +2137,1 @@\n-\/\/ Pattern:\n+\/\/ Reduces the pattern:\n@@ -2129,6 +2139,2 @@\n-\/\/\n-\/\/ Assume:\n-\/\/   (AndX add1 mask) == 0\n-\/\/\n-\/\/ ... prove why we know that we can return:\n-\/\/   (AndX add2 mask)\n+\/\/ to\n+\/\/   (AndX add1 mask), if add2 is neutral wrt mask (see above), and vice versa.\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":40,"deletions":34,"binary":false,"changes":74,"status":"modified"}]}