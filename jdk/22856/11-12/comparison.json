{"files":[{"patch":"@@ -778,1 +778,1 @@\n-    \/\/ Same as above, but with long[] input.\n+    \/\/ Same as testMemorySegmentIInvarL3e, but with long[] input.\n@@ -879,2 +879,1 @@\n-    \/\/ Would be nice if it vectorized.\n-    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    \/\/ With AlignVector (strict alignment requirements): we cannot prove that the invariants are alignable -> no vectorization.\n@@ -904,2 +903,1 @@\n-    \/\/ Would be nice if it vectorized.\n-    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n+    \/\/ With AlignVector (strict alignment requirements): we cannot prove that the invariants are alignable -> no vectorization.\n@@ -946,1 +944,1 @@\n-    \/\/ FAILS: should be ok to vectorize, but does not. Investigate in JDK-8331659.\n+  \/\/ With AlignVector (strict alignment requirements): we cannot prove that the invariants are alignable -> no vectorization.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    @IR(counts = {IRNode.POPULATE_INDEX, \"> 0\"})\n+    \/\/ Does not vectorize, possibly because the OrI is pushed through the Phi, see also JDK-8348096.\n@@ -117,1 +117,4 @@\n-    \/\/ Currently disabled due to sum-under-mask optimization.\n+    \/\/ Does not vectorize: due to sum-under-mask optimization.\n+    \/\/ (i+0) & 7, (i+1) & 7 ... (i+8) & 7 ....  -> PopulateIndex\n+    \/\/ becomes\n+    \/\/ (i+0) & 7, (i+1) & 7 ... (i+0) & 7 .... -> pattern broken\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopulateIndex.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}