{"files":[{"patch":"@@ -163,4 +163,0 @@\n-        tests.put(\"testMemorySegmentIInvarL3da\", () -> {\n-          MemorySegment data = MemorySegment.ofArray(aI.clone());\n-          return testMemorySegmentIInvarL3da(data, 1, 2, 3, RANGE-200);\n-        });\n@@ -171,4 +167,0 @@\n-        tests.put(\"testMemorySegmentIInvarL3d2a\", () -> {\n-          MemorySegment data = MemorySegment.ofArray(aI.clone());\n-          return testMemorySegmentIInvarL3d2a(data, 1, 2, 3, RANGE-200);\n-        });\n@@ -183,4 +175,0 @@\n-        tests.put(\"testMemorySegmentIInvarL3ea\", () -> {\n-          MemorySegment data = MemorySegment.ofArray(aI.clone());\n-          return testMemorySegmentIInvarL3ea(data, 1, 2, 3, RANGE-200);\n-        });\n@@ -207,4 +195,0 @@\n-        tests.put(\"testMemorySegmentLInvarL3da\", () -> {\n-          MemorySegment data = MemorySegment.ofArray(aL.clone());\n-          return testMemorySegmentLInvarL3da(data, 1, 2, 3, RANGE-200);\n-        });\n@@ -215,4 +199,0 @@\n-        tests.put(\"testMemorySegmentLInvarL3d2a\", () -> {\n-          MemorySegment data = MemorySegment.ofArray(aL.clone());\n-          return testMemorySegmentLInvarL3d2a(data, 1, 2, 3, RANGE-200);\n-        });\n@@ -227,4 +207,0 @@\n-        tests.put(\"testMemorySegmentLInvarL3ea\", () -> {\n-          MemorySegment data = MemorySegment.ofArray(aL.clone());\n-          return testMemorySegmentLInvarL3ea(data, 1, 2, 3, RANGE-200);\n-        });\n@@ -269,1 +245,0 @@\n-                 \"testMemorySegmentIInvarL3da\",\n@@ -271,1 +246,0 @@\n-                 \"testMemorySegmentIInvarL3d2a\",\n@@ -274,1 +248,0 @@\n-                 \"testMemorySegmentIInvarL3ea\",\n@@ -280,1 +253,0 @@\n-                 \"testMemorySegmentLInvarL3da\",\n@@ -282,1 +254,0 @@\n-                 \"testMemorySegmentLInvarL3d2a\",\n@@ -285,1 +256,0 @@\n-                 \"testMemorySegmentLInvarL3ea\",\n@@ -714,2 +684,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 10\",\n-                  IRNode.STORE_VECTOR,  \"= 10\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n@@ -719,13 +689,0 @@\n-    static Object[] testMemorySegmentIInvarL3d(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n-        long i1 = (long)(-invar1 + invar2 + invar3);\n-        long i2 = (long)(invar2 + invar3 - invar1); \/\/ equivalent\n-        for (int i = 0; i < size; i+=2) {\n-            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 0);\n-            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + i2 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 0, v0 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_INT, i + i2 + 1, v1 + 1);\n-        }\n-        return new Object[]{ m };\n-    }\n-\n-    @Test\n@@ -739,1 +696,1 @@\n-    static Object[] testMemorySegmentIInvarL3da(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentIInvarL3d(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n@@ -752,2 +709,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 10\",\n-                  IRNode.STORE_VECTOR,  \"= 10\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n@@ -757,12 +714,0 @@\n-    static Object[] testMemorySegmentIInvarL3d2(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n-        long i1 = (long)(-invar1 + invar2 + invar3);\n-        for (int i = 0; i < size; i+=2) {\n-            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 0);\n-            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 0, v0 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 1, v1 + 1);\n-        }\n-        return new Object[]{ m };\n-    }\n-\n-    @Test\n@@ -776,1 +721,1 @@\n-    static Object[] testMemorySegmentIInvarL3d2a(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentIInvarL3d2(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n@@ -806,3 +751,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 10\",\n-                  IRNode.STORE_VECTOR,  \"= 10\"},\n-        applyIf = {\"AlignVector\", \"false\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n@@ -810,0 +754,1 @@\n+        applyIf = {\"AlignVector\", \"false\"},\n@@ -811,13 +756,0 @@\n-    static Object[] testMemorySegmentIInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n-        long i1 = (long)(-invar1 + invar2 + invar3);\n-        long i2 = (long)(invar2 + invar3) - (long)(invar1); \/\/ not equivalent\n-        for (int i = 0; i < size; i+=2) {\n-            int v0 = m.getAtIndex(ValueLayout.JAVA_INT, i + i1 + 0);\n-            int v1 = m.getAtIndex(ValueLayout.JAVA_INT, i + i2 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_INT, i + i1 + 0, v0 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_INT, i + i2 + 1, v1 + 1);\n-        }\n-        return new Object[]{ m };\n-    }\n-\n-    @Test\n@@ -826,1 +758,0 @@\n-        applyIf = {\"AlignVector\", \"true\"},\n@@ -828,0 +759,1 @@\n+        applyIf = {\"AlignVector\", \"true\"},\n@@ -832,1 +764,1 @@\n-    static Object[] testMemorySegmentIInvarL3ea(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentIInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n@@ -914,2 +846,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 4\",\n-                  IRNode.STORE_VECTOR,  \"= 4\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n@@ -919,15 +851,0 @@\n-    \/\/ Would be nice if it vectorized.\n-    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n-    static Object[] testMemorySegmentLInvarL3d(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n-        long i1 = (long)(-invar1 + invar2 + invar3);\n-        long i2 = (long)(invar2 + invar3 - invar1); \/\/ equivalent\n-        for (int i = 0; i < size; i+=2) {\n-            long v0 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0);\n-            long v1 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0, v0 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1, v1 + 1);\n-        }\n-        return new Object[]{ m };\n-    }\n-\n-    @Test\n@@ -941,1 +858,1 @@\n-    static Object[] testMemorySegmentLInvarL3da(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentLInvarL3d(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n@@ -954,2 +871,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 4\",\n-                  IRNode.STORE_VECTOR,  \"= 4\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n@@ -959,14 +876,0 @@\n-    \/\/ Would be nice if it vectorized.\n-    \/\/ Fails because of control flow. Somehow the \"offsetPlain\" check (checks for alignment) is not folded away.\n-    static Object[] testMemorySegmentLInvarL3d2(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n-        long i1 = (long)(-invar1 + invar2 + invar3);\n-        for (int i = 0; i < size; i+=2) {\n-            long v0 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0);\n-            long v1 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0, v0 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 1, v1 + 1);\n-        }\n-        return new Object[]{ m };\n-    }\n-\n-    @Test\n@@ -980,1 +883,1 @@\n-    static Object[] testMemorySegmentLInvarL3d2a(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentLInvarL3d2(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n@@ -1010,2 +913,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_L, \"= 4\",\n-                  IRNode.STORE_VECTOR,  \"= 4\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_L, \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n@@ -1015,14 +918,0 @@\n-    \/\/ FAILS: should be ok to vectorize, but does not. Investigate in JDK-8331659.\n-    static Object[] testMemorySegmentLInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n-        long i1 = (long)(-invar1 + invar2 + invar3);\n-        long i2 = (long)(invar2 + invar3) - (long)(invar1); \/\/ not equivalent\n-        for (int i = 0; i < size; i+=2) {\n-            long v0 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0);\n-            long v1 = m.getAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_LONG, i + i1 + 0, v0 + 1);\n-            m.setAtIndex(ValueLayout.JAVA_LONG, i + i2 + 1, v1 + 1);\n-        }\n-        return new Object[]{ m };\n-    }\n-\n-    @Test\n@@ -1035,1 +924,1 @@\n-    static Object[] testMemorySegmentLInvarL3ea(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n+    static Object[] testMemorySegmentLInvarL3e(MemorySegment m, int invar1, int invar2, int invar3, int size) {\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java","additions":20,"deletions":131,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-    @IR(counts = {IRNode.POPULATE_INDEX, \"= 0\"}) \/\/ disabled by sum-under-mask optimization.\n+    \/\/ Currently disabled due to sum-under-mask optimization.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopulateIndex.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}