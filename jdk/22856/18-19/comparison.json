{"files":[{"patch":"@@ -2109,3 +2109,2 @@\n-\/\/ When mask is of the form 1111111 (2^m - 1) and expr has at least m trailing zeros,\n-\/\/ then expr is a multiple of 2^m. (AndX sum mask) is equivalent to sum % (2^m) and any multiple\n-\/\/ of the modulus is congruent with zero modulo 2^m (https:\/\/en.wikipedia.org\/wiki\/Modular_arithmetic).\n+\/\/ Given expr with at least w trailing bits,\n+\/\/ let \"mod = 2^w\", \"suffix_mask = mod - 1\", and \"mask\" be any non-negative value <= suffix_mask.\n@@ -2113,3 +2112,4 @@\n-\/\/ This extends to when lower bits in mask are unset:\n-\/\/ if (AndX (AddX expr addend) 2^m-1) == (AndX addend 2^m-1) for any addend, then also\n-\/\/    (AndX (AddX expr addend)  mask) == (AndX addend  mask) for any addend, provided mask's MSB is at most m.\n+\/\/    expr % mod == 0                             (multiple of power of two)\n+\/\/ => (a + expr) % mod         == a % mod         (zero element in modular arithmetic)\n+\/\/ => (a + expr) & suffix_mask == a & suffix_mask (remainder means masking with suffix bits)\n+\/\/ => (a + expr) & mask        == a & mask        (equivalency under suffix mask also holds under partial mask)\n@@ -2117,2 +2117,1 @@\n-\/\/ We therefore need to only compare the position of the LSB in expr against the position\n-\/\/ of the MSB in mask.\n+\/\/ Hence, if expr has at least w trailing bits, it is a zero element under any mask with width w.\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"}]}