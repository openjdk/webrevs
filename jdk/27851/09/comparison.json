{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.security.NoSuchAlgorithmException;\n@@ -38,0 +39,1 @@\n+import java.security.UnrecoverableEntryException;\n@@ -224,2 +226,8 @@\n-        if ((firstDot == -1) || (secondDot == firstDot)) {\n-            \/\/ invalid alias\n+\n+        if ((firstDot < 1)\n+                || (secondDot - firstDot < 2)\n+                || (alias.length() - secondDot < 2)) {\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+                SSLLogger.warning(\"Invalid alias format: \" + alias);\n+            }\n@@ -228,0 +236,1 @@\n+\n@@ -243,2 +252,10 @@\n-        } catch (Exception e) {\n-            \/\/ ignore\n+        } catch (UnrecoverableEntryException |\n+                 KeyStoreException |\n+                 NumberFormatException |\n+                 NoSuchAlgorithmException |\n+                 IndexOutOfBoundsException e) {\n+            \/\/ ignore and only log exception\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+                SSLLogger.warning(\"Exception thrown while getting an alias \" +\n+                                  alias + \": \" + e);\n+            }\n@@ -281,2 +298,3 @@\n-                            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                                SSLLogger.fine(\"KeyMgr: choosing key: \" + status);\n+                            if (SSLLogger.isOn\n+                                    && SSLLogger.isOn(\"ssl,keymanager\")) {\n+                                SSLLogger.fine(\"Choosing key: \" + status);\n@@ -297,2 +315,2 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                SSLLogger.fine(\"KeyMgr: no matching key found\");\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+                SSLLogger.fine(\"No matching key found\");\n@@ -303,1 +321,1 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n@@ -305,1 +323,1 @@\n-                    \"KeyMgr: no good matching key found, \"\n+                    \"No good matching key found, \"\n@@ -343,2 +361,2 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                SSLLogger.fine(\"KeyMgr: no matching alias found\");\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+                SSLLogger.fine(\"No matching alias found\");\n@@ -349,2 +367,2 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-            SSLLogger.fine(\"KeyMgr: getting aliases\", allResults);\n+        if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,keymanager\")) {\n+            SSLLogger.fine(\"Getting aliases\", allResults);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerImpl.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6302126 6302321 6302271 6302304\n+ * @bug 6302126 6302321 6302271 6302304 8369995\n@@ -35,0 +35,6 @@\n+ *     Extra logging and\/or propagate errors in X509KeyManagerImpl\n+ *\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @modules java.base\/sun.security.x509\n+ *\n+ * @run junit NullCases\n@@ -36,4 +42,14 @@\n-import java.io.*;\n-import java.net.*;\n-import java.security.*;\n-import javax.net.ssl.*;\n+\n+import jdk.test.lib.Asserts;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.X509KeyManager;\n+import java.security.KeyPair;\n+import java.security.SecureRandom;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n@@ -42,1 +58,3 @@\n-import java.util.*;\n+import static jdk.httpclient.test.lib.common.DynamicKeyStoreUtil.generateCert;\n+import static jdk.httpclient.test.lib.common.DynamicKeyStoreUtil.generateKeyStore;\n+import static jdk.httpclient.test.lib.common.DynamicKeyStoreUtil.generateRSAKeyPair;\n@@ -46,4 +64,0 @@\n-    public static void main(String[] args) throws Exception {\n-        KeyManagerFactory kmf;\n-        X509KeyManager km;\n-        char [] password = {' '};\n@@ -51,1 +65,5 @@\n-        \/\/ check for bug 6302126\n+    private static KeyManagerFactory kmf;\n+    private static X509KeyManager km;\n+\n+    @BeforeAll\n+    public static void beforeAll() throws Exception {\n@@ -53,1 +71,0 @@\n-        kmf.init((KeyStore)null, password);\n@@ -55,1 +72,9 @@\n-        \/\/ check for 6302321\n+        \/\/ creating a new keystore\n+        final SecureRandom secureRandom = new SecureRandom();\n+        final KeyPair keyPair = generateRSAKeyPair(secureRandom);\n+        final X509Certificate originServerCert =\n+                generateCert(keyPair, secureRandom, \"subject\");\n+        final KeyStore ks = generateKeyStore(keyPair.getPrivate(),\n+                new Certificate[]{originServerCert});\n+\n+        kmf.init(ks, null);\n@@ -57,5 +82,52 @@\n-        X509Certificate[] certs = km.getCertificateChain(\"doesnotexist\");\n-        PrivateKey priv = km.getPrivateKey(\"doesnotexist\");\n-        if (certs != null || priv != null) {\n-            throw new Exception(\"Should return null if the alias can't be found\");\n-        }\n+    }\n+\n+    private X509KeyManager generateNullKm() throws Exception {\n+        char[] password = {' '};\n+        kmf.init((KeyStore) null, password);\n+        return (X509KeyManager) kmf.getKeyManagers()[0];\n+    }\n+\n+    @Test\n+    public void JDK6302126Test() throws Exception {\n+        \/\/ check for bug 6302126\n+\n+        generateNullKm();\n+    }\n+\n+    @Test\n+    public void JDK6302304Test() throws Exception {\n+        \/\/ check for bug 6302304\n+\n+        final X509KeyManager km = generateNullKm();\n+\n+        final String[] serverAliases =\n+                km.getServerAliases(null, null);\n+        Asserts.assertNull(serverAliases,\n+                \"Should return null if server alias not found\");\n+        final String[] clientAliases =\n+                km.getClientAliases(null, null);\n+        Asserts.assertNull(clientAliases,\n+                \"Should return null if client alias not found\");\n+\n+        final X509Certificate[] certs =\n+                km.getCertificateChain(null);\n+        final PrivateKey priv =\n+                km.getPrivateKey(null);\n+        Asserts.assertNull(certs,\n+                \"Should return null if the alias can't be found\");\n+        Asserts.assertNull(priv,\n+                \"Should return null if the alias can't be found\");\n+\n+        final String serverAlias =\n+                km.chooseServerAlias(null, null, null);\n+        Asserts.assertNull(serverAlias,\n+                \"Should return null if the alias can't be chosen\");\n+        final String clientAlias =\n+                km.chooseClientAlias(null, null, null);\n+        Asserts.assertNull(clientAlias,\n+                \"Should return null if the alias can't be chosen\");\n+    }\n+\n+    @Test\n+    public void JDK6302321Test() {\n+        \/\/ check for bug 6302321\n@@ -63,0 +135,11 @@\n+        final X509Certificate[] certs =\n+                km.getCertificateChain(\"doesnotexist\");\n+        final PrivateKey priv = km.getPrivateKey(\"doesnotexist\");\n+        Asserts.assertNull(certs,\n+                \"Should return null if the alias can't be found\");\n+        Asserts.assertNull(priv,\n+                \"Should return null if the alias can't be found\");\n+    }\n+\n+    @Test\n+    public void JDK6302271Test() {\n@@ -64,16 +147,75 @@\n-        String[] clis = km.getClientAliases(\"doesnotexist\", null);\n-        if (clis != null && clis.length == 0) {\n-            throw new Exception(\"Should return null instead of empty array\");\n-        }\n-        String[] srvs = km.getServerAliases(\"doesnotexist\", null);\n-        if (srvs != null && srvs.length == 0) {\n-            throw new Exception(\"Should return null instead of empty array\");\n-        }\n-\n-        \/\/ check for 6302304\n-        km.getServerAliases(null, null);\n-        km.getClientAliases(null, null);\n-        km.getCertificateChain(null);\n-        km.getPrivateKey(null);\n-        km.chooseServerAlias(null, null, null);\n-        km.chooseClientAlias(null, null, null);\n+\n+        final String[] clis =\n+                km.getClientAliases(\"doesnotexist\", null);\n+        Asserts.assertFalse((clis != null && clis.length == 0),\n+                \"Should return null instead of empty array\");\n+\n+        final String[] srvs =\n+                km.getServerAliases(\"doesnotexist\", null);\n+        Asserts.assertFalse((srvs != null && srvs.length == 0),\n+                \"Should return null instead of empty array\");\n+    }\n+\n+    \/**\n+     * The following tests are testing JDK-8369995\n+     *\/\n+\n+    @Test\n+    public void incompleteChainAndKeyTest() {\n+        final X509Certificate[] certs = km.getCertificateChain(\"1.1\");\n+        final PrivateKey priv = km.getPrivateKey(\"1.1\");\n+\n+        Asserts.assertNull(certs,\n+                \"Should return null if the alias is incomplete\");\n+        Asserts.assertNull(priv,\n+                \"Should return null if the alias is incomplete\");\n+    }\n+\n+    @Test\n+    public void nonexistentBuilderTest() {\n+        final X509Certificate[] certs = km.getCertificateChain(\"RSA.1.1\");\n+        final PrivateKey priv = km.getPrivateKey(\"RSA.1.1\");\n+\n+        Asserts.assertNull(certs,\n+                \"Should return null if builder doesn't exist\");\n+        Asserts.assertNull(priv,\n+                \"Should return null if builder doesn't exist\");\n+    }\n+\n+    @Test\n+    public void nonexistentKSTest() {\n+        final X509Certificate[] certs = km.getCertificateChain(\"RSA.0.1\");\n+        final PrivateKey priv = km.getPrivateKey(\"RSA.0.1\");\n+\n+        Asserts.assertNull(certs,\n+                \"Should return null if KS doesn't exist\");\n+        Asserts.assertNull(priv,\n+                \"Should return null if KS doesn't exist\");\n+    }\n+\n+    @Test\n+    public void wrongNumberFormatTest() {\n+        final X509Certificate[] certs =\n+                km.getCertificateChain(\"RSA.not.exist\");\n+        final PrivateKey priv = km.getPrivateKey(\"RSA.not.exist\");\n+\n+        Asserts.assertNull(certs,\n+                \"Should return null if number format is wrong in alias\");\n+        Asserts.assertNull(priv,\n+                \"Should return null if number format is wrong in alias\");\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"1..1\", \"1..\",\".1.\", \"..1\", \".9.123456789\"})\n+    public void invalidAliasTest(final String alias) {\n+        final X509Certificate[] certs = km.getCertificateChain(alias);\n+        final PrivateKey priv = km.getPrivateKey(alias);\n+\n+        Asserts.assertNull(certs,\n+                String.format(\n+                        \"Should return null if the alias is invalid <%s>\",\n+                        alias));\n+        Asserts.assertNull(priv,\n+                String.format(\n+                        \"Should return null if the alias is invalid <%s>\",\n+                        alias));\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/NullCases.java","additions":177,"deletions":35,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.X509KeyManager;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreSpi;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.cert.Certificate;\n+import java.util.ConcurrentModificationException;\n+import java.util.Date;\n+import java.util.Enumeration;\n+\n+\/*\n+ * @test\n+ * @bug 8369995\n+ * @summary X509KeyManagerImpl negative tests causing exceptions\n+ * @library \/test\/lib\n+ * @run junit\/othervm X509KeyManagerNegativeTests\n+ *\/\n+public class X509KeyManagerNegativeTests {\n+    private static X509KeyManager exceptionThrowingKM;\n+\n+    @BeforeAll\n+    public static void beforeAll() throws Exception {\n+\n+        \/\/ initialising exception throwing ks\n+        \/\/ cleaned up after the tests are complete\n+        final KeyManagerFactory exceptionThrowingKMF =\n+                KeyManagerFactory.getInstance(\"NewSunX509\");\n+\n+        \/\/ adding dummy provider\n+        Security.addProvider(new MyCustomKSProvider());\n+        final KeyStore exceptionThrowingKS =\n+                KeyStore.getInstance(\"MyExceptionKS\");\n+        exceptionThrowingKS.load(null, null);\n+\n+        exceptionThrowingKMF\n+                .init(exceptionThrowingKS, null);\n+        exceptionThrowingKM =\n+                (X509KeyManager) exceptionThrowingKMF.getKeyManagers()[0];\n+    }\n+\n+    @AfterAll\n+    public static void cleanup() {\n+        \/\/ remove custom provider\n+        Security.removeProvider(\"MyCustomKSProvider\");\n+    }\n+\n+    @Test\n+    public void ksExceptionTest() {\n+        Asserts.assertThrows(ConcurrentModificationException.class,\n+                () -> exceptionThrowingKM.getCertificateChain(\"RSA.0.0\"));\n+        Asserts.assertThrows(ConcurrentModificationException.class,\n+                () -> exceptionThrowingKM.getPrivateKey(\"RSA.0.0\"));\n+    }\n+\n+    public static class MyCustomKSProvider extends Provider {\n+        public MyCustomKSProvider() {\n+            super(\"MyCustomKSProvider\",\n+                    \"1.0\",\n+                    \"My Custom KS Provider\");\n+            put(\"KeyStore.MyExceptionKS\", MyExceptionKS.class.getName());\n+        }\n+    }\n+\n+    public static class MyExceptionKS extends KeyStoreSpi {\n+\n+        @Override\n+        public KeyStore.Entry engineGetEntry(String alias,\n+                                             KeyStore.ProtectionParameter param)\n+        {\n+            throw new ConcurrentModificationException(\"getEntry exception\");\n+        }\n+\n+        @Override\n+        public Key engineGetKey(String alias, char[] password) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Certificate[] engineGetCertificateChain(String alias) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Certificate engineGetCertificate(String alias) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Date engineGetCreationDate(String alias) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> engineAliases() {\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean engineContainsAlias(String alias) {\n+            return false;\n+        }\n+\n+        @Override\n+        public int engineSize() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public boolean engineIsKeyEntry(String alias) {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean engineIsCertificateEntry(String alias) {\n+            return false;\n+        }\n+\n+        @Override\n+        public String engineGetCertificateAlias(Certificate cert) {\n+            return null;\n+        }\n+\n+        @Override\n+        public void engineStore(OutputStream stream, char[] password) {\n+        }\n+\n+        @Override\n+        public void engineLoad(InputStream stream, char[] password) {\n+        }\n+\n+        @Override\n+        public void engineSetKeyEntry(String alias,\n+                                      Key key,\n+                                      char[] password,\n+                                      Certificate[] chain) {\n+        }\n+\n+        @Override\n+        public void engineSetKeyEntry(String alias,\n+                                      byte[] key,\n+                                      Certificate[] chain) {\n+        }\n+\n+        @Override\n+        public void engineSetCertificateEntry(String alias,\n+                                              Certificate cert) {\n+        }\n+\n+        @Override\n+        public void engineDeleteEntry(String alias) {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/X509KeyManagerNegativeTests.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"}]}