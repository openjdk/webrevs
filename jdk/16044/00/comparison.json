{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n@@ -30,0 +31,1 @@\n+import jdk.internal.util.DateTimeUtils;\n@@ -36,0 +38,2 @@\n+import java.time.*;\n+import java.util.Date;\n@@ -144,0 +148,103 @@\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long mix(long lengthCoder, LocalDate value) {\n+        return checkOverflow(lengthCoder + DateTimeUtils.stringSize(value));\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long mix(long lengthCoder, LocalTime value) {\n+        return checkOverflow(lengthCoder + DateTimeUtils.stringSize(value));\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long mix(long lengthCoder, LocalDateTime value) {\n+        return checkOverflow(lengthCoder + DateTimeUtils.stringSize(value));\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long mix(long lengthCoder, Instant value) {\n+        return checkOverflow(lengthCoder + DateTimeUtils.stringSize(value));\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long mix(long lengthCoder, OffsetTime value) {\n+        return checkOverflow(lengthCoder + DateTimeUtils.stringSize(value));\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long mix(long lengthCoder, OffsetDateTime value) {\n+        return checkOverflow(lengthCoder + DateTimeUtils.stringSize(value));\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long mix(long lengthCoder, ZonedDateTime value) {\n+        return checkOverflow(lengthCoder + DateTimeUtils.stringSize(value));\n+    }\n+\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     * @since 22\n+     *\/\n+    static long mix(long lengthCoder, Date value) {\n+        return checkOverflow(lengthCoder + DateTimeUtils.stringSize(value));\n+    }\n+\n@@ -389,0 +496,293 @@\n+    \/**\n+     * Prepends the stringly representation of LocalDate value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      LocalDate value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    private static long prepend(long indexCoder, byte[] buf, LocalDate value) {\n+        indexCoder -= DateTimeUtils.stringSize(value);\n+        if (indexCoder < UTF16) {\n+            DateTimeUtils.getCharsLatin1(buf, (int)indexCoder, value);\n+        } else {\n+            DateTimeUtils.getCharsUTF16(buf, (int)indexCoder, value);\n+        }\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      LocalDate value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static long prepend(long indexCoder, byte[] buf, LocalDate value, String prefix) {\n+        indexCoder = prepend(indexCoder, buf, value);\n+        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of LocalTime value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      LocalTime value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    private static long prepend(long indexCoder, byte[] buf, LocalTime value) {\n+        indexCoder -= DateTimeUtils.stringSize(value);\n+        if (indexCoder < UTF16) {\n+            DateTimeUtils.getCharsLatin1(buf, (int)indexCoder, value);\n+        } else {\n+            DateTimeUtils.getCharsUTF16(buf, (int)indexCoder, value);\n+        }\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      LocalTime value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static long prepend(long indexCoder, byte[] buf, LocalTime value, String prefix) {\n+        indexCoder = prepend(indexCoder, buf, value);\n+        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of LocalDateTime value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      LocalDateTime value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    private static long prepend(long indexCoder, byte[] buf, LocalDateTime value) {\n+        indexCoder -= DateTimeUtils.stringSize(value);\n+        if (indexCoder < UTF16) {\n+            DateTimeUtils.getCharsLatin1(buf, (int)indexCoder, value);\n+        } else {\n+            DateTimeUtils.getCharsUTF16(buf, (int)indexCoder, value);\n+        }\n+        return indexCoder;\n+    }\n+\n+    static long prepend(long indexCoder, byte[] buf, LocalDateTime value, String prefix) {\n+        indexCoder = prepend(indexCoder, buf, value);\n+        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of Instant value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      Instant value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    private static long prepend(long indexCoder, byte[] buf, Instant value) {\n+        indexCoder -= DateTimeUtils.stringSize(value);\n+        if (indexCoder < UTF16) {\n+            DateTimeUtils.getCharsLatin1(buf, (int)indexCoder, value);\n+        } else {\n+            DateTimeUtils.getCharsUTF16(buf, (int)indexCoder, value);\n+        }\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      Instant value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static long prepend(long indexCoder, byte[] buf, Instant value, String prefix) {\n+        indexCoder = prepend(indexCoder, buf, value);\n+        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of OffsetTime value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      OffsetTime value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static long prepend(long indexCoder, byte[] buf, OffsetTime value) {\n+        indexCoder = prepend(indexCoder, buf, value.getOffset().getId());\n+        LocalTime time = value.toLocalTime();\n+        indexCoder -= DateTimeUtils.stringSize(time);\n+        if (indexCoder < UTF16) {\n+            DateTimeUtils.getCharsLatin1(buf, (int)indexCoder, time);\n+        } else {\n+            DateTimeUtils.getCharsUTF16(buf, (int)indexCoder, time);\n+        }\n+\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      OffsetTime value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static long prepend(long indexCoder, byte[] buf, OffsetTime value, String prefix) {\n+        indexCoder = prepend(indexCoder, buf, value);\n+        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of OffsetDateTime value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      OffsetDateTime value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    private static long prepend(long indexCoder, byte[] buf, OffsetDateTime value) {\n+        indexCoder = prepend(indexCoder, buf, value.getOffset().getId());\n+        LocalDateTime dateTime = value.toLocalDateTime();\n+        indexCoder -= DateTimeUtils.stringSize(dateTime);\n+        if (indexCoder < UTF16) {\n+            DateTimeUtils.getCharsLatin1(buf, (int)indexCoder, dateTime);\n+        } else {\n+            DateTimeUtils.getCharsUTF16(buf, (int)indexCoder, dateTime);\n+        }\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      OffsetDateTime value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static long prepend(long indexCoder, byte[] buf, OffsetDateTime value, String prefix) {\n+        indexCoder = prepend(indexCoder, buf, value);\n+        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of ZonedDateTime value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      ZonedDateTime value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    private static long prepend(long indexCoder, byte[] buf, ZonedDateTime value) {\n+        ZoneOffset offset = value.getOffset();\n+        ZoneId zone = value.getZone();\n+        if (offset != zone) {\n+            indexCoder = prepend(indexCoder, buf, ']');\n+            indexCoder = prepend(indexCoder, buf, zone.toString());\n+            indexCoder = prepend(indexCoder, buf, '[');\n+        }\n+        indexCoder = prepend(indexCoder, buf, offset.getId());\n+        indexCoder = prepend(indexCoder, buf, value.toLocalDateTime());\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      ZonedDateTime value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static long prepend(long indexCoder, byte[] buf, ZonedDateTime value, String prefix) {\n+        indexCoder = prepend(indexCoder, buf, value);\n+        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends the stringly representation of Date value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      Date value to encode\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static long prepend(long indexCoder, byte[] buf, Date value) {\n+        indexCoder -= (DateTimeUtils.stringSize(value));\n+        if (indexCoder < UTF16) {\n+            DateTimeUtils.getCharsLatin1(buf, (int)indexCoder, value);\n+        } else {\n+            DateTimeUtils.getCharsUTF16(buf, (int)indexCoder, value);\n+        }\n+        return indexCoder;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      Date value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     *\/\n+    static long prepend(long indexCoder, byte[] buf, Date value, String prefix) {\n+        indexCoder = prepend(indexCoder, buf, value);\n+        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        return indexCoder;\n+    }\n+\n@@ -547,0 +947,6 @@\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static boolean isLatin1(long indexCoder) {\n+        return indexCoder < UTF16;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":406,"deletions":0,"binary":false,"changes":406,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-    private static void writeDigitPair(byte[] buf, int charPos, int value) {\n+    static void writeDigitPair(byte[] buf, int charPos, int value) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1773,1 +1773,1 @@\n-    private static void putPair(byte[] buf, int charPos, int v) {\n+    static void putPair(byte[] buf, int charPos, int v) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2490,0 +2490,3 @@\n+            public void putCharUTF16(byte[] bytes, int index, int ch) {\n+                StringUTF16.putChar(bytes, index, ch);\n+            }\n@@ -2530,0 +2533,4 @@\n+            public boolean stringConcatHelpeIsLatin1(long lengthCoder) {\n+                return StringConcatHelper.isLatin1(lengthCoder);\n+            }\n+\n@@ -2555,0 +2562,20 @@\n+            public int stringSize(int i) {\n+                return Integer.stringSize(i);\n+            }\n+\n+            public int getCharsLatin1(long i, int index, byte[] buf) {\n+                return StringLatin1.getChars(i, index, buf);\n+            }\n+\n+            public int getCharsUTF16(long i, int index, byte[] buf) {\n+                return StringUTF16.getChars(i, index, buf);\n+            }\n+\n+            public void writeDigitPairLatin1(byte[] buf, int charPos, int value) {\n+                StringLatin1.writeDigitPair(buf, charPos, value);\n+            }\n+\n+            public void writeDigitPairUTF16(byte[] buf, int charPos, int value) {\n+                StringUTF16.putPair(buf, charPos, value);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.time.*;\n@@ -37,0 +38,1 @@\n+import java.util.Date;\n@@ -745,1 +747,9 @@\n-            TYPE_COUNT = 6;\n+            LOCAL_DATE_IDX = 6,\n+            LOCAL_TIME_IDX = 7,\n+            LOCAL_DATE_TIME_IDX = 8,\n+            INSTANT_IDX = 9,\n+            OFFSET_TIME_IDX = 10,\n+            OFFSET_DATE_TIME_IDX = 11,\n+            ZONED_DATE_TIME_IDX = 12,\n+            DATE_IDX = 13,\n+            TYPE_COUNT = 14;\n@@ -753,0 +763,8 @@\n+        if (cl == LocalDate.class)                       return LOCAL_DATE_IDX;\n+        if (cl == LocalTime.class)                       return LOCAL_TIME_IDX;\n+        if (cl == LocalDateTime.class)                   return LOCAL_DATE_TIME_IDX;\n+        if (cl == Instant.class)                         return INSTANT_IDX;\n+        if (cl == OffsetTime.class)                      return OFFSET_TIME_IDX;\n+        if (cl == OffsetDateTime.class)                  return OFFSET_DATE_TIME_IDX;\n+        if (cl == ZonedDateTime.class)                   return ZONED_DATE_TIME_IDX;\n+        if (cl == Date.class)                            return DATE_IDX;\n@@ -1101,0 +1119,8 @@\n+            boolean dt = ptype == LocalDate.class\n+                    || ptype == LocalTime.class\n+                    || ptype == LocalDateTime.class\n+                    || ptype == Instant.class\n+                    || ptype == OffsetTime.class\n+                    || ptype == OffsetDateTime.class\n+                    || ptype == ZonedDateTime.class\n+                    || ptype == Date.class;\n@@ -1103,1 +1129,2 @@\n-                             isFormatConcatItem ? FormatConcatItem.class : Object.class;\n+                             isFormatConcatItem ? FormatConcatItem.class :\n+                             dt ? ptype : Object.class;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.internal.access.JavaUtilDateAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -1380,0 +1382,9 @@\n+\n+    private static class JavaUtilDateAccessImpl implements JavaUtilDateAccess {\n+        public BaseCalendar.Date normalize(Date date) {\n+            return date.normalize();\n+        }\n+    }\n+    static {\n+        SharedSecrets.setJavaUtilDateAccess(new JavaUtilDateAccessImpl());\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Date.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import static java.util.Formatter.DateTime.*;\n@@ -33,0 +34,1 @@\n+import java.time.*;\n@@ -37,0 +39,1 @@\n+import jdk.internal.access.JavaUtilDateAccess;\n@@ -39,0 +42,1 @@\n+import jdk.internal.util.DateTimeUtils;\n@@ -43,0 +47,2 @@\n+import sun.util.calendar.BaseCalendar;\n+\n@@ -56,0 +62,1 @@\n+    private static final JavaUtilDateAccess JDA = SharedSecrets.getJavaUtilDateAccess();\n@@ -118,0 +125,4 @@\n+    private static boolean isLatin1(long lengthCoder) {\n+        return JLA.stringConcatHelpeIsLatin1(lengthCoder);\n+    }\n+\n@@ -540,0 +551,296 @@\n+\n+    static final class FormatItemLocalDate implements FormatConcatItem {\n+        final char c;\n+        final LocalDate value;\n+        FormatItemLocalDate(char c, LocalDate value) {\n+            this.c = c;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            int size = switch (c) {\n+                case DATE -> 8;\n+                case ISO_STANDARD_DATE -> DateTimeUtils.yearSize(value.getYear()) + 6;\n+                default -> throw new UnknownFormatConversionException(\"Unsupported field: \" + c);\n+            };\n+            return lengthCoder + size;\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            boolean latin1 = isLatin1(lengthCoder);\n+            switch (c) {\n+                case DATE: {\n+                    lengthCoder -= 8;\n+                    int off = (int) lengthCoder;\n+                    int year = value.getYear(), month = value.getMonthValue(), dayOfMonth = value.getDayOfMonth();\n+                    if (latin1) {\n+                        getDateCharsLatin1(buffer, off, year, month, dayOfMonth);\n+                    } else {\n+                        getDateCharsUTF16(buffer, off, year, month, dayOfMonth);\n+                    }\n+                    break;\n+                }\n+                case ISO_STANDARD_DATE: {\n+                    lengthCoder -= DateTimeUtils.yearSize(value.getYear()) + 6;\n+                    int off = (int) lengthCoder;\n+                    if (latin1) {\n+                        DateTimeUtils.getCharsLatin1(buffer, off, value);\n+                    } else {\n+                        DateTimeUtils.getCharsUTF16(buffer, off, value);\n+                    }\n+                    break;\n+                }\n+                default:\n+                    throw new UnknownFormatConversionException(\"Unsupported field: \" + c);\n+            }\n+            return lengthCoder;\n+        }\n+    }\n+\n+    static final class FormatItemLocalTime implements FormatConcatItem {\n+        final char c;\n+        final LocalTime value;\n+\n+        FormatItemLocalTime(char c, LocalTime value) {\n+            this.c = c;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            int size = switch (c) {\n+                case TIME         -> 8;\n+                case TIME_12_HOUR -> 11;\n+                case TIME_24_HOUR -> 5;\n+                default -> throw new UnknownFormatConversionException(\"Unsupported field: \" + c);\n+            };\n+            return lengthCoder + size;\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            boolean latin1 = isLatin1(lengthCoder);\n+            return switch (c) {\n+                case TIME         -> prependTime(lengthCoder, buffer, latin1, value);\n+                case TIME_12_HOUR -> prependTime12Hour(lengthCoder, buffer, latin1, value);\n+                case TIME_24_HOUR -> prependTime24Hour(lengthCoder, buffer, latin1, value);\n+                default -> throw new UnknownFormatConversionException(\"Unsupported field: \" + c);\n+            };\n+        }\n+\n+        static long prependTime(long lengthCoder, byte[] buffer, boolean latin1, LocalTime value) {\n+            lengthCoder -= 8;\n+            int off = (int) lengthCoder;\n+            int hour   = value.getHour(),\n+                minute = value.getMinute(),\n+                second = value.getSecond();\n+            if (latin1) {\n+                DateTimeUtils.getLocalTimeCharsLatin1(buffer, off, hour, minute, second);\n+            } else {\n+                DateTimeUtils.getLocalTimeCharsUTF16(buffer, off, hour, minute, second);\n+            }\n+            return lengthCoder;\n+        }\n+\n+        static long prependTime12Hour(long lengthCoder, byte[] buffer, boolean latin1, LocalTime value) {\n+            lengthCoder -= 11;\n+            int off = (int) lengthCoder;\n+            int hour   = value.getHour(),\n+                minute = value.getMinute(),\n+                second = value.getSecond();\n+            if (latin1) {\n+                getTime12HourCharsLatin1(buffer, off, hour, minute, second);\n+            } else {\n+                getTime12HourCharsUTF16(buffer, off, hour, minute, second);\n+            }\n+            return lengthCoder;\n+        }\n+\n+        static long prependTime24Hour(long lengthCoder, byte[] buffer, boolean latin1, LocalTime value) {\n+            lengthCoder -= 5;\n+            int off = (int) lengthCoder;\n+            int hour   = value.getHour(),\n+                minute = value.getMinute();\n+            if (latin1) {\n+                getTime24HourCharsLatin1(buffer, off, hour, minute);\n+            } else {\n+                getTime24HourCharsUTF16(buffer, off, hour, minute);\n+            }\n+            return lengthCoder;\n+        }\n+    }\n+\n+    static final class FormatItemDate implements FormatConcatItem {\n+        final char c;\n+        final Date value;\n+\n+        FormatItemDate(char c, Date value) {\n+            this.c = c;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            int size = switch (c) {\n+                case TIME_12_HOUR      -> 11;\n+                case TIME_24_HOUR      -> 5;\n+                case TIME, DATE        -> 8;\n+                case DATE_TIME         -> DateTimeUtils.stringSize(value);\n+                case ISO_STANDARD_DATE -> isoStandardDateSize(JDA.normalize(value));\n+                default -> throw new UnknownFormatConversionException(\"Unsupported field: \" + c);\n+            };\n+            return lengthCoder + size;\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) {\n+            boolean latin1 = isLatin1(lengthCoder);\n+            BaseCalendar.Date date = JDA.normalize(value);\n+            return switch (c) {\n+                case TIME              -> prependTime(lengthCoder, buffer, latin1, date);\n+                case TIME_12_HOUR      -> prependTime12Hour(lengthCoder, buffer, latin1, date);\n+                case TIME_24_HOUR      -> prependTime24Hour(lengthCoder, buffer, latin1, date);\n+                case DATE              -> prependDate(lengthCoder, buffer, latin1, date);\n+                case DATE_TIME         -> prependDateTime(lengthCoder, buffer, latin1, date);\n+                case ISO_STANDARD_DATE -> prependISODate(lengthCoder, buffer, latin1, date);\n+                default -> throw new UnknownFormatConversionException(\"Unsupported field: \" + c);\n+            };\n+        }\n+\n+        static int isoStandardDateSize(BaseCalendar.Date value) {\n+            return Math.max(4, JLA.stringSize(value.getYear())) + 6;\n+        }\n+\n+        static long prependDate(long lengthCoder, byte[] buffer, boolean latin1, BaseCalendar.Date date) {\n+            lengthCoder -= 8;\n+            int off = (int) lengthCoder;\n+            int year       = date.getYear(),\n+                month      = date.getMonth(),\n+                dayOfMonth = date.getDayOfMonth();\n+            if (latin1) {\n+                getDateCharsLatin1(buffer, off, year, month, dayOfMonth);\n+            } else {\n+                getDateCharsUTF16(buffer, off, year, month, dayOfMonth);\n+            }\n+            return lengthCoder;\n+        }\n+\n+        static long prependISODate(long lengthCoder, byte[] buffer, boolean latin1, BaseCalendar.Date date) {\n+            lengthCoder -= isoStandardDateSize(date);\n+            int off = (int) lengthCoder;\n+            if (latin1) {\n+                DateTimeUtils.getDateCharsLatin1(buffer, off, date);\n+            } else {\n+                DateTimeUtils.getDateCharsUTF16(buffer, off, date);\n+            }\n+            return lengthCoder;\n+        }\n+\n+        static long prependTime(long lengthCoder, byte[] buffer, boolean latin1, BaseCalendar.Date date) {\n+            lengthCoder -= 8;\n+            int off = (int) lengthCoder;\n+            int hour   = date.getHours(),\n+                minute = date.getMinutes(),\n+                second = date.getSeconds();\n+            if (latin1) {\n+                DateTimeUtils.getLocalTimeCharsLatin1(buffer, off, hour, minute, second);\n+            } else {\n+                DateTimeUtils.getLocalTimeCharsUTF16(buffer, off, hour, minute, second);\n+            }\n+            return lengthCoder;\n+        }\n+\n+        static long prependTime12Hour(long lengthCoder, byte[] buffer, boolean latin1, BaseCalendar.Date date) {\n+            lengthCoder -= 11;\n+            int off = (int) lengthCoder;\n+            int hour   = date.getHours(),\n+                minute = date.getMinutes(),\n+                second = date.getSeconds();\n+            if (latin1) {\n+                getTime12HourCharsLatin1(buffer, off, hour, minute, second);\n+            } else {\n+                getTime12HourCharsUTF16(buffer, off, hour, minute, second);\n+            }\n+            return lengthCoder;\n+        }\n+\n+        static long prependTime24Hour(long lengthCoder, byte[] buffer, boolean latin1, BaseCalendar.Date date) {\n+            lengthCoder -= 5;\n+            int off = (int) lengthCoder;\n+            int hour   = date.getHours(),\n+                minute = date.getMinutes();\n+            if (latin1) {\n+                getTime24HourCharsLatin1(buffer, off, hour, minute);\n+            } else {\n+                getTime24HourCharsUTF16(buffer, off, hour, minute);\n+            }\n+            return lengthCoder;\n+        }\n+\n+        static long prependDateTime(long lengthCoder, byte[] buffer, boolean latin1, BaseCalendar.Date date) {\n+            lengthCoder -= DateTimeUtils.stringSize(date);\n+            int off = (int) lengthCoder;\n+            if (latin1) {\n+                DateTimeUtils.getCharsLatin1(buffer, off, date);\n+            } else {\n+                DateTimeUtils.getCharsUTF16(buffer, off, date);\n+            }\n+            return lengthCoder;\n+        }\n+    }\n+\n+    private static void getDateCharsLatin1(byte[] buffer, int off, int year, int month, int dayOfMonth) {\n+        JLA.writeDigitPairLatin1(buffer, off, month);\n+        buffer[off + 2] = '\/';\n+        JLA.writeDigitPairLatin1(buffer, off + 3, dayOfMonth);\n+        buffer[off + 5] = '\/';\n+        JLA.writeDigitPairLatin1(buffer, off + 6, year % 100);\n+    }\n+\n+    private static void getDateCharsUTF16(byte[] buffer, int off, int year, int month, int dayOfMonth) {\n+        JLA.writeDigitPairUTF16(buffer, off, month);\n+        JLA.putCharUTF16(buffer, off + 2, '\/');\n+        JLA.writeDigitPairUTF16(buffer, off + 3, dayOfMonth);\n+        JLA.putCharUTF16(buffer, off + 5, '\/');\n+        JLA.writeDigitPairUTF16(buffer, off + 6, year % 100);\n+    }\n+\n+    private static void getTime24HourCharsLatin1(byte[] buffer, int off, int hour, int minute) {\n+        JLA.writeDigitPairLatin1(buffer, off, hour);\n+        buffer[off + 2] = ':';\n+        JLA.writeDigitPairLatin1(buffer, off + 3, minute);\n+    }\n+\n+    private static void getTime24HourCharsUTF16(byte[] buffer, int off, int hour, int minute) {\n+        JLA.writeDigitPairUTF16(buffer, off, hour);\n+        JLA.putCharUTF16(buffer, off + 2, ':');\n+        JLA.writeDigitPairUTF16(buffer, off + 3, minute);\n+    }\n+\n+    private static void getTime12HourCharsLatin1(byte[] buffer, int off, int hour, int minute, int second) {\n+        int h12 = hour == 0 ? 12\n+                : hour > 12 ? hour - 12 : hour;\n+        JLA.writeDigitPairLatin1(buffer, off, h12);\n+        buffer[off + 2] = ':';\n+        JLA.writeDigitPairLatin1(buffer, off + 3, minute);\n+        buffer[off + 5] = ':';\n+        JLA.writeDigitPairLatin1(buffer, off + 6, second);\n+        buffer[off + 8] = ' ';\n+        buffer[off + 9] = (byte) (hour < 12 ? 'A' : 'P');\n+        buffer[off + 10] = 'M';\n+    }\n+\n+    private static void getTime12HourCharsUTF16(byte[] buffer, int off, int hour, int minute, int second) {\n+        int h12 = hour == 0 ? 12\n+                : hour > 12 ? hour - 12 : hour;\n+        JLA.writeDigitPairUTF16(buffer, off, h12);\n+        JLA.putCharUTF16(buffer, off + 2, ':');\n+        JLA.writeDigitPairUTF16(buffer, off + 3, minute);\n+        JLA.putCharUTF16(buffer, off + 5, ':');\n+        JLA.writeDigitPairUTF16(buffer, off + 6, second);\n+        JLA.putCharUTF16(buffer, off + 8, ' ');\n+        JLA.putCharUTF16(buffer, off + 9, hour < 12 ? 'A' : 'P');\n+        JLA.putCharUTF16(buffer, off + 10, 'M');\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n@@ -35,0 +36,1 @@\n+import java.time.*;\n@@ -37,0 +39,1 @@\n+import java.util.Date;\n@@ -83,1 +86,10 @@\n-        return type.isPrimitive() || type == String.class ? type : Object.class;\n+        return type.isPrimitive() || type == String.class\n+                || type == LocalDate.class\n+                || type == LocalDateTime.class\n+                || type == LocalTime.class\n+                || type == Instant.class\n+                || type == OffsetTime.class\n+                || type == OffsetDateTime.class\n+                || type == ZonedDateTime.class\n+                || type == Date.class\n+                ? type : Object.class;\n@@ -169,0 +181,12 @@\n+    private static final MethodHandle FILocalDate_MH =\n+            findStringConcatItemConstructor(FormatItemLocalDate.class,\n+                    char.class, LocalDate.class);\n+\n+    private static final MethodHandle FILocalTime_MH =\n+            findStringConcatItemConstructor(FormatItemLocalTime.class,\n+                    char.class, LocalTime.class);\n+\n+    private static final MethodHandle FIDate_MH =\n+            findStringConcatItemConstructor(FormatItemDate.class,\n+                    char.class, Date.class);\n+\n@@ -185,0 +209,21 @@\n+    private static final MethodHandle ToLocalDate_LDT_MH =\n+            findMethod(LocalDateTime.class, \"toLocalDate\", LocalDate.class);\n+\n+    private static final MethodHandle ToLocalDate_ZDT_MH =\n+            findMethod(ZonedDateTime.class, \"toLocalDate\", LocalDate.class);\n+\n+    private static final MethodHandle ToLocalDate_ODT_MH =\n+            findMethod(OffsetDateTime.class, \"toLocalDate\", LocalDate.class);\n+\n+    private static final MethodHandle ToLocalTime_LDT_MH =\n+            findMethod(LocalDateTime.class, \"toLocalTime\", LocalTime.class);\n+\n+    private static final MethodHandle ToLocalTime_ZDT_MH =\n+            findMethod(ZonedDateTime.class, \"toLocalTime\", LocalTime.class);\n+\n+    private static final MethodHandle ToLocalTime_ODT_MH =\n+            findMethod(OffsetDateTime.class, \"toLocalTime\", LocalTime.class);\n+\n+    private static final MethodHandle ToLocalTime_OT_MH =\n+            findMethod(OffsetTime.class, \"toLocalTime\", LocalTime.class);\n+\n@@ -284,1 +329,10 @@\n-                    if (isPrimitive || ptype == String.class) {\n+                    if (isPrimitive\n+                            || ptype == String.class\n+                            || ptype == LocalDate.class\n+                            || ptype == LocalDateTime.class\n+                            || ptype == LocalTime.class\n+                            || ptype == OffsetTime.class\n+                            || ptype == OffsetDateTime.class\n+                            || ptype == ZonedDateTime.class\n+                            || ptype == Instant.class\n+                            || ptype == Date.class) {\n@@ -378,0 +432,126 @@\n+            case DATE_TIME -> {\n+                if (flags == 0 && isGenericDFS && width == -1) {\n+                    char c = fs.c;\n+                    if (c == DateTime.ISO_STANDARD_DATE && itype == LocalDate.class) {\n+                        return null;\n+                    }\n+\n+                    switch (c) {\n+                        case DateTime.DATE:\n+                        case DateTime.ISO_STANDARD_DATE: {\n+                            if (itype == LocalDate.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(\n+                                        mh,\n+                                        insertArguments(FILocalDate_MH, 0, c));\n+                            } else if (itype == LocalDateTime.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(\n+                                        mh,\n+                                        insertArguments(\n+                                                filterArguments(\n+                                                        FILocalDate_MH,\n+                                                        1,\n+                                                        ToLocalDate_LDT_MH),\n+                                                0,\n+                                                c));\n+                            } else if (itype == OffsetDateTime.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(\n+                                        mh,\n+                                        insertArguments(\n+                                                filterArguments(\n+                                                        FILocalDate_MH,\n+                                                        1,\n+                                                        ToLocalDate_ODT_MH),\n+                                                0,\n+                                                c));\n+                            } else if (itype == ZonedDateTime.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(\n+                                        mh,\n+                                        insertArguments(\n+                                                filterArguments(\n+                                                        FILocalDate_MH,\n+                                                        1,\n+                                                        ToLocalDate_ZDT_MH),\n+                                                0,\n+                                                c));\n+                            } else if (itype == Date.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(mh,\n+                                        insertArguments(FIDate_MH, 0, c));\n+                            }\n+                            break;\n+                        }\n+                        case DateTime.TIME_12_HOUR:\n+                        case DateTime.TIME_24_HOUR:\n+                        case DateTime.TIME: {\n+                            if (itype == LocalTime.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(mh,\n+                                        insertArguments(FILocalTime_MH, 0, c));\n+                            } else if (itype == LocalDateTime.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(\n+                                        mh,\n+                                        insertArguments(\n+                                                filterArguments(\n+                                                        FILocalTime_MH,\n+                                                        1,\n+                                                        ToLocalTime_LDT_MH),\n+                                                0,\n+                                                c));\n+                            } else if (itype == OffsetDateTime.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(\n+                                        mh,\n+                                        insertArguments(\n+                                                filterArguments(\n+                                                        FILocalTime_MH,\n+                                                        1,\n+                                                        ToLocalTime_ODT_MH),\n+                                                0,\n+                                                c));\n+                            } else if (itype == ZonedDateTime.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(\n+                                        mh,\n+                                        insertArguments(\n+                                                filterArguments(\n+                                                        FILocalTime_MH,\n+                                                        1,\n+                                                        ToLocalTime_ZDT_MH),\n+                                                0,\n+                                                c));\n+                            } else if (itype == OffsetTime.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(\n+                                        mh,\n+                                        insertArguments(\n+                                                filterArguments(\n+                                                        FILocalTime_MH,\n+                                                        1,\n+                                                        ToLocalTime_OT_MH),\n+                                                0,\n+                                                c));\n+                            } else if (itype == Date.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(mh,\n+                                        insertArguments(FIDate_MH, 0, c));\n+                            }\n+                            break;\n+                        }\n+                        case DateTime.DATE_TIME: {\n+                            if (itype == Date.class) {\n+                                handled = true;\n+                                mh = filterReturnValue(mh,\n+                                        insertArguments(FIDate_MH, 0, c));\n+                            }\n+                            break;\n+                        }\n+                        default:\n+                            break;\n+                    }\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatterBuilder.java","additions":182,"deletions":2,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -361,0 +361,9 @@\n+    \/**\n+     * Put the char at index in a byte[] in internal UTF-16 representation,\n+     * with no bounds checks.\n+     *\n+     * @param bytes the UTF-16 encoded bytes\n+     * @param index of the char to retrieve, 0 <= index < (bytes.length >> 1)\n+     *\/\n+    void putCharUTF16(byte[] bytes, int index, int ch);\n+\n@@ -414,0 +423,5 @@\n+    \/**\n+     * Returns {@code true} if lengthCoder is Latin1\n+     *\/\n+    boolean stringConcatHelpeIsLatin1(long lengthCoder);\n+\n@@ -451,0 +465,47 @@\n+    \/**\n+     * Returns the string representation size for a given int value.\n+     *\n+     * @param x int value\n+     * @return string size\n+     *\n+     * @implNote There are other ways to compute this: e.g. binary search,\n+     * but values are biased heavily towards zero, and therefore linear search\n+     * wins. The iteration results are also routinely inlined in the generated\n+     * code after loop unrolling.\n+     *\/\n+    int stringSize(int i);\n+\n+    \/**\n+     * Places characters representing the integer i into the\n+     * character array buf. The characters are placed into\n+     * the buffer backwards starting with the least significant\n+     * digit at the specified index (exclusive), and working\n+     * backwards from there.\n+     *\n+     * @implNote This method converts positive inputs into negative\n+     * values, to cover the Integer.MIN_VALUE case. Converting otherwise\n+     * (negative to positive) will expose -Integer.MIN_VALUE that overflows\n+     * integer.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, Latin1-encoded\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    int getCharsLatin1(long i, int index, byte[] buf);\n+\n+    \/**\n+     * This is a variant of {@link StringLatin1#getChars(int, int, byte[])}, but for\n+     * UTF-16 coder.\n+     *\n+     * @param i     value to convert\n+     * @param index next index, after the least significant digit\n+     * @param buf   target buffer, UTF16-coded.\n+     * @return index of the most significant digit or minus sign, if present\n+     *\/\n+    int getCharsUTF16(long i, int index, byte[] buf);\n+\n+    void writeDigitPairLatin1(byte[] buf, int charPos, int value);\n+\n+    void writeDigitPairUTF16(byte[] buf, int charPos, int value);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import java.util.Date;\n+import sun.util.calendar.BaseCalendar;\n+\n+public interface JavaUtilDateAccess {\n+    BaseCalendar.Date normalize(Date date);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilDateAccess.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -83,0 +83,1 @@\n+    private static JavaUtilDateAccess javaUtilDateAccess;\n@@ -152,0 +153,15 @@\n+    public static JavaUtilDateAccess getJavaUtilDateAccess() {\n+        var access = javaUtilDateAccess;\n+        if (access == null) {\n+            \/\/ Ensure Date is initialized; we know that this class\n+            \/\/ provides the shared secret\n+            ensureClassInitialized(java.util.Date.class);\n+            access = javaUtilDateAccess;\n+        }\n+        return access;\n+    }\n+\n+    public static void setJavaUtilDateAccess(JavaUtilDateAccess javaUtilDateAccess) {\n+        SharedSecrets.javaUtilDateAccess = javaUtilDateAccess;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,508 @@\n+\/*\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.time.*;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaUtilDateAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import sun.util.calendar.BaseCalendar;\n+\n+\/**\n+ * DateTimeUtils\n+ *\n+ * @since 21\n+ *\/\n+public final class DateTimeUtils {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    private static final JavaUtilDateAccess JDA = SharedSecrets.getJavaUtilDateAccess();\n+\n+    \/**\n+     * Constructor.\n+     *\/\n+    private DateTimeUtils() {\n+    }\n+\n+    \/**\n+     * Hours per day.\n+     *\/\n+    static final int HOURS_PER_DAY = 24;\n+    \/**\n+     * Minutes per hour.\n+     *\/\n+    static final int MINUTES_PER_HOUR = 60;\n+    \/**\n+     * Minutes per day.\n+     *\/\n+    static final int MINUTES_PER_DAY = MINUTES_PER_HOUR * HOURS_PER_DAY;\n+    \/**\n+     * Seconds per minute.\n+     *\/\n+    static final int SECONDS_PER_MINUTE = 60;\n+    \/**\n+     * Seconds per hour.\n+     *\/\n+    static final int SECONDS_PER_HOUR = SECONDS_PER_MINUTE * MINUTES_PER_HOUR;\n+    \/**\n+     * Seconds per day.\n+     *\/\n+    public static final int SECONDS_PER_DAY = SECONDS_PER_HOUR * HOURS_PER_DAY;\n+\n+    public static int yearSize(int year) {\n+        if (Math.abs(year) < 1000) {\n+            return year < 0 ? 5 : 4;\n+        }\n+        return JLA.stringSize(year) + (year > 9999 ? 1 : 0);\n+    }\n+\n+    public static int nanoSize(int nano) {\n+        if (nano == 0) {\n+            return 0;\n+        }\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        if (nano - div * 1000 != 0) {\n+            return 10;\n+        }\n+\n+        return (div - div2 * 1000 == 0) ? 4 : 7;\n+    }\n+\n+    public static void getCharsLatin1(byte[] buf, int off, LocalDate value) {\n+        getDateCharsLatin1(buf, off, value.getYear(), value.getMonthValue(), value.getDayOfMonth());\n+    }\n+\n+    public static void getCharsUTF16(byte[] buf, int off, LocalDate value) {\n+        getDateCharsUTF16(buf, off, value.getYear(), value.getMonthValue(), value.getDayOfMonth());\n+    }\n+\n+    public static void getDateCharsLatin1(byte[] buf, int off, int year, int month, int dayOfMonth) {\n+        int yearSize = yearSize(year);\n+        int yearAbs = Math.abs(year);\n+\n+        int yearEnd = off + yearSize;\n+        if (yearAbs < 1000) {\n+            if (year < 0) {\n+                buf[off++] = '-';\n+            }\n+            int y01 = yearAbs \/ 100;\n+            int y23 = yearAbs - y01 * 100;\n+\n+            JLA.writeDigitPairLatin1(buf, off, y01);\n+            JLA.writeDigitPairLatin1(buf, off + 2, y23);\n+        } else {\n+            if (year > 9999) {\n+                buf[off] = '+';\n+            }\n+            JLA.getCharsLatin1(year, yearEnd, buf);\n+        }\n+\n+        off = yearEnd;\n+        buf[off] = '-';\n+        JLA.writeDigitPairLatin1(buf, off + 1, month); \/\/ mm\n+        buf[off + 3] = '-';\n+        JLA.writeDigitPairLatin1(buf, off + 4, dayOfMonth); \/\/ dd\n+    }\n+\n+    public static void getDateCharsUTF16(byte[] buf, int off, int year, int month, int dayOfMonth) {\n+        int yearSize = yearSize(year);\n+        int yearAbs = Math.abs(year);\n+\n+        int yearEnd = off + yearSize;\n+        if (yearAbs < 1000) {\n+            if (year < 0) {\n+                JLA.putCharUTF16(buf, off++, '-');\n+            }\n+            int y01 = yearAbs \/ 100;\n+            int y23 = yearAbs - y01 * 100;\n+\n+            JLA.writeDigitPairUTF16(buf, off, y01);\n+            JLA.writeDigitPairUTF16(buf, off + 2, y23);\n+        } else {\n+            if (year > 9999) {\n+                JLA.putCharUTF16(buf, off, '+');\n+            }\n+            JLA.getCharsUTF16(year, yearEnd, buf);\n+        }\n+\n+        off = yearEnd;\n+        JLA.putCharUTF16(buf, off, '-');\n+        JLA.writeDigitPairUTF16(buf, off + 1, month);\n+        JLA.putCharUTF16(buf, off + 3, '-');\n+        JLA.writeDigitPairUTF16(buf, off + 4, dayOfMonth);\n+    }\n+\n+    public static void getCharsLatin1(byte[] buf, int off, LocalTime value) {\n+        getLocalTimeCharsLatin1(buf, off, value.getHour(), value.getMinute(), value.getSecond());\n+        getNanoCharsLatin1(buf, off + 8, value.getNano());\n+    }\n+\n+    public static void getLocalTimeCharsLatin1(byte[] buf, int off, int hour, int minute, int second) {\n+        JLA.writeDigitPairLatin1(buf, off, hour);\n+        buf[off + 2] = ':';\n+        JLA.writeDigitPairLatin1(buf, off + 3, minute);\n+        buf[off + 5] = ':';\n+        JLA.writeDigitPairLatin1(buf, off + 6, second);\n+    }\n+\n+    public static void getCharsUTF16(byte[] buf, int off, LocalTime value) {\n+        getLocalTimeCharsUTF16(buf, off, value.getHour(), value.getMinute(), value.getSecond());\n+        getNanoCharsUTF16(buf, off + 8, value.getNano());\n+    }\n+\n+    public static void getLocalTimeCharsUTF16(byte[] buf, int off, int hour, int minute, int second) {\n+        JLA.writeDigitPairUTF16(buf, off, hour);\n+        JLA.putCharUTF16(buf, off + 2, ':');\n+        JLA.writeDigitPairUTF16(buf, off + 3, minute);\n+        JLA.putCharUTF16(buf, off + 5, ':');\n+        JLA.writeDigitPairUTF16(buf, off + 6, second);\n+    }\n+\n+    public static void getCharsLatin1(byte[] buf, int off, Instant value) {\n+        long epochSecond = value.getEpochSecond();\n+        LocalDate date = LocalDate.ofEpochDay(Math.floorDiv(epochSecond, SECONDS_PER_DAY));\n+        LocalTime time = LocalTime.ofSecondOfDay(Math.floorMod(epochSecond, SECONDS_PER_DAY));\n+        int nano = value.getNano();\n+        int dateSize = stringSize(date);\n+        int timeSize = 8;\n+        getCharsLatin1(buf, off, date);\n+        off += dateSize;\n+        buf[off++] = 'T';\n+        getLocalTimeCharsLatin1(buf, off, time.getHour(), time.getMinute(), time.getSecond());\n+        off += timeSize;\n+        getNanoCharsLatin1(buf, off, nano);\n+        buf[off + nanoSize(nano)] = 'Z';\n+    }\n+\n+    public static void getCharsUTF16(byte[] buf, int off, Instant value) {\n+        long epochSecond = value.getEpochSecond();\n+        LocalDate date = LocalDate.ofEpochDay(Math.floorDiv(epochSecond, SECONDS_PER_DAY));\n+        LocalTime time = LocalTime.ofSecondOfDay(Math.floorMod(epochSecond, SECONDS_PER_DAY));\n+        int nano = value.getNano();\n+        int dateSize = stringSize(date);\n+        int timeSize = 8;\n+        getCharsUTF16(buf, off, date);\n+        off += dateSize;\n+        JLA.putCharUTF16(buf, off++, 'T');\n+        getLocalTimeCharsUTF16(buf, off, time.getHour(), time.getMinute(), time.getSecond());\n+        off += timeSize;\n+        getNanoCharsUTF16(buf, off, nano);\n+        JLA.putCharUTF16(buf, off + nanoSize(nano), 'Z');\n+    }\n+\n+    private static void getNanoCharsLatin1(byte[] buf, int off, int nano) {\n+        if (nano == 0) {\n+            return;\n+        }\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        int div2_k = div2 \/ 100;\n+        buf[off] = '.';\n+        buf[off + 1] = (byte) ('0' + div2_k);\n+        JLA.writeDigitPairLatin1(buf, off + 2, div2 - div2_k * 100);\n+        off += 4;\n+\n+        int rem1 = nano - div * 1000;\n+        int rem2;\n+        if (rem1 == 0) {\n+            rem2 = div - div2 * 1000;\n+            if (rem2 == 0) {\n+                return;\n+            }\n+        } else {\n+            rem2 = div - div2 * 1000;\n+        }\n+\n+        int rem2_k = rem2 \/ 100;\n+        buf[off] = (byte) ('0' + rem2_k);\n+        JLA.writeDigitPairLatin1(buf, off + 1, rem2 - rem2_k * 100);\n+        off += 3;\n+\n+        if (rem1 != 0) {\n+            int rem1_k = rem1 \/ 100;\n+            buf[off] = (byte) ('0' + rem1_k);\n+            JLA.writeDigitPairLatin1(buf, off + 1, rem1 - rem1_k * 100);\n+        }\n+    }\n+\n+    private static void getNanoCharsUTF16(byte[] buf, int off, int nano) {\n+        if (nano == 0) {\n+            return;\n+        }\n+\n+        int div = nano \/ 1000;\n+        int div2 = div \/ 1000;\n+\n+        int div2_k = div2 \/ 100;\n+        JLA.putCharUTF16(buf, off, '.');\n+        JLA.putCharUTF16(buf, off + 1, '0' + div2_k);\n+        JLA.writeDigitPairUTF16(buf, off + 2, div2 - div2_k * 100);\n+        off += 4;\n+\n+        int rem1 = nano - div * 1000;\n+        int rem2;\n+        if (rem1 == 0) {\n+            rem2 = div - div2 * 1000;\n+            if (rem2 == 0) {\n+                return;\n+            }\n+        } else {\n+            rem2 = div - div2 * 1000;\n+        }\n+\n+        int rem2_k = rem2 \/ 100;\n+        JLA.putCharUTF16(buf, off, '0' + rem2_k);\n+        JLA.writeDigitPairUTF16(buf, off + 1, rem2 - rem2_k * 100);\n+        off += 3;\n+\n+        if (rem1 != 0) {\n+            int rem1_k = rem1 \/ 100;\n+            JLA.putCharUTF16(buf, off, '0' + rem1_k);\n+            JLA.writeDigitPairUTF16(buf, off + 1, rem1 - rem1_k * 100);\n+        }\n+    }\n+\n+    public static int stringSize(LocalDate value) {\n+        return yearSize(value.getYear()) + 6;\n+    }\n+\n+    public static int stringSize(LocalTime value) {\n+        return nanoSize(value.getNano()) + 8;\n+    }\n+\n+    public static int stringSize(LocalDateTime value) {\n+        return yearSize(value.getYear()) + nanoSize(value.getNano()) + 15;\n+    }\n+\n+    public static int stringSize(OffsetDateTime value) {\n+        return stringSize(value.toLocalDateTime()) + value.getOffset().getId().length();\n+    }\n+\n+    public static int stringSize(OffsetTime value) {\n+        return stringSize(value.toLocalTime()) + value.getOffset().getId().length();\n+    }\n+\n+    public static int stringSize(ZonedDateTime value) {\n+        ZoneOffset offset = value.getOffset();\n+        int size = stringSize(value.toLocalDateTime()) + offset.getId().length();\n+        ZoneId zone = value.getZone();\n+        if (offset != zone) {\n+            size += zone.toString().length() + 2;\n+        }\n+        return size;\n+    }\n+\n+    public static int stringSize(Instant value) {\n+        LocalDate localDate = LocalDate.ofEpochDay(Math.floorDiv(value.getEpochSecond(), SECONDS_PER_DAY));\n+        return yearSize(localDate.getYear()) + 16 + nanoSize(value.getNano());\n+    }\n+\n+    public static void getCharsLatin1(byte[] buf, int off, LocalDateTime value) {\n+        int dateSize = yearSize(value.getYear()) + 6;\n+        int nanoSize = nanoSize(value.getNano());\n+\n+        getCharsLatin1(buf, off, value.toLocalDate());\n+        buf[off + dateSize] = 'T';\n+        getCharsLatin1(buf, off + dateSize + 1, value.toLocalTime());\n+    }\n+\n+    public static void getCharsUTF16(byte[] buf, int off, LocalDateTime value) {\n+        int dateSize = yearSize(value.getYear()) + 6;\n+        int nanoSize = nanoSize(value.getNano());\n+\n+        getCharsUTF16(buf, off, value.toLocalDate());\n+        JLA.putCharUTF16(buf, off + dateSize, 'T');\n+        getCharsUTF16(buf, off + dateSize + 1, value.toLocalTime());\n+    }\n+\n+    private static final byte[] wtb = {\n+            \/\/ weeks\n+            'S', 'u', 'n',\n+            'M', 'o', 'n',\n+            'T', 'u', 'e',\n+            'W', 'e', 'd',\n+            'T', 'h', 'u',\n+            'F', 'r', 'i',\n+            'S', 'a', 't',\n+\n+            \/\/ months\n+            'J', 'a', 'n',\n+            'F', 'e', 'b',\n+            'M', 'a', 'r',\n+            'A', 'p', 'r',\n+            'M', 'a', 'y',\n+            'J', 'u', 'n',\n+            'J', 'u', 'l',\n+            'A', 'u', 'g',\n+            'S', 'e', 'p',\n+            'O', 'c', 't',\n+            'N', 'o', 'v',\n+            'D', 'e', 'c',\n+    };\n+\n+    public static int yearSize(BaseCalendar.Date date) {\n+        return yearSize(\n+                date.getYear());\n+    }\n+\n+    public static int stringSize(Date date) {\n+        return stringSize(\n+                JDA.normalize(date));\n+    }\n+\n+    public static int stringSize(BaseCalendar.Date date) {\n+        return JLA.stringSize(date.getYear()) + 24;\n+    }\n+\n+    public static void getCharsLatin1(byte[] buf, int off, Date date) {\n+        getCharsLatin1(buf, off, JDA.normalize(date));\n+    }\n+\n+    public static void getCharsUTF16(byte[] buf, int off, Date date) {\n+        getCharsUTF16(buf, off, JDA.normalize(date));\n+    }\n+\n+    public static void getCharsLatin1(byte[] buf, int off, BaseCalendar.Date date) {\n+        \/\/ EEE\n+        int weekIndex = (date.getDayOfWeek() - 1) * 3;\n+        buf[off] = wtb[weekIndex];\n+        buf[off + 1] = wtb[weekIndex + 1];\n+        buf[off + 2] = wtb[weekIndex + 2];\n+\n+        buf[off + 3] = ' ';\n+\n+        \/\/ MMM\n+        int monthIndex = (date.getMonth() + 6) * 3;\n+        buf[off + 4] = wtb[monthIndex];\n+        buf[off + 5] = wtb[monthIndex + 1];\n+        buf[off + 6] = wtb[monthIndex + 2];\n+\n+        buf[off + 7] = ' ';\n+        JLA.writeDigitPairLatin1(buf, off + 8, date.getDayOfMonth()); \/\/ dd\n+        buf[off + 10] = ' ';\n+        JLA.writeDigitPairLatin1(buf, off + 11, date.getHours()); \/\/ HH\n+        buf[off + 13] = ':';\n+        JLA.writeDigitPairLatin1(buf, off + 14, date.getMinutes()); \/\/ mm\n+        buf[off + 16] = ':';\n+        JLA.writeDigitPairLatin1(buf, off + 17, date.getSeconds()); \/\/ ss\n+        buf[off + 19] = ' ';\n+\n+        TimeZone zi = date.getZone();\n+        String shortName = zi != null ? zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US) : \"GMT\";\n+        buf[off + 20] = (byte) shortName.charAt(0);\n+        buf[off + 21] = (byte) shortName.charAt(1);\n+        buf[off + 22] = (byte) shortName.charAt(2);\n+        buf[off + 23] = ' ';\n+\n+        int year = date.getYear();\n+        int yearSize = JLA.stringSize(year);\n+        JLA.getCharsLatin1(year, off + 24 + yearSize, buf);\n+    }\n+\n+    public static void getCharsUTF16(byte[] buf, int off, BaseCalendar.Date date) {\n+        \/\/ EEE\n+        int weekIndex = (date.getDayOfWeek() - 1) * 3;\n+        JLA.putCharUTF16(buf, off, wtb[weekIndex]);\n+        JLA.putCharUTF16(buf, off + 1, wtb[weekIndex + 1]);\n+        JLA.putCharUTF16(buf, off + 2, wtb[weekIndex + 2]);\n+\n+        JLA.putCharUTF16(buf, off + 3, ' ');\n+\n+        \/\/ MMM\n+        int monthIndex = (date.getMonth() + 6) * 3;\n+        JLA.putCharUTF16(buf, off + 4, wtb[monthIndex]);\n+        JLA.putCharUTF16(buf, off + 5, wtb[monthIndex + 1]);\n+        JLA.putCharUTF16(buf, off + 6, wtb[monthIndex + 2]);\n+\n+        JLA.putCharUTF16(buf, off + 7, ' ');\n+        JLA.writeDigitPairUTF16(buf, off + 8, date.getDayOfMonth()); \/\/ dd\n+        JLA.putCharUTF16(buf, off + 10, ' ');\n+        JLA.writeDigitPairUTF16(buf, off + 11, date.getHours()); \/\/ HH\n+        JLA.putCharUTF16(buf, off + 13, ':');\n+        JLA.writeDigitPairUTF16(buf, off + 14, date.getMinutes()); \/\/ mm\n+        JLA.putCharUTF16(buf, off + 16, ':');\n+        JLA.writeDigitPairUTF16(buf, off + 17, date.getSeconds()); \/\/ ss\n+        JLA.putCharUTF16(buf, off + 19, ' ');\n+\n+        TimeZone zi = date.getZone();\n+        String shortName = zi != null ? zi.getDisplayName(date.isDaylightTime(), TimeZone.SHORT, Locale.US) : \"GMT\";\n+        JLA.putCharUTF16(buf, off + 20, shortName.charAt(0));\n+        JLA.putCharUTF16(buf, off + 21, shortName.charAt(1));\n+        JLA.putCharUTF16(buf, off + 22, shortName.charAt(2));\n+        JLA.putCharUTF16(buf, off + 23, ' ');\n+\n+        int year = date.getYear();\n+        int yearSize = JLA.stringSize(year);\n+        JLA.getCharsUTF16(year, off + 24 + yearSize, buf);\n+    }\n+\n+    public static void getDateCharsLatin1(byte[] buf, int off, BaseCalendar.Date date) {\n+        int year = date.getYear();\n+        int month = date.getMonth();\n+        int dayOfMonth = date.getDayOfMonth();\n+\n+        int yearSize = JLA.stringSize(year);\n+        int yearEnd = off + Math.max(yearSize, 4);\n+        for (int i = 0; i < 4 - yearSize; ++i) {\n+            buf[off + i] = '0';\n+        }\n+        JLA.getCharsLatin1(year, yearEnd, buf);\n+        off = yearEnd;\n+        buf[off] = '-';\n+        JLA.writeDigitPairLatin1(buf, off + 1, month); \/\/ mm\n+        buf[off + 3] = '-';\n+        JLA.writeDigitPairLatin1(buf, off + 4, dayOfMonth); \/\/ dd\n+    }\n+\n+    public static void getDateCharsUTF16(byte[] buf, int off, BaseCalendar.Date date) {\n+        int year = date.getYear();\n+        int month = date.getMonth();\n+        int dayOfMonth = date.getDayOfMonth();\n+\n+        int yearSize = JLA.stringSize(year);\n+        int yearEnd = off + Math.max(yearSize, 4);\n+        for (int i = 0; i < 4 - yearSize; ++i) {\n+            JLA.putCharUTF16(buf, off, '0');\n+        }\n+        JLA.getCharsUTF16(year, yearEnd, buf);\n+        off = yearEnd;\n+        JLA.putCharUTF16(buf, off, '-');\n+        JLA.writeDigitPairUTF16(buf, off + 1, month);\n+        JLA.putCharUTF16(buf, off + 3, '-');\n+        JLA.writeDigitPairUTF16(buf, off + 4, dayOfMonth);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DateTimeUtils.java","additions":508,"deletions":0,"binary":false,"changes":508,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n@@ -31,0 +32,1 @@\n+import java.time.*;\n@@ -33,0 +35,1 @@\n+import java.util.Date;\n@@ -43,0 +46,1 @@\n+        suiteDateTimes(FMT);\n@@ -47,0 +51,1 @@\n+        suiteDateTimes(thaiFormat);\n@@ -961,0 +966,156 @@\n+\n+    static void suiteDateTimes(FormatProcessor fmt) {\n+        ZoneOffset zoneOffset = ZoneOffset.ofHours(8);\n+        ZoneId zoneId = ZoneId.systemDefault();\n+\n+        int[] years = {-99999, -9999, -999, -99, -9, 0, 9, 99, 999, 1999, 2999, 9999, 99999};\n+        for (int year : years) {\n+            for (int month = 1; month <= 12; month++) {\n+                for (int dayOfMonth = 1; dayOfMonth <= 28; dayOfMonth++) {\n+                    LocalDate localDate = LocalDate.of(year, month, dayOfMonth);\n+                    LocalDateTime ldt = LocalDateTime.of(localDate, LocalTime.MIN);\n+                    OffsetDateTime odt = OffsetDateTime.of(ldt, zoneOffset);\n+                    ZonedDateTime zdt = ZonedDateTime.of(ldt, zoneId);\n+                    Instant instant = Instant.from(zdt);\n+                    Date date = Date.from(instant);\n+\n+                    \/\/ %tF latin1\n+                    test(\"time %tF\".formatted(ldt), fmt.\"time %tF\\{ldt}\");\n+                    test(\"time %tF\".formatted(zdt), fmt.\"time %tF\\{zdt}\");\n+                    test(\"time %tF\".formatted(odt), fmt.\"time %tF\\{odt}\");\n+                    test(\"time %tF\".formatted(date), fmt.\"time %tF\\{date}\");\n+\n+                    \/\/ %tF utf16\n+                    test(\"\\u65f6\\u95f4 %tF\".formatted(ldt), fmt.\"\\u65f6\\u95f4 %tF\\{ldt}\");\n+                    test(\"\\u65f6\\u95f4 %tF\".formatted(zdt), fmt.\"\\u65f6\\u95f4 %tF\\{zdt}\");\n+                    test(\"\\u65f6\\u95f4 %tF\".formatted(odt), fmt.\"\\u65f6\\u95f4 %tF\\{odt}\");\n+                    test(\"\\u65f6\\u95f4 %tF\".formatted(date), fmt.\"\\u65f6\\u95f4 %tF\\{date}\");\n+\n+                    \/\/ %tD latin1\n+                    test(\"time %tD\".formatted(ldt), fmt.\"time %tD\\{ldt}\");\n+                    test(\"time %tD\".formatted(zdt), fmt.\"time %tD\\{zdt}\");\n+                    test(\"time %tD\".formatted(odt), fmt.\"time %tD\\{odt}\");\n+                    test(\"time %tD\".formatted(date), fmt.\"time %tD\\{date}\");\n+\n+                    \/\/ %tD utf16\n+                    test(\"\\u65f6\\u95f4 %tD\".formatted(ldt), fmt.\"\\u65f6\\u95f4 %tD\\{ldt}\");\n+                    test(\"\\u65f6\\u95f4 %tD\".formatted(zdt), fmt.\"\\u65f6\\u95f4 %tD\\{zdt}\");\n+                    test(\"\\u65f6\\u95f4 %tD\".formatted(odt), fmt.\"\\u65f6\\u95f4 %tD\\{odt}\");\n+                    test(\"\\u65f6\\u95f4 %tD\".formatted(date), fmt.\"\\u65f6\\u95f4 %tD\\{date}\");\n+\n+                    \/\/ %s latin1\n+                    test(\"date %s\".formatted(ldt), fmt.\"date %s\\{ldt}\");\n+                    test(\"date %s\".formatted(zdt), fmt.\"date %s\\{zdt}\");\n+                    test(\"date %s\".formatted(odt), fmt.\"date %s\\{odt}\");\n+                    test(\"date %s\".formatted(localDate), fmt.\"date %s\\{localDate}\");\n+                    test(\"date %s\".formatted(date), fmt.\"date %s\\{date}\");\n+                    test(\"date %s\".formatted(instant), fmt.\"date %s\\{instant}\");\n+\n+                    \/\/ %s utf16\n+                    test(\"\\u65e5\\u671f %s\".formatted(ldt), fmt.\"\\u65e5\\u671f %s\\{ldt}\");\n+                    test(\"\\u65e5\\u671f %s\".formatted(zdt), fmt.\"\\u65e5\\u671f %s\\{zdt}\");\n+                    test(\"\\u65e5\\u671f %s\".formatted(odt), fmt.\"\\u65e5\\u671f %s\\{odt}\");\n+                    test(\"\\u65e5\\u671f %s\".formatted(localDate), fmt.\"\\u65e5\\u671f %s\\{localDate}\");\n+                    test(\"\\u65e5\\u671f %s\".formatted(date), fmt.\"\\u65e5\\u671f %s\\{date}\");\n+                    test(\"\\u65e5\\u671f %s\".formatted(instant), fmt.\"\\u65e5\\u671f %s\\{instant}\");\n+\n+                    test(\"%tc\".formatted(date), fmt.\"%tc\\{date}\");\n+                    test(\"\\u65f6\\u95f4%tc\".formatted(date), fmt.\"\\u65f6\\u95f4%tc\\{date}\");\n+                }\n+            }\n+        }\n+\n+        LocalDate localDate = LocalDate.of(2023, 10, 3);\n+        int[] nanos = {\n+                0, 1, 10, 12, 100, 123,\n+                123000, 123010, 123100, 123120, 123123,\n+                100000000, 120000000,\n+                123000000, 123000001, 123000010, 123000100, 123001000, 123010000, 123100000,\n+                123120000, 123120010, 123120100, 123123000, 123123100, 123123120, 123123123,\n+                999999999\n+        };\n+        int[] minutes = {0, 1, 9, 10, 59};\n+        int[] seconds = {0, 1, 9, 10, 59};\n+        for (int hour = 0; hour < 23; hour++) {\n+            for (int minute : minutes) {\n+                for (int nano : nanos) {\n+                    for (int second : seconds) {\n+                        LocalTime localTime = LocalTime.of(hour, minute, second, nano);\n+                        OffsetTime offsetTime = OffsetTime.of(localTime, zoneOffset);\n+\n+                        LocalDateTime ldt = LocalDateTime.of(localDate, localTime);\n+                        OffsetDateTime odt = OffsetDateTime.of(ldt, zoneOffset);\n+                        ZonedDateTime zdt = ZonedDateTime.of(ldt, zoneId);\n+                        Instant instant = Instant.from(zdt);\n+                        Date date = Date.from(instant);\n+\n+                        \/\/ %tr latin1\n+                        test(\"time %tr\".formatted(localTime), fmt. \"time %tr\\{ localTime }\" );\n+                        test(\"time %tr\".formatted(offsetTime), fmt. \"time %tr\\{ offsetTime }\" );\n+                        test(\"time %tr\".formatted(ldt), fmt. \"time %tr\\{ ldt }\" );\n+                        test(\"time %tr\".formatted(odt), fmt. \"time %tr\\{ odt }\" );\n+                        test(\"time %tr\".formatted(zdt), fmt. \"time %tr\\{ zdt }\" );\n+\n+                        \/\/ %tr utf16\n+                        test(\"\\u65f6\\u95f4 %tr\".formatted(localTime), fmt. \"\\u65f6\\u95f4 %tr\\{ localTime }\" );\n+                        test(\"\\u65f6\\u95f4 %tr\".formatted(offsetTime), fmt. \"\\u65f6\\u95f4 %tr\\{ offsetTime }\" );\n+                        test(\"\\u65f6\\u95f4 %tr\".formatted(ldt), fmt. \"\\u65f6\\u95f4 %tr\\{ ldt }\" );\n+                        test(\"\\u65f6\\u95f4 %tr\".formatted(odt), fmt. \"\\u65f6\\u95f4 %tr\\{ odt }\" );\n+                        test(\"\\u65f6\\u95f4 %tr\".formatted(zdt), fmt. \"\\u65f6\\u95f4 %tr\\{ zdt }\" );\n+\n+                        \/\/ %tR latin1\n+                        test(\"time %tR\".formatted(localTime), fmt. \"time %tR\\{ localTime }\" );\n+                        test(\"time %tR\".formatted(offsetTime), fmt. \"time %tR\\{ offsetTime }\" );\n+                        test(\"time %tR\".formatted(ldt), fmt. \"time %tR\\{ ldt }\" );\n+                        test(\"time %tR\".formatted(odt), fmt. \"time %tR\\{ odt }\" );\n+                        test(\"time %tR\".formatted(zdt), fmt. \"time %tR\\{ zdt }\" );\n+\n+                        \/\/ %tR utf16\n+                        test(\"\\u65f6\\u95f4 %tR\".formatted(localTime), fmt. \"\\u65f6\\u95f4 %tR\\{ localTime }\" );\n+                        test(\"\\u65f6\\u95f4 %tR\".formatted(offsetTime), fmt. \"\\u65f6\\u95f4 %tR\\{ offsetTime }\" );\n+                        test(\"\\u65f6\\u95f4 %tR\".formatted(ldt), fmt. \"\\u65f6\\u95f4 %tR\\{ ldt }\" );\n+                        test(\"\\u65f6\\u95f4 %tR\".formatted(odt), fmt. \"\\u65f6\\u95f4 %tR\\{ odt }\" );\n+                        test(\"\\u65f6\\u95f4 %tR\".formatted(zdt), fmt. \"\\u65f6\\u95f4 %tR\\{ zdt }\" );\n+\n+                        \/\/ %tT latin1\n+                        test(\"time %tT\".formatted(localTime), fmt.\"time %tT\\{localTime}\");\n+                        test(\"time %tT\".formatted(offsetTime), fmt.\"time %tT\\{offsetTime}\");\n+                        test(\"time %tT\".formatted(ldt), fmt.\"time %tT\\{ldt}\");\n+                        test(\"time %tT\".formatted(zdt), fmt.\"time %tT\\{zdt}\");\n+                        test(\"time %tT\".formatted(odt), fmt.\"time %tT\\{odt}\");\n+                        test(\"time %tT\".formatted(date), fmt.\"time %tT\\{date}\");\n+\n+                        \/\/ %tT utf16\n+                        test(\"\\u65f6\\u95f4 %tT\".formatted(localTime), fmt.\"\\u65f6\\u95f4 %tT\\{localTime}\");\n+                        test(\"\\u65f6\\u95f4 %tT\".formatted(offsetTime), fmt.\"\\u65f6\\u95f4 %tT\\{offsetTime}\");\n+                        test(\"\\u65f6\\u95f4 %tT\".formatted(ldt), fmt.\"\\u65f6\\u95f4 %tT\\{ldt}\");\n+                        test(\"\\u65f6\\u95f4 %tT\".formatted(zdt), fmt.\"\\u65f6\\u95f4 %tT\\{zdt}\");\n+                        test(\"\\u65f6\\u95f4 %tT\".formatted(odt), fmt.\"\\u65f6\\u95f4 %tT\\{odt}\");\n+                        test(\"\\u65f6\\u95f4 %tT\".formatted(date), fmt.\"\\u65f6\\u95f4 %tT\\{date}\");\n+\n+                        \/\/ %s latin1\n+                        test(\"time %s\".formatted(localTime), fmt.\"time %s\\{localTime}\");\n+                        test(\"time %s\".formatted(offsetTime), fmt.\"time %s\\{offsetTime}\");\n+                        test(\"time %s\".formatted(ldt), fmt.\"time %s\\{ldt}\");\n+                        test(\"time %s\".formatted(odt), fmt.\"time %s\\{odt}\");\n+                        test(\"time %s\".formatted(zdt), fmt.\"time %s\\{zdt}\");\n+                        test(\"time %s\".formatted(date), fmt.\"time %s\\{date}\");\n+                        test(\"time %s\".formatted(instant), fmt.\"time %s\\{instant}\");\n+\n+                        \/\/ %s utf16\n+                        test(\"\\u65f6\\u95f4 %s\".formatted(localTime), fmt.\"\\u65f6\\u95f4 %s\\{localTime}\");\n+                        test(\"\\u65f6\\u95f4 %s\".formatted(offsetTime), fmt.\"\\u65f6\\u95f4 %s\\{offsetTime}\");\n+                        test(\"\\u65f6\\u95f4 %s\".formatted(ldt), fmt.\"\\u65f6\\u95f4 %s\\{ldt}\");\n+                        test(\"\\u65f6\\u95f4 %s\".formatted(odt), fmt.\"\\u65f6\\u95f4 %s\\{odt}\");\n+                        test(\"\\u65f6\\u95f4 %s\".formatted(zdt), fmt.\"\\u65f6\\u95f4 %s\\{zdt}\");\n+                        test(\"\\u65f6\\u95f4 %s\".formatted(date), fmt.\"\\u65f6\\u95f4 %s\\{date}\");\n+                        test(\"\\u65f6\\u95f4 %s\".formatted(instant), fmt.\"\\u65f6\\u95f4 %s\\{instant}\");\n+\n+                        \/\/ %tc\n+                        test(\"time %tc\".formatted(date), fmt.\"time %tc\\{date}\");\n+                        test(\"\\u65f6\\u95f4%tc\".formatted(date), fmt.\"\\u65f6\\u95f4%tc\\{date}\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/template\/FormatterBuilder.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.time.*;\n+import java.util.Date;\n@@ -53,0 +55,5 @@\n+    public ZonedDateTime zdt = ZonedDateTime.now();\n+    public LocalDateTime ldt = zdt.toLocalDateTime();\n+    public LocalTime localTime = ldt.toLocalTime();\n+    public Instant instant = Instant.from(zdt);\n+    public Date date = Date.from(instant);\n@@ -78,0 +85,25 @@\n+\n+    @Benchmark\n+    public String zdtFormat() {\n+        return FMT.\"%s\\{zdt}\";\n+    }\n+\n+    @Benchmark\n+    public String ldtFormat() {\n+        return FMT.\"%s\\{ldt}\";\n+    }\n+\n+    @Benchmark\n+    public String localTimeFormat() {\n+        return FMT.\"%s\\{localTime}\";\n+    }\n+\n+    @Benchmark\n+    public String instantFormat() {\n+        return FMT.\"%s\\{instant}\";\n+    }\n+\n+    @Benchmark\n+    public String dateFormat() {\n+        return FMT.\"%s\\{date}\";\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringTemplateFMT.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"}]}