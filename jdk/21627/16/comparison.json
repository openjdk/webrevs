{"files":[{"patch":"@@ -178,1 +178,1 @@\n-    st->print(\"%#11llx\", reinterpret_cast<const unsigned long long>(mem_info.BaseAddress) - reinterpret_cast<const unsigned long long>(mem_info.AllocationBase));\n+    st->print(\"%#11llx\", reinterpret_cast<unsigned long long>(mem_info.BaseAddress) - reinterpret_cast<unsigned long long>(mem_info.AllocationBase));\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1441,1 +1441,1 @@\n-  void* ret = ::GetProcAddress((HMODULE)lib, name);\n+  void* ret = CAST_FROM_FN_PTR(void*, ::GetProcAddress((HMODULE)lib, name));\n@@ -1452,1 +1452,1 @@\n-  return ::GetProcAddress(nullptr, name);\n+  return CAST_FROM_FN_PTR(void*, ::GetProcAddress(nullptr, name));\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#ifdef AARCH64\n@@ -32,5 +33,7 @@\n-\/\/ This code is a copy of __ieee754_fmod() formerly from the JDK's libfdlibm and is\n-\/\/ used as a workaround for issues with the Windows x64 CRT implementation\n-\/\/ of fmod. Microsoft has acknowledged that this is an issue in Visual Studio\n-\/\/ 2012 and forward, but has not provided a time frame for a fix other than that\n-\/\/ it'll not be fixed in Visual Studio 2013 or 2015.\n+\/\/ This code is a copy of __ieee754_fmod() formerly from the JDK's libfdlibm and\n+\/\/ used to be a workaround for issues with the Windows x64 CRT implementation of\n+\/\/ fmod, but while Windows x64 now uses handwritten assembly, it was discovered\n+\/\/ that Windows ARM64 now also suffers from the same bug, so this is now used\n+\/\/ on Windows ARM64 instead. Microsoft has acknowledged that this is an issue in\n+\/\/ Visual Studio 2012 and forward, but has not provided a time frame for a fix\n+\/\/ other than that it'll not be fixed in Visual Studio 2013 or 2015.\n@@ -40,1 +43,1 @@\n-double SharedRuntime::fmod_winx64(double x, double y)\n+double SharedRuntime::fmod_winarm64(double x, double y)\n@@ -159,0 +162,2 @@\n+\n+#endif\n","filename":"src\/hotspot\/os\/windows\/sharedRuntimeRem.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -334,1 +334,1 @@\n-#ifdef _WIN64\n+#if defined(_WINDOWS) && defined(AARCH64)\n@@ -339,1 +339,0 @@\n-#endif\n@@ -341,1 +340,0 @@\n-#if !defined(X86)\n@@ -343,3 +341,10 @@\n-#ifdef _WIN64\n-  \/\/ 64-bit Windows on amd64 returns the wrong values for\n-  \/\/ infinity operands.\n+  \/\/ Initially, this was in place because 64-bit Windows\n+  \/\/ on amd64 returns the wrong values for infinity\n+  \/\/ operands. 64-bit Windows on AMD64 now uses custom\n+  \/\/ handwritten assembly, but when 8342769 tried to\n+  \/\/ delete this workaround, it was discovered in\n+  \/\/ review that now Windows\/ARM64 suffers from the\n+  \/\/ same bug, so this workaround is now used for\n+  \/\/ Windows\/ARM64. This, along with the implementation\n+  \/\/ of the workaround in sharedRuntimeRem.cpp, can be\n+  \/\/ safely deleted once the bug is fixed.\n@@ -353,4 +358,1 @@\n-  return ((jfloat)fmod_winx64((double)x, (double)y));\n-#else\n-  return ((jfloat)fmod((double)x,(double)y));\n-#endif\n+  return ((jfloat)fmod_winarm64((double)x, (double)y));\n@@ -360,1 +362,0 @@\n-#ifdef _WIN64\n@@ -368,2 +369,8 @@\n-  return ((jdouble)fmod_winx64((double)x, (double)y));\n-#else\n+  return ((jdouble)fmod_winarm64((double)x, (double)y));\n+JRT_END\n+#elif !defined(X86)\n+JRT_LEAF(jfloat, SharedRuntime::frem(jfloat x, jfloat y))\n+  return ((jfloat)fmod((double)x,(double)y));\n+JRT_END\n+\n+JRT_LEAF(jdouble, SharedRuntime::drem(jdouble x, jdouble y))\n@@ -371,1 +378,0 @@\n-#endif\n@@ -373,1 +379,1 @@\n-#endif \/\/ !X86\n+#endif \/\/ _WINDOWS && AARCH64\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -131,3 +131,8 @@\n-#ifdef _WIN64\n-  \/\/ Workaround for fmod issue in the Windows x64 CRT\n-  static double fmod_winx64(double x, double y);\n+#if defined(_WINDOWS) && defined(AARCH64)\n+  \/\/ This used to be a workaround for the fmod issue\n+  \/\/ in the Windows x64 CRT. Windows x64 now uses its\n+  \/\/ own custom assembly, but during the review of\n+  \/\/ 8342769 it was discovered that Windows ARM64\n+  \/\/ now needs the workaround, so this is now used\n+  \/\/ for Windows ARM64\n+  static double fmod_winarm64(double x, double y);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -766,1 +766,1 @@\n-      ASSERT_EQ(mapping_info.committed_size, 0);\n+      ASSERT_EQ(mapping_info.committed_size, size_t{0});\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -792,1 +792,1 @@\n-    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 when large page is not supported by the processor\";\n+    EXPECT_EQ(decided_size, size_t{0}) << \"Expected decided size to be 0 when large page is not supported by the processor\";\n@@ -814,1 +814,1 @@\n-    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 for large pages bigger than 4mb on AMD64\";\n+    EXPECT_EQ(decided_size, size_t{0}) << \"Expected decided size to be 0 for large pages bigger than 4mb on AMD64\";\n@@ -827,1 +827,1 @@\n-  EXPECT_EQ(decided_size, 0) << \"Expected decided size to default to 0 when LargePageSizeInBytes is not a multiple of minimum size\";\n+  EXPECT_EQ(decided_size, size_t{0}) << \"Expected decided size to default to 0 when LargePageSizeInBytes is not a multiple of minimum size\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}