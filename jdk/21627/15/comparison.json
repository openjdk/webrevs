{"files":[{"patch":"@@ -177,1 +177,1 @@\n-    st->print(\"%#11llx\", reinterpret_cast<const unsigned long long>(mem_info.BaseAddress) - reinterpret_cast<const unsigned long long>(mem_info.AllocationBase));\n+    st->print(\"%#11llx\", reinterpret_cast<unsigned long long>(mem_info.BaseAddress) - reinterpret_cast<unsigned long long>(mem_info.AllocationBase));\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1415,1 +1415,1 @@\n-  void* ret = ::GetProcAddress((HMODULE)lib, name);\n+  void* ret = CAST_FROM_FN_PTR(void*, ::GetProcAddress((HMODULE)lib, name));\n@@ -1426,1 +1426,1 @@\n-  return ::GetProcAddress(nullptr, name);\n+  return CAST_FROM_FN_PTR(void*, ::GetProcAddress(nullptr, name));\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#ifdef AARCH64\n@@ -32,5 +33,7 @@\n-\/\/ This code is a copy of __ieee754_fmod() formerly from the JDK's libfdlibm and is\n-\/\/ used as a workaround for issues with the Windows x64 CRT implementation\n-\/\/ of fmod. Microsoft has acknowledged that this is an issue in Visual Studio\n-\/\/ 2012 and forward, but has not provided a time frame for a fix other than that\n-\/\/ it'll not be fixed in Visual Studio 2013 or 2015.\n+\/\/ This code is a copy of __ieee754_fmod() formerly from the JDK's libfdlibm and\n+\/\/ used to be a workaround for issues with the Windows x64 CRT implementation of\n+\/\/ fmod, but while Windows x64 now uses handwritten assembly, it was discovered\n+\/\/ that Windows ARM64 now also suffers from the same bug, so this is now used\n+\/\/ on Windows ARM64 instead. Microsoft has acknowledged that this is an issue in\n+\/\/ Visual Studio 2012 and forward, but has not provided a time frame for a fix\n+\/\/ other than that it'll not be fixed in Visual Studio 2013 or 2015.\n@@ -40,1 +43,1 @@\n-double SharedRuntime::fmod_winx64(double x, double y)\n+double SharedRuntime::fmod_winarm64(double x, double y)\n@@ -159,0 +162,2 @@\n+\n+#endif\n","filename":"src\/hotspot\/os\/windows\/sharedRuntimeRem.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-#ifdef _WIN64\n+#if defined(_WINDOWS) && defined(AARCH64)\n@@ -291,1 +291,0 @@\n-#endif\n@@ -293,1 +292,0 @@\n-#if !defined(X86)\n@@ -295,3 +293,10 @@\n-#ifdef _WIN64\n-  \/\/ 64-bit Windows on amd64 returns the wrong values for\n-  \/\/ infinity operands.\n+  \/\/ Initially, this was in place because 64-bit Windows\n+  \/\/ on amd64 returns the wrong values for infinity\n+  \/\/ operands. 64-bit Windows on AMD64 now uses custom\n+  \/\/ handwritten assembly, but when 8342769 tried to\n+  \/\/ delete this workaround, it was discovered in\n+  \/\/ review that now Windows\/ARM64 suffers from the\n+  \/\/ same bug, so this workaround is now used for\n+  \/\/ Windows\/ARM64. This, along with the implementation\n+  \/\/ of the workaround in sharedRuntimeRem.cpp, can be\n+  \/\/ safely deleted once the bug is fixed.\n@@ -305,4 +310,1 @@\n-  return ((jfloat)fmod_winx64((double)x, (double)y));\n-#else\n-  return ((jfloat)fmod((double)x,(double)y));\n-#endif\n+  return ((jfloat)fmod_winarm64((double)x, (double)y));\n@@ -312,1 +314,0 @@\n-#ifdef _WIN64\n@@ -320,2 +321,8 @@\n-  return ((jdouble)fmod_winx64((double)x, (double)y));\n-#else\n+  return ((jdouble)fmod_winarm64((double)x, (double)y));\n+JRT_END\n+#elif !defined(X86)\n+JRT_LEAF(jfloat, SharedRuntime::frem(jfloat x, jfloat y))\n+  return ((jfloat)fmod((double)x,(double)y));\n+JRT_END\n+\n+JRT_LEAF(jdouble, SharedRuntime::drem(jdouble x, jdouble y))\n@@ -323,1 +330,0 @@\n-#endif\n@@ -325,1 +331,1 @@\n-#endif \/\/ !X86\n+#endif \/\/ _WINDOWS && AARCH64\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -142,3 +142,8 @@\n-#ifdef _WIN64\n-  \/\/ Workaround for fmod issue in the Windows x64 CRT\n-  static double fmod_winx64(double x, double y);\n+#if defined(_WINDOWS) && defined(AARCH64)\n+  \/\/ This used to be a workaround for the fmod issue\n+  \/\/ in the Windows x64 CRT. Windows x64 now uses its\n+  \/\/ own custom assembly, but during the review of\n+  \/\/ 8342769 it was discovered that Windows ARM64\n+  \/\/ now needs the workaround, so this is now used\n+  \/\/ for Windows ARM64\n+  static double fmod_winarm64(double x, double y);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -765,1 +765,1 @@\n-      ASSERT_EQ(mapping_info.committed_size, 0);\n+      ASSERT_EQ(mapping_info.committed_size, size_t{0});\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -794,1 +794,1 @@\n-    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 when large page is not supported by the processor\";\n+    EXPECT_EQ(decided_size, size_t{0}) << \"Expected decided size to be 0 when large page is not supported by the processor\";\n@@ -816,1 +816,1 @@\n-    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 for large pages bigger than 4mb on IA32 or AMD64\";\n+    EXPECT_EQ(decided_size, size_t{0}) << \"Expected decided size to be 0 for large pages bigger than 4mb on IA32 or AMD64\";\n@@ -829,1 +829,1 @@\n-  EXPECT_EQ(decided_size, 0) << \"Expected decided size to default to 0 when LargePageSizeInBytes is not a multiple of minimum size\";\n+  EXPECT_EQ(decided_size, size_t{0}) << \"Expected decided size to default to 0 when LargePageSizeInBytes is not a multiple of minimum size\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}