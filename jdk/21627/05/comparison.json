{"files":[{"patch":"@@ -80,0 +80,1 @@\n+#ifndef _WIN64\n@@ -81,0 +82,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    st->print(\"%#11llx\", reinterpret_cast<const unsigned long long>(mem_info.BaseAddress) - reinterpret_cast<const unsigned long long>(mem_info.AllocationBase));\n+    st->print(\"%#11llx\", reinterpret_cast<unsigned long long>(mem_info.BaseAddress) - reinterpret_cast<unsigned long long>(mem_info.AllocationBase));\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-#ifdef _WIN64\n+#ifdef _M_ARM64\n@@ -297,2 +297,10 @@\n-  \/\/ 64-bit Windows on amd64 returns the wrong values for\n-  \/\/ infinity operands.\n+  \/\/ Initially, this was in place because 64-bit Windows\n+  \/\/ on amd64 returns the wrong values for infinity\n+  \/\/ operands. 64-bit Windows on AMD64 now uses custom\n+  \/\/ handwritten assembly, but when 8342769 tried to\n+  \/\/ delete this workaround, it was discovered in\n+  \/\/ review that now Windows\/ARM64 suffers from the\n+  \/\/ same bug, so this workaround is now used for\n+  \/\/ Windows\/ARM64. This, along with the implementation\n+  \/\/ of the workaround in sharedRuntimeRem.cpp, can be\n+  \/\/ safely deleted once the bug is fixed.\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -143,1 +143,6 @@\n-  \/\/ Workaround for fmod issue in the Windows x64 CRT\n+  \/\/ This used to be a workaround for the fmod issue\n+  \/\/ in the Windows x64 CRT. Windows x64 now uses its\n+  \/\/ own custom assembly, but during the review of\n+  \/\/ 8342769 it was discovered that Windows ARM64\n+  \/\/ now needs the workaround, so this is now used\n+  \/\/ for Windows ARM64\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -766,1 +766,1 @@\n-      ASSERT_EQ(mapping_info.committed_size, 0);\n+      ASSERT_EQ(mapping_info.committed_size, size_t { 0 });\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 when large page is not supported by the processor\";\n+    EXPECT_EQ(decided_size, size_t { 0 }) << \"Expected decided size to be 0 when large page is not supported by the processor\";\n@@ -817,1 +817,1 @@\n-    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 for large pages bigger than 4mb on IA32 or AMD64\";\n+    EXPECT_EQ(decided_size, size_t { 0 }) << \"Expected decided size to be 0 for large pages bigger than 4mb on IA32 or AMD64\";\n@@ -830,1 +830,1 @@\n-  EXPECT_EQ(decided_size, 0) << \"Expected decided size to default to 0 when LargePageSizeInBytes is not a multiple of minimum size\";\n+  EXPECT_EQ(decided_size, size_t { 0 }) << \"Expected decided size to default to 0 when LargePageSizeInBytes is not a multiple of minimum size\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}