{"files":[{"patch":"@@ -80,0 +80,1 @@\n+#ifndef _WIN64\n@@ -81,0 +82,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    st->print(\"%#11llx\", reinterpret_cast<const unsigned long long>(mem_info.BaseAddress) - reinterpret_cast<const unsigned long long>(mem_info.AllocationBase));\n+    st->print(\"%#11llx\", reinterpret_cast<unsigned long long>(mem_info.BaseAddress) - reinterpret_cast<unsigned long long>(mem_info.AllocationBase));\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1394,1 +1394,1 @@\n-  void* ret = ::GetProcAddress((HMODULE)lib, name);\n+  void* ret = CAST_FROM_FN_PTR(void*, ::GetProcAddress((HMODULE)lib, name));\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#ifdef AARCH64\n@@ -33,5 +34,7 @@\n-\/\/ This code is a copy of __ieee754_fmod() formerly from the JDK's libfdlibm and is\n-\/\/ used as a workaround for issues with the Windows x64 CRT implementation\n-\/\/ of fmod. Microsoft has acknowledged that this is an issue in Visual Studio\n-\/\/ 2012 and forward, but has not provided a time frame for a fix other than that\n-\/\/ it'll not be fixed in Visual Studio 2013 or 2015.\n+\/\/ This code is a copy of __ieee754_fmod() formerly from the JDK's libfdlibm and\n+\/\/ used to be a workaround for issues with the Windows x64 CRT implementation of\n+\/\/ fmod, but while Windows x64 now uses handwritten assembly, it was discovered\n+\/\/ that Windows ARM64 now also suffers from the same bug, so this is now used\n+\/\/ on Windows ARM64 instead. Microsoft has acknowledged that this is an issue in\n+\/\/ Visual Studio 2012 and forward, but has not provided a time frame for a fix\n+\/\/ other than that it'll not be fixed in Visual Studio 2013 or 2015.\n@@ -41,1 +44,1 @@\n-double SharedRuntime::fmod_winx64(double x, double y)\n+double SharedRuntime::fmod_winarm64(double x, double y)\n@@ -160,0 +163,2 @@\n+\n+#endif\n","filename":"src\/hotspot\/os\/windows\/sharedRuntimeRem.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-#ifdef _WIN64\n+#if defined(_WINDOWS) && defined(AARCH64)\n@@ -292,1 +292,0 @@\n-#endif\n@@ -294,1 +293,0 @@\n-#if !defined(X86)\n@@ -296,3 +294,10 @@\n-#ifdef _WIN64\n-  \/\/ 64-bit Windows on amd64 returns the wrong values for\n-  \/\/ infinity operands.\n+  \/\/ Initially, this was in place because 64-bit Windows\n+  \/\/ on amd64 returns the wrong values for infinity\n+  \/\/ operands. 64-bit Windows on AMD64 now uses custom\n+  \/\/ handwritten assembly, but when 8342769 tried to\n+  \/\/ delete this workaround, it was discovered in\n+  \/\/ review that now Windows\/ARM64 suffers from the\n+  \/\/ same bug, so this workaround is now used for\n+  \/\/ Windows\/ARM64. This, along with the implementation\n+  \/\/ of the workaround in sharedRuntimeRem.cpp, can be\n+  \/\/ safely deleted once the bug is fixed.\n@@ -306,4 +311,1 @@\n-  return ((jfloat)fmod_winx64((double)x, (double)y));\n-#else\n-  return ((jfloat)fmod((double)x,(double)y));\n-#endif\n+  return ((jfloat)fmod_winarm64((double)x, (double)y));\n@@ -313,1 +315,0 @@\n-#ifdef _WIN64\n@@ -321,2 +322,8 @@\n-  return ((jdouble)fmod_winx64((double)x, (double)y));\n-#else\n+  return ((jdouble)fmod_winarm64((double)x, (double)y));\n+JRT_END\n+#elif !defined(X86)\n+JRT_LEAF(jfloat, SharedRuntime::frem(jfloat x, jfloat y))\n+  return ((jfloat)fmod((double)x,(double)y));\n+JRT_END\n+\n+JRT_LEAF(jdouble, SharedRuntime::drem(jdouble x, jdouble y))\n@@ -324,1 +331,0 @@\n-#endif\n@@ -326,1 +332,1 @@\n-#endif \/\/ !X86\n+#endif \/\/ _WINDOWS && AARCH64\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -142,3 +142,8 @@\n-#ifdef _WIN64\n-  \/\/ Workaround for fmod issue in the Windows x64 CRT\n-  static double fmod_winx64(double x, double y);\n+#if defined(_WINDOWS) && defined(AARCH64)\n+  \/\/ This used to be a workaround for the fmod issue\n+  \/\/ in the Windows x64 CRT. Windows x64 now uses its\n+  \/\/ own custom assembly, but during the review of\n+  \/\/ 8342769 it was discovered that Windows ARM64\n+  \/\/ now needs the workaround, so this is now used\n+  \/\/ for Windows ARM64\n+  static double fmod_winarm64(double x, double y);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -766,1 +766,1 @@\n-      ASSERT_EQ(mapping_info.committed_size, 0);\n+      ASSERT_EQ(mapping_info.committed_size, size_t{0});\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 when large page is not supported by the processor\";\n+    EXPECT_EQ(decided_size, size_t{0}) << \"Expected decided size to be 0 when large page is not supported by the processor\";\n@@ -817,1 +817,1 @@\n-    EXPECT_EQ(decided_size, 0) << \"Expected decided size to be 0 for large pages bigger than 4mb on IA32 or AMD64\";\n+    EXPECT_EQ(decided_size, size_t{0}) << \"Expected decided size to be 0 for large pages bigger than 4mb on IA32 or AMD64\";\n@@ -830,1 +830,1 @@\n-  EXPECT_EQ(decided_size, 0) << \"Expected decided size to default to 0 when LargePageSizeInBytes is not a multiple of minimum size\";\n+  EXPECT_EQ(decided_size, size_t{0}) << \"Expected decided size to default to 0 when LargePageSizeInBytes is not a multiple of minimum size\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}