{"files":[{"patch":"@@ -1810,1 +1810,1 @@\n-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n+void os::pd_free_memory_without_uncommit(char *addr, size_t bytes) {\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1687,1 +1687,1 @@\n-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n+void os::pd_free_memory_without_uncommit(char *addr, size_t bytes) {\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3038,9 +3038,2 @@\n-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n-  \/\/ This method works by doing an mmap over an existing mmaping and effectively discarding\n-  \/\/ the existing pages. However it won't work for SHM-based large pages that cannot be\n-  \/\/ uncommitted at all. We don't do anything in this case to avoid creating a segment with\n-  \/\/ small pages on top of the SHM segment. This method always works for small pages, so we\n-  \/\/ allow that in any case.\n-  if (alignment_hint <= os::vm_page_size() || can_commit_large_page_memory()) {\n-    commit_memory(addr, bytes, alignment_hint, !ExecMem);\n-  }\n+void os::pd_free_memory_without_uncommit(char *addr, size_t bytes) {\n+   ::madvise(addr, bytes, MADV_DONTNEED);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3896,1 +3896,1 @@\n-void os::pd_free_memory(char *addr, size_t bytes, size_t alignment_hint) { }\n+void os::pd_free_memory_without_uncommit(char *addr, size_t bytes) { }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-    os::free_memory((char*)aligned_region.start(), aligned_region.byte_size(), os_align);\n+    os::free_memory_without_uncommit((char*)aligned_region.start(), aligned_region.byte_size());\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        os::free_memory((char*)start, size, page_size);\n+        os::free_memory_without_uncommit((char*)start, size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2238,2 +2238,2 @@\n-void os::free_memory(char *addr, size_t bytes, size_t alignment_hint) {\n-  pd_free_memory(addr, bytes, alignment_hint);\n+void os::free_memory_without_uncommit(char *addr, size_t bytes) {\n+  pd_free_memory_without_uncommit(addr, bytes);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-  static void   pd_free_memory(char *addr, size_t bytes, size_t alignment_hint);\n+  static void   pd_free_memory_without_uncommit(char *addr, size_t bytes);\n@@ -523,1 +523,1 @@\n-  static void   free_memory(char *addr, size_t bytes, size_t alignment_hint);\n+  static void   free_memory_without_uncommit(char *addr, size_t bytes);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-    os::free_memory(base, size, page_sz);\n+    os::free_memory_without_uncommit(base, size);\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-\n@@ -42,0 +41,4 @@\n+#if !defined(_WINDOWS) && !defined(_AIX)\n+#include <sys\/mman.h>\n+#endif\n+\n@@ -979,0 +982,31 @@\n+#if !defined(_WINDOWS) && !defined(_AIX)\n+TEST_VM(os, free_without_uncommit) {\n+  const size_t page_sz = os::vm_page_size();\n+  const size_t pages = 64;\n+  const size_t size = pages * page_sz;\n+\n+  char *base = os::reserve_memory(size, false, mtTest);\n+  ASSERT_NE(base, (char*) nullptr);\n+  ASSERT_TRUE(os::commit_memory(base, size, false));\n+\n+  for (size_t index = 0; index < pages; index++) {\n+    base[index * page_sz] = 'a';\n+  }\n+\n+  os::free_memory_without_uncommit(base, size);\n+\n+#ifdef __linux__\n+  \/\/ Check that memory has been freed. Skip on BSD since MADV_DONTNEED doesn't free memory.\n+  size_t committed_size;\n+  address committed_start;\n+  ASSERT_FALSE(os::committed_in_range((address) base, size, committed_start, committed_size));\n+#endif\n+\n+  \/\/ Ensure we can still use the memory without having to recommit.\n+  for (size_t index = 0; index < pages; index++) {\n+    base[index * page_sz] = 'a';\n+  }\n+\n+  os::release_memory(base, size);\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"}]}