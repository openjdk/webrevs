{"files":[{"patch":"@@ -359,1 +359,1 @@\n-        i = buf.get();\n+        i = Byte.toUnsignedInt(buf.get());\n@@ -397,1 +397,1 @@\n-        i = buf.get();  \/\/ length\n+        i = Byte.toUnsignedInt(buf.get());  \/\/ length\n@@ -413,1 +413,1 @@\n-                int l = buf.get();\n+                int l = Byte.toUnsignedInt(buf.get());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,395 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350830\n+ * @summary TLS 1.2 Client session resumption having ServerNameIndication\n+ * @run main\/othervm ResumeClientTLS12withSNI\n+ *\/\n+\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.util.*;\n+\n+public class ResumeClientTLS12withSNI {\n+\n+    \/*\n+     * Enables logging of the SSLEngine operations.\n+     *\/\n+    private static final boolean logging = false;\n+\n+    \/*\n+     * Enables the JSSE system debugging system property:\n+     *\n+     *     -Djavax.net.debug=ssl:handshake\n+     *\n+     * This gives a lot of low-level information about operations underway,\n+     * including specific handshake messages, and might be best examined\n+     * after gaining some familiarity with this application.\n+     *\/\n+    private static final boolean debug = true;\n+\n+    private static SSLContext sslc;\n+\n+    private SSLEngine clientEngine; \/\/ client Engine\n+    private ByteBuffer clientOut; \/\/ write side of clientEngine\n+    private ByteBuffer clientIn; \/\/ read side of clientEngine\n+\n+    private SSLEngine serverEngine; \/\/ server Engine\n+    private ByteBuffer serverOut; \/\/ write side of serverEngine\n+    private ByteBuffer serverIn; \/\/ read side of serverEngine\n+\n+    \/*\n+     * For data transport, this example uses local ByteBuffers.\n+     *\/\n+    private ByteBuffer cTOs; \/\/ \"reliable\" transport client->server\n+    private ByteBuffer sTOc; \/\/ \"reliable\" transport server->client\n+\n+\n+    private byte[] previousSessionId;\n+\n+    \/*\n+     * The following is to set up the keystores.\n+     *\/\n+    private static final String pathToStores = System.getProperty(\"test.src\", \".\");\n+    private static final String keyStoreFile = \"keystore_san.p12\";\n+    private static final String trustStoreFile = \"keystore_san.p12\";\n+    private static final char[] passphrase = \"123456\".toCharArray();\n+\n+    private static final String keyFilename =\n+            pathToStores + \"\/\" + keyStoreFile;\n+    private static final String trustFilename =\n+            pathToStores + \"\/\" + trustStoreFile;\n+\n+    private static final String HOST_NAME = \"arf.yak.foo.localhost123456.localhost123456.localhost123456.localhost123456.localhost123456.localhost123456.\"\n+            + \"localhost123456.localhost123456.localhost123456.localhost123456.localhost123456.localhost123456\";\n+    private static final SNIHostName SNI_NAME = new SNIHostName(HOST_NAME);\n+    private static final SNIMatcher SNI_MATCHER = SNIHostName.createSNIMatcher(\"arf\\\\.yak\\\\.foo.*\");\n+\n+    \/*\n+     * Main entry point for this test.\n+     *\/\n+    public static void main(String args[]) throws Exception {\n+        if (debug) {\n+            System.setProperty(\"javax.net.debug\", \"ssl\");\n+        }\n+\n+        final ResumeClientTLS12withSNI clientSession = new ResumeClientTLS12withSNI(\"TLSv1.2\");\n+        for (int i = 0; i < 2; i++) {\n+            clientSession.runTest();\n+        }\n+    }\n+\n+    public ResumeClientTLS12withSNI(final String sslProtocol) throws Exception {\n+\n+        KeyManagerFactory kmf = makeKeyManagerFactory(keyFilename,\n+                passphrase);\n+        TrustManagerFactory tmf = makeTrustManagerFactory(trustFilename,\n+                passphrase);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(sslProtocol);\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        sslc = sslCtx;\n+    }\n+\n+    private static KeyManagerFactory makeKeyManagerFactory(String ksPath,\n+                                                           char[] pass) throws GeneralSecurityException, IOException {\n+        KeyManagerFactory kmf;\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+\n+        try (FileInputStream fsIn = new FileInputStream(ksPath)) {\n+            ks.load(fsIn, pass);\n+            kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+            kmf.init(ks, pass);\n+        }\n+        return kmf;\n+    }\n+\n+    private static TrustManagerFactory makeTrustManagerFactory(String tsPath,\n+                                                               char[] pass) throws GeneralSecurityException, IOException {\n+        TrustManagerFactory tmf;\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+\n+        try (FileInputStream fsIn = new FileInputStream(tsPath)) {\n+            ts.load(fsIn, pass);\n+            tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+            tmf.init(ts);\n+        }\n+        return tmf;\n+    }\n+\n+    \/*\n+     * Run the test.\n+     *\n+     * Sit in a tight loop, both engines calling wrap\/unwrap regardless\n+     * of whether data is available or not. We do this until both engines\n+     * report back they are closed.\n+     *\n+     * The main loop handles all of the I\/O phases of the SSLEngine's\n+     * lifetime:\n+     *\n+     * initial handshaking\n+     * application data transfer\n+     * engine closing\n+     *\n+     *\/\n+    private void runTest() throws Exception {\n+        boolean dataDone = false;\n+\n+        createSSLEngines();\n+        createBuffers();\n+\n+        SSLEngineResult clientResult; \/\/ results from client's last operation\n+        SSLEngineResult serverResult; \/\/ results from server's last operation\n+\n+        \/*\n+         * Examining the SSLEngineResults could be much more involved,\n+         * and may alter the overall flow of the application.\n+         *\n+         * For example, if we received a BUFFER_OVERFLOW when trying\n+         * to write to the output pipe, we could reallocate a larger\n+         * pipe, but instead we wait for the peer to drain it.\n+         *\/\n+        while (!isEngineClosed(clientEngine) ||\n+                !isEngineClosed(serverEngine)) {\n+\n+            log(\"================\");\n+\n+            clientResult = clientEngine.wrap(clientOut, cTOs);\n+            if (clientResult.getHandshakeStatus() == HandshakeStatus.FINISHED) {\n+                this.verifySessionResumption(this.previousSessionId, clientEngine);\n+                this.previousSessionId = clientEngine.getSession().getId();\n+            }\n+            log(\"client wrap: \", clientResult);\n+            runDelegatedTasks(clientResult, clientEngine);\n+\n+            serverResult = serverEngine.wrap(serverOut, sTOc);\n+            log(\"server wrap: \", serverResult);\n+            runDelegatedTasks(serverResult, serverEngine);\n+\n+            cTOs.flip();\n+            sTOc.flip();\n+\n+            log(\"-------\");\n+\n+            clientResult = clientEngine.unwrap(sTOc, clientIn);\n+            if (clientResult.getHandshakeStatus() == HandshakeStatus.FINISHED) {\n+                this.verifySessionResumption(this.previousSessionId, clientEngine);\n+                this.previousSessionId = clientEngine.getSession().getId();\n+            }\n+            log(\"client unwrap: \", clientResult);\n+            runDelegatedTasks(clientResult, clientEngine);\n+\n+            serverResult = serverEngine.unwrap(cTOs, serverIn);\n+            log(\"server unwrap: \", serverResult);\n+            runDelegatedTasks(serverResult, serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+\n+            \/*\n+             * After we've transfered all application data between the client\n+             * and server, we close the clientEngine's outbound stream.\n+             * This generates a close_notify handshake message, which the\n+             * server engine receives and responds by closing itself.\n+             *\n+             * In normal operation, each SSLEngine should call\n+             * closeOutbound(). To protect against truncation attacks,\n+             * SSLEngine.closeInbound() should be called whenever it has\n+             * determined that no more input data will ever be\n+             * available (say a closed input stream).\n+             *\/\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n+\n+                \/*\n+                 * A sanity check to ensure we got what was sent.\n+                 *\/\n+                checkTransfer(serverOut, clientIn);\n+                checkTransfer(clientOut, serverIn);\n+\n+                log(\"\\tClosing clientEngine's *OUTBOUND*...\");\n+                clientEngine.closeOutbound();\n+                \/\/ serverEngine.closeOutbound();\n+                dataDone = true;\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Using the SSLContext created during object creation,\n+     * create\/configure the SSLEngines we'll use for this test.\n+     *\/\n+    private void createSSLEngines() throws Exception {\n+        \/*\n+         * Configure the serverEngine to act as a server in the SSL\/TLS\n+         * handshake.\n+         *\/\n+        serverEngine = sslc.createSSLEngine();\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(false);\n+        SSLParameters servSSLParams = serverEngine.getSSLParameters();\n+        servSSLParams.setSNIMatchers(List.of(SNI_MATCHER));\n+        serverEngine.setSSLParameters(servSSLParams);\n+\n+        \/*\n+         * Similar to above, but using client mode instead.\n+         *\/\n+        clientEngine = sslc.createSSLEngine(\"client\", 80);\n+        clientEngine.setUseClientMode(true);\n+        SSLParameters cliSSLParams = clientEngine.getSSLParameters();\n+        cliSSLParams.setServerNames(List.of(SNI_NAME));\n+        clientEngine.setSSLParameters(cliSSLParams);\n+    }\n+\n+    \/*\n+     * Create and size the buffers appropriately.\n+     *\/\n+    private void createBuffers() {\n+\n+        \/*\n+         * We'll assume the buffer sizes are the same\n+         * between client and server.\n+         *\/\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/*\n+         * We'll make the input buffers a bit bigger than the max needed\n+         * size, so that unwrap()s following a successful data transfer\n+         * won't generate BUFFER_OVERFLOWS.\n+         *\n+         * We'll use a mix of direct and indirect ByteBuffers for\n+         * tutorial purposes only. In reality, only use direct\n+         * ByteBuffers when they give a clear performance enhancement.\n+         *\/\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+\n+        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n+\n+    \/*\n+     * If the result indicates that we have outstanding tasks to do,\n+     * go ahead and run them in this thread.\n+     *\/\n+    private static void runDelegatedTasks(SSLEngineResult result,\n+                                          SSLEngine engine) throws Exception {\n+\n+        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"\\trunning delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            log(\"\\tnew HandshakeStatus: \" + hsStatus);\n+        }\n+    }\n+\n+    private static boolean isEngineClosed(SSLEngine engine) {\n+        return (engine.isOutboundDone() && engine.isInboundDone());\n+    }\n+\n+    \/*\n+     * Simple check to make sure everything came across as expected.\n+     *\/\n+    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+            throws Exception {\n+        a.flip();\n+        b.flip();\n+\n+        if (!a.equals(b)) {\n+            throw new Exception(\"Data didn't transfer cleanly\");\n+        } else {\n+            log(\"\\tData transferred cleanly\");\n+        }\n+\n+        a.position(a.limit());\n+        b.position(b.limit());\n+        a.limit(a.capacity());\n+        b.limit(b.capacity());\n+    }\n+\n+    \/*\n+     * Logging code\n+     *\/\n+    private static boolean resultOnce = true;\n+\n+    private static void log(String str, SSLEngineResult result) {\n+        if (!logging) {\n+            return;\n+        }\n+        if (resultOnce) {\n+            resultOnce = false;\n+            System.out.println(\"The format of the SSLEngineResult is: \\n\" +\n+                    \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\" +\n+                    \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n+        }\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+        log(str +\n+                result.getStatus() + \"\/\" + hsStatus + \", \" +\n+                result.bytesConsumed() + \"\/\" + result.bytesProduced() +\n+                \" bytes\");\n+        if (hsStatus == HandshakeStatus.FINISHED) {\n+            log(\"\\t...ready for application data\");\n+        }\n+    }\n+\n+    private static void log(String str) {\n+        if (logging) {\n+            System.out.println(str);\n+        }\n+    }\n+\n+    private void verifySessionResumption(final byte[] expected, final SSLEngine engine) {\n+        if (expected == null) {\n+            \/\/ we haven't yet created a session previously, so there isn't any\n+            \/\/ session to be expected to resume\n+            return;\n+        }\n+        final byte[] sessionId = engine.getSession().getId();\n+        \/\/ compare and verify if they are same\n+        if (Arrays.equals(expected, sessionId)) {\n+            System.out.println(this.sslc.getProvider().getName() + \" \" + this.sslc.getProtocol() + \" - Session resumption SUCCEEDED\");\n+        } else {\n+            System.out.println(this.sslc.getProvider().getName() + \" \" + this.sslc.getProtocol() + \" - Session resumption FAILED\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeClientTLS12withSNI.java","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/keystore_san.p12","binary":true,"status":"added"}]}