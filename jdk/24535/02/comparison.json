{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -314,1 +315,1 @@\n-                ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));\n+                ProtocolVersion.valueOf(Record.getInt16(buf));\n@@ -321,1 +322,1 @@\n-                CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));\n+                CipherSuite.valueOf(Record.getInt16(buf));\n@@ -325,1 +326,1 @@\n-        int i = Byte.toUnsignedInt(buf.get());\n+        int i = Record.getInt8(buf);\n@@ -328,1 +329,1 @@\n-                    Short.toUnsignedInt(buf.getShort())));\n+                    Record.getInt16(buf)));\n@@ -333,1 +334,1 @@\n-        i = Byte.toUnsignedInt(buf.get());\n+        i = Record.getInt8(buf);\n@@ -337,1 +338,1 @@\n-                    Short.toUnsignedInt(buf.getShort())));\n+                    Record.getInt16(buf)));\n@@ -342,11 +343,3 @@\n-        byte[] b;\n-        i = Short.toUnsignedInt(buf.getShort());\n-        if (i > 0) {\n-            b = new byte[i];\n-            \/\/ Get algorithm string\n-            buf.get(b, 0, i);\n-            \/\/ Encoded length\n-            i = Short.toUnsignedInt(buf.getShort());\n-            \/\/ Encoded SecretKey\n-            b = new byte[i];\n-            buf.get(b);\n+        byte[] b = Record.getBytes16(buf);\n+        if (b.length > 0) {\n+            b = Record.getBytes16(buf);\n@@ -359,4 +352,2 @@\n-        i = buf.get();\n-        if (i > 0) {\n-            b = new byte[i];\n-            buf.get(b);\n+        b = Record.getBytes8(buf);\n+        if (b.length > 0) {\n@@ -369,10 +360,3 @@\n-        i = buf.get();\n-        if (i > 0) {\n-            b = new byte[i];\n-            \/\/ Get algorithm string\n-            buf.get(b, 0, i);\n-            \/\/ Encoded length\n-            i = Short.toUnsignedInt(buf.getShort());\n-            \/\/ Encoded SecretKey\n-            b = new byte[i];\n-            buf.get(b);\n+        b = Record.getBytes8(buf);\n+        if (b.length > 0) {\n+            b = Record.getBytes16(buf);\n@@ -383,0 +367,1 @@\n+\n@@ -384,1 +369,1 @@\n-        this.useExtendedMasterSecret = (buf.get() != 0);\n+        this.useExtendedMasterSecret = (Record.getInt8(buf) != 0);\n@@ -387,2 +372,2 @@\n-        i = buf.get();\n-        if (i == 0) {\n+        b = Record.getBytes8(buf);\n+        if (b.length == 0) {\n@@ -391,2 +376,0 @@\n-            b = new byte[i];\n-            buf.get(b);\n@@ -397,2 +380,2 @@\n-        i = buf.get();  \/\/ length\n-        if (i == 0) {\n+        b = Record.getBytes8(buf);\n+        if (b.length == 0) {\n@@ -401,2 +384,0 @@\n-            b = new byte[i];\n-            buf.get(b, 0, b.length);\n@@ -407,1 +388,1 @@\n-        int len = Short.toUnsignedInt(buf.getShort());\n+        int len = Record.getInt16(buf);\n@@ -413,3 +394,1 @@\n-                int l = buf.get();\n-                b = new byte[l];\n-                buf.get(b, 0, l);\n+                b = Record.getBytes8(buf);\n@@ -420,1 +399,0 @@\n-\n@@ -430,1 +408,1 @@\n-        len = Short.toUnsignedInt(buf.getShort());\n+        len = Record.getInt16(buf);\n@@ -437,2 +415,1 @@\n-            b = new byte[Short.toUnsignedInt(buf.getShort())];\n-            buf.get(b);\n+            b = Record.getBytes16(buf);\n@@ -443,2 +420,2 @@\n-        i = Byte.toUnsignedInt(buf.get());\n-        if (i == 0) {\n+        b = Record.getBytes8(buf);\n+        if (b.length == 0) {\n@@ -447,2 +424,0 @@\n-            b = new byte[i];\n-            buf.get(b, 0, i);\n@@ -451,1 +426,1 @@\n-        this.port = Short.toUnsignedInt(buf.getShort());\n+        this.port = Record.getInt16(buf);\n@@ -454,1 +429,1 @@\n-        i = buf.get();\n+        i = Record.getInt8(buf);\n@@ -473,1 +448,1 @@\n-        switch (buf.get()) {\n+        switch (Record.getInt8(buf)) {\n@@ -495,3 +470,1 @@\n-                i = buf.get();\n-                b = new byte[i];\n-                buf.get(b, 0, i);\n+                b = Record.getBytes8(buf);\n@@ -499,2 +472,0 @@\n-                \/\/ Get length of encoding\n-                i = Short.toUnsignedInt(buf.getShort());\n@@ -502,2 +473,1 @@\n-                b = new byte[i];\n-                buf.get(b);\n+                b = Record.getBytes16(buf);\n@@ -506,1 +476,1 @@\n-                i = buf.get();\n+                i = Record.getInt8(buf);\n@@ -508,2 +478,1 @@\n-                    this.pskIdentity = new byte[buf.get()];\n-                    buf.get(pskIdentity);\n+                    this.pskIdentity = Record.getBytes8(buf);\n@@ -523,0 +492,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":35,"deletions":65,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -0,0 +1,367 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350830\n+ * @summary TLS 1.2 Client session resumption having ServerNameIndication\n+ * @modules java.base\/sun.security.tools.keytool\n+ * @run main\/othervm -Djavax.net.debug=all ResumeClientTLS12withSNI\n+ *\/\n+\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.util.*;\n+\n+public class ResumeClientTLS12withSNI {\n+\n+    \/*\n+     * Enables logging of the SSLEngine operations.\n+     *\/\n+    private static final boolean logging = true;\n+\n+    private static SSLContext sslc;\n+\n+    private SSLEngine clientEngine; \/\/ client Engine\n+    private ByteBuffer clientOut; \/\/ write side of clientEngine\n+    private ByteBuffer clientIn; \/\/ read side of clientEngine\n+\n+    private SSLEngine serverEngine; \/\/ server Engine\n+    private ByteBuffer serverOut; \/\/ write side of serverEngine\n+    private ByteBuffer serverIn; \/\/ read side of serverEngine\n+\n+    \/*\n+     * For data transport, this example uses local ByteBuffers.\n+     *\/\n+    private ByteBuffer cTOs; \/\/ \"reliable\" transport client->server\n+    private ByteBuffer sTOc; \/\/ \"reliable\" transport server->client\n+\n+    \/*\n+     * The following is to set up the keystores.\n+     *\/\n+    private static final String pathToStores = System.getProperty(\"test.src\", \".\");\n+    private static final String keyStoreFile = \"ks_san.p12\";\n+    private static final String trustStoreFile = \"ks_san.p12\";\n+    private static final char[] passphrase = \"123456\".toCharArray();\n+\n+    private static final String keyFilename =\n+            pathToStores + \"\/\" + keyStoreFile;\n+    private static final String trustFilename =\n+            pathToStores + \"\/\" + trustStoreFile;\n+\n+    private static final String HOST_NAME = \"arf.yak.foo.localhost123456.localhost123456.localhost123456.localhost123456.localhost123456.localhost123456.\"\n+            + \"localhost123456.localhost123456.localhost123456.localhost123456.localhost123456.localhost123456\";\n+    private static final SNIMatcher SNI_MATCHER = SNIHostName.createSNIMatcher(\"arf\\\\.yak\\\\.foo.*\");\n+\n+    \/*\n+     * Main entry point for this test.\n+     *\/\n+    public static void main(String args[]) throws Exception {\n+        Files.deleteIfExists(Path.of(keyFilename));\n+\n+        sun.security.tools.keytool.Main.main(\n+                (\"-keystore \" + keyFilename + \" -storepass 123456 -keypass 123456 -dname\"\n+                 + \" CN=test\" + \" -alias ks_san -genkeypair -keyalg rsa -ext \"\n+                 + \"san=dns:localhost123.localhost123.localhost123.localhost123.\"\n+                 + \"localhost123.localhost123.localhost123.localhost123.localhost123.\"\n+                 + \"localhost123.localhost123.localhost123.localhost123.localhost123.\"\n+                 + \"localhost123.localhost123.localhost123.localhost123.localhost123.com,\"\n+                 + \"dns:localhost456\").split(\" \"));\n+        final ResumeClientTLS12withSNI clientSession = new ResumeClientTLS12withSNI(\"TLSv1.2\");\n+        for (int i = 0; i < 2; i++) {\n+            clientSession.runTest();\n+        }\n+\n+        Files.deleteIfExists(Path.of(keyFilename));\n+    }\n+\n+    public ResumeClientTLS12withSNI(final String sslProtocol) throws Exception {\n+\n+        KeyManagerFactory kmf = makeKeyManagerFactory(keyFilename,\n+                passphrase);\n+        TrustManagerFactory tmf = makeTrustManagerFactory(trustFilename,\n+                passphrase);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(sslProtocol);\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        sslc = sslCtx;\n+    }\n+\n+    private static KeyManagerFactory makeKeyManagerFactory(String ksPath,\n+                                                           char[] pass) throws GeneralSecurityException, IOException {\n+        KeyManagerFactory kmf;\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+\n+        try (FileInputStream fsIn = new FileInputStream(ksPath)) {\n+            ks.load(fsIn, pass);\n+            kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+            kmf.init(ks, pass);\n+        }\n+        return kmf;\n+    }\n+\n+    private static TrustManagerFactory makeTrustManagerFactory(String tsPath,\n+                                                               char[] pass) throws GeneralSecurityException, IOException {\n+        TrustManagerFactory tmf;\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+\n+        try (FileInputStream fsIn = new FileInputStream(tsPath)) {\n+            ts.load(fsIn, pass);\n+            tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+            tmf.init(ts);\n+        }\n+        return tmf;\n+    }\n+\n+    \/*\n+     * Run the test.\n+     *\n+     * Sit in a tight loop, both engines calling wrap\/unwrap regardless\n+     * of whether data is available or not. We do this until both engines\n+     * report back they are closed.\n+     *\n+     * The main loop handles all of the I\/O phases of the SSLEngine's\n+     * lifetime:\n+     *\n+     * initial handshaking\n+     * application data transfer\n+     * engine closing\n+     *\n+     *\/\n+    private void runTest() throws Exception {\n+        boolean dataDone = false;\n+\n+        createSSLEngines();\n+        createBuffers();\n+\n+        SSLEngineResult clientResult; \/\/ results from client's last operation\n+        SSLEngineResult serverResult; \/\/ results from server's last operation\n+\n+        \/*\n+         * Examining the SSLEngineResults could be much more involved,\n+         * and may alter the overall flow of the application.\n+         *\n+         * For example, if we received a BUFFER_OVERFLOW when trying\n+         * to write to the output pipe, we could reallocate a larger\n+         * pipe, but instead we wait for the peer to drain it.\n+         *\/\n+        while (!isEngineClosed(clientEngine) ||\n+                !isEngineClosed(serverEngine)) {\n+\n+            log(\"================\");\n+\n+            clientResult = clientEngine.wrap(clientOut, cTOs);\n+            log(\"client wrap: \", clientResult);\n+            runDelegatedTasks(clientResult, clientEngine);\n+\n+            serverResult = serverEngine.wrap(serverOut, sTOc);\n+            log(\"server wrap: \", serverResult);\n+            runDelegatedTasks(serverResult, serverEngine);\n+\n+            cTOs.flip();\n+            sTOc.flip();\n+\n+            log(\"-------\");\n+\n+            clientResult = clientEngine.unwrap(sTOc, clientIn);\n+            log(\"client unwrap: \", clientResult);\n+            runDelegatedTasks(clientResult, clientEngine);\n+\n+            serverResult = serverEngine.unwrap(cTOs, serverIn);\n+            log(\"server unwrap: \", serverResult);\n+            runDelegatedTasks(serverResult, serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+\n+            \/*\n+             * After we've transfered all application data between the client\n+             * and server, we close the clientEngine's outbound stream.\n+             * This generates a close_notify handshake message, which the\n+             * server engine receives and responds by closing itself.\n+             *\n+             * In normal operation, each SSLEngine should call\n+             * closeOutbound(). To protect against truncation attacks,\n+             * SSLEngine.closeInbound() should be called whenever it has\n+             * determined that no more input data will ever be\n+             * available (say a closed input stream).\n+             *\/\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n+\n+                \/*\n+                 * A sanity check to ensure we got what was sent.\n+                 *\/\n+                checkTransfer(serverOut, clientIn);\n+                checkTransfer(clientOut, serverIn);\n+\n+                log(\"\\tClosing clientEngine's *OUTBOUND*...\");\n+                clientEngine.closeOutbound();\n+                \/\/ serverEngine.closeOutbound();\n+                dataDone = true;\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Using the SSLContext created during object creation,\n+     * create\/configure the SSLEngines we'll use for this test.\n+     *\/\n+    private void createSSLEngines() throws Exception {\n+        \/*\n+         * Configure the serverEngine to act as a server in the SSL\/TLS\n+         * handshake.\n+         *\/\n+        serverEngine = sslc.createSSLEngine();\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(false);\n+        SSLParameters servSSLParams = serverEngine.getSSLParameters();\n+        servSSLParams.setSNIMatchers(List.of(SNI_MATCHER));\n+        serverEngine.setSSLParameters(servSSLParams);\n+\n+        \/*\n+         * Similar to above, but using client mode instead.\n+         *\/\n+        clientEngine = sslc.createSSLEngine(HOST_NAME, 80);\n+        clientEngine.setUseClientMode(true);\n+        SSLParameters cliSSLParams = clientEngine.getSSLParameters();\n+        clientEngine.setSSLParameters(cliSSLParams);\n+    }\n+\n+    \/*\n+     * Create and size the buffers appropriately.\n+     *\/\n+    private void createBuffers() {\n+\n+        \/*\n+         * We'll assume the buffer sizes are the same\n+         * between client and server.\n+         *\/\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/*\n+         * We'll make the input buffers a bit bigger than the max needed\n+         * size, so that unwrap()s following a successful data transfer\n+         * won't generate BUFFER_OVERFLOWS.\n+         *\n+         * We'll use a mix of direct and indirect ByteBuffers for\n+         * tutorial purposes only. In reality, only use direct\n+         * ByteBuffers when they give a clear performance enhancement.\n+         *\/\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+\n+        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n+\n+    \/*\n+     * If the result indicates that we have outstanding tasks to do,\n+     * go ahead and run them in this thread.\n+     *\/\n+    private static void runDelegatedTasks(SSLEngineResult result,\n+                                          SSLEngine engine) throws Exception {\n+\n+        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"\\trunning delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            log(\"\\tnew HandshakeStatus: \" + hsStatus);\n+        }\n+    }\n+\n+    private static boolean isEngineClosed(SSLEngine engine) {\n+        return (engine.isOutboundDone() && engine.isInboundDone());\n+    }\n+\n+    \/*\n+     * Simple check to make sure everything came across as expected.\n+     *\/\n+    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+            throws Exception {\n+        a.flip();\n+        b.flip();\n+\n+        if (!a.equals(b)) {\n+            throw new Exception(\"Data didn't transfer cleanly\");\n+        } else {\n+            log(\"\\tData transferred cleanly\");\n+        }\n+\n+        a.position(a.limit());\n+        b.position(b.limit());\n+        a.limit(a.capacity());\n+        b.limit(b.capacity());\n+    }\n+\n+    \/*\n+     * Logging code\n+     *\/\n+    private static boolean resultOnce = true;\n+\n+    private static void log(String str, SSLEngineResult result) {\n+        if (!logging) {\n+            return;\n+        }\n+        if (resultOnce) {\n+            resultOnce = false;\n+            System.out.println(\"The format of the SSLEngineResult is: \\n\" +\n+                    \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\" +\n+                    \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n+        }\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+        log(str +\n+                result.getStatus() + \"\/\" + hsStatus + \", \" +\n+                result.bytesConsumed() + \"\/\" + result.bytesProduced() +\n+                \" bytes\");\n+        if (hsStatus == HandshakeStatus.FINISHED) {\n+            log(\"\\t...ready for application data\");\n+        }\n+    }\n+\n+    private static void log(String str) {\n+        if (logging) {\n+            System.out.println(str);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeClientTLS12withSNI.java","additions":367,"deletions":0,"binary":false,"changes":367,"status":"added"}]}