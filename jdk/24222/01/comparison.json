{"files":[{"patch":"@@ -110,0 +110,4 @@\n+\n+#ifdef ASSERT\n+  bool skip_card_enqueue_set() const { return _skip_card_enqueue != Uninitialized; }\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -241,2 +241,1 @@\n-void G1ParScanThreadState::start_partial_objarray(G1HeapRegionAttr dest_attr,\n-                                                  oop from_obj,\n+void G1ParScanThreadState::start_partial_objarray(oop from_obj,\n@@ -254,6 +253,1 @@\n-  \/\/ Skip the card enqueue iff the object (to_array) is in survivor region.\n-  \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n-  \/\/ Instead, we use dest_attr.is_young() because the two values are always\n-  \/\/ equal: successfully allocated young regions must be survivor regions.\n-  assert(dest_attr.is_young() == _g1h->heap_region_containing(to_array)->is_survivor(), \"must be\");\n-  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n+  assert(_scanner.skip_card_enqueue_set(), \"must be\");\n@@ -425,0 +419,39 @@\n+ALWAYSINLINE\n+void G1ParScanThreadState::do_iterate_object(oop const obj,\n+                                             oop const old,\n+                                             Klass* const klass,\n+                                             G1HeapRegionAttr const region_attr,\n+                                             G1HeapRegionAttr const dest_attr,\n+                                             uint age) {\n+    \/\/ Most objects are not arrays, so do one array check rather than\n+    \/\/ checking for each array category for each object.\n+    if (klass->is_array_klass()) {\n+      assert(!klass->is_stack_chunk_instance_klass(), \"must be\");\n+\n+      if (klass->is_objArray_klass()) {\n+        start_partial_objarray(old, obj);\n+      } else {\n+        \/\/ Nothing needs to be done for typeArrays.  Body doesn't contain\n+        \/\/ any oops to scan, and the type in the klass will already be handled\n+        \/\/ by processing the built-in module.\n+        assert(klass->is_typeArray_klass(), \"invariant\");\n+      }\n+      return;\n+    }\n+\n+    ContinuationGCSupport::transform_stack_chunk(obj);\n+\n+    \/\/ Check for deduplicating young Strings.\n+    if (G1StringDedup::is_candidate_from_evacuation(klass,\n+                                                    region_attr,\n+                                                    dest_attr,\n+                                                    age)) {\n+      \/\/ Record old; request adds a new weak reference, which reference\n+      \/\/ processing expects to refer to a from-space object.\n+      _string_dedup_requests.add(old);\n+    }\n+\n+    assert(_scanner.skip_card_enqueue_set(), \"must be\");\n+    obj->oop_iterate_backwards(&_scanner, klass);\n+}\n+\n@@ -449,1 +482,1 @@\n-    return handle_evacuation_failure_par(old, old_mark, word_sz, true \/* cause_pinned *\/);\n+    return handle_evacuation_failure_par(old, old_mark, klass, region_attr, word_sz, true \/* cause_pinned *\/);\n@@ -466,1 +499,1 @@\n-      return handle_evacuation_failure_par(old, old_mark, word_sz, false \/* cause_pinned *\/);\n+      return handle_evacuation_failure_par(old, old_mark, klass, region_attr, word_sz, false \/* cause_pinned *\/);\n@@ -478,1 +511,1 @@\n-    return handle_evacuation_failure_par(old, old_mark, word_sz, false \/* cause_pinned *\/);\n+    return handle_evacuation_failure_par(old, old_mark, klass, region_attr, word_sz, false \/* cause_pinned *\/);\n@@ -510,24 +543,8 @@\n-    \/\/ Most objects are not arrays, so do one array check rather than\n-    \/\/ checking for each array category for each object.\n-    if (klass->is_array_klass()) {\n-      if (klass->is_objArray_klass()) {\n-        start_partial_objarray(dest_attr, old, obj);\n-      } else {\n-        \/\/ Nothing needs to be done for typeArrays.  Body doesn't contain\n-        \/\/ any oops to scan, and the type in the klass will already be handled\n-        \/\/ by processing the built-in module.\n-        assert(klass->is_typeArray_klass(), \"invariant\");\n-      }\n-      return obj;\n-    }\n-\n-    ContinuationGCSupport::transform_stack_chunk(obj);\n-\n-    \/\/ Check for deduplicating young Strings.\n-    if (G1StringDedup::is_candidate_from_evacuation(klass,\n-                                                    region_attr,\n-                                                    dest_attr,\n-                                                    age)) {\n-      \/\/ Record old; request adds a new weak reference, which reference\n-      \/\/ processing expects to refer to a from-space object.\n-      _string_dedup_requests.add(old);\n+    {\n+      \/\/ Skip the card enqueue iff the object (obj) is in survivor region.\n+      \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n+      \/\/ Instead, we use dest_attr.is_young() because the two values are always\n+      \/\/ equal: successfully allocated young regions must be survivor regions.\n+      assert(dest_attr.is_young() == _g1h->heap_region_containing(obj)->is_survivor(), \"must be\");\n+      G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n+      do_iterate_object(obj, old, klass, region_attr, dest_attr, age);\n@@ -536,7 +553,0 @@\n-    \/\/ Skip the card enqueue iff the object (obj) is in survivor region.\n-    \/\/ However, G1HeapRegion::is_survivor() is too expensive here.\n-    \/\/ Instead, we use dest_attr.is_young() because the two values are always\n-    \/\/ equal: successfully allocated young regions must be survivor regions.\n-    assert(dest_attr.is_young() == _g1h->heap_region_containing(obj)->is_survivor(), \"must be\");\n-    G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_young());\n-    obj->oop_iterate_backwards(&_scanner, klass);\n@@ -624,1 +634,1 @@\n-oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m, size_t word_sz, bool cause_pinned) {\n+oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m, Klass* klass, G1HeapRegionAttr attr, size_t word_sz, bool cause_pinned) {\n@@ -638,2 +648,0 @@\n-    ContinuationGCSupport::transform_stack_chunk(old);\n-\n@@ -642,6 +650,8 @@\n-    \/\/ For iterating objects that failed evacuation currently we can reuse the\n-    \/\/ existing closure to scan evacuated objects; since we are iterating from a\n-    \/\/ collection set region (i.e. never a Survivor region), we always need to\n-    \/\/ gather cards for this case.\n-    G1SkipCardEnqueueSetter x(&_scanner, false \/* skip_card_enqueue *\/);\n-    old->oop_iterate_backwards(&_scanner);\n+    {\n+      \/\/ For iterating objects that failed evacuation currently we can reuse the\n+      \/\/ existing closure to scan evacuated objects; since we are iterating from a\n+      \/\/ collection set region (i.e. never a Survivor region), we always need to\n+      \/\/ gather cards for this case.\n+      G1SkipCardEnqueueSetter x(&_scanner, false \/* skip_card_enqueue *\/);\n+      do_iterate_object(old, old, klass, attr, attr, m.age());\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":61,"deletions":51,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-  void start_partial_objarray(G1HeapRegionAttr dest_dir, oop from, oop to);\n+  void start_partial_objarray(oop from, oop to);\n@@ -186,0 +186,6 @@\n+  void do_iterate_object(oop const obj,\n+                         oop const old,\n+                         Klass* const klass,\n+                         G1HeapRegionAttr const region_attr,\n+                         G1HeapRegionAttr const dest_attr,\n+                         uint age);\n@@ -233,1 +239,1 @@\n-  oop handle_evacuation_failure_par(oop obj, markWord m, size_t word_sz, bool cause_pinned);\n+  oop handle_evacuation_failure_par(oop obj, markWord m, Klass* klass, G1HeapRegionAttr attr, size_t word_sz, bool cause_pinned);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-        private static byte[] garbage;\n@@ -73,1 +72,1 @@\n-                holder[i % holder.length] = new byte[1024];\n+                holder[i % holder.length] = new Object[256];\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestAllocationFailure.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}