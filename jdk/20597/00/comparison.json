{"files":[{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+#include <limits>\n+#include <iostream>\n+\n+#include <winnt.h>\n+#include <memoryapi.h>\n+#include <psapi.h>\n+\n+class MappingInfo {\n+    static const int MAX_STR_LEN = 20;\n+public:\n+    char apBuffer[MAX_STR_LEN];\n+    char stateBuffer[MAX_STR_LEN];\n+    char protectBuffer[MAX_STR_LEN];\n+    char typeBuffer[MAX_STR_LEN];\n+    char fileName[MAX_PATH];\n+\n+    MappingInfo() {}\n+\n+    void process(MEMORY_BASIC_INFORMATION& mInfo) {\n+        getProtectString(apBuffer, sizeof(apBuffer), mInfo.AllocationProtect);\n+        getStateString(stateBuffer, sizeof(stateBuffer), mInfo);\n+        getProtectString(protectBuffer, sizeof(protectBuffer), mInfo.Protect);\n+        getTypeString(typeBuffer, sizeof(typeBuffer), mInfo);\n+        fileName[0] = 0;\n+        if (mInfo.Type == MEM_IMAGE) {\n+            HMODULE hModule = 0;\n+            if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, static_cast<LPCSTR>(mInfo.AllocationBase), &hModule)) {\n+                GetModuleFileName(hModule, fileName, sizeof(fileName));\n+            }\n+        }\n+    }\n+\n+    const char* getProtectString(char* buffer, size_t bufsiz, DWORD prot) {\n+        const int IR = 0;\n+        const int IW = 1;\n+        const int IX = 2;\n+        const int IP = 3;\n+        int idx = 4;\n+        strncpy_s(buffer, bufsiz, \"----  \", 7);\n+        if (prot & PAGE_EXECUTE) {\n+            buffer[IX] = 'x';\n+        } else if (prot & PAGE_EXECUTE_READ) {\n+            buffer[IR] = 'r';\n+            buffer[IX] = 'x';\n+        } else if (prot & PAGE_EXECUTE_READWRITE) {\n+            buffer[IR] = 'r';\n+            buffer[IW] = 'w';\n+            buffer[IX] = 'x';\n+        } else if (prot & PAGE_EXECUTE_WRITECOPY) {\n+            buffer[IW] = 'w';\n+            buffer[IX] = 'x';\n+            buffer[idx++] = 'c';\n+        } else if (prot & PAGE_NOACCESS) {\n+            strncpy_s(buffer, bufsiz, \"(NA)\", 5);\n+        } else if (prot & PAGE_READONLY) {\n+            buffer[IR] = 'r';\n+        } else if (prot & PAGE_READWRITE) {\n+            buffer[IR] = 'r';\n+            buffer[IW] = 'w';\n+        } else if (prot & PAGE_WRITECOPY) {\n+            buffer[IW] = 'w';\n+            buffer[idx++] = 'c';\n+        } else if (prot & PAGE_TARGETS_INVALID) {\n+            buffer[idx++] = 'i';\n+        } else if (prot & PAGE_TARGETS_NO_UPDATE) {\n+            buffer[idx++] = 'n';\n+        } else if (prot != 0) {\n+            snprintf(buffer, bufsiz, \"(0x%x)\", prot);\n+            idx = static_cast<int>(strlen(buffer));\n+        }\n+\n+        if (prot & PAGE_GUARD) {\n+            buffer[idx++] = 'G';\n+        }\n+        if (prot & PAGE_NOCACHE) {\n+            buffer[idx++] = 'C';\n+        }\n+        if (prot & PAGE_WRITECOMBINE) {\n+            buffer[idx++] = 'W';\n+        }\n+        buffer[idx] = 0;\n+        return buffer;\n+    }\n+    const char* getStateString(char* buffer, size_t bufsiz, MEMORY_BASIC_INFORMATION& mInfo) {\n+        if (mInfo.State == MEM_COMMIT) {\n+            buffer[0] = 'c'; buffer[1] = 0;\n+        } else if (mInfo.State == MEM_FREE) {\n+            buffer[0] = 'f'; buffer[1] = 0;\n+        } else if (mInfo.State == MEM_RESERVE) {\n+            buffer[0] = 'r'; buffer[1] = 0;\n+        } else {\n+            snprintf(buffer, bufsiz, \"0x%x\", mInfo.State);\n+        }\n+        return buffer;\n+    }\n+\n+    const char* getTypeString(char* buffer, size_t bufsiz, MEMORY_BASIC_INFORMATION& mInfo) {\n+        if (mInfo.Type == MEM_IMAGE) {\n+            strncpy_s(buffer, bufsiz, \"img\", 4);\n+        } else if (mInfo.Type == MEM_MAPPED) {\n+            strncpy_s(buffer, bufsiz, \"map\", 4);\n+        } else if (mInfo.Type == MEM_PRIVATE) {\n+            strncpy_s(buffer, bufsiz, \"pvt\", 4);\n+        } else {\n+            snprintf(buffer, bufsiz, \"0x%x\", mInfo.Type);\n+        }\n+        return buffer;\n+    }\n+};\n+\n+class MappingInfoSummary {\n+  unsigned _num_mappings;\n+  size_t _total_region_size;  \/\/ combined resident set size\n+  size_t _total_committed;    \/\/ combined committed size\n+  size_t _total_reserved;     \/\/ combined shared size\n+public:\n+  MappingInfoSummary() : _num_mappings(0),  _total_region_size(0),\n+                      _total_committed(0), _total_reserved(0) {}\n+\n+  void add_mapping(const MEMORY_BASIC_INFORMATION& mInfo, const MappingInfo& info) {\n+    if (mInfo.State != MEM_FREE) {\n+      _num_mappings++;\n+      _total_region_size += mInfo.RegionSize;\n+      _total_committed += mInfo.State == MEM_COMMIT ? mInfo.RegionSize : 0;\n+      _total_reserved += mInfo.State == MEM_RESERVE ? mInfo.RegionSize : 0;\n+    }\n+  }\n+\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+    os::print_os_info(st);\n+    os::print_memory_info(st);\n+    st->print_cr(\"current process reserved memory: \" PROPERFMT, PROPERFMTARGS(_total_reserved));\n+  }\n+};\n+\n+class MappingInfoPrinter {\n+  const MappingPrintSession& _session;\n+public:\n+  MappingInfoPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n+\n+  void print_single_mapping(const MEMORY_BASIC_INFORMATION& mInfo, const MappingInfo& info) const {\n+    outputStream* st = _session.out();\n+#define INDENT_BY(n)          \\\n+  if (st->fill_to(n) == 0) {  \\\n+    st->print(\" \");           \\\n+  }\n+    st->print(PTR_FORMAT \"-\" PTR_FORMAT, mInfo.BaseAddress, static_cast<const char*>(mInfo.BaseAddress) + mInfo.RegionSize);\n+    INDENT_BY(38);\n+    st->print(\"%12zu\", mInfo.RegionSize);\n+    INDENT_BY(51);\n+    st->print(\"%s\", info.protectBuffer);\n+    INDENT_BY(57);\n+    st->print(\"%s-%s\", info.stateBuffer, info.typeBuffer);\n+    INDENT_BY(60);\n+    st->print(\"%#9llx\", reinterpret_cast<const unsigned long long>(mInfo.BaseAddress) - reinterpret_cast<const unsigned long long>(mInfo.AllocationBase));\n+    INDENT_BY(72);\n+    if (_session.print_nmt_info_for_region(mInfo.BaseAddress, static_cast<const char*>(mInfo.BaseAddress) + mInfo.RegionSize)) {\n+      st->print(\" \");\n+    }\n+    st->print_raw(info.fileName);\n+  #undef INDENT_BY\n+    st->cr();\n+  }\n+\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:    protection:\");\n+    st->print_cr(\"             rwx: read \/ write \/ execute\");\n+    st->print_cr(\"             c: copy on write\");\n+    st->print_cr(\"             G: guard\");\n+    st->print_cr(\"             C: no cache\");\n+    st->print_cr(\"             W: write combine\");\n+    st->print_cr(\"             i: targets invalid\");\n+    st->print_cr(\"             n: targets noupdate\");\n+    st->print_cr(\"state:   region state and type:\");\n+    st->print_cr(\"             state: committed \/ reserved\");\n+    st->print_cr(\"             type: image \/ mapped \/ private\");\n+    st->print_cr(\"file:    file mapped, if mapping is not anonymous\");\n+    st->print_cr(\"vm info: VM information (requires NMT)\");\n+    {\n+      streamIndentor si(st, 16);\n+      _session.print_nmt_flag_legend();\n+    }\n+  }\n+\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            0         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x00007ffd5bd64000-0x00007ffd5c250000      5160960 r---  c-img 0x10d4000 C:\\work\\jdk\\build\\work-fastdebug\\jdk\\bin\\server\\jvm.dll\n+    st->print_cr(\"from               to                        vsize prot  state    offset vm info\/file\");\n+    st->print_cr(\"=============================================================================================================================\");\n+  }\n+};\n+\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+\n+    HANDLE hProcess = GetCurrentProcess();\n+\n+    MappingInfoPrinter printer(session);\n+    MappingInfoSummary summary;\n+\n+    outputStream* const st = session.out();\n+\n+    printer.print_legend();\n+    st->cr();\n+    printer.print_header();\n+\n+    MEMORY_BASIC_INFORMATION mInfo;\n+    MappingInfo info;\n+\n+    for (char* ptr = 0; VirtualQueryEx(hProcess, ptr, &mInfo, sizeof(mInfo)) == sizeof(mInfo); ptr += mInfo.RegionSize) {\n+      info.process(mInfo);\n+      if (mInfo.State != MEM_FREE) {\n+        printer.print_single_mapping(mInfo, info);\n+        summary.add_mapping(mInfo, info);\n+      }\n+    }\n+    st->cr();\n+    summary.print_on(session);\n+    st->cr();\n+}\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-#ifdef LINUX\n+#if defined(LINUX) || defined(_WIN64)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#ifdef LINUX\n+#if defined(LINUX) || defined(_WIN64)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+#endif \/\/ LINUX\n+#if defined(LINUX) || defined(_WIN64)\n@@ -143,1 +145,1 @@\n-#endif \/\/ LINUX\n+#endif \/\/ LINUX or WINDOWS\n@@ -1176,1 +1178,1 @@\n-#ifdef LINUX\n+#if defined(LINUX) || defined(_WIN64)\n@@ -1200,0 +1202,1 @@\n+#ifndef _WIN64\n@@ -1204,0 +1207,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -984,1 +984,1 @@\n-#ifdef LINUX\n+#if defined(LINUX) || defined(_WIN64)\n@@ -1020,1 +1020,1 @@\n-#endif \/\/ LINUX\n+#endif \/\/ LINUX or WINDOWS\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires (os.family==\"linux\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\")\n@@ -66,1 +66,1 @@\n-            for (String s: shouldMatchUnconditionally) {\n+            for (String s: shouldMatchUnconditionally()) {\n@@ -70,1 +70,1 @@\n-                for (String s: shouldMatchIfNMTIsEnabled) {\n+                for (String s: shouldMatchIfNMTIsEnabled()) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires (os.family==\"linux\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\")\n@@ -45,1 +45,1 @@\n-        for (String s: shouldMatchUnconditionally) {\n+        for (String s: shouldMatchUnconditionally()) {\n@@ -49,1 +49,1 @@\n-            for (String s: shouldMatchIfNMTIsEnabled) {\n+            for (String s: shouldMatchIfNMTIsEnabled()) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -32,0 +34,1 @@\n+    private static final String someNumber = \"(0x\\\\p{XDigit}+|\\\\d+)\";\n@@ -47,1 +50,2 @@\n-    protected static final String shouldMatchUnconditionally[] = {\n+\n+    private static final String shouldMatchUnconditionally_linux[] = {\n@@ -58,1 +62,1 @@\n-    protected static final String shouldMatchIfNMTIsEnabled[] = {\n+    private static final String shouldMatchIfNMTIsEnabled_linux[] = {\n@@ -69,0 +73,39 @@\n+\n+    \/\/ windows:\n+    private static final String winprot = \"[\\\\-rwxcin]*\";\n+    private static final String wintype = \"[rc]-(img|map|pvt)\";\n+\n+    private static final String winbase = range + space + someSize + space + winprot + space;\n+\n+    private static final String winimage     = winbase + \"c-img\" + space + someNumber + space;\n+    private static final String wincommitted = winbase + \"c-pvt\" + space + someNumber + space;\n+    private static final String winreserved  = winbase + \"r-pvt\" + space + someNumber + space;\n+\n+    private static final String shouldMatchUnconditionally_windows[] = {\n+        \/\/ java launcher\n+        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\]java[.]exe\",\n+        \/\/ libjvm\n+        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\].*[\\\\\/\\\\\\\\]jvm.dll\"\n+    };\n+\n+    private static final String shouldMatchIfNMTIsEnabled_windows[] = {\n+        wincommitted + \"JAVAHEAP.*\",\n+        \/\/ metaspace\n+        wincommitted + \"META.*\",\n+        \/\/ parts of metaspace should be uncommitted\n+        winreserved + \"META.*\",\n+        \/\/ code cache\n+        wincommitted + \"CODE.*\",\n+        \/\/ Main thread stack\n+        wincommitted + \"STACK-\\\\d+-main.*\"\n+    };\n+\n+    private static final boolean isWindows = Platform.isWindows();\n+\n+    protected static String[] shouldMatchUnconditionally() {\n+        return isWindows ? shouldMatchUnconditionally_windows : shouldMatchUnconditionally_linux;\n+    }\n+    protected static String[] shouldMatchIfNMTIsEnabled() {\n+        return isWindows ? shouldMatchIfNMTIsEnabled_windows : shouldMatchIfNMTIsEnabled_linux;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"}]}