{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, 2024, Red Hat, Inc. and\/or its affiliates.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n@@ -31,3 +31,1 @@\n-#include <limits>\n-#include <iostream>\n-\n+#include <limits.h>\n@@ -38,0 +36,3 @@\n+\/* maximum number of mapping records returned *\/\n+static const int MAX_REGIONS_RETURNED = 1000000;\n+\n@@ -39,1 +40,0 @@\n-    static const int MAX_STR_LEN = 20;\n@@ -41,20 +41,23 @@\n-    char apBuffer[MAX_STR_LEN];\n-    char stateBuffer[MAX_STR_LEN];\n-    char protectBuffer[MAX_STR_LEN];\n-    char typeBuffer[MAX_STR_LEN];\n-    char fileName[MAX_PATH];\n-\n-    MappingInfo() {}\n-\n-    void process(MEMORY_BASIC_INFORMATION& mInfo) {\n-        getProtectString(apBuffer, sizeof(apBuffer), mInfo.AllocationProtect);\n-        getStateString(stateBuffer, sizeof(stateBuffer), mInfo);\n-        getProtectString(protectBuffer, sizeof(protectBuffer), mInfo.Protect);\n-        getTypeString(typeBuffer, sizeof(typeBuffer), mInfo);\n-        fileName[0] = 0;\n-        if (mInfo.Type == MEM_IMAGE) {\n-            HMODULE hModule = 0;\n-            if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, static_cast<LPCSTR>(mInfo.AllocationBase), &hModule)) {\n-                GetModuleFileName(hModule, fileName, sizeof(fileName));\n-            }\n-        }\n+  stringStream _ap_buffer;\n+  stringStream _state_buffer;\n+  stringStream _protect_buffer;\n+  stringStream _type_buffer;\n+  char _file_name[MAX_PATH];\n+\n+  MappingInfo() {}\n+\n+  void process(MEMORY_BASIC_INFORMATION& mem_info) {\n+    _ap_buffer.reset();\n+    _state_buffer.reset();\n+    _protect_buffer.reset();\n+    _type_buffer.reset();\n+    get_protect_string(_ap_buffer, mem_info.AllocationProtect);\n+    get_state_string(_state_buffer, mem_info);\n+    get_protect_string(_protect_buffer,  mem_info.Protect);\n+    get_type_string(_type_buffer, mem_info);\n+    _file_name[0] = 0;\n+    if (mem_info.Type == MEM_IMAGE) {\n+      HMODULE hModule = 0;\n+      if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, static_cast<LPCSTR>(mem_info.AllocationBase), &hModule)) {\n+        GetModuleFileName(hModule, _file_name, sizeof(_file_name));\n+      }\n@@ -62,0 +65,1 @@\n+  }\n@@ -63,50 +67,13 @@\n-    const char* getProtectString(char* buffer, size_t bufsiz, DWORD prot) {\n-        const int IR = 0;\n-        const int IW = 1;\n-        const int IX = 2;\n-        const int IP = 3;\n-        int idx = 4;\n-        strncpy_s(buffer, bufsiz, \"----  \", 7);\n-        if (prot & PAGE_EXECUTE) {\n-            buffer[IX] = 'x';\n-        } else if (prot & PAGE_EXECUTE_READ) {\n-            buffer[IR] = 'r';\n-            buffer[IX] = 'x';\n-        } else if (prot & PAGE_EXECUTE_READWRITE) {\n-            buffer[IR] = 'r';\n-            buffer[IW] = 'w';\n-            buffer[IX] = 'x';\n-        } else if (prot & PAGE_EXECUTE_WRITECOPY) {\n-            buffer[IW] = 'w';\n-            buffer[IX] = 'x';\n-            buffer[idx++] = 'c';\n-        } else if (prot & PAGE_NOACCESS) {\n-            strncpy_s(buffer, bufsiz, \"(NA)\", 5);\n-        } else if (prot & PAGE_READONLY) {\n-            buffer[IR] = 'r';\n-        } else if (prot & PAGE_READWRITE) {\n-            buffer[IR] = 'r';\n-            buffer[IW] = 'w';\n-        } else if (prot & PAGE_WRITECOPY) {\n-            buffer[IW] = 'w';\n-            buffer[idx++] = 'c';\n-        } else if (prot & PAGE_TARGETS_INVALID) {\n-            buffer[idx++] = 'i';\n-        } else if (prot & PAGE_TARGETS_NO_UPDATE) {\n-            buffer[idx++] = 'n';\n-        } else if (prot != 0) {\n-            snprintf(buffer, bufsiz, \"(0x%x)\", prot);\n-            idx = static_cast<int>(strlen(buffer));\n-        }\n-\n-        if (prot & PAGE_GUARD) {\n-            buffer[idx++] = 'G';\n-        }\n-        if (prot & PAGE_NOCACHE) {\n-            buffer[idx++] = 'C';\n-        }\n-        if (prot & PAGE_WRITECOMBINE) {\n-            buffer[idx++] = 'W';\n-        }\n-        buffer[idx] = 0;\n-        return buffer;\n+  void get_protect_string(outputStream& out, DWORD prot) {\n+    const char read_c = prot & (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY) ? 'r' : '-';\n+    const char write_c = prot & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY) ? 'w' : '-';\n+    const char execute_c = prot & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY) ? 'x' : '-';\n+    out.print(\"%c%c%c\", read_c, write_c, execute_c);\n+    if (prot & (PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY)) {\n+      out.put('c');\n+    }\n+    if (prot & PAGE_GUARD) {\n+      out.put('g');\n+    }\n+    if (prot & PAGE_NOCACHE) {\n+      out.put('n');\n@@ -114,11 +81,2 @@\n-    const char* getStateString(char* buffer, size_t bufsiz, MEMORY_BASIC_INFORMATION& mInfo) {\n-        if (mInfo.State == MEM_COMMIT) {\n-            buffer[0] = 'c'; buffer[1] = 0;\n-        } else if (mInfo.State == MEM_FREE) {\n-            buffer[0] = 'f'; buffer[1] = 0;\n-        } else if (mInfo.State == MEM_RESERVE) {\n-            buffer[0] = 'r'; buffer[1] = 0;\n-        } else {\n-            snprintf(buffer, bufsiz, \"0x%x\", mInfo.State);\n-        }\n-        return buffer;\n+    if (prot & PAGE_WRITECOMBINE) {\n+      out.put('W');\n@@ -126,0 +84,6 @@\n+    const DWORD bits = PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE \n+                        | PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY | PAGE_EXECUTE \n+                        | PAGE_GUARD | PAGE_NOCACHE | PAGE_WRITECOMBINE;\n+    \n+    assert((proc & bits) == proc, \"Unknown Windows memory protection value\");\n+  }\n@@ -127,11 +91,9 @@\n-    const char* getTypeString(char* buffer, size_t bufsiz, MEMORY_BASIC_INFORMATION& mInfo) {\n-        if (mInfo.Type == MEM_IMAGE) {\n-            strncpy_s(buffer, bufsiz, \"img\", 4);\n-        } else if (mInfo.Type == MEM_MAPPED) {\n-            strncpy_s(buffer, bufsiz, \"map\", 4);\n-        } else if (mInfo.Type == MEM_PRIVATE) {\n-            strncpy_s(buffer, bufsiz, \"pvt\", 4);\n-        } else {\n-            snprintf(buffer, bufsiz, \"0x%x\", mInfo.Type);\n-        }\n-        return buffer;\n+  void get_state_string(outputStream& out, MEMORY_BASIC_INFORMATION& mem_info) {\n+    if (mem_info.State == MEM_COMMIT) {\n+      out.put('c');\n+    } else if (mem_info.State == MEM_FREE) {\n+      out.put('f');\n+    } else if (mem_info.State == MEM_RESERVE) {\n+      out.put('r');\n+    } else {\n+      out.print(\"0x%x\", mem_info.State);\n@@ -139,0 +101,13 @@\n+  }\n+\n+  void get_type_string(outputStream& out, MEMORY_BASIC_INFORMATION& mem_info) {\n+    if (mem_info.Type == MEM_IMAGE) {\n+      out.print(\"img\");\n+    } else if (mem_info.Type == MEM_MAPPED) {\n+      out.print(\"map\");\n+    } else if (mem_info.Type == MEM_PRIVATE) {\n+      out.print(\"pvt\");\n+    } else {\n+      out.print(\"0x%x\", mem_info.Type);\n+    }\n+  }\n@@ -145,1 +120,9 @@\n-  size_t _total_reserved;     \/\/ combined shared size\n+  class WinOsInfo : public os::win32 {\n+    public:\n+      static void printOsInfo(outputStream* st) {\n+        st->print(\"OS:\");\n+        os::win32::print_windows_version(st);\n+        os::win32::print_uptime_info(st);\n+        VM_Version::print_platform_virtualization_info(st);\n+      }\n+  };\n@@ -148,1 +131,1 @@\n-                      _total_committed(0), _total_reserved(0) {}\n+                      _total_committed(0) {}\n@@ -150,2 +133,2 @@\n-  void add_mapping(const MEMORY_BASIC_INFORMATION& mInfo, const MappingInfo& info) {\n-    if (mInfo.State != MEM_FREE) {\n+  void add_mapping(const MEMORY_BASIC_INFORMATION& mem_info, const MappingInfo& mapping_info) {\n+    if (mem_info.State != MEM_FREE) {\n@@ -153,3 +136,2 @@\n-      _total_region_size += mInfo.RegionSize;\n-      _total_committed += mInfo.State == MEM_COMMIT ? mInfo.RegionSize : 0;\n-      _total_reserved += mInfo.State == MEM_RESERVE ? mInfo.RegionSize : 0;\n+      _total_region_size += mem_info.RegionSize;\n+      _total_committed += mem_info.State == MEM_COMMIT ? mem_info.RegionSize : 0;\n@@ -161,1 +143,1 @@\n-    os::print_os_info(st);\n+    WinOsInfo::printOsInfo(st);\n@@ -163,1 +145,2 @@\n-    st->print_cr(\"current process reserved memory: \" PROPERFMT, PROPERFMTARGS(_total_reserved));\n+    st->print_cr(\"current process reserved memory: \" PROPERFMT, PROPERFMTARGS(_total_region_size));\n+    st->print_cr(\"current process committed memory: \" PROPERFMT, PROPERFMTARGS(_total_committed));\n@@ -174,1 +157,1 @@\n-  void print_single_mapping(const MEMORY_BASIC_INFORMATION& mInfo, const MappingInfo& info) const {\n+  void print_single_mapping(const MEMORY_BASIC_INFORMATION& mem_info, const MappingInfo& mapping_info) const {\n@@ -180,1 +163,1 @@\n-    st->print(PTR_FORMAT \"-\" PTR_FORMAT, mInfo.BaseAddress, static_cast<const char*>(mInfo.BaseAddress) + mInfo.RegionSize);\n+    st->print(PTR_FORMAT \"-\" PTR_FORMAT, mem_info.BaseAddress, static_cast<const char*>(mem_info.BaseAddress) + mem_info.RegionSize);\n@@ -182,1 +165,1 @@\n-    st->print(\"%12zu\", mInfo.RegionSize);\n+    st->print(\"%12zu\", mem_info.RegionSize);\n@@ -184,1 +167,1 @@\n-    st->print(\"%s\", info.protectBuffer);\n+    st->print(\"%s\", mapping_info._protect_buffer.base());\n@@ -186,1 +169,1 @@\n-    st->print(\"%s-%s\", info.stateBuffer, info.typeBuffer);\n+    st->print(\"%s-%s\", mapping_info._state_buffer.base(), mapping_info._type_buffer.base());\n@@ -188,1 +171,1 @@\n-    st->print(\"%#9llx\", reinterpret_cast<const unsigned long long>(mInfo.BaseAddress) - reinterpret_cast<const unsigned long long>(mInfo.AllocationBase));\n+    st->print(\"%#9llx\", reinterpret_cast<const unsigned long long>(mem_info.BaseAddress) - reinterpret_cast<const unsigned long long>(mem_info.AllocationBase));\n@@ -190,1 +173,1 @@\n-    if (_session.print_nmt_info_for_region(mInfo.BaseAddress, static_cast<const char*>(mInfo.BaseAddress) + mInfo.RegionSize)) {\n+    if (_session.print_nmt_info_for_region(mem_info.BaseAddress, static_cast<const char*>(mem_info.BaseAddress) + mem_info.RegionSize)) {\n@@ -193,1 +176,1 @@\n-    st->print_raw(info.fileName);\n+    st->print_raw(mapping_info._file_name);\n@@ -204,2 +187,2 @@\n-    st->print_cr(\"             G: guard\");\n-    st->print_cr(\"             C: no cache\");\n+    st->print_cr(\"             g: guard\");\n+    st->print_cr(\"             n: no cache\");\n@@ -207,2 +190,0 @@\n-    st->print_cr(\"             i: targets invalid\");\n-    st->print_cr(\"             n: targets noupdate\");\n@@ -232,1 +213,1 @@\n-    HANDLE hProcess = GetCurrentProcess();\n+  HANDLE hProcess = GetCurrentProcess();\n@@ -234,2 +215,2 @@\n-    MappingInfoPrinter printer(session);\n-    MappingInfoSummary summary;\n+  MappingInfoPrinter printer(session);\n+  MappingInfoSummary summary;\n@@ -237,1 +218,1 @@\n-    outputStream* const st = session.out();\n+  outputStream* const st = session.out();\n@@ -239,3 +220,3 @@\n-    printer.print_legend();\n-    st->cr();\n-    printer.print_header();\n+  printer.print_legend();\n+  st->cr();\n+  printer.print_header();\n@@ -243,2 +224,2 @@\n-    MEMORY_BASIC_INFORMATION mInfo;\n-    MappingInfo info;\n+  MEMORY_BASIC_INFORMATION mem_info;\n+  MappingInfo mapping_info;\n@@ -246,6 +227,7 @@\n-    for (char* ptr = 0; VirtualQueryEx(hProcess, ptr, &mInfo, sizeof(mInfo)) == sizeof(mInfo); ptr += mInfo.RegionSize) {\n-      info.process(mInfo);\n-      if (mInfo.State != MEM_FREE) {\n-        printer.print_single_mapping(mInfo, info);\n-        summary.add_mapping(mInfo, info);\n-      }\n+  int region_count = 0;\n+  ::memset(&mem_info, 0, sizeof(mem_info));\n+  for (char* ptr = 0; VirtualQueryEx(hProcess, ptr, &mem_info, sizeof(mem_info)) == sizeof(mem_info); ) {\n+    assert(mem_info.RegionSize > 0);\n+    if (++region_count > MAX_REGIONS_RETURNED) {\n+      st->print_cr(\"limit of %d regions reached (results inaccurate)\", region_count);\n+      break;\n@@ -253,3 +235,11 @@\n-    st->cr();\n-    summary.print_on(session);\n-    st->cr();\n+    mapping_info.process(mem_info);\n+    if (mem_info.State != MEM_FREE) {\n+      printer.print_single_mapping(mem_info, mapping_info);\n+      summary.add_mapping(mem_info, mapping_info);\n+    }\n+    ptr += mem_info.RegionSize;\n+    ::memset(&mem_info, 0, sizeof(mem_info));\n+  }\n+  st->cr();\n+  summary.print_on(session);\n+  st->cr();\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":127,"deletions":137,"binary":false,"changes":264,"status":"modified"}]}