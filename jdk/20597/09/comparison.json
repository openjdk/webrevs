{"files":[{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+#include <limits.h>\n+#include <winnt.h>\n+#include <memoryapi.h>\n+#include <psapi.h>\n+\n+\/* maximum number of mapping records returned *\/\n+static const int MAX_REGIONS_RETURNED = 1000000;\n+\n+class MappingInfo {\n+public:\n+  stringStream _ap_buffer;\n+  stringStream _state_buffer;\n+  stringStream _protect_buffer;\n+  stringStream _type_buffer;\n+  char _file_name[MAX_PATH];\n+\n+  MappingInfo() {}\n+\n+  void process(MEMORY_BASIC_INFORMATION& mem_info) {\n+    _ap_buffer.reset();\n+    _state_buffer.reset();\n+    _protect_buffer.reset();\n+    _type_buffer.reset();\n+    get_protect_string(_ap_buffer, mem_info.AllocationProtect);\n+    get_state_string(_state_buffer, mem_info);\n+    get_protect_string(_protect_buffer,  mem_info.Protect);\n+    get_type_string(_type_buffer, mem_info);\n+    _file_name[0] = 0;\n+    if (mem_info.Type == MEM_IMAGE) {\n+      HMODULE hModule = 0;\n+      if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, static_cast<LPCSTR>(mem_info.AllocationBase), &hModule)) {\n+        GetModuleFileName(hModule, _file_name, sizeof(_file_name));\n+      }\n+    }\n+  }\n+\n+  void get_protect_string(outputStream& out, DWORD prot) {\n+    const char read_c = prot & (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY) ? 'r' : '-';\n+    const char write_c = prot & (PAGE_READWRITE | PAGE_WRITECOPY | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY) ? 'w' : '-';\n+    const char execute_c = prot & (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY) ? 'x' : '-';\n+    out.print(\"%c%c%c\", read_c, write_c, execute_c);\n+    if (prot & (PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY)) {\n+      out.put('c');\n+    }\n+    if (prot & PAGE_GUARD) {\n+      out.put('g');\n+    }\n+    if (prot & PAGE_NOCACHE) {\n+      out.put('n');\n+    }\n+    if (prot & PAGE_WRITECOMBINE) {\n+      out.put('W');\n+    }\n+    const DWORD bits = PAGE_NOACCESS | PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE\n+                        | PAGE_WRITECOPY | PAGE_EXECUTE_WRITECOPY | PAGE_EXECUTE\n+                        | PAGE_GUARD | PAGE_NOCACHE | PAGE_WRITECOMBINE;\n+    assert((prot & bits) == prot, \"Unknown Windows memory protection value: 0x%x unknown bits: 0x%x\", prot, prot & ~bits);\n+  }\n+\n+  void get_state_string(outputStream& out, MEMORY_BASIC_INFORMATION& mem_info) {\n+    if (mem_info.State == MEM_COMMIT) {\n+      out.put('c');\n+    } else if (mem_info.State == MEM_FREE) {\n+      out.put('f');\n+    } else if (mem_info.State == MEM_RESERVE) {\n+      out.put('r');\n+    } else {\n+      fatal(\"Unknown Windows memory state value: 0x%x\", mem_info.State);\n+    }\n+  }\n+\n+  void get_type_string(outputStream& out, MEMORY_BASIC_INFORMATION& mem_info) {\n+    if (mem_info.Type == MEM_IMAGE) {\n+      out.print(\"img\");\n+    } else if (mem_info.Type == MEM_MAPPED) {\n+      out.print(\"map\");\n+    } else if (mem_info.Type == MEM_PRIVATE) {\n+      out.print(\"pvt\");\n+    } else if (mem_info.Type == 0 && mem_info.State == MEM_FREE) {\n+      out.print(\"---\");\n+    } else {\n+      fatal(\"Unknown Windows memory type 0x%x\", mem_info.Type);\n+    }\n+  }\n+};\n+\n+class MappingInfoSummary {\n+  unsigned _num_mappings;\n+  size_t _total_region_size;  \/\/ combined resident set size\n+  size_t _total_committed;    \/\/ combined committed size\n+  class WinOsInfo : public os::win32 {\n+    public:\n+      static void printOsInfo(outputStream* st) {\n+        st->print(\"OS:\");\n+        os::win32::print_windows_version(st);\n+        os::win32::print_uptime_info(st);\n+        VM_Version::print_platform_virtualization_info(st);\n+        os::print_memory_info(st);\n+      }\n+  };\n+public:\n+  MappingInfoSummary() : _num_mappings(0),  _total_region_size(0),\n+                      _total_committed(0) {}\n+\n+  void add_mapping(const MEMORY_BASIC_INFORMATION& mem_info, const MappingInfo& mapping_info) {\n+    if (mem_info.State != MEM_FREE) {\n+      _num_mappings++;\n+      _total_region_size += mem_info.RegionSize;\n+      _total_committed += mem_info.State == MEM_COMMIT ? mem_info.RegionSize : 0;\n+    }\n+  }\n+\n+  void print_on(const MappingPrintSession& session) const {\n+    outputStream* st = session.out();\n+    WinOsInfo::printOsInfo(st);\n+    st->print_cr(\"current process reserved memory: \" PROPERFMT, PROPERFMTARGS(_total_region_size));\n+    st->print_cr(\"current process committed memory: \" PROPERFMT, PROPERFMTARGS(_total_committed));\n+    st->print_cr(\"current process region count: \" PROPERFMT, PROPERFMTARGS(_num_mappings));\n+  }\n+};\n+\n+class MappingInfoPrinter {\n+  const MappingPrintSession& _session;\n+public:\n+  MappingInfoPrinter(const MappingPrintSession& session) :\n+    _session(session)\n+  {}\n+\n+  void print_single_mapping(const MEMORY_BASIC_INFORMATION& mem_info, const MappingInfo& mapping_info) const {\n+    outputStream* st = _session.out();\n+#define INDENT_BY(n)          \\\n+  if (st->fill_to(n) == 0) {  \\\n+    st->print(\" \");           \\\n+  }\n+    st->print(PTR_FORMAT \"-\" PTR_FORMAT, mem_info.BaseAddress, static_cast<const char*>(mem_info.BaseAddress) + mem_info.RegionSize);\n+    INDENT_BY(38);\n+    st->print(\"%12zu\", mem_info.RegionSize);\n+    INDENT_BY(51);\n+    st->print(\"%s\", mapping_info._protect_buffer.base());\n+    INDENT_BY(57);\n+    st->print(\"%s-%s\", mapping_info._state_buffer.base(), mapping_info._type_buffer.base());\n+    INDENT_BY(60);\n+    st->print(\"%#9llx\", reinterpret_cast<const unsigned long long>(mem_info.BaseAddress) - reinterpret_cast<const unsigned long long>(mem_info.AllocationBase));\n+    INDENT_BY(72);\n+    if (_session.print_nmt_info_for_region(mem_info.BaseAddress, static_cast<const char*>(mem_info.BaseAddress) + mem_info.RegionSize)) {\n+      st->print(\" \");\n+    }\n+    st->print_raw(mapping_info._file_name);\n+  #undef INDENT_BY\n+    st->cr();\n+  }\n+\n+  void print_legend() const {\n+    outputStream* st = _session.out();\n+    st->print_cr(\"from, to, vsize: address range and size\");\n+    st->print_cr(\"prot:    protection:\");\n+    st->print_cr(\"             rwx: read \/ write \/ execute\");\n+    st->print_cr(\"             c: copy on write\");\n+    st->print_cr(\"             g: guard\");\n+    st->print_cr(\"             n: no cache\");\n+    st->print_cr(\"             W: write combine\");\n+    st->print_cr(\"state:   region state and type:\");\n+    st->print_cr(\"             state: committed \/ reserved\");\n+    st->print_cr(\"             type: image \/ mapped \/ private\");\n+    st->print_cr(\"file:    file mapped, if mapping is not anonymous\");\n+    st->print_cr(\"vm info: VM information (requires NMT)\");\n+    {\n+      streamIndentor si(st, 16);\n+      _session.print_nmt_flag_legend();\n+    }\n+  }\n+\n+  void print_header() const {\n+    outputStream* st = _session.out();\n+    \/\/            0         1         2         3         4         5         6         7         8         9         0         1         2         3         4         5         6         7\n+    \/\/            012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789\n+    \/\/            0x00007ffd5bd64000-0x00007ffd5c250000      5160960 r---  c-img 0x10d4000 C:\\work\\jdk\\build\\work-fastdebug\\jdk\\bin\\server\\jvm.dll\n+    st->print_cr(\"from               to                        vsize prot  state    offset vm info\/file\");\n+    st->print_cr(\"=============================================================================================================================\");\n+  }\n+};\n+\n+void MemMapPrinter::pd_print_all_mappings(const MappingPrintSession& session) {\n+\n+  HANDLE hProcess = GetCurrentProcess();\n+\n+  MappingInfoPrinter printer(session);\n+  MappingInfoSummary summary;\n+\n+  outputStream* const st = session.out();\n+\n+  printer.print_legend();\n+  st->cr();\n+  printer.print_header();\n+\n+  MEMORY_BASIC_INFORMATION mem_info;\n+  MappingInfo mapping_info;\n+\n+  int region_count = 0;\n+  ::memset(&mem_info, 0, sizeof(mem_info));\n+  for (char* ptr = 0; VirtualQueryEx(hProcess, ptr, &mem_info, sizeof(mem_info)) == sizeof(mem_info); ) {\n+    assert(mem_info.RegionSize > 0, \"RegionSize is not greater than zero\");\n+    if (++region_count > MAX_REGIONS_RETURNED) {\n+      st->print_cr(\"limit of %d regions reached (results inaccurate)\", region_count);\n+      break;\n+    }\n+    mapping_info.process(mem_info);\n+    if (mem_info.State != MEM_FREE) {\n+      printer.print_single_mapping(mem_info, mapping_info);\n+      summary.add_mapping(mem_info, mapping_info);\n+    }\n+    ptr += mem_info.RegionSize;\n+    ::memset(&mem_info, 0, sizeof(mem_info));\n+  }\n+  st->cr();\n+  summary.print_on(session);\n+  st->cr();\n+}\n","filename":"src\/hotspot\/os\/windows\/memMapPrinter_windows.cpp","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-#ifdef LINUX\n+#if defined(LINUX) || defined(_WIN64)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#ifdef LINUX\n+#if defined(LINUX) || defined(_WIN64)\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+#endif \/\/ LINUX\n+#if defined(LINUX) || defined(_WIN64)\n@@ -143,1 +145,1 @@\n-#endif \/\/ LINUX\n+#endif \/\/ LINUX or WINDOWS\n@@ -1176,1 +1178,1 @@\n-#ifdef LINUX\n+#if defined(LINUX) || defined(_WIN64)\n@@ -1194,0 +1196,4 @@\n+  if (name == NULL || name[0] == 0) {\n+    output()->print_cr(\"filename is empty or not specified.  No file written\");\n+    return;\n+  }\n@@ -1200,0 +1206,1 @@\n+#ifndef _WIN64\n@@ -1204,0 +1211,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -984,1 +984,1 @@\n-#ifdef LINUX\n+#if defined(LINUX) || defined(_WIN64)\n@@ -991,1 +991,1 @@\n-    return \"Prints an annotated process memory map of the VM process (linux only).\";\n+    return \"Prints an annotated process memory map of the VM process (linux and Windows only).\";\n@@ -1009,1 +1009,1 @@\n-    return \"Dumps an annotated process memory map to an output file (linux only).\";\n+    return \"Dumps an annotated process memory map to an output file (linux and Windows only).\";\n@@ -1020,1 +1020,1 @@\n-#endif \/\/ LINUX\n+#endif \/\/ LINUX or WINDOWS\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * @requires (os.family==\"linux\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\")\n@@ -66,1 +66,1 @@\n-            for (String s: shouldMatchUnconditionally) {\n+            for (String s: shouldMatchUnconditionally()) {\n@@ -70,1 +70,1 @@\n-                for (String s: shouldMatchIfNMTIsEnabled) {\n+                for (String s: shouldMatchIfNMTIsEnabled()) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires (os.family==\"linux\")\n+ * @requires (os.family == \"linux\" | os.family == \"windows\")\n@@ -45,1 +45,1 @@\n-        for (String s: shouldMatchUnconditionally) {\n+        for (String s: shouldMatchUnconditionally()) {\n@@ -49,1 +49,1 @@\n-            for (String s: shouldMatchIfNMTIsEnabled) {\n+            for (String s: shouldMatchIfNMTIsEnabled()) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -32,0 +34,1 @@\n+    private static final String someNumber = \"(0x\\\\p{XDigit}+|\\\\d+)\";\n@@ -47,1 +50,2 @@\n-    protected static final String shouldMatchUnconditionally[] = {\n+\n+    private static final String shouldMatchUnconditionally_linux[] = {\n@@ -58,1 +62,1 @@\n-    protected static final String shouldMatchIfNMTIsEnabled[] = {\n+    private static final String shouldMatchIfNMTIsEnabled_linux[] = {\n@@ -69,0 +73,39 @@\n+\n+    \/\/ windows:\n+    private static final String winprot = \"[\\\\-rwxcin]*\";\n+    private static final String wintype = \"[rc]-(img|map|pvt)\";\n+\n+    private static final String winbase = range + space + someSize + space + winprot + space;\n+\n+    private static final String winimage     = winbase + \"c-img\" + space + someNumber + space;\n+    private static final String wincommitted = winbase + \"c-pvt\" + space + someNumber + space;\n+    private static final String winreserved  = winbase + \"r-pvt\" + space + someNumber + space;\n+\n+    private static final String shouldMatchUnconditionally_windows[] = {\n+        \/\/ java launcher\n+        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\]java[.]exe\",\n+        \/\/ libjvm\n+        winimage + \".*[\\\\\/\\\\\\\\]bin[\\\\\/\\\\\\\\].*[\\\\\/\\\\\\\\]jvm.dll\"\n+    };\n+\n+    private static final String shouldMatchIfNMTIsEnabled_windows[] = {\n+        wincommitted + \"JAVAHEAP.*\",\n+        \/\/ metaspace\n+        wincommitted + \"META.*\",\n+        \/\/ parts of metaspace should be uncommitted\n+        winreserved + \"META.*\",\n+        \/\/ code cache\n+        wincommitted + \"CODE.*\",\n+        \/\/ Main thread stack\n+        wincommitted + \"STACK-\\\\d+-main.*\"\n+    };\n+\n+    private static final boolean isWindows = Platform.isWindows();\n+\n+    protected static String[] shouldMatchUnconditionally() {\n+        return isWindows ? shouldMatchUnconditionally_windows : shouldMatchUnconditionally_linux;\n+    }\n+    protected static String[] shouldMatchIfNMTIsEnabled() {\n+        return isWindows ? shouldMatchIfNMTIsEnabled_windows : shouldMatchIfNMTIsEnabled_linux;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTestBase.java","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+        }\n+        if (Platform.isLinux() || Platform.isWindows()) {\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdPIDSubstitution.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}