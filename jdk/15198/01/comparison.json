{"files":[{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -588,0 +589,12 @@\n+#ifdef ASSERT\n+  const char* val = Arguments::PropertyList_get_value(Arguments::system_properties(), \"test.jvmci.lookupTypeException\");\n+  if (val != nullptr) {\n+    if (strstr(val, \"<trace>\") != nullptr) {\n+      tty->print_cr(\"CompilerToVM.lookupType: %s\", str);\n+    } else if (strstr(val, str) != nullptr) {\n+      THROW_MSG_0(vmSymbols::java_lang_Exception(),\n+                  err_msg(\"lookupTypeException: %s\", str));\n+    }\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -436,2 +436,1 @@\n-  int encode(JavaThread* THREAD, jlong buffer, int buffer_size) {\n-    Klass* vmSupport = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_vm_VMSupport(), true, THREAD);\n+  bool handle_pending_exception(JavaThread* THREAD, jlong buffer, int buffer_size) {\n@@ -454,0 +453,8 @@\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  int encode(JavaThread* THREAD, jlong buffer, int buffer_size) {\n+    Klass* vmSupport = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_vm_VMSupport(), true, THREAD);\n+    if (handle_pending_exception(THREAD, buffer, buffer_size)) {\n@@ -465,0 +472,3 @@\n+    if (handle_pending_exception(THREAD, buffer, buffer_size)) {\n+      return 0;\n+    }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1249,0 +1249,1 @@\n+#ifdef ASSERT\n@@ -1254,0 +1255,1 @@\n+#endif\n@@ -2064,0 +2066,1 @@\n+#ifdef ASSERT\n@@ -2070,0 +2073,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.internal.misc.VM;\n+\n@@ -59,0 +61,1 @@\n+        maybeFailClinit();\n@@ -70,0 +73,16 @@\n+    \/**\n+     * Helper to test exception translation.\n+     *\/\n+    private static void maybeFailClinit() {\n+        String className = VM.getSavedProperty(\"test.jvmci.TranslatedException.clinit.throw\");\n+        if (className != null) {\n+            try {\n+                throw (Throwable) Class.forName(className).getDeclaredConstructor().newInstance();\n+            } catch (RuntimeException | Error e) {\n+                throw e;\n+            } catch (Throwable e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/TranslatedException.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+ *          Requires a debug VM as it uses test.jvmci.compileMethodExceptionIsFatal\n+ *          which is only read in a debug VM.\n@@ -28,0 +30,1 @@\n+ * @requires vm.debug\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestUncaughtErrorInCompileMethod.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @library \/test\/lib\n@@ -56,0 +57,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -160,0 +163,5 @@\n+        if (!Platform.isDebugBuild()) {\n+            \/\/ The test.jvmci.forceEnomemOnLibjvmciInit property is only\n+            \/\/ read in a debug VM.\n+            return;\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotJVMCIRuntime.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}