{"files":[{"patch":"@@ -2470,0 +2470,17 @@\n+        if (val.mag.length < BURNIKEL_ZIEGLER_THRESHOLD ||\n+                mag.length - val.mag.length < BURNIKEL_ZIEGLER_OFFSET) {\n+            return divideKnuth(val);\n+        } else {\n+            return divideBurnikelZiegler(val);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a BigInteger whose value is {@code (this \/ val)} using an O(n^2) algorithm from Knuth.\n+     *\n+     * @param  val value by which this BigInteger is to be divided.\n+     * @return {@code this \/ val}\n+     * @throws ArithmeticException if {@code val} is zero.\n+     * @see MutableBigInteger#divideKnuth(MutableBigInteger, MutableBigInteger, boolean)\n+     *\/\n+    private BigInteger divideKnuth(BigInteger val) {\n@@ -2474,1 +2491,1 @@\n-        a.divide(b, q, false);\n+        a.divideKnuth(b, q, false);\n@@ -2490,0 +2507,10 @@\n+        if (val.mag.length < BURNIKEL_ZIEGLER_THRESHOLD ||\n+                mag.length - val.mag.length < BURNIKEL_ZIEGLER_OFFSET) {\n+            return divideAndRemainderKnuth(val);\n+        } else {\n+            return divideAndRemainderBurnikelZiegler(val);\n+        }\n+    }\n+\n+    \/** Long division *\/\n+    private BigInteger[] divideAndRemainderKnuth(BigInteger val) {\n@@ -2494,1 +2521,1 @@\n-        MutableBigInteger r = a.divide(b, q);\n+        MutableBigInteger r = a.divideKnuth(b, q);\n@@ -2509,0 +2536,10 @@\n+        if (val.mag.length < BURNIKEL_ZIEGLER_THRESHOLD ||\n+                mag.length - val.mag.length < BURNIKEL_ZIEGLER_OFFSET) {\n+            return remainderKnuth(val);\n+        } else {\n+            return remainderBurnikelZiegler(val);\n+        }\n+    }\n+\n+    \/** Long division *\/\n+    private BigInteger remainderKnuth(BigInteger val) {\n@@ -2513,1 +2550,33 @@\n-        return a.divide(b, q).toBigInteger(this.signum);\n+        return a.divideKnuth(b, q).toBigInteger(this.signum);\n+    }\n+\n+    \/**\n+     * Calculates {@code this \/ val} using the Burnikel-Ziegler algorithm.\n+     * @param  val the divisor\n+     * @return {@code this \/ val}\n+     *\/\n+    private BigInteger divideBurnikelZiegler(BigInteger val) {\n+        return divideAndRemainderBurnikelZiegler(val)[0];\n+    }\n+\n+    \/**\n+     * Calculates {@code this % val} using the Burnikel-Ziegler algorithm.\n+     * @param val the divisor\n+     * @return {@code this % val}\n+     *\/\n+    private BigInteger remainderBurnikelZiegler(BigInteger val) {\n+        return divideAndRemainderBurnikelZiegler(val)[1];\n+    }\n+\n+    \/**\n+     * Computes {@code this \/ val} and {@code this % val} using the\n+     * Burnikel-Ziegler algorithm.\n+     * @param val the divisor\n+     * @return an array containing the quotient and remainder\n+     *\/\n+    private BigInteger[] divideAndRemainderBurnikelZiegler(BigInteger val) {\n+        MutableBigInteger q = new MutableBigInteger();\n+        MutableBigInteger r = new MutableBigInteger(this).divideAndRemainderBurnikelZiegler(new MutableBigInteger(val), q);\n+        BigInteger qBigInt = q.isZero() ? ZERO : q.toBigInteger(signum*val.signum);\n+        BigInteger rBigInt = r.isZero() ? ZERO : r.toBigInteger(signum);\n+        return new BigInteger[] {qBigInt, rBigInt};\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":72,"deletions":3,"binary":false,"changes":75,"status":"modified"}]}