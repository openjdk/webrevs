{"files":[{"patch":"@@ -226,3 +226,1 @@\n-     * <p>Note: never used for a BigInteger with a magnitude of zero.\n-     *\n-     * @see #firstNonzeroIntNum()\n+     * @see #numberOfTrailingZeroInts()\n@@ -230,1 +228,1 @@\n-    private int firstNonzeroIntNumPlusTwo;\n+    private int numberOfTrailingZeroIntsPlusTwo;\n@@ -1772,1 +1770,1 @@\n-        if (Integer.bitCount(y) == 1) {\n+        if (Integer.lowestOneBit(y) == y) {\n@@ -2643,2 +2641,2 @@\n-\n-        if ((bitLength() - 1L) * exponent >= Integer.MAX_VALUE) {\n+        \/\/ (bitLength(mag, mag.length) - 1L) * exponent + 1L > Integer.MAX_VALUE\n+        if (scaleFactor + bitsToShift - exponent >= Integer.MAX_VALUE) {\n@@ -2831,3 +2829,1 @@\n-        if (len == 0)\n-            return 0;\n-        return ((len - 1) << 5) + bitLengthForInt(val[0]);\n+        return len == 0 ? 0 : len * Integer.SIZE - Integer.numberOfLeadingZeros(val[0]);\n@@ -3616,7 +3612,3 @@\n-            boolean onesLost = false;\n-            for (int i=magLen-1, j=magLen-nInts; i >= j && !onesLost; i--)\n-                onesLost = (mag[i] != 0);\n-            if (!onesLost && nBits != 0)\n-                onesLost = (mag[magLen - nInts - 1] << (32 - nBits) != 0);\n-\n-            if (onesLost)\n+            int nzInts = numberOfTrailingZeroInts();\n+            if (nInts > nzInts || nInts == nzInts\n+                    && nBits > Integer.numberOfTrailingZeros(magLen - 1 - nzInts)) {\n@@ -3624,0 +3616,1 @@\n+            }\n@@ -3838,10 +3831,1 @@\n-            lsb = 0;\n-            if (signum == 0) {\n-                lsb -= 1;\n-            } else {\n-                \/\/ Search for lowest order nonzero int\n-                int i,b;\n-                for (i=0; (b = getInt(i)) == 0; i++)\n-                    ;\n-                lsb += (i << 5) + Integer.numberOfTrailingZeros(b);\n-            }\n+            lsb = signum == 0 ? -1 : numberOfTrailingZeros();\n@@ -3869,17 +3853,7 @@\n-            int[] m = mag;\n-            int len = m.length;\n-            if (len == 0) {\n-                n = 0; \/\/ offset by one to initialize\n-            }  else {\n-                \/\/ Calculate the bit length of the magnitude\n-                int magBitLength = ((len - 1) << 5) + bitLengthForInt(mag[0]);\n-                 if (signum < 0) {\n-                     \/\/ Check if magnitude is a power of two\n-                     boolean pow2 = (Integer.bitCount(mag[0]) == 1);\n-                     for (int i=1; i< len && pow2; i++)\n-                         pow2 = (mag[i] == 0);\n-\n-                     n = (pow2 ? magBitLength - 1 : magBitLength);\n-                 } else {\n-                     n = magBitLength;\n-                 }\n+            \/\/ Calculate the bit length of the magnitude\n+            n = bitLength(mag, mag.length);\n+            if (signum < 0\n+                    \/\/ Check if magnitude is a power of two\n+                    && Integer.lowestOneBit(mag[0]) == mag[0]\n+                    && numberOfTrailingZeroInts() == mag.length - 1) {\n+                n--;\n@@ -3904,0 +3878,2 @@\n+\n+            final int firstZeroInt = mag.length - numberOfTrailingZeroInts();\n@@ -3905,1 +3881,1 @@\n-            for (int i=0; i < mag.length; i++)\n+            for (int i = 0; i < firstZeroInt; i++)\n@@ -3907,8 +3883,4 @@\n-            if (signum < 0) {\n-                \/\/ Count the trailing zeros in the magnitude\n-                int magTrailingZeroCount = 0, j;\n-                for (j=mag.length-1; mag[j] == 0; j--)\n-                    magTrailingZeroCount += 32;\n-                magTrailingZeroCount += Integer.numberOfTrailingZeros(mag[j]);\n-                bc += magTrailingZeroCount - 1;\n-            }\n+\n+            if (signum < 0)\n+                bc += numberOfTrailingZeros() - 1;\n+\n@@ -4419,1 +4391,1 @@\n-        int exponent = ((mag.length - 1) << 5) + bitLengthForInt(mag[0]) - 1;\n+        int exponent = bitLength(mag, mag.length) - 1;\n@@ -4504,1 +4476,1 @@\n-        int exponent = ((mag.length - 1) << 5) + bitLengthForInt(mag[0]) - 1;\n+        int exponent = bitLength(mag, mag.length) - 1;\n@@ -4886,1 +4858,12 @@\n-                (n <= firstNonzeroIntNum() ? -magInt : ~magInt));\n+                (n <= numberOfTrailingZeroInts() ? -magInt : ~magInt));\n+    }\n+\n+    \/**\n+     * Returns the number of zero bits following the lowest-order (\"rightmost\")\n+     * one-bit in the magnitude. Assumes {@code mag.length != 0}.\n+     *\n+     * @see #numberOfTrailingZeroInts\n+     *\/\n+    private int numberOfTrailingZeros() {\n+        int tz = numberOfTrailingZeroInts();\n+        return tz * Integer.SIZE + Integer.numberOfTrailingZeros(mag[mag.length - 1 - tz]);\n@@ -4892,1 +4875,1 @@\n-     * least significant). If the magnitude is zero, return value is undefined.\n+     * least significant). If the magnitude is zero, return value is zero.\n@@ -4894,1 +4877,0 @@\n-     * <p>Note: never used for a BigInteger with a magnitude of zero.\n@@ -4897,2 +4879,2 @@\n-    private int firstNonzeroIntNum() {\n-        int fn = firstNonzeroIntNumPlusTwo - 2;\n+    private int numberOfTrailingZeroInts() {\n+        int fn = numberOfTrailingZeroIntsPlusTwo - 2;\n@@ -4902,2 +4884,2 @@\n-            int mlen = mag.length;\n-            for (i = mlen - 1; i >= 0 && mag[i] == 0; i--)\n+            final int lowest = mag.length - 1;\n+            for (i = lowest; i >= 0 && mag[i] == 0; i--)\n@@ -4905,2 +4887,2 @@\n-            fn = mlen - i - 1;\n-            firstNonzeroIntNumPlusTwo = fn + 2; \/\/ offset by two to initialize\n+            fn = lowest - i;\n+            numberOfTrailingZeroIntsPlusTwo = fn + 2; \/\/ offset by two to initialize\n@@ -5055,5 +5037,1 @@\n-        int len = mag.length;\n-\n-        int bitLen = (len == 0 ? 0 : ((len - 1) << 5) + bitLengthForInt(mag[0]));\n-        int byteLen = (bitLen + 7) >>> 3;\n-        byte[] result = new byte[byteLen];\n+        byte[] result = new byte[(bitLength(mag, mag.length) + 7) >>> 3];\n@@ -5061,1 +5039,1 @@\n-        for (int i = byteLen - 1, bytesCopied = 4, intIndex = len - 1, nextInt = 0;\n+        for (int i = result.length - 1, bytesCopied = 4, intIndex = mag.length - 1, nextInt = 0;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":48,"deletions":70,"binary":false,"changes":118,"status":"modified"}]}