{"files":[{"patch":"@@ -206,1 +206,2 @@\n-     * One plus the bitLength of this BigInteger. This is a stable variable.\n+     * One plus the bitLength of the magnitude of this BigInteger.\n+     * This is a stable variable.\n@@ -209,1 +210,1 @@\n-     * @see #bitLength()\n+     * @see #magBitLength()\n@@ -211,1 +212,1 @@\n-    private int bitLengthPlusOne;\n+    private int magBitLengthPlusOne;\n@@ -226,3 +227,1 @@\n-     * <p>Note: never used for a BigInteger with a magnitude of zero.\n-     *\n-     * @see #firstNonzeroIntNum()\n+     * @see #numberOfTrailingZeroInts()\n@@ -230,1 +229,1 @@\n-    private int firstNonzeroIntNumPlusTwo;\n+    private int numberOfTrailingZeroIntsPlusTwo;\n@@ -1759,3 +1758,2 @@\n-                    if ((long)bitLength(mag, mag.length) +\n-                        (long)bitLength(val.mag, val.mag.length) >\n-                        32L*MAX_MAG_LENGTH) {\n+                    if ((long) this.magBitLength() + val.magBitLength() >\n+                        (long) Integer.SIZE * MAX_MAG_LENGTH) {\n@@ -1772,1 +1770,1 @@\n-        if (Integer.bitCount(y) == 1) {\n+        if (Integer.lowestOneBit(y) == y) {\n@@ -2274,1 +2272,1 @@\n-                    if (bitLength(mag, mag.length) > 16L*MAX_MAG_LENGTH) {\n+                    if (magBitLength() > (Integer.SIZE \/ 2) * MAX_MAG_LENGTH) {\n@@ -2643,2 +2641,2 @@\n-\n-        if ((bitLength() - 1L) * exponent >= Integer.MAX_VALUE) {\n+        \/\/ (magBitLength() - 1L) * exponent + 1L > Integer.MAX_VALUE\n+        if (scaleFactor + bitsToShift - exponent >= Integer.MAX_VALUE) {\n@@ -2827,2 +2825,1 @@\n-     * Calculate bitlength of contents of the first len elements an int array,\n-     * assuming there are no leading zero ints.\n+     * Calculate bitlength of the magnitude of this {@code BigInteger}.\n@@ -2830,4 +2827,8 @@\n-    private static int bitLength(int[] val, int len) {\n-        if (len == 0)\n-            return 0;\n-        return ((len - 1) << 5) + bitLengthForInt(val[0]);\n+    private int magBitLength() {\n+        int n = magBitLengthPlusOne - 1;\n+        if (n == -1) { \/\/ not initialized\n+            n = mag.length == 0 ? 0\n+                    : mag.length * Integer.SIZE - Integer.numberOfLeadingZeros(mag[0]);\n+            magBitLengthPlusOne = n + 1;\n+        }\n+        return n;\n@@ -3130,1 +3131,1 @@\n-        int ebits = bitLength(exp, exp.length);\n+        int ebits = y.magBitLength();\n@@ -3616,7 +3617,3 @@\n-            boolean onesLost = false;\n-            for (int i=magLen-1, j=magLen-nInts; i >= j && !onesLost; i--)\n-                onesLost = (mag[i] != 0);\n-            if (!onesLost && nBits != 0)\n-                onesLost = (mag[magLen - nInts - 1] << (32 - nBits) != 0);\n-\n-            if (onesLost)\n+            int nzInts = numberOfTrailingZeroInts();\n+            if (nInts > nzInts || nInts == nzInts\n+                    && (mag[magLen - nzInts - 1] & ((1 << nBits) - 1)) != 0) {\n@@ -3624,0 +3621,1 @@\n+            }\n@@ -3640,1 +3638,1 @@\n-    int[] javaIncrement(int[] val) {\n+    static int[] javaIncrement(int[] val) {\n@@ -3838,1 +3836,0 @@\n-            lsb = 0;\n@@ -3840,1 +3837,1 @@\n-                lsb -= 1;\n+                lsb = -1;\n@@ -3842,5 +3839,2 @@\n-                \/\/ Search for lowest order nonzero int\n-                int i,b;\n-                for (i=0; (b = getInt(i)) == 0; i++)\n-                    ;\n-                lsb += (i << 5) + Integer.numberOfTrailingZeros(b);\n+                int tz = numberOfTrailingZeroInts();\n+                lsb = tz * Integer.SIZE + Integer.numberOfTrailingZeros(mag[mag.length - 1 - tz]);\n@@ -3867,23 +3861,5 @@\n-        int n = bitLengthPlusOne - 1;\n-        if (n == -1) { \/\/ bitLength not initialized yet\n-            int[] m = mag;\n-            int len = m.length;\n-            if (len == 0) {\n-                n = 0; \/\/ offset by one to initialize\n-            }  else {\n-                \/\/ Calculate the bit length of the magnitude\n-                int magBitLength = ((len - 1) << 5) + bitLengthForInt(mag[0]);\n-                 if (signum < 0) {\n-                     \/\/ Check if magnitude is a power of two\n-                     boolean pow2 = (Integer.bitCount(mag[0]) == 1);\n-                     for (int i=1; i< len && pow2; i++)\n-                         pow2 = (mag[i] == 0);\n-\n-                     n = (pow2 ? magBitLength - 1 : magBitLength);\n-                 } else {\n-                     n = magBitLength;\n-                 }\n-            }\n-            bitLengthPlusOne = n + 1;\n-        }\n-        return n;\n+        return signum < 0\n+                \/\/ Check if magnitude is a power of two\n+                && Integer.lowestOneBit(mag[0]) == mag[0]\n+                && numberOfTrailingZeroInts() == mag.length - 1\n+            ? magBitLength() - 1 : magBitLength();\n@@ -3904,0 +3880,2 @@\n+\n+            final int firstZeroInt = mag.length - numberOfTrailingZeroInts();\n@@ -3905,1 +3883,1 @@\n-            for (int i=0; i < mag.length; i++)\n+            for (int i = 0; i < firstZeroInt; i++)\n@@ -3907,8 +3885,4 @@\n-            if (signum < 0) {\n-                \/\/ Count the trailing zeros in the magnitude\n-                int magTrailingZeroCount = 0, j;\n-                for (j=mag.length-1; mag[j] == 0; j--)\n-                    magTrailingZeroCount += 32;\n-                magTrailingZeroCount += Integer.numberOfTrailingZeros(mag[j]);\n-                bc += magTrailingZeroCount - 1;\n-            }\n+\n+            if (signum < 0)\n+                bc += getLowestSetBit() - 1; \/\/ Count the trailing zeros\n+\n@@ -4419,1 +4393,1 @@\n-        int exponent = ((mag.length - 1) << 5) + bitLengthForInt(mag[0]) - 1;\n+        int exponent = magBitLength() - 1;\n@@ -4504,1 +4478,1 @@\n-        int exponent = ((mag.length - 1) << 5) + bitLengthForInt(mag[0]) - 1;\n+        int exponent = magBitLength() - 1;\n@@ -4886,1 +4860,1 @@\n-                (n <= firstNonzeroIntNum() ? -magInt : ~magInt));\n+                (n <= numberOfTrailingZeroInts() ? -magInt : ~magInt));\n@@ -4892,1 +4866,1 @@\n-     * least significant). If the magnitude is zero, return value is undefined.\n+     * least significant). If the magnitude is zero, return value is zero.\n@@ -4894,1 +4868,0 @@\n-     * <p>Note: never used for a BigInteger with a magnitude of zero.\n@@ -4897,3 +4870,3 @@\n-    private int firstNonzeroIntNum() {\n-        int fn = firstNonzeroIntNumPlusTwo - 2;\n-        if (fn == -2) { \/\/ firstNonzeroIntNum not initialized yet\n+    private int numberOfTrailingZeroInts() {\n+        int nz = numberOfTrailingZeroIntsPlusTwo - 2;\n+        if (nz == -2) { \/\/ numberOfTrailingZeroInts not initialized yet\n@@ -4902,2 +4875,2 @@\n-            int mlen = mag.length;\n-            for (i = mlen - 1; i >= 0 && mag[i] == 0; i--)\n+            final int lowest = mag.length - 1;\n+            for (i = lowest; i >= 0 && mag[i] == 0; i--)\n@@ -4905,2 +4878,2 @@\n-            fn = mlen - i - 1;\n-            firstNonzeroIntNumPlusTwo = fn + 2; \/\/ offset by two to initialize\n+            nz = lowest - i;\n+            numberOfTrailingZeroIntsPlusTwo = nz + 2; \/\/ offset by two to initialize\n@@ -4908,1 +4881,1 @@\n-        return fn;\n+        return nz;\n@@ -5055,5 +5028,1 @@\n-        int len = mag.length;\n-\n-        int bitLen = (len == 0 ? 0 : ((len - 1) << 5) + bitLengthForInt(mag[0]));\n-        int byteLen = (bitLen + 7) >>> 3;\n-        byte[] result = new byte[byteLen];\n+        byte[] result = new byte[(magBitLength() + 7) >>> 3];\n@@ -5061,1 +5030,1 @@\n-        for (int i = byteLen - 1, bytesCopied = 4, intIndex = len - 1, nextInt = 0;\n+        for (int i = result.length - 1, bytesCopied = 4, intIndex = mag.length - 1, nextInt = 0;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":56,"deletions":87,"binary":false,"changes":143,"status":"modified"}]}