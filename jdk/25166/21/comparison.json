{"files":[{"patch":"@@ -206,1 +206,2 @@\n-     * One plus the bitLength of this BigInteger. This is a stable variable.\n+     * One plus the bitLength of the magnitude of this BigInteger.\n+     * This is a stable variable.\n@@ -209,1 +210,1 @@\n-     * @see #bitLength()\n+     * @see #magBitLength()\n@@ -211,1 +212,1 @@\n-    private int bitLengthPlusOne;\n+    private int magBitLengthPlusOne;\n@@ -226,3 +227,1 @@\n-     * <p>Note: never used for a BigInteger with a magnitude of zero.\n-     *\n-     * @see #firstNonzeroIntNum()\n+     * @see #numberOfTrailingZeroInts()\n@@ -230,1 +229,1 @@\n-    private int firstNonzeroIntNumPlusTwo;\n+    private int numberOfTrailingZeroIntsPlusTwo;\n@@ -405,1 +404,1 @@\n-            mag = trustedStripLeadingZeroInts(val);\n+            mag = stripLeadingZeroInts(val, true);\n@@ -493,1 +492,1 @@\n-        this.mag = stripLeadingZeroInts(magnitude);\n+        this.mag = stripLeadingZeroInts(magnitude, false);\n@@ -599,1 +598,1 @@\n-        mag = trustedStripLeadingZeroInts(magnitude);\n+        mag = stripLeadingZeroInts(magnitude, true);\n@@ -650,1 +649,1 @@\n-        mag = trustedStripLeadingZeroInts(magnitude);\n+        mag = stripLeadingZeroInts(magnitude, true);\n@@ -844,1 +843,1 @@\n-        int highBit = 1 << ((bitLength+31) & 0x1f);  \/\/ High bit of high int\n+        int highBit = 1 << (bitLength - 1);  \/\/ High bit of high int\n@@ -888,1 +887,1 @@\n-        p.mag[p.mag.length-1] &= 0xfffffffe;\n+        p.mag[p.mag.length-1] &= ~1;\n@@ -899,1 +898,1 @@\n-            p.mag[p.mag.length-1] &= 0xfffffffe;\n+            p.mag[p.mag.length-1] &= ~1;\n@@ -1397,1 +1396,1 @@\n-        resultMag = trustedStripLeadingZeroInts(resultMag);\n+        resultMag = stripLeadingZeroInts(resultMag, true);\n@@ -1417,1 +1416,1 @@\n-        resultMag = trustedStripLeadingZeroInts(resultMag);\n+        resultMag = stripLeadingZeroInts(resultMag, true);\n@@ -1599,1 +1598,1 @@\n-        resultMag = trustedStripLeadingZeroInts(resultMag);\n+        resultMag = stripLeadingZeroInts(resultMag, true);\n@@ -1703,1 +1702,1 @@\n-            result = trustedStripLeadingZeroInts(result);\n+            result = stripLeadingZeroInts(result, true);\n@@ -1759,3 +1758,2 @@\n-                    if ((long)bitLength(mag, mag.length) +\n-                        (long)bitLength(val.mag, val.mag.length) >\n-                        32L*MAX_MAG_LENGTH) {\n+                    if ((long) this.magBitLength() + val.magBitLength() >\n+                        (long) Integer.SIZE * MAX_MAG_LENGTH) {\n@@ -1772,1 +1770,1 @@\n-        if (Integer.bitCount(y) == 1) {\n+        if (Integer.lowestOneBit(y) == y) {\n@@ -2160,1 +2158,1 @@\n-        return new BigInteger(trustedStripLeadingZeroInts(intSlice), 1);\n+        return new BigInteger(stripLeadingZeroInts(intSlice, true), 1);\n@@ -2199,1 +2197,1 @@\n-        result = trustedStripLeadingZeroInts(result);\n+        result = stripLeadingZeroInts(result, true);\n@@ -2217,1 +2215,1 @@\n-        return new BigInteger(trustedStripLeadingZeroInts(lowerInts), 1);\n+        return new BigInteger(stripLeadingZeroInts(lowerInts, true), 1);\n@@ -2236,1 +2234,1 @@\n-        return new BigInteger(trustedStripLeadingZeroInts(upperInts), 1);\n+        return new BigInteger(stripLeadingZeroInts(upperInts, true), 1);\n@@ -2265,1 +2263,1 @@\n-            return new BigInteger(trustedStripLeadingZeroInts(z), 1);\n+            return new BigInteger(stripLeadingZeroInts(z, true), 1);\n@@ -2274,1 +2272,1 @@\n-                    if (bitLength(mag, mag.length) > 16L*MAX_MAG_LENGTH) {\n+                    if (magBitLength() > (Integer.SIZE \/ 2) * MAX_MAG_LENGTH) {\n@@ -2643,2 +2641,2 @@\n-\n-        if ((bitLength() - 1L) * exponent >= Integer.MAX_VALUE) {\n+        \/\/ (magBitLength() - 1L) * exponent + 1L > Integer.MAX_VALUE\n+        if (scaleFactor + bitsToShift - exponent >= Integer.MAX_VALUE) {\n@@ -2827,2 +2825,1 @@\n-     * Calculate bitlength of contents of the first len elements an int array,\n-     * assuming there are no leading zero ints.\n+     * Calculate bitlength of the magnitude of this {@code BigInteger}.\n@@ -2830,4 +2827,8 @@\n-    private static int bitLength(int[] val, int len) {\n-        if (len == 0)\n-            return 0;\n-        return ((len - 1) << 5) + bitLengthForInt(val[0]);\n+    private int magBitLength() {\n+        int n = magBitLengthPlusOne - 1;\n+        if (n == -1) { \/\/ not initialized\n+            n = mag.length == 0 ? 0\n+                    : mag.length * Integer.SIZE - Integer.numberOfLeadingZeros(mag[0]);\n+            magBitLengthPlusOne = n + 1;\n+        }\n+        return n;\n@@ -3130,1 +3131,1 @@\n-        int ebits = bitLength(exp, exp.length);\n+        int ebits = y.magBitLength();\n@@ -3183,1 +3184,1 @@\n-        int bitpos = 1 << ((ebits-1) & (32-1));\n+        int bitpos = 1 << ((ebits-1) & 0x1f);\n@@ -3193,1 +3194,1 @@\n-                bitpos = 1 << (32-1);\n+                bitpos = 1 << 0x1f;\n@@ -3227,1 +3228,1 @@\n-                    bitpos = 1 << (32-1);\n+                    bitpos = 1 << 0x1f;\n@@ -3616,7 +3617,3 @@\n-            boolean onesLost = false;\n-            for (int i=magLen-1, j=magLen-nInts; i >= j && !onesLost; i--)\n-                onesLost = (mag[i] != 0);\n-            if (!onesLost && nBits != 0)\n-                onesLost = (mag[magLen - nInts - 1] << (32 - nBits) != 0);\n-\n-            if (onesLost)\n+            int nzInts = numberOfTrailingZeroInts();\n+            if (nInts > nzInts || nInts == nzInts\n+                    && (mag[magLen - nzInts - 1] & ((1 << nBits) - 1)) != 0) {\n@@ -3624,0 +3621,1 @@\n+            }\n@@ -3640,1 +3638,1 @@\n-    int[] javaIncrement(int[] val) {\n+    static int[] javaIncrement(int[] val) {\n@@ -3753,1 +3751,1 @@\n-        return (getInt(n >>> 5) & (1 << (n & 31))) != 0;\n+        return (getInt(n >>> 5) & (1 << (n & 0x1f))) != 0;\n@@ -3774,1 +3772,1 @@\n-        result[result.length-intNum-1] |= (1 << (n & 31));\n+        result[result.length-intNum-1] |= (1 << (n & 0x1f));\n@@ -3798,1 +3796,1 @@\n-        result[result.length-intNum-1] &= ~(1 << (n & 31));\n+        result[result.length-intNum-1] &= ~(1 << (n & 0x1f));\n@@ -3822,1 +3820,1 @@\n-        result[result.length-intNum-1] ^= (1 << (n & 31));\n+        result[result.length-intNum-1] ^= (1 << (n & 0x1f));\n@@ -3838,1 +3836,0 @@\n-            lsb = 0;\n@@ -3840,1 +3837,1 @@\n-                lsb -= 1;\n+                lsb = -1;\n@@ -3842,5 +3839,2 @@\n-                \/\/ Search for lowest order nonzero int\n-                int i,b;\n-                for (i=0; (b = getInt(i)) == 0; i++)\n-                    ;\n-                lsb += (i << 5) + Integer.numberOfTrailingZeros(b);\n+                int tz = numberOfTrailingZeroInts();\n+                lsb = tz * Integer.SIZE + Integer.numberOfTrailingZeros(mag[mag.length - 1 - tz]);\n@@ -3867,23 +3861,5 @@\n-        int n = bitLengthPlusOne - 1;\n-        if (n == -1) { \/\/ bitLength not initialized yet\n-            int[] m = mag;\n-            int len = m.length;\n-            if (len == 0) {\n-                n = 0; \/\/ offset by one to initialize\n-            }  else {\n-                \/\/ Calculate the bit length of the magnitude\n-                int magBitLength = ((len - 1) << 5) + bitLengthForInt(mag[0]);\n-                 if (signum < 0) {\n-                     \/\/ Check if magnitude is a power of two\n-                     boolean pow2 = (Integer.bitCount(mag[0]) == 1);\n-                     for (int i=1; i< len && pow2; i++)\n-                         pow2 = (mag[i] == 0);\n-\n-                     n = (pow2 ? magBitLength - 1 : magBitLength);\n-                 } else {\n-                     n = magBitLength;\n-                 }\n-            }\n-            bitLengthPlusOne = n + 1;\n-        }\n-        return n;\n+        return signum < 0\n+                \/\/ Check if magnitude is a power of two\n+                && Integer.lowestOneBit(mag[0]) == mag[0]\n+                && numberOfTrailingZeroInts() == mag.length - 1\n+            ? magBitLength() - 1 : magBitLength();\n@@ -3904,0 +3880,2 @@\n+\n+            final int firstZeroInt = mag.length - numberOfTrailingZeroInts();\n@@ -3905,1 +3883,1 @@\n-            for (int i=0; i < mag.length; i++)\n+            for (int i = 0; i < firstZeroInt; i++)\n@@ -3907,8 +3885,4 @@\n-            if (signum < 0) {\n-                \/\/ Count the trailing zeros in the magnitude\n-                int magTrailingZeroCount = 0, j;\n-                for (j=mag.length-1; mag[j] == 0; j--)\n-                    magTrailingZeroCount += 32;\n-                magTrailingZeroCount += Integer.numberOfTrailingZeros(mag[j]);\n-                bc += magTrailingZeroCount - 1;\n-            }\n+\n+            if (signum < 0)\n+                bc += getLowestSetBit() - 1; \/\/ Count the trailing zeros\n+\n@@ -4336,2 +4310,1 @@\n-        int byteLen = bitLength()\/8 + 1;\n-        byte[] byteArray = new byte[byteLen];\n+        byte[] byteArray = new byte[(bitLength() >>> 3) + 1];\n@@ -4339,1 +4312,1 @@\n-        for (int i=byteLen-1, bytesCopied=4, nextInt=0, intIndex=0; i >= 0; i--) {\n+        for (int i=byteArray.length-1, bytesCopied=4, nextInt=0, intIndex=0; i >= 0; i--) {\n@@ -4369,3 +4342,1 @@\n-        int result = 0;\n-        result = getInt(0);\n-        return result;\n+        return getInt(0);\n@@ -4391,5 +4362,1 @@\n-        long result = 0;\n-\n-        for (int i=1; i >= 0; i--)\n-            result = (result << 32) + (getInt(i) & LONG_MASK);\n-        return result;\n+        return ((long) getInt(1) << Integer.SIZE) | (getInt(0) & LONG_MASK);\n@@ -4419,1 +4386,1 @@\n-        int exponent = ((mag.length - 1) << 5) + bitLengthForInt(mag[0]) - 1;\n+        int exponent = magBitLength() - 1;\n@@ -4504,1 +4471,1 @@\n-        int exponent = ((mag.length - 1) << 5) + bitLengthForInt(mag[0]) - 1;\n+        int exponent = magBitLength() - 1;\n@@ -4577,1 +4544,2 @@\n-     * Returns a copy of the input array stripped of any leading zero bytes.\n+     * Returns the input array stripped of any leading zero ints.\n+     * If the source is trusted the copying may be skipped.\n@@ -4579,2 +4547,1 @@\n-    private static int[] stripLeadingZeroInts(int[] val) {\n-        int vlen = val.length;\n+    private static int[] stripLeadingZeroInts(int[] val, boolean trusted) {\n@@ -4583,2 +4550,2 @@\n-        \/\/ Find first nonzero byte\n-        for (keep = 0; keep < vlen && val[keep] == 0; keep++)\n+        \/\/ Find first nonzero int\n+        for (keep = 0; keep < val.length && val[keep] == 0; keep++)\n@@ -4586,15 +4553,1 @@\n-        return Arrays.copyOfRange(val, keep, vlen);\n-    }\n-\n-    \/**\n-     * Returns the input array stripped of any leading zero bytes.\n-     * Since the source is trusted the copying may be skipped.\n-     *\/\n-    private static int[] trustedStripLeadingZeroInts(int[] val) {\n-        int vlen = val.length;\n-        int keep;\n-\n-        \/\/ Find first nonzero byte\n-        for (keep = 0; keep < vlen && val[keep] == 0; keep++)\n-            ;\n-        return keep == 0 ? val : Arrays.copyOfRange(val, keep, vlen);\n+        return trusted && keep == 0 ? val : Arrays.copyOfRange(val, keep, val.length);\n@@ -4771,1 +4724,1 @@\n-        int keep, j;\n+        int keep, i;\n@@ -4779,1 +4732,1 @@\n-        for (j=keep; j < a.length && a[j] == 0; j++)\n+        for (i = a.length - 1; i >= keep && a[i] == 0; i--) \/\/ Skip trailing zeros\n@@ -4781,12 +4734,12 @@\n-        int extraInt = (j == a.length ? 1 : 0);\n-        int result[] = new int[a.length - keep + extraInt];\n-\n-        \/* Copy one's complement of input into output, leaving extra\n-         * int (if it exists) == 0x00 *\/\n-        for (int i = keep; i < a.length; i++)\n-            result[i - keep + extraInt] = ~a[i];\n-\n-        \/\/ Add one to one's complement to generate two's complement\n-        for (int i=result.length-1; ++result[i] == 0; i--)\n-            ;\n-\n+        int[] result;\n+        if (i < keep) {\n+            result = new int[a.length - keep + 1];\n+            result[0] = 1;\n+        } else { \/\/ Exists a non-sign int that is non-zero\n+            result = new int[a.length - keep];\n+            \/\/ Copy two's complement of input into output\n+            result[i - keep] = -a[i];\n+            i--;\n+            for (; i >= keep; i--)\n+                result[i - keep] = ~a[i];\n+        }\n@@ -4886,1 +4839,1 @@\n-                (n <= firstNonzeroIntNum() ? -magInt : ~magInt));\n+                (n <= numberOfTrailingZeroInts() ? -magInt : ~magInt));\n@@ -4892,1 +4845,1 @@\n-     * least significant). If the magnitude is zero, return value is undefined.\n+     * least significant). If the magnitude is zero, return value is zero.\n@@ -4894,1 +4847,0 @@\n-     * <p>Note: never used for a BigInteger with a magnitude of zero.\n@@ -4897,3 +4849,3 @@\n-    private int firstNonzeroIntNum() {\n-        int fn = firstNonzeroIntNumPlusTwo - 2;\n-        if (fn == -2) { \/\/ firstNonzeroIntNum not initialized yet\n+    private int numberOfTrailingZeroInts() {\n+        int nz = numberOfTrailingZeroIntsPlusTwo - 2;\n+        if (nz == -2) { \/\/ numberOfTrailingZeroInts not initialized yet\n@@ -4902,2 +4854,2 @@\n-            int mlen = mag.length;\n-            for (i = mlen - 1; i >= 0 && mag[i] == 0; i--)\n+            final int lowest = mag.length - 1;\n+            for (i = lowest; i >= 0 && mag[i] == 0; i--)\n@@ -4905,2 +4857,2 @@\n-            fn = mlen - i - 1;\n-            firstNonzeroIntNumPlusTwo = fn + 2; \/\/ offset by two to initialize\n+            nz = lowest - i;\n+            numberOfTrailingZeroIntsPlusTwo = nz + 2; \/\/ offset by two to initialize\n@@ -4908,1 +4860,1 @@\n-        return fn;\n+        return nz;\n@@ -5055,1 +5007,1 @@\n-        int len = mag.length;\n+        byte[] result = new byte[(magBitLength() + 7) >>> 3];\n@@ -5057,5 +5009,1 @@\n-        int bitLen = (len == 0 ? 0 : ((len - 1) << 5) + bitLengthForInt(mag[0]));\n-        int byteLen = (bitLen + 7) >>> 3;\n-        byte[] result = new byte[byteLen];\n-\n-        for (int i = byteLen - 1, bytesCopied = 4, intIndex = len - 1, nextInt = 0;\n+        for (int i = result.length - 1, bytesCopied = 4, intIndex = mag.length - 1, nextInt = 0;\n@@ -5088,1 +5036,1 @@\n-        if (mag.length <= 2 && bitLength() <= 63)\n+        if (mag.length <= 2 && bitLength() < Long.SIZE)\n@@ -5090,2 +5038,2 @@\n-        else\n-            throw new ArithmeticException(\"BigInteger out of long range\");\n+\n+        throw new ArithmeticException(\"BigInteger out of long range\");\n@@ -5107,1 +5055,1 @@\n-        if (mag.length <= 1 && bitLength() <= 31)\n+        if (mag.length <= 1 && bitLength() < Integer.SIZE)\n@@ -5109,2 +5057,2 @@\n-        else\n-            throw new ArithmeticException(\"BigInteger out of int range\");\n+\n+        throw new ArithmeticException(\"BigInteger out of int range\");\n@@ -5126,5 +5074,3 @@\n-        if (mag.length <= 1 && bitLength() <= 31) {\n-            int value = intValue();\n-            if (value >= Short.MIN_VALUE && value <= Short.MAX_VALUE)\n-                return shortValue();\n-        }\n+        if (mag.length <= 1 && bitLength() < Short.SIZE)\n+            return shortValue();\n+\n@@ -5147,5 +5093,3 @@\n-        if (mag.length <= 1 && bitLength() <= 31) {\n-            int value = intValue();\n-            if (value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE)\n-                return byteValue();\n-        }\n+        if (mag.length <= 1 && bitLength() < Byte.SIZE)\n+            return byteValue();\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":115,"deletions":171,"binary":false,"changes":286,"status":"modified"}]}