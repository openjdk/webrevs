{"files":[{"patch":"@@ -110,4 +110,0 @@\n-    case StorageType::INTEGER_AND_FLOAT:\n-      \/\/ \"no partial DW rule\"\n-      __ stw(as_Register(from_reg), -8, R1_SP);\n-      __ lfs(F13, -8, R1_SP); \/\/ fallthrough\n@@ -133,4 +129,0 @@\n-    case StorageType::STACK_AND_FLOAT:\n-      \/\/ \"no partial DW rule\"\n-      __ stw(as_Register(from_reg), -8, R1_SP);\n-      __ lfs(F13, -8, R1_SP); \/\/ fallthrough\n@@ -161,1 +153,1 @@\n-      if (to_reg.segment_mask() == REG32_MASK) {\n+      if (from_reg.segment_mask() == REG32_MASK) {\n@@ -190,3 +182,0 @@\n-    case StorageType::INTEGER_AND_FLOAT:\n-      \/\/ \"no partial DW rule\"\n-      __ lfs(F13, reg2offset(from_reg, in_stk_bias), callerSP); \/\/ fallthrough\n@@ -207,3 +196,0 @@\n-    case StorageType::STACK_AND_FLOAT:\n-      \/\/ \"no partial DW rule\"\n-      __ lfs(F13, reg2offset(from_reg, in_stk_bias), callerSP); \/\/ fallthrough\n@@ -244,1 +230,0 @@\n-      case StorageType::INTEGER_AND_FLOAT:\n@@ -251,1 +236,0 @@\n-      case StorageType::STACK_AND_FLOAT:\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-  INTEGER_AND_FLOAT = 4,\n-  STACK_AND_FLOAT = 5,\n@@ -41,1 +39,1 @@\n-  FRAME_DATA = 6,\n+  FRAME_DATA = 4,\n@@ -47,1 +45,1 @@\n-   return type == StorageType::INTEGER || type == StorageType::INTEGER_AND_FLOAT || type == StorageType::FLOAT;\n+   return type == StorageType::INTEGER || type == StorageType::FLOAT;\n@@ -58,1 +56,1 @@\n-  assert(vms.type() == StorageType::INTEGER || vms.type() == StorageType::INTEGER_AND_FLOAT, \"not the right type\");\n+  assert(vms.type() == StorageType::INTEGER, \"not the right type\");\n","filename":"src\/hotspot\/cpu\/ppc\/vmstorage_ppc.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,0 +92,2 @@\n+    private record HfaRegs(VMStorage[] first, VMStorage[] second) {}\n+\n@@ -234,1 +236,1 @@\n-        VMStorage[] hfaAlloc(List<MemoryLayout> scalarLayouts) {\n+        HfaRegs hfaAlloc(List<MemoryLayout> scalarLayouts) {\n@@ -262,1 +264,2 @@\n-            VMStorage[] result = new VMStorage[fpRegCnt + structSlots];\n+            VMStorage[] result  = new VMStorage[fpRegCnt + structSlots],\n+                        result2 = new VMStorage[fpRegCnt + structSlots]; \/\/ For overlapping.\n@@ -284,1 +287,1 @@\n-                \/\/ \"no partial DW rule\": Mark first stack slot to get filled.\n+                \/\/ \"no partial DW rule\": Put GP reg or stack slot into result2.\n@@ -289,1 +292,1 @@\n-                    overlappingReg = new VMStorage(StorageType.INTEGER_AND_FLOAT,\n+                    overlappingReg = new VMStorage(StorageType.INTEGER,\n@@ -292,1 +295,1 @@\n-                    overlappingReg = new VMStorage(StorageType.STACK_AND_FLOAT,\n+                    overlappingReg = new VMStorage(StorageType.STACK,\n@@ -296,1 +299,1 @@\n-                result[fpRegCnt - 1] = overlappingReg; \/\/ Replace by overlapped slot.\n+                result2[fpRegCnt - 1] = overlappingReg;\n@@ -304,1 +307,1 @@\n-            return result;\n+            return new HfaRegs(result, result2);\n@@ -361,1 +364,1 @@\n-                    VMStorage[] regs = storageCalculator.hfaAlloc(scalarLayouts);\n+                    HfaRegs regs = storageCalculator.hfaAlloc(scalarLayouts);\n@@ -364,1 +367,2 @@\n-                    for (VMStorage storage : regs) {\n+                    for (int index = 0; index < regs.first().length; index++) {\n+                        VMStorage storage = regs.first()[index];\n@@ -366,2 +370,2 @@\n-                        final long size = (baseSize == 4 &&\n-                                           (storage.type() == StorageType.FLOAT || layout.byteSize() - offset < 8)) ? 4 : 8;\n+                        long size = (baseSize == 4 &&\n+                                     (storage.type() == StorageType.FLOAT || layout.byteSize() - offset < 8)) ? 4 : 8;\n@@ -374,0 +378,10 @@\n+                        VMStorage storage2 = regs.second()[index];\n+                        if (storage2 != null) {\n+                            \/\/ We have a second slot to fill (always 64 bit GP reg or stack slot).\n+                            size = 8;\n+                            if (offset + size < layout.byteSize()) {\n+                                bindings.dup();\n+                            }\n+                            bindings.bufferLoad(offset, long.class)\n+                                    .vmStore(storage2, long.class);\n+                        }\n@@ -433,1 +447,1 @@\n-                    VMStorage[] regs = storageCalculator.hfaAlloc(scalarLayouts);\n+                    HfaRegs regs = storageCalculator.hfaAlloc(scalarLayouts);\n@@ -436,1 +450,3 @@\n-                    for (VMStorage storage : regs) {\n+                    for (int index = 0; index < regs.first().length; index++) {\n+                        \/\/ Use second if available since first one only contains one 32 bit value.\n+                        VMStorage storage = regs.second()[index] == null ? regs.first()[index] : regs.second()[index];\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/CallArranger.java","additions":29,"deletions":13,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-        byte INTEGER_AND_FLOAT = 4;\n-        byte STACK_AND_FLOAT = 5;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/PPC64Architecture.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}