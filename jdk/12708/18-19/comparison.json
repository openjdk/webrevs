{"files":[{"patch":"@@ -93,1 +93,2 @@\n-static const int native_invoker_code_size = 1024;\n+static const int native_invoker_code_base_size = 384;\n+static const int native_invoker_size_per_arg = 8;\n@@ -103,2 +104,3 @@\n-  int locs_size = 64;\n-  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n+  int code_size = native_invoker_code_base_size + (num_args * native_invoker_size_per_arg);\n+  int locs_size = 1; \/\/ must be non-zero\n+  CodeBuffer code(\"nep_invoker_blob\", code_size, locs_size);\n","filename":"src\/hotspot\/cpu\/ppc\/downcallLinker_ppc.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,0 +118,3 @@\n+static const int upcall_stub_code_base_size = 1536; \/\/ depends on GC (resolve_jobject)\n+static const int upcall_stub_size_per_arg = 16; \/\/ arg save & restore + move\n+\n@@ -127,1 +130,2 @@\n-  CodeBuffer buffer(\"upcall_stub\", \/* code_size = *\/ 2048, \/* locs_size = *\/ 1024);\n+  int code_size = upcall_stub_code_base_size + (total_in_args * upcall_stub_size_per_arg);\n+  CodeBuffer buffer(\"upcall_stub\", code_size, \/* locs_size = *\/ 1);\n@@ -336,0 +340,2 @@\n+  buffer.log_section_sizes(name);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/upcallLinker_ppc.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.abi.AbstractLinker.UpcallStubFactory;\n@@ -140,1 +141,1 @@\n-    public MemorySegment arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, SegmentScope session) {\n+    public UpcallStubFactory arrangeUpcall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -143,5 +144,3 @@\n-        if (bindings.isInMemoryReturn) {\n-            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n-        }\n-\n-        return UpcallLinker.make(C, target, bindings.callingSequence, session);\n+        final boolean dropReturn = true; \/* drop return, since we don't have bindings for it *\/\n+        return SharedUtils.arrangeUpcallHelper(mt, bindings.isInMemoryReturn, dropReturn, C,\n+                bindings.callingSequence);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/CallArranger.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.foreign.MemorySegment;\n@@ -55,2 +54,2 @@\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return CallArranger.ABIv2.arrangeUpcall(target, targetType, function, scope);\n+    protected UpcallStubFactory arrangeUpcall(MethodType targetType, FunctionDescriptor function) {\n+        return CallArranger.ABIv2.arrangeUpcall(targetType, function);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64leLinker.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/foreign\/largestub\/TestLargeStub.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}