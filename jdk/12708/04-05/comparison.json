{"files":[{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test passing of Homogeneous Float Aggregates.\n+ * @enablePreview\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n+ * @requires !vm.musl\n+ *\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestHFA\n+ *\/\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+public class TestHFA {\n+\n+    static {\n+        System.loadLibrary(\"TestHFA\");\n+    }\n+\n+    final static Linker abi = Linker.nativeLinker();\n+    final static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+    static final OfFloat FLOAT = JAVA_FLOAT.withBitAlignment(32);\n+\n+    final static GroupLayout S_FFLayout = MemoryLayout.structLayout(\n+        FLOAT.withName(\"p0\"),\n+        FLOAT.withName(\"p1\")\n+    ).withName(\"S_FF\");\n+\n+    final static GroupLayout S_FFFFFFFLayout = MemoryLayout.structLayout(\n+        FLOAT.withName(\"p0\"),\n+        FLOAT.withName(\"p1\"),\n+        FLOAT.withName(\"p2\"),\n+        FLOAT.withName(\"p3\"),\n+        FLOAT.withName(\"p4\"),\n+        FLOAT.withName(\"p5\"),\n+        FLOAT.withName(\"p6\")\n+    ).withName(\"S_FFFF\");\n+\n+    static final FunctionDescriptor fdadd_floats_structs = FunctionDescriptor.of(S_FFFFFFFLayout, S_FFFFFFFLayout, S_FFFFFFFLayout);\n+    static final FunctionDescriptor fdadd_float_to_struct_after_floats = FunctionDescriptor.of(S_FFLayout,\n+        JAVA_FLOAT, JAVA_FLOAT, JAVA_FLOAT, JAVA_FLOAT, JAVA_FLOAT,\n+        JAVA_FLOAT, JAVA_FLOAT, JAVA_FLOAT, JAVA_FLOAT, JAVA_FLOAT,\n+        JAVA_FLOAT, JAVA_FLOAT, S_FFLayout, JAVA_FLOAT);\n+    static final FunctionDescriptor fdadd_float_to_struct_after_structs = FunctionDescriptor.of(S_FFLayout,\n+        S_FFLayout, S_FFLayout, S_FFLayout, S_FFLayout, S_FFLayout, S_FFLayout,\n+        S_FFLayout, JAVA_FLOAT);\n+    static final FunctionDescriptor fdadd_float_to_large_struct_after_structs = FunctionDescriptor.of(S_FFFFFFFLayout,\n+        S_FFLayout, S_FFLayout, S_FFLayout, S_FFLayout, S_FFLayout, S_FFLayout,\n+        S_FFFFFFFLayout, JAVA_FLOAT);\n+\n+    final static MethodHandle mhadd_float_structs = abi.downcallHandle(lookup.find(\"add_float_structs\").orElseThrow(),\n+        fdadd_floats_structs);\n+    final static MethodHandle mhadd_float_to_struct_after_floats = abi.downcallHandle(lookup.find(\"add_float_to_struct_after_floats\").orElseThrow(),\n+        fdadd_float_to_struct_after_floats);\n+    final static MethodHandle mhadd_float_to_struct_after_structs = abi.downcallHandle(lookup.find(\"add_float_to_struct_after_structs\").orElseThrow(),\n+        fdadd_float_to_struct_after_structs);\n+    final static MethodHandle mhadd_float_to_large_struct_after_structs = abi.downcallHandle(lookup.find(\"add_float_to_large_struct_after_structs\").orElseThrow(),\n+        fdadd_float_to_large_struct_after_structs);\n+\n+    @Test\n+    public static void testAddFloatStructs() {\n+        float p0 = 0.0f, p1 = 0.0f, p2 = 0.0f, p3 = 0.0f, p4 = 0.0f, p5 = 0.0f, p6 = 0.0f;\n+        try {\n+            Arena arena = Arena.openConfined();\n+            MemorySegment s = MemorySegment.allocateNative(S_FFFFFFFLayout, arena.scope());\n+            s.set(FLOAT, 0, 1.0f);\n+            s.set(FLOAT, 4, 2.0f);\n+            s.set(FLOAT, 8, 3.0f);\n+            s.set(FLOAT, 12, 4.0f);\n+            s.set(FLOAT, 16, 5.0f);\n+            s.set(FLOAT, 20, 6.0f);\n+            s.set(FLOAT, 24, 7.0f);\n+            s = (MemorySegment)mhadd_float_structs.invokeExact((SegmentAllocator)arena, s, s);\n+            p0 = s.get(FLOAT, 0);\n+            p1 = s.get(FLOAT, 4);\n+            p2 = s.get(FLOAT, 8);\n+            p3 = s.get(FLOAT, 12);\n+            p4 = s.get(FLOAT, 16);\n+            p5 = s.get(FLOAT, 20);\n+            p6 = s.get(FLOAT, 24);\n+            System.out.println(\"S_FFFFFFF(\" + p0 + \";\" + p1 + \";\" + p2 + \";\" + p3 + \";\" + p4 + \";\" + p5 + \";\" + p6 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2.0f || p1 != 4.0f || p2 != 6.0f || p3 != 8.0f || p4 != 10.0f || p5 != 12.0f || p6 != 14.0f)\n+            throw new RuntimeException(\"add_float_structs\");\n+    }\n+\n+    @Test\n+    public static void testAddFloatToStructAfterFloats() {\n+        float p0 = 0.0f, p1 = 0.0f;\n+        try {\n+            Arena arena = Arena.openConfined();\n+            MemorySegment s = MemorySegment.allocateNative(S_FFLayout, arena.scope());\n+            s.set(FLOAT, 0, 1.0f);\n+            s.set(FLOAT, 4, 1.0f);\n+            s = (MemorySegment)mhadd_float_to_struct_after_floats.invokeExact((SegmentAllocator)arena,\n+                1.0f, 2.0f, 3.0f, 4.0f, 5.0f,\n+                6.0f, 7.0f, 8.0f, 9.0f, 10.0f,\n+                11.0f, 12.0f, s, 1.0f);\n+            p0 = s.get(FLOAT, 0);\n+            p1 = s.get(FLOAT, 4);\n+            System.out.println(\"S_FF(\" + p0 + \";\" + p1 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2.0f || p1 != 1.0f) throw new RuntimeException(\"add_float_to_struct_after_floats error\");\n+    }\n+\n+    @Test\n+    public static void testAddFloatToStructAfterStructs() {\n+        float p0 = 0.0f, p1 = 0.0f;\n+        try {\n+            Arena arena = Arena.openConfined();\n+            MemorySegment s = MemorySegment.allocateNative(S_FFLayout, arena.scope());\n+            s.set(FLOAT, 0, 1.0f);\n+            s.set(FLOAT, 4, 1.0f);\n+            s = (MemorySegment)mhadd_float_to_struct_after_structs.invokeExact((SegmentAllocator)arena,\n+                 s, s, s, s, s, s,\n+                 s, 1.0f);\n+            p0 = s.get(FLOAT, 0);\n+            p1 = s.get(FLOAT, 4);\n+            System.out.println(\"S_FF(\" + p0 + \";\" + p1 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2.0f || p1 != 1.0f) throw new RuntimeException(\"add_float_to_struct_after_structs error\");\n+    }\n+\n+    @Test\n+    public static void testAddFloatToLargeStructAfterStructs() {\n+        float p0 = 0.0f, p1 = 0.0f, p2 = 0.0f, p3 = 0.0f, p4 = 0.0f, p5 = 0.0f, p6 = 0.0f;\n+        try {\n+            Arena arena = Arena.openConfined();\n+            MemorySegment s = MemorySegment.allocateNative(S_FFFFFFFLayout, arena.scope());\n+            s.set(FLOAT, 0, 1.0f);\n+            s.set(FLOAT, 4, 2.0f);\n+            s.set(FLOAT, 8, 3.0f);\n+            s.set(FLOAT, 12, 4.0f);\n+            s.set(FLOAT, 16, 5.0f);\n+            s.set(FLOAT, 20, 6.0f);\n+            s.set(FLOAT, 24, 7.0f);\n+            s = (MemorySegment)mhadd_float_to_large_struct_after_structs.invokeExact((SegmentAllocator)arena,\n+                 s, s, s, s, s, s,\n+                 s, 1.0f);\n+            p0 = s.get(FLOAT, 0);\n+            p1 = s.get(FLOAT, 4);\n+            p2 = s.get(FLOAT, 8);\n+            p3 = s.get(FLOAT, 12);\n+            p4 = s.get(FLOAT, 16);\n+            p5 = s.get(FLOAT, 20);\n+            p6 = s.get(FLOAT, 24);\n+            System.out.println(\"S_FFFFFFF(\" + p0 + \";\" + p1 + \";\" + p2 + \";\" + p3 + \";\" + p4 + \";\" + p5 + \";\" + p6 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2.0f || p1 != 2.0f || p2 != 3.0f || p3 != 4.0f || p4 != 5.0f || p5 != 6.0f || p6 != 7.0f)\n+            throw new RuntimeException(\"add_float_to_large_struct_after_structs error\");\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestHFA.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"shared.h\"\n+\n+struct S_FFFFFFF { float p0, p1, p2, p3, p4, p5, p6; };\n+\n+EXPORT struct S_FFFFFFF add_float_structs(struct S_FFFFFFF p0,\n+  struct S_FFFFFFF p1){\n+  p0.p0 += p1.p0;\n+  p0.p1 += p1.p1;\n+  p0.p2 += p1.p2;\n+  p0.p3 += p1.p3;\n+  p0.p4 += p1.p4;\n+  p0.p5 += p1.p5;\n+  p0.p6 += p1.p6;\n+  return p0;\n+}\n+\n+\/\/ Corner case on PPC64le: Pass struct S_FF partially in FP register and on stack.\n+\/\/ Pass additional float on stack.\n+EXPORT struct S_FF add_float_to_struct_after_floats(\n+  float f1, float f2, float f3, float f4, float f5,\n+  float f6, float f7, float f8, float f9, float f10,\n+  float f11, float f12, struct S_FF s, float f) {\n+  s.p0 += f;\n+  return s;\n+}\n+\n+\/\/ Corner case on PPC64le: Pass struct S_FF partially in FP register and in GP register.\n+\/\/ Pass additional float in GP register.\n+EXPORT struct S_FF add_float_to_struct_after_structs(\n+  struct S_FF s1, struct S_FF s2, struct S_FF s3, struct S_FF s4, struct S_FF s5, struct S_FF s6,\n+  struct S_FF s, float f) {\n+  s.p0 += f;\n+  return s;\n+}\n+\n+\/\/ Corner case on PPC64le: Pass struct S_FF partially in FP register and in GP register and on stack.\n+EXPORT struct S_FFFFFFF add_float_to_large_struct_after_structs(\n+  struct S_FF s1, struct S_FF s2, struct S_FF s3, struct S_FF s4, struct S_FF s5, struct S_FF s6,\n+  struct S_FFFFFFF s, float f) {\n+  s.p0 += f;\n+  return s;\n+}\n","filename":"test\/jdk\/java\/foreign\/libTestHFA.c","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}