{"files":[{"patch":"@@ -37,1 +37,1 @@\n-    LINUX_PPC_64,\n+    LINUX_PPC_64_LE,\n@@ -69,1 +69,1 @@\n-            ABI = LINUX_PPC_64;\n+            ABI = LINUX_PPC_64_LE;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-                case SYS_V, LINUX_AARCH_64, MAC_OS_AARCH_64, LINUX_PPC_64, LINUX_RISCV_64 -> libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n+                case SYS_V, LINUX_AARCH_64, MAC_OS_AARCH_64, LINUX_PPC_64_LE, LINUX_RISCV_64 -> libLookup(libs -> libs.load(jdkLibraryPath(\"syslookup\")));\n@@ -122,1 +122,1 @@\n-            case SYS_V, LINUX_AARCH_64, MAC_OS_AARCH_64, LINUX_PPC_64, LINUX_RISCV_64 -> \"lib\";\n+            case SYS_V, LINUX_AARCH_64, MAC_OS_AARCH_64, LINUX_PPC_64_LE, LINUX_RISCV_64 -> \"lib\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.internal.foreign.abi.ppc64.linux.LinuxPPC64Linker;\n+import jdk.internal.foreign.abi.ppc64.linux.LinuxPPC64leLinker;\n@@ -49,1 +49,1 @@\n-                                                                      SysVx64Linker, WindowsAArch64Linker, Windowsx64Linker, LinuxPPC64Linker, LinuxRISCV64Linker {\n+                                                                      SysVx64Linker, WindowsAArch64Linker, Windowsx64Linker, LinuxPPC64leLinker, LinuxRISCV64Linker {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.internal.foreign.abi.ppc64.linux.LinuxPPC64Linker;\n+import jdk.internal.foreign.abi.ppc64.linux.LinuxPPC64leLinker;\n@@ -195,1 +195,1 @@\n-            case LINUX_PPC_64 -> LinuxPPC64Linker.getInstance();\n+            case LINUX_PPC_64_LE -> LinuxPPC64leLinker.getInstance();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.foreign.abi.ppc64.linux.ABIv2CallArranger;\n@@ -65,3 +66,3 @@\n-public class CallArranger {\n-    \/\/ Linux PPC64 Little Endian uses ABI v2.\n-    private static final boolean useABIv2 = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;\n+public abstract class CallArranger {\n+    protected abstract boolean useABIv2();\n+\n@@ -74,1 +75,1 @@\n-    private static final ABIDescriptor C = abiFor(\n+    private final ABIDescriptor C = abiFor(\n@@ -82,1 +83,1 @@\n-        useABIv2 ? 32 : 48, \/\/ ABI header (excluding argument register spill slots)\n+        useABIv2() ? 32 : 48, \/\/ ABI header (excluding argument register spill slots)\n@@ -91,2 +92,2 @@\n-    protected CallArranger() {} \/\/ Singleton\n-    public static final CallArranger INSTANCE = new CallArranger();\n+    protected CallArranger() {}\n+    public static final CallArranger ABIv2 = new ABIv2CallArranger();\n@@ -149,1 +150,1 @@\n-    private static boolean isInMemoryReturn(Optional<MemoryLayout> returnLayout) {\n+    private boolean isInMemoryReturn(Optional<MemoryLayout> returnLayout) {\n@@ -152,1 +153,1 @@\n-            .filter(layout -> !TypeClass.isStructHFAorReturnRegisterAggregate(layout, useABIv2))\n+            .filter(layout -> !TypeClass.isStructHFAorReturnRegisterAggregate(layout, useABIv2()))\n@@ -203,1 +204,1 @@\n-            if (!useABIv2 && is32Bit) {\n+            if (!useABIv2() && is32Bit) {\n@@ -219,1 +220,1 @@\n-            if (!useABIv2 && layout.byteSize() % 8 != 0) throw new UnsupportedOperationException(\n+            if (!useABIv2() && layout.byteSize() % 8 != 0) throw new UnsupportedOperationException(\n@@ -331,1 +332,1 @@\n-            TypeClass argumentClass = TypeClass.classifyLayout(layout, useABIv2);\n+            TypeClass argumentClass = TypeClass.classifyLayout(layout, useABIv2());\n@@ -408,1 +409,1 @@\n-            TypeClass argumentClass = TypeClass.classifyLayout(layout, useABIv2);\n+            TypeClass argumentClass = TypeClass.classifyLayout(layout, useABIv2());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/CallArranger.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.ppc64.linux;\n+\n+import jdk.internal.foreign.abi.ppc64.CallArranger;\n+\n+\/**\n+ * PPC64 CallArranger specialized for Linux ABI v2.\n+ *\/\n+public class ABIv2CallArranger extends CallArranger {\n+\n+    @Override\n+    protected boolean useABIv2() {\n+        return true; \/\/ Linux PPC64 Little Endian uses ABI v2.\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/ABIv2CallArranger.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.foreign.abi.ppc64.linux;\n-\n-import jdk.internal.foreign.abi.AbstractLinker;\n-import jdk.internal.foreign.abi.LinkerOptions;\n-import jdk.internal.foreign.abi.ppc64.CallArranger;\n-\n-import java.lang.foreign.SegmentScope;\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.function.Consumer;\n-\n-public final class LinuxPPC64Linker extends AbstractLinker {\n-    private static LinuxPPC64Linker instance;\n-\n-    public static LinuxPPC64Linker getInstance() {\n-        if (instance == null) {\n-            instance = new LinuxPPC64Linker();\n-        }\n-        return instance;\n-    }\n-\n-    @Override\n-    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n-        return CallArranger.INSTANCE.arrangeDowncall(inferredMethodType, function, options);\n-    }\n-\n-    @Override\n-    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n-        return CallArranger.INSTANCE.arrangeUpcall(target, targetType, function, scope);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64Linker.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.ppc64.linux;\n+\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.ppc64.CallArranger;\n+\n+import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Consumer;\n+\n+public final class LinuxPPC64leLinker extends AbstractLinker {\n+    private static LinuxPPC64leLinker instance;\n+\n+    public static LinuxPPC64leLinker getInstance() {\n+        if (instance == null) {\n+            instance = new LinuxPPC64leLinker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.ABIv2.arrangeDowncall(inferredMethodType, function, options);\n+    }\n+\n+    @Override\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n+        return CallArranger.ABIv2.arrangeUpcall(target, targetType, function, scope);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/linux\/LinuxPPC64leLinker.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"}]}