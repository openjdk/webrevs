{"files":[{"patch":"@@ -32,1 +32,0 @@\n- * @requires !vm.musl\n@@ -39,0 +38,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -69,1 +70,1 @@\n-    static final FunctionDescriptor fdadd_floats_structs = FunctionDescriptor.of(S_FFFFFFFLayout, S_FFFFFFFLayout, S_FFFFFFFLayout);\n+    static final FunctionDescriptor fdadd_float_structs = FunctionDescriptor.of(S_FFFFFFFLayout, S_FFFFFFFLayout, S_FFFFFFFLayout);\n@@ -81,0 +82,5 @@\n+    static final FunctionDescriptor fdpass_two_large_structs = FunctionDescriptor.of(S_FFFFFFFLayout, ADDRESS, S_FFFFFFFLayout, S_FFFFFFFLayout);\n+    static final FunctionDescriptor fdpass_struct_after_floats = FunctionDescriptor.of(S_FFLayout, ADDRESS, S_FFLayout, JAVA_FLOAT);\n+    static final FunctionDescriptor fdpass_struct_after_structs = FunctionDescriptor.of(S_FFLayout, ADDRESS, S_FFLayout, JAVA_FLOAT);\n+    static final FunctionDescriptor fdpass_large_struct_after_structs = FunctionDescriptor.of(S_FFFFFFFLayout, ADDRESS, S_FFFFFFFLayout, JAVA_FLOAT);\n+\n@@ -82,1 +88,1 @@\n-        fdadd_floats_structs);\n+        fdadd_float_structs);\n@@ -90,0 +96,9 @@\n+    final static MethodHandle mhpass_two_large_structs = abi.downcallHandle(lookup.find(\"pass_two_large_structs\").orElseThrow(),\n+        fdpass_two_large_structs);\n+    final static MethodHandle mhpass_struct_after_floats = abi.downcallHandle(lookup.find(\"pass_struct_after_floats\").orElseThrow(),\n+        fdpass_struct_after_floats);\n+    final static MethodHandle mhpass_struct_after_structs = abi.downcallHandle(lookup.find(\"pass_struct_after_structs\").orElseThrow(),\n+        fdpass_struct_after_structs);\n+    final static MethodHandle mhpass_large_struct_after_structs = abi.downcallHandle(lookup.find(\"pass_large_struct_after_structs\").orElseThrow(),\n+        fdpass_large_struct_after_structs);\n+\n@@ -116,1 +131,1 @@\n-            throw new RuntimeException(\"add_float_structs\");\n+            throw new RuntimeException(\"add_float_structs error\");\n@@ -190,0 +205,154 @@\n+\n+    \/\/ Java versions for Upcall tests.\n+    public static MemorySegment addFloatStructs(MemorySegment p0, MemorySegment p1) {\n+        float val0 = p0.get(FLOAT,  0) + p1.get(FLOAT,  0);\n+        float val1 = p0.get(FLOAT,  4) + p1.get(FLOAT,  4);\n+        float val2 = p0.get(FLOAT,  8) + p1.get(FLOAT,  8);\n+        float val3 = p0.get(FLOAT, 12) + p1.get(FLOAT, 12);\n+        float val4 = p0.get(FLOAT, 16) + p1.get(FLOAT, 16);\n+        float val5 = p0.get(FLOAT, 20) + p1.get(FLOAT, 20);\n+        float val6 = p0.get(FLOAT, 24) + p1.get(FLOAT, 24);\n+        p0.set(FLOAT,  0, val0);\n+        p0.set(FLOAT,  4, val1);\n+        p0.set(FLOAT,  8, val2);\n+        p0.set(FLOAT, 12, val3);\n+        p0.set(FLOAT, 16, val4);\n+        p0.set(FLOAT, 20, val5);\n+        p0.set(FLOAT, 24, val6);\n+        return p0;\n+    }\n+\n+    public static MemorySegment addFloatToStructAfterFloats(\n+            float f1, float f2, float f3, float f4, float f5,\n+            float f6, float f7, float f8, float f9, float f10,\n+            float f11, float f12, MemorySegment s, float f) {\n+        float val = s.get(FLOAT, 0);\n+        s.set(FLOAT, 0, val + f);\n+        return s;\n+    }\n+\n+    public static MemorySegment addFloatToStructAfterStructs(\n+            MemorySegment s1, MemorySegment s2, MemorySegment s3,\n+            MemorySegment s4, MemorySegment s5, MemorySegment s6,\n+            MemorySegment s, float f) {\n+        float val = s.get(FLOAT, 0);\n+        s.set(FLOAT, 0, val + f);\n+        return s;\n+    }\n+\n+    @Test\n+    public static void testAddFloatStructsUpcall() {\n+        float p0 = 0.0f, p1 = 0.0f, p2 = 0.0f, p3 = 0.0f, p4 = 0.0f, p5 = 0.0f, p6 = 0.0f;\n+        try {\n+            Arena arena = Arena.openConfined();\n+            MemorySegment s = MemorySegment.allocateNative(S_FFFFFFFLayout, arena.scope());\n+            s.set(FLOAT,  0, 1.0f);\n+            s.set(FLOAT,  4, 2.0f);\n+            s.set(FLOAT,  8, 3.0f);\n+            s.set(FLOAT, 12, 4.0f);\n+            s.set(FLOAT, 16, 5.0f);\n+            s.set(FLOAT, 20, 6.0f);\n+            s.set(FLOAT, 24, 7.0f);\n+            MethodType mt = MethodType.methodType(MemorySegment.class,\n+                                                  MemorySegment.class, MemorySegment.class);\n+            MemorySegment stub = abi.upcallStub(MethodHandles.lookup().findStatic(TestHFA.class, \"addFloatStructs\", mt),\n+                                                fdadd_float_structs, SegmentScope.global());\n+            s = (MemorySegment)mhpass_two_large_structs.invokeExact((SegmentAllocator)arena, stub, s, s);\n+            p0 = s.get(FLOAT,  0);\n+            p1 = s.get(FLOAT,  4);\n+            p2 = s.get(FLOAT,  8);\n+            p3 = s.get(FLOAT, 12);\n+            p4 = s.get(FLOAT, 16);\n+            p5 = s.get(FLOAT, 20);\n+            p6 = s.get(FLOAT, 24);\n+            System.out.println(\"S_FFFFFFF(\" + p0 + \";\" + p1 + \";\" + p2 + \";\" + p3 + \";\" + p4 + \";\" + p5 + \";\" + p6 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2.0f || p1 != 4.0f || p2 != 6.0f || p3 != 8.0f || p4 != 10.0f || p5 != 12.0f || p6 != 14.0f)\n+            throw new RuntimeException(\"add_float_structs (Upcall)\");\n+    }\n+\n+    @Test\n+    public static void testAddFloatToStructAfterFloatsUpcall() {\n+        float p0 = 0.0f, p1 = 0.0f;\n+        try {\n+            Arena arena = Arena.openConfined();\n+            MemorySegment s = MemorySegment.allocateNative(S_FFLayout, arena.scope());\n+            s.set(FLOAT, 0, 1.0f);\n+            s.set(FLOAT, 4, 1.0f);\n+            MethodType mt = MethodType.methodType(MemorySegment.class,\n+                                                  float.class, float.class, float.class, float.class,\n+                                                  float.class, float.class, float.class, float.class,\n+                                                  float.class, float.class, float.class, float.class,\n+                                                  MemorySegment.class, float.class);\n+            MemorySegment stub = abi.upcallStub(MethodHandles.lookup().findStatic(TestHFA.class, \"addFloatToStructAfterFloats\", mt),\n+                                                fdadd_float_to_struct_after_floats, SegmentScope.global());\n+            s = (MemorySegment)mhpass_struct_after_floats.invokeExact((SegmentAllocator)arena, stub, s, 1.0f);\n+            p0 = s.get(FLOAT, 0);\n+            p1 = s.get(FLOAT, 4);\n+            System.out.println(\"S_FF(\" + p0 + \";\" + p1 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2.0f || p1 != 1.0f) throw new RuntimeException(\"add_float_to_struct_after_floats (Upcall)\");\n+    }\n+\n+    @Test\n+    public static void testAddFloatToStructAfterStructsUpcall() {\n+        float p0 = 0.0f, p1 = 0.0f;\n+        try {\n+            Arena arena = Arena.openConfined();\n+            MemorySegment s = MemorySegment.allocateNative(S_FFLayout, arena.scope());\n+            s.set(FLOAT, 0, 1.0f);\n+            s.set(FLOAT, 4, 1.0f);\n+            MethodType mt = MethodType.methodType(MemorySegment.class,\n+                                                  MemorySegment.class, MemorySegment.class, MemorySegment.class,\n+                                                  MemorySegment.class, MemorySegment.class, MemorySegment.class,\n+                                                  MemorySegment.class, float.class);\n+            MemorySegment stub = abi.upcallStub(MethodHandles.lookup().findStatic(TestHFA.class, \"addFloatToStructAfterStructs\", mt),\n+                                                fdadd_float_to_struct_after_structs, SegmentScope.global());\n+            s = (MemorySegment)mhpass_struct_after_structs.invokeExact((SegmentAllocator)arena, stub, s, 1.0f);\n+            p0 = s.get(FLOAT, 0);\n+            p1 = s.get(FLOAT, 4);\n+            System.out.println(\"S_FF(\" + p0 + \";\" + p1 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2.0f || p1 != 1.0f) throw new RuntimeException(\"add_float_to_struct_after_structs (Upcall)\");\n+    }\n+\n+    @Test\n+    public static void testAddFloatToLargeStructAfterStructsUpcall() {\n+        float p0 = 0.0f, p1 = 0.0f, p2 = 0.0f, p3 = 0.0f, p4 = 0.0f, p5 = 0.0f, p6 = 0.0f;\n+        try {\n+            Arena arena = Arena.openConfined();\n+            MemorySegment s = MemorySegment.allocateNative(S_FFFFFFFLayout, arena.scope());\n+            s.set(FLOAT,  0, 1.0f);\n+            s.set(FLOAT,  4, 2.0f);\n+            s.set(FLOAT,  8, 3.0f);\n+            s.set(FLOAT, 12, 4.0f);\n+            s.set(FLOAT, 16, 5.0f);\n+            s.set(FLOAT, 20, 6.0f);\n+            s.set(FLOAT, 24, 7.0f);\n+            MethodType mt = MethodType.methodType(MemorySegment.class,\n+                                                  MemorySegment.class, MemorySegment.class, MemorySegment.class,\n+                                                  MemorySegment.class, MemorySegment.class, MemorySegment.class,\n+                                                  MemorySegment.class, float.class);\n+            MemorySegment stub = abi.upcallStub(MethodHandles.lookup().findStatic(TestHFA.class, \"addFloatToStructAfterStructs\", mt),\n+                                                fdadd_float_to_large_struct_after_structs, SegmentScope.global());\n+            s = (MemorySegment)mhpass_large_struct_after_structs.invokeExact((SegmentAllocator)arena, stub, s, 1.0f);\n+            p0 = s.get(FLOAT,  0);\n+            p1 = s.get(FLOAT,  4);\n+            p2 = s.get(FLOAT,  8);\n+            p3 = s.get(FLOAT, 12);\n+            p4 = s.get(FLOAT, 16);\n+            p5 = s.get(FLOAT, 20);\n+            p6 = s.get(FLOAT, 24);\n+            System.out.println(\"S_FFFFFFF(\" + p0 + \";\" + p1 + \";\" + p2 + \";\" + p3 + \";\" + p4 + \";\" + p5 + \";\" + p6 + \")\");\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+        }\n+        if (p0 != 2.0f || p1 != 2.0f || p2 != 3.0f || p3 != 4.0f || p4 != 5.0f || p5 != 6.0f || p6 != 7.0f)\n+            throw new RuntimeException(\"add_float_to_large_struct_after_structs (Upcall)\");\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestHFA.java","additions":173,"deletions":4,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -67,0 +67,34 @@\n+\n+\/\/ Upcall versions.\n+EXPORT struct S_FFFFFFF pass_two_large_structs(struct S_FFFFFFF (*fun)(struct S_FFFFFFF, struct S_FFFFFFF),\n+                                               struct S_FFFFFFF s1, struct S_FFFFFFF s2) {\n+  return fun(s1, s2);\n+}\n+\n+EXPORT struct S_FF pass_struct_after_floats(struct S_FF (*fun)(\n+                                              float, float, float, float, float,\n+                                              float, float, float, float, float,\n+                                              float, float, struct S_FF, float),\n+                                            struct S_FF s1, float f) {\n+  return fun(1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f, 11.0f, 12.0f, s1, f);\n+}\n+\n+EXPORT struct S_FF pass_struct_after_structs(struct S_FF (*fun)(\n+                                               struct S_FF, struct S_FF, struct S_FF,\n+                                               struct S_FF, struct S_FF, struct S_FF,\n+                                               struct S_FF, float),\n+                                             struct S_FF s1, float f) {\n+  struct S_FF dummy;\n+  dummy.p0 = 1; dummy.p1 = 2;\n+  return fun(dummy, dummy, dummy, dummy, dummy, dummy, s1, f);\n+}\n+\n+EXPORT struct S_FFFFFFF pass_large_struct_after_structs(struct S_FFFFFFF (*fun)(\n+                                                          struct S_FF, struct S_FF, struct S_FF,\n+                                                          struct S_FF, struct S_FF, struct S_FF,\n+                                                          struct S_FFFFFFF, float),\n+                                                        struct S_FFFFFFF s1, float f) {\n+  struct S_FF dummy;\n+  dummy.p0 = 1; dummy.p1 = 2;\n+  return fun(dummy, dummy, dummy, dummy, dummy, dummy, s1, f);\n+}\n","filename":"test\/jdk\/java\/foreign\/libTestHFA.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"}]}