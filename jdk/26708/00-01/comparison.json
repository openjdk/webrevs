{"files":[{"patch":"@@ -1202,2 +1202,4 @@\n-     * When parsing, the behaviour of {@link DateTimeFormatterBuilder#appendOffsetId()}\n-     * will be used to parse the offset, converting the instant to UTC as necessary.\n+     * When parsing, the behaviour of\n+     * {@link DateTimeFormatterBuilder#appendOffset(String, String)\n+     * appendOffset(\"+HH:mm:ss\", \"Z\")} will be used to parse the offset,\n+     * converting the instant to UTC as necessary.\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -897,2 +897,4 @@\n-     * When parsing, the behaviour of {@link DateTimeFormatterBuilder#appendOffsetId()}\n-     * will be used to parse the offset, converting the instant to UTC as necessary.\n+     * When parsing, the behaviour of\n+     * {@link DateTimeFormatterBuilder#appendOffset(String, String)\n+     * appendOffset(\"+HH:mm:ss\", \"Z\")} will be used to parse the offset, converting\n+     * the instant to UTC as necessary.\n@@ -3890,1 +3892,1 @@\n-                    .appendOffsetId()\n+                    .appendOffset(\"+HH:mm:ss\", \"Z\")\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+import java.time.format.DateTimeParseException;\n@@ -73,1 +74,1 @@\n- * @bug 8273369 8331202\n+ * @bug 8273369 8331202 8364752\n@@ -154,0 +155,31 @@\n+\n+    @DataProvider\n+    private Object[][] valid_instants() {\n+        return new Object[][] {\n+            {\"2017-01-01T00:00:00.000+02\"},\n+            {\"2017-01-01T00:00:00.000+02:00\"},\n+            {\"2017-01-01T00:00:00.000+02:00:00\"},\n+            {\"2017-01-01T00:00:00.000Z\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"valid_instants\")\n+    public void test_parse_valid(String instant) {\n+        Instant.parse(instant);\n+    }\n+\n+    @DataProvider\n+    private Object[][] invalid_instants() {\n+        return new Object[][] {\n+            {\"2017-01-01T00:00:00.000\"},\n+            {\"2017-01-01T00:00:00.000+0\"},\n+            {\"2017-01-01T00:00:00.000+020\"},\n+            {\"2017-01-01T00:00:00.000+02:0\"},\n+            {\"2017-01-01T00:00:00.000UTC\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"invalid_instants\")\n+    public void test_parse_invalid(String instant) {\n+        assertThrows(DateTimeParseException.class, () -> Instant.parse(instant));\n+    }\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/TestInstant.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"}]}