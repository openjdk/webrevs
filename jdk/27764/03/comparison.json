{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -39,1 +40,1 @@\n-void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n+void MallocHeader::print_block_on_error(outputStream* st, address bad_address, address block_address) const {\n@@ -51,0 +52,12 @@\n+  if (MemTracker::tracking_level() == NMT_TrackingLevel::NMT_detail) {\n+    MallocHeader* mh = (MallocHeader*)block_address;\n+    NativeCallStack stack;\n+    if (MallocSiteTable::access_stack(stack, *mh)) {\n+      st->print_cr(\"allocated from:\");\n+      stack.print_on(st);\n+    } else {\n+      st->print_cr(\"allocation-site cannot be shown since the marker is also corrupted.\");\n+    }\n+    st->print_cr(\"\");\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  void print_block_on_error(outputStream* st, address bad_address) const;\n+  void print_block_on_error(outputStream* st, address bad_address, address block_address) const;\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    header_pointer->print_block_on_error(tty, corruption != nullptr ? corruption : (address)header_pointer);\n+    header_pointer->print_block_on_error(tty, corruption != nullptr ? corruption : (address)header_pointer, (address)header_pointer);\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,3 @@\n-  assert(bucket_idx < table_size, \"Invalid bucket index\");\n+  if (bucket_idx >= table_size) {\n+    return nullptr;\n+  }\n@@ -172,1 +174,3 @@\n-  assert(head != nullptr, \"Invalid position index\");\n+  if (head == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/nmt\/mallocSiteTable.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,0 +167,10 @@\n+TEST_VM_FATAL_ERROR_MSG(NMT, memory_corruption_call_stack, \".*header canary.*\") {\n+  if (MemTracker::tracking_level() != NMT_detail) {\n+    guarantee(false, \"fake message ignore this - header canary\");\n+  }\n+  const size_t SIZE = 1024;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  *(p - 1) = 0;\n+  os::free(p);\n+}\n+\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 021MALLOC_SIZE-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Check the allocation-site stack trace of a corrupted memory at free() time\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:NativeMemoryTracking=detail NMTPrintMallocSiteOfCorruptedMemory\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class NMTPrintMallocSiteOfCorruptedMemory {\n+    private static final String HEADER_ARG = \"header\";\n+    private static final String FOOTER_ARG = \"footer\";\n+    private static final String HEADER_AND_SITE_ARG = \"header-and-site\";\n+    private static final String FOOTER_AND_SITE_ARG = \"footer-and-site\";\n+    private static final int MALLOC_SIZE = 10;\n+    private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    static {\n+        System.loadLibrary(\"MallocHeaderModifier\");\n+    }\n+\n+    public static native byte modifyHeaderCanary(long malloc_memory);\n+    public static native byte modifyFooterCanary(long malloc_memory, long size);\n+    public static native byte modifyHeaderCanaryAndSiteMarker(long malloc_memory);\n+    public static native byte modifyFooterCanaryAndSiteMarker(long malloc_memory, long size);\n+\n+    private static void runThisTestWith(String arg) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(new String[] {\"-Xbootclasspath\/a:.\",\n+                                                                                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                                    \"-XX:+WhiteBoxAPI\",\n+                                                                                    \"-XX:NativeMemoryTracking=detail\",\n+                                                                                    \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+                                                                                    \"NMTPrintMallocSiteOfCorruptedMemory\",\n+                                                                                    arg});\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldMatch(\"NMT Block at .*, corruption at: \");\n+        switch(arg) {\n+            case HEADER_AND_SITE_ARG, FOOTER_AND_SITE_ARG -> output.shouldContain(\"allocation-site cannot be shown since the marker is also corrupted.\");\n+            case HEADER_ARG, FOOTER_ARG -> {\n+                output.shouldContain(\"allocated from:\");\n+                output.shouldMatch(\"\\\\[.*\\\\]WB_NMTMalloc\\\\+0x.*\");\n+            }\n+        }\n+    }\n+\n+    private static void testModifyHeaderCanary() {\n+        long addr = wb.NMTMalloc(MALLOC_SIZE);\n+        modifyHeaderCanary(addr);\n+        wb.NMTFree(addr);\n+    }\n+\n+    private static void testModifyFooterCanary() {\n+        long addr = wb.NMTMalloc(MALLOC_SIZE);\n+        modifyFooterCanary(addr, MALLOC_SIZE);\n+        wb.NMTFree(addr);\n+    }\n+\n+    private static void testModifyHeaderCanaryAndSiteMarker() {\n+        long addr = wb.NMTMalloc(MALLOC_SIZE);\n+        modifyHeaderCanaryAndSiteMarker(addr);\n+        wb.NMTFree(addr);\n+    }\n+\n+    private static void testModifyFooterCanaryAndSiteMarker() {\n+        long addr = wb.NMTMalloc(MALLOC_SIZE);\n+        modifyFooterCanaryAndSiteMarker(addr, MALLOC_SIZE);\n+        wb.NMTFree(addr);\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        if (args != null && args.length == 1) {\n+            switch (args[0]) {\n+                case HEADER_ARG -> testModifyHeaderCanary();\n+                case FOOTER_ARG -> testModifyFooterCanary();\n+                case HEADER_AND_SITE_ARG -> testModifyHeaderCanaryAndSiteMarker();\n+                case FOOTER_AND_SITE_ARG -> testModifyFooterCanaryAndSiteMarker();\n+                default -> throw new RuntimeException(\"Invalid argument for NMTPrintMallocSiteOfCorruptedMemory (\" + args[0] + \")\");\n+            }\n+        } else {\n+            runThisTestWith(HEADER_ARG);\n+            runThisTestWith(FOOTER_ARG);\n+            runThisTestWith(HEADER_AND_SITE_ARG);\n+            runThisTestWith(FOOTER_AND_SITE_ARG);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/NMTPrintMallocSiteOfCorruptedMemory.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include <string.h>\n+\n+JNIEXPORT jint JNICALL\n+Java_NMTPrintMallocSiteOfCorruptedMemory_modifyHeaderCanary(JNIEnv *env, jclass cls, jlong addr) {\n+  *((jint*)(uintptr_t)addr - 1) = 0;\n+  return 0;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_NMTPrintMallocSiteOfCorruptedMemory_modifyFooterCanary(JNIEnv *env, jclass cls, jlong addr, jint size) {\n+  *((jbyte*)(uintptr_t)addr + size + 1) = 0;\n+  return 0;\n+}\n+JNIEXPORT jint JNICALL\n+Java_NMTPrintMallocSiteOfCorruptedMemory_modifyHeaderCanaryAndSiteMarker(JNIEnv *env, jclass cls, jlong addr) {\n+  jbyte* p = (jbyte*)(uintptr_t)addr - 16;\n+  memset(p, 0xFF , 16);\n+  return 0;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_NMTPrintMallocSiteOfCorruptedMemory_modifyFooterCanaryAndSiteMarker(JNIEnv *env, jclass cls, jlong addr, jint size) {\n+  jbyte* p = (jbyte*)(uintptr_t)addr - 16;\n+  memset(p, 0xFF , 16);\n+  *((jbyte*)(uintptr_t)addr + size + 1) = 0;\n+  return 0;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/libMallocHeaderModifier.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}