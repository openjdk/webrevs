{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memTracker.hpp\"\n@@ -39,1 +40,1 @@\n-void MallocHeader::print_block_on_error(outputStream* st, address bad_address) const {\n+void MallocHeader::print_block_on_error(outputStream* st, address bad_address, address block_address) const {\n@@ -51,0 +52,12 @@\n+  if (MemTracker::tracking_level() == NMT_TrackingLevel::NMT_detail) {\n+    MallocHeader* mh = (MallocHeader*)block_address;\n+    NativeCallStack stack;\n+    if (MallocSiteTable::access_stack(stack, *mh)) {\n+      st->print_cr(\"allocated from:\");\n+      stack.print_on(st);\n+    } else {\n+      st->print_cr(\"allocation-site cannot be shown since the marker is also corrupted.\");\n+    }\n+    st->print_cr(\"\");\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  void print_block_on_error(outputStream* st, address bad_address) const;\n+  void print_block_on_error(outputStream* st, address bad_address, address block_address) const;\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    header_pointer->print_block_on_error(tty, corruption != nullptr ? corruption : (address)header_pointer);\n+    header_pointer->print_block_on_error(tty, corruption != nullptr ? corruption : (address)header_pointer, (address)header_pointer);\n","filename":"src\/hotspot\/share\/nmt\/mallocHeader.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,3 @@\n-  assert(bucket_idx < table_size, \"Invalid bucket index\");\n+  if (bucket_idx >= table_size) {\n+    return nullptr;\n+  }\n@@ -172,1 +174,3 @@\n-  assert(head != nullptr, \"Invalid position index\");\n+  if (head == nullptr) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/nmt\/mallocSiteTable.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -167,0 +167,10 @@\n+TEST_VM_FATAL_ERROR_MSG(NMT, memory_corruption_call_stack, \".*header canary.*\") {\n+  if (MemTracker::tracking_level() != NMT_detail) {\n+    guarantee(false, \"fake message ignore this - header canary\");\n+  }\n+  const size_t SIZE = 1024;\n+  char* p = (char*)os::malloc(SIZE, mtTest);\n+  *(p -1) = 0;\n+  os::free(p);\n+}\n+\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}