{"files":[{"patch":"@@ -1,804 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.regex.Pattern;\n-\n-import com.sun.tools.classfile.Dependency.Filter;\n-import com.sun.tools.classfile.Dependency.Finder;\n-import com.sun.tools.classfile.Dependency.Location;\n-import com.sun.tools.classfile.Type.ArrayType;\n-import com.sun.tools.classfile.Type.ClassSigType;\n-import com.sun.tools.classfile.Type.ClassType;\n-import com.sun.tools.classfile.Type.MethodType;\n-import com.sun.tools.classfile.Type.SimpleType;\n-import com.sun.tools.classfile.Type.TypeParamType;\n-import com.sun.tools.classfile.Type.WildcardType;\n-\n-import static com.sun.tools.classfile.ConstantPool.*;\n-\n-\/**\n- * A framework for determining {@link Dependency dependencies} between class files.\n- *\n- * A {@link Dependency.Finder finder} is used to identify the dependencies of\n- * individual classes. Some finders may return subtypes of {@code Dependency} to\n- * further characterize the type of dependency, such as a dependency on a\n- * method within a class.\n- *\n- * A {@link Dependency.Filter filter} may be used to restrict the set of\n- * dependencies found by a finder.\n- *\n- * Dependencies that are found may be passed to a {@link Dependencies.Recorder\n- * recorder} so that the dependencies can be stored in a custom data structure.\n- *\/\n-public class Dependencies {\n-    \/**\n-     * Thrown when a class file cannot be found.\n-     *\/\n-    @SuppressWarnings(\"this-escape\")\n-    public static class ClassFileNotFoundException extends Exception {\n-        private static final long serialVersionUID = 3632265927794475048L;\n-\n-        public ClassFileNotFoundException(String className) {\n-            super(className);\n-            this.className = className;\n-        }\n-\n-        public ClassFileNotFoundException(String className, Throwable cause) {\n-            this(className);\n-            initCause(cause);\n-        }\n-\n-        public final String className;\n-    }\n-\n-    \/**\n-     * Thrown when an exception is found processing a class file.\n-     *\/\n-    @SuppressWarnings(\"this-escape\")\n-    public static class ClassFileError extends Error {\n-        private static final long serialVersionUID = 4111110813961313203L;\n-\n-        public ClassFileError(Throwable cause) {\n-            initCause(cause);\n-        }\n-    }\n-\n-    \/**\n-     * Service provider interface to locate and read class files.\n-     *\/\n-    public interface ClassFileReader {\n-        \/**\n-         * Get the ClassFile object for a specified class.\n-         * @param className the name of the class to be returned.\n-         * @return the ClassFile for the given class\n-         * @throws Dependencies.ClassFileNotFoundException if the classfile cannot be\n-         *   found\n-         *\/\n-        public ClassFile getClassFile(String className)\n-                throws ClassFileNotFoundException;\n-    }\n-\n-    \/**\n-     * Service provide interface to handle results.\n-     *\/\n-    public interface Recorder {\n-        \/**\n-         * Record a dependency that has been found.\n-         * @param d\n-         *\/\n-        public void addDependency(Dependency d);\n-    }\n-\n-    \/**\n-     * Get the  default finder used to locate the dependencies for a class.\n-     * @return the default finder\n-     *\/\n-    public static Finder getDefaultFinder() {\n-        return new APIDependencyFinder(AccessFlags.ACC_PRIVATE);\n-    }\n-\n-    \/**\n-     * Get a finder used to locate the API dependencies for a class.\n-     * These include the superclass, superinterfaces, and classes referenced in\n-     * the declarations of fields and methods.  The fields and methods that\n-     * are checked can be limited according to a specified access.\n-     * The access parameter must be one of {@link AccessFlags#ACC_PUBLIC ACC_PUBLIC},\n-     * {@link AccessFlags#ACC_PRIVATE ACC_PRIVATE},\n-     * {@link AccessFlags#ACC_PROTECTED ACC_PROTECTED}, or 0 for\n-     * package private access. Members with greater than or equal accessibility\n-     * to that specified will be searched for dependencies.\n-     * @param access the access of members to be checked\n-     * @return an API finder\n-     *\/\n-    public static Finder getAPIFinder(int access) {\n-        return new APIDependencyFinder(access);\n-    }\n-\n-    \/**\n-     * Get a finder to do class dependency analysis.\n-     *\n-     * @return a Class dependency finder\n-     *\/\n-    public static Finder getClassDependencyFinder() {\n-        return new ClassDependencyFinder();\n-    }\n-\n-    \/**\n-     * Get the finder used to locate the dependencies for a class.\n-     * @return the finder\n-     *\/\n-    public Finder getFinder() {\n-        if (finder == null)\n-            finder = getDefaultFinder();\n-        return finder;\n-    }\n-\n-    \/**\n-     * Set the finder used to locate the dependencies for a class.\n-     * @param f the finder\n-     *\/\n-    public void setFinder(Finder f) {\n-        finder = Objects.requireNonNull(f);\n-    }\n-\n-    \/**\n-     * Get the default filter used to determine included when searching\n-     * the transitive closure of all the dependencies.\n-     * Unless overridden, the default filter accepts all dependencies.\n-     * @return the default filter.\n-     *\/\n-    public static Filter getDefaultFilter() {\n-        return DefaultFilter.instance();\n-    }\n-\n-    \/**\n-     * Get a filter which uses a regular expression on the target's class name\n-     * to determine if a dependency is of interest.\n-     * @param pattern the pattern used to match the target's class name\n-     * @return a filter for matching the target class name with a regular expression\n-     *\/\n-    public static Filter getRegexFilter(Pattern pattern) {\n-        return new TargetRegexFilter(pattern);\n-    }\n-\n-    \/**\n-     * Get a filter which checks the package of a target's class name\n-     * to determine if a dependency is of interest. The filter checks if the\n-     * package of the target's class matches any of a set of given package\n-     * names. The match may optionally match subpackages of the given names as well.\n-     * @param packageNames the package names used to match the target's class name\n-     * @param matchSubpackages whether or not to match subpackages as well\n-     * @return a filter for checking the target package name against a list of package names\n-     *\/\n-    public static Filter getPackageFilter(Set<String> packageNames, boolean matchSubpackages) {\n-        return new TargetPackageFilter(packageNames, matchSubpackages);\n-    }\n-\n-    \/**\n-     * Get the filter used to determine the dependencies included when searching\n-     * the transitive closure of all the dependencies.\n-     * Unless overridden, the default filter accepts all dependencies.\n-     * @return the filter\n-     *\/\n-    public Filter getFilter() {\n-        if (filter == null)\n-            filter = getDefaultFilter();\n-        return filter;\n-    }\n-\n-    \/**\n-     * Set the filter used to determine the dependencies included when searching\n-     * the transitive closure of all the dependencies.\n-     * @param f the filter\n-     *\/\n-    public void setFilter(Filter f) {\n-        filter = Objects.requireNonNull(f);\n-    }\n-\n-    \/**\n-     * Find the dependencies of a class, using the current\n-     * {@link Dependencies#getFinder finder} and\n-     * {@link Dependencies#getFilter filter}.\n-     * The search may optionally include the transitive closure of all the\n-     * filtered dependencies, by also searching in the classes named in those\n-     * dependencies.\n-     * @param classFinder a finder to locate class files\n-     * @param rootClassNames the names of the root classes from which to begin\n-     *      searching\n-     * @param transitiveClosure whether or not to also search those classes\n-     *      named in any filtered dependencies that are found.\n-     * @return the set of dependencies that were found\n-     * @throws ClassFileNotFoundException if a required class file cannot be found\n-     * @throws ClassFileError if an error occurs while processing a class file,\n-     *      such as an error in the internal class file structure.\n-     *\/\n-    public Set<Dependency> findAllDependencies(\n-            ClassFileReader classFinder, Set<String> rootClassNames,\n-            boolean transitiveClosure)\n-            throws ClassFileNotFoundException {\n-        final Set<Dependency> results = new HashSet<>();\n-        Recorder r = results::add;\n-        findAllDependencies(classFinder, rootClassNames, transitiveClosure, r);\n-        return results;\n-    }\n-\n-    \/**\n-     * Find the dependencies of a class, using the current\n-     * {@link Dependencies#getFinder finder} and\n-     * {@link Dependencies#getFilter filter}.\n-     * The search may optionally include the transitive closure of all the\n-     * filtered dependencies, by also searching in the classes named in those\n-     * dependencies.\n-     * @param classFinder a finder to locate class files\n-     * @param rootClassNames the names of the root classes from which to begin\n-     *      searching\n-     * @param transitiveClosure whether or not to also search those classes\n-     *      named in any filtered dependencies that are found.\n-     * @param recorder a recorder for handling the results\n-     * @throws ClassFileNotFoundException if a required class file cannot be found\n-     * @throws ClassFileError if an error occurs while processing a class file,\n-     *      such as an error in the internal class file structure.\n-     *\/\n-    public void findAllDependencies(\n-            ClassFileReader classFinder, Set<String> rootClassNames,\n-            boolean transitiveClosure, Recorder recorder)\n-            throws ClassFileNotFoundException {\n-        Set<String> doneClasses = new HashSet<>();\n-\n-        getFinder();  \/\/ ensure initialized\n-        getFilter();  \/\/ ensure initialized\n-\n-        \/\/ Work queue of names of classfiles to be searched.\n-        \/\/ Entries will be unique, and for classes that do not yet have\n-        \/\/ dependencies in the results map.\n-        Deque<String> deque = new LinkedList<>(rootClassNames);\n-\n-        String className;\n-        while ((className = deque.poll()) != null) {\n-            assert (!doneClasses.contains(className));\n-            doneClasses.add(className);\n-\n-            ClassFile cf = classFinder.getClassFile(className);\n-\n-            \/\/ The following code just applies the filter to the dependencies\n-            \/\/ followed for the transitive closure.\n-            for (Dependency d: finder.findDependencies(cf)) {\n-                recorder.addDependency(d);\n-                if (transitiveClosure && filter.accepts(d)) {\n-                    String cn = d.getTarget().getClassName();\n-                    if (!doneClasses.contains(cn))\n-                        deque.add(cn);\n-                }\n-            }\n-        }\n-    }\n-\n-    private Filter filter;\n-    private Finder finder;\n-\n-    \/**\n-     * A location identifying a class.\n-     *\/\n-    static class SimpleLocation implements Location {\n-        public SimpleLocation(String name) {\n-            this.name = name;\n-            this.className = name.replace('\/', '.');\n-        }\n-\n-        public String getName() {\n-            return name;\n-        }\n-\n-        public String getClassName() {\n-            return className;\n-        }\n-\n-        public String getPackageName() {\n-            int i = name.lastIndexOf('\/');\n-            return (i > 0) ? name.substring(0, i).replace('\/', '.') : \"\";\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            if (this == other)\n-                return true;\n-            if (!(other instanceof SimpleLocation))\n-                return false;\n-            return (name.equals(((SimpleLocation) other).name));\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return name.hashCode();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return name;\n-        }\n-\n-        private String name;\n-        private String className;\n-    }\n-\n-    \/**\n-     * A dependency of one class on another.\n-     *\/\n-    static class SimpleDependency implements Dependency {\n-        public SimpleDependency(Location origin, Location target) {\n-            this.origin = origin;\n-            this.target = target;\n-        }\n-\n-        public Location getOrigin() {\n-            return origin;\n-        }\n-\n-        public Location getTarget() {\n-            return target;\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            if (this == other)\n-                return true;\n-            if (!(other instanceof SimpleDependency))\n-                return false;\n-            SimpleDependency o = (SimpleDependency) other;\n-            return (origin.equals(o.origin) && target.equals(o.target));\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return origin.hashCode() * 31 + target.hashCode();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return origin + \":\" + target;\n-        }\n-\n-        private Location origin;\n-        private Location target;\n-    }\n-\n-\n-    \/**\n-     * This class accepts all dependencies.\n-     *\/\n-    static class DefaultFilter implements Filter {\n-        private static DefaultFilter instance;\n-\n-        static DefaultFilter instance() {\n-            if (instance == null)\n-                instance = new DefaultFilter();\n-            return instance;\n-        }\n-\n-        public boolean accepts(Dependency dependency) {\n-            return true;\n-        }\n-    }\n-\n-    \/**\n-     * This class accepts those dependencies whose target's class name matches a\n-     * regular expression.\n-     *\/\n-    static class TargetRegexFilter implements Filter {\n-        TargetRegexFilter(Pattern pattern) {\n-            this.pattern = pattern;\n-        }\n-\n-        public boolean accepts(Dependency dependency) {\n-            return pattern.matcher(dependency.getTarget().getClassName()).matches();\n-        }\n-\n-        private final Pattern pattern;\n-    }\n-\n-    \/**\n-     * This class accepts those dependencies whose class name is in a given\n-     * package.\n-     *\/\n-    static class TargetPackageFilter implements Filter {\n-        TargetPackageFilter(Set<String> packageNames, boolean matchSubpackages) {\n-            for (String pn: packageNames) {\n-                if (pn.length() == 0) \/\/ implies null check as well\n-                    throw new IllegalArgumentException();\n-            }\n-            this.packageNames = packageNames;\n-            this.matchSubpackages = matchSubpackages;\n-        }\n-\n-        public boolean accepts(Dependency dependency) {\n-            String pn = dependency.getTarget().getPackageName();\n-            if (packageNames.contains(pn))\n-                return true;\n-\n-            if (matchSubpackages) {\n-                for (String n: packageNames) {\n-                    if (pn.startsWith(n + \".\"))\n-                        return true;\n-                }\n-            }\n-\n-            return false;\n-        }\n-\n-        private final Set<String> packageNames;\n-        private final boolean matchSubpackages;\n-    }\n-\n-    \/**\n-     * This class identifies class names directly or indirectly in the constant pool.\n-     *\/\n-    static class ClassDependencyFinder extends BasicDependencyFinder {\n-        public Iterable<? extends Dependency> findDependencies(ClassFile classfile) {\n-            Visitor v = new Visitor(classfile);\n-            for (CPInfo cpInfo: classfile.constant_pool.entries()) {\n-                v.scan(cpInfo);\n-            }\n-            try {\n-                v.addClass(classfile.super_class);\n-                v.addClasses(classfile.interfaces);\n-                v.scan(classfile.attributes);\n-\n-                for (Field f : classfile.fields) {\n-                    v.scan(f.descriptor, f.attributes);\n-                }\n-                for (Method m : classfile.methods) {\n-                    v.scan(m.descriptor, m.attributes);\n-                    Exceptions_attribute e =\n-                        (Exceptions_attribute)m.attributes.get(Attribute.Exceptions);\n-                    if (e != null) {\n-                        v.addClasses(e.exception_index_table);\n-                    }\n-                }\n-            } catch (ConstantPoolException e) {\n-                throw new ClassFileError(e);\n-            }\n-\n-            return v.deps;\n-        }\n-    }\n-\n-    \/**\n-     * This class identifies class names in the signatures of classes, fields,\n-     * and methods in a class.\n-     *\/\n-    static class APIDependencyFinder extends BasicDependencyFinder {\n-        APIDependencyFinder(int access) {\n-            switch (access) {\n-                case AccessFlags.ACC_PUBLIC:\n-                case AccessFlags.ACC_PROTECTED:\n-                case AccessFlags.ACC_PRIVATE:\n-                case 0:\n-                    showAccess = access;\n-                    break;\n-                default:\n-                    throw new IllegalArgumentException(\"invalid access 0x\"\n-                            + Integer.toHexString(access));\n-            }\n-        }\n-\n-        public Iterable<? extends Dependency> findDependencies(ClassFile classfile) {\n-            try {\n-                Visitor v = new Visitor(classfile);\n-                v.addClass(classfile.super_class);\n-                v.addClasses(classfile.interfaces);\n-                \/\/ inner classes?\n-                for (Field f : classfile.fields) {\n-                    if (checkAccess(f.access_flags))\n-                        v.scan(f.descriptor, f.attributes);\n-                }\n-                for (Method m : classfile.methods) {\n-                    if (checkAccess(m.access_flags)) {\n-                        v.scan(m.descriptor, m.attributes);\n-                        Exceptions_attribute e =\n-                                (Exceptions_attribute) m.attributes.get(Attribute.Exceptions);\n-                        if (e != null)\n-                            v.addClasses(e.exception_index_table);\n-                    }\n-                }\n-                return v.deps;\n-            } catch (ConstantPoolException e) {\n-                throw new ClassFileError(e);\n-            }\n-        }\n-\n-        boolean checkAccess(AccessFlags flags) {\n-            \/\/ code copied from javap.Options.checkAccess\n-            boolean isPublic = flags.is(AccessFlags.ACC_PUBLIC);\n-            boolean isProtected = flags.is(AccessFlags.ACC_PROTECTED);\n-            boolean isPrivate = flags.is(AccessFlags.ACC_PRIVATE);\n-            boolean isPackage = !(isPublic || isProtected || isPrivate);\n-\n-            if ((showAccess == AccessFlags.ACC_PUBLIC) && (isProtected || isPrivate || isPackage))\n-                return false;\n-            else if ((showAccess == AccessFlags.ACC_PROTECTED) && (isPrivate || isPackage))\n-                return false;\n-            else if ((showAccess == 0) && (isPrivate))\n-                return false;\n-            else\n-                return true;\n-        }\n-\n-        private int showAccess;\n-    }\n-\n-    abstract static class BasicDependencyFinder implements Finder {\n-        private Map<String,Location> locations = new ConcurrentHashMap<>();\n-\n-        Location getLocation(String className) {\n-            return locations.computeIfAbsent(className, SimpleLocation::new);\n-        }\n-\n-        class Visitor implements ConstantPool.Visitor<Void,Void>, Type.Visitor<Void, Void> {\n-            private ConstantPool constant_pool;\n-            private Location origin;\n-            Set<Dependency> deps;\n-\n-            Visitor(ClassFile classFile) {\n-                try {\n-                    constant_pool = classFile.constant_pool;\n-                    origin = getLocation(classFile.getName());\n-                    deps = new HashSet<>();\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            void scan(Descriptor d, Attributes attrs) {\n-                try {\n-                    scan(new Signature(d.index).getType(constant_pool));\n-                    scan(attrs);\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            void scan(CPInfo cpInfo) {\n-                cpInfo.accept(this, null);\n-            }\n-\n-            void scan(Type t) {\n-                t.accept(this, null);\n-            }\n-\n-            void scan(Attributes attrs) {\n-                try {\n-                    Signature_attribute sa = (Signature_attribute)attrs.get(Attribute.Signature);\n-                    if (sa != null)\n-                        scan(sa.getParsedSignature().getType(constant_pool));\n-\n-                    scan((RuntimeVisibleAnnotations_attribute)\n-                            attrs.get(Attribute.RuntimeVisibleAnnotations));\n-                    scan((RuntimeVisibleParameterAnnotations_attribute)\n-                            attrs.get(Attribute.RuntimeVisibleParameterAnnotations));\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            private void scan(RuntimeAnnotations_attribute attr) throws ConstantPoolException {\n-                if (attr == null) {\n-                    return;\n-                }\n-                for (int i = 0; i < attr.annotations.length; i++) {\n-                    int index = attr.annotations[i].type_index;\n-                    scan(new Signature(index).getType(constant_pool));\n-                }\n-            }\n-\n-            private void scan(RuntimeParameterAnnotations_attribute attr) throws ConstantPoolException {\n-                if (attr == null) {\n-                    return;\n-                }\n-                for (int param = 0; param < attr.parameter_annotations.length; param++) {\n-                    for (int i = 0; i < attr.parameter_annotations[param].length; i++) {\n-                        int index = attr.parameter_annotations[param][i].type_index;\n-                        scan(new Signature(index).getType(constant_pool));\n-                    }\n-                }\n-            }\n-\n-            void addClass(int index) throws ConstantPoolException {\n-                if (index != 0) {\n-                    String name = constant_pool.getClassInfo(index).getBaseName();\n-                    if (name != null)\n-                        addDependency(name);\n-                }\n-            }\n-\n-            void addClasses(int[] indices) throws ConstantPoolException {\n-                for (int i: indices)\n-                    addClass(i);\n-            }\n-\n-            private void addDependency(String name) {\n-                deps.add(new SimpleDependency(origin, getLocation(name)));\n-            }\n-\n-            \/\/ ConstantPool.Visitor methods\n-\n-            public Void visitClass(CONSTANT_Class_info info, Void p) {\n-                try {\n-                    if (info.getName().startsWith(\"[\"))\n-                        new Signature(info.name_index).getType(constant_pool).accept(this, null);\n-                    else\n-                        addDependency(info.getBaseName());\n-                    return null;\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            public Void visitDouble(CONSTANT_Double_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitFieldref(CONSTANT_Fieldref_info info, Void p) {\n-                return visitRef(info, p);\n-            }\n-\n-            public Void visitFloat(CONSTANT_Float_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitInteger(CONSTANT_Integer_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info info, Void p) {\n-                return visitRef(info, p);\n-            }\n-\n-            public Void visitInvokeDynamic(CONSTANT_InvokeDynamic_info info, Void p) {\n-                return null;\n-            }\n-\n-            @Override\n-            public Void visitDynamicConstant(CONSTANT_Dynamic_info info, Void aVoid) {\n-                return null;\n-            }\n-\n-            public Void visitLong(CONSTANT_Long_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitMethodHandle(CONSTANT_MethodHandle_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitMethodType(CONSTANT_MethodType_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitMethodref(CONSTANT_Methodref_info info, Void p) {\n-                return visitRef(info, p);\n-            }\n-\n-            public Void visitModule(CONSTANT_Module_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitNameAndType(CONSTANT_NameAndType_info info, Void p) {\n-                try {\n-                    new Signature(info.type_index).getType(constant_pool).accept(this, null);\n-                    return null;\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            public Void visitPackage(CONSTANT_Package_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitString(CONSTANT_String_info info, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitUtf8(CONSTANT_Utf8_info info, Void p) {\n-                return null;\n-            }\n-\n-            private Void visitRef(CPRefInfo info, Void p) {\n-                try {\n-                    visitClass(info.getClassInfo(), p);\n-                    return null;\n-                } catch (ConstantPoolException e) {\n-                    throw new ClassFileError(e);\n-                }\n-            }\n-\n-            \/\/ Type.Visitor methods\n-\n-            private void findDependencies(Type t) {\n-                if (t != null)\n-                    t.accept(this, null);\n-            }\n-\n-            private void findDependencies(List<? extends Type> ts) {\n-                if (ts != null) {\n-                    for (Type t: ts)\n-                        t.accept(this, null);\n-                }\n-            }\n-\n-            public Void visitSimpleType(SimpleType type, Void p) {\n-                return null;\n-            }\n-\n-            public Void visitArrayType(ArrayType type, Void p) {\n-                findDependencies(type.elemType);\n-                return null;\n-            }\n-\n-            public Void visitMethodType(MethodType type, Void p) {\n-                findDependencies(type.paramTypes);\n-                findDependencies(type.returnType);\n-                findDependencies(type.throwsTypes);\n-                findDependencies(type.typeParamTypes);\n-                return null;\n-            }\n-\n-            public Void visitClassSigType(ClassSigType type, Void p) {\n-                findDependencies(type.superclassType);\n-                findDependencies(type.superinterfaceTypes);\n-                return null;\n-            }\n-\n-            public Void visitClassType(ClassType type, Void p) {\n-                findDependencies(type.outerType);\n-                addDependency(type.getBinaryName());\n-                findDependencies(type.typeArgs);\n-                return null;\n-            }\n-\n-            public Void visitTypeParamType(TypeParamType type, Void p) {\n-                findDependencies(type.classBound);\n-                findDependencies(type.interfaceBounds);\n-                return null;\n-            }\n-\n-            public Void visitWildcardType(WildcardType type, Void p) {\n-                findDependencies(type.boundType);\n-                return null;\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Dependencies.java","additions":0,"deletions":804,"binary":false,"changes":804,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.constantpool.*;\n@@ -33,5 +35,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool;\n-\n-import static com.sun.tools.classfile.ConstantPool.CPInfo;\n-\n@@ -48,4 +45,4 @@\n-    final List<ConstantPool.CONSTANT_Class_info> classes = new ArrayList<>();\n-    final List<ConstantPool.CONSTANT_Fieldref_info> fieldRefs = new ArrayList<>();\n-    final List<ConstantPool.CONSTANT_Methodref_info> methodRefs = new ArrayList<>();\n-    final List<ConstantPool.CONSTANT_InterfaceMethodref_info> intfMethodRefs = new ArrayList<>();\n+    final List<ClassEntry> classes = new ArrayList<>();\n+    final List<FieldRefEntry> fieldRefs = new ArrayList<>();\n+    final List<MethodRefEntry> methodRefs = new ArrayList<>();\n+    final List<InterfaceMethodRefEntry> intfMethodRefs = new ArrayList<>();\n@@ -53,1 +50,1 @@\n-    public static CPEntries loadFrom(ClassFile cf) {\n+    public static CPEntries loadFrom(ClassModel cf) {\n@@ -55,2 +52,8 @@\n-        for (CPInfo cpi : cf.constant_pool.entries()) {\n-            cpi.accept(new CPSelector(), entries);\n+        for (PoolEntry cpi : cf.constantPool()) {\n+            switch (cpi) {\n+                case ClassEntry ce -> entries.classes.add(ce);\n+                case MethodRefEntry mref -> entries.methodRefs.add(mref);\n+                case InterfaceMethodRefEntry imref -> entries.intfMethodRefs.add(imref);\n+                case FieldRefEntry fref -> entries.fieldRefs.add(fref);\n+                default -> {}\n+            }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/CPEntries.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.jdeprscan.scan;\n-\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Dynamic_info;\n-\n-\/**\n- * A visitor that selects constant pool entries by type and adds\n- * them to the given CPEntries object.\n- *\/\n-class CPSelector implements ConstantPool.Visitor<Void,CPEntries> {\n-    @Override\n-    public Void visitClass(ConstantPool.CONSTANT_Class_info info, CPEntries p) {\n-        p.classes.add(info);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitDouble(ConstantPool.CONSTANT_Double_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitFieldref(ConstantPool.CONSTANT_Fieldref_info info, CPEntries p) {\n-        p.fieldRefs.add(info);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitFloat(ConstantPool.CONSTANT_Float_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitInteger(ConstantPool.CONSTANT_Integer_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitInterfaceMethodref(ConstantPool.CONSTANT_InterfaceMethodref_info info, CPEntries p) {\n-        p.intfMethodRefs.add(info);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitInvokeDynamic(ConstantPool.CONSTANT_InvokeDynamic_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    public Void visitDynamicConstant(CONSTANT_Dynamic_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitLong(ConstantPool.CONSTANT_Long_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitMethodref(ConstantPool.CONSTANT_Methodref_info info, CPEntries p) {\n-        p.methodRefs.add(info);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitMethodHandle(ConstantPool.CONSTANT_MethodHandle_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitMethodType(ConstantPool.CONSTANT_MethodType_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitModule(ConstantPool.CONSTANT_Module_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitNameAndType(ConstantPool.CONSTANT_NameAndType_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitPackage(ConstantPool.CONSTANT_Package_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitString(ConstantPool.CONSTANT_String_info info, CPEntries p) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitUtf8(ConstantPool.CONSTANT_Utf8_info info, CPEntries p) {\n-        return null;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/CPSelector.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-\n@@ -32,0 +29,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n@@ -95,1 +94,1 @@\n-    public ClassFile find(String className) {\n+    public ClassModel find(String className) {\n@@ -97,1 +96,1 @@\n-            ClassFile cf = pe.find(className);\n+            ClassModel cf = pe.find(className);\n@@ -116,1 +115,1 @@\n-        ClassFile find(String className);\n+        ClassModel find(String className);\n@@ -130,1 +129,1 @@\n-        public ClassFile find(String className) {\n+        public ClassModel find(String className) {\n@@ -136,2 +135,2 @@\n-                return ClassFile.read(jarFile.getInputStream(entry));\n-            } catch (IOException | ConstantPoolException ex) {\n+                return ClassFile.of().parse(jarFile.getInputStream(entry).readAllBytes());\n+            } catch (IOException | IllegalArgumentException ex) {\n@@ -157,1 +156,1 @@\n-        public ClassFile find(String className) {\n+        public ClassModel find(String className) {\n@@ -160,1 +159,1 @@\n-                return ClassFile.read(classFileName);\n+                return ClassFile.of().parse(classFileName);\n@@ -163,1 +162,1 @@\n-            } catch (IOException | ConstantPoolException ex) {\n+            } catch (IOException | IllegalArgumentException ex) {\n@@ -184,1 +183,1 @@\n-        public ClassFile find(String className) {\n+        public ClassModel find(String className) {\n@@ -197,1 +196,1 @@\n-                    return ClassFile.read(opath.get());\n+                    return ClassFile.of().parse(opath.get());\n@@ -203,1 +202,1 @@\n-            } catch (IOException | ConstantPoolException ex) {\n+            } catch (IOException | IllegalArgumentException ex) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/ClassFinder.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.jdeprscan.scan;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-\/**\n- * Represents a method's signature, that is, its parameter types\n- * and its return type.\n- *\/\n-public class MethodSig {\n-    final List<String> parameters;\n-    final String returnType;\n-\n-    \/**\n-     * Parses the method descriptor and returns a MethodSig instance.\n-     *\n-     * @param desc the descriptor to parse\n-     * @return the new MethodSig instance\n-     *\/\n-    public static MethodSig fromDesc(String desc) {\n-        return parse(desc, 0, desc.length());\n-    }\n-\n-    \/**\n-     * Returns this method's return type.\n-     *\n-     * @return the return type\n-     *\/\n-    public String getReturnType() {\n-        return returnType;\n-    }\n-\n-    \/**\n-     * Returns a list of parameters of this method.\n-     *\n-     * @return the parameter list\n-     *\/\n-    public List<String> getParameters() {\n-        return parameters;\n-    }\n-\n-    \/**\n-     * Returns a string describing this method.\n-     *\n-     * @return the string description\n-     *\/\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"parameters\");\n-        if (parameters.isEmpty()) {\n-            sb.append(\" none\");\n-        } else {\n-            int i = 0;\n-            for (String p : parameters) {\n-                sb.append(String.format(\" %d=%s\", i++, p));\n-            }\n-        }\n-        sb.append(String.format(\" return %s\", returnType));\n-        return sb.toString();\n-    }\n-\n-    private MethodSig(List<String> parameters, String returnType) {\n-        this.parameters = Collections.unmodifiableList(parameters);\n-        this.returnType = returnType;\n-    }\n-\n-    private static IllegalArgumentException ex(String desc, int pos) {\n-        return new IllegalArgumentException(String.format(\n-            \"illegal descriptor \\\"%s\\\" at position %d\", desc, pos));\n-    }\n-\n-    private static MethodSig parse(String desc, int start, int end)\n-            throws IllegalArgumentException {\n-        int p = start;\n-        int dims = 0;\n-        boolean inReturnType = false;\n-        String returnType = null;\n-        List<String> parameters = new ArrayList<>();\n-\n-        while (p < end) {\n-            String type;\n-            char ch;\n-            switch (ch = desc.charAt(p)) {\n-                case '(':\n-                    p++;\n-                    continue;\n-\n-                case ')':\n-                    p++;\n-                    inReturnType = true;\n-                    continue;\n-\n-                case '[':\n-                    p++;\n-                    dims++;\n-                    continue;\n-\n-                case 'B': \/\/ byte\n-                case 'C': \/\/ char\n-                case 'D': \/\/ double\n-                case 'F': \/\/ float\n-                case 'I': \/\/ int\n-                case 'J': \/\/ long\n-                case 'S': \/\/ short\n-                case 'Z': \/\/ boolean\n-                case 'V': \/\/ void\n-                    type = Character.toString(ch);\n-                    p++;\n-                    break;\n-\n-                case 'L':\n-                    int sep = desc.indexOf(';', p);\n-                    if (sep == -1 || sep >= end)\n-                        throw ex(desc, p);\n-                    type = desc.substring(p, ++sep);\n-                    p = sep;\n-                    break;\n-\n-                default:\n-                    throw ex(desc, p);\n-            }\n-\n-            StringBuilder sb = new StringBuilder();\n-            for ( ; dims > 0; dims-- )\n-                sb.append(\"[\");\n-            sb.append(type);\n-            if (inReturnType) {\n-                returnType = sb.toString();\n-            } else {\n-                parameters.add(sb.toString());\n-            }\n-        }\n-\n-        if (returnType == null) {\n-            throw ex(desc, end);\n-        }\n-\n-        return new MethodSig(parameters, returnType);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/MethodSig.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,7 @@\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.constantpool.FieldRefEntry;\n+import java.lang.classfile.constantpool.NameAndTypeEntry;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -44,1 +51,0 @@\n-import java.util.stream.Collectors;\n@@ -47,1 +53,0 @@\n-import com.sun.tools.classfile.*;\n@@ -52,3 +57,0 @@\n-import static com.sun.tools.classfile.AccessFlags.*;\n-import static com.sun.tools.classfile.ConstantPool.*;\n-\n@@ -88,1 +90,1 @@\n-        \/\/ manager; and b) the symbol file includes .sig files, not class files, which ClassFile\n+        \/\/ manager; and b) the symbol file includes .sig files, not class files, which ClassModel\n@@ -167,3 +169,3 @@\n-    String typeKind(ClassFile cf) {\n-        AccessFlags flags = cf.access_flags;\n-        if (flags.is(ACC_ENUM)) {\n+    String typeKind(ClassModel cf) {\n+        AccessFlags flags = cf.flags();\n+        if (flags.has(AccessFlag.ENUM)) {\n@@ -171,1 +173,1 @@\n-        } else if (flags.is(ACC_ANNOTATION)) {\n+        } else if (flags.has(AccessFlag.ANNOTATION)) {\n@@ -173,1 +175,1 @@\n-        } else if (flags.is(ACC_INTERFACE)) {\n+        } else if (flags.has(AccessFlag.INTERFACE)) {\n@@ -184,3 +186,2 @@\n-    void printType(String key, ClassFile cf, String cname, boolean r)\n-            throws ConstantPoolException {\n-        out.println(Messages.get(key, typeKind(cf), cf.getName(), cname, dep(r)));\n+    void printType(String key, ClassModel cf, String cname, boolean r) {\n+        out.println(Messages.get(key, typeKind(cf), cf.thisClass().asInternalName(), cname, dep(r)));\n@@ -189,3 +190,3 @@\n-    void printMethod(String key, ClassFile cf, String cname, String mname, String rtype,\n-                     boolean r) throws ConstantPoolException {\n-        out.println(Messages.get(key, typeKind(cf), cf.getName(), cname, mname, rtype, dep(r)));\n+    void printMethod(String key, ClassModel cf, String cname, String mname, String rtype,\n+                     boolean r)  {\n+        out.println(Messages.get(key, typeKind(cf), cf.thisClass().asInternalName(), cname, mname, rtype, dep(r)));\n@@ -194,3 +195,3 @@\n-    void printField(String key, ClassFile cf, String cname, String fname,\n-                     boolean r) throws ConstantPoolException {\n-        out.println(Messages.get(key, typeKind(cf), cf.getName(), cname, fname, dep(r)));\n+    void printField(String key, ClassModel cf, String cname, String fname,\n+                     boolean r)  {\n+        out.println(Messages.get(key, typeKind(cf), cf.thisClass().asInternalName(), cname, fname, dep(r)));\n@@ -199,3 +200,3 @@\n-    void printFieldType(String key, ClassFile cf, String cname, String fname, String type,\n-                     boolean r) throws ConstantPoolException {\n-        out.println(Messages.get(key, typeKind(cf), cf.getName(), cname, fname, type, dep(r)));\n+    void printFieldType(String key, ClassModel cf, String cname, String fname, String type,\n+                     boolean r)  {\n+        out.println(Messages.get(key, typeKind(cf), cf.thisClass().asInternalName(), cname, fname, type, dep(r)));\n@@ -204,3 +205,3 @@\n-    void printHasField(ClassFile cf, String fname, String type, boolean r)\n-            throws ConstantPoolException {\n-        out.println(Messages.get(\"scan.out.hasfield\", typeKind(cf), cf.getName(), fname, type, dep(r)));\n+    void printHasField(ClassModel cf, String fname, String type, boolean r)\n+             {\n+        out.println(Messages.get(\"scan.out.hasfield\", typeKind(cf), cf.thisClass().asInternalName(), fname, type, dep(r)));\n@@ -209,3 +210,3 @@\n-    void printHasMethodParmType(ClassFile cf, String mname, String parmType, boolean r)\n-            throws ConstantPoolException {\n-        out.println(Messages.get(\"scan.out.methodparmtype\", typeKind(cf), cf.getName(), mname, parmType, dep(r)));\n+    void printHasMethodParmType(ClassModel cf, String mname, String parmType, boolean r)\n+             {\n+        out.println(Messages.get(\"scan.out.methodparmtype\", typeKind(cf), cf.thisClass().asInternalName(), mname, parmType, dep(r)));\n@@ -214,3 +215,3 @@\n-    void printHasMethodRetType(ClassFile cf, String mname, String retType, boolean r)\n-            throws ConstantPoolException {\n-        out.println(Messages.get(\"scan.out.methodrettype\", typeKind(cf), cf.getName(), mname, retType, dep(r)));\n+    void printHasMethodRetType(ClassModel cf, String mname, String retType, boolean r)\n+             {\n+        out.println(Messages.get(\"scan.out.methodrettype\", typeKind(cf), cf.thisClass().asInternalName(), mname, retType, dep(r)));\n@@ -219,3 +220,3 @@\n-    void printHasOverriddenMethod(ClassFile cf, String overridden, String mname, String desc, boolean r)\n-            throws ConstantPoolException {\n-        out.println(Messages.get(\"scan.out.methodoverride\", typeKind(cf), cf.getName(), overridden,\n+    void printHasOverriddenMethod(ClassModel cf, String overridden, String mname, String desc, boolean r)\n+             {\n+        out.println(Messages.get(\"scan.out.methodoverride\", typeKind(cf), cf.thisClass().asInternalName(), overridden,\n@@ -256,1 +257,1 @@\n-     * @param targetClass the ClassFile of the class to search\n+     * @param targetClass the ClassModel of the class to search\n@@ -261,1 +262,1 @@\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @ if a constant pool entry cannot be found\n@@ -263,1 +264,1 @@\n-    boolean isMemberPresent(ClassFile targetClass,\n+    boolean isMemberPresent(ClassModel targetClass,\n@@ -267,1 +268,1 @@\n-            throws ConstantPoolException {\n+             {\n@@ -269,3 +270,3 @@\n-            for (Method m : targetClass.methods) {\n-                String mname = m.getName(targetClass.constant_pool);\n-                String mdesc = targetClass.constant_pool.getUTF8Value(m.descriptor.index);\n+            for (var m : targetClass.methods()) {\n+                String mname = m.methodName().stringValue();\n+                String mdesc = m.methodType().stringValue();\n@@ -277,2 +278,2 @@\n-            for (Field f : targetClass.fields) {\n-                String fname = f.getName(targetClass.constant_pool);\n+            for (var f : targetClass.fields()) {\n+                String fname = f.fieldName().stringValue();\n@@ -291,2 +292,2 @@\n-     * @param cf the ClassFile of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of this class\n+     * @ if a constant pool entry cannot be found\n@@ -294,5 +295,3 @@\n-    void addInterfaces(Deque<String> intfs, ClassFile cf)\n-            throws ConstantPoolException {\n-        int count = cf.interfaces.length;\n-        for (int i = 0; i < count; i++) {\n-            intfs.addLast(cf.getInterfaceName(i));\n+    void addInterfaces(Deque<String> intfs, ClassModel cf) {\n+        for (var itf : cf.interfaces()) {\n+            intfs.addLast(itf.asInternalName());\n@@ -310,1 +309,1 @@\n-     * @param cf the ClassFile of this class\n+     * @param cf the ClassModel of this class\n@@ -318,1 +317,1 @@\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @ if a constant pool entry cannot be found\n@@ -321,1 +320,1 @@\n-            ClassFile cf, String startClassName, String findName, String findDesc,\n+            ClassModel cf, String startClassName, String findName, String findDesc,\n@@ -323,2 +322,2 @@\n-            throws ConstantPoolException {\n-        ClassFile startClass;\n+             {\n+        ClassModel startClass;\n@@ -326,1 +325,1 @@\n-        if (cf.getName().equals(startClassName)) {\n+        if (cf.thisClass().asInternalName().equals(startClassName)) {\n@@ -339,1 +338,1 @@\n-        ClassFile curClass = startClass;\n+        ClassModel curClass = startClass;\n@@ -347,1 +346,2 @@\n-            if (curClass.super_class == 0) { \/\/ reached Object\n+            var superclass = curClass.superclass();\n+            if (superclass.isEmpty()) { \/\/ reached Object\n@@ -352,1 +352,1 @@\n-            String superName = curClass.getSuperclassName();\n+            String superName = superclass.get().asInternalName();\n@@ -394,1 +394,1 @@\n-            String foundClassName = curClass.getName();\n+            String foundClassName = curClass.thisClass().asInternalName();\n@@ -402,2 +402,2 @@\n-     * @param cf the ClassFile of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of this class\n+     * @ if a constant pool entry cannot be found\n@@ -405,2 +405,6 @@\n-    void checkSuper(ClassFile cf) throws ConstantPoolException {\n-        String sname = cf.getSuperclassName();\n+    void checkSuper(ClassModel cf)  {\n+        var superclass = cf.superclass();\n+        if (superclass.isEmpty()) {\n+            return;\n+        }\n+        String sname = superclass.get().asInternalName();\n@@ -416,2 +420,2 @@\n-     * @param cf the ClassFile of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of this class\n+     * @ if a constant pool entry cannot be found\n@@ -419,4 +423,3 @@\n-    void checkInterfaces(ClassFile cf) throws ConstantPoolException {\n-        int ni = cf.interfaces.length;\n-        for (int i = 0; i < ni; i++) {\n-            String iname = cf.getInterfaceName(i);\n+    void checkInterfaces(ClassModel cf)  {\n+        for (var itf : cf.interfaces()) {\n+            String iname = itf.asInternalName();\n@@ -433,1 +436,1 @@\n-     * @param cf the ClassFile of this class\n+     * @param cf the ClassModel of this class\n@@ -435,1 +438,1 @@\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @ if a constant pool entry cannot be found\n@@ -437,3 +440,3 @@\n-    void checkClasses(ClassFile cf, CPEntries entries) throws ConstantPoolException {\n-        for (ConstantPool.CONSTANT_Class_info ci : entries.classes) {\n-            String name = nameFromRefType(ci.getName());\n+    void checkClasses(ClassModel cf, CPEntries entries)  {\n+        for (var ci : entries.classes) {\n+            String name = nameFromRefType(ci.asInternalName());\n@@ -452,1 +455,1 @@\n-     * @param cf the ClassFile of this class\n+     * @param cf the ClassModel of this class\n@@ -456,1 +459,1 @@\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @ if a constant pool entry cannot be found\n@@ -458,1 +461,1 @@\n-    void checkMethodRef(ClassFile cf,\n+    void checkMethodRef(ClassModel cf,\n@@ -460,4 +463,4 @@\n-                        CONSTANT_NameAndType_info nti,\n-                        String msgKey) throws ConstantPoolException {\n-        String name = nti.getName();\n-        String type = nti.getType();\n+                        NameAndTypeEntry nti,\n+                        String msgKey)  {\n+        String name = nti.name().stringValue();\n+        String type = nti.type().stringValue();\n@@ -477,2 +480,2 @@\n-     * @param cf the ClassFile of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of this class\n+     * @ if a constant pool entry cannot be found\n@@ -480,6 +483,6 @@\n-    void checkFieldRef(ClassFile cf,\n-                       ConstantPool.CONSTANT_Fieldref_info fri) throws ConstantPoolException {\n-        String clname = nameFromRefType(fri.getClassName());\n-        CONSTANT_NameAndType_info nti = fri.getNameAndTypeInfo();\n-        String name = nti.getName();\n-        String type = nti.getType();\n+    void checkFieldRef(ClassModel cf,\n+                       FieldRefEntry fri)  {\n+        String clname = nameFromRefType(fri.owner().asInternalName());\n+        var nti = fri.nameAndType();\n+        String name = nti.name().stringValue();\n+        String type = nti.type().stringValue();\n@@ -499,2 +502,2 @@\n-     * @param cf the ClassFile of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of this class\n+     * @ if a constant pool entry cannot be found\n@@ -502,3 +505,3 @@\n-    void checkFields(ClassFile cf) throws ConstantPoolException {\n-        for (Field f : cf.fields) {\n-            String type = nameFromDescType(cf.constant_pool.getUTF8Value(f.descriptor.index));\n+    void checkFields(ClassModel cf)  {\n+        for (var f : cf.fields()) {\n+            String type = nameFromDescType(f.fieldType().stringValue());\n@@ -508,1 +511,1 @@\n-                    printHasField(cf, f.getName(cf.constant_pool), type, dd.isForRemoval());\n+                    printHasField(cf, f.fieldName().stringValue(), type, dd.isForRemoval());\n@@ -517,2 +520,2 @@\n-     * @param cf the ClassFile object of this class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel object of this class\n+     * @ if a constant pool entry cannot be found\n@@ -520,5 +523,5 @@\n-    void checkMethods(ClassFile cf) throws ConstantPoolException {\n-        for (Method m : cf.methods) {\n-            String mname = m.getName(cf.constant_pool);\n-            String desc = cf.constant_pool.getUTF8Value(m.descriptor.index);\n-            MethodSig sig = MethodSig.fromDesc(desc);\n+    void checkMethods(ClassModel cf)  {\n+        for (var m : cf.methods()) {\n+            String mname = m.methodName().stringValue();\n+            var desc = m.methodType().stringValue();\n+            MethodTypeDesc sig = m.methodTypeSymbol();\n@@ -527,1 +530,2 @@\n-            for (String parm : sig.getParameters()) {\n+            for (var parmDesc : sig.parameterArray()) {\n+                var parm = parmDesc.descriptorString();\n@@ -537,1 +541,1 @@\n-            String ret = nameFromDescType(sig.getReturnType());\n+            String ret = nameFromDescType(sig.returnType().descriptorString());\n@@ -546,1 +550,1 @@\n-            String overridden = resolveMember(cf, cf.getName(), mname, desc, true, false);\n+            String overridden = resolveMember(cf, cf.thisClass().asInternalName(), mname, desc, true, false);\n@@ -559,2 +563,2 @@\n-     * @param cf the ClassFile of the class\n-     * @throws ConstantPoolException if a constant pool entry cannot be found\n+     * @param cf the ClassModel of the class\n+     * @ if a constant pool entry cannot be found\n@@ -562,1 +566,1 @@\n-    void processClass(ClassFile cf) throws ConstantPoolException {\n+    void processClass(ClassModel cf)  {\n@@ -564,1 +568,1 @@\n-            out.println(Messages.get(\"scan.process.class\", cf.getName()));\n+            out.println(Messages.get(\"scan.process.class\", cf.thisClass().asInternalName()));\n@@ -573,3 +577,3 @@\n-        for (ConstantPool.CONSTANT_Methodref_info mri : entries.methodRefs) {\n-            String clname = mri.getClassName();\n-            CONSTANT_NameAndType_info nti = mri.getNameAndTypeInfo();\n+        for (var mri : entries.methodRefs) {\n+            String clname = mri.owner().asInternalName();\n+            var nti = mri.nameAndType();\n@@ -579,3 +583,3 @@\n-        for (ConstantPool.CONSTANT_InterfaceMethodref_info imri : entries.intfMethodRefs) {\n-            String clname = imri.getClassName();\n-            CONSTANT_NameAndType_info nti = imri.getNameAndTypeInfo();\n+        for (var imri : entries.intfMethodRefs) {\n+            String clname = imri.owner().asInternalName();\n+            var nti = imri.nameAndType();\n@@ -585,1 +589,1 @@\n-        for (ConstantPool.CONSTANT_Fieldref_info fri : entries.fieldRefs) {\n+        for (var fri : entries.fieldRefs) {\n@@ -610,1 +614,2 @@\n-                    processClass(ClassFile.read(jf.getInputStream(entry)));\n+                    processClass(ClassFile.of().parse(jf\n+                            .getInputStream(entry).readAllBytes()));\n@@ -616,1 +621,1 @@\n-        } catch (IOException | ConstantPoolException ex) {\n+        } catch (IOException | IllegalArgumentException ex) {\n@@ -643,1 +648,1 @@\n-                processClass(ClassFile.read(p));\n+                processClass(ClassFile.of().parse(p));\n@@ -646,1 +651,1 @@\n-        } catch (IOException | ConstantPoolException ex) {\n+        } catch (IOException | IllegalArgumentException ex) {\n@@ -660,1 +665,1 @@\n-            ClassFile cf = finder.find(className);\n+            ClassModel cf = finder.find(className);\n@@ -668,1 +673,1 @@\n-        } catch (ConstantPoolException ex) {\n+        } catch (IllegalArgumentException ex) {\n@@ -683,1 +688,1 @@\n-            ClassFile cf = ClassFile.read(path);\n+            ClassModel cf = ClassFile.of().parse(path);\n@@ -688,1 +693,1 @@\n-        } catch (IOException | ConstantPoolException ex) {\n+        } catch (IOException | IllegalArgumentException ex) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/scan\/Scan.java","additions":132,"deletions":127,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependency.Location;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Analyzer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependency.Location;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Archive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,1 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Dependencies.ClassFileError;\n+import com.sun.tools.jdeps.Dependencies.ClassFileError;\n@@ -39,0 +36,2 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n@@ -45,1 +44,0 @@\n-import java.util.Enumeration;\n@@ -57,1 +55,1 @@\n- * ClassFileReader reads ClassFile(s) of a given path that can be\n+ * ClassFileReader reads ClassModel(s) of a given path that can be\n@@ -120,1 +118,1 @@\n-     * Returns the ClassFile matching the given binary name\n+     * Returns the ClassModel matching the given binary name\n@@ -123,1 +121,1 @@\n-    public ClassFile getClassFile(String name) throws IOException {\n+    public ClassModel getClassFile(String name) throws IOException {\n@@ -140,1 +138,1 @@\n-    public Iterable<ClassFile> getClassFiles() throws IOException {\n+    public Iterable<ClassModel> getClassFiles() throws IOException {\n@@ -144,2 +142,1 @@\n-    protected ClassFile readClassFile(Path p) throws IOException {\n-        InputStream is = null;\n+    protected ClassModel readClassFile(Path p) throws IOException {\n@@ -147,3 +144,2 @@\n-            is = Files.newInputStream(p);\n-            return ClassFile.read(is);\n-        } catch (ConstantPoolException e) {\n+            return ClassFile.of().parse(p);\n+        } catch (IllegalArgumentException e) {\n@@ -151,4 +147,0 @@\n-        } finally {\n-            if (is != null) {\n-                is.close();\n-            }\n@@ -160,3 +152,3 @@\n-            ClassFile cf = ClassFile.read(path);\n-            String name = cf.access_flags.is(AccessFlags.ACC_MODULE)\n-                ? \"module-info\" : cf.getName();\n+            ClassModel cf = ClassFile.of().parse(path);\n+            String name = cf.isModuleInfo()\n+                ? \"module-info\" : cf.thisClass().asInternalName();\n@@ -164,1 +156,1 @@\n-        } catch (ConstantPoolException|IOException e) {\n+        } catch (IllegalArgumentException|IOException e) {\n@@ -178,1 +170,1 @@\n-    class FileIterator implements Iterator<ClassFile> {\n+    class FileIterator implements Iterator<ClassModel> {\n@@ -187,1 +179,1 @@\n-        public ClassFile next() {\n+        public ClassModel next() {\n@@ -192,1 +184,1 @@\n-                ClassFile cf = readClassFile(path);\n+                ClassModel cf = readClassFile(path);\n@@ -231,1 +223,1 @@\n-        public ClassFile getClassFile(String name) throws IOException {\n+        public ClassModel getClassFile(String name) throws IOException {\n@@ -252,2 +244,2 @@\n-        public Iterable<ClassFile> getClassFiles() throws IOException {\n-            final Iterator<ClassFile> iter = new DirectoryIterator();\n+        public Iterable<ClassModel> getClassFiles() throws IOException {\n+            final Iterator<ClassModel> iter = new DirectoryIterator();\n@@ -257,1 +249,1 @@\n-        class DirectoryIterator implements Iterator<ClassFile> {\n+        class DirectoryIterator implements Iterator<ClassModel> {\n@@ -274,1 +266,1 @@\n-            public ClassFile next() {\n+            public ClassModel next() {\n@@ -335,1 +327,1 @@\n-        public ClassFile getClassFile(String name) throws IOException {\n+        public ClassModel getClassFile(String name) throws IOException {\n@@ -356,1 +348,1 @@\n-        protected ClassFile readClassFile(JarFile jarfile, JarEntry e) throws IOException {\n+        protected ClassModel readClassFile(JarFile jarfile, JarEntry e) throws IOException {\n@@ -358,1 +350,1 @@\n-                ClassFile cf = ClassFile.read(is);\n+                ClassModel cf = ClassFile.of().parse(is.readAllBytes());\n@@ -360,1 +352,1 @@\n-                if (jarfile.isMultiRelease() && !cf.getName().equals(\"module-info\")) {\n+                if (jarfile.isMultiRelease() && !cf.isModuleInfo()) {\n@@ -364,1 +356,1 @@\n-            } catch (ConstantPoolException ex) {\n+            } catch (IllegalArgumentException ex) {\n@@ -369,2 +361,2 @@\n-        public Iterable<ClassFile> getClassFiles() throws IOException {\n-            final Iterator<ClassFile> iter = new JarFileIterator(this, jarfile);\n+        public Iterable<ClassModel> getClassFiles() throws IOException {\n+            final Iterator<ClassModel> iter = new JarFileIterator(this, jarfile);\n@@ -375,1 +367,1 @@\n-    class JarFileIterator implements Iterator<ClassFile> {\n+    class JarFileIterator implements Iterator<ClassModel> {\n@@ -380,1 +372,1 @@\n-        protected ClassFile cf;\n+        protected ClassModel cf;\n@@ -416,1 +408,1 @@\n-        public ClassFile next() {\n+        public ClassModel next() {\n@@ -420,1 +412,1 @@\n-            ClassFile classFile = cf;\n+            ClassModel classFile = cf;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/ClassFileReader.java","additions":34,"deletions":42,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,709 @@\n+\/*\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.jdeps;\n+\n+import java.lang.classfile.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.regex.Pattern;\n+\n+import com.sun.tools.jdeps.Dependency.Filter;\n+import com.sun.tools.jdeps.Dependency.Finder;\n+import com.sun.tools.jdeps.Dependency.Location;\n+\n+\/**\n+ * A framework for determining {@link Dependency dependencies} between class files.\n+ *\n+ * A {@link Dependency.Finder finder} is used to identify the dependencies of\n+ * individual classes. Some finders may return subtypes of {@code Dependency} to\n+ * further characterize the type of dependency, such as a dependency on a\n+ * method within a class.\n+ *\n+ * A {@link Dependency.Filter filter} may be used to restrict the set of\n+ * dependencies found by a finder.\n+ *\n+ * Dependencies that are found may be passed to a {@link Dependencies.Recorder\n+ * recorder} so that the dependencies can be stored in a custom data structure.\n+ *\/\n+public class Dependencies {\n+    \/**\n+     * Thrown when a class file cannot be found.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    public static class ClassFileNotFoundException extends Exception {\n+        private static final long serialVersionUID = 3632265927794475048L;\n+\n+        public ClassFileNotFoundException(String className) {\n+            super(className);\n+            this.className = className;\n+        }\n+\n+        public ClassFileNotFoundException(String className, Throwable cause) {\n+            this(className);\n+            initCause(cause);\n+        }\n+\n+        public final String className;\n+    }\n+\n+    \/**\n+     * Thrown when an exception is found processing a class file.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    public static class ClassFileError extends Error {\n+        private static final long serialVersionUID = 4111110813961313203L;\n+\n+        public ClassFileError(Throwable cause) {\n+            initCause(cause);\n+        }\n+    }\n+\n+    \/**\n+     * Service provider interface to locate and read class files.\n+     *\/\n+    public interface ClassFileReader {\n+        \/**\n+         * Get the ClassFile object for a specified class.\n+         * @param className the name of the class to be returned.\n+         * @return the ClassFile for the given class\n+         * @throws Dependencies.ClassFileNotFoundException if the classfile cannot be\n+         *   found\n+         *\/\n+        public ClassModel getClassFile(String className)\n+                throws ClassFileNotFoundException;\n+    }\n+\n+    \/**\n+     * Service provide interface to handle results.\n+     *\/\n+    public interface Recorder {\n+        \/**\n+         * Record a dependency that has been found.\n+         * @param d\n+         *\/\n+        public void addDependency(Dependency d);\n+    }\n+\n+    \/**\n+     * Get the  default finder used to locate the dependencies for a class.\n+     * @return the default finder\n+     *\/\n+    public static Finder getDefaultFinder() {\n+        return new APIDependencyFinder(ClassFile.ACC_PRIVATE);\n+    }\n+\n+    \/**\n+     * Get a finder used to locate the API dependencies for a class.\n+     * These include the superclass, superinterfaces, and classes referenced in\n+     * the declarations of fields and methods.  The fields and methods that\n+     * are checked can be limited according to a specified access.\n+     * The access parameter must be one of {@link ClassFile#ACC_PUBLIC ACC_PUBLIC},\n+     * {@link ClassFile#ACC_PRIVATE ACC_PRIVATE},\n+     * {@link ClassFile#ACC_PROTECTED ACC_PROTECTED}, or 0 for\n+     * package private access. Members with greater than or equal accessibility\n+     * to that specified will be searched for dependencies.\n+     * @param access the access of members to be checked\n+     * @return an API finder\n+     *\/\n+    public static Finder getAPIFinder(int access) {\n+        return new APIDependencyFinder(access);\n+    }\n+\n+    \/**\n+     * Get a finder to do class dependency analysis.\n+     *\n+     * @return a Class dependency finder\n+     *\/\n+    public static Finder getClassDependencyFinder() {\n+        return new ClassDependencyFinder();\n+    }\n+\n+    \/**\n+     * Get the finder used to locate the dependencies for a class.\n+     * @return the finder\n+     *\/\n+    public Finder getFinder() {\n+        if (finder == null)\n+            finder = getDefaultFinder();\n+        return finder;\n+    }\n+\n+    \/**\n+     * Set the finder used to locate the dependencies for a class.\n+     * @param f the finder\n+     *\/\n+    public void setFinder(Finder f) {\n+        finder = Objects.requireNonNull(f);\n+    }\n+\n+    \/**\n+     * Get the default filter used to determine included when searching\n+     * the transitive closure of all the dependencies.\n+     * Unless overridden, the default filter accepts all dependencies.\n+     * @return the default filter.\n+     *\/\n+    public static Filter getDefaultFilter() {\n+        return DefaultFilter.instance();\n+    }\n+\n+    \/**\n+     * Get a filter which uses a regular expression on the target's class name\n+     * to determine if a dependency is of interest.\n+     * @param pattern the pattern used to match the target's class name\n+     * @return a filter for matching the target class name with a regular expression\n+     *\/\n+    public static Filter getRegexFilter(Pattern pattern) {\n+        return new TargetRegexFilter(pattern);\n+    }\n+\n+    \/**\n+     * Get a filter which checks the package of a target's class name\n+     * to determine if a dependency is of interest. The filter checks if the\n+     * package of the target's class matches any of a set of given package\n+     * names. The match may optionally match subpackages of the given names as well.\n+     * @param packageNames the package names used to match the target's class name\n+     * @param matchSubpackages whether or not to match subpackages as well\n+     * @return a filter for checking the target package name against a list of package names\n+     *\/\n+    public static Filter getPackageFilter(Set<String> packageNames, boolean matchSubpackages) {\n+        return new TargetPackageFilter(packageNames, matchSubpackages);\n+    }\n+\n+    \/**\n+     * Get the filter used to determine the dependencies included when searching\n+     * the transitive closure of all the dependencies.\n+     * Unless overridden, the default filter accepts all dependencies.\n+     * @return the filter\n+     *\/\n+    public Filter getFilter() {\n+        if (filter == null)\n+            filter = getDefaultFilter();\n+        return filter;\n+    }\n+\n+    \/**\n+     * Set the filter used to determine the dependencies included when searching\n+     * the transitive closure of all the dependencies.\n+     * @param f the filter\n+     *\/\n+    public void setFilter(Filter f) {\n+        filter = Objects.requireNonNull(f);\n+    }\n+\n+    \/**\n+     * Find the dependencies of a class, using the current\n+     * {@link Dependencies#getFinder finder} and\n+     * {@link Dependencies#getFilter filter}.\n+     * The search may optionally include the transitive closure of all the\n+     * filtered dependencies, by also searching in the classes named in those\n+     * dependencies.\n+     * @param classFinder a finder to locate class files\n+     * @param rootClassNames the names of the root classes from which to begin\n+     *      searching\n+     * @param transitiveClosure whether or not to also search those classes\n+     *      named in any filtered dependencies that are found.\n+     * @return the set of dependencies that were found\n+     * @throws ClassFileNotFoundException if a required class file cannot be found\n+     * @throws ClassFileError if an error occurs while processing a class file,\n+     *      such as an error in the internal class file structure.\n+     *\/\n+    public Set<Dependency> findAllDependencies(\n+            ClassFileReader classFinder, Set<String> rootClassNames,\n+            boolean transitiveClosure)\n+            throws ClassFileNotFoundException {\n+        final Set<Dependency> results = new HashSet<>();\n+        Recorder r = results::add;\n+        findAllDependencies(classFinder, rootClassNames, transitiveClosure, r);\n+        return results;\n+    }\n+\n+    \/**\n+     * Find the dependencies of a class, using the current\n+     * {@link Dependencies#getFinder finder} and\n+     * {@link Dependencies#getFilter filter}.\n+     * The search may optionally include the transitive closure of all the\n+     * filtered dependencies, by also searching in the classes named in those\n+     * dependencies.\n+     * @param classFinder a finder to locate class files\n+     * @param rootClassNames the names of the root classes from which to begin\n+     *      searching\n+     * @param transitiveClosure whether or not to also search those classes\n+     *      named in any filtered dependencies that are found.\n+     * @param recorder a recorder for handling the results\n+     * @throws ClassFileNotFoundException if a required class file cannot be found\n+     * @throws ClassFileError if an error occurs while processing a class file,\n+     *      such as an error in the internal class file structure.\n+     *\/\n+    public void findAllDependencies(\n+            ClassFileReader classFinder, Set<String> rootClassNames,\n+            boolean transitiveClosure, Recorder recorder)\n+            throws ClassFileNotFoundException {\n+        Set<String> doneClasses = new HashSet<>();\n+\n+        getFinder();  \/\/ ensure initialized\n+        getFilter();  \/\/ ensure initialized\n+\n+        \/\/ Work queue of names of classfiles to be searched.\n+        \/\/ Entries will be unique, and for classes that do not yet have\n+        \/\/ dependencies in the results map.\n+        Deque<String> deque = new LinkedList<>(rootClassNames);\n+\n+        String className;\n+        while ((className = deque.poll()) != null) {\n+            assert (!doneClasses.contains(className));\n+            doneClasses.add(className);\n+\n+            ClassModel cf = classFinder.getClassFile(className);\n+\n+            \/\/ The following code just applies the filter to the dependencies\n+            \/\/ followed for the transitive closure.\n+            for (Dependency d: finder.findDependencies(cf)) {\n+                recorder.addDependency(d);\n+                if (transitiveClosure && filter.accepts(d)) {\n+                    String cn = d.getTarget().getClassName();\n+                    if (!doneClasses.contains(cn))\n+                        deque.add(cn);\n+                }\n+            }\n+        }\n+    }\n+\n+    private Filter filter;\n+    private Finder finder;\n+\n+    \/**\n+     * A location identifying a class.\n+     *\/\n+    static class SimpleLocation implements Location {\n+        public SimpleLocation(String name) {\n+            this.name = name;\n+            this.className = name.replace('\/', '.');\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        public String getClassName() {\n+            return className;\n+        }\n+\n+        public String getPackageName() {\n+            int i = name.lastIndexOf('\/');\n+            return (i > 0) ? name.substring(0, i).replace('\/', '.') : \"\";\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other)\n+                return true;\n+            if (!(other instanceof SimpleLocation))\n+                return false;\n+            return (name.equals(((SimpleLocation) other).name));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return name.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n+\n+        private String name;\n+        private String className;\n+    }\n+\n+    \/**\n+     * A dependency of one class on another.\n+     *\/\n+    static class SimpleDependency implements Dependency {\n+        public SimpleDependency(Location origin, Location target) {\n+            this.origin = origin;\n+            this.target = target;\n+        }\n+\n+        public Location getOrigin() {\n+            return origin;\n+        }\n+\n+        public Location getTarget() {\n+            return target;\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other)\n+                return true;\n+            if (!(other instanceof SimpleDependency))\n+                return false;\n+            SimpleDependency o = (SimpleDependency) other;\n+            return (origin.equals(o.origin) && target.equals(o.target));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return origin.hashCode() * 31 + target.hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return origin + \":\" + target;\n+        }\n+\n+        private Location origin;\n+        private Location target;\n+    }\n+\n+\n+    \/**\n+     * This class accepts all dependencies.\n+     *\/\n+    static class DefaultFilter implements Filter {\n+        private static DefaultFilter instance;\n+\n+        static DefaultFilter instance() {\n+            if (instance == null)\n+                instance = new DefaultFilter();\n+            return instance;\n+        }\n+\n+        public boolean accepts(Dependency dependency) {\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * This class accepts those dependencies whose target's class name matches a\n+     * regular expression.\n+     *\/\n+    static class TargetRegexFilter implements Filter {\n+        TargetRegexFilter(Pattern pattern) {\n+            this.pattern = pattern;\n+        }\n+\n+        public boolean accepts(Dependency dependency) {\n+            return pattern.matcher(dependency.getTarget().getClassName()).matches();\n+        }\n+\n+        private final Pattern pattern;\n+    }\n+\n+    \/**\n+     * This class accepts those dependencies whose class name is in a given\n+     * package.\n+     *\/\n+    static class TargetPackageFilter implements Filter {\n+        TargetPackageFilter(Set<String> packageNames, boolean matchSubpackages) {\n+            for (String pn: packageNames) {\n+                if (pn.length() == 0) \/\/ implies null check as well\n+                    throw new IllegalArgumentException();\n+            }\n+            this.packageNames = packageNames;\n+            this.matchSubpackages = matchSubpackages;\n+        }\n+\n+        public boolean accepts(Dependency dependency) {\n+            String pn = dependency.getTarget().getPackageName();\n+            if (packageNames.contains(pn))\n+                return true;\n+\n+            if (matchSubpackages) {\n+                for (String n: packageNames) {\n+                    if (pn.startsWith(n + \".\"))\n+                        return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        private final Set<String> packageNames;\n+        private final boolean matchSubpackages;\n+    }\n+\n+    \/**\n+     * This class identifies class names directly or indirectly in the constant pool.\n+     *\/\n+    static class ClassDependencyFinder extends BasicDependencyFinder {\n+        public Iterable<? extends Dependency> findDependencies(ClassModel classfile) {\n+            Visitor v = new Visitor(classfile);\n+            for (var cpInfo: classfile.constantPool()) {\n+                v.scan(cpInfo);\n+            }\n+            try {\n+                classfile.superclass().ifPresent(v::addClass);\n+                v.addClasses(classfile.interfaces());\n+                v.scanAttributes(classfile);\n+\n+                for (var f : classfile.fields()) {\n+                    v.scan(f.fieldTypeSymbol());\n+                    v.scanAttributes(f);\n+                }\n+                for (var m : classfile.methods()) {\n+                    v.scan(m.methodTypeSymbol());\n+                    v.scanAttributes(m);\n+                }\n+            } catch (IllegalArgumentException e) {\n+                throw new ClassFileError(e);\n+            }\n+\n+            return v.deps;\n+        }\n+    }\n+\n+    \/**\n+     * This class identifies class names in the signatures of classes, fields,\n+     * and methods in a class.\n+     *\/\n+    static class APIDependencyFinder extends BasicDependencyFinder {\n+        APIDependencyFinder(int access) {\n+            switch (access) {\n+                case ClassFile.ACC_PUBLIC:\n+                case ClassFile.ACC_PROTECTED:\n+                case ClassFile.ACC_PRIVATE:\n+                case 0:\n+                    showAccess = access;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"invalid access 0x\"\n+                            + Integer.toHexString(access));\n+            }\n+        }\n+\n+        public Iterable<? extends Dependency> findDependencies(ClassModel classfile) {\n+            try {\n+                Visitor v = new Visitor(classfile);\n+                classfile.superclass().ifPresent(v::addClass);\n+                v.addClasses(classfile.interfaces());\n+                \/\/ inner classes?\n+                for (var f : classfile.fields()) {\n+                    if (checkAccess(f.flags())) {\n+                        v.scan(f.fieldTypeSymbol());\n+                        v.scanAttributes(f);\n+                    }\n+                }\n+                for (var m : classfile.methods()) {\n+                    if (checkAccess(m.flags())) {\n+                        v.scan(m.methodTypeSymbol());\n+                        v.scanAttributes(m);\n+                    }\n+                }\n+                return v.deps;\n+            } catch (IllegalArgumentException e) {\n+                throw new ClassFileError(e);\n+            }\n+        }\n+\n+        boolean checkAccess(AccessFlags flags) {\n+            \/\/ code copied from javap.Options.checkAccess\n+            boolean isPublic = flags.has(AccessFlag.PUBLIC);\n+            boolean isProtected = flags.has(AccessFlag.PROTECTED);\n+            boolean isPrivate = flags.has(AccessFlag.PRIVATE);\n+            boolean isPackage = !(isPublic || isProtected || isPrivate);\n+\n+            if ((showAccess == ClassFile.ACC_PUBLIC) && (isProtected || isPrivate || isPackage))\n+                return false;\n+            else if ((showAccess == ClassFile.ACC_PROTECTED) && (isPrivate || isPackage))\n+                return false;\n+            else if ((showAccess == 0) && (isPrivate))\n+                return false;\n+            else\n+                return true;\n+        }\n+\n+        private int showAccess;\n+    }\n+\n+    abstract static class BasicDependencyFinder implements Finder {\n+        private Map<String,Location> locations = new ConcurrentHashMap<>();\n+\n+        Location getLocation(String className) {\n+            return locations.computeIfAbsent(className, SimpleLocation::new);\n+        }\n+\n+        class Visitor {\n+            private final Location origin;\n+            final Set<Dependency> deps;\n+\n+            Visitor(ClassModel classFile) {\n+                try {\n+                    origin = getLocation(classFile.thisClass().asInternalName());\n+                } catch (IllegalArgumentException e) {\n+                    throw new ClassFileError(e);\n+                }\n+                deps = new HashSet<>();\n+            }\n+\n+            private void addDependency(String internalName) {\n+                deps.add(new SimpleDependency(origin, getLocation(internalName)));\n+            }\n+\n+            private void addClass(ClassEntry ce) throws IllegalArgumentException {\n+                assert ce.name().charAt(0) != '[';\n+                addDependency(ce.asInternalName());\n+            }\n+\n+            private void addClasses(Collection<? extends ClassEntry> ces) throws IllegalArgumentException {\n+                for (var i: ces)\n+                    addClass(i);\n+            }\n+\n+            private void scan(ClassDesc cd) {\n+                while (cd.isArray()) {\n+                    cd = cd.componentType();\n+                }\n+                if (cd.isClassOrInterface()) {\n+                    var desc = cd.descriptorString();\n+                    addDependency(desc.substring(1, desc.length() - 1));\n+                }\n+            }\n+\n+            private void scan(MethodTypeDesc mtd) {\n+                scan(mtd.returnType());\n+                for (int i = 0; i < mtd.parameterCount(); i++) {\n+                    scan(mtd.parameterType(i));\n+                }\n+            }\n+\n+            void scanAttributes(AttributedElement attrs) {\n+                try {\n+                    var sa = attrs.findAttribute(Attributes.SIGNATURE).orElse(null);\n+                    if (sa != null) {\n+                        switch (attrs) {\n+                            case ClassModel _ -> scan(sa.asClassSignature());\n+                            case MethodModel _ -> scan(sa.asMethodSignature());\n+                            default -> scan(sa.asTypeSignature());\n+                        }\n+                    }\n+\n+                    var rvaa = attrs.findAttribute(Attributes.RUNTIME_VISIBLE_ANNOTATIONS).orElse(null);\n+                    if (rvaa != null) {\n+                        for (var anno : rvaa.annotations()) {\n+                            scan(anno.classSymbol());\n+                        }\n+                    }\n+\n+                    var rvpaa = attrs.findAttribute(Attributes.RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS).orElse(null);\n+                    if (rvpaa != null) {\n+                        for (var parameter : rvpaa.parameterAnnotations()) {\n+                            for (var anno : parameter) {\n+                                scan(anno.classSymbol());\n+                            }\n+                        }\n+                    }\n+\n+                    var exceptions = attrs.findAttribute(Attributes.EXCEPTIONS).orElse(null);\n+                    if (exceptions != null) {\n+                        for (var e : exceptions.exceptions()) {\n+                            addClass(e);\n+                        }\n+                    }\n+                } catch (IllegalArgumentException e) {\n+                    throw new ClassFileError(e);\n+                }\n+            }\n+\n+            \/\/ ConstantPool scanning\n+\n+            void scan(PoolEntry cpInfo) {\n+                try {\n+                    switch (cpInfo) {\n+                        case ClassEntry clazz -> scan(clazz.asSymbol());\n+                        case FieldRefEntry field -> scan(field.owner().asSymbol());\n+                        case MethodRefEntry method -> scan(method.owner().asSymbol());\n+                        case InterfaceMethodRefEntry interfaceMethod -> scan(interfaceMethod.owner().asSymbol());\n+                        case NameAndTypeEntry nat -> {\n+                            var desc = nat.type();\n+                            if (desc.charAt(0) == '(') {\n+                                scan(MethodTypeDesc.ofDescriptor(desc.stringValue()));\n+                            } else {\n+                                scan(ClassDesc.ofDescriptor(desc.stringValue()));\n+                            }\n+                        }\n+                        default -> {}\n+                    }\n+                } catch (IllegalArgumentException e) {\n+                    throw new ClassFileError(e);\n+                }\n+            }\n+\n+            \/\/ Signature scanning\n+\n+            private void scan(MethodSignature sig) {\n+                for (var param : sig.typeParameters()) {\n+                    scan(param);\n+                }\n+                for (var param : sig.arguments()) {\n+                    scan(param);\n+                }\n+                scan(sig.result());\n+                for (var thrown : sig.throwableSignatures()) {\n+                    scan(thrown);\n+                }\n+            }\n+\n+            private void scan(ClassSignature sig) {\n+                for (var param : sig.typeParameters()) {\n+                    scan(param);\n+                }\n+                scan(sig.superclassSignature());\n+                for (var itf : sig.superinterfaceSignatures()) {\n+                    scan(itf);\n+                }\n+            }\n+\n+            private void scan(Signature.TypeParam param) {\n+                param.classBound().ifPresent(this::scan);\n+                for (var itf : param.interfaceBounds()) {\n+                    scan(itf);\n+                }\n+            }\n+\n+            private void scan(Signature sig) {\n+                switch (sig) {\n+                    case Signature.ClassTypeSig ct -> {\n+                        ct.outerType().ifPresent(this::scan);\n+                        scan(ct.classDesc());\n+                        for (var arg : ct.typeArgs()) {\n+                            if (arg instanceof Signature.TypeArg.Bounded bounded) {\n+                                scan(bounded.boundType());\n+                            }\n+                        }\n+                    }\n+                    case Signature.ArrayTypeSig at -> scan(at.componentSignature());\n+                    case Signature.BaseTypeSig _, Signature.TypeVarSig _ -> {}\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Dependencies.java","additions":709,"deletions":0,"binary":false,"changes":709,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package com.sun.tools.classfile;\n+package com.sun.tools.jdeps;\n@@ -29,0 +29,2 @@\n+import java.lang.classfile.ClassModel;\n+\n@@ -59,1 +61,1 @@\n-        public Iterable<? extends Dependency> findDependencies(ClassFile classfile);\n+        public Iterable<? extends Dependency> findDependencies(ClassModel classfile);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Dependency.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Dependency.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,7 +31,2 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Dependencies;\n-import com.sun.tools.classfile.Dependencies.ClassFileError;\n-import com.sun.tools.classfile.Dependency;\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependencies.ClassFileError;\n+import com.sun.tools.jdeps.Dependency.Location;\n@@ -41,1 +36,4 @@\n-import java.nio.file.Paths;\n+import java.lang.classfile.AccessFlags;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.reflect.AccessFlag;\n@@ -49,1 +47,0 @@\n-import java.util.concurrent.Callable;\n@@ -179,2 +176,2 @@\n-            for (ClassFile cf : archive.reader().getClassFiles()) {\n-                if (cf.access_flags.is(AccessFlags.ACC_MODULE))\n+            for (var cf : archive.reader().getClassFiles()) {\n+                if (cf.isModuleInfo())\n@@ -185,2 +182,2 @@\n-                    classFileName = cf.getName();\n-                } catch (ConstantPoolException e) {\n+                    classFileName = cf.thisClass().asInternalName();\n+                } catch (IllegalArgumentException e) {\n@@ -192,1 +189,1 @@\n-                if (!finder.accept(archive, cn, cf.access_flags))\n+                if (!finder.accept(archive, cn, cf.flags()))\n@@ -220,1 +217,1 @@\n-        ClassFile cf = archive.reader().getClassFile(name);\n+        var cf = archive.reader().getClassFile(name);\n@@ -226,1 +223,1 @@\n-        if (cf.access_flags.is(AccessFlags.ACC_MODULE))\n+        if (cf.isModuleInfo())\n@@ -232,2 +229,2 @@\n-            cn =  cf.getName().replace('\/', '.');\n-        } catch (ConstantPoolException e) {\n+            cn =  cf.thisClass().asInternalName().replace('\/', '.');\n+        } catch (IllegalArgumentException e) {\n@@ -237,1 +234,1 @@\n-        if (!finder.accept(archive, cn, cf.access_flags))\n+        if (!finder.accept(archive, cn, cf.flags()))\n@@ -299,1 +296,1 @@\n-                ? Dependencies.getAPIFinder(AccessFlags.ACC_PROTECTED)\n+                ? Dependencies.getAPIFinder(ClassFile.ACC_PROTECTED)\n@@ -312,1 +309,1 @@\n-                                 accessFlags.is(AccessFlags.ACC_PUBLIC)\n+                                 accessFlags.has(AccessFlag.PUBLIC)\n@@ -317,1 +314,1 @@\n-        public Iterable<? extends Dependency> findDependencies(ClassFile classfile) {\n+        public Iterable<? extends Dependency> findDependencies(ClassModel classfile) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/DependencyFinder.java","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependency.Location;\n@@ -31,1 +31,0 @@\n-import java.util.Collection;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/DepsAnalyzer.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import com.sun.tools.classfile.Dependency;\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/JdepsConfiguration.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,1 @@\n-import com.sun.tools.classfile.Dependencies;\n-import com.sun.tools.classfile.Dependency;\n-import com.sun.tools.classfile.Dependency.Location;\n+import com.sun.tools.jdeps.Dependency.Location;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/JdepsFilter.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import com.sun.tools.classfile.Dependency;\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/ModuleAnalyzer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPoolException;\n-\n+import java.lang.classfile.ClassModel;\n@@ -47,2 +45,2 @@\n-    public static void add(JarFile jarfile, JarEntry e, ClassFile cf)\n-            throws ConstantPoolException\n+    public static void add(JarFile jarfile, JarEntry e, ClassModel cf)\n+            throws IllegalArgumentException\n@@ -57,1 +55,1 @@\n-                String name = cf.getName().replace('\/', '.');\n+                String name = cf.thisClass().asInternalName().replace('\/', '.');\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/VersionHelper.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Simple tests for method signature parsing\n- * @modules jdk.jdeps\/com.sun.tools.jdeprscan.scan\n- * @build TestMethodSig\n- * @run testng jdk.jdeprscan.TestMethodSig\n- *\/\n-\n-package jdk.jdeprscan;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.assertEquals;\n-import static com.sun.tools.jdeprscan.scan.MethodSig.fromDesc;\n-\n-public class TestMethodSig {\n-    @Test\n-    public void testSimple() {\n-        assertEquals(fromDesc(\"(Ljava\/rmi\/RMISecurityManager;)Ljava\/lang\/Object;\").toString(),\n-                     \"parameters 0=Ljava\/rmi\/RMISecurityManager; return Ljava\/lang\/Object;\");\n-    }\n-\n-    @Test\n-    public void testMultParamVoidReturn() {\n-        assertEquals(fromDesc(\"([[IZLjava\/lang\/String;B[J)V\").toString(),\n-                     \"parameters 0=[[I 1=Z 2=Ljava\/lang\/String; 3=B 4=[J return V\");\n-    }\n-\n-    @Test\n-    public void testNoParams() {\n-        assertEquals(fromDesc(\"()J\").toString(),\n-                     \"parameters none return J\");\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testMissingReturnType() {\n-        fromDesc(\"(ISJZ)\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/jdeprscan\/tests\/jdk\/jdeprscan\/TestMethodSig.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"}]}