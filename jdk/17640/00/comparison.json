{"files":[{"patch":"@@ -71,53 +71,0 @@\n- * <p>\n- * A {@code ChoiceFormat} can be constructed using either an array of formats\n- * and an array of limits or a string pattern. When constructing with\n- * format and limit arrays, the length of these arrays must be the same.\n- *\n- * For example,\n- * <ul>\n- * <li>\n- *     <em>limits<\/em> = {1,2,3,4,5,6,7}<br>\n- *     <em>formats<\/em> = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"}\n- * <li>\n- *     <em>limits<\/em> = {0, 1, ChoiceFormat.nextDouble(1)}<br>\n- *     <em>formats<\/em> = {\"no files\", \"one file\", \"many files\"}<br>\n- *     ({@code nextDouble} can be used to get the next higher double, to\n- *     make the half-open interval.)\n- * <\/ul>\n- *\n- * <p>\n- * Below is an example of constructing a ChoiceFormat with arrays to format\n- * and parse values:\n- * {@snippet lang=java :\n- * double[] limits = {1,2,3,4,5,6,7};\n- * String[] dayOfWeekNames = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"};\n- * ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);\n- * ParsePosition status = new ParsePosition(0);\n- * for (double i = 0.0; i <= 8.0; ++i) {\n- *     status.setIndex(0);\n- *     System.out.println(i + \" -> \" + form.format(i) + \" -> \"\n- *                              + form.parse(form.format(i),status));\n- * }\n- * }\n- *\n- * <p>\n- * For more sophisticated patterns, {@code ChoiceFormat} can be used with\n- * {@link MessageFormat} to produce accurate forms for singular and plural:\n- * {@snippet lang=java :\n- * MessageFormat msgFmt = new MessageFormat(\"The disk \\\"{0}\\\" contains {1}.\");\n- * double[] fileLimits = {0,1,2};\n- * String[] filePart = {\"no files\",\"one file\",\"{1,number} files\"};\n- * ChoiceFormat fileChoices = new ChoiceFormat(fileLimits, filePart);\n- * msgFmt.setFormatByArgumentIndex(1, fileChoices);\n- * Object[] args = {\"MyDisk\", 1273};\n- * System.out.println(msgFmt.format(args));\n- * }\n- * The output with different values for {@code fileCount}:\n- * <blockquote><pre>\n- * The disk \"MyDisk\" contains no files.\n- * The disk \"MyDisk\" contains one file.\n- * The disk \"MyDisk\" contains 1,273 files.\n- * <\/pre><\/blockquote>\n- * See {@link MessageFormat##pattern_caveats MessageFormat} for caveats regarding\n- * {@code MessageFormat} patterns within a {@code ChoiceFormat} pattern.\n- *\n@@ -130,1 +77,0 @@\n- * <dd><i>Note: Each additional SubPattern must have a Limit greater than the previous SubPattern's Limit<\/i>\n@@ -136,0 +82,1 @@\n+ * <dd><sub>Note: Each additional SubPattern must have an ascending Limit-Relation interval<\/sub><\/dd>\n@@ -175,1 +122,1 @@\n- * <dd>Any characters except the <i>Relation<\/i> symbols\n+ * <dd>Any characters except the special pattern character '|'\n@@ -182,4 +129,1 @@\n- * <p>If a <i>Relation<\/i> symbol is to be used within a <i>Format<\/i> pattern,\n- * it must be single quoted. For example,\n- * {@code new ChoiceFormat(\"1# '#'1 \").format(1)} returns {@code \" #1 \"}.\n- * Use two single quotes in a row to produce a literal single quote. For example,\n+ * <p> Use two single quotes in a row to produce a literal single quote. For example,\n@@ -188,1 +132,35 @@\n- * <p>Below is an example of constructing a ChoiceFormat with a pattern:\n+ * <h2>Usage Information<\/h2>\n+ *\n+ * <p>\n+ * A {@code ChoiceFormat} can be constructed using either an array of formats\n+ * and an array of limits or a string pattern. When constructing with\n+ * format and limit arrays, the length of these arrays must be the same.\n+ *\n+ * For example,\n+ * <ul>\n+ * <li>\n+ *     <em>limits<\/em> = {1,2,3,4,5,6,7}<br>\n+ *     <em>formats<\/em> = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"}\n+ * <li>\n+ *     <em>limits<\/em> = {0, 1, ChoiceFormat.nextDouble(1)}<br>\n+ *     <em>formats<\/em> = {\"no files\", \"one file\", \"many files\"}<br>\n+ *     ({@code nextDouble} can be used to get the next higher double, to\n+ *     make the half-open interval.)\n+ * <\/ul>\n+ *\n+ * <p>\n+ * Below is an example of constructing a ChoiceFormat with arrays to format\n+ * and parse values:\n+ * {@snippet lang=java :\n+ * double[] limits = {1,2,3,4,5,6,7};\n+ * String[] dayOfWeekNames = {\"Sun\",\"Mon\",\"Tue\",\"Wed\",\"Thur\",\"Fri\",\"Sat\"};\n+ * ChoiceFormat form = new ChoiceFormat(limits, dayOfWeekNames);\n+ * ParsePosition status = new ParsePosition(0);\n+ * for (double i = 0.0; i <= 8.0; ++i) {\n+ *     status.setIndex(0);\n+ *     System.out.println(i + \" -> \" + form.format(i) + \" -> \"\n+ *                              + form.parse(form.format(i),status));\n+ * }\n+ * }\n+ *\n+ * <p>Below is an example of constructing a ChoiceFormat with a String pattern:\n@@ -205,0 +183,21 @@\n+ * <p>\n+ * For more sophisticated patterns, {@code ChoiceFormat} can be used with\n+ * {@link MessageFormat} to produce accurate forms for singular and plural:\n+ * {@snippet lang=java :\n+ * MessageFormat msgFmt = new MessageFormat(\"The disk \\\"{0}\\\" contains {1}.\");\n+ * double[] fileLimits = {0,1,2};\n+ * String[] filePart = {\"no files\",\"one file\",\"{1,number} files\"};\n+ * ChoiceFormat fileChoices = new ChoiceFormat(fileLimits, filePart);\n+ * msgFmt.setFormatByArgumentIndex(1, fileChoices);\n+ * Object[] args = {\"MyDisk\", 1273};\n+ * System.out.println(msgFmt.format(args));\n+ * }\n+ * The output with different values for {@code fileCount}:\n+ * <blockquote><pre>\n+ * The disk \"MyDisk\" contains no files.\n+ * The disk \"MyDisk\" contains one file.\n+ * The disk \"MyDisk\" contains 1,273 files.\n+ * <\/pre><\/blockquote>\n+ * See {@link MessageFormat##pattern_caveats MessageFormat} for caveats regarding\n+ * {@code MessageFormat} patterns within a {@code ChoiceFormat} pattern.\n+ *\n@@ -257,1 +256,1 @@\n-        int part = 0;\n+        int part = 0; \/\/ 0 denotes limit, 1 denotes format\n@@ -273,1 +272,4 @@\n-            } else if (ch == '<' || ch == '#' || ch == '\\u2264') {\n+            } else if (part == 0 && (ch == '<' || ch == '#' || ch == '\\u2264')) {\n+                \/\/ Only consider relational symbols if parsing the limit segment (part == 0).\n+                \/\/ Don't treat a relational symbol as syntactically significant\n+                \/\/ when parsing Format segment (part == 1)\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":64,"deletions":62,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6801704\n+ * @bug 6285888 6801704\n@@ -104,2 +104,0 @@\n-                arguments(\"0#foo1#\", ERR1), \/\/ SubPattern not separated by '|'\n-                arguments(\"0#foo#\", ERR1), \/\/ Using a Relation in a format\n@@ -108,0 +106,5 @@\n+\n+                \/\/ No longer throw IAE after 6285888, as relational symbols\n+                \/\/ can now be used within the Format segment.\n+                \/\/ arguments(\"0#foo1#\", ERR1), \/\/ SubPattern not separated by '|'\n+                \/\/ arguments(\"0#foo#\", ERR1), \/\/ Using a Relation in a format\n","filename":"test\/jdk\/java\/text\/Format\/ChoiceFormat\/PatternsTest.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6285888\n+ * @summary Ensure ChoiceFormat supports \"#\", \"<\", \"â‰¤\" within\n+ *          the format segment of a ChoiceFormat String pattern\n+ * @run junit SymbolsInFormatSegment\n+ *\/\n+\n+import java.text.ChoiceFormat;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * These tests would previously throw IAEs on all input as ChoiceFormat would parse\n+ * the relational symbol syntactically (when not needed). With the associated change\n+ * set, ChoiceFormat knows to not treat any subsequent relational symbols as\n+ * syntactically significant unless a '|' has been parsed.\n+ *\/\n+public class SymbolsInFormatSegment {\n+\n+    \/\/ Test a variety of patterns with relational symbols in the Format segment\n+    @ParameterizedTest\n+    @MethodSource(\"patternsWithSymbols\")\n+    public void allowInConstructor(String pattern, String expected, int limit) {\n+        var cf = new ChoiceFormat(pattern);\n+        assertEquals(expected, cf.format(limit));\n+    }\n+\n+    \/\/ Same as previous test, but check the applyPattern method\n+    @ParameterizedTest\n+    @MethodSource(\"patternsWithSymbols\")\n+    public void allowInApplyPattern(String pattern, String expected, int limit) {\n+        var cf = new ChoiceFormat(\"\");\n+        cf.applyPattern(pattern);\n+        assertEquals(expected, cf.format(limit));\n+    }\n+\n+    private static Stream<Arguments> patternsWithSymbols() {\n+        return Stream.of(\n+                \/\/ CSR example\n+                Arguments.of(\"1#The code is #7281\", \"The code is #7281\", 1),\n+                \/\/ Other examples\n+                Arguments.of(\"1#<\", \"<\", 1),\n+                Arguments.of(\"1#foo<\", \"foo<\", 1),\n+                Arguments.of(\"1<foo\\u2264\", \"foo\\u2264\", 1),\n+                Arguments.of(\"1\\u2264foo#\", \"foo#\", 1),\n+                Arguments.of(\"1#foo<#\\u2264|2\\u2264baz<#\\u2264\", \"baz<#\\u2264\", 100),\n+                Arguments.of(\"1#foo<#\\u2264|2#baz<#\\u2264|3<bar##\\u2264\", \"bar##\\u2264\", 100),\n+                Arguments.of(\"1#foo<#\\u2264|2#baz<#\\u2264|3\\u2264bar##\\u2264\", \"bar##\\u2264\", 100)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/ChoiceFormat\/SymbolsInFormatSegment.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"}]}