{"files":[{"patch":"@@ -1931,0 +1931,32 @@\n+template<typename IntegerType>\n+static const IntegerType* integral_abs_value(const IntegerType* t) {\n+  typedef typename IntegerType::NativeType NativeType;\n+\n+  assert(!t->is_con(), \"Constant types must have already been handled\");\n+\n+  NativeType lo_abs = uabs(t->_lo);\n+  NativeType hi_abs = uabs(t->_hi);\n+\n+  if (lo_abs < 0) {\n+    assert(lo_abs == std::numeric_limits<NativeType>::min(), \"uabs(t->_lo) must be min value if negative!\");\n+\n+    \/\/ If lo is type_min, then hi must be type_max. This is because:\n+    \/\/ - An integer type is defined as type_min <= lo <= hi <= type_max.\n+    \/\/ - Since t is not a constant, it must be that lo < hi.\n+    \/\/ - Therefore, hi must be >= type_min+1.\n+    \/\/ - As abs(type_min+1) == type_max and for all n from type_min+1 to hi, abs(n) <= type_max, the upper bound must be type_max.\n+    return IntegerType::TYPE_DOMAIN;\n+  }\n+\n+  NativeType lo = 0;\n+  if (t->_hi < 0 || t->_lo >= 0) {\n+    \/\/ If both values are positive or negative, select the value that is closer to 0.\n+    lo = MIN2(lo_abs, hi_abs);\n+  }\n+\n+  \/\/ Select the value that extends the furthest from 0.\n+  NativeType hi = MAX2(lo_abs, hi_abs);\n+\n+  return IntegerType::make(lo, hi, t->_widen);\n+}\n+\n@@ -1943,1 +1975,2 @@\n-    break;\n+\n+    return integral_abs_value(ti);\n@@ -1950,1 +1983,2 @@\n-    break;\n+\n+    return integral_abs_value(tl);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +28,1 @@\n+import compiler.lib.generators.Generators;\n@@ -31,1 +33,1 @@\n- * @bug 8276673 8280089\n+ * @bug 8276673 8280089 8349563\n@@ -33,1 +35,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @key randomness\n@@ -106,1 +108,1 @@\n-    @IR(failOn = {IRNode.ABS_I, IRNode.ABS_L, IRNode.ABS_F, IRNode.ABS_D})\n+    @IR(failOn = {IRNode.ABS_I, IRNode.ABS_L, IRNode.ABS_F, IRNode.ABS_D}, applyIfPlatform = { \"64-bit\", \"true\" })\n@@ -163,1 +165,1 @@\n-    @IR(counts = {IRNode.ABS_L, \"1\"})\n+    @IR(counts = {IRNode.ABS_L, \"1\"}, applyIfPlatform = { \"64-bit\", \"true\" })\n@@ -169,2 +171,2 @@\n-    @IR(failOn = {IRNode.SUB_L})\n-    @IR(counts = {IRNode.ABS_L, \"1\"})\n+    @IR(failOn = {IRNode.SUB_L}, applyIfPlatform = { \"64-bit\", \"true\" })\n+    @IR(counts = {IRNode.ABS_L, \"1\"}, applyIfPlatform = { \"64-bit\", \"true\" })\n@@ -232,1 +234,101 @@\n- }\n+\n+    @Run(test = {\"testIntRange1\", \"testIntRange2\", \"testIntRange3\", \"testIntRange4\"})\n+    public void checkIntRanges(RunInfo info) {\n+        for (int i : ispecial) {\n+            checkIntRange(i);\n+        }\n+\n+        for (int j = 0; j < 20; j++) {\n+            int i = Generators.G.ints().next();\n+            checkIntRange(i);\n+        }\n+    }\n+\n+    @DontCompile\n+    public void checkIntRange(int i) {\n+        Asserts.assertEquals(Math.abs((i & 7) - 4) > 4, testIntRange1(i));\n+        Asserts.assertEquals(Math.abs((i & 7) - 4) < 0, testIntRange2(i));\n+        Asserts.assertEquals(Math.abs(-((i & 7) + 2)) < 2, testIntRange3(i));\n+        Asserts.assertEquals(Math.abs(-((i & 7) + 2)) > 9, testIntRange4(i));\n+    }\n+\n+    @Run(test = {\"testLongRange1\", \"testLongRange2\", \"testLongRange3\", \"testLongRange4\"})\n+    public void checkLongRanges(RunInfo info) {\n+        for (long l : lspecial) {\n+          checkLongRange(l);\n+        }\n+\n+        for (int j = 0; j < 20; j++) {\n+            long l = Generators.G.longs().next();\n+            checkLongRange(l);\n+        }\n+    }\n+\n+    @DontCompile\n+    public void checkLongRange(long l) {\n+        Asserts.assertEquals(Math.abs((l & 7) - 4) > 4, testLongRange1(l));\n+        Asserts.assertEquals(Math.abs((l & 7) - 4) < 0, testLongRange2(l));\n+        Asserts.assertEquals(Math.abs(-((l & 7) + 2)) < 2, testLongRange3(l));\n+        Asserts.assertEquals(Math.abs(-((l & 7) + 2)) > 9, testLongRange4(l));\n+    }\n+\n+    \/\/ Int ranges\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_I })\n+    public boolean testIntRange1(int in) {\n+        \/\/ [-4, 3] => [0, 4]\n+        return Math.abs((in & 7) - 4) > 4;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_I })\n+    public boolean testIntRange2(int in) {\n+        \/\/ [-4, 3] => [0, 4]\n+        return Math.abs((in & 7) - 4) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_I })\n+    public boolean testIntRange3(int in) {\n+        \/\/ [-9, -2] => [2, 9]\n+        return Math.abs(-((in & 7) + 2)) < 2;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_I })\n+    public boolean testIntRange4(int in) {\n+        \/\/ [-9, -2] => [2, 9]\n+        return Math.abs(-((in & 7) + 2)) > 9;\n+    }\n+\n+    \/\/ Long ranges\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_L }, applyIfPlatform = { \"64-bit\", \"true\" })\n+    public boolean testLongRange1(long in) {\n+        \/\/ [-4, 3] => [0, 4]\n+        return Math.abs((in & 7) - 4) > 4;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_L }, applyIfPlatform = { \"64-bit\", \"true\" })\n+    public boolean testLongRange2(long in) {\n+        \/\/ [-4, 3] => [0, 4]\n+        return Math.abs((in & 7) - 4) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_L }, applyIfPlatform = { \"64-bit\", \"true\" })\n+    public boolean testLongRange3(long in) {\n+        \/\/ [-9, -2] => [2, 9]\n+        return Math.abs(-((in & 7) + 2)) < 2;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_L }, applyIfPlatform = { \"64-bit\", \"true\" })\n+    public boolean testLongRange4(long in) {\n+        \/\/ [-9, -2] => [2, 9]\n+        return Math.abs(-((in & 7) + 2)) > 9;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIRAbs.java","additions":109,"deletions":7,"binary":false,"changes":116,"status":"modified"}]}