{"files":[{"patch":"@@ -1936,0 +1936,39 @@\n+template<typename IntegerType>\n+static const IntegerType* integral_abs_value(const IntegerType* t) {\n+  typedef typename IntegerType::NativeType NativeType;\n+\n+  if (t->is_con()) {\n+    \/\/ Handle minimum value separately to avoid overflow\n+    if (t->get_con() == IntegerType::MIN->_lo) {\n+      return IntegerType::MIN;\n+    }\n+\n+    return IntegerType::make(ABS(t->get_con()));\n+  }\n+\n+  if (t->_lo == IntegerType::MIN->_lo) {\n+    \/\/ If lo is type_min, then hi must be type_max. This is because:\n+    \/\/ - An integer type is defined as type_min <= lo <= hi <= type_max.\n+    \/\/ - Since t is not a constant, it must be that lo < hi.\n+    \/\/ - Therefore, hi must be >= type_min+1.\n+    \/\/ - As abs(type_min+1) == type_max and for all n from type_min+1 to hi, abs(n) <= type_max, the upper bound must be type_max.\n+\n+    return IntegerType::TYPE_DOMAIN;\n+  }\n+\n+  \/\/ Knowing that min_type is not in t, we know there is no overflow.\n+  NativeType lo_abs = ABS(t->_lo);\n+  NativeType hi_abs = ABS(t->_hi);\n+\n+  NativeType lo = 0;\n+  if (t->_hi < 0 || t->_lo >= 0) {\n+    \/\/ If both values are positive or negative, select the value that is closer to 0.\n+    lo = MIN2(lo_abs, hi_abs);\n+  }\n+\n+  \/\/ Select the value that extends the furthest from 0.\n+  NativeType hi = MAX2(lo_abs, hi_abs);\n+\n+  return IntegerType::make(lo, hi, t->_widen);\n+}\n+\n@@ -1945,4 +1984,2 @@\n-    if (ti->is_con()) {\n-      return TypeInt::make(g_uabs(ti->get_con()));\n-    }\n-    break;\n+\n+    return integral_abs_value(ti);\n@@ -1952,4 +1989,2 @@\n-    if (tl->is_con()) {\n-      return TypeLong::make(g_uabs(tl->get_con()));\n-    }\n-    break;\n+\n+    return integral_abs_value(tl);\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":43,"deletions":8,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +28,1 @@\n+import compiler.lib.generators.*;\n@@ -31,1 +33,1 @@\n- * @bug 8276673 8280089\n+ * @bug 8276673 8280089 8349563\n@@ -33,1 +35,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n+ * @key randomness\n@@ -39,0 +41,23 @@\n+    private static final RestrictableGenerator<Integer> INTS = Generators.G.ints();\n+    private static final RestrictableGenerator<Long> LONGS = Generators.G.longs();\n+\n+    private static final IntRange INT_RANGE = IntRange.generate(INTS);\n+    private static final LongRange LONG_RANGE = LongRange.generate(LONGS);\n+\n+    private static final int INT_1 = INTS.next();\n+    private static final int INT_2 = INTS.next();\n+    private static final int INT_3 = INTS.next();\n+    private static final int INT_4 = INTS.next();\n+    private static final int INT_5 = INTS.next();\n+    private static final int INT_6 = INTS.next();\n+    private static final int INT_7 = INTS.next();\n+    private static final int INT_8 = INTS.next();\n+\n+    private static final long LONG_1 = LONGS.next();\n+    private static final long LONG_2 = LONGS.next();\n+    private static final long LONG_3 = LONGS.next();\n+    private static final long LONG_4 = LONGS.next();\n+    private static final long LONG_5 = LONGS.next();\n+    private static final long LONG_6 = LONGS.next();\n+    private static final long LONG_7 = LONGS.next();\n+    private static final long LONG_8 = LONGS.next();\n@@ -106,1 +131,1 @@\n-    @IR(failOn = {IRNode.ABS_I, IRNode.ABS_L, IRNode.ABS_F, IRNode.ABS_D})\n+    @IR(failOn = {IRNode.ABS_I, IRNode.ABS_L, IRNode.ABS_F, IRNode.ABS_D}, applyIfPlatform = { \"64-bit\", \"true\" })\n@@ -163,1 +188,1 @@\n-    @IR(counts = {IRNode.ABS_L, \"1\"})\n+    @IR(counts = {IRNode.ABS_L, \"1\"}, applyIfPlatform = { \"64-bit\", \"true\" })\n@@ -169,2 +194,2 @@\n-    @IR(failOn = {IRNode.SUB_L})\n-    @IR(counts = {IRNode.ABS_L, \"1\"})\n+    @IR(failOn = {IRNode.SUB_L}, applyIfPlatform = { \"64-bit\", \"true\" })\n+    @IR(counts = {IRNode.ABS_L, \"1\"}, applyIfPlatform = { \"64-bit\", \"true\" })\n@@ -232,1 +257,221 @@\n- }\n+\n+    @Run(test = {\"testIntRange1\", \"testIntRange2\", \"testIntRange3\", \"testIntRange4\", \"testIntRangeFolding\"})\n+    public void checkIntRanges(RunInfo info) {\n+        for (int i : ispecial) {\n+            checkIntRange(i);\n+        }\n+\n+        for (int j = 0; j < 20; j++) {\n+            int i = INTS.next();\n+            checkIntRange(i);\n+        }\n+    }\n+\n+    @DontCompile\n+    public void checkIntRange(int i) {\n+        Asserts.assertEquals(Math.abs((i & 7) - 4) > 4, testIntRange1(i));\n+        Asserts.assertEquals(Math.abs((i & 7) - 4) < 0, testIntRange2(i));\n+        Asserts.assertEquals(Math.abs(-((i & 7) + 2)) < 2, testIntRange3(i));\n+        Asserts.assertEquals(Math.abs(-((i & 7) + 2)) > 9, testIntRange4(i));\n+        Asserts.assertEquals(testIntRangeFoldingInterpreter(i), testIntRangeFolding(i));\n+    }\n+\n+    @Run(test = {\"testLongRange1\", \"testLongRange2\", \"testLongRange3\", \"testLongRange4\", \"testLongRangeFolding\"})\n+    public void checkLongRanges(RunInfo info) {\n+        for (long l : lspecial) {\n+          checkLongRange(l);\n+        }\n+\n+        for (int j = 0; j < 20; j++) {\n+            long l = LONGS.next();\n+            checkLongRange(l);\n+        }\n+    }\n+\n+    @DontCompile\n+    public void checkLongRange(long l) {\n+        Asserts.assertEquals(Math.abs((l & 7) - 4) > 4, testLongRange1(l));\n+        Asserts.assertEquals(Math.abs((l & 7) - 4) < 0, testLongRange2(l));\n+        Asserts.assertEquals(Math.abs(-((l & 7) + 2)) < 2, testLongRange3(l));\n+        Asserts.assertEquals(Math.abs(-((l & 7) + 2)) > 9, testLongRange4(l));\n+        Asserts.assertEquals(testLongRangeFoldingInterpreter(l), testLongRangeFolding(l));\n+    }\n+\n+    \/\/ Int ranges\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_I })\n+    public boolean testIntRange1(int in) {\n+        \/\/ [-4, 3] => [0, 4]\n+        return Math.abs((in & 7) - 4) > 4;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_I })\n+    public boolean testIntRange2(int in) {\n+        \/\/ [-4, 3] => [0, 4]\n+        return Math.abs((in & 7) - 4) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_I })\n+    public boolean testIntRange3(int in) {\n+        \/\/ [-9, -2] => [2, 9]\n+        return Math.abs(-((in & 7) + 2)) < 2;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_I })\n+    public boolean testIntRange4(int in) {\n+        \/\/ [-9, -2] => [2, 9]\n+        return Math.abs(-((in & 7) + 2)) > 9;\n+    }\n+\n+    @Test\n+    public int testIntRangeFolding(int in) {\n+        int c = INT_RANGE.clamp(in);\n+        int v = Math.abs(c);\n+\n+        int sum = 0;\n+        if (v > INT_1) { sum += 1; }\n+        if (v > INT_2) { sum += 2; }\n+        if (v > INT_3) { sum += 4; }\n+        if (v > INT_4) { sum += 8; }\n+        if (v > INT_5) { sum += 16; }\n+        if (v > INT_6) { sum += 32; }\n+        if (v > INT_7) { sum += 64; }\n+        if (v > INT_8) { sum += 128; }\n+\n+        return sum;\n+    }\n+\n+    @DontCompile\n+    public int testIntRangeFoldingInterpreter(int in) {\n+        int c = INT_RANGE.clamp(in);\n+        int v = Math.abs(c);\n+\n+        int sum = 0;\n+        if (v > INT_1) { sum += 1; }\n+        if (v > INT_2) { sum += 2; }\n+        if (v > INT_3) { sum += 4; }\n+        if (v > INT_4) { sum += 8; }\n+        if (v > INT_5) { sum += 16; }\n+        if (v > INT_6) { sum += 32; }\n+        if (v > INT_7) { sum += 64; }\n+        if (v > INT_8) { sum += 128; }\n+\n+        return sum;\n+    }\n+\n+    \/\/ Long ranges\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_L }, applyIfPlatform = { \"64-bit\", \"true\" })\n+    public boolean testLongRange1(long in) {\n+        \/\/ [-4, 3] => [0, 4]\n+        return Math.abs((in & 7) - 4) > 4;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_L }, applyIfPlatform = { \"64-bit\", \"true\" })\n+    public boolean testLongRange2(long in) {\n+        \/\/ [-4, 3] => [0, 4]\n+        return Math.abs((in & 7) - 4) < 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_L }, applyIfPlatform = { \"64-bit\", \"true\" })\n+    public boolean testLongRange3(long in) {\n+        \/\/ [-9, -2] => [2, 9]\n+        return Math.abs(-((in & 7) + 2)) < 2;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.ABS_L }, applyIfPlatform = { \"64-bit\", \"true\" })\n+    public boolean testLongRange4(long in) {\n+        \/\/ [-9, -2] => [2, 9]\n+        return Math.abs(-((in & 7) + 2)) > 9;\n+    }\n+\n+    @Test\n+    public int testLongRangeFolding(long in) {\n+        long c = LONG_RANGE.clamp(in);\n+        long v = Math.abs(c);\n+\n+        int sum = 0;\n+        if (v > LONG_1) { sum += 1; }\n+        if (v > LONG_2) { sum += 2; }\n+        if (v > LONG_3) { sum += 4; }\n+        if (v > LONG_4) { sum += 8; }\n+        if (v > LONG_5) { sum += 16; }\n+        if (v > LONG_6) { sum += 32; }\n+        if (v > LONG_7) { sum += 64; }\n+        if (v > LONG_8) { sum += 128; }\n+\n+        return sum;\n+    }\n+\n+    @DontCompile\n+    public int testLongRangeFoldingInterpreter(long in) {\n+        long c = LONG_RANGE.clamp(in);\n+        long v = Math.abs(c);\n+\n+        int sum = 0;\n+        if (v > LONG_1) { sum += 1; }\n+        if (v > LONG_2) { sum += 2; }\n+        if (v > LONG_3) { sum += 4; }\n+        if (v > LONG_4) { sum += 8; }\n+        if (v > LONG_5) { sum += 16; }\n+        if (v > LONG_6) { sum += 32; }\n+        if (v > LONG_7) { sum += 64; }\n+        if (v > LONG_8) { sum += 128; }\n+\n+        return sum;\n+    }\n+\n+    record IntRange(int lo, int hi) {\n+        IntRange {\n+            if (lo > hi) {\n+                throw new IllegalArgumentException(\"lo > hi\");\n+            }\n+        }\n+\n+        int clamp(int v) {\n+            return Math.min(hi, Math.max(v, lo));\n+        }\n+\n+        static IntRange generate(Generator<Integer> g) {\n+            var a = g.next();\n+            var b = g.next();\n+            if (a > b) {\n+                var tmp = a;\n+                a = b;\n+                b = tmp;\n+            }\n+            return new IntRange(a, b);\n+        }\n+    }\n+\n+    record LongRange(long lo, long hi) {\n+        LongRange {\n+            if (lo > hi) {\n+                throw new IllegalArgumentException(\"lo > hi\");\n+            }\n+        }\n+\n+        long clamp(long v) {\n+            return Math.min(hi, Math.max(v, lo));\n+        }\n+\n+        static LongRange generate(Generator<Long> g) {\n+            var a = g.next();\n+            var b = g.next();\n+            if (a > b) {\n+                var tmp = a;\n+                a = b;\n+                b = tmp;\n+            }\n+            return new LongRange(a, b);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIRAbs.java","additions":252,"deletions":7,"binary":false,"changes":259,"status":"modified"}]}