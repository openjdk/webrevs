{"files":[{"patch":"@@ -2222,1 +2222,1 @@\n-      st->print(\"Profiled Loop \");\n+      st->print(\"Profiled_Loop \");\n@@ -2228,1 +2228,1 @@\n-      st->print(\"Loop Limit Check \");\n+      st->print(\"Loop_Limit_Check \");\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1443,0 +1443,5 @@\n+    public static final String OPAQUE_TEMPLATE_ASSERTION_PREDICATE = PREFIX + \"OPAQUE_TEMPLATE_ASSERTION_PREDICATE\" + POSTFIX;\n+    static {\n+        duringLoopOpts(OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"OpaqueTemplateAssertionPredicate\");\n+    }\n+\n@@ -1549,1 +1554,1 @@\n-        parsePredicateNodes(LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"Loop Limit Check\");\n+        parsePredicateNodes(LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"Loop_Limit_Check\");\n@@ -1554,1 +1559,6 @@\n-        parsePredicateNodes(PROFILED_LOOP_PARSE_PREDICATE, \"Profiled Loop\");\n+        parsePredicateNodes(PROFILED_LOOP_PARSE_PREDICATE, \"Profiled_Loop\");\n+    }\n+\n+    public static final String AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE = PREFIX + \"AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE\" + POSTFIX;\n+    static {\n+        parsePredicateNodes(AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"Auto_Vectorization_Check\");\n@@ -2774,0 +2784,10 @@\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#BEFORE_LOOP_OPTS}\n+     * up to and including {@link CompilePhase#AFTER_LOOP_OPTS}\n+     *\/\n+    private static void duringLoopOpts(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.AFTER_LOOP_OPTS, regex,\n+                                                                          CompilePhase.BEFORE_LOOP_OPTS,\n+                                                                          CompilePhase.AFTER_LOOP_OPTS));\n+    }\n+\n@@ -2780,1 +2800,1 @@\n-        String regex = START + \"ParsePredicate\" + MID + \"#\" + label + \"[ ]*!jvms:\" + END;\n+        String regex = START + \"ParsePredicate\" + MID + \"#\" + label + \" \" + END;\n@@ -2783,1 +2803,1 @@\n-                                                                          CompilePhase.PHASEIDEALLOOP_ITERATIONS));\n+                                                                          CompilePhase.AFTER_LOOP_OPTS));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ package compiler.loopopts;\n+\n+ import compiler.lib.ir_framework.*;\n+ import jdk.test.lib.Asserts;\n+\n+ \/*\n+  * @test\n+  * @bug 8346552\n+  * @summary Test that all parse predicates are cloned after loop unswitching.\n+  * @library \/test\/lib \/\n+  * @run driver compiler.loopopts.TestUnswitchPredicateCloning\n+  *\/\n+\n+public class TestUnswitchPredicateCloning {\n+    static final int WARMUP = 10_000;\n+    static final int SIZE = 100;\n+    static final int IDX = 42;\n+\n+    public static void main(String[] strArr) {\n+        TestFramework.runWithFlags(\"-Xcomp\");\n+    }\n+\n+    @Run(test = \"test\")\n+    private static void check() {\n+        int res = test(IDX);\n+        Asserts.assertEQ(res, SIZE * IDX);\n+    }\n+\n+    @DontInline\n+    private static int[] getArr() {\n+        int[] arr = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            arr[i] = i;\n+        }\n+\n+        return arr;\n+    }\n+\n+    @Test\n+    \/\/ Check that loop unswitching the number of parse predicates inside the unswitched\n+    \/\/ loop have doubled.\n+    @IR(counts = {IRNode.LOOP_PARSE_PREDICATE, \"3\",\n+                 IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"3\",\n+                 IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"3\",\n+                 IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"3\"},\n+        phase = CompilePhase.BEFORE_LOOP_UNSWITCHING)\n+    @IR(counts = {IRNode.LOOP_PARSE_PREDICATE, \"5\",\n+                 IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"5\",\n+                 IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"5\",\n+                 IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"5\"},\n+        phase = CompilePhase.AFTER_LOOP_UNSWITCHING)\n+    \/\/ Check that opaque template assertion predicated are added in loop predication\n+    \/\/ even if loop predication only happens after loop unswitching.\n+    @IR(failOn = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE },\n+        phase = CompilePhase.AFTER_LOOP_UNSWITCHING)\n+    @IR(counts = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"2\" },\n+        phase = CompilePhase.AFTER_LOOP_PREDICATION_RC)\n+    static int test(int j) {\n+        int zero = 34;\n+        int limit = 2;\n+\n+        \/\/ Ensure zero == 0 is only known after CCP\n+        for (; limit < 4; limit *= 2) {\n+        }\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        int[] arr = getArr();\n+        int res = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            \/\/ Trigger unswitching only after CCP\n+            if (zero == 0) {\n+                \/\/ Trigger range check after loop unswitching\n+                res += arr[j];\n+            } else {\n+                res += arr[i];\n+            }\n+        }\n+\n+        return res;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestUnswitchPredicateCloning.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"}]}