{"files":[{"patch":"@@ -2222,1 +2222,1 @@\n-      st->print(\"Profiled Loop \");\n+      st->print(\"Profiled_Loop \");\n@@ -2228,1 +2228,1 @@\n-      st->print(\"Loop Limit Check \");\n+      st->print(\"Loop_Limit_Check \");\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -1096,1 +1097,2 @@\n-      _phase(phase) {}\n+      _phase(phase),\n+      _is_counted_loop(true_path_loop_head->is_CountedLoop()) {}\n@@ -1098,1 +1100,0 @@\n-\/\/ Keep track of whether we are in the correct Predicate Block where Template Assertion Predicates can be found.\n@@ -1100,0 +1101,4 @@\n+\/\/ Does not clone a Loop Limit Check Parse Predicate if a counted loop is unswitched, because it most likely will not be\n+\/\/ used anymore (it could only be used when both unswitched loop versions die and the Loop Limit Check Parse Predicate\n+\/\/ ends up at a LoopNode without Loop Limit Check Parse Predicate directly following the unswitched loop that can then\n+\/\/ be speculatively converted to a counted loop - this is rather rare).\n@@ -1101,0 +1106,4 @@\n+  Deoptimization::DeoptReason deopt_reason = parse_predicate.head()->deopt_reason();\n+  if (_is_counted_loop && deopt_reason == Deoptimization::Reason_loop_limit_check) {\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1179,0 +1179,1 @@\n+  const bool _is_counted_loop;\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1473,0 +1473,5 @@\n+    public static final String OPAQUE_TEMPLATE_ASSERTION_PREDICATE = PREFIX + \"OPAQUE_TEMPLATE_ASSERTION_PREDICATE\" + POSTFIX;\n+    static {\n+        duringLoopOpts(OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"OpaqueTemplateAssertionPredicate\");\n+    }\n+\n@@ -1579,1 +1584,1 @@\n-        parsePredicateNodes(LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"Loop Limit Check\");\n+        parsePredicateNodes(LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"Loop_Limit_Check\");\n@@ -1584,1 +1589,6 @@\n-        parsePredicateNodes(PROFILED_LOOP_PARSE_PREDICATE, \"Profiled Loop\");\n+        parsePredicateNodes(PROFILED_LOOP_PARSE_PREDICATE, \"Profiled_Loop\");\n+    }\n+\n+    public static final String AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE = PREFIX + \"AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE\" + POSTFIX;\n+    static {\n+        parsePredicateNodes(AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"Auto_Vectorization_Check\");\n@@ -2814,0 +2824,10 @@\n+    \/**\n+     * Apply {@code regex} on all ideal graph phases starting from {@link CompilePhase#BEFORE_LOOP_OPTS}\n+     * up to and including {@link CompilePhase#AFTER_LOOP_OPTS}\n+     *\/\n+    private static void duringLoopOpts(String irNodePlaceholder, String regex) {\n+        IR_NODE_MAPPINGS.put(irNodePlaceholder, new SinglePhaseRangeEntry(CompilePhase.AFTER_LOOP_OPTS, regex,\n+                                                                          CompilePhase.BEFORE_LOOP_OPTS,\n+                                                                          CompilePhase.AFTER_LOOP_OPTS));\n+    }\n+\n@@ -2820,1 +2840,1 @@\n-        String regex = START + \"ParsePredicate\" + MID + \"#\" + label + \"[ ]*!jvms:\" + END;\n+        String regex = START + \"ParsePredicate\" + MID + \"#\" + label + \" \" + END;\n@@ -2823,1 +2843,1 @@\n-                                                                          CompilePhase.PHASEIDEALLOOP_ITERATIONS));\n+                                                                          CompilePhase.AFTER_LOOP_OPTS));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8346552\n+ * @summary Test that all parse predicates are cloned after loop unswitching.\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.TestUnswitchPredicateCloning\n+ *\/\n+\n+public class TestUnswitchPredicateCloning {\n+    static final int SIZE = 100;\n+\n+    private static final Random random = Utils.getRandomInstance();\n+\n+    public static void main(String[] strArr) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"testUnswitchingBeforePredication\", \"testPredicationBeforeUnswitching\", \"testUnswitchingUncounted\"})\n+    @Warmup(0)\n+    private static void runNoWarmup() {\n+        final int idx = random.nextInt(SIZE);\n+        final boolean cond = random.nextBoolean();\n+        int res = testUnswitchingBeforePredication(idx);\n+        Asserts.assertEQ(SIZE * idx, res);\n+        res = testPredicationBeforeUnswitching(idx, cond);\n+        Asserts.assertEQ((SIZE * (SIZE - 1)) \/ 2 + (cond ? SIZE * idx : 0), res);\n+        res = testUnswitchingUncounted(cond);\n+        Asserts.assertEQ((SIZE * (SIZE - 1)) \/ 2 + (cond ? SIZE : 0), res);\n+    }\n+\n+    @DontInline\n+    private static int[] getArr() {\n+        int[] arr = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            arr[i] = i;\n+        }\n+        return arr;\n+    }\n+\n+    @Test\n+    \/\/ Check that Loop Unswitching doubled the number of Parse Predicates: We have\n+    \/\/ them at the true- and false-path-loop. Note that the Loop Limit Check Parse\n+    \/\/ Predicate is not cloned when we already have a counted loop.\n+    @IR(counts = { IRNode.LOOP_PARSE_PREDICATE, \"3\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"3\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"3\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"3\" },\n+        phase = CompilePhase.BEFORE_LOOP_UNSWITCHING)\n+    \/\/ Since we know that Loop Predication happens after Loop Unswitching, we can test the\n+    \/\/ have already been removed in the beautify loop phase.\n+    @IR(counts = { IRNode.LOOP_PARSE_PREDICATE, \"4\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"4\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"3\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"4\" },\n+        phase = CompilePhase.BEFORE_LOOP_PREDICATION_RC)\n+    \/\/ Check that Opaque Template Assertion Predicates are added in Loop Predication\n+    \/\/ even if Loop Predication only happens after Loop Unswitching.\n+    @IR(failOn = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE },\n+        phase = CompilePhase.AFTER_LOOP_UNSWITCHING)\n+    @IR(counts = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"2\" },\n+        phase = CompilePhase.AFTER_LOOP_PREDICATION_RC)\n+    static int testUnswitchingBeforePredication(int j) {\n+        int zero = 34;\n+        int limit = 2;\n+\n+        \/\/ Ensure zero == 0 is only known after CCP\n+        for (; limit < 4; limit *= 2) {\n+        }\n+        for (int i = 2; i < limit; i++) {\n+            zero = 0;\n+        }\n+\n+        int[] arr = getArr();\n+        int res = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            \/\/ Trigger unswitching only after CCP\n+            if (zero == 0) {\n+                \/\/ Trigger range check after loop unswitching\n+                res += arr[j];\n+            } else {\n+                res += arr[i];\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Check that Loop Unswitching doubled the number of Parse and Template\n+    \/\/ Assertion Predicates. Again, the Loop Limit Check Parse Predicate\n+    \/\/ remains at the Loop Selector since this is a counted loop.\n+    @IR(failOn = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE },\n+        phase = CompilePhase.BEFORE_LOOP_PREDICATION_RC)\n+    @IR(counts = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"2\",\n+                   IRNode.LOOP_PARSE_PREDICATE, \"1\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"1\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"1\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"1\" },\n+        phase = CompilePhase.BEFORE_LOOP_UNSWITCHING)\n+    \/\/ After Loop Unswitching and after removing the killed predicates.\n+    @IR(counts = { IRNode.OPAQUE_TEMPLATE_ASSERTION_PREDICATE, \"4\",\n+                   IRNode.LOOP_PARSE_PREDICATE, \"2\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"2\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"1\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"2\" },\n+        phase = CompilePhase.BEFORE_LOOP_PREDICATION_IC)\n+    static int testPredicationBeforeUnswitching(int j, boolean cond) {\n+        int[] arr = getArr();\n+        int res = 0;\n+        for (int i = 0; i < arr.length; i++) {\n+            if (cond) {\n+                res += arr[j];\n+            }\n+            res += arr[i];\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    \/\/ Check that Loop Unswitching doubled the number of all Parse Predicates.\n+    \/\/ Since this is not counted loop, the Loop Limit Check Parse Predicate\n+    \/\/ has to be cloned to both unswitched loops.\n+    @IR(counts = { IRNode.LOOP_PARSE_PREDICATE, \"1\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"1\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"1\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"1\" },\n+        phase = CompilePhase.BEFORE_LOOP_UNSWITCHING)\n+    \/\/ After Loop Unswitching and after removing the killed predicates all\n+    \/\/ Parse Predicates are doubled.\n+    @IR(counts = { IRNode.LOOP_PARSE_PREDICATE, \"2\",\n+                   IRNode.PROFILED_LOOP_PARSE_PREDICATE, \"2\",\n+                   IRNode.LOOP_LIMIT_CHECK_PARSE_PREDICATE, \"2\",\n+                   IRNode.AUTO_VECTORIZATION_CHECK_PARSE_PREDICATE, \"2\" },\n+        failOn = { IRNode.COUNTED_LOOP },\n+        phase = CompilePhase.PHASEIDEALLOOP1)\n+    @IR(failOn = { IRNode.COUNTED_LOOP })\n+    static int testUnswitchingUncounted(boolean cond) {\n+        int[] arr = getArr();\n+        int res = 0;\n+        int i = 0;\n+        while (i < arr.length) {\n+            if (cond) {\n+                res += 1;\n+            }\n+            res += arr[i];\n+\n+            i = arr[i] + 1; \/\/ effectively i += 1, but don't tell the compiler!\n+        }\n+\n+        return res;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestUnswitchPredicateCloning.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"}]}