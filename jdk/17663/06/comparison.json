{"files":[{"patch":"@@ -485,0 +485,25 @@\n+    \/**\n+     * A DateFormat style.\n+     * {@code Style} is an enum which corresponds to the DateFormat style\n+     * constants. Use {@code getValue()} to retrieve the associated int style\n+     * value.\n+     *\/\n+    enum Style {\n+\n+        FULL(DateFormat.FULL),\n+        LONG(DateFormat.LONG),\n+        MEDIUM(DateFormat.MEDIUM),\n+        SHORT(DateFormat.SHORT),\n+        DEFAULT(DateFormat.MEDIUM);\n+\n+        private final int value;\n+\n+        Style(int value){\n+            this.value = value;\n+        }\n+\n+        int getValue() {\n+            return value;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DateFormat.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.io.InvalidObjectException;\n@@ -43,0 +42,1 @@\n+import java.io.InvalidObjectException;\n@@ -44,1 +44,1 @@\n-import java.text.DecimalFormat;\n+import java.time.format.DateTimeFormatter;\n@@ -55,1 +55,1 @@\n- * messages in a language-neutral way. Use this to construct messages\n+ * messages in a language-neutral way. Use this class to construct messages\n@@ -85,2 +85,10 @@\n- * <i>FormatType: one of <\/i>\n- *         number date time choice\n+ * <i>FormatType:<\/i>\n+ *         number\n+ *         dtf_date\n+ *         dtf_time\n+ *         dtf_datetime\n+ *         <i>pre-defined DateTimeFormatter(s)<\/i>\n+ *         date\n+ *         time\n+ *         choice\n+ *         list\n@@ -96,0 +104,4 @@\n+ *         compact_short\n+ *         compact_long\n+ *         or\n+ *         unit\n@@ -99,39 +111,0 @@\n- * <p>Within a <i>String<\/i>, a pair of single quotes can be used to\n- * quote any arbitrary characters except single quotes. For example,\n- * pattern string <code>\"'{0}'\"<\/code> represents string\n- * <code>\"{0}\"<\/code>, not a <i>FormatElement<\/i>. A single quote itself\n- * must be represented by doubled single quotes {@code ''} throughout a\n- * <i>String<\/i>.  For example, pattern string <code>\"'{''}'\"<\/code> is\n- * interpreted as a sequence of <code>'{<\/code> (start of quoting and a\n- * left curly brace), {@code ''} (a single quote), and\n- * <code>}'<\/code> (a right curly brace and end of quoting),\n- * <em>not<\/em> <code>'{'<\/code> and <code>'}'<\/code> (quoted left and\n- * right curly braces): representing string <code>\"{'}\"<\/code>,\n- * <em>not<\/em> <code>\"{}\"<\/code>.\n- *\n- * <p>A <i>SubformatPattern<\/i> is interpreted by its corresponding\n- * subformat, and subformat-dependent pattern rules apply. For example,\n- * pattern string <code>\"{1,number,<u>$'#',##<\/u>}\"<\/code>\n- * (<i>SubformatPattern<\/i> with underline) will produce a number format\n- * with the pound-sign quoted, with a result such as: {@code\n- * \"$#31,45\"}. Refer to each {@code Format} subclass documentation for\n- * details.\n- *\n- * <p>Any unmatched quote is treated as closed at the end of the given\n- * pattern. For example, pattern string {@code \"'{0}\"} is treated as\n- * pattern {@code \"'{0}'\"}.\n- *\n- * <p>Any curly braces within an unquoted pattern must be balanced. For\n- * example, <code>\"ab {0} de\"<\/code> and <code>\"ab '}' de\"<\/code> are\n- * valid patterns, but <code>\"ab {0'}' de\"<\/code>, <code>\"ab } de\"<\/code>\n- * and <code>\"''{''\"<\/code> are not.\n- *\n- * <dl><dt><b>Warning:<\/b><dd>The rules for using quotes within message\n- * format patterns unfortunately have shown to be somewhat confusing.\n- * In particular, it isn't always obvious to localizers whether single\n- * quotes need to be doubled or not. Make sure to inform localizers about\n- * the rules, and tell them (for example, by using comments in resource\n- * bundle source files) which strings will be processed by {@code MessageFormat}.\n- * Note that localizers may need to use single quotes in translated\n- * strings where the original version doesn't have them.\n- * <\/dl>\n@@ -146,2 +119,3 @@\n- * table shows how the values map to {@code Format} instances. Combinations not\n- * shown in the table are illegal. A <i>SubformatPattern<\/i> must\n+ * table shows how the values map to {@code Format} instances. These values\n+ * are case-insensitive when passed to {@link #applyPattern(String)}. Combinations\n+ * not shown in the table are illegal. A <i>SubformatPattern<\/i> must\n@@ -164,1 +138,1 @@\n- *       <th scope=\"row\" style=\"font-weight:normal\" rowspan=5>{@code number}\n+ *       <th scope=\"row\" style=\"font-weight:normal\" rowspan=7>{@code number}\n@@ -177,0 +151,34 @@\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code compact_short}\n+ *       <td>{@link NumberFormat#getCompactNumberInstance(Locale, NumberFormat.Style)\n+ *       NumberFormat.getCompactNumberInstance}{@code (getLocale(),} {@link NumberFormat.Style#SHORT})\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code compact_long}\n+ *       <td>{@link NumberFormat#getCompactNumberInstance(Locale, NumberFormat.Style)\n+ *       NumberFormat.getCompactNumberInstance}{@code (getLocale(),} {@link NumberFormat.Style#LONG})\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\"><i>SubformatPattern<\/i>\n+ *       <td>{@code new} {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols)\n+ *       DecimalFormat}{@code (subformatPattern,} {@link DecimalFormatSymbols#getInstance(Locale)\n+ *       DecimalFormatSymbols.getInstance}{@code (getLocale()))}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\" rowspan=6>{@code dtf_date}\n+ *       <th scope=\"row\" style=\"font-weight:normal\"><i>(none)<\/i>\n+ *       <td>{@link DateTimeFormatter#ofLocalizedDate(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedDate(}{@link java.time.format.FormatStyle#MEDIUM}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code short}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedDate(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedDate(}{@link java.time.format.FormatStyle#SHORT}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code medium}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedDate(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedDate(}{@link java.time.format.FormatStyle#MEDIUM}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code long}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedDate(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedDate(}{@link java.time.format.FormatStyle#LONG}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code full}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedDate(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedDate(}{@link java.time.format.FormatStyle#FULL}{@code ).withLocale(getLocale())}\n+ *    <tr>\n@@ -178,1 +186,70 @@\n- *       <td>{@code new} {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols) DecimalFormat}{@code (subformatPattern,} {@link DecimalFormatSymbols#getInstance(Locale) DecimalFormatSymbols.getInstance}{@code (getLocale()))}\n+ *       <td>{@link DateTimeFormatter#ofPattern(String, Locale)\n+ *       DateTimeFormatter.ofPattern}{@code (subformatPattern, getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\" rowspan=6>{@code dtf_time}\n+ *       <th scope=\"row\" style=\"font-weight:normal\"><i>(none)<\/i>\n+ *       <td>{@link DateTimeFormatter#ofLocalizedTime(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedTime(}{@link java.time.format.FormatStyle#MEDIUM}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code short}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedTime(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedTime(}{@link java.time.format.FormatStyle#SHORT}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code medium}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedTime(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedTime(}{@link java.time.format.FormatStyle#MEDIUM}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code long}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedTime(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedTime(}{@link java.time.format.FormatStyle#LONG}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code full}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedTime(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedTime(}{@link java.time.format.FormatStyle#FULL}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\"><i>SubformatPattern<\/i>\n+ *       <td>{@link DateTimeFormatter#ofPattern(String, Locale)   DateTimeFormatter.ofPattern}{@code (subformatPattern, getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\" rowspan=6>{@code dtf_datetime}\n+ *       <th scope=\"row\" style=\"font-weight:normal\"><i>(none)<\/i>\n+ *       <td>{@link DateTimeFormatter#ofLocalizedDateTime(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedDateTime(}{@link java.time.format.FormatStyle#MEDIUM}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code short}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedDateTime(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedDateTime(}{@link java.time.format.FormatStyle#SHORT}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code medium}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedDateTime(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedDateTime(}{@link java.time.format.FormatStyle#MEDIUM}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code long}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedDateTime(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedDateTime(}{@link java.time.format.FormatStyle#LONG}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code full}\n+ *       <td>{@link DateTimeFormatter#ofLocalizedDateTime(java.time.format.FormatStyle)\n+ *       DateTimeFormatter.ofLocalizedDateTime(}{@link java.time.format.FormatStyle#FULL}{@code ).withLocale(getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\"><i>SubformatPattern<\/i>\n+ *       <td>{@link DateTimeFormatter#ofPattern(String, Locale)\n+ *       DateTimeFormatter.ofPattern}{@code (subformatPattern, getLocale())}\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\" rowspan=1>{@code pre-defined DateTimeFormatter(s)}\n+ *       <th scope=\"row\" style=\"font-weight:normal\"><i>(none)<\/i>\n+ *       <td>The {@code pre-defined DateTimeFormatter(s)} are used as a {@code FormatType} :\n+ *       {@link DateTimeFormatter#BASIC_ISO_DATE BASIC_ISO_DATE},\n+ *       {@link DateTimeFormatter#ISO_LOCAL_DATE ISO_LOCAL_DATE},\n+ *       {@link DateTimeFormatter#ISO_OFFSET_DATE ISO_OFFSET_DATE},\n+ *       {@link DateTimeFormatter#ISO_DATE ISO_DATE},\n+ *       {@link DateTimeFormatter#ISO_LOCAL_TIME ISO_LOCAL_TIME},\n+ *       {@link DateTimeFormatter#ISO_OFFSET_TIME ISO_OFFSET_TIME},\n+ *       {@link DateTimeFormatter#ISO_TIME ISO_TIME},\n+ *       {@link DateTimeFormatter#ISO_LOCAL_DATE_TIME ISO_LOCAL_DATE_TIME},\n+ *       {@link DateTimeFormatter#ISO_OFFSET_DATE_TIME ISO_OFFSET_DATE_TIME},\n+ *       {@link DateTimeFormatter#ISO_ZONED_DATE_TIME ISO_ZONED_DATE_TIME},\n+ *       {@link DateTimeFormatter#ISO_DATE_TIME ISO_DATE_TIME},\n+ *       {@link DateTimeFormatter#ISO_ORDINAL_DATE ISO_ORDINAL_DATE},\n+ *       {@link DateTimeFormatter#ISO_WEEK_DATE ISO_WEEK_DATE},\n+ *       {@link DateTimeFormatter#ISO_INSTANT ISO_INSTANT},\n+ *       {@link DateTimeFormatter#RFC_1123_DATE_TIME RFC_1123_DATE_TIME}\n@@ -182,1 +259,2 @@\n- *       <td>{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}\n+ *       <td>{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}\n+ *       {@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}\n@@ -185,1 +263,2 @@\n- *       <td>{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}\n+ *       <td>{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}\n+ *       {@code (}{@link DateFormat#SHORT}{@code , getLocale())}\n@@ -188,1 +267,2 @@\n- *       <td>{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}\n+ *       <td>{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}\n+ *       {@code (}{@link DateFormat#MEDIUM}{@code , getLocale())}\n@@ -191,1 +271,2 @@\n- *       <td>{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}\n+ *       <td>{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}\n+ *       {@code (}{@link DateFormat#LONG}{@code , getLocale())}\n@@ -194,1 +275,2 @@\n- *       <td>{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}\n+ *       <td>{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}\n+ *       {@code (}{@link DateFormat#FULL}{@code , getLocale())}\n@@ -197,1 +279,2 @@\n- *       <td>{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}\n+ *       <td>{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale)\n+ *       SimpleDateFormat}{@code (subformatPattern, getLocale())}\n@@ -201,1 +284,2 @@\n- *       <td>{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}\n+ *       <td>{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}\n+ *       {@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}\n@@ -204,1 +288,2 @@\n- *       <td>{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}\n+ *       <td>{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}\n+ *       {@code (}{@link DateFormat#SHORT}{@code , getLocale())}\n@@ -207,1 +292,2 @@\n- *       <td>{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}\n+ *       <td>{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}\n+ *       {@code (}{@link DateFormat#MEDIUM}{@code , getLocale())}\n@@ -210,1 +296,2 @@\n- *       <td>{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}\n+ *       <td>{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}\n+ *       {@code (}{@link DateFormat#LONG}{@code , getLocale())}\n@@ -213,1 +300,2 @@\n- *       <td>{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}\n+ *       <td>{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}\n+ *       {@code (}{@link DateFormat#FULL}{@code , getLocale())}\n@@ -216,1 +304,2 @@\n- *       <td>{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}\n+ *       <td>{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale)\n+ *       SimpleDateFormat}{@code (subformatPattern, getLocale())}\n@@ -221,0 +310,13 @@\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\" rowspan=3>{@code list}\n+ *       <th scope=\"row\" style=\"font-weight:normal\"><i>(none)<\/i>\n+ *       <td>{@link ListFormat#getInstance(Locale, ListFormat.Type, ListFormat.Style)\n+ *       ListFormat.getInstance}{@code (getLocale()}, {@link ListFormat.Type#STANDARD}, {@link ListFormat.Style#FULL})\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code or}\n+ *       <td>{@link ListFormat#getInstance(Locale, ListFormat.Type, ListFormat.Style)\n+ *       ListFormat.getInstance}{@code (getLocale()}, {@link ListFormat.Type#OR}, {@link ListFormat.Style#FULL})\n+ *    <tr>\n+ *       <th scope=\"row\" style=\"font-weight:normal\">{@code unit}\n+ *       <td>{@link ListFormat#getInstance(Locale, ListFormat.Type, ListFormat.Style)\n+ *       ListFormat.getInstance}{@code (getLocale()}, {@link ListFormat.Type#UNIT}, {@link ListFormat.Style#FULL}}\n@@ -224,1 +326,43 @@\n- * <h3>Usage Information<\/h3>\n+ * <h3>Quoting Rules in Patterns<\/h3>\n+ *\n+ * <p>Within a <i>String<\/i>, a pair of single quotes can be used to\n+ * quote any arbitrary characters except single quotes. For example,\n+ * pattern string <code>\"'{0}'\"<\/code> represents string\n+ * <code>\"{0}\"<\/code>, not a <i>FormatElement<\/i>. A single quote itself\n+ * must be represented by doubled single quotes {@code ''} throughout a\n+ * <i>String<\/i>.  For example, pattern string <code>\"'{''}'\"<\/code> is\n+ * interpreted as a sequence of <code>'{<\/code> (start of quoting and a\n+ * left curly brace), {@code ''} (a single quote), and\n+ * <code>}'<\/code> (a right curly brace and end of quoting),\n+ * <em>not<\/em> <code>'{'<\/code> and <code>'}'<\/code> (quoted left and\n+ * right curly braces): representing string <code>\"{'}\"<\/code>,\n+ * <em>not<\/em> <code>\"{}\"<\/code>.\n+ *\n+ * <p>A <i>SubformatPattern<\/i> is interpreted by its corresponding\n+ * subformat, and subformat-dependent pattern rules apply. For example,\n+ * pattern string <code>\"{1,number,<u>$'#',##<\/u>}\"<\/code>\n+ * (<i>SubformatPattern<\/i> with underline) will produce a number format\n+ * with the pound-sign quoted, with a result such as: {@code\n+ * \"$#31,45\"}. Refer to each {@code Format} subclass documentation for\n+ * details.\n+ *\n+ * <p>Any unmatched quote is treated as closed at the end of the given\n+ * pattern. For example, pattern string {@code \"'{0}\"} is treated as\n+ * pattern {@code \"'{0}'\"}.\n+ *\n+ * <p>Any curly braces within an unquoted pattern must be balanced. For\n+ * example, <code>\"ab {0} de\"<\/code> and <code>\"ab '}' de\"<\/code> are\n+ * valid patterns, but <code>\"ab {0'}' de\"<\/code>, <code>\"ab } de\"<\/code>\n+ * and <code>\"''{''\"<\/code> are not.\n+ *\n+ * <dl><dt><b>Warning:<\/b><dd>The rules for using quotes within message\n+ * format patterns unfortunately have shown to be somewhat confusing.\n+ * In particular, it isn't always obvious to localizers whether single\n+ * quotes need to be doubled or not. Make sure to inform localizers about\n+ * the rules, and tell them (for example, by using comments in resource\n+ * bundle source files) which strings will be processed by {@code MessageFormat}.\n+ * Note that localizers may need to use single quotes in translated\n+ * strings where the original version doesn't have them.\n+ * <\/dl>\n+ *\n+ * <h2>Usage Information<\/h2>\n@@ -227,4 +371,4 @@\n- * Here are some examples of usage.\n- * In real internationalized programs, the message format pattern and other\n- * static strings will, of course, be obtained from resource bundles.\n- * Other parameters will be dynamically determined at runtime.\n+ * The following example demonstrates a general usage of {@code MessageFormat}.\n+ * In internationalized programs, the message format pattern and other\n+ * static strings will likely be obtained from resource bundles.\n+ *\n@@ -232,2 +376,0 @@\n- * The first example uses the static method {@code MessageFormat.format},\n- * which internally creates a {@code MessageFormat} for one-time use:\n@@ -237,1 +379,0 @@\n- *\n@@ -240,1 +381,1 @@\n- *     planet, new Date(), event);\n+ *     planet, new GregorianCalendar(2053, Calendar.JULY, 3, 12, 30).getTime(), event);\n@@ -242,4 +383,0 @@\n- * The output is:\n- * <blockquote><pre>\n- * At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.\n- * <\/pre><\/blockquote>\n@@ -247,14 +384,1 @@\n- * <p>\n- * The following example creates a {@code MessageFormat} instance that\n- * can be used repeatedly:\n- * {@snippet lang=java :\n- * int fileCount = 1273;\n- * String diskName = \"MyDisk\";\n- * Object[] testArgs = {Long.valueOf(fileCount), diskName};\n- *\n- * MessageFormat form = new MessageFormat(\n- *     \"The disk \\\"{1}\\\" contains {0} file(s).\");\n- *\n- * System.out.println(form.format(testArgs));\n- * }\n- * The output with different values for {@code fileCount}:\n+ * {@code result} returns the following:\n@@ -262,3 +386,1 @@\n- * The disk \"MyDisk\" contains 0 file(s).\n- * The disk \"MyDisk\" contains 1 file(s).\n- * The disk \"MyDisk\" contains 1,273 file(s).\n+ * At 12:30:00 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.\n@@ -271,7 +393,3 @@\n- * MessageFormat msgFmt = new MessageFormat(\"The disk \\\"{0}\\\" contains {1}.\");\n- * double[] fileLimits = {0,1,2};\n- * String[] filePart = {\"no files\",\"one file\",\"{1,number} files\"};\n- * ChoiceFormat fileChoices = new ChoiceFormat(fileLimits, filePart);\n- * msgFmt.setFormatByArgumentIndex(1, fileChoices);\n- * Object[] args = {\"MyDisk\", 1273};\n- * System.out.println(msgFmt.format(args));\n+ * MessageFormat msgFmt = new MessageFormat(\"The disk \\\"{0}\\\" contains {1,choice,0#no files|1#one file|1< {1,number,integer} files}.\");\n+ * Object[] args = {\"MyDisk\", fileCount};\n+ * String result = msgFmt.format(args);\n@@ -279,1 +397,2 @@\n- * The output with different values for {@code fileCount}:\n+ *\n+ * {@code result} with different values for {@code fileCount}, returns the following:\n@@ -287,9 +406,0 @@\n- * You can create the {@code ChoiceFormat} programmatically, as in the\n- * above example, or by using a pattern. See {@link ChoiceFormat}\n- * for more information.\n- * {@snippet lang=java :\n- * msgFmt.applyPattern(\n- *    \"There {0,choice,0#are no files|1#is one file|1<are {1,number,integer} files}.\");\n- * }\n- *\n- * <p>\n@@ -307,0 +417,29 @@\n+ *\n+ * <h2>Formatting Date and Time<\/h2>\n+ *\n+ * MessageFormat provides patterns that support the date\/time formatters in the\n+ * {@link java.time.format} and {@link java.text} packages. Consider the following three examples,\n+ * with a date of 11\/16\/2023:\n+ *\n+ * <p>1) a <i>date<\/i> {@code FormatType} with a <i>full<\/i> {@code FormatStyle},\n+ * {@snippet lang=java :\n+ * Object[] arg = {new GregorianCalendar(2023, Calendar.NOVEMBER, 16).getTime()};\n+ * var fmt = new MessageFormat(\"The date was {0,date,full}\");\n+ * fmt.format(arg); \/\/ returns \"The date was Thursday, November 16, 2023\"\n+ * }\n+ *\n+ * <p>2) a <i>dtf_date<\/i> {@code FormatType} with a <i>full<\/i> {@code FormatStyle},\n+ * {@snippet lang=java :\n+ * Object[] arg = {LocalDate.of(2023, 11, 16)};\n+ * var fmt = new MessageFormat(\"The date was {0,dtf_date,full}\");\n+ * fmt.format(arg); \/\/ returns \"The date was Thursday, November 16, 2023\"\n+ * }\n+ *\n+ * <p>3) an <i>ISO_LOCAL_DATE<\/i> {@code FormatType},\n+ * {@snippet lang=java :\n+ * Object[] arg = {LocalDate.of(2023, 11, 16)};\n+ * var fmt = new MessageFormat(\"The date was {0,ISO_LOCAL_DATE}\");\n+ * fmt.format(arg); \/\/ returns \"The date was 2023-11-16\"\n+ * }\n+ *\n+ * <h3>Parsing<\/h3>\n@@ -346,0 +485,1 @@\n+ * @see          DateTimeFormatter\n@@ -516,1 +656,1 @@\n-                                makeFormat(i, formatNumber, segments);\n+                                setFormatFromPattern(i, formatNumber, segments);\n@@ -552,1 +692,3 @@\n-     * Returns a pattern representing the current state of the message format.\n+     * {@return a String pattern adhering to the {@link ##patterns patterns section} that\n+     * represents the current state of this {@code MessageFormat}}\n+     *\n@@ -559,3 +701,3 @@\n-     * is semantically equivalent to this instance.\n-     *\n-     * @return a pattern representing the current state of the message format\n+     * is semantically equivalent to this instance. If a subformat cannot be\n+     * converted to a String pattern, the {@code FormatType} and {@code FormatStyle}\n+     * will be omitted from the {@code FormatElement}.\n@@ -570,40 +712,49 @@\n-            result.append('{').append(argumentNumbers[i]);\n-            Format fmt = formats[i];\n-            String subformatPattern = null;\n-            if (fmt == null) {\n-                \/\/ do nothing, string format\n-            } else if (fmt instanceof NumberFormat) {\n-                if (fmt.equals(NumberFormat.getInstance(locale))) {\n-                    result.append(\",number\");\n-                } else if (fmt.equals(NumberFormat.getCurrencyInstance(locale))) {\n-                    result.append(\",number,currency\");\n-                } else if (fmt.equals(NumberFormat.getPercentInstance(locale))) {\n-                    result.append(\",number,percent\");\n-                } else if (fmt.equals(NumberFormat.getIntegerInstance(locale))) {\n-                    result.append(\",number,integer\");\n-                } else {\n-                    if (fmt instanceof DecimalFormat dfmt) {\n-                        result.append(\",number\");\n-                        subformatPattern = dfmt.toPattern();\n-                    } else if (fmt instanceof ChoiceFormat cfmt) {\n-                        result.append(\",choice\");\n-                        subformatPattern = cfmt.toPattern();\n-                    } else {\n-                        \/\/ UNKNOWN\n-                    }\n-                }\n-            } else if (fmt instanceof DateFormat) {\n-                int index;\n-                for (index = MODIFIER_DEFAULT; index < DATE_TIME_MODIFIERS.length; index++) {\n-                    DateFormat df = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[index],\n-                                                               locale);\n-                    if (fmt.equals(df)) {\n-                        result.append(\",date\");\n-                        break;\n-                    }\n-                    df = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[index],\n-                                                    locale);\n-                    if (fmt.equals(df)) {\n-                        result.append(\",time\");\n-                        break;\n-                    }\n+            result.append('{')\n+                    .append(argumentNumbers[i])\n+                    .append(patternFromFormat(formats[i]))\n+                    .append('}');\n+        }\n+        copyAndFixQuotes(pattern, lastOffset, pattern.length(), result);\n+        return result.toString();\n+    }\n+\n+    \/**\n+     * This method converts a Format into a {@code FormatType} and {@code\n+     * FormatStyle}, if applicable. For each Format, this method will\n+     * first check against the pre-defined styles established in the\n+     * {@link ##patterns patterns section}. Any \"default\"\/\"medium\" styles\n+     * are omitted according to the specification.\n+     * If a Format does not match to a pre-defined style, it will provide the\n+     * {@code SubformatPattern}, if the Format class can provide one. The\n+     * following subformats do not provide a {@code SubformatPattern}:\n+     * CompactNumberFormat, ListFormat, and DateTimeFormatter (ClassicFormat).\n+     *\n+     * <p>In addition, since DateTimeFormatter and ClassicFormat do not implement {@code equals()},\n+     * there is not a means to compare {@code fmt} to a ClassicFormat for equality,\n+     * and thus we don't have enough info to represent it as a pattern since there is no way to check\n+     * if {@code fmt} is equal to some, (for example, \"long\" style) pre-defined ClassicFormat.\n+     * Even if ClassicFormat implemented equals(), it is a wrapper class for\n+     * DateTimeFormatter, which would require DTF to implement equals() as well to effectively\n+     * compare the two ClassicFormats.\n+     *\/\n+    private String patternFromFormat(Format fmt) {\n+        if (fmt instanceof NumberFormat nFmt) {\n+            \/\/ Check nFmt factory instances\n+            String nStyle = NumberFormat.matchToStyle(nFmt, locale);\n+            if (nStyle != null) {\n+                return \",number\" + (nStyle.isEmpty() ? nStyle : \",\" + nStyle);\n+            }\n+            \/\/ Check SubformatPattern\n+            if (fmt instanceof DecimalFormat dFmt) {\n+                \/\/ Quote eligible mFmt pattern characters: '{' and '}'\n+                \/\/ Here, and in other subformatPattern instances\n+                return \",number,\" + copyAndQuoteBraces(dFmt.toPattern());\n+            } else if (fmt instanceof ChoiceFormat cFmt) {\n+                return \",choice,\" + copyAndQuoteBraces(cFmt.toPattern());\n+            }\n+        } else if (fmt instanceof DateFormat) {\n+            \/\/ Check dFmt factory instances\n+            for (DateFormat.Style style : DateFormat.Style.values()) {\n+                if (fmt.equals(DateFormat.getDateInstance(style.getValue(), locale))) {\n+                    return \",date\" + ((style.getValue() != DateFormat.DEFAULT)\n+                            ? \",\" + style.name().toLowerCase(Locale.ROOT) : \"\");\n@@ -611,9 +762,3 @@\n-                if (index >= DATE_TIME_MODIFIERS.length) {\n-                    if (fmt instanceof SimpleDateFormat sdfmt) {\n-                        result.append(\",date\");\n-                        subformatPattern = sdfmt.toPattern();\n-                    } else {\n-                        \/\/ UNKNOWN\n-                    }\n-                } else if (index != MODIFIER_DEFAULT) {\n-                    result.append(',').append(DATE_TIME_MODIFIER_KEYWORDS[index]);\n+                if (fmt.equals(DateFormat.getTimeInstance(style.getValue(), locale))) {\n+                    return \",time\" + ((style.getValue() != DateFormat.DEFAULT)\n+                            ? \",\" + style.name().toLowerCase(Locale.ROOT) : \"\");\n@@ -621,2 +766,0 @@\n-            } else {\n-                \/\/result.append(\", unknown\");\n@@ -624,7 +767,11 @@\n-            if (subformatPattern != null) {\n-                result.append(',');\n-\n-                \/\/ The subformat pattern comes already quoted, but only for those characters that are\n-                \/\/ special to the subformat. Therefore, we may need to quote additional characters.\n-                \/\/ The ones we care about at the MessageFormat level are '{' and '}'.\n-                copyAndQuoteBraces(subformatPattern, result);\n+            \/\/ Check SubformatPattern\n+            if (fmt instanceof SimpleDateFormat sdFmt) {\n+                return \",date,\" + copyAndQuoteBraces(sdFmt.toPattern());\n+            }\n+        } else if (fmt instanceof ListFormat) {\n+            \/\/ Check lFmt factory instances\n+            for (ListFormat.Type type : ListFormat.Type.values()) {\n+                if (fmt.equals(ListFormat.getInstance(locale, type, ListFormat.Style.FULL))) {\n+                    return \",list\" + ((type != ListFormat.Type.STANDARD)\n+                            ? \",\" + type.name().toLowerCase(Locale.ROOT) : \"\");\n+                }\n@@ -632,1 +779,0 @@\n-            result.append('}');\n@@ -634,2 +780,3 @@\n-        copyAndFixQuotes(pattern, lastOffset, pattern.length(), result);\n-        return result.toString();\n+        \/\/ By here, this is an instanceof Format that is unknown to MessageFormat.\n+        \/\/ Since it is unknown, nothing can be done.\n+        return \"\";\n@@ -697,3 +844,2 @@\n-        for (int i = 0; i < runsToCopy; i++) {\n-            formats[i] = newFormats[i];\n-        }\n+        if (runsToCopy >= 0)\n+            System.arraycopy(newFormats, 0, formats, 0, runsToCopy);\n@@ -1066,1 +1212,1 @@\n-                    if (!strValue.equals(\"{\"+argumentNumbers[i]+\"}\"))\n+                    if (!strValue.equals(\"{\" + argumentNumbers[i] + \"}\"))\n@@ -1453,59 +1599,15 @@\n-    private static final int SEG_RAW      = 0;\n-    private static final int SEG_INDEX    = 1;\n-    private static final int SEG_TYPE     = 2;\n-    private static final int SEG_MODIFIER = 3; \/\/ modifier or subformat\n-\n-    \/\/ Indices for type keywords\n-    private static final int TYPE_NULL    = 0;\n-    private static final int TYPE_NUMBER  = 1;\n-    private static final int TYPE_DATE    = 2;\n-    private static final int TYPE_TIME    = 3;\n-    private static final int TYPE_CHOICE  = 4;\n-\n-    private static final String[] TYPE_KEYWORDS = {\n-        \"\",\n-        \"number\",\n-        \"date\",\n-        \"time\",\n-        \"choice\"\n-    };\n-\n-    \/\/ Indices for number modifiers\n-    private static final int MODIFIER_DEFAULT  = 0; \/\/ common in number and date-time\n-    private static final int MODIFIER_CURRENCY = 1;\n-    private static final int MODIFIER_PERCENT  = 2;\n-    private static final int MODIFIER_INTEGER  = 3;\n-\n-    private static final String[] NUMBER_MODIFIER_KEYWORDS = {\n-        \"\",\n-        \"currency\",\n-        \"percent\",\n-        \"integer\"\n-    };\n-\n-    \/\/ Indices for date-time modifiers\n-    private static final int MODIFIER_SHORT   = 1;\n-    private static final int MODIFIER_MEDIUM  = 2;\n-    private static final int MODIFIER_LONG    = 3;\n-    private static final int MODIFIER_FULL    = 4;\n-\n-    private static final String[] DATE_TIME_MODIFIER_KEYWORDS = {\n-        \"\",\n-        \"short\",\n-        \"medium\",\n-        \"long\",\n-        \"full\"\n-    };\n-\n-    \/\/ Date-time style values corresponding to the date-time modifiers.\n-    private static final int[] DATE_TIME_MODIFIERS = {\n-        DateFormat.DEFAULT,\n-        DateFormat.SHORT,\n-        DateFormat.MEDIUM,\n-        DateFormat.LONG,\n-        DateFormat.FULL,\n-    };\n-\n-    private void makeFormat(int position, int offsetNumber,\n-                            StringBuilder[] textSegments)\n-    {\n+    private static final int SEG_RAW      = 0; \/\/ String in MessageFormatPattern\n+    private static final int SEG_INDEX    = 1; \/\/ ArgumentIndex\n+    private static final int SEG_TYPE     = 2; \/\/ FormatType\n+    private static final int SEG_MODIFIER = 3; \/\/ FormatStyle\n+\n+    \/**\n+     * This method sets a Format in the {@code formats} array for the\n+     * corresponding {@code argumentNumber} based on the pattern supplied.\n+     * If the pattern supplied does not contain a {@code FormatType}, null\n+     * is stored in the {@code formats} array.\n+     *\/\n+    private void setFormatFromPattern(int position, int offsetNumber,\n+                            StringBuilder[] textSegments) {\n+\n+        \/\/ Convert any null values in textSegments to empty string\n@@ -1544,0 +1646,1 @@\n+\n@@ -1549,2 +1652,1 @@\n-        \/\/ now get the format\n-        Format newFormat = null;\n+        \/\/ Only search for corresponding type\/style if type is not empty\n@@ -1552,67 +1654,4 @@\n-            int type = findKeyword(segments[SEG_TYPE], TYPE_KEYWORDS);\n-            switch (type) {\n-            case TYPE_NULL:\n-                \/\/ Type \"\" is allowed. e.g., \"{0,}\", \"{0,,}\", and \"{0,,#}\"\n-                \/\/ are treated as \"{0}\".\n-                break;\n-\n-            case TYPE_NUMBER:\n-                switch (findKeyword(segments[SEG_MODIFIER], NUMBER_MODIFIER_KEYWORDS)) {\n-                case MODIFIER_DEFAULT:\n-                    newFormat = NumberFormat.getInstance(locale);\n-                    break;\n-                case MODIFIER_CURRENCY:\n-                    newFormat = NumberFormat.getCurrencyInstance(locale);\n-                    break;\n-                case MODIFIER_PERCENT:\n-                    newFormat = NumberFormat.getPercentInstance(locale);\n-                    break;\n-                case MODIFIER_INTEGER:\n-                    newFormat = NumberFormat.getIntegerInstance(locale);\n-                    break;\n-                default: \/\/ DecimalFormat pattern\n-                    try {\n-                        newFormat = new DecimalFormat(segments[SEG_MODIFIER],\n-                                                      DecimalFormatSymbols.getInstance(locale));\n-                    } catch (IllegalArgumentException e) {\n-                        maxOffset = oldMaxOffset;\n-                        throw e;\n-                    }\n-                    break;\n-                }\n-                break;\n-\n-            case TYPE_DATE:\n-            case TYPE_TIME:\n-                int mod = findKeyword(segments[SEG_MODIFIER], DATE_TIME_MODIFIER_KEYWORDS);\n-                if (mod >= 0 && mod < DATE_TIME_MODIFIER_KEYWORDS.length) {\n-                    if (type == TYPE_DATE) {\n-                        newFormat = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[mod],\n-                                                               locale);\n-                    } else {\n-                        newFormat = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[mod],\n-                                                               locale);\n-                    }\n-                } else {\n-                    \/\/ SimpleDateFormat pattern\n-                    try {\n-                        newFormat = new SimpleDateFormat(segments[SEG_MODIFIER], locale);\n-                    } catch (IllegalArgumentException e) {\n-                        maxOffset = oldMaxOffset;\n-                        throw e;\n-                    }\n-                }\n-                break;\n-\n-            case TYPE_CHOICE:\n-                try {\n-                    \/\/ ChoiceFormat pattern\n-                    newFormat = new ChoiceFormat(segments[SEG_MODIFIER]);\n-                } catch (Exception e) {\n-                    maxOffset = oldMaxOffset;\n-                    throw new IllegalArgumentException(\"Choice Pattern incorrect: \"\n-                                                       + segments[SEG_MODIFIER], e);\n-                }\n-                break;\n-\n-            default:\n+            try {\n+                formats[offsetNumber] = formatFromPattern(segments[SEG_TYPE], segments[SEG_MODIFIER]);\n+            } catch (Exception e) {\n+                \/\/ Catch to reset maxOffset\n@@ -1620,2 +1659,1 @@\n-                throw new IllegalArgumentException(\"unknown format type: \" +\n-                                                   segments[SEG_TYPE]);\n+                throw e;\n@@ -1623,0 +1661,4 @@\n+        } else {\n+            \/\/ Type \"\" is allowed. e.g., \"{0,}\", \"{0,,}\", and \"{0,,#}\"\n+            \/\/ are treated as \"{0}\".\n+            formats[offsetNumber] = null;\n@@ -1624,1 +1666,0 @@\n-        formats[offsetNumber] = newFormat;\n@@ -1627,4 +1668,29 @@\n-    private static int findKeyword(String s, String[] list) {\n-        for (int i = 0; i < list.length; ++i) {\n-            if (s.equals(list[i]))\n-                return i;\n+    \/**\n+     * This method converts a {@code FormatType} and {@code FormatStyle} to a\n+     * {@code Format} value. The String parameters are converted\n+     * to their corresponding enum values FormatType and FormatStyle which are used\n+     * to return a {@code Format}. See the patterns section in the class\n+     * description for further detail on a MessageFormat pattern.\n+     *\n+     * @param type the {@code FormatType} in {@code FormatElement}\n+     * @param style the {@code FormatStyle} in {@code FormatElement}\n+     * @return a Format that corresponds to the corresponding {@code formatType}\n+     *         and {@code formatStyle}\n+     * @throws IllegalArgumentException if a Format cannot be produced from the\n+     *         type and style provided\n+     *\/\n+    private Format formatFromPattern(String type, String style) {\n+        \/\/ Get the type, if it's valid\n+        FormatType fType;\n+        try {\n+            fType = FormatType.valueOf(type.trim().toUpperCase(Locale.ROOT));\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ Invalid type throws exception\n+            throw new IllegalArgumentException(\"unknown format type: \" + type);\n+        }\n+        \/\/ Get the style if recognized, otherwise treat style as a SubformatPattern\n+        FormatStyle fStyle;\n+        try {\n+            fStyle = FormatStyle.fromString(style);\n+        } catch (IllegalArgumentException iae) {\n+            fStyle = FormatStyle.SUBFORMATPATTERN;\n@@ -1632,0 +1698,104 @@\n+        return switch (fType) {\n+            case NUMBER -> switch (fStyle) {\n+                case DEFAULT -> NumberFormat.getInstance(locale);\n+                case CURRENCY ->\n+                        NumberFormat.getCurrencyInstance(locale);\n+                case PERCENT ->\n+                        NumberFormat.getPercentInstance(locale);\n+                case INTEGER ->\n+                        NumberFormat.getIntegerInstance(locale);\n+                case COMPACT_SHORT ->\n+                        NumberFormat.getCompactNumberInstance(locale, NumberFormat.Style.SHORT);\n+                case COMPACT_LONG ->\n+                        NumberFormat.getCompactNumberInstance(locale, NumberFormat.Style.LONG);\n+                default -> formatFromSubformatPattern(fType, style);\n+            };\n+            case DATE -> switch (fStyle) {\n+                case DEFAULT ->\n+                        DateFormat.getDateInstance(DateFormat.DEFAULT, locale);\n+                case SHORT ->\n+                        DateFormat.getDateInstance(DateFormat.SHORT, locale);\n+                case MEDIUM ->\n+                        DateFormat.getDateInstance(DateFormat.MEDIUM, locale);\n+                case LONG ->\n+                        DateFormat.getDateInstance(DateFormat.LONG, locale);\n+                case FULL ->\n+                        DateFormat.getDateInstance(DateFormat.FULL, locale);\n+                default -> formatFromSubformatPattern(fType, style);\n+            };\n+            case TIME -> switch (fStyle) {\n+                case DEFAULT ->\n+                        DateFormat.getTimeInstance(DateFormat.DEFAULT, locale);\n+                case SHORT ->\n+                        DateFormat.getTimeInstance(DateFormat.SHORT, locale);\n+                case MEDIUM ->\n+                        DateFormat.getTimeInstance(DateFormat.MEDIUM, locale);\n+                case LONG ->\n+                        DateFormat.getTimeInstance(DateFormat.LONG, locale);\n+                case FULL ->\n+                        DateFormat.getTimeInstance(DateFormat.FULL, locale);\n+                default -> formatFromSubformatPattern(fType, style);\n+            };\n+            case DTF_DATE -> switch (fStyle) {\n+                case DEFAULT, MEDIUM ->\n+                        DateTimeFormatter.ofLocalizedDate(java.time.format.FormatStyle.MEDIUM).withLocale(locale).toFormat();\n+                case SHORT ->\n+                        DateTimeFormatter.ofLocalizedDate(java.time.format.FormatStyle.SHORT).withLocale(locale).toFormat();\n+                case LONG ->\n+                        DateTimeFormatter.ofLocalizedDate(java.time.format.FormatStyle.LONG).withLocale(locale).toFormat();\n+                case FULL ->\n+                        DateTimeFormatter.ofLocalizedDate(java.time.format.FormatStyle.FULL).withLocale(locale).toFormat();\n+                default -> formatFromSubformatPattern(fType, style);\n+            };\n+            case DTF_TIME -> switch (fStyle) {\n+                case DEFAULT, MEDIUM ->\n+                        DateTimeFormatter.ofLocalizedTime(java.time.format.FormatStyle.MEDIUM).withLocale(locale).toFormat();\n+                case SHORT ->\n+                        DateTimeFormatter.ofLocalizedTime(java.time.format.FormatStyle.SHORT).withLocale(locale).toFormat();\n+                case LONG ->\n+                        DateTimeFormatter.ofLocalizedTime(java.time.format.FormatStyle.LONG).withLocale(locale).toFormat();\n+                case FULL ->\n+                        DateTimeFormatter.ofLocalizedTime(java.time.format.FormatStyle.FULL).withLocale(locale).toFormat();\n+                default -> formatFromSubformatPattern(fType, style);\n+            };\n+            case DTF_DATETIME -> switch (fStyle) {\n+                case DEFAULT, MEDIUM ->\n+                        DateTimeFormatter.ofLocalizedDateTime(java.time.format.FormatStyle.MEDIUM).withLocale(locale).toFormat();\n+                case SHORT ->\n+                        DateTimeFormatter.ofLocalizedDateTime(java.time.format.FormatStyle.SHORT).withLocale(locale).toFormat();\n+                case LONG ->\n+                        DateTimeFormatter.ofLocalizedDateTime(java.time.format.FormatStyle.LONG).withLocale(locale).toFormat();\n+                case FULL ->\n+                        DateTimeFormatter.ofLocalizedDateTime(java.time.format.FormatStyle.FULL).withLocale(locale).toFormat();\n+                default -> formatFromSubformatPattern(fType, style);\n+            };\n+            case CHOICE -> formatFromSubformatPattern(fType, style);\n+            case LIST -> switch (fStyle) {\n+                case DEFAULT ->\n+                        ListFormat.getInstance(locale, ListFormat.Type.STANDARD, ListFormat.Style.FULL);\n+                case OR ->\n+                        ListFormat.getInstance(locale, ListFormat.Type.OR, ListFormat.Style.FULL);\n+                case UNIT ->\n+                        ListFormat.getInstance(locale, ListFormat.Type.UNIT, ListFormat.Style.FULL);\n+                \/\/ ListFormat does not provide a String pattern method\/constructor\n+                default -> formatFromSubformatPattern(fType, style);\n+            };\n+            \/\/ The DateTimeFormatter constants are only given as a type\n+            \/\/ Regardless of style, return the corresponding DTF constant\n+            case BASIC_ISO_DATE -> DateTimeFormatter.BASIC_ISO_DATE.toFormat();\n+            case ISO_LOCAL_DATE -> DateTimeFormatter.ISO_LOCAL_DATE.toFormat();\n+            case ISO_OFFSET_DATE -> DateTimeFormatter.ISO_OFFSET_DATE.toFormat();\n+            case ISO_DATE -> DateTimeFormatter.ISO_DATE.toFormat();\n+            case ISO_LOCAL_TIME -> DateTimeFormatter.ISO_LOCAL_TIME.toFormat();\n+            case ISO_OFFSET_TIME -> DateTimeFormatter.ISO_OFFSET_TIME.toFormat();\n+            case ISO_TIME -> DateTimeFormatter.ISO_TIME.toFormat();\n+            case ISO_LOCAL_DATE_TIME -> DateTimeFormatter.ISO_LOCAL_DATE_TIME.toFormat();\n+            case ISO_OFFSET_DATE_TIME -> DateTimeFormatter.ISO_OFFSET_DATE_TIME.toFormat();\n+            case ISO_ZONED_DATE_TIME -> DateTimeFormatter.ISO_ZONED_DATE_TIME.toFormat();\n+            case ISO_DATE_TIME -> DateTimeFormatter.ISO_DATE_TIME.toFormat();\n+            case ISO_ORDINAL_DATE -> DateTimeFormatter.ISO_ORDINAL_DATE.toFormat();\n+            case ISO_WEEK_DATE -> DateTimeFormatter.ISO_WEEK_DATE.toFormat();\n+            case ISO_INSTANT -> DateTimeFormatter.ISO_INSTANT.toFormat();\n+            case RFC_1123_DATE_TIME -> DateTimeFormatter.RFC_1123_DATE_TIME.toFormat();\n+        };\n+    }\n@@ -1633,6 +1803,40 @@\n-        \/\/ Try trimmed lowercase.\n-        String ls = s.trim().toLowerCase(Locale.ROOT);\n-        if (ls != s) {\n-            for (int i = 0; i < list.length; ++i) {\n-                if (ls.equals(list[i]))\n-                    return i;\n+    \/**\n+     * This method will attempt to return a subformat produced with the provided\n+     * SubformatPattern applied. If the subformat does not support SubformatPatterns\n+     * or the SubformatPattern is illegal to the subformat, an IllegalArgumentException\n+     * is thrown. To adhere to the specification, this method ensures if an underlying\n+     * exception is thrown, it is rethrown as an IllegalArgumentException unless\n+     * the underlying exception is itself an IAE, or an NPE.\n+     *\n+     * @param fType the enum type of the subformat\n+     * @param pattern the SubformatPattern to be applied\n+     * @return a Format that corresponds to the corresponding {@code fType}\n+     *         and {@code pattern}\n+     * @throws IllegalArgumentException if a Format cannot be produced from the\n+     *         type and SubformatPattern provided\n+     *\/\n+    private Format formatFromSubformatPattern(FormatType fType, String pattern) {\n+        \/\/ Modified for neater exception value if needed\n+        String type = fType.name().charAt(0) + fType.name().substring(1).toLowerCase(Locale.ROOT);\n+        try {\n+            return switch (fType) {\n+                case NUMBER -> new DecimalFormat(pattern, DecimalFormatSymbols.getInstance(locale));\n+                case DATE, TIME -> new SimpleDateFormat(pattern, locale);\n+                case DTF_DATE, DTF_TIME, DTF_DATETIME ->\n+                        DateTimeFormatter.ofPattern(pattern).toFormat();\n+                case CHOICE -> new ChoiceFormat(pattern);\n+                \/\/ These classe(s) do not support String patterns\n+                default -> throw new IllegalArgumentException(String.format(\n+                            \"Unexpected modifier for %s: %s\", type, pattern));\n+            };\n+        } catch (Exception e) {\n+            \/\/ getClass check over separate catch block to not catch the IAE subclasses\n+            \/\/ For example, ChoiceFormat can throw a NumberFormatException\n+            if (e.getClass() == IllegalArgumentException.class\n+                    || e.getClass() == NullPointerException.class) {\n+                \/\/ If IAE no need to wrap with another IAE\n+                \/\/ If NPE, it should be thrown as is (as specified)\n+                throw e;\n+            } else {\n+                throw new IllegalArgumentException(String.format(\n+                        \"%s pattern incorrect: %s\", type, pattern), e);\n@@ -1641,1 +1845,0 @@\n-        return -1;\n@@ -1671,2 +1874,4 @@\n-    \/\/ Copy the text, but add quotes around any quotables that aren't already quoted\n-    private static void copyAndQuoteBraces(String source, StringBuilder target) {\n+    \/\/ The subformat pattern comes already quoted, but only for those characters that are\n+    \/\/ special to the subformat. Therefore, we may need to quote additional characters.\n+    \/\/ The ones we care about at the MessageFormat level are '{' and '}'.\n+    private static String copyAndQuoteBraces(String source) {\n@@ -1679,0 +1884,1 @@\n+        StringBuilder quotedSource = new StringBuilder();\n@@ -1697,2 +1903,1 @@\n-            target.append(source);\n-            return;\n+            return source;\n@@ -1706,1 +1911,1 @@\n-                target.append(ch);          \/\/ doubling works whether quoted or not\n+                quotedSource.append(ch);          \/\/ doubling works whether quoted or not\n@@ -1708,1 +1913,1 @@\n-                target.append('\\'');\n+                quotedSource.append('\\'');\n@@ -1711,1 +1916,1 @@\n-            target.append(ch);\n+            quotedSource.append(ch);\n@@ -1714,1 +1919,71 @@\n-            target.append('\\'');\n+            quotedSource.append('\\'');\n+        }\n+\n+        return quotedSource.toString();\n+    }\n+\n+    \/\/ Corresponding to the FormatType pattern\n+    private enum FormatType {\n+        NUMBER,\n+        DATE,\n+        TIME,\n+        DTF_DATE,\n+        DTF_TIME,\n+        DTF_DATETIME,\n+        CHOICE,\n+        LIST,\n+\n+        \/\/ Pre-defined DateTimeFormatter types\n+        BASIC_ISO_DATE,\n+        ISO_LOCAL_DATE,\n+        ISO_OFFSET_DATE ,\n+        ISO_DATE,\n+        ISO_LOCAL_TIME,\n+        ISO_OFFSET_TIME,\n+        ISO_TIME,\n+        ISO_LOCAL_DATE_TIME,\n+        ISO_OFFSET_DATE_TIME,\n+        ISO_ZONED_DATE_TIME,\n+        ISO_DATE_TIME,\n+        ISO_ORDINAL_DATE,\n+        ISO_WEEK_DATE,\n+        ISO_INSTANT,\n+        RFC_1123_DATE_TIME;\n+    }\n+\n+    \/\/ Corresponding to the FormatStyle pattern\n+    private enum FormatStyle {\n+        DEFAULT(\"\"),\n+        SHORT(\"short\"),\n+        MEDIUM(\"medium\"),\n+        LONG(\"long\"),\n+        FULL(\"full\"),\n+        INTEGER(\"integer\"),\n+        CURRENCY(\"currency\"),\n+        PERCENT(\"percent\"),\n+        COMPACT_SHORT(\"compact_short\"),\n+        COMPACT_LONG(\"compact_long\"),\n+        OR(\"or\"),\n+        UNIT(\"unit\"),\n+        SUBFORMATPATTERN(null);\n+\n+        private final String text;\n+\n+        \/\/ Differs from FormatType in that the text String is\n+        \/\/ not guaranteed to match the Enum name, thus a text field is used\n+        FormatStyle(String text) {\n+            this.text = text;\n+        }\n+\n+        \/\/ This method returns a FormatStyle (excluding SUBFORMATPATTERN)\n+        \/\/ that matches the passed String. If no FormatStyle is found,\n+        \/\/ an IllegalArgumentException is thrown\n+        private static FormatStyle fromString(String text) {\n+            for (FormatStyle style : values()) {\n+                \/\/ Also check trimmed case-insensitive for historical reasons\n+                if (style != FormatStyle.SUBFORMATPATTERN &&\n+                        text.trim().compareToIgnoreCase(style.text) == 0) {\n+                    return style;\n+                }\n+            }\n+            throw new IllegalArgumentException();\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":602,"deletions":327,"binary":false,"changes":929,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -680,0 +680,27 @@\n+    \/**\n+     * This method compares the passed NumberFormat to a number of pre-defined\n+     * style NumberFormat instances, (created with the passed locale). Returns a\n+     * matching FormatStyle string if found, otherwise null.\n+     * This method is used by MessageFormat to provide string pattens for NumberFormat\n+     * Subformats. Any future pre-defined NumberFormat styles should be added to this method.\n+     *\/\n+    static String matchToStyle(NumberFormat fmt, Locale locale) {\n+        if (fmt.equals(NumberFormat.getInstance(locale))) {\n+            return \"\";\n+        } else if (fmt.equals(NumberFormat.getCurrencyInstance(locale))) {\n+            return \"currency\";\n+        } else if (fmt.equals(NumberFormat.getPercentInstance(locale))) {\n+            return \"percent\";\n+        } else if (fmt.equals(NumberFormat.getIntegerInstance(locale))) {\n+            return \"integer\";\n+        } else if (fmt.equals(NumberFormat.getCompactNumberInstance(locale,\n+                NumberFormat.Style.SHORT))) {\n+            return \"compact_short\";\n+        } else if (fmt.equals(NumberFormat.getCompactNumberInstance(locale,\n+                NumberFormat.Style.LONG))) {\n+            return \"compact_long\";\n+        } else {\n+            return null;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318761\n+ * @summary Test MessageFormatPattern ability to recognize and produce\n+ *          appropriate FormatType and FormatStyle for CompactNumberFormat.\n+ * @run junit CompactSubFormats\n+ *\/\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.MessageFormat;\n+import java.text.NumberFormat;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class CompactSubFormats {\n+\n+    \/\/ Ensure the built-in FormatType and FormatStyles for cnFmt are as expected\n+    @Test\n+    public void applyPatternTest() {\n+        var mFmt = new MessageFormat(\n+                \"{0,number,compact_short}{1,number,compact_long}\");\n+        var compactShort = NumberFormat.getCompactNumberInstance(\n+                mFmt.getLocale(), NumberFormat.Style.SHORT);\n+        var compactLong = NumberFormat.getCompactNumberInstance(\n+                mFmt.getLocale(), NumberFormat.Style.LONG);\n+        assertEquals(mFmt.getFormatsByArgumentIndex()[0], compactShort);\n+        assertEquals(mFmt.getFormatsByArgumentIndex()[1], compactLong);\n+    }\n+\n+    \/\/ Ensure that only 'compact_short' and 'compact_long' are recognized as\n+    \/\/ compact number modifiers. All other compact_XX should be interpreted as\n+    \/\/ a subformatPattern for a DecimalFormat\n+    @Test\n+    public void recognizedCompactStylesTest() {\n+        \/\/ An exception won't be thrown since 'compact_regular' will be interpreted as a\n+        \/\/ subformatPattern.\n+        assertEquals(new DecimalFormat(\"compact_regular\"),\n+                new MessageFormat(\"{0,number,compact_regular}\").getFormatsByArgumentIndex()[0]);\n+    }\n+\n+    \/\/ SHORT and LONG CompactNumberFormats should produce correct patterns\n+    @Test\n+    public void toPatternTest() {\n+        var mFmt = new MessageFormat(\"{0}{1}\");\n+        mFmt.setFormatByArgumentIndex(0, NumberFormat.getCompactNumberInstance(\n+                mFmt.getLocale(), NumberFormat.Style.SHORT));\n+        mFmt.setFormatByArgumentIndex(1, NumberFormat.getCompactNumberInstance(\n+                mFmt.getLocale(), NumberFormat.Style.LONG));\n+        assertEquals(\"{0,number,compact_short}{1,number,compact_long}\", mFmt.toPattern());\n+    }\n+\n+    \/\/ A custom cnFmt cannot be recognized, thus does not produce any built-in pattern\n+    @Test\n+    public void badToPatternTest() {\n+        var mFmt = new MessageFormat(\"{0}\");\n+        \/\/ Non-recognizable compactNumberFormat\n+        mFmt.setFormatByArgumentIndex(0, new CompactNumberFormat(\"\",\n+                        DecimalFormatSymbols.getInstance(Locale.US), new String[]{\"\"}));\n+        \/\/ Default behavior of unrecognizable Formats is a FormatElement\n+        \/\/ in the form of { ArgumentIndex }\n+        assertEquals(\"{0}\", mFmt.toPattern());\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/CompactSubFormats.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318761\n+ * @summary Test MessageFormatPattern ability to recognize and produce the\n+ *          appropriate FormatType and FormatStyle for ListFormat. ListFormat's\n+ *          STANDARD, OR, and UNIT types are supported as built-in patterns for\n+ *          MessageFormat. All types use the FULL style.\n+ * @run junit ListSubFormats\n+ *\/\n+\n+import java.text.ListFormat;\n+import java.text.MessageFormat;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class ListSubFormats {\n+\n+    \/\/ Recognize the 'list' FormatType as well as '', 'or', and\n+    \/\/ 'unit' associated FormatStyles\n+    @Test\n+    public void applyPatternTest() {\n+        var mFmt = new MessageFormat(\"{0,list}{1,list,or}{2,list,unit}\");\n+        var listStandard = ListFormat.getInstance(mFmt.getLocale(),\n+                ListFormat.Type.STANDARD, ListFormat.Style.FULL);\n+        var listOr = ListFormat.getInstance(mFmt.getLocale(),\n+                ListFormat.Type.OR, ListFormat.Style.FULL);\n+        var listUnit = ListFormat.getInstance(mFmt.getLocale(),\n+                ListFormat.Type.UNIT, ListFormat.Style.FULL);\n+        assertEquals(mFmt.getFormatsByArgumentIndex()[0], listStandard);\n+        assertEquals(mFmt.getFormatsByArgumentIndex()[1], listOr);\n+        assertEquals(mFmt.getFormatsByArgumentIndex()[2], listUnit);\n+    }\n+\n+    \/\/ Ensure incorrect FormatElement pattern throws IAE\n+    \/\/ java.text.ListFormat does not support String subformatPatterns\n+    @Test\n+    public void badApplyPatternTest() {\n+        \/\/ Wrong FormatStyle\n+        IllegalArgumentException exc = assertThrows(IllegalArgumentException.class, () ->\n+                new MessageFormat(\"{0,list,standard}\"));\n+        assertEquals(\"Unexpected modifier for List: standard\", exc.getMessage());\n+\n+        \/\/ Wrong FormatType\n+        exc = assertThrows(IllegalArgumentException.class, () ->\n+                new MessageFormat(\"{0,listt,or}\"));\n+        assertEquals(\"unknown format type: listt\", exc.getMessage());\n+\n+    }\n+\n+    \/\/ STANDARD, OR, UNIT ListFormats (with FULL style) should\n+    \/\/ produce correct patterns.\n+    @Test\n+    public void toPatternTest() {\n+        var mFmt = new MessageFormat(\"{0}{1}{2}\");\n+        mFmt.setFormatByArgumentIndex(0,\n+                ListFormat.getInstance(mFmt.getLocale(), ListFormat.Type.STANDARD, ListFormat.Style.FULL));\n+        mFmt.setFormatByArgumentIndex(1,\n+                ListFormat.getInstance(mFmt.getLocale(), ListFormat.Type.OR, ListFormat.Style.FULL));\n+        mFmt.setFormatByArgumentIndex(2,\n+                ListFormat.getInstance(mFmt.getLocale(), ListFormat.Type.UNIT, ListFormat.Style.FULL));\n+        assertEquals(\"{0,list}{1,list,or}{2,list,unit}\", mFmt.toPattern());\n+    }\n+\n+    \/\/ A custom ListFormat cannot be recognized, thus does not produce any built-in pattern\n+    @Test\n+    public void badToPatternTest() {\n+        var mFmt = new MessageFormat(\"{0}\");\n+        mFmt.setFormatByArgumentIndex(0,\n+                ListFormat.getInstance(mFmt.getLocale(), ListFormat.Type.UNIT, ListFormat.Style.NARROW));\n+        assertEquals(\"{0}\", mFmt.toPattern());\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/ListSubFormats.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 6481179 8039165\n+ * @bug 6481179 8039165 8318761\n@@ -42,0 +42,9 @@\n+    \/\/ Any exception for a Subformat should be re-thrown as propagated as an IAE\n+    \/\/ to the MessageFormat\n+    @Test\n+    public void rethrowAsIAE() {\n+        \/\/ Same Subformat pattern for ChoiceFormat throws NumberFormatException\n+        assertThrows(IllegalArgumentException.class,\n+                () -> new MessageFormat(\"{0,choice,0foo#foo}\"));\n+    }\n+\n@@ -60,0 +69,3 @@\n+        \/\/ Same as above, but with Subformat pattern\n+        assertThrows(NullPointerException.class,\n+                () -> new MessageFormat(\"{0, date,dd}\", null));\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/MessageFormatExceptions.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8318761\n+ * @summary Test MessageFormatPattern ability to recognize the appropriate\n+ *          FormatType and FormatStyle for DateTimeFormatter(ClassicFormat).\n+ *          This includes the types dtf_time, dtf_date, dtf_datetime,\n+ *          and the DateTimeFormatter predefined formatters.\n+ * @run junit TemporalSubFormats\n+ *\/\n+\n+import java.text.Format;\n+import java.text.MessageFormat;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.FormatStyle;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class TemporalSubFormats {\n+\n+    \/\/ Check that applying the built-in DateTimeFormatter types returns the\n+    \/\/ correct Format and formats properly. Patterns are case-insensitive\n+    @ParameterizedTest\n+    @MethodSource(\"preDefinedTypes\")\n+    public void preDefinedPatternsTest(String pattern, Format fmt) {\n+        var mFmt = new MessageFormat(\"quux{0,\"+pattern+\"}quux\");\n+        Object[] temporals = new Object[]{LocalDate.now(), LocalTime.now(),\n+                ZonedDateTime.now(), LocalDateTime.now(), OffsetDateTime.now(), Instant.now()};\n+        for (Object val : temporals) {\n+            \/\/ Wrap in Object array for MessageFormat\n+            Object[] wrappedVal = new Object[]{val};\n+\n+            try {\n+                String mFmtted = mFmt.format(wrappedVal);\n+                \/\/ If current format can support the time object. Check equality of result\n+                assertEquals(mFmtted, \"quux\"+fmt.format(val)+\"quux\");\n+            } catch (IllegalArgumentException ignored) {\n+                \/\/ Otherwise, ensure both throw IAE on unsupported field\n+                assertThrows(IllegalArgumentException.class, () -> fmt.format(val));\n+            }\n+        }\n+    }\n+\n+    \/\/ Provides String patterns and the associated (standalone) FormatType\n+    \/\/ Values should be case-insensitive\n+    private static Stream<Arguments> preDefinedTypes() {\n+        return Stream.of(\n+            Arguments.of(\"BASIC_ISO_DATE\", DateTimeFormatter.BASIC_ISO_DATE.toFormat()),\n+            Arguments.of(\"ISO_LOCAL_DATE\", DateTimeFormatter.ISO_LOCAL_DATE.toFormat()),\n+            Arguments.of(\"ISO_OFFSET_DATE\", DateTimeFormatter.ISO_OFFSET_DATE.toFormat()),\n+            Arguments.of(\"ISO_DATE\", DateTimeFormatter.ISO_DATE.toFormat()),\n+            Arguments.of(\"iso_local_time\", DateTimeFormatter.ISO_LOCAL_TIME.toFormat()),\n+            Arguments.of(\"ISO_OFFSET_TIME\", DateTimeFormatter.ISO_OFFSET_TIME.toFormat()),\n+            Arguments.of(\"iso_time\", DateTimeFormatter.ISO_TIME.toFormat()),\n+            Arguments.of(\"ISO_LOCAL_DATE_TIME\", DateTimeFormatter.ISO_LOCAL_DATE_TIME.toFormat()),\n+            Arguments.of(\"ISO_OFFSET_DATE_TIME\", DateTimeFormatter.ISO_OFFSET_DATE_TIME.toFormat()),\n+            Arguments.of(\"ISO_ZONED_DATE_TIME\", DateTimeFormatter.ISO_ZONED_DATE_TIME.toFormat()),\n+            Arguments.of(\"ISO_DATE_TIME\", DateTimeFormatter.ISO_DATE_TIME.toFormat()),\n+            Arguments.of(\"ISO_ORDINAL_DATE\", DateTimeFormatter.ISO_ORDINAL_DATE.toFormat()),\n+            Arguments.of(\"iso_week_date\", DateTimeFormatter.ISO_WEEK_DATE.toFormat()),\n+            Arguments.of(\"ISO_INSTANT\", DateTimeFormatter.ISO_INSTANT.toFormat()),\n+            Arguments.of(\"RFC_1123_DATE_TIME\", DateTimeFormatter.RFC_1123_DATE_TIME.toFormat())\n+        );\n+    }\n+\n+    \/\/ Check that the appropriate FormatType\/Style combo returns correct Format\n+    \/\/ Unlike the other pattern tests, the formatted output is used to check\n+    \/\/ equality, as DateTimeFormatter does not implement equals()\n+    @ParameterizedTest\n+    @MethodSource(\"styles\")\n+    public void applyPatternTest(String style, FormatStyle fStyle) {\n+        var time = ZonedDateTime.now();\n+        var date = LocalDate.now();\n+\n+        \/\/ Test dtf_date\n+        var dFmt = new MessageFormat(\"{0,dtf_date\"+style+\"}\");\n+        assertEquals(DateTimeFormatter.ofLocalizedDate(fStyle).withLocale(\n+                dFmt.getLocale()).toFormat().format(date),\n+                dFmt.getFormatsByArgumentIndex()[0].format(date));\n+\n+        \/\/ Test dtf_time\n+        var tFmt = new MessageFormat(\"{0,dtf_time\"+style+\"}\");\n+        assertEquals(DateTimeFormatter.ofLocalizedTime(fStyle).withLocale(\n+                tFmt.getLocale()).toFormat().format(time),\n+                tFmt.getFormatsByArgumentIndex()[0].format(time));\n+\n+        \/\/ Test dtf_datetime\n+        var dtFmt = new MessageFormat(\"{0,dtf_datetime\"+style+\"}\");\n+        assertEquals(DateTimeFormatter.ofLocalizedDateTime(fStyle).withLocale(\n+                        dtFmt.getLocale()).toFormat().format(time),\n+                dtFmt.getFormatsByArgumentIndex()[0].format(time));\n+    }\n+\n+    \/\/ Provides String patterns and the associated FormatStyle\n+    private static Stream<Arguments> styles() {\n+        return Stream.of(\n+                Arguments.of(\"\", FormatStyle.MEDIUM),\n+                Arguments.of(\",short\", FormatStyle.SHORT),\n+                Arguments.of(\",medium\", FormatStyle.MEDIUM),\n+                Arguments.of(\",long\", FormatStyle.LONG),\n+                Arguments.of(\",full\", FormatStyle.FULL)\n+        );\n+    }\n+\n+    \/\/ Test that a proper Format from a SubformatPattern can be reproduced\n+    @Test\n+    public void subformatPatternTest() {\n+        \/\/ SubformatPattern invokes the same method for both dtf_date,\n+        \/\/ dtf_time, and dtf_datetime\n+        var pattern = \"d MMM uuuu\";\n+        var date = LocalDate.now();\n+\n+        \/\/ Test dtf_date\n+        var dFmt = new MessageFormat(\"{0,dtf_date,\"+pattern+\"}\");\n+        assertEquals(DateTimeFormatter.ofPattern(pattern,dFmt.getLocale()).toFormat().format(date),\n+                dFmt.getFormatsByArgumentIndex()[0].format(date));\n+\n+        \/\/ Test dtf_time\n+        var tFmt = new MessageFormat(\"{0,dtf_time,\"+pattern+\"}\");\n+        assertEquals(DateTimeFormatter.ofPattern(pattern,tFmt.getLocale()).toFormat().format(date),\n+                tFmt.getFormatsByArgumentIndex()[0].format(date));\n+\n+        \/\/ Test dtf_datetime\n+        var dtFmt = new MessageFormat(\"{0,dtf_datetime,\"+pattern+\"}\");\n+        assertEquals(DateTimeFormatter.ofPattern(pattern,dtFmt.getLocale()).toFormat().format(date),\n+                dtFmt.getFormatsByArgumentIndex()[0].format(date));\n+    }\n+\n+    \/\/ Ensure that only the supported built-in FormatStyles or a\n+    \/\/ valid SubformatPattern are recognized\n+    @Test\n+    public void badApplyPatternTest() {\n+        \/\/ Not a supported FormatStyle: throws the underlying IAE from DTF\n+        \/\/ as it is interpreted as a subformatPattern\n+        IllegalArgumentException exc = assertThrows(IllegalArgumentException.class, () ->\n+                new MessageFormat(\"{0,dtf_date,longer}\"));\n+        assertEquals(\"Unknown pattern letter: l\", exc.getMessage());\n+\n+        \/\/ Not a legal SubformatPattern: throws the underlying IAE from DTF\n+        exc = assertThrows(IllegalArgumentException.class, () ->\n+                new MessageFormat(\"{0,dtf_date,VVV}\"));\n+        assertEquals(\"Pattern letter count must be 2: V\", exc.getMessage());\n+\n+        \/\/ Pre-defined ISO style does not exist and should be ignored\n+        assertDoesNotThrow(() -> new MessageFormat(\"{0,BASIC_ISO_DATE,foo}\"),\n+                \"Style on a pre-defined DTF should be ignored, instead of throwing an exception\");\n+    }\n+\n+    \/\/ DateTimeFormatters cannot be recognized when toPattern() is invoked\n+    \/\/ Default behavior of unrecognizable Formats is a FormatElement\n+    \/\/ in the form of { ArgumentIndex }\n+    @Test\n+    public void nonRecognizableToPatternTest() {\n+        \/\/ Check SubformatPattern\n+        var validPattern = \"yy\";\n+        var mFmt = new MessageFormat(\"{0}\");\n+        mFmt.setFormatByArgumentIndex(0, DateTimeFormatter.ofPattern(validPattern).toFormat());\n+        assertEquals(\"{0}\", mFmt.toPattern());\n+\n+        \/\/ Check pre-defined styles\n+        var dFmt = new MessageFormat(\"{0,dtf_date,long}\");\n+        assertEquals(\"{0}\", dFmt.toPattern());\n+        var tFmt = new MessageFormat(\"{0,dtf_time,long}\");\n+        assertEquals(\"{0}\", tFmt.toPattern());\n+        var dtFmt = new MessageFormat(\"{0,dtf_datetime,long}\");\n+        assertEquals(\"{0}\", dtFmt.toPattern());\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/TemporalSubFormats.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"}]}