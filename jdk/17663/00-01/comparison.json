{"files":[{"patch":"@@ -369,2 +369,2 @@\n- * MessageFormat provides patterns that support both the {@link java.time} package\n- * and the {@link Date java.util.Date} type. Consider the following three examples,\n+ * MessageFormat provides patterns that support the date\/time formatters in the\n+ * {@link java.time.format} and {@link java.text} packages. Consider the following three examples,\n@@ -375,1 +375,3 @@\n- * Object[] arg = {new Date(2023, 11, 16)};\n+ * Calendar cal = Calendar.getInstance();\n+ * cal.set(123 + 1900, 10, 16);\n+ * Object[] arg = {cal.getTime()};\n@@ -1635,1 +1637,1 @@\n-            fType = FormatType.fromString(type);\n+            fType = FormatType.valueOf(type.trim().toUpperCase(Locale.ROOT));\n@@ -1769,1 +1771,1 @@\n-        String type = fType.text.substring(0,1).toUpperCase(Locale.ROOT) + fType.text.substring(1);\n+        String type = fType.name().charAt(0) + fType.name().substring(1).toLowerCase(Locale.ROOT);\n@@ -1824,8 +1826,8 @@\n-        NUMBER(\"number\"),\n-        DATE(\"date\"),\n-        TIME(\"time\"),\n-        DTF_DATE(\"dtf_date\"),\n-        DTF_TIME(\"dtf_time\"),\n-        DTF_DATETIME(\"dtf_datetime\"),\n-        CHOICE(\"choice\"),\n-        LIST(\"list\"),\n+        NUMBER,\n+        DATE,\n+        TIME,\n+        DTF_DATE,\n+        DTF_TIME,\n+        DTF_DATETIME,\n+        CHOICE,\n+        LIST,\n@@ -1834,34 +1836,15 @@\n-        BASIC_ISO_DATE(\"BASIC_ISO_DATE\"),\n-        ISO_LOCAL_DATE(\"ISO_LOCAL_DATE\"),\n-        ISO_OFFSET_DATE (\"ISO_OFFSET_DATE\"),\n-        ISO_DATE(\"ISO_DATE\"),\n-        ISO_LOCAL_TIME(\"ISO_LOCAL_TIME\"),\n-        ISO_OFFSET_TIME(\"ISO_OFFSET_TIME\"),\n-        ISO_TIME(\"ISO_TIME\"),\n-        ISO_LOCAL_DATE_TIME(\"ISO_LOCAL_DATE_TIME\"),\n-        ISO_OFFSET_DATE_TIME(\"ISO_OFFSET_DATE_TIME\"),\n-        ISO_ZONED_DATE_TIME(\"ISO_ZONED_DATE_TIME\"),\n-        ISO_DATE_TIME(\"ISO_DATE_TIME\"),\n-        ISO_ORDINAL_DATE(\"ISO_ORDINAL_DATE\"),\n-        ISO_WEEK_DATE(\"ISO_WEEK_DATE\"),\n-        ISO_INSTANT(\"ISO_INSTANT\"),\n-        RFC_1123_DATE_TIME(\"RFC_1123_DATE_TIME\");\n-\n-        private final String text;\n-\n-        FormatType(String text){\n-            this.text = text;\n-        }\n-\n-        \/\/ This method returns a FormatType that matches the passed String.\n-        \/\/ If no matching FormatType is found, an IllegalArgumentException is thrown.\n-        private static FormatType fromString(String text) {\n-            for (FormatType other : values()) {\n-                \/\/ Also check trimmed lower case for historical reasons\n-                if (text.trim().toLowerCase(Locale.ROOT)\n-                        .equals(other.text.trim().toLowerCase(Locale.ROOT))) {\n-                    return other;\n-                }\n-            }\n-            throw new IllegalArgumentException();\n-        }\n+        BASIC_ISO_DATE,\n+        ISO_LOCAL_DATE,\n+        ISO_OFFSET_DATE ,\n+        ISO_DATE,\n+        ISO_LOCAL_TIME,\n+        ISO_OFFSET_TIME,\n+        ISO_TIME,\n+        ISO_LOCAL_DATE_TIME,\n+        ISO_OFFSET_DATE_TIME,\n+        ISO_ZONED_DATE_TIME,\n+        ISO_DATE_TIME,\n+        ISO_ORDINAL_DATE,\n+        ISO_WEEK_DATE,\n+        ISO_INSTANT,\n+        RFC_1123_DATE_TIME;\n@@ -1888,0 +1871,2 @@\n+        \/\/ Differs from FormatType in that the text String is\n+        \/\/ not guaranteed to match the Enum name, thus a text field is used\n@@ -1896,3 +1881,2 @@\n-                \/\/ Also check trimmed lower case for historical reasons\n-                if (text.equals(style.text)\n-                        || text.trim().toLowerCase(Locale.ROOT).equals(style.text)) {\n+                \/\/ Also check trimmed case-insensitive for historical reasons\n+                if (text.trim().toLowerCase(Locale.ROOT).equals(style.text)) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":34,"deletions":50,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -59,1 +58,3 @@\n-    \/\/ Ensure that only 'compact_short' and 'compact_long' are recognized\n+    \/\/ Ensure that only 'compact_short' and 'compact_long' are recognized as\n+    \/\/ compact number modifiers. All other compact_XX should be interpreted as\n+    \/\/ a subformatPattern for a DecimalFormat\n@@ -61,1 +62,1 @@\n-    public void badApplyPatternTest() {\n+    public void recognizedCompactStylesTest() {\n","filename":"test\/jdk\/java\/text\/Format\/MessageFormat\/CompactSubFormats.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}