{"files":[{"patch":"@@ -455,2 +455,1 @@\n-    _min_size_watermark(_size),\n-    _removed_last_uncommit_cycle(0) {}\n+    _min_size_watermark(_size) {}\n@@ -555,2 +554,1 @@\n-void ZMappedCache::reset_uncommit_cycle() {\n-  _removed_last_uncommit_cycle = 0;\n+void ZMappedCache::reset_uncommit_watermark() {\n@@ -564,7 +562,1 @@\n-size_t ZMappedCache::remove_for_uncommit(size_t max_size, ZArray<ZVirtualMemory>* out) {\n-  const size_t remove_allowed =\n-      _min_size_watermark < _removed_last_uncommit_cycle\n-          ? 0\n-          : _min_size_watermark - _removed_last_uncommit_cycle;\n-  const size_t size = MIN2(remove_allowed, max_size);\n-\n+size_t ZMappedCache::remove_for_uncommit(size_t size, ZArray<ZVirtualMemory>* out) {\n@@ -575,4 +567,1 @@\n-  const size_t removed = remove_discontiguous_with_strategy<RemovalStrategy::HighestAddress>(size, out);\n-  _removed_last_uncommit_cycle += removed;\n-\n-  return removed;\n+  return remove_discontiguous_with_strategy<RemovalStrategy::HighestAddress>(size, out);\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.cpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  size_t        _removed_last_uncommit_cycle;\n@@ -106,1 +105,1 @@\n-  void reset_uncommit_cycle();\n+  void reset_uncommit_watermark();\n@@ -108,1 +107,1 @@\n-  size_t remove_for_uncommit(size_t max_size, ZArray<ZVirtualMemory>* out);\n+  size_t remove_for_uncommit(size_t size, ZArray<ZVirtualMemory>* out);\n","filename":"src\/hotspot\/share\/gc\/z\/zMappedCache.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -106,0 +106,5 @@\n+    if (!activate_uncommit_cycle()) {\n+      \/\/ We failed activating a new cycle, continue until next cycle\n+      continue;\n+    }\n+\n@@ -113,0 +118,2 @@\n+      \/\/ 'uncommitted == 0' is a proxy for uncommit_cycle_is_canceled() without\n+      \/\/ having to take the page allocator lock\n@@ -153,1 +160,1 @@\n-      log_info(gc, heap)(\"Uncommitter (%u) Uncommitted: %zuM(%.0f%%) in %fs\",\n+      log_info(gc, heap)(\"Uncommitter (%u) Uncommitted: %zuM(%.0f%%) in %.3fms\",\n@@ -155,1 +162,1 @@\n-                         accumulated_time.seconds());\n+                         accumulated_time.seconds() * MILLIUNITS);\n@@ -168,0 +175,11 @@\n+void ZUncommitter::reset_uncommit_cycle() {\n+  _to_uncommit = 0;\n+  _uncommitted = 0;\n+  _cycle_start = 0.0;\n+  _cancel_time = 0.0;\n+\n+  postcond(uncommit_cycle_is_finished());\n+  postcond(!uncommit_cycle_is_canceled());\n+  postcond(!uncommit_cycle_is_active());\n+}\n+\n@@ -176,1 +194,1 @@\n-  precond(uncommit_cycle_is_active() || uncommit_cycle_is_canceled());\n+  precond(uncommit_cycle_is_active());\n@@ -187,8 +205,1 @@\n-  _to_uncommit = 0;\n-  _uncommitted = 0;\n-  _cycle_start = 0.0;\n-  _cancel_time = 0.0;\n-\n-  postcond(uncommit_cycle_is_finished());\n-  postcond(!uncommit_cycle_is_canceled());\n-  postcond(!uncommit_cycle_is_active());\n+  reset_uncommit_cycle();\n@@ -197,1 +208,9 @@\n-void ZUncommitter::activate_uncommit_cycle() {\n+bool ZUncommitter::activate_uncommit_cycle() {\n+  if (!should_continue()) {\n+    \/\/ We are stopping\n+    return false;\n+  }\n+\n+  \/\/ Lock\n+  ZLocker<ZLock> locker(&_partition->_page_allocator->_lock);\n+\n@@ -200,1 +219,10 @@\n-  precond(!uncommit_cycle_is_canceled());\n+\n+  if (uncommit_cycle_is_canceled()) {\n+    \/\/ We were canceled before we managed to activate, update the timeout\n+    update_next_cycle_timeout_on_cancel();\n+\n+    \/\/ Reset the cycle\n+    reset_uncommit_cycle();\n+\n+    return false;\n+  }\n@@ -220,1 +248,1 @@\n-  cache->reset_uncommit_cycle();\n+  cache->reset_uncommit_watermark();\n@@ -223,0 +251,2 @@\n+\n+  return true;\n@@ -245,2 +275,5 @@\n-  log_debug(gc, heap)(\"Uncommitter (%u) Cancel Next Cycle Timeout: \" UINT64_FORMAT \"ms\",\n-                      _id, _next_cycle_timeout);\n+  \/\/ Skip logging if there is no delay\n+  if (ZUncommitDelay > 0) {\n+    log_debug(gc, heap)(\"Uncommitter (%u) Cancel Next Cycle Timeout: \" UINT64_FORMAT \"ms\",\n+                        _id, _next_cycle_timeout);\n+  }\n@@ -255,2 +288,5 @@\n-  log_debug(gc, heap)(\"Uncommitter (%u) Finish Next Cycle Timeout: \" UINT64_FORMAT \"ms\",\n-                      _id, _next_cycle_timeout);\n+  \/\/ Skip logging if there is no delay\n+  if (ZUncommitDelay > 0) {\n+    log_debug(gc, heap)(\"Uncommitter (%u) Finish Next Cycle Timeout: \" UINT64_FORMAT \"ms\",\n+                        _id, _next_cycle_timeout);\n+  }\n@@ -261,1 +297,1 @@\n-  _partition->_cache.reset_uncommit_cycle();\n+  _partition->_cache.reset_uncommit_watermark();\n@@ -332,0 +368,2 @@\n+  precond(uncommit_cycle_is_active());\n+\n@@ -353,2 +391,1 @@\n-    if (limit == 0) {\n-      \/\/ This may occur if the current max capacity for this partition is 0\n+    ZMappedCache& cache = _partition->_cache;\n@@ -356,8 +393,4 @@\n-      cancel_uncommit_cycle();\n-      return 0;\n-    }\n-\n-    if (!uncommit_cycle_is_active()) {\n-      \/\/ We are activating a new cycle\n-      activate_uncommit_cycle();\n-    }\n+    \/\/ Never uncommit more than the current uncommit watermark,\n+    \/\/ (adjusted by what has already been uncommitted).\n+    const size_t allowed_to_uncommit = MAX2(cache.uncommit_watermark(), _uncommitted) - _uncommitted;\n+    const size_t to_uncommit = MIN2(_to_uncommit, allowed_to_uncommit);\n@@ -368,1 +401,1 @@\n-    const size_t flush = MIN3(release, limit, _to_uncommit);\n+    const size_t flush = MIN3(release, limit, to_uncommit);\n@@ -371,1 +404,1 @@\n-    flushed = _partition->_cache.remove_for_uncommit(flush, &flushed_vmems);\n+    flushed = cache.remove_for_uncommit(flush, &flushed_vmems);\n","filename":"src\/hotspot\/share\/gc\/z\/zUncommitter.cpp","additions":64,"deletions":31,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+  void reset_uncommit_cycle();\n@@ -55,1 +56,1 @@\n-  void activate_uncommit_cycle();\n+  bool activate_uncommit_cycle();\n","filename":"src\/hotspot\/share\/gc\/z\/zUncommitter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}