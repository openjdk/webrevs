{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.io.IOException;\n@@ -35,0 +36,2 @@\n+import static java.lang.Integer.numberOfLeadingZeros;\n+import static java.lang.Math.multiplyHigh;\n@@ -92,1 +95,0 @@\n-@SuppressWarnings(\"serial\")\n@@ -221,6 +223,4 @@\n-     * @implSpec\n-     * The current implementation acts as if this {@code Float16} were\n-     * {@linkplain #floatValue() converted} to {@code float} and then\n-     * the string for that {@code float} returned. This behavior is\n-     * expected to change to accommodate the precision of {@code\n-     * Float16}.\n+     * The behavior of this method is analogous to {@link\n+     * Float#toString(float)} in the handling of special values\n+     * (signed zeros, infinities, and NaN) and the generation of a\n+     * decimal string that will convert back to the argument value.\n@@ -233,3 +233,1 @@\n-        \/\/ FIXME -- update for Float16 precision\n-        return Float.toString(f16.floatValue());\n-        \/\/ return FloatToDecimal.toString(f16.floatValue());\n+         return Float16ToDecimal.toString(f16);\n@@ -246,0 +244,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToHexCharacter operation\n+     * defined in IEEE 754.\n+     *\n@@ -445,1 +447,3 @@\n-            || Math.abs(trialResult) > (65504.0 + 32.0) || \/\/ Float.MAX_VALUE + ulp(MAX_VALUE)\n+            || Math.abs(trialResult) > (65504.0 + 32.0) || \/\/ Float.MAX_VALUE + ulp(MAX_VALUE),\n+                                                           \/\/ handles infinities too\n+            Double.isNaN(trialResult) ||\n@@ -565,4 +569,0 @@\n-     * @apiNote\n-     * This method corresponds to the convertFormat operation defined\n-     * in IEEE 754.\n-     *\n@@ -786,0 +786,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n@@ -797,0 +801,4 @@\n+     * @apiNote\n+     * This method corresponds to the convertToIntegerTowardZero\n+     * operation defined in IEEE 754.\n+     *\n@@ -982,0 +990,4 @@\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is analagous to the handling of\n+     * those cases by the Math#max(double, double) method.\n+     *\n@@ -991,1 +1003,0 @@\n-     * @see Math#max(double, double)\n@@ -1001,0 +1012,4 @@\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is analagous to the handling of\n+     * those cases by the Math#min(double, double) method.\n+     *\n@@ -1010,1 +1025,0 @@\n-     * @see Math#min(double, double)\n@@ -1487,0 +1501,3 @@\n+     *\n+     * @see Math#ulp(float)\n+     * @see Math#ulp(double)\n@@ -1525,0 +1542,3 @@\n+     *\n+     * @see Math#nextUp(float)\n+     * @see Math#nextUp(double)\n@@ -1560,0 +1580,3 @@\n+     *\n+     * @see Math#nextDown(float)\n+     * @see Math#nextDown(double)\n@@ -1601,0 +1624,3 @@\n+     *\n+     * @see Math#scalb(float, int)\n+     * @see Math#scalb(double, int)\n@@ -1640,0 +1666,3 @@\n+     *\n+     * @see Math#copySign(float, float)\n+     * @see Math#copySign(double, double)\n@@ -1663,0 +1692,3 @@\n+     *\n+     * @see Math#signum(float)\n+     * @see Math#signum(double)\n@@ -1667,0 +1699,646 @@\n+\n+    \/* TODO Temporary hack while Float16 resides in incubator *\/\n+    private static final class Float16ToDecimal {\n+        \/*\n+         * For full details about this code see the following references:\n+         *\n+         * [1] Giulietti, \"The Schubfach way to render doubles\",\n+         *     https:\/\/drive.google.com\/file\/d\/1gp5xv4CAa78SVgCeWfGqqI4FfYYYuNFb\n+         *\n+         * [2] IEEE Computer Society, \"IEEE Standard for Floating-Point Arithmetic\"\n+         *\n+         * [3] Bouvier & Zimmermann, \"Division-Free Binary-to-Decimal Conversion\"\n+         *\n+         * Divisions are avoided altogether for the benefit of those architectures\n+         * that do not provide specific machine instructions or where they are slow.\n+         * This is discussed in section 10 of [1].\n+         *\/\n+\n+        \/* The precision in bits *\/\n+        static final int P = PRECISION;\n+\n+        \/* Exponent width in bits *\/\n+        private static final int W = (Float16.SIZE - 1) - (P - 1);\n+\n+        \/* Minimum value of the exponent: -(2^(W-1)) - P + 3 *\/\n+        static final int Q_MIN = (-1 << (W - 1)) - P + 3;\n+\n+        \/* Maximum value of the exponent: 2^(W-1) - P *\/\n+        static final int Q_MAX = (1 << (W - 1)) - P;\n+\n+        \/* 10^(E_MIN - 1) <= MIN_VALUE < 10^E_MIN *\/\n+        static final int E_MIN = -7;\n+\n+        \/* 10^(E_MAX - 1) <= MAX_VALUE < 10^E_MAX *\/\n+        static final int E_MAX = 5;\n+\n+        \/* Threshold to detect tiny values, as in section 8.2.1 of [1] *\/\n+        static final int C_TINY = 2;\n+\n+        \/* The minimum and maximum k, as in section 8 of [1] *\/\n+        static final int K_MIN = -8;\n+        static final int K_MAX = 1;\n+\n+        \/* H is as in section 8.1 of [1] *\/\n+        static final int H = 5;\n+\n+        \/* Minimum value of the significand of a normal value: 2^(P-1) *\/\n+        private static final int C_MIN = 1 << (P - 1);\n+\n+        \/* Mask to extract the biased exponent *\/\n+        private static final int BQ_MASK = (1 << W) - 1;\n+\n+        \/* Mask to extract the fraction bits *\/\n+        private static final int T_MASK = (1 << (P - 1)) - 1;\n+\n+        \/* Used in rop() *\/\n+        private static final long MASK_32 = (1L << 32) - 1;\n+\n+        \/* Used for left-to-tight digit extraction *\/\n+        private static final int MASK_15 = (1 << 15) - 1;\n+\n+        private static final int NON_SPECIAL    = 0;\n+        private static final int PLUS_ZERO      = 1;\n+        private static final int MINUS_ZERO     = 2;\n+        private static final int PLUS_INF       = 3;\n+        private static final int MINUS_INF      = 4;\n+        private static final int NAN            = 5;\n+\n+        \/*\n+         * Room for the longer of the forms\n+         *     -ddd.dd      H + 2 characters\n+         *     -ddddd.0     H + 3 characters\n+         *     -0.00ddddd   H + 5 characters\n+         *     -d.ddddE-e   H + 5 characters\n+         * where there are H digits d\n+         *\/\n+        public static final int MAX_CHARS = H + 5;\n+\n+        private final byte[] bytes = new byte[MAX_CHARS];\n+\n+        \/* Index into bytes of rightmost valid character *\/\n+        private int index;\n+\n+        private Float16ToDecimal() {\n+        }\n+\n+        \/**\n+         * Returns a string representation of the {@code Float16}\n+         * argument. All characters mentioned below are ASCII characters.\n+         *\n+         * @param   v   the {@code Float16} to be converted.\n+         * @return a string representation of the argument.\n+         * @see Float16#toString(Float16)\n+         *\/\n+        public static String toString(Float16 v) {\n+            return new Float16ToDecimal().toDecimalString(v);\n+        }\n+\n+        \/**\n+         * Appends the rendering of the {@code v} to {@code app}.\n+         *\n+         * <p>The outcome is the same as if {@code v} were first\n+         * {@link #toString(Float16) rendered} and the resulting string were then\n+         * {@link Appendable#append(CharSequence) appended} to {@code app}.\n+         *\n+         * @param v the {@code Float16} whose rendering is appended.\n+         * @param app the {@link Appendable} to append to.\n+         * @throws IOException If an I\/O error occurs\n+         *\/\n+        public static Appendable appendTo(Float16 v, Appendable app)\n+                throws IOException {\n+            return new Float16ToDecimal().appendDecimalTo(v, app);\n+        }\n+\n+        private String toDecimalString(Float16 v) {\n+            return switch (toDecimal(v)) {\n+                case NON_SPECIAL -> charsToString();\n+                case PLUS_ZERO -> \"0.0\";\n+                case MINUS_ZERO -> \"-0.0\";\n+                case PLUS_INF -> \"Infinity\";\n+                case MINUS_INF -> \"-Infinity\";\n+                default -> \"NaN\";\n+            };\n+        }\n+\n+        private Appendable appendDecimalTo(Float16 v, Appendable app)\n+                throws IOException {\n+            switch (toDecimal(v)) {\n+                case NON_SPECIAL:\n+                    char[] chars = new char[index + 1];\n+                    for (int i = 0; i < chars.length; ++i) {\n+                        chars[i] = (char) bytes[i];\n+                    }\n+                    if (app instanceof StringBuilder builder) {\n+                        return builder.append(chars);\n+                    }\n+                    if (app instanceof StringBuffer buffer) {\n+                        return buffer.append(chars);\n+                    }\n+                    for (char c : chars) {\n+                        app.append(c);\n+                    }\n+                    return app;\n+                case PLUS_ZERO: return app.append(\"0.0\");\n+                case MINUS_ZERO: return app.append(\"-0.0\");\n+                case PLUS_INF: return app.append(\"Infinity\");\n+                case MINUS_INF: return app.append(\"-Infinity\");\n+                default: return app.append(\"NaN\");\n+            }\n+        }\n+\n+        \/*\n+         * Returns\n+         *     PLUS_ZERO       iff v is 0.0\n+         *     MINUS_ZERO      iff v is -0.0\n+         *     PLUS_INF        iff v is POSITIVE_INFINITY\n+         *     MINUS_INF       iff v is NEGATIVE_INFINITY\n+         *     NAN             iff v is NaN\n+         *\/\n+        private int toDecimal(Float16 v) {\n+            \/*\n+             * For full details see references [2] and [1].\n+             *\n+             * For finite v != 0, determine integers c and q such that\n+             *     |v| = c 2^q    and\n+             *     Q_MIN <= q <= Q_MAX    and\n+             *         either    2^(P-1) <= c < 2^P                 (normal)\n+             *         or        0 < c < 2^(P-1)  and  q = Q_MIN    (subnormal)\n+             *\/\n+            int bits = float16ToRawShortBits(v);\n+            int t = bits & T_MASK;\n+            int bq = (bits >>> P - 1) & BQ_MASK;\n+            if (bq < BQ_MASK) {\n+                index = -1;\n+                if (bits < 0) {\n+                    append('-');\n+                }\n+                if (bq != 0) {\n+                    \/* normal value. Here mq = -q *\/\n+                    int mq = -Q_MIN + 1 - bq;\n+                    int c = C_MIN | t;\n+                    \/* The fast path discussed in section 8.3 of [1] *\/\n+                    if (0 < mq & mq < P) {\n+                        int f = c >> mq;\n+                        if (f << mq == c) {\n+                            return toChars(f, 0);\n+                        }\n+                    }\n+                    return toDecimal(-mq, c, 0);\n+                }\n+                if (t != 0) {\n+                    \/* subnormal value *\/\n+                    return t < C_TINY\n+                            ? toDecimal(Q_MIN, 10 * t, -1)\n+                            : toDecimal(Q_MIN, t, 0);\n+                }\n+                return bits == 0 ? PLUS_ZERO : MINUS_ZERO;\n+            }\n+            if (t != 0) {\n+                return NAN;\n+            }\n+            return bits > 0 ? PLUS_INF : MINUS_INF;\n+        }\n+\n+        private int toDecimal(int q, int c, int dk) {\n+            \/*\n+             * The skeleton corresponds to figure 7 of [1].\n+             * The efficient computations are those summarized in figure 9.\n+             * Also check the appendix.\n+             *\n+             * Here's a correspondence between Java names and names in [1],\n+             * expressed as approximate LaTeX source code and informally.\n+             * Other names are identical.\n+             * cb:     \\bar{c}     \"c-bar\"\n+             * cbr:    \\bar{c}_r   \"c-bar-r\"\n+             * cbl:    \\bar{c}_l   \"c-bar-l\"\n+             *\n+             * vb:     \\bar{v}     \"v-bar\"\n+             * vbr:    \\bar{v}_r   \"v-bar-r\"\n+             * vbl:    \\bar{v}_l   \"v-bar-l\"\n+             *\n+             * rop:    r_o'        \"r-o-prime\"\n+             *\/\n+            int out = c & 0x1;\n+            long cb = c << 2;\n+            long cbr = cb + 2;\n+            long cbl;\n+            int k;\n+            \/*\n+             * flog10pow2(e) = floor(log_10(2^e))\n+             * flog10threeQuartersPow2(e) = floor(log_10(3\/4 2^e))\n+             * flog2pow10(e) = floor(log_2(10^e))\n+             *\/\n+            if (c != C_MIN | q == Q_MIN) {\n+                \/* regular spacing *\/\n+                cbl = cb - 2;\n+                k = MathUtils.flog10pow2(q);\n+            } else {\n+                \/* irregular spacing *\/\n+                cbl = cb - 1;\n+                k = MathUtils.flog10threeQuartersPow2(q);\n+            }\n+            int h = q + MathUtils.flog2pow10(-k) + 33;\n+\n+            \/* g is as in the appendix *\/\n+            long g = MathUtils.g1(k) + 1;\n+\n+            int vb = rop(g, cb << h);\n+            int vbl = rop(g, cbl << h);\n+            int vbr = rop(g, cbr << h);\n+\n+            int s = vb >> 2;\n+            if (s >= 100) {\n+                \/*\n+                 * For n = 5, m = 1 the discussion in section 10 of [1] shows\n+                 *     s' = floor(s \/ 10) = floor(s 52_429 \/ 2^19)\n+                 *\n+                 * sp10 = 10 s'\n+                 * tp10 = 10 t'\n+                 * upin    iff    u' = sp10 10^k in Rv\n+                 * wpin    iff    w' = tp10 10^k in Rv\n+                 * See section 9.3 of [1].\n+                 *\/\n+                int sp10 = 10 * (int) (s * 52_429L >>> 19);\n+                int tp10 = sp10 + 10;\n+                boolean upin = vbl + out <= sp10 << 2;\n+                boolean wpin = (tp10 << 2) + out <= vbr;\n+                if (upin != wpin) {\n+                    return toChars(upin ? sp10 : tp10, k);\n+                }\n+            }\n+\n+            \/*\n+             * 10 <= s < 100    or    s >= 100  and  u', w' not in Rv\n+             * uin    iff    u = s 10^k in Rv\n+             * win    iff    w = t 10^k in Rv\n+             * See section 9.3 of [1].\n+             *\/\n+            int t = s + 1;\n+            boolean uin = vbl + out <= s << 2;\n+            boolean win = (t << 2) + out <= vbr;\n+            if (uin != win) {\n+                \/* Exactly one of u or w lies in Rv *\/\n+                return toChars(uin ? s : t, k + dk);\n+            }\n+            \/*\n+             * Both u and w lie in Rv: determine the one closest to v.\n+             * See section 9.3 of [1].\n+             *\/\n+            int cmp = vb - (s + t << 1);\n+            return toChars(cmp < 0 || cmp == 0 && (s & 0x1) == 0 ? s : t, k + dk);\n+        }\n+\n+        \/*\n+         * Computes rop(cp g 2^(-95))\n+         * See appendix and figure 11 of [1].\n+         *\/\n+        private static int rop(long g, long cp) {\n+            long x1 = multiplyHigh(g, cp);\n+            long vbp = x1 >>> 31;\n+            return (int) (vbp | (x1 & MASK_32) + MASK_32 >>> 32);\n+        }\n+\n+        \/*\n+         * Formats the decimal f 10^e.\n+         *\/\n+        private int toChars(int f, int e) {\n+            \/*\n+             * For details not discussed here see section 10 of [1].\n+             *\n+             * Determine len such that\n+             *     10^(len-1) <= f < 10^len\n+             *\/\n+            int len = MathUtils.flog10pow2(Integer.SIZE - numberOfLeadingZeros(f));\n+            if (f >= MathUtils.pow10(len)) {\n+                len += 1;\n+            }\n+\n+            \/*\n+             * Let fp and ep be the original f and e, respectively.\n+             * Transform f and e to ensure\n+             *     10^(H-1) <= f < 10^H\n+             *     fp 10^ep = f 10^(e-H) = 0.f 10^e\n+             *\/\n+            f *= (int)MathUtils.pow10(H - len);\n+            e += len;\n+\n+            \/*\n+             * The toChars?() methods perform left-to-right digits extraction\n+             * using ints, provided that the arguments are limited to 8 digits.\n+             * Therefore, split the H = 9 digits of f into:\n+             *     h = the most significant digit of f\n+             *     l = the last 4, least significant digits of f\n+             *\n+             * For n = 5, m = 4 the discussion in section 10 of [1] shows\n+             *     floor(f \/ 10^4) = floor(107_375L f \/ 2^30)\n+             *\/\n+            int h = (int) (f * 107_375L >>> 30);\n+            int l = f - 10_000 * h;\n+\n+            if (0 < e && e <= 7) {\n+                return toChars1(h, l, e);\n+            }\n+            if (-3 < e && e <= 0) {\n+                return toChars2(h, l, e);\n+            }\n+            return toChars3(h, l, e);\n+        }\n+\n+        private int toChars1(int h, int l, int e) {\n+            \/*\n+             * 0 < e <= 7: plain format without leading zeroes.\n+             * Left-to-right digits extraction:\n+             * algorithm 1 in [3], with b = 10, k = 4, n = 15.\n+             *\/\n+            appendDigit(h);\n+            int y = y(l);\n+            int t;\n+            int i = 1;\n+            for (; i < e; ++i) {\n+                t = 10 * y;\n+                appendDigit(t >>> 15);\n+                y = t & MASK_15;\n+            }\n+            append('.');\n+            for (; i <= 4; ++i) {\n+                t = 10 * y;\n+                appendDigit(t >>> 15);\n+                y = t & MASK_15;\n+            }\n+            \/*\n+             * As H = 5 < 7, where 7 is the threshold for plain format without\n+             * leading zeros, it can happen that the 2nd loop above is not executed.\n+             * The following line ensures the presence of a digit to the right\n+             * of the decimal point.\n+             *\/\n+            appendDigit(0);\n+            removeTrailingZeroes();\n+            return NON_SPECIAL;\n+        }\n+\n+        private int toChars2(int h, int l, int e) {\n+            \/* -3 < e <= 0: plain format with leading zeroes *\/\n+            appendDigit(0);\n+            append('.');\n+            for (; e < 0; ++e) {\n+                appendDigit(0);\n+            }\n+            appendDigit(h);\n+            append4Digits(l);\n+            removeTrailingZeroes();\n+            return NON_SPECIAL;\n+        }\n+\n+        private int toChars3(int h, int l, int e) {\n+            \/* -3 >= e | e > 7: computerized scientific notation *\/\n+            appendDigit(h);\n+            append('.');\n+            append4Digits(l);\n+            removeTrailingZeroes();\n+            exponent(e - 1);\n+            return NON_SPECIAL;\n+        }\n+\n+        private void append4Digits(int m) {\n+            \/*\n+             * Left-to-right digits extraction:\n+             * algorithm 1 in [3], with b = 10, k = 4, n = 15.\n+             *\/\n+            int y = y(m);\n+            for (int i = 0; i < 4; ++i) {\n+                int t = 10 * y;\n+                appendDigit(t >>> 15);\n+                y = t & MASK_15;\n+            }\n+        }\n+\n+        private void removeTrailingZeroes() {\n+            while (bytes[index] == '0') {\n+                --index;\n+            }\n+            \/* ... but do not remove the one directly to the right of '.' *\/\n+            if (bytes[index] == '.') {\n+                ++index;\n+            }\n+        }\n+\n+        private int y(int a) {\n+            \/*\n+             * Algorithm 1 in [3] needs computation of\n+             *     floor((a + 1) 2^n \/ b^k) - 1\n+             * with a < 10^4, b = 10, k = 4, n = 15.\n+             * Noting that\n+             *     (a + 1) 2^n <= 10^4 2^15 < 10^9\n+             * For n = 9, m = 4 the discussion in section 10 of [1] leads to:\n+             *\/\n+            return (int) (((a + 1) << 15) * 1_759_218_605L >>> 44) - 1;\n+        }\n+\n+        private void exponent(int e) {\n+            append('E');\n+            if (e < 0) {\n+                append('-');\n+                e = -e;\n+            }\n+            appendDigit(e);\n+        }\n+\n+        private void append(int c) {\n+            bytes[++index] = (byte) c;\n+        }\n+\n+        private void appendDigit(int d) {\n+            bytes[++index] = (byte) ('0' + d);\n+        }\n+\n+        \/* Using the deprecated constructor enhances performance *\/\n+        @SuppressWarnings(\"deprecation\")\n+        private String charsToString() {\n+            return new String(bytes, 0, 0, index + 1);\n+        }\n+\n+    }\n+\n+    \/* TODO Temporary hack while Float16 resides in incubator *\/\n+\n+    \/**\n+     * This class exposes package private utilities for other classes.\n+     * Thus, all methods are assumed to be invoked with correct arguments,\n+     * so these are not checked at all.\n+     *\/\n+    private static final class MathUtils {\n+        \/*\n+         * For full details about this code see the following reference:\n+         *\n+         *     Giulietti, \"The Schubfach way to render doubles\",\n+         *     https:\/\/drive.google.com\/file\/d\/1gp5xv4CAa78SVgCeWfGqqI4FfYYYuNFb\n+         *\/\n+\n+        \/*\n+         * The boundaries for k in g0(int) and g1(int).\n+         * K_MIN must be DoubleToDecimal.K_MIN or less.\n+         * K_MAX must be DoubleToDecimal.K_MAX or more.\n+         *\/\n+        static final int K_MIN = -8;\n+        static final int K_MAX = 1;\n+\n+        \/* Must be DoubleToDecimal.H or more *\/\n+        static final int H = 17;\n+\n+        \/* C_10 = floor(log10(2) * 2^Q_10), A_10 = floor(log10(3\/4) * 2^Q_10) *\/\n+        private static final int Q_10 = 41;\n+        private static final long C_10 = 661_971_961_083L;\n+        private static final long A_10 = -274_743_187_321L;\n+\n+        \/* C_2 = floor(log2(10) * 2^Q_2) *\/\n+        private static final int Q_2 = 38;\n+        private static final long C_2 = 913_124_641_741L;\n+\n+        private MathUtils() {\n+            throw new RuntimeException(\"not supposed to be instantiated.\");\n+        }\n+\n+        \/* The first powers of 10. The last entry must be 10^(DoubleToDecimal.H) *\/\n+        private static final long[] pow10 = {\n+                1L,\n+                10L,\n+                100L,\n+                1_000L,\n+                10_000L,\n+                100_000L,\n+                1_000_000L,\n+                10_000_000L,\n+                100_000_000L,\n+                1_000_000_000L,\n+                10_000_000_000L,\n+                100_000_000_000L,\n+                1_000_000_000_000L,\n+                10_000_000_000_000L,\n+                100_000_000_000_000L,\n+                1_000_000_000_000_000L,\n+                10_000_000_000_000_000L,\n+                100_000_000_000_000_000L,\n+        };\n+\n+        \/**\n+         * Returns 10<sup>{@code e}<\/sup>.\n+         *\n+         * @param e The exponent which must meet\n+         *          0 &le; {@code e} &le; {@link #H}.\n+         * @return 10<sup>{@code e}<\/sup>.\n+         *\/\n+        static long pow10(int e) {\n+            return pow10[e];\n+        }\n+\n+        \/**\n+         * Returns the unique integer <i>k<\/i> such that\n+         * 10<sup><i>k<\/i><\/sup> &le; 2<sup>{@code e}<\/sup>\n+         * &lt; 10<sup><i>k<\/i>+1<\/sup>.\n+         * <p>\n+         * The result is correct when |{@code e}| &le; 6_432_162.\n+         * Otherwise the result is undefined.\n+         *\n+         * @param e The exponent of 2, which should meet\n+         *          |{@code e}| &le; 6_432_162 for safe results.\n+         * @return &lfloor;log<sub>10<\/sub>2<sup>{@code e}<\/sup>&rfloor;.\n+         *\/\n+        static int flog10pow2(int e) {\n+            return (int) (e * C_10 >> Q_10);\n+        }\n+\n+        \/**\n+         * Returns the unique integer <i>k<\/i> such that\n+         * 10<sup><i>k<\/i><\/sup> &le; 3\/4 &middot; 2<sup>{@code e}<\/sup>\n+         * &lt; 10<sup><i>k<\/i>+1<\/sup>.\n+         * <p>\n+         * The result is correct when\n+         * -3_606_689 &le; {@code e} &le; 3_150_619.\n+         * Otherwise the result is undefined.\n+         *\n+         * @param e The exponent of 2, which should meet\n+         *          -3_606_689 &le; {@code e} &le; 3_150_619 for safe results.\n+         * @return &lfloor;log<sub>10<\/sub>(3\/4 &middot;\n+         * 2<sup>{@code e}<\/sup>)&rfloor;.\n+         *\/\n+        static int flog10threeQuartersPow2(int e) {\n+            return (int) (e * C_10 + A_10 >> Q_10);\n+        }\n+\n+        \/**\n+         * Returns the unique integer <i>k<\/i> such that\n+         * 2<sup><i>k<\/i><\/sup> &le; 10<sup>{@code e}<\/sup>\n+         * &lt; 2<sup><i>k<\/i>+1<\/sup>.\n+         * <p>\n+         * The result is correct when |{@code e}| &le; 1_838_394.\n+         * Otherwise the result is undefined.\n+         *\n+         * @param e The exponent of 10, which should meet\n+         *          |{@code e}| &le; 1_838_394 for safe results.\n+         * @return &lfloor;log<sub>2<\/sub>10<sup>{@code e}<\/sup>&rfloor;.\n+         *\/\n+        static int flog2pow10(int e) {\n+            return (int) (e * C_2 >> Q_2);\n+        }\n+\n+        \/**\n+         * Let 10<sup>-{@code k}<\/sup> = <i>&beta;<\/i> 2<sup><i>r<\/i><\/sup>,\n+         * for the unique pair of integer <i>r<\/i> and real <i>&beta;<\/i> meeting\n+         * 2<sup>125<\/sup> &le; <i>&beta;<\/i> &lt; 2<sup>126<\/sup>.\n+         * Further, let <i>g<\/i> = &lfloor;<i>&beta;<\/i>&rfloor; + 1.\n+         * Split <i>g<\/i> into the higher 63 bits <i>g<\/i><sub>1<\/sub> and\n+         * the lower 63 bits <i>g<\/i><sub>0<\/sub>. Thus,\n+         * <i>g<\/i><sub>1<\/sub> =\n+         * &lfloor;<i>g<\/i> 2<sup>-63<\/sup>&rfloor;\n+         * and\n+         * <i>g<\/i><sub>0<\/sub> =\n+         * <i>g<\/i> - <i>g<\/i><sub>1<\/sub> 2<sup>63<\/sup>.\n+         * <p>\n+         * This method returns <i>g<\/i><sub>1<\/sub> while\n+         * {@link #g0(int)} returns <i>g<\/i><sub>0<\/sub>.\n+         * <p>\n+         * If needed, the exponent <i>r<\/i> can be computed as\n+         * <i>r<\/i> = {@code flog2pow10(-k)} - 125 (see {@link #flog2pow10(int)}).\n+         *\n+         * @param k The exponent of 10, which must meet\n+         *          {@link #K_MIN} &le; {@code e} &le; {@link #K_MAX}.\n+         * @return <i>g<\/i><sub>1<\/sub> as described above.\n+         *\/\n+        static long g1(int k) {\n+            return g[k - K_MIN << 1];\n+        }\n+\n+        \/**\n+         * Returns <i>g<\/i><sub>0<\/sub> as described in\n+         * {@link #g1(int)}.\n+         *\n+         * @param k The exponent of 10, which must meet\n+         *          {@link #K_MIN} &le; {@code e} &le; {@link #K_MAX}.\n+         * @return <i>g<\/i><sub>0<\/sub> as described in\n+         * {@link #g1(int)}.\n+         *\/\n+        static long g0(int k) {\n+            return g[k - K_MIN << 1 | 1];\n+        }\n+\n+        \/*\n+         * The precomputed values for g1(int) and g0(int).\n+         * The first entry must be for an exponent of K_MIN or less.\n+         * The last entry must be for an exponent of K_MAX or more.\n+         *\/\n+        private static final long[] g = {\n+                0x5F5E_1000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -8\n+                0x4C4B_4000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -7\n+                0x7A12_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -6\n+                0x61A8_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -5\n+                0x4E20_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -4\n+                0x7D00_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -3\n+                0x6400_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -2\n+                0x5000_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/   -1\n+                0x4000_0000_0000_0000L, 0x0000_0000_0000_0001L, \/\/    0\n+                0x6666_6666_6666_6666L, 0x3333_3333_3333_3334L, \/\/    1\n+        };\n+\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":695,"deletions":17,"binary":false,"changes":712,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+        checkBaseConversionRoundTrip();\n@@ -138,2 +139,1 @@\n-\n-        System.out.println();\n+        \/\/ System.out.println();\n@@ -515,0 +515,7 @@\n+            new String2Float16Case( \"NaN\",  NaNf),\n+            new String2Float16Case(\"+NaN\", NaNf),\n+            new String2Float16Case(\"-NaN\", NaNf),\n+\n+            new String2Float16Case( \"+Infinity\", +InfinityF),\n+            new String2Float16Case( \"-Infinity\", -InfinityF),\n+\n@@ -587,0 +594,21 @@\n+    private static void checkBaseConversionRoundTrip() {\n+        checkFloat16(Float16.NaN,\n+                     Float16.valueOf(\"NaN\").floatValue(),\n+                     \"base conversion of NaN\");\n+\n+        \/\/ For each non-NaN value, make sure\n+        \/\/ value -> string -> value\n+        \/\/ sequence of conversions gives the expected result.\n+\n+        for(int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; i++) {\n+            Float16 f16 = Float16.shortBitsToFloat16((short)i);\n+            if (Float16.isNaN(f16))\n+                continue;\n+\n+            checkFloat16(f16,\n+                         Float16.valueOf(Float16.toString(f16)).floatValue(),\n+                         \"base conversion\");\n+        }\n+        return;\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/BasicFloat16ArithTests.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"}]}