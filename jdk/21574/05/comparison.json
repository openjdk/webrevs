{"files":[{"patch":"@@ -0,0 +1,1518 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.vector;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+\/\/ import jdk.internal.math.*;\n+\n+import static java.lang.Float.float16ToFloat;\n+import static java.lang.Float.floatToFloat16;\n+\n+\/**\n+ * The {@code Float16} is a class holding 16-bit data\n+ * in IEEE 754 binary16 format.\n+ *\n+ * <p>Binary16 Format:<br>\n+ *   S EEEEE  MMMMMMMMMM<br>\n+ *   Sign        - 1 bit<br>\n+ *   Exponent    - 5 bits<br>\n+ *   Significand - 10 bits (does not include the <i>implicit bit<\/i> inferred from the exponent, see {@link #PRECISION})<br>\n+ *\n+ * <p>Unless otherwise specified, the methods in this class use a\n+ * <em>rounding policy<\/em> (JLS {@jls 15.4}) of {@linkplain\n+ * java.math.RoundingMode#HALF_EVEN round to nearest}.\n+ *\n+ * <p>This is a <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>\n+ * class; programmers should treat instances that are\n+ * {@linkplain #equals(Object) equal} as interchangeable and should not\n+ * use instances for synchronization, or unpredictable behavior may\n+ * occur. For example, in a future release, synchronization may fail.\n+ *\n+ * @apiNote\n+ * The methods in this class generally have analogous methods in\n+ * either {@link Float}\/{@link Double} or {@link Math}\/{@link\n+ * StrictMath}. Unless otherwise specified, the handling of special\n+ * floating-point values such as {@linkplain #isNaN(Float16) NaN}\n+ * values, {@linkplain #isInfinite(Float16) infinities}, and signed\n+ * zeros of methods in this class is wholly analogous to the handling\n+ * of equivalent cases by methods in {@code Float}, {@code Double},\n+ * {@code Math}, etc.\n+ *\n+ * @since 24\n+ *\/\n+\n+\/\/ Currently Float16 is a value-based class and in future it is\n+\/\/ expected to be aligned with Value Classes and Object as describedin\n+\/\/ JEP-401 (https:\/\/openjdk.org\/jeps\/401).\n+\/\/ @jdk.internal.MigratedValueClass\n+\/\/ @jdk.internal.ValueBased\n+@SuppressWarnings(\"serial\")\n+public final class Float16\n+    extends Number\n+    implements Comparable<Float16> {\n+    private final short value;\n+    private static final long serialVersionUID = 16; \/\/ May not be needed when a value class?\n+\n+    \/\/ Functionality for future consideration:\n+    \/\/ IEEEremainder \/ remainder operator remainder\n+\n+   \/**\n+    * Returns a {@code Float16} instance wrapping IEEE 754 binary16\n+    * encoded {@code short} value.\n+    *\n+    * @param  bits a short value.\n+    *\/\n+    private Float16(short bits ) {\n+        this.value = bits;\n+    }\n+\n+    \/\/ Do *not* define any public constructors\n+\n+    \/**\n+     * A constant holding the positive infinity of type {@code\n+     * Float16}.\n+     *\n+     * @see Float#POSITIVE_INFINITY\n+     * @see Double#POSITIVE_INFINITY\n+     *\/\n+    public static final Float16 POSITIVE_INFINITY = valueOf(Float.POSITIVE_INFINITY);\n+\n+    \/**\n+     * A constant holding the negative infinity of type {@code\n+     * Float16}.\n+     *\n+     * @see Float#NEGATIVE_INFINITY\n+     * @see Double#NEGATIVE_INFINITY\n+     *\/\n+    public static final Float16 NEGATIVE_INFINITY = valueOf(Float.NEGATIVE_INFINITY);\n+\n+    \/**\n+     * A constant holding a Not-a-Number (NaN) value of type {@code\n+     * Float16}.\n+     *\n+     * @see Float#NaN\n+     * @see Double#NaN\n+     *\/\n+    public static final Float16 NaN = valueOf(Float.NaN);\n+\n+    \/**\n+     * A constant holding the largest positive finite value of type\n+     * {@code Float16},\n+     * (2-2<sup>-10<\/sup>)&middot;2<sup>15<\/sup>, numerically equal to 65504.0.\n+     *\n+     * @see Float#MAX_VALUE\n+     * @see Double#MAX_VALUE\n+     *\/\n+    public static final Float16 MAX_VALUE = valueOf(0x1.ffcp15f);\n+\n+    \/**\n+     * A constant holding the smallest positive normal value of type\n+     * {@code Float16}, 2<sup>-14<\/sup>.\n+     *\n+     * @see Float#MIN_NORMAL\n+     * @see Double#MIN_NORMAL\n+     *\/\n+    public static final Float16 MIN_NORMAL = valueOf(0x1.0p-14f);\n+\n+    \/**\n+     * A constant holding the smallest positive nonzero value of type\n+     * {@code Float16}, 2<sup>-24<\/sup>.\n+     *\n+     * @see Float#MIN_VALUE\n+     * @see Double#MIN_VALUE\n+     *\/\n+    public static final Float16 MIN_VALUE = valueOf(0x1.0p-24f);\n+\n+    \/**\n+     * The number of bits used to represent a {@code Float16} value,\n+     * {@value}.\n+     *\n+     * @see Float#SIZE\n+     * @see Double#SIZE\n+     *\/\n+    public static final int SIZE = 16;\n+\n+    \/**\n+     * The number of bits in the significand of a {@code Float16}\n+     * value, {@value}.  This corresponds to parameter N in section\n+     * {@jls 4.2.3} of <cite>The Java Language Specification<\/cite>.\n+     *\n+     * @see Float#PRECISION\n+     * @see Double#PRECISION\n+     *\/\n+    public static final int PRECISION = 11;\n+\n+    \/**\n+     * Maximum exponent a finite {@code Float16} variable may have,\n+     * {@value}. It is equal to the value returned by {@code\n+     * Float16.getExponent(Float16.MAX_VALUE)}.\n+     *\n+     * @see Float#MAX_EXPONENT\n+     * @see Double#MAX_EXPONENT\n+     *\/\n+    public static final int MAX_EXPONENT = (1 << (SIZE - PRECISION - 1)) - 1; \/\/ 15\n+\n+    \/**\n+     * Minimum exponent a normalized {@code Float16} variable may\n+     * have, {@value}.  It is equal to the value returned by {@code\n+     * Float16.getExponent(Float16.MIN_NORMAL)}.\n+     *\n+     * @see Float#MIN_EXPONENT\n+     * @see Double#MIN_EXPONENT\n+     *\/\n+    public static final int MIN_EXPONENT = 1 - MAX_EXPONENT; \/\/ -14\n+\n+    \/**\n+     * The number of bytes used to represent a {@code Float16} value,\n+     * {@value}.\n+     *\n+     * @see Float#BYTES\n+     * @see Double#BYTES\n+     *\/\n+    public static final int BYTES = SIZE \/ Byte.SIZE;\n+\n+    \/**\n+     * Returns a string representation of the {@code Float16}\n+     * argument.\n+     *\n+     * @implSpec\n+     * The current implementation acts as if this {@code Float16} were\n+     * {@linkplain #floatValue() converted} to {@code float} and then\n+     * the string for that {@code float} returned. This behavior is\n+     * expected to change to accommodate the precision of {@code\n+     * Float16}.\n+     *\n+     * @param   f16   the {@code Float16} to be converted.\n+     * @return a string representation of the argument.\n+     * @see java.lang.Float#toString(float)\n+     *\/\n+    public static String toString(Float16 f16) {\n+        \/\/ FIXME -- update for Float16 precision\n+        return Float.toString(f16.floatValue());\n+        \/\/ return FloatToDecimal.toString(f16.floatValue());\n+    }\n+\n+    \/**\n+     * Returns a hexadecimal string representation of the {@code\n+     * Float16} argument.\n+     *\n+     * The behavior of this class is analogous to {@link\n+     * Float#toHexString(float)} except that an exponent value of\n+     * {@code \"p14\"} is used for subnormal {@code Float16} values.\n+     *\n+     * @param   f16   the {@code Float16} to be converted.\n+     * @return a hex string representation of the argument.\n+     *\n+     * @see Float#toHexString(float)\n+     * @see Double#toHexString(double)\n+     *\/\n+    public static String toHexString(Float16 f16) {\n+        float f = f16.floatValue();\n+        if (Math.abs(f) < float16ToFloat(MIN_NORMAL.value)\n+            &&  f != 0.0f ) {\/\/ Float16 subnormal\n+            \/\/ Adjust exponent to create subnormal double, then\n+            \/\/ replace subnormal double exponent with subnormal Float16\n+            \/\/ exponent\n+            String s = Double.toHexString(Math.scalb((double)f,\n+                                                     \/* -1022+14 *\/\n+                                                     Double.MIN_EXPONENT-\n+                                                     MIN_EXPONENT));\n+            return s.replaceFirst(\"p-1022$\", \"p-14\");\n+        } else {\/\/ double string will be the same as Float16 string\n+            return Double.toHexString(f);\n+        }\n+    }\n+\n+    \/\/ -----------------------\n+\n+   \/**\n+    * {@return the value of an {@code int} converted to {@code\n+    * Float16}}\n+    *\n+    * @param  value an {@code int} value.\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFromInt operation defined\n+    * in IEEE 754.\n+    *\/\n+    public static Float16 valueOf(int value) {\n+        \/\/ int -> double conversion is exact\n+        return valueOf((double)value);\n+    }\n+\n+   \/**\n+    * {@return the value of a {@code long} converted to {@code Float16}}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFromInt operation defined\n+    * in IEEE 754.\n+    *\n+    * @param  value a {@code long} value.\n+    *\/\n+    public static Float16 valueOf(long value) {\n+        if (value <= -65_520L) {  \/\/ -(Float16.MAX_VALUE + Float16.ulp(Float16.MAX_VALUE) \/ 2)\n+            return NEGATIVE_INFINITY;\n+        } else {\n+            if (value >= 65_520L) {  \/\/ Float16.MAX_VALUE + Float16.ulp(Float16.MAX_VALUE) \/ 2\n+                return POSITIVE_INFINITY;\n+            }\n+            \/\/ Remaining range of long, the integers in approx. +\/-\n+            \/\/ 2^16, all fit in a float so the correct conversion can\n+            \/\/ be done via an intermediate float conversion.\n+            return valueOf((float)value);\n+        }\n+    }\n+\n+   \/**\n+    * {@return a {@code Float16} value rounded from the {@code float}\n+    * argument using the round to nearest rounding policy}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFormat operation defined\n+    * in IEEE 754.\n+    *\n+    * @param  f a {@code float}\n+    *\/\n+    public static Float16 valueOf(float f) {\n+        return new Float16(Float.floatToFloat16(f));\n+    }\n+\n+   \/**\n+    * {@return a {@code Float16} value rounded from the {@code double}\n+    * argument using the round to nearest rounding policy}\n+    *\n+    * @apiNote\n+    * This method corresponds to the convertFormat operation defined\n+    * in IEEE 754.\n+    *\n+    * @param  d a {@code double}\n+    *\/\n+    public static Float16 valueOf(double d) {\n+        long doppel = Double.doubleToRawLongBits(d);\n+\n+        short sign_bit = (short)((doppel & 0x8000_0000_0000_0000L) >> 48);\n+\n+        if (Double.isNaN(d)) {\n+            \/\/ Have existing float code handle any attempts to\n+            \/\/ preserve NaN bits.\n+            return valueOf((float)d);\n+        }\n+\n+        double abs_d = Math.abs(d);\n+\n+        \/\/ The overflow threshold is binary16 MAX_VALUE + 1\/2 ulp\n+        if (abs_d >= (0x1.ffcp15 + 0x0.002p15) ) {\n+             \/\/ correctly signed infinity\n+            return new Float16((short)(sign_bit | 0x7c00));\n+        }\n+\n+        \/\/ Smallest magnitude nonzero representable binary16 value\n+        \/\/ is equal to 0x1.0p-24; half-way and smaller rounds to zero.\n+        if (abs_d <= 0x1.0p-24d * 0.5d) { \/\/ Covers double zeros and subnormals.\n+            return new Float16(sign_bit); \/\/ Positive or negative zero\n+        }\n+\n+        \/\/ Dealing with finite values in exponent range of binary16\n+        \/\/ (when rounding is done, could still round up)\n+        int exp = Math.getExponent(d);\n+        assert -25 <= exp && exp <= 15;\n+\n+        \/\/ For binary16 subnormals, beside forcing exp to -15, retain\n+        \/\/ the difference expdelta = E_min - exp.  This is the excess\n+        \/\/ shift value, in addition to 42, to be used in the\n+        \/\/ computations below.  Further the (hidden) msb with value 1\n+        \/\/ in d must be involved as well.\n+        int expdelta = 0;\n+        long msb = 0x0000_0000_0000_0000L;\n+        if (exp < -14) {\n+            expdelta = -14 - exp; \/\/ FIXME?\n+            exp = -15;\n+            msb = 0x0010_0000_0000_0000L; \/\/ should be 0x0020_... ?\n+        }\n+        long f_signif_bits = doppel & 0x000f_ffff_ffff_ffffL | msb;\n+\n+        \/\/ Significand bits as if using rounding to zero (truncation).\n+        short signif_bits = (short)(f_signif_bits >> (42 + expdelta));\n+\n+        \/\/ For round to nearest even, determining whether or not to\n+        \/\/ round up (in magnitude) is a function of the least\n+        \/\/ significant bit (LSB), the next bit position (the round\n+        \/\/ position), and the sticky bit (whether there are any\n+        \/\/ nonzero bits in the exact result to the right of the round\n+        \/\/ digit). An increment occurs in three cases:\n+        \/\/\n+        \/\/ LSB  Round Sticky\n+        \/\/ 0    1     1\n+        \/\/ 1    1     0\n+        \/\/ 1    1     1\n+        \/\/ See \"Computer Arithmetic Algorithms,\" Koren, Table 4.9\n+\n+        long lsb    = f_signif_bits & (1L << 42 + expdelta);\n+        long round  = f_signif_bits & (1L << 41 + expdelta);\n+        long sticky = f_signif_bits & ((1L << 41 + expdelta) - 1);\n+\n+        if (round != 0 && ((lsb | sticky) != 0 )) {\n+            signif_bits++;\n+        }\n+\n+        \/\/ No bits set in significand beyond the *first* exponent bit,\n+        \/\/ not just the significand; quantity is added to the exponent\n+        \/\/ to implement a carry out from rounding the significand.\n+        assert (0xf800 & signif_bits) == 0x0;\n+\n+        return new Float16((short)(sign_bit | ( ((exp + 15) << 10) + signif_bits ) ));\n+    }\n+\n+    \/**\n+     * Returns a {@code Float16} holding the floating-point value\n+     * represented by the argument string.\n+     *\n+     * @implSpec\n+     * The current implementation acts as if the string were\n+     * {@linkplain Double#parseDouble(String) parsed} as a {@code\n+     * double} and then {@linkplain #valueOf(double) converted} to\n+     * {@code Float16}. This behavior is expected to change to\n+     * accommodate the precision of {@code Float16}.\n+     *\n+     * @param  s the string to be parsed.\n+     * @return the {@code Float16} value represented by the string\n+     *         argument.\n+     * @throws NullPointerException  if the string is null\n+     * @throws NumberFormatException if the string does not contain a\n+     *               parsable {@code Float16}.\n+     * @see    java.lang.Float#valueOf(String)\n+     *\/\n+    public static Float16 valueOf(String s) throws NumberFormatException {\n+        \/\/ TOOD: adjust precision of parsing if needed\n+        return valueOf(Double.parseDouble(s));\n+    }\n+\n+    \/**\n+     * {@return a {@link Float16} value rounded from the {@link BigDecimal}\n+     * argument using the round to nearest rounding policy}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n+     *\n+     * @param  v a {@link BigDecimal}\n+     *\/\n+    public static Float16 valueOf(BigDecimal v) {\n+        return BigDecimalConversion.float16Value(v);\n+    }\n+\n+    private class BigDecimalConversion {\n+        \/*\n+         * Let l = log_2(10).\n+         * Then, L < l < L + ulp(L) \/ 2, that is, L = roundTiesToEven(l).\n+         *\/\n+        private static final double L = 3.321928094887362;\n+\n+        private static final int P_F16 = PRECISION;  \/\/ 11\n+        private static final int Q_MIN_F16 = MIN_EXPONENT - (P_F16 - 1);  \/\/ -24\n+        private static final int Q_MAX_F16 = MAX_EXPONENT - (P_F16 - 1);  \/\/ 5\n+\n+        \/**\n+         * Powers of 10 which can be represented exactly in {@code\n+         * Float16}.\n+         *\/\n+        private static final Float16[] FLOAT16_10_POW = {\n+            Float16.valueOf(1), Float16.valueOf(10), Float16.valueOf(100),\n+            Float16.valueOf(1_000), Float16.valueOf(10_000)\n+        };\n+\n+        public static Float16 float16Value(BigDecimal bd) {\n+             int scale = bd.scale();\n+             BigInteger unscaledValue = bd.unscaledValue();\n+\n+              if (unscaledValue.abs().compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0) {\n+                 long intCompact = unscaledValue.longValue();\n+                 Float16 v = Float16.valueOf(intCompact);\n+                 if (scale == 0) {\n+                     return v;\n+                 }\n+                 \/*\n+                  * The discussion for the double case also applies here. That is,\n+                  * the following test is precise for all long values, but here\n+                  * Long.MAX_VALUE is not an issue.\n+                  *\/\n+                 if (v.longValue() == intCompact) {\n+                     if (0 < scale && scale < FLOAT16_10_POW.length) {\n+                         return Float16.divide(v, FLOAT16_10_POW[scale]);\n+                     }\n+                     if (0 > scale && scale > -FLOAT16_10_POW.length) {\n+                         return Float16.multiply(v, FLOAT16_10_POW[-scale]);\n+                     }\n+                 }\n+             }\n+            return fullFloat16Value(bd);\n+        }\n+\n+        private static BigInteger bigTenToThe(int scale) {\n+            return BigInteger.TEN.pow(scale);\n+        }\n+\n+        private static Float16 fullFloat16Value(BigDecimal bd) {\n+            if (BigDecimal.ZERO.compareTo(bd) == 0) {\n+                return Float16.valueOf(0);\n+            }\n+            BigInteger w = bd.unscaledValue().abs();\n+            int scale = bd.scale();\n+            long qb = w.bitLength() - (long) Math.ceil(scale * L);\n+            Float16 signum = Float16.valueOf(bd.signum());\n+            if (qb < Q_MIN_F16 - 2) {  \/\/ qb < -26\n+                return Float16.multiply(signum, Float16.valueOf(0));\n+            }\n+            if (qb > Q_MAX_F16 + P_F16 + 1) {  \/\/ qb > 17\n+                return Float16.multiply(signum, Float16.POSITIVE_INFINITY);\n+            }\n+            if (scale < 0) {\n+                return Float16.multiply(signum, valueOf(w.multiply(bigTenToThe(-scale))));\n+            }\n+            if (scale == 0) {\n+                return Float16.multiply(signum, valueOf(w));\n+            }\n+            int ql = (int) qb - (P_F16 + 3);\n+            BigInteger pow10 =  bigTenToThe(scale);\n+            BigInteger m, n;\n+            if (ql <= 0) {\n+                m = w.shiftLeft(-ql);\n+                n = pow10;\n+            } else {\n+                m = w;\n+                n = pow10.shiftLeft(ql);\n+            }\n+            BigInteger[] qr = m.divideAndRemainder(n);\n+            \/*\n+             * We have\n+             *      2^12 = 2^{P+1} <= i < 2^{P+5} = 2^16\n+             * Contrary to the double and float cases, where we use long and int, resp.,\n+             * here we cannot simply declare i as short, because P + 5 < Short.SIZE\n+             * fails to hold.\n+             * Using int is safe, though.\n+             *\n+             * Further, as Math.scalb(Float16) does not exists, we fall back to\n+             * Math.scalb(double).\n+             *\/\n+            int i = qr[0].intValue();\n+            int sb = qr[1].signum();\n+            int dq = (Integer.SIZE - (P_F16 + 2)) - Integer.numberOfLeadingZeros(i);\n+            int eq = (Q_MIN_F16 - 2) - ql;\n+            if (dq >= eq) {\n+                return Float16.valueOf(bd.signum() * Math.scalb((double) (i | sb), ql));\n+            }\n+            int mask = (1 << eq) - 1;\n+            int j = i >> eq | (Integer.signum(i & mask)) | sb;\n+            return Float16.valueOf(bd.signum() * Math.scalb((double) j, Q_MIN_F16 - 2));\n+        }\n+\n+        public static Float16 valueOf(BigInteger bi) {\n+            int signum = bi.signum();\n+            return (signum == 0 || bi.bitLength() <= 31)\n+                ? Float16.valueOf(bi.longValue())  \/\/ might return infinities\n+                : signum > 0\n+                ? Float16.POSITIVE_INFINITY\n+                : Float16.NEGATIVE_INFINITY;\n+        }\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the specified number is a\n+     * Not-a-Number (NaN) value, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isNaN operation defined in IEEE\n+     * 754.\n+     *\n+     * @param   f16   the value to be tested.\n+     * @return  {@code true} if the argument is NaN;\n+     *          {@code false} otherwise.\n+     *\n+     * @see Float#isNaN(float)\n+     * @see Double#isNaN(double)\n+     *\/\n+    public static boolean isNaN(Float16 f16) {\n+        final short bits = float16ToRawShortBits(f16);\n+        \/\/ A NaN value has all ones in its exponent and a non-zero significand\n+        return ((bits & 0x7c00) == 0x7c00 && (bits & 0x03ff) != 0);\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the specified number is infinitely\n+     * large in magnitude, {@code false} otherwise.\n+     *\n+     * @apiNote\n+     * This method corresponds to the isInfinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param   f16   the value to be tested.\n+     * @return  {@code true} if the argument is positive infinity or\n+     *          negative infinity; {@code false} otherwise.\n+     *\n+     * @see Float#isInfinite(float)\n+     * @see Double#isInfinite(double)\n+     *\/\n+    public static boolean isInfinite(Float16 f16) {\n+        return ((float16ToRawShortBits(f16) ^ float16ToRawShortBits(POSITIVE_INFINITY)) & 0x7fff) == 0;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the argument is a finite floating-point\n+     * value; returns {@code false} otherwise (for NaN and infinity\n+     * arguments).\n+     *\n+     * @apiNote\n+     * This method corresponds to the isFinite operation defined in\n+     * IEEE 754.\n+     *\n+     * @param f16 the {@code Float16} value to be tested\n+     * @return {@code true} if the argument is a finite\n+     * floating-point value, {@code false} otherwise.\n+     *\n+     * @see Float#isFinite(float)\n+     * @see Double#isFinite(double)\n+     *\/\n+    public static boolean isFinite(Float16 f16) {\n+        return (float16ToRawShortBits(f16) & (short)0x0000_7FFF) <= float16ToRawShortBits(MAX_VALUE);\n+     }\n+\n+    \/**\n+     * {@return the value of this {@code Float16} as a {@code byte} after\n+     * a narrowing primitive conversion}\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public byte byteValue() {\n+        return (byte)floatValue();\n+    }\n+\n+    \/**\n+     * {@return a string representation of this {@code Float16}}\n+     *\n+     * @implSpec\n+     * This method returns the result of {@code Float16.toString(this)}.\n+     *\/\n+    public String toString() {\n+        return toString(this);\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Float16} as a {@code short}\n+     * after a narrowing primitive conversion}\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public short shortValue() {\n+        return (short)floatValue();\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Float16} as an {@code int} after\n+     * a narrowing primitive conversion}\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public int intValue() {\n+        return (int)floatValue();\n+    }\n+\n+    \/**\n+     * {@return value of this {@code Float16} as a {@code long} after a\n+     * narrowing primitive conversion}\n+     *\n+     * @jls 5.1.3 Narrowing Primitive Conversion\n+     *\/\n+    @Override\n+    public long longValue() {\n+        return (long)floatValue();\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Float16} as a {@code float}\n+     * after a widening primitive conversion}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n+     *\n+     * @jls 5.1.2 Widening Primitive Conversion\n+     *\/\n+    @Override\n+    public float floatValue() {\n+        return float16ToFloat(value);\n+    }\n+\n+    \/**\n+     * {@return the value of this {@code Float16} as a {@code double}\n+     * after a widening primitive conversion}\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFormat operation defined\n+     * in IEEE 754.\n+     *\n+     * @jls 5.1.2 Widening Primitive Conversion\n+     *\/\n+    @Override\n+    public double doubleValue() {\n+        return (double)floatValue();\n+    }\n+\n+    \/**\n+     * {@return a hash code for this {@code Float16} object}\n+     *\n+     * The general contract of {@code Object#hashCode()}is satisfied;\n+     * all NaN values have the same hash value.\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return hashCode(this);\n+    }\n+\n+    \/**\n+     * Returns a hash code for a {@code Float16} value; compatible with\n+     * {@code Float16.hashCode()}.\n+     *\n+     * @param value the value to hash\n+     * @return a hash code value for a {@code Float16} value.\n+     *\/\n+    public static int hashCode(Float16 value) {\n+        Float16 f16 = isNaN(value) ? Float16.NaN : value;\n+        return (int)float16ToRawShortBits(f16);\n+    }\n+\n+    \/**\n+     * Compares this object against the specified object.  The result\n+     * is {@code true} if and only if the argument is not\n+     * {@code null} and is a {@code Float16} object that\n+     * represents a {@code Float16} that has the same value as the\n+     * {@code double} represented by this object.\n+     *\n+     * @jls 15.21.1 Numerical Equality Operators == and !=\n+     *\/\n+    public boolean equals(Object obj) {\n+        return (obj instanceof Float16 f16) &&\n+            (float16ToShortBits(f16) == float16ToShortBits(this));\n+    }\n+\n+    \/**\n+     * Returns a representation of the specified floating-point value\n+     * according to the IEEE 754 floating-point binary16 bit layout.\n+     *\n+     * @param   f16   a {@code Float16} floating-point number.\n+     * @return the bits that represent the floating-point number.\n+     *\n+     * @see Float#floatToRawIntBits(float)\n+     * @see Double#doubleToRawLongBits(double)\n+     *\/\n+    public static short float16ToRawShortBits(Float16 f16) {\n+        return f16.value;\n+    }\n+\n+    \/**\n+     * Returns a representation of the specified floating-point value\n+     * according to the IEEE 754 floating-point binary16 bit layout.\n+     * All NaN values return the same bit pattern as {@link Float16#NaN}.\n+     *\n+     * @param   f16   a {@code Float16} floating-point number.\n+     * @return the bits that represent the floating-point number.\n+     *\n+     * @see Float#floatToRawIntBits(float)\n+     * @see Double#doubleToRawLongBits(double)\n+     *\/\n+    public static short float16ToShortBits(Float16 f16) {\n+        if (isNaN(f16)) {\n+            return Float16.NaN.value;\n+        }\n+        return f16.value;\n+    }\n+\n+    \/**\n+     * Returns the {@code Float16} value corresponding to a given bit\n+     * representation.\n+     *\n+     * @param   bits   any {@code short} integer.\n+     * @return  the {@code Float16} floating-point value with the same\n+     *          bit pattern.\n+     *\n+     * @see Float#intBitsToFloat(int)\n+     * @see Double#longBitsToDouble(long)\n+     *\/\n+    public static Float16 shortBitsToFloat16(short bits) {\n+        return new Float16(bits);\n+    }\n+\n+    \/**\n+     * Compares two {@code Float16} objects numerically.\n+     *\n+     * This method imposes a total order on {@code Float16} objects\n+     * with two differences compared to the incomplete order defined by\n+     * the Java language numerical comparison operators ({@code <, <=,\n+     * ==, >=, >}) on {@code float} and {@code double} values.\n+     *\n+     * <ul><li> A NaN is <em>unordered<\/em> with respect to other\n+     *          values and unequal to itself under the comparison\n+     *          operators.  This method chooses to define {@code\n+     *          Float16.NaN} to be equal to itself and greater than all\n+     *          other {@code Float16} values (including {@code\n+     *          Float16.POSITIVE_INFINITY}).\n+     *\n+     *      <li> Positive zero and negative zero compare equal\n+     *      numerically, but are distinct and distinguishable values.\n+     *      This method chooses to define positive zero\n+     *      to be greater than negative zero.\n+     * <\/ul>\n+     *\n+     * @param   anotherFloat16   the {@code Float16} to be compared.\n+     * @return  the value {@code 0} if {@code anotherFloat16} is\n+     *          numerically equal to this {@code Float16}; a value\n+     *          less than {@code 0} if this {@code Float16}\n+     *          is numerically less than {@code anotherFloat16};\n+     *          and a value greater than {@code 0} if this\n+     *          {@code Float16} is numerically greater than\n+     *          {@code anotherFloat16}.\n+     *\n+     * @see Float#compareTo(Float)\n+     * @see Double#compareTo(Double)\n+     * @jls 15.20.1 Numerical Comparison Operators {@code <}, {@code <=}, {@code >}, and {@code >=}\n+     *\/\n+    @Override\n+    public int compareTo(Float16 anotherFloat16) {\n+        return compare(this, anotherFloat16);\n+    }\n+\n+    \/**\n+     * Compares the two specified {@code Float16} values.\n+     *\n+     * @param   f1        the first {@code Float16} to compare\n+     * @param   f2        the second {@code Float16} to compare\n+     * @return  the value {@code 0} if {@code f1} is\n+     *          numerically equal to {@code f2}; a value less than\n+     *          {@code 0} if {@code f1} is numerically less than\n+     *          {@code f2}; and a value greater than {@code 0}\n+     *          if {@code f1} is numerically greater than\n+     *          {@code f2}.\n+     *\n+     * @see Float#compare(float, float)\n+     * @see Double#compare(double, double)\n+     *\/\n+    public static int compare(Float16 f1, Float16 f2) {\n+        return Float.compare(f1.floatValue(), f2.floatValue());\n+    }\n+\n+    \/**\n+     * Returns the larger of two {@code Float16} values.\n+     *\n+     * @apiNote\n+     * This method corresponds to the maximum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the greater of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @see Math#max(float, float)\n+     * @see Math#max(double, double)\n+     *\/\n+    public static Float16 max(Float16 a, Float16 b) {\n+        return shortBitsToFloat16(floatToFloat16(Math.max(a.floatValue(),\n+                                                          b.floatValue() )));\n+    }\n+\n+    \/**\n+     * Returns the smaller of two {@code Float16} values.\n+     *\n+     * @apiNote\n+     * This method corresponds to the minimum operation defined in\n+     * IEEE 754.\n+     *\n+     * @param a the first operand\n+     * @param b the second operand\n+     * @return the smaller of {@code a} and {@code b}\n+     * @see java.util.function.BinaryOperator\n+     * @see Math#min(float, float)\n+     * @see Math#min(double, double)\n+     *\/\n+    public static Float16 min(Float16 a, Float16 b) {\n+        return shortBitsToFloat16(floatToFloat16(Math.min(a.floatValue(),\n+                                                          b.floatValue()) ));\n+    }\n+\n+    \/\/ Skipping for now\n+    \/\/ public Optional<Float16> describeConstable()\n+    \/\/ public Float16 resolveConstantDesc(MethodHandles.Lookup lookup)\n+\n+    \/*\n+     * Note: for the basic arithmetic operations {+, -, *, \/} and\n+     * square root, among binary interchange formats (binary16,\n+     * binary32 a.k.a. float, binary64 a.k.a double, etc.) the \"2p + 2\"\n+     * property holds. That is, if one format has p bits of precision,\n+     * if the next larger format has at least 2p + 2 bits of\n+     * precision, arithmetic on the smaller format can be implemented by:\n+     *\n+     * 1) converting each argument to the wider format\n+     * 2) performing the operation in the wider format\n+     * 3) converting the result from 2) to the narrower format\n+     *\n+     * For example, this property hold between the formats used for the\n+     * float and double types. Therefore, the following is a valid\n+     * implementation of a float addition:\n+     *\n+     * float add(float addend, float augend) {\n+     *     return (float)((double)addend + (double)augend);\n+     * }\n+     *\n+     * The same property holds between the float16 format and\n+     * float. Therefore, the software implementations of Float16 {+,\n+     * -, *, \/} and square root below use the technique of widening\n+     * the Float16 arguments to float, performing the operation in\n+     * float arithmetic, and then rounding the float result to\n+     * Float16.\n+     *\n+     * For discussion and derivation of this property see:\n+     *\n+     * \"When Is Double Rounding Innocuous?\" by Samuel Figueroa\n+     * ACM SIGNUM Newsletter, Volume 30 Issue 3, pp 21-26\n+     * https:\/\/dl.acm.org\/doi\/pdf\/10.1145\/221332.221334\n+     *\n+     * Figueroa's write-up refers to lecture notes by W. Kahan. Those\n+     * lectures notes are assumed to be these ones by Kahan and\n+     * others:\n+     *\n+     * https:\/\/www.arithmazium.org\/classroom\/lib\/Lecture_08_notes_slides.pdf\n+     * https:\/\/www.arithmazium.org\/classroom\/lib\/Lecture_09_notes_slides.pdf\n+     *\/\n+\n+    \/**\n+     * Adds two {@code Float16} values together as per the {@code +}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code +} operator for\n+     * floating-point addition (JLS {@jls 15.18.2}).\n+     *\n+     * @apiNote This method corresponds to the addition operation\n+     * defined in IEEE 754.\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     * @return the sum of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     * @jls 15.18.2 Additive Operators (+ and -) for Numeric Types\n+     *\/\n+    public static Float16 add(Float16 addend, Float16 augend) {\n+        return valueOf(addend.floatValue() + augend.floatValue());\n+    }\n+\n+    \/**\n+     * Subtracts two {@code Float16} values as per the {@code -}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, infinities, and other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code -} operator for\n+     * floating-point subtraction (JLS {@jls 15.18.2}).\n+     *\n+     * @apiNote This method corresponds to the subtraction operation\n+     * defined in IEEE 754.\n+     *\n+     * @param minuend the first operand\n+     * @param  subtrahend the second operand\n+     * @return the difference of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     * @jls 15.18.2 Additive Operators (+ and -) for Numeric Types\n+     *\/\n+    public static Float16 subtract(Float16 minuend, Float16 subtrahend) {\n+        return valueOf(minuend.floatValue() - subtrahend.floatValue());\n+    }\n+\n+    \/**\n+     * Multiplies two {@code Float16} values as per the {@code *}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, and infinities, other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code *} operator for\n+     * floating-point multiplication (JLS {@jls 15.17.1}).\n+     *\n+     * @apiNote This method corresponds to the multiplication\n+     * operation defined in IEEE 754.\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     * @return the product of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     * @jls 15.17.1 Multiplication Operator *\n+     *\/\n+    public static Float16 multiply(Float16 multiplier, Float16 multiplicand) {\n+        return valueOf(multiplier.floatValue() * multiplicand.floatValue());\n+    }\n+\n+    \/**\n+     * Divides two {@code Float16} values as per the {@code \/}\n+     * operator semantics using the round to nearest rounding policy.\n+     *\n+     * The handling of signed zeros, NaNs, and infinities, other\n+     * special cases by this method is the same as for the handling of\n+     * those cases by the built-in {@code \/} operator for\n+     * floating-point division (JLS {@jls 15.17.2}).\n+     *\n+     * @apiNote This method corresponds to the division\n+     * operation defined in IEEE 754.\n+     *\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     * @return the quotient of the operands\n+     *\n+     * @jls 15.4 Floating-point Expressions\n+     * @jls 15.17.2 Division Operator \/\n+     *\/\n+    public static Float16 divide(Float16 dividend, Float16 divisor) {\n+        return valueOf(dividend.floatValue() \/ divisor.floatValue());\n+    }\n+\n+    \/**\n+     * {@return the square root of the operand} The square root is\n+     * computed using the round to nearest rounding policy.\n+     *\n+     * The handling of zeros, NaN, infinities, and negative arguments\n+     * by this method is analogous to the handling of those cases by\n+     * {@link Math#sqrt(double)}.\n+     *\n+     * @apiNote\n+     * This method corresponds to the squareRoot operation defined in\n+     * IEEE 754.\n+     *\n+     * @param radicand the argument to have its square root taken\n+     *\n+     * @see Math#sqrt(double)\n+     *\/\n+    public static Float16 sqrt(Float16 radicand) {\n+        \/\/ Rounding path of sqrt(Float16 -> double) -> Float16 is fine\n+        \/\/ for preserving the correct final value. The conversion\n+        \/\/ Float16 -> double preserves the exact numerical value. The\n+        \/\/ conversion of double -> Float16 also benefits from the\n+        \/\/ 2p+2 property of IEEE 754 arithmetic.\n+        return valueOf(Math.sqrt(radicand.doubleValue()));\n+    }\n+\n+    \/**\n+     * Returns the fused multiply add of the three arguments; that is,\n+     * returns the exact product of the first two arguments summed\n+     * with the third argument and then rounded once to the nearest\n+     * {@code Float16}.\n+     *\n+     * The handling of zeros, NaN, infinities, and other special cases\n+     * by this method is analogous to the handling of those cases by\n+     * {@link Math#fma(float, float, float)}.\n+     *\n+     * @apiNote This method corresponds to the fusedMultiplyAdd\n+     * operation defined in IEEE 754.\n+     *\n+     * @param a a value\n+     * @param b a value\n+     * @param c a value\n+     *\n+     * @return (<i>a<\/i>&nbsp;&times;&nbsp;<i>b<\/i>&nbsp;+&nbsp;<i>c<\/i>)\n+     * computed, as if with unlimited range and precision, and rounded\n+     * once to the nearest {@code Float16} value\n+     *\n+     * @see Math#fma(float, float, float)\n+     * @see Math#fma(double, double, double)\n+     *\/\n+    public static Float16 fma(Float16 a, Float16 b, Float16 c) {\n+        \/*\n+         * The double format has sufficient precision that a Float16\n+         * fma can be computed by doing the arithmetic in double, with\n+         * one rounding error for the sum, and then a second rounding\n+         * error to round the product-sum to Float16. In pseudocode,\n+         * this method is equivalent to the following code, assuming\n+         * casting was defined between Float16 and double:\n+         *\n+         * double product = (double)a * (double)b;  \/\/ Always exact\n+         * double productSum = product + (double)c;\n+         * return (Float16)produdctSum;\n+         *\n+         * (Note that a similar relationship does *not* hold between\n+         * the double format and computing a float fma.)\n+         *\n+         * Below is a sketch of the proof that simple double\n+         * arithmetic can be used to implement a correctly rounded\n+         * Float16 fma.\n+         *\n+         * ----------------------\n+         *\n+         * As preliminaries, the handling of NaN and Infinity\n+         * arguments falls out as a consequence of general operation\n+         * of non-finite values by double * and +. Any NaN argument to\n+         * fma will lead to a NaN result, infinities will propagate or\n+         * get turned into NaN as appropriate, etc.\n+         *\n+         * One or more zero arguments are also handled correctly,\n+         * including the propagation of the sign of zero if all three\n+         * arguments are zero.\n+         *\n+         * The double format has 53 logical bits of precision and its\n+         * exponent range goes from -1022 to 1023. The Float16 format\n+         * has 11 bits of logical precision and its exponent range\n+         * goes from -14 to 15. Therefore, the individual powers of 2\n+         * representable in the Float16 format range from the\n+         * subnormal 2^(-24), MIN_VALUE, to 2^15, the leading bit\n+         * position of MAX_VALUE.\n+         *\n+         * In cases where the numerical value of (a * b) + c is\n+         * computed exactly in a double, after a single rounding to\n+         * Float16, the result is necessarily correct since the one\n+         * double -> Float16 conversion is the only source of\n+         * numerical error. The operation as implemented in those\n+         * cases would be equivalent to rounding the infinitely precise\n+         * value to the result format, etc.\n+         *\n+         * However, for some inputs, the intermediate product-sum will\n+         * *not* be exact and additional analysis is needed to justify\n+         * not having any corrective computation to compensate for\n+         * intermediate rounding errors.\n+         *\n+         * The following analysis will rely on the range of bit\n+         * positions representable in the intermediate\n+         * product-sum.\n+         *\n+         * For the product a*b of Float16 inputs, the range of\n+         * exponents for nonzero finite results goes from 2^(-48)\n+         * (from MIN_VALUE squared) to 2^31 (from the exact value of\n+         * MAX_VALUE squared). This full range of exponent positions,\n+         * (31 -(-48) + 1 ) = 80 exceeds the precision of\n+         * double. However, only the product a*b can exceed the\n+         * exponent range of Float16. Therefore, there are three main\n+         * cases to consider:\n+         *\n+         * 1) Large exponent product, exponent > Float16.MAX_EXPONENT\n+         *\n+         * The magnitude of the overflow threshold for Float16 is:\n+         *\n+         * MAX_VALUE + 1\/2 * ulp(MAX_VALUE) =  0x1.ffcp15 + 0x0.002p15 = 0x1.ffep15\n+         *\n+         * Therefore, for any product greater than or equal in\n+         * magnitude to (0x1.ffep15 + MAX_VALUE) = 0x1.ffdp16, the\n+         * final fma result will certainly overflow to infinity (under\n+         * round to nearest) since adding in c = -MAX_VALUE will still\n+         * be at or above the overflow threshold.\n+         *\n+         * If the exponent of the product is 15 or 16, the smallest\n+         * subnormal Float16 is 2^-24 and the ~40 bit wide range bit\n+         * positions would fit in a single double exactly.\n+         *\n+         * 2) Exponent of product is within the range of _normal_\n+         * Float16 values; Float16.MIN_EXPONENT <=  exponent <= Float16.MAX_EXPONENT\n+         *\n+         * The exact product has at most 22 contiguous bits in its\n+         * logical significand. The third number being added in has at\n+         * most 11 contiguous bits in its significand and the lowest\n+         * bit position that could be set is 2^(-24). Therefore, when\n+         * the product has the maximum in-range exponent, 2^15, a\n+         * single double has enough precision to hold down to the\n+         * smallest subnormal bit position, 15 - (-24) + 1 = 40 <\n+         * 53. If the product was large and rounded up, increasing the\n+         * exponent, when the third operand was added, this would\n+         * cause the exponent to go up to 16, which is within the\n+         * range of double, so the product-sum is exact and will be\n+         * correct when rounded to Float16.\n+         *\n+         * 3) Exponent of product is in the range of subnormal values or smaller,\n+         * exponent < Float16.MIN_EXPONENT\n+         *\n+         * The smallest exponent possible in a product is 2^(-48).\n+         * For moderately sized Float16 values added to the product,\n+         * with an exponent of about 4, the sum will not be\n+         * exact. Therefore, an analysis is needed to determine if the\n+         * double-rounding is benign or would lead to a different\n+         * final Float16 result. Double rounding can lead to a\n+         * different result in two cases:\n+         *\n+         * 1) The first rounding from the exact value to the extended\n+         * precision (here `double`) happens to be directed _toward_ 0\n+         * to a value exactly midway between two adjacent working\n+         * precision (here `Float16`) values, followed by a second\n+         * rounding from there which again happens to be directed\n+         * _toward_ 0 to one of these values (the one with lesser\n+         * magnitude).  A single rounding from the exact value to the\n+         * working precision, in contrast, rounds to the value with\n+         * larger magnitude.\n+         *\n+         * 2) Symmetrically, the first rounding to the extended\n+         * precision happens to be directed _away_ from 0 to a value\n+         * exactly midway between two adjacent working precision\n+         * values, followed by a second rounding from there which\n+         * again happens to be directed _away_ from 0 to one of these\n+         * values (the one with larger magnitude).  However, a single\n+         * rounding from the exact value to the working precision\n+         * rounds to the value with lesser magnitude.\n+         *\n+         * If the double rounding occurs in other cases, it is\n+         * innocuous, returning the same value as a single rounding to\n+         * the final format. Therefore, it is sufficient to show that\n+         * the first rounding to double does not occur at the midpoint\n+         * of two adjacent Float16 values:\n+         *\n+         * 1) If a, b and c have the same sign, the sum a*b + c has a\n+         * significand with a large gap of 20 or more 0s between the\n+         * bits of the significand of c to the left (at most 11 bits)\n+         * and those of the product a*b to the right (at most 22\n+         * bits).  The rounding bit for the final working precision of\n+         * `float16` is the leftmost 0 in the gap.\n+         *\n+         *   a) If rounding to `double` is directed toward 0, all the\n+         *   0s in the gap are preserved, thus the `Float16` rounding\n+         *   bit is unaffected and remains 0. This means that the\n+         *   `double` value is _not_ the midpoint of two adjacent\n+         *   `float16` values, so double rounding is harmless.\n+         *\n+         *   b) If rounding to `double` is directed away form 0, the\n+         *   rightmost 0 in the gap might be replaced by a 1, but the\n+         *   others are unaffected, including the `float16` rounding\n+         *   bit. Again, this shows that the `double` value is _not_\n+         *   the midpoint of two adjacent `float16` values, and double\n+         *   rounding is innocuous.\n+         *\n+         * 2) If a, b and c have opposite signs, in the sum a*b + c\n+         * the long gap of 0s above is replaced by a long gap of\n+         * 1s. The `float16` rounding bit is the leftmost 1 in the\n+         * gap, or the second leftmost 1 iff c is a power of 2. In\n+         * both cases, the rounding bit is followed by at least\n+         * another 1.\n+         *\n+         *   a) If rounding to `double` is directed toward 0, the\n+         *   `float16` rounding bit and its follower are preserved and\n+         *   both 1, so the `double` value is _not_ the midpoint of\n+         *   two adjacent `float16` values, and double rounding is\n+         *   harmless.\n+         *\n+         *   b) If rounding to `double` is directed away from 0, the\n+         *   `float16` rounding bit and its follower are either\n+         *   preserved (both 1), or both switch to 0. Either way, the\n+         *   `double` value is again _not_ the midpoint of two\n+         *   adjacent `float16` values, and double rounding is\n+         *   harmless.\n+         *\/\n+\n+        \/\/ product is numerically exact in float before the cast to\n+        \/\/ double; not necessary to widen to double before the\n+        \/\/ multiply.\n+        double product = (double)(a.floatValue() * b.floatValue());\n+        return valueOf(product + c.doubleValue());\n+    }\n+\n+    \/**\n+     * {@return the negation of the argument}\n+     *\n+     * Special cases:\n+     * <ul>\n+     * <li> If the argument is zero, the result is a zero with the\n+     * opposite sign as the argument.\n+     * <li> If the argument is infinite, the result is an infinity\n+     * with the opposite sign as the argument.\n+     * <li> If the argument is a NaN, the result is a NaN.\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * This method corresponds to the negate operation defined in IEEE\n+     * 754.\n+     *\n+     * @param f16 the value to be negated\n+     * @jls 15.15.4 Unary Minus Operator {@code -}\n+     *\/\n+    public static Float16 negate(Float16 f16) {\n+        \/\/ Negate sign bit only. Per IEEE 754-2019 section 5.5.1,\n+        \/\/ negate is a bit-level operation and not a logical\n+        \/\/ operation. Therefore, in this case do _not_ use the float\n+        \/\/ unary minus as an implementation as that is not guaranteed\n+        \/\/ to flip the sign bit of a NaN.\n+        return shortBitsToFloat16((short)(f16.value ^ (short)0x0000_8000));\n+    }\n+\n+    \/**\n+     * {@return the absolute value of the argument}\n+     *\n+     * The handling of zeros, NaN, and infinities by this method is\n+     * analogous to the handling of those cases by {@link\n+     * Math#abs(float)}.\n+     *\n+     * @param f16 the argument whose absolute value is to be determined\n+     *\n+     * @see Math#abs(float)\n+     * @see Math#abs(double)\n+     *\/\n+    public static Float16 abs(Float16 f16) {\n+        \/\/ Zero out sign bit. Per IEE 754-2019 section 5.5.1, abs is a\n+        \/\/ bit-level operation and not a logical operation.\n+        return shortBitsToFloat16((short)(f16.value & (short)0x0000_7FFF));\n+    }\n+\n+    \/**\n+     * Returns the unbiased exponent used in the representation of a\n+     * {@code Float16}.\n+     *\n+     * <ul>\n+     * <li>If the argument is NaN or infinite, then the result is\n+     * {@link Float16#MAX_EXPONENT} + 1.\n+     * <li>If the argument is zero or subnormal, then the result is\n+     * {@link Float16#MIN_EXPONENT} - 1.\n+     * <\/ul>\n+     *\n+     * @apiNote\n+     * This method is analogous to the logB operation defined in IEEE\n+     * 754, but returns a different value on subnormal arguments.\n+     *\n+     * @param f16 a {@code Float16} value\n+     * @return the unbiased exponent of the argument\n+     *\n+     * @see Math#getExponent(float)\n+     * @see Math#getExponent(double)\n+     *\/\n+    public static int getExponent(Float16 f16) {\n+        return getExponent0(f16.value);\n+    }\n+\n+    \/**\n+     * From the bitwise representation of a float16, mask out exponent\n+     * bits, shift to the right and then subtract out float16's bias\n+     * adjust, 15, to get true exponent value.\n+     *\/\n+    \/*package*\/ static int getExponent0(short bits) {\n+        \/\/ package private to be usable in java.lang.Float.\n+        int bin16ExpBits     = 0x0000_7c00 & bits;     \/\/ Five exponent bits.\n+        return (bin16ExpBits >> (PRECISION - 1)) - 15;\n+    }\n+\n+    \/**\n+     * Returns the size of an ulp of the argument.  An ulp, unit in\n+     * the last place, of a {@code Float16} value is the positive\n+     * distance between this floating-point value and the {@code\n+     * Float16} value next larger in magnitude.  Note that for non-NaN\n+     * <i>x<\/i>, <code>ulp(-<i>x<\/i>) == ulp(<i>x<\/i>)<\/code>.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is NaN.\n+     * <li> If the argument is positive or negative infinity, then the\n+     * result is positive infinity.\n+     * <li> If the argument is positive or negative zero, then the result is\n+     * {@code Float16.MIN_VALUE}.\n+     * <li> If the argument is &plusmn;{@code Float16.MAX_VALUE}, then\n+     * the result is equal to 2<sup>5<\/sup>, 32.0.\n+     * <\/ul>\n+     *\n+     * @param f16 the floating-point value whose ulp is to be returned\n+     * @return the size of an ulp of the argument\n+     *\/\n+    public static Float16 ulp(Float16 f16) {\n+        int exp = getExponent(f16);\n+\n+        return switch(exp) {\n+        case MAX_EXPONENT + 1 -> abs(f16);          \/\/ NaN or infinity\n+        case MIN_EXPONENT - 1 -> Float16.MIN_VALUE; \/\/ zero or subnormal\n+        default -> {\n+            assert exp <= MAX_EXPONENT && exp >= MIN_EXPONENT;\n+            \/\/ ulp(x) is usually 2^(SIGNIFICAND_WIDTH-1)*(2^ilogb(x))\n+            \/\/ Let float -> float16 conversion handle encoding issues.\n+            yield scalb(valueOf(1), exp - (PRECISION - 1));\n+        }\n+        };\n+    }\n+\n+    \/**\n+     * Returns the floating-point value adjacent to {@code v} in\n+     * the direction of positive infinity.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, the result is NaN.\n+     *\n+     * <li> If the argument is positive infinity, the result is\n+     * positive infinity.\n+     *\n+     * <li> If the argument is zero, the result is\n+     * {@link #MIN_VALUE}\n+     *\n+     * <\/ul>\n+     *\n+     * @apiNote This method corresponds to the nextUp\n+     * operation defined in IEEE 754.\n+     *\n+     * @param v starting floating-point value\n+     * @return The adjacent floating-point value closer to positive\n+     * infinity.\n+     *\/\n+    public static Float16 nextUp(Float16 v) {\n+        float f = v.floatValue();\n+        if (f < Float.POSITIVE_INFINITY) {\n+            if (f != 0) {\n+                int bits = float16ToRawShortBits(v);\n+                return shortBitsToFloat16((short) (bits + ((bits >= 0) ? 1 : -1)));\n+            }\n+            return MIN_VALUE;\n+        }\n+        return v; \/\/ v is NaN or +Infinity\n+    }\n+\n+    \/**\n+     * Returns the floating-point value adjacent to {@code v} in\n+     * the direction of negative infinity.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, the result is NaN.\n+     *\n+     * <li> If the argument is negative infinity, the result is\n+     * negative infinity.\n+     *\n+     * <li> If the argument is zero, the result is\n+     * -{@link #MIN_VALUE}\n+     *\n+     * <\/ul>\n+     *\n+     * @apiNote This method corresponds to the nextDown\n+     * operation defined in IEEE 754.\n+     *\n+     * @param v  starting floating-point value\n+     * @return The adjacent floating-point value closer to negative\n+     * infinity.\n+     *\/\n+    public static Float16 nextDown(Float16 v) {\n+        float f = v.floatValue();\n+        if (f > Float.NEGATIVE_INFINITY) {\n+            if (f != 0) {\n+                int bits = float16ToRawShortBits(v);\n+                return shortBitsToFloat16((short) (bits - ((bits >= 0) ? 1 : -1)));\n+            }\n+            return negate(MIN_VALUE);\n+        }\n+        return v; \/\/ v is NaN or -Infinity\n+    }\n+\n+    \/**\n+     * Returns {@code v} &times; 2<sup>{@code scaleFactor}<\/sup>\n+     * rounded as if performed by a single correctly rounded\n+     * floating-point multiply.  If the exponent of the result is\n+     * between {@link Float16#MIN_EXPONENT} and {@link\n+     * Float16#MAX_EXPONENT}, the answer is calculated exactly.  If the\n+     * exponent of the result would be larger than {@code\n+     * Float16.MAX_EXPONENT}, an infinity is returned.  Note that if the\n+     * result is subnormal, precision may be lost; that is, when\n+     * {@code scalb(x, n)} is subnormal, {@code scalb(scalb(x, n),\n+     * -n)} may not equal <i>x<\/i>.  When the result is non-NaN, the\n+     * result has the same sign as {@code v}.\n+     *\n+     * <p>Special cases:\n+     * <ul>\n+     * <li> If the first argument is NaN, NaN is returned.\n+     * <li> If the first argument is infinite, then an infinity of the\n+     * same sign is returned.\n+     * <li> If the first argument is zero, then a zero of the same\n+     * sign is returned.\n+     * <\/ul>\n+     *\n+     * @apiNote This method corresponds to the scaleB operation\n+     * defined in IEEE 754.\n+     *\n+     * @param v number to be scaled by a power of two.\n+     * @param scaleFactor power of 2 used to scale {@code v}\n+     * @return {@code v} &times; 2<sup>{@code scaleFactor}<\/sup>\n+     *\/\n+    public static Float16 scalb(Float16 v, int scaleFactor) {\n+        \/\/ magnitude of a power of two so large that scaling a finite\n+        \/\/ nonzero value by it would be guaranteed to over or\n+        \/\/ underflow; due to rounding, scaling down takes an\n+        \/\/ additional power of two which is reflected here\n+        final int MAX_SCALE = Float16.MAX_EXPONENT + -Float16.MIN_EXPONENT +\n+                Float16Consts.SIGNIFICAND_WIDTH + 1;\n+\n+        \/\/ Make sure scaling factor is in a reasonable range\n+        scaleFactor = Math.max(Math.min(scaleFactor, MAX_SCALE), -MAX_SCALE);\n+\n+        int DoubleConsts_EXP_BIAS = 1023;\n+        \/*\n+         * Since + MAX_SCALE for Float16 fits well within the double\n+         * exponent range and + Float16 -> double conversion is exact\n+         * the multiplication below will be exact. Therefore, the\n+         * rounding that occurs when the double product is cast to\n+         * Float16 will be the correctly rounded Float16 result.\n+         *\/\n+        return valueOf(v.doubleValue()\n+                * Double.longBitsToDouble((long) (scaleFactor + DoubleConsts_EXP_BIAS) << Double.PRECISION - 1));\n+    }\n+    \/**\n+     * Returns the first floating-point argument with the sign of the\n+     * second floating-point argument.\n+     * This method does not require NaN {@code sign}\n+     * arguments to be treated as positive values; implementations are\n+     * permitted to treat some NaN arguments as positive and other NaN\n+     * arguments as negative to allow greater performance.\n+     *\n+     * @apiNote\n+     * This method corresponds to the copySign operation defined in\n+     * IEEE 754.\n+     *\n+     * @param magnitude  the parameter providing the magnitude of the result\n+     * @param sign   the parameter providing the sign of the result\n+     * @return a value with the magnitude of {@code magnitude}\n+     * and the sign of {@code sign}.\n+     *\/\n+    public static Float16 copySign(Float16 magnitude, Float16 sign) {\n+        return shortBitsToFloat16((short) ((float16ToRawShortBits(sign) &\n+                        (Float16Consts.SIGN_BIT_MASK)) |\n+                        (float16ToRawShortBits(magnitude) &\n+                                (Float16Consts.EXP_BIT_MASK |\n+                                        Float16Consts.SIGNIF_BIT_MASK))));\n+    }\n+\n+    \/**\n+     * Returns the signum function of the argument; zero if the argument\n+     * is zero, 1.0 if the argument is greater than zero, -1.0 if the\n+     * argument is less than zero.\n+     *\n+     * <p>Special Cases:\n+     * <ul>\n+     * <li> If the argument is NaN, then the result is NaN.\n+     * <li> If the argument is positive zero or negative zero, then the\n+     *      result is the same as the argument.\n+     * <\/ul>\n+     *\n+     * @param f the floating-point value whose signum is to be returned\n+     * @return the signum function of the argument\n+     *\/\n+    public static Float16 signum(Float16 f) {\n+        return (f.floatValue() == 0.0f || isNaN(f)) ? f : copySign(valueOf(1), f);\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":1518,"deletions":0,"binary":false,"changes":1518,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.vector;\n+\n+import static jdk.incubator.vector.Float16.MIN_EXPONENT;\n+import static jdk.incubator.vector.Float16.PRECISION;\n+import static jdk.incubator.vector.Float16.SIZE;\n+\n+\/**\n+ * This class contains additional constants documenting limits of the\n+ * {@code Float16} type.\n+ *\/\n+\n+class Float16Consts {\n+    \/**\n+     * Don't let anyone instantiate this class.\n+     *\/\n+    private Float16Consts() {}\n+\n+    \/**\n+     * The number of logical bits in the significand of a\n+     * {@code Float16} number, including the implicit bit.\n+     *\/\n+    public static final int SIGNIFICAND_WIDTH = PRECISION;\n+\n+    \/**\n+     * The exponent the smallest positive {@code Float16}\n+     * subnormal value would have if it could be normalized.\n+     *\/\n+    public static final int MIN_SUB_EXPONENT =\n+            MIN_EXPONENT - (SIGNIFICAND_WIDTH - 1); \/\/ -24\n+\n+    \/**\n+     * Bias used in representing a {@code Float16} exponent.\n+     *\/\n+    public static final int EXP_BIAS =\n+            (1 << (SIZE - SIGNIFICAND_WIDTH - 1)) - 1; \/\/ 15\n+\n+    \/**\n+     * Bit mask to isolate the sign bit of a {@code Float16}.\n+     *\/\n+    public static final int SIGN_BIT_MASK = 1 << (SIZE - 1);\n+\n+    \/**\n+     * Bit mask to isolate the exponent field of a {@code Float16}.\n+     *\/\n+    public static final int EXP_BIT_MASK =\n+            ((1 << (SIZE - SIGNIFICAND_WIDTH)) - 1) << (SIGNIFICAND_WIDTH - 1);\n+\n+    \/**\n+     * Bit mask to isolate the significand field of a {@code Float16}.\n+     *\/\n+    public static final int SIGNIF_BIT_MASK = (1 << (SIGNIFICAND_WIDTH - 1)) - 1;\n+\n+    \/**\n+     * Bit mask to isolate the magnitude bits (combined exponent and\n+     * significand fields) of a {@code Float16}.\n+     *\/\n+    public static final int MAG_BIT_MASK = EXP_BIT_MASK | SIGNIF_BIT_MASK;\n+\n+    static {\n+        \/\/ verify bit masks cover all bit positions and that the bit\n+        \/\/ masks are non-overlapping\n+        assert(((SIGN_BIT_MASK | EXP_BIT_MASK | SIGNIF_BIT_MASK) == 0xFFFF) &&\n+               (((SIGN_BIT_MASK & EXP_BIT_MASK) == 0) &&\n+                ((SIGN_BIT_MASK & SIGNIF_BIT_MASK) == 0) &&\n+                ((EXP_BIT_MASK & SIGNIF_BIT_MASK) == 0)) &&\n+                ((SIGN_BIT_MASK | MAG_BIT_MASK) == 0xFFFF));\n+    }\n+}\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16Consts.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,3 @@\n- * @bug 8205592\n- * @summary Verify {double, float}Value methods work\n+ * @bug 8205592 8339252 8341260\n+ * @summary Verify {double, float, float16}Value methods work\n+ * @modules jdk.incubator.vector\n@@ -38,0 +39,1 @@\n+import jdk.incubator.vector.Float16;\n@@ -67,0 +69,12 @@\n+    private static BigDecimal nextHalfUp(Float16 v) {\n+        BigDecimal bv = new BigDecimal(v.doubleValue());\n+        BigDecimal ulp = new BigDecimal(Float16.ulp(v).doubleValue());\n+        return bv.add(ulp.multiply(HALF));\n+    }\n+\n+    private static BigDecimal nextHalfDown(Float16 v) {\n+        BigDecimal bv = new BigDecimal(v.doubleValue());\n+        BigDecimal ulp = new BigDecimal(v.doubleValue() - Float16.nextDown(v).doubleValue());\n+        return bv.subtract(ulp.multiply(HALF));\n+    }\n+\n@@ -75,0 +89,4 @@\n+    private static String toDecHexString(Float16 v) {\n+        return v + \" (\" + Float16.toHexString(v) + \")\";\n+    }\n+\n@@ -93,0 +111,9 @@\n+    private static void checkFloat16(BigDecimal bv, Float16 exp) {\n+        Float16 res =  Float16.valueOf(bv); \/\/ bv.float16Value();\n+        if (exp.floatValue() != res.floatValue()) {\n+            String message = \"Bad conversion: got \" + toDecHexString(res) +\n+                    \", expected \" + toDecHexString(exp);\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n@@ -115,0 +142,9 @@\n+    private static void testFloat16ValueNearMinValue() {\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal b = nextHalfUp(Float16.multiply(Float16.valueOf(n), Float16.MIN_VALUE));\n+            checkFloat16(b, Float16.multiply(Float16.valueOf((n + 1) \/ 2 * 2), Float16.MIN_VALUE));\n+            checkFloat16(b.subtract(EPS), Float16.multiply(Float16.valueOf(n), Float16.MIN_VALUE));\n+            checkFloat16(b.add(EPS), Float16.multiply(Float16.valueOf(n + 1), Float16.MIN_VALUE));\n+        }\n+    }\n+\n@@ -153,0 +189,19 @@\n+    private static void testFloat16ValueNearMinNormal() {\n+        Float16 v = Float16.MIN_NORMAL;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfDown(v);\n+            checkFloat16(bv, isOdd(n) ? Float16.nextDown(v) : v);\n+            checkFloat16(bv.subtract(EPS), Float16.nextDown(v));\n+            checkFloat16(bv.add(EPS), v);\n+            v = Float16.nextDown(v);\n+        }\n+        v = Float16.MIN_NORMAL;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfUp(v);\n+            checkFloat16(bv, isOdd(n) ? Float16.nextUp(v) : v);\n+            checkFloat16(bv.subtract(EPS), v);\n+            checkFloat16(bv.add(EPS), Float16.nextUp(v));\n+            v = Float16.nextUp(v);\n+        }\n+    }\n+\n@@ -183,0 +238,15 @@\n+    private static void testFloat16ValueNearMaxValue() {\n+        Float16 v = Float16.MAX_VALUE;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfDown(v);\n+            checkFloat16(bv, isOdd(n) ? v : Float16.nextDown(v));\n+            checkFloat16(bv.subtract(EPS), Float16.nextDown(v));\n+            checkFloat16(bv.add(EPS), v);\n+            v = Float16.nextDown(v);\n+        }\n+        BigDecimal bv = nextHalfUp(Float16.MAX_VALUE);\n+        checkFloat16(bv, Float16.POSITIVE_INFINITY);\n+        checkFloat16(bv.subtract(EPS), Float16.MAX_VALUE);\n+        checkFloat16(bv.add(EPS), Float16.POSITIVE_INFINITY);\n+    }\n+\n@@ -231,0 +301,24 @@\n+    private static void testFloat16ValueRandom() {\n+        Random r = RandomFactory.getRandom();\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-Float16.MAX_VALUE.floatValue(), Float16.MAX_VALUE.floatValue()));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e4f, 1e4f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e3f, 1e3f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e-3f, 1e-3f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            Float16 v = Float16.valueOf(r.nextFloat(-1e-4f, 1e-4f));\n+            checkFloat16(new BigDecimal(v.floatValue()), v);\n+        }\n+    }\n+\n@@ -235,1 +329,1 @@\n-        checkDouble(BigDecimal.valueOf(-1, -1000), -Double.POSITIVE_INFINITY);\n+        checkDouble(BigDecimal.valueOf(-1, -1000), Double.NEGATIVE_INFINITY);\n@@ -242,1 +336,8 @@\n-        checkFloat(BigDecimal.valueOf(-1, -1000), -Float.POSITIVE_INFINITY);\n+        checkFloat(BigDecimal.valueOf(-1, -1000), Float.NEGATIVE_INFINITY);\n+    }\n+\n+    private static void testFloat16ValueExtremes() {\n+        checkFloat16(BigDecimal.valueOf(1, 1000), Float16.valueOf(0.0f));\n+        checkFloat16(BigDecimal.valueOf(-1, 1000), Float16.valueOf(-0.0f));\n+        checkFloat16(BigDecimal.valueOf(1, -1000), Float16.POSITIVE_INFINITY);\n+        checkFloat16(BigDecimal.valueOf(-1, -1000), Float16.NEGATIVE_INFINITY);\n@@ -257,0 +358,6 @@\n+\n+        testFloat16ValueNearMinValue();\n+        testFloat16ValueNearMinNormal();\n+        testFloat16ValueNearMaxValue();\n+        testFloat16ValueRandom();\n+        testFloat16ValueExtremes();\n","filename":"test\/jdk\/java\/math\/BigDecimal\/DoubleFloatValueTests.java","additions":112,"deletions":5,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -0,0 +1,678 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8329817 8334432 8339076 8341260\n+ * @modules jdk.incubator.vector\n+ * @summary Basic tests of Float16 arithmetic and similar operations\n+ *\/\n+\n+import jdk.incubator.vector.Float16;\n+import static jdk.incubator.vector.Float16.*;\n+\n+public class BasicFloat16ArithTests {\n+    private static float InfinityF = Float.POSITIVE_INFINITY;\n+    private static float NaNf = Float.NaN;\n+\n+    private static final float MAX_VAL_FP16 = 0x1.ffcp15f;\n+\n+    public static void main(String... args) {\n+        checkConstants();\n+        checkNegate();\n+        checkAbs();\n+        checkIsNaN();\n+        checkFiniteness();\n+        checkMinMax();\n+        checkArith();\n+        checkSqrt();\n+        checkGetExponent();\n+        checkUlp();\n+        checkValueOfDouble();\n+        checkValueOfLong();\n+        FusedMultiplyAddTests.main();\n+    }\n+\n+    \/*\n+     * The software implementation of Float16 delegates to float or\n+     * double operations for most of the actual computation. This\n+     * regression test takes that into account as it generally only\n+     * has limited testing to probe whether or not the proper\n+     * functionality is being delegated to.\n+     *\n+     * To make the test easier to read, float literals that are exact\n+     * upon conversion to Float16 are used for the test data.\n+     *\n+     * The float <-> Float16 conversions are well-tested from prior\n+     * work and are assumed to be correct by this regression test.\n+     *\/\n+\n+    private static void checkConstants() {\n+        checkInt(BYTES,          2, \"Float16.BYTES\");\n+        checkInt(MAX_EXPONENT,  15, \"Float16.MAX_EXPONENT\");\n+        checkInt(MIN_EXPONENT, -14, \"Float16.MIN_EXPONENT\");\n+        checkInt(PRECISION,     11, \"Float16.PRECISION\");\n+        checkInt(SIZE,          16, \"Float16.SIZE\");\n+\n+        checkFloat16(MIN_VALUE,  0x1.0p-24f, \"Float16.MIN_VALUE\");\n+        checkFloat16(MIN_NORMAL, 0x1.0p-14f, \"Float16.MIN_NORMAL\");\n+        checkFloat16(MAX_VALUE,  65504.0f,  \"Float16.MAX_VALUE\");\n+\n+        checkFloat16(POSITIVE_INFINITY,   InfinityF,  \"+infinity\");\n+        checkFloat16(NEGATIVE_INFINITY,  -InfinityF,  \"-infinity\");\n+        checkFloat16(NaN,                 NaNf,            \"NaN\");\n+    }\n+\n+    private static void checkInt(int value, int expected, String message) {\n+        if (value != expected) {\n+            throwRE(String.format(\"Didn't get expected value for %s;%nexpected %d, got %d\",\n+                                  message, expected, value));\n+        }\n+    }\n+\n+    private static void checkFloat16(Float16 value16, float expected, String message) {\n+        float value = value16.floatValue();\n+        if (Float.compare(value, expected) != 0) {\n+            throwRE(String.format(\"Didn't get expected value for %s;%nexpected %g (%a), got %g (%a)\",\n+                                  message, expected, expected, value, value));\n+        }\n+    }\n+\n+    private static void checkNegate() {\n+        float[][] testCases = {\n+            {-0.0f,   0.0f},\n+            { 0.0f,  -0.0f},\n+\n+            {-1.0f,   1.0f},\n+            { 1.0f,  -1.0f},\n+\n+            {InfinityF, -InfinityF},\n+            {-InfinityF, InfinityF},\n+\n+            {NaNf,       NaNf},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  negate(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"negate(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkAbs() {\n+        float[][] testCases = {\n+            {-0.0f,   0.0f},\n+            { 0.0f,   0.0f},\n+\n+            {-1.0f,   1.0f},\n+            { 1.0f,   1.0f},\n+\n+            { InfinityF, InfinityF},\n+            {-InfinityF, InfinityF},\n+\n+            {NaNf,       NaNf},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  abs(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"abs(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkIsNaN() {\n+        if (!isNaN(NaN)) {\n+            throwRE(\"Float16.isNaN() returns false for a NaN\");\n+        }\n+\n+        float[] testCases = {\n+            -InfinityF,\n+            InfinityF,\n+            -0.0f,\n+            +0.0f,\n+             1.0f,\n+            -1.0f,\n+        };\n+\n+        for(var testCase : testCases) {\n+            boolean result = isNaN(valueOf(testCase));\n+            if (result) {\n+                throwRE(\"isNaN returned true for \" + testCase);\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkFiniteness() {\n+        float[] infinities = {\n+            -InfinityF,\n+             InfinityF,\n+        };\n+\n+        for(var infinity : infinities) {\n+            boolean result1 = isFinite(valueOf(infinity));\n+            boolean result2 = isInfinite(valueOf(infinity));\n+\n+            if (result1) {\n+                throw new RuntimeException(\"Float16.isFinite returned true for \" + infinity);\n+            }\n+\n+            if (!result2) {\n+                throwRE(\"Float16.isInfinite returned false for \" + infinity);\n+            }\n+        }\n+\n+        if (isFinite(NaN)) {\n+            throwRE(\"Float16.isFinite() returns true for a NaN\");\n+        }\n+\n+        if (isInfinite(NaN)) {\n+            throwRE(\"Float16.isInfinite() returns true for a NaN\");\n+        }\n+\n+        float[] finities = {\n+            -0.0f,\n+            +0.0f,\n+             1.0f,\n+            -1.0f,\n+        };\n+\n+        for(var finity : finities) {\n+            boolean result1 = isFinite(valueOf(finity));\n+            boolean result2 = isInfinite(valueOf(finity));\n+\n+            if (!result1) {\n+                throwRE(\"Float16.isFinite returned true for \" + finity);\n+            }\n+\n+            if (result2) {\n+                throwRE(\"Float16.isInfinite returned true for \" + finity);\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkMinMax() {\n+        float small = 1.0f;\n+        float large = 2.0f;\n+\n+        if (min(valueOf(small), valueOf(large)).floatValue() != small) {\n+            throwRE(String.format(\"min(%g, %g) not equal to %g)\",\n+                                  small, large, small));\n+        }\n+\n+        if (max(valueOf(small), valueOf(large)).floatValue() != large) {\n+            throwRE(String.format(\"max(%g, %g) not equal to %g)\",\n+                                  small, large, large));\n+        }\n+    }\n+\n+    \/*\n+     * Cursory checks to make sure correct operation is being called\n+     * with arguments in proper order.\n+     *\/\n+    private static void checkArith() {\n+        float   a   = 1.0f;\n+        Float16 a16 = valueOf(a);\n+\n+        float   b   = 2.0f;\n+        Float16 b16 = valueOf(b);\n+\n+        if (add(a16, b16).floatValue() != (a + b)) {\n+            throwRE(\"failure with \" + a16 + \" + \" + b16);\n+        }\n+        if (add(b16, a16).floatValue() != (b + a)) {\n+            throwRE(\"failure with \" + b16 + \" + \" + a16);\n+        }\n+\n+        if (subtract(a16, b16).floatValue() != (a - b)) {\n+            throwRE(\"failure with \" + a16 + \" - \" + b16);\n+        }\n+        if (subtract(b16, a16).floatValue() != (b - a)) {\n+            throwRE(\"failure with \" + b16 + \" - \" + a16);\n+        }\n+\n+        if (multiply(a16, b16).floatValue() != (a * b)) {\n+            throwRE(\"failure with \" + a16 + \" * \" + b16);\n+        }\n+        if (multiply(b16, a16).floatValue() != (b * a)) {\n+            throwRE(\"failure with \" + b16 + \" * \" + a16);\n+        }\n+\n+        if (divide(a16, b16).floatValue() != (a \/ b)) {\n+            throwRE(\"failure with \" + a16 + \" \/ \" + b16);\n+        }\n+        if (divide(b16, a16).floatValue() != (b \/ a)) {\n+            throwRE(\"failure with \" + b16 + \" \/ \" + a16);\n+        }\n+        return;\n+    }\n+\n+    private static void checkSqrt() {\n+        float[][] testCases = {\n+            {-0.0f,   -0.0f},\n+            { 0.0f,    0.0f},\n+\n+            {1.0f,   1.0f},\n+            {4.0f,   2.0f},\n+            {9.0f,   3.0f},\n+\n+            { InfinityF, InfinityF},\n+            {-InfinityF, NaNf},\n+\n+            {NaNf,       NaNf},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            Float16 result =  sqrt(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"sqrt(\" + arg + \")\");\n+            }\n+        }\n+\n+        return;\n+    }\n+\n+    private static void checkGetExponent() {\n+        float[][] testCases = {\n+            {InfinityF, MAX_EXPONENT + 1},\n+            {InfinityF, MAX_EXPONENT + 1},\n+            {NaNf,      MAX_EXPONENT + 1},\n+\n+            {-0.0f,      MIN_EXPONENT - 1},\n+            {+0.0f,      MIN_EXPONENT - 1},\n+            {0x1.0p-24f, MIN_EXPONENT - 1}, \/\/ Float16.MIN_VALUE\n+            {0x1.0p-14f, MIN_EXPONENT},     \/\/ Float16.MIN_NORMAL\n+            {1.0f,       0},\n+            {2.0f,       1},\n+            {4.0f,       2},\n+\n+            {MAX_VAL_FP16*0.5f, MAX_EXPONENT - 1},\n+            {MAX_VAL_FP16,      MAX_EXPONENT},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            \/\/ Exponents are in-range for Float16\n+            Float16 result =  valueOf(getExponent(valueOf(arg)));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"getExponent(\" + arg + \")\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    private static void checkUlp() {\n+        float[][] testCases = {\n+            {InfinityF, InfinityF},\n+            {InfinityF, InfinityF},\n+            {NaNf,      NaNf},\n+\n+            \/\/ Zeros, subnormals, and MIN_VALUE all have MIN_VALUE as an ulp.\n+            {-0.0f,      0x1.0p-24f},\n+            {+0.0f,      0x1.0p-24f},\n+            {0x1.0p-24f, 0x1.0p-24f},\n+            {0x1.0p-14f, 0x1.0p-24f},\n+\n+            \/\/ ulp is 10 bits away\n+            {0x1.0p0f,       0x0.004p0f}, \/\/ 1.0f\n+            {0x1.0p1f,       0x0.004p1f}, \/\/ 2.0f\n+            {0x1.0p2f,       0x0.004p2f}, \/\/ 4.0f\n+\n+            {MAX_VAL_FP16*0.5f, 0x0.004p14f},\n+            {MAX_VAL_FP16,      0x0.004p15f},\n+        };\n+\n+        for(var testCase : testCases) {\n+            float arg =      testCase[0];\n+            float expected = testCase[1];\n+            \/\/ Exponents are in-range for Float16\n+            Float16 result =  ulp(valueOf(arg));\n+\n+            if (Float.compare(expected, result.floatValue()) != 0) {\n+                checkFloat16(result, expected, \"ulp(\" + arg + \")\");\n+            }\n+        }\n+        return;\n+    }\n+\n+    private static void throwRE(String message) {\n+        throw new RuntimeException(message);\n+    }\n+\n+    private static void checkValueOfDouble() {\n+        \/*\n+         * Check that double -> Float16 conversion rounds properly\n+         * around the midway point for each finite Float16 value by\n+         * looping over the positive values and checking the negations\n+         * along the way.\n+         *\/\n+\n+        String roundUpMsg   = \"Didn't get half-way case rounding down\";\n+        String roundDownMsg = \"Didn't get half-way case rounding up\";\n+\n+        for(int i = 0; i <= Short.MAX_VALUE; i++ ) {\n+            boolean isEven = ((i & 0x1) == 0);\n+            Float16 f16 = Float16.shortBitsToFloat16((short)i);\n+            Float16 f16Neg = negate(f16);\n+\n+            if (!isFinite(f16))\n+                continue;\n+\n+            \/\/ System.out.println(\"\\t\" + toHexString(f16));\n+\n+            Float16 ulp = ulp(f16);\n+            double halfWay = f16.doubleValue() + ulp.doubleValue() * 0.5;\n+\n+            \/\/ Under the round to nearest even rounding policy, the\n+            \/\/ half-way case should round down to the starting value\n+            \/\/ if the starting value is even; otherwise, it should round up.\n+            float roundedBack = valueOf(halfWay).floatValue();\n+            float roundedBackNeg = valueOf(-halfWay).floatValue();\n+\n+            if (isEven) {\n+                checkFloat16(f16,    roundedBack,    roundDownMsg);\n+                checkFloat16(f16Neg, roundedBackNeg, roundDownMsg);\n+            } else {\n+                checkFloat16(add(f16,         ulp), roundedBack,    roundUpMsg);\n+                checkFloat16(subtract(f16Neg, ulp), roundedBackNeg, roundUpMsg);\n+            }\n+\n+            \/\/ Should always round down\n+            double halfWayNextDown = Math.nextDown(halfWay);\n+            checkFloat16(f16,    valueOf(halfWayNextDown).floatValue(),  roundDownMsg);\n+            checkFloat16(f16Neg, valueOf(-halfWayNextDown).floatValue(), roundDownMsg);\n+\n+            \/\/ Should always round up\n+            double halfWayNextUp =   Math.nextUp(halfWay);\n+            checkFloat16(add(f16, ulp),         valueOf( halfWayNextUp).floatValue(), roundUpMsg);\n+            checkFloat16(subtract(f16Neg, ulp), valueOf(-halfWayNextUp).floatValue(), roundUpMsg);\n+        }\n+    }\n+\n+    private static void checkValueOfLong() {\n+        checkFloat16(valueOf(-65_521), Float.NEGATIVE_INFINITY, \"-infinity\");\n+        checkFloat16(valueOf(-65_520), Float.NEGATIVE_INFINITY, \"-infinity\");\n+        checkFloat16(valueOf(-65_519), -MAX_VALUE.floatValue(), \"-MAX_VALUE\");\n+        checkFloat16(valueOf(65_519), MAX_VALUE.floatValue(), \"MAX_VALUE\");\n+        checkFloat16(valueOf(65_520), Float.POSITIVE_INFINITY, \"+infinity\");\n+        checkFloat16(valueOf(65_521), Float.POSITIVE_INFINITY, \"+infinity\");\n+    }\n+\n+    class FusedMultiplyAddTests {\n+        public static void main(String... args) {\n+            testZeroNanInfCombos();\n+            testNonFinite();\n+            testZeroes();\n+            testSimple();\n+            testRounding();\n+        }\n+\n+        private static void testZeroNanInfCombos() {\n+            float [] testInputs = {\n+                Float.NaN,\n+                -InfinityF,\n+                +InfinityF,\n+                -0.0f,\n+                +0.0f,\n+            };\n+\n+            for (float i : testInputs) {\n+                for (float j : testInputs) {\n+                    for (float k : testInputs) {\n+                        testFusedMacCase(i, j, k, Math.fma(i, j, k));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private static void testNonFinite() {\n+            float [][] testCases = {\n+                {1.0f,       InfinityF,  2.0f,\n+                 InfinityF,\n+                },\n+\n+                {1.0f,       2.0f,       InfinityF,\n+                 InfinityF,\n+                },\n+\n+                {InfinityF,  1.0f,       InfinityF,\n+                 InfinityF,\n+                },\n+\n+                {0x1.ffcp14f, 2.0f,     -InfinityF,\n+                 -InfinityF},\n+\n+                {InfinityF,  1.0f,      -InfinityF,\n+                 NaNf,\n+                },\n+\n+                {-InfinityF, 1.0f,       InfinityF,\n+                 NaNf,\n+                },\n+\n+                {1.0f,       NaNf,       2.0f,\n+                 NaNf,\n+                },\n+\n+                {1.0f,       2.0f,       NaNf,\n+                 NaNf,\n+                },\n+\n+                {InfinityF,  2.0f,       NaNf,\n+                 NaNf,\n+                },\n+\n+                {NaNf,       2.0f,       InfinityF,\n+                 NaNf,\n+                },\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testZeroes() {\n+            float [][] testCases = {\n+                {+0.0f, +0.0f, +0.0f,\n+                 +0.0f,\n+                },\n+\n+                {-0.0f, +0.0f, +0.0f,\n+                 +0.0f,\n+                },\n+\n+                {+0.0f, +0.0f, -0.0f,\n+                 +0.0f,\n+                },\n+\n+                {+0.0f, +0.0f, -0.0f,\n+                 +0.0f,\n+                },\n+\n+                {-0.0f, +0.0f, -0.0f,\n+                 -0.0f,\n+                },\n+\n+                {-0.0f, -0.0f, -0.0f,\n+                 +0.0f,\n+                },\n+\n+                {-1.0f, +0.0f, -0.0f,\n+                 -0.0f,\n+                },\n+\n+                {-1.0f, +0.0f, +0.0f,\n+                 +0.0f,\n+                },\n+\n+                {-2.0f, +0.0f, -0.0f,\n+                 -0.0f,\n+                },\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testSimple() {\n+            final float ulpOneFp16 = ulp(valueOf(1.0f)).floatValue();\n+\n+            float [][] testCases = {\n+                {1.0f, 2.0f, 3.0f,\n+                 5.0f,},\n+\n+                {1.0f, 2.0f, -2.0f,\n+                 0.0f,},\n+\n+                {5.0f, 5.0f, -25.0f,\n+                 0.0f,},\n+\n+                {0.5f*MAX_VAL_FP16, 2.0f, -0.5f*MAX_VAL_FP16,\n+                 0.5f*MAX_VAL_FP16},\n+\n+                {MAX_VAL_FP16, 2.0f, -MAX_VAL_FP16,\n+                 MAX_VAL_FP16},\n+\n+                {MAX_VAL_FP16, 2.0f, 1.0f,\n+                 InfinityF},\n+\n+                {(1.0f + ulpOneFp16),\n+                 (1.0f + ulpOneFp16),\n+                 -1.0f - 2.0f*ulpOneFp16,\n+                 ulpOneFp16 * ulpOneFp16},\n+\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testRounding() {\n+            final float ulpOneFp16 = ulp(valueOf(1.0f)).floatValue();\n+\n+            float [][] testCases = {\n+                \/\/ The product is equal to\n+                \/\/ (MAX_VALUE + 1\/2 * ulp(MAX_VALUE) + MAX_VALUE = (0x1.ffcp15 + 0x0.002p15)+ 0x1.ffcp15\n+                \/\/ so overflows.\n+                {0x1.3p1f, 0x1.afp15f, -MAX_VAL_FP16,\n+                 InfinityF},\n+\n+                \/\/ Product exactly equals 0x1.ffep15, the overflow\n+                \/\/ threshold; subtracting a non-zero finite value will\n+                \/\/ result in MAX_VALUE, adding zero or a positive\n+                \/\/ value will overflow.\n+                {0x1.2p10f, 0x1.c7p5f, -0x1.0p-14f,\n+                 MAX_VAL_FP16},\n+\n+                {0x1.2p10f, 0x1.c7p5f, -0.0f,\n+                 InfinityF},\n+\n+                {0x1.2p10f, 0x1.c7p5f, +0.0f,\n+                 InfinityF},\n+\n+                {0x1.2p10f, 0x1.c7p5f, +0x1.0p-14f,\n+                 InfinityF},\n+\n+                {0x1.2p10f, 0x1.c7p5f, InfinityF,\n+                 InfinityF},\n+\n+                \/\/ PRECISION bits in the subnormal intermediate product\n+                {0x1.ffcp-14f, 0x1.0p-24f, 0x1.0p13f, \/\/ Can be held exactly\n+                 0x1.0p13f},\n+\n+                {0x1.ffcp-14f, 0x1.0p-24f, 0x1.0p14f, \/\/ *Cannot* be held exactly\n+                 0x1.0p14f},\n+\n+                \/\/ Check values where the exact result cannot be\n+                \/\/ exactly stored in a double.\n+                {0x1.0p-24f, 0x1.0p-24f, 0x1.0p10f,\n+                 0x1.0p10f},\n+\n+                {0x1.0p-24f, 0x1.0p-24f, 0x1.0p14f,\n+                 0x1.0p14f},\n+\n+                \/\/ Check subnormal results, underflow to zero\n+                {0x1.0p-24f, -0.5f, 0x1.0p-24f,\n+                 0.0f},\n+\n+                \/\/ Check subnormal results, underflow to zero\n+                {0x1.0p-24f, -0.5f, 0.0f,\n+                 -0.0f},\n+            };\n+\n+            for (float[] testCase: testCases) {\n+                testFusedMacCase(testCase[0], testCase[1], testCase[2], testCase[3]);\n+            }\n+        }\n+\n+        private static void testFusedMacCase(float input1, float input2, float input3, float expected) {\n+            Float16 a = valueOf(input1);\n+            Float16 b = valueOf(input2);\n+            Float16 c = valueOf(input3);\n+            Float16 d = valueOf(expected);\n+\n+            test(\"Float16.fma(float)\", a, b, c, Float16.fma(a, b, c), d);\n+\n+            \/\/ Permute first two inputs\n+            test(\"Float16.fma(float)\", b, a, c, Float16.fma(b, a, c), d);\n+            return;\n+        }\n+    }\n+\n+    private static void test(String testName,\n+                           Float16 input1, Float16 input2, Float16 input3,\n+                           Float16 result, Float16 expected) {\n+        if (Float16.compare(expected, result ) != 0) {\n+            System.err.println(\"Failure for \"  + testName + \":\\n\" +\n+                               \"\\tFor inputs \" + input1   + \"\\t(\" + toHexString(input1) + \") and \"\n+                                               + input2   + \"\\t(\" + toHexString(input2) + \") and\"\n+                                               + input3   + \"\\t(\" + toHexString(input3) + \")\\n\"  +\n+                               \"\\texpected  \"  + expected + \"\\t(\" + toHexString(expected) + \")\\n\" +\n+                               \"\\tgot       \"  + result   + \"\\t(\" + toHexString(result) + \").\");\n+            throw new RuntimeException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/vector\/BasicFloat16ArithTests.java","additions":678,"deletions":0,"binary":false,"changes":678,"status":"added"}]}