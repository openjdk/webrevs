{"files":[{"patch":"@@ -413,6 +413,9 @@\n-     * @implSpec\n-     * The current implementation acts as if the string were\n-     * {@linkplain Double#parseDouble(String) parsed} as a {@code\n-     * double} and then {@linkplain #valueOf(double) converted} to\n-     * {@code Float16}. This behavior is expected to change to\n-     * accommodate the precision of {@code Float16}.\n+     * The grammar of strings accepted by this method is the same as\n+     * that accepted by {@link Double#valueOf(String)}. The rounding\n+     * policy is also analogous to the one used by that method, a\n+     * valid input is regarded as an exact numerical value that is\n+     * rounded once to the nearest representable {@code Float16} value.\n+     *\n+     * @apiNote\n+     * This method corresponds to the convertFromDecimalCharacter and\n+     * convertFromHexCharacter operations defined in IEEE 754.\n@@ -429,2 +432,127 @@\n-        \/\/ TOOD: adjust precision of parsing if needed\n-        return valueOf(Double.parseDouble(s));\n+        s = s.trim(); \/\/ Legacy behavior from analagous methods on\n+                      \/\/ Float and Double.\n+\n+        \/\/ Trial conversion from String -> double. Do quick range\n+        \/\/ check for a pass-through, then check for possibility of\n+        \/\/ double-rounding and another conversion using\n+        \/\/ BigInteger\/BigDecimal, if needed.\n+        double trialResult = Double.parseDouble(s);\n+        \/\/ After this point, the trimmed string is known to be\n+        \/\/ syntactically well-formed; should be able to operate on\n+        \/\/ characters rather than codepoints.\n+\n+        if (trialResult == 0.0 \/\/ handles signed zeros\n+            || Math.abs(trialResult) > (65504.0 + 32.0) || \/\/ Float.MAX_VALUE + ulp(MAX_VALUE)\n+            noDoubleRoundingToFloat16(trialResult)) {\n+            return valueOf(trialResult);\n+        } else {\n+            \/\/ If double rounding is not ruled out, re-parse, create a\n+            \/\/ BigDecimal to hold the exact numerical value, round and\n+            \/\/ return.\n+\n+            \/\/ Remove any trailing FloatTypeSuffix (f|F|d|D), not\n+            \/\/ recognized by BigDecimal (or BigInteger)\n+            int sLength = s.length();\n+            if (Character.isAlphabetic(s.charAt(sLength-1))) {\n+                s = s.substring(0, sLength - 1);\n+            }\n+\n+            char startingChar = s.charAt(0);\n+            boolean isSigned = (startingChar == '-') || (startingChar == '+');\n+            \/\/ Hex literal will start \"-0x...\" or \"+0x...\" or \"0x...\"\"\n+            boolean hexInput = isX(s.charAt(isSigned ? 2 : 1));\n+\n+            if (!hexInput) { \/\/ Decimal input\n+                \/\/ Grammar of BigDecimal string input is compatible\n+                \/\/ with the decimal grammar for this method after\n+                \/\/ trimming and removal of any FloatTypeSuffix.\n+                return valueOf(new BigDecimal(s));\n+            } else {\n+                \/\/ For hex inputs, convert the significand and\n+                \/\/ exponent portions separately.\n+                \/\/\n+                \/\/ Rough form of the hex input:\n+                \/\/ Sign_opt 0x IntHexDigits_opt . FracHexDigits_opt [p|P] SignedInteger\n+                \/\/\n+                \/\/ Partition input into between \"0x\" and \"p\" and from\n+                \/\/ \"p\" to end of string.\n+                \/\/\n+                \/\/ For the region between x and p, see if there is a\n+                \/\/ period present. If so, the net exponent will need\n+                \/\/ to be adjusted by the number of digits to the right\n+                \/\/ of the (hexa)decimal point.\n+                \/\/\n+                \/\/ Use BigInteger(String, 16) to construct the\n+                \/\/ significand -- accepts leading sign.\n+                StringBuilder hexSignificand = new StringBuilder();\n+                if (isSigned) {\n+                    hexSignificand.append(startingChar);\n+                }\n+\n+                int fractionDigits = 0;\n+                int digitStart = isSigned ? 3 : 2 ;\n+\n+                int periodIndex = s.indexOf((int)'.');\n+\n+                int pIndex = findPIndex(s);\n+\n+                \/\/ Gather the significand digits\n+                if (periodIndex != -1) {\n+                    \/\/ Reconstruct integer and fraction digit sequence\n+                    \/\/ without the period.\n+                    hexSignificand.append(s.substring(digitStart,      periodIndex));\n+                    hexSignificand.append(s.substring(periodIndex + 1, pIndex));\n+                    fractionDigits = pIndex - periodIndex -1;\n+                } else {\n+                    \/\/ All integer digits, no fraction digits\n+                    hexSignificand.append(s.substring(digitStart, pIndex));\n+                }\n+\n+                \/\/ The exponent of a hexadecimal floating-point\n+                \/\/ literal is written in _decimal_.\n+                int rawExponent = Integer.parseInt(s.substring(pIndex+1));\n+\n+                \/\/ The exact numerical value of the string is:\n+                \/\/\n+                \/\/ normalizedSignificand * 2^(adjustedExponent)\n+                \/\/\n+                \/\/ Given the set of methods on BigDecimal, in\n+                \/\/ particular pow being limited to non-negative\n+                \/\/ exponents, this is computed either by multiplying\n+                \/\/ by BigDecimal.TWO raised to the adjustedExponent or\n+                \/\/ dividing by BigDecimal.TWO raised to the negated\n+                \/\/ adjustedExponent.\n+\n+                BigDecimal normalizedSignficand =\n+                    new BigDecimal(new BigInteger(hexSignificand.toString(), 16));\n+\n+                \/\/ Each hex fraction digit is four bits\n+                int adjustedExponent = rawExponent - 4*fractionDigits;\n+\n+                BigDecimal convertedStringValue = (adjustedExponent >= 0) ?\n+                    normalizedSignficand.multiply(BigDecimal.TWO.pow( adjustedExponent)) :\n+                    normalizedSignficand.divide(  BigDecimal.TWO.pow(-adjustedExponent));\n+                return valueOf(convertedStringValue);\n+            }\n+        }\n+    }\n+\n+    private static boolean noDoubleRoundingToFloat16(double d) {\n+        \/\/ Note that if the String -> double conversion returned\n+        \/\/ whether or not the conversion was exact, many cases could\n+        \/\/ be skipped since the double-rounding would be known not to\n+        \/\/ have occurred.\n+        long dAsLong = Double.doubleToRawLongBits(d);\n+        long mask = 0x01FF_FFFF_FFFFL; \/\/ 41 low-order bits\n+        long maskedValue = dAsLong & mask;\n+        \/\/ Can't have all-zeros or all-ones in low-order bits\n+        return maskedValue != 0L && maskedValue != mask;\n+    }\n+\n+    private static boolean isX(int character) {\n+        return character == (int)'x' || character == (int)'X';\n+    }\n+\n+    private static int findPIndex(String s) {\n+        int pIndex = s.indexOf((int)'p');\n+        return (pIndex != -1) ?  pIndex : s.indexOf((int)'P');\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":136,"deletions":8,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+        checkValueOfString();\n@@ -512,0 +513,74 @@\n+    private static void checkValueOfString() {\n+        String2Float16Case[] testCases = {\n+            new String2Float16Case( \"+0.0\", 0.0f),\n+            new String2Float16Case(\"-0.0\", -0.0f),\n+\n+            new String2Float16Case( \"1.0\",  1.0f),\n+            new String2Float16Case(\"-1.0\", -1.0f),\n+\n+            \/\/ Check for FloatTypeSuffix handling\n+            new String2Float16Case( \"1.5f\", 1.5f),\n+            new String2Float16Case( \"1.5F\", 1.5f),\n+            new String2Float16Case( \"1.5D\", 1.5f),\n+            new String2Float16Case( \"1.5d\", 1.5f),\n+\n+            new String2Float16Case(\"65504.0\", 65504.0f),  \/\/ Float16.MAX_VALUE\n+\n+\n+            new String2Float16Case(\"65520.0\", InfinityF), \/\/ Float16.MAX_VALUE + 0.5*ulp\n+\n+            new String2Float16Case(\"65520.01\", InfinityF), \/\/ Float16.MAX_VALUE + > 0.5*ulp\n+            new String2Float16Case(\"65520.001\", InfinityF), \/\/ Float16.MAX_VALUE + > 0.5*ulp\n+            new String2Float16Case(\"65520.0001\", InfinityF), \/\/ Float16.MAX_VALUE + > 0.5*ulp\n+            new String2Float16Case(\"65520.00000000001\", InfinityF), \/\/ Float16.MAX_VALUE + > 0.5*ulp\n+\n+            new String2Float16Case(\"65519.99999999999\", 65504.0f), \/\/ Float16.MAX_VALUE +  < 0.5*ulp\n+            new String2Float16Case(\"0x1.ffdffffffffffp15\", 65504.0f),\n+            new String2Float16Case(\"0x1.ffdfffffffffp15\", 65504.0f),\n+\n+\n+            new String2Float16Case(\"65519.999999999999\", 65504.0f),\n+            new String2Float16Case(\"65519.9999999999999\", 65504.0f),\n+            new String2Float16Case(\"65519.99999999999999\", 65504.0f),\n+            new String2Float16Case(\"65519.999999999999999\", 65504.0f),\n+\n+            \/\/ Float16.MAX_VALUE +  < 0.5*ulp\n+            new String2Float16Case(\"65519.9999999999999999999999999999999999999\", 65504.0f),\n+\n+            \/\/ Near MAX_VALUE - 0.5 ulp\n+            new String2Float16Case(\"65488.0\", 65472.0f),\n+            new String2Float16Case(\"65487.9999\", 65472.0f),\n+            new String2Float16Case(\"65487.99999999\", 65472.0f),\n+            new String2Float16Case(\"65487.9999999999999999\", 65472.0f),\n+\n+            new String2Float16Case(\"65488.000001\", MAX_VAL_FP16),\n+\n+            new String2Float16Case(\"65536.0\", InfinityF), \/\/ Float16.MAX_VALUE + ulp\n+\n+            \/\/ Hex values\n+            new String2Float16Case(\"0x1p2\",   0x1.0p2f),\n+            new String2Float16Case(\"0x1.0p1\", 0x1.0p1f),\n+\n+            new String2Float16Case(\"-0x1p2\",  -0x1.0p2f),\n+            new String2Float16Case(\"0x3.45p12\", 0x3.45p12f),\n+\n+            new String2Float16Case(\"0x3.4500000001p12\", 0x3.45p12f),\n+\n+            \/\/ Near half-way double + float cases in hex\n+            new String2Float16Case(\"0x1.ffdfffffffffffffffffffffffffffffffffffp15\", 65504.0f),\n+\n+        };\n+\n+        for(String2Float16Case testCase : testCases) {\n+            String input = testCase.input();\n+            float expected = testCase.expected();\n+            Float16 result = Float16.valueOf(input);\n+            checkFloat16(result, expected, \"Float16.valueOf(String) \" + input);\n+        }\n+\n+        return;\n+    }\n+\n+    private static record String2Float16Case(String input, float expected) {\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/BasicFloat16ArithTests.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"}]}