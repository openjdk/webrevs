{"files":[{"patch":"@@ -70,1 +70,1 @@\n-\/\/ expected to be aligned with Value Classes and Object as describedin\n+\/\/ expected to be aligned with Value Classes and Object as described in\n@@ -450,23 +450,23 @@\n-             int scale = bd.scale();\n-             BigInteger unscaledValue = bd.unscaledValue();\n-\n-              if (unscaledValue.abs().compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0) {\n-                 long intCompact = unscaledValue.longValue();\n-                 Float16 v = Float16.valueOf(intCompact);\n-                 if (scale == 0) {\n-                     return v;\n-                 }\n-                 \/*\n-                  * The discussion for the double case also applies here. That is,\n-                  * the following test is precise for all long values, but here\n-                  * Long.MAX_VALUE is not an issue.\n-                  *\/\n-                 if (v.longValue() == intCompact) {\n-                     if (0 < scale && scale < FLOAT16_10_POW.length) {\n-                         return Float16.divide(v, FLOAT16_10_POW[scale]);\n-                     }\n-                     if (0 > scale && scale > -FLOAT16_10_POW.length) {\n-                         return Float16.multiply(v, FLOAT16_10_POW[-scale]);\n-                     }\n-                 }\n-             }\n+            int scale = bd.scale();\n+            BigInteger unscaledValue = bd.unscaledValue();\n+\n+            if (unscaledValue.abs().compareTo(BigInteger.valueOf(Long.MAX_VALUE)) <= 0) {\n+                long intCompact = unscaledValue.longValue();\n+                Float16 v = Float16.valueOf(intCompact);\n+                if (scale == 0) {\n+                    return v;\n+                }\n+                \/*\n+                 * The discussion for the double case also applies here. That is,\n+                 * the following test is precise for all long values, but here\n+                 * Long.MAX_VALUE is not an issue.\n+                 *\/\n+                if (v.longValue() == intCompact) {\n+                    if (0 < scale && scale < FLOAT16_10_POW.length) {\n+                        return Float16.divide(v, FLOAT16_10_POW[scale]);\n+                    }\n+                    if (0 > scale && scale > -FLOAT16_10_POW.length) {\n+                        return Float16.multiply(v, FLOAT16_10_POW[-scale]);\n+                    }\n+                }\n+            }\n@@ -691,2 +691,5 @@\n-     * The general contract of {@code Object#hashCode()}is satisfied;\n-     * all NaN values have the same hash value.\n+     * The general contract of {@code Object#hashCode()} is satisfied.\n+     * All NaN values have the same hash code. Additionally, all\n+     * distinct numerical values have unique hash codes; in\n+     * particular, negative zero and positive zero have different hash\n+     * codes from each other.\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":29,"deletions":26,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.HashSet;\n@@ -41,0 +42,2 @@\n+        checkBitWise();\n+        checkHash();\n@@ -70,0 +73,68 @@\n+    \/**\n+     * Verify handling of NaN representations\n+     *\/\n+    private static void checkBitWise() {\n+        short nanImage = float16ToRawShortBits(Float16.NaN);\n+\n+        int exponent = 0x7c00;\n+        int sign =     0x8000;\n+\n+        \/\/ All-zeros significand with a max exponent are infinite\n+        \/\/ values, not NaN values.\n+        for(int i = 0x1; i <= 0x03ff; i++) {\n+            short  posNaNasShort = (short)(       exponent | i);\n+            short  negNaNasShort = (short)(sign | exponent | i);\n+\n+            Float16 posf16 = shortBitsToFloat16(posNaNasShort);\n+            Float16 negf16 = shortBitsToFloat16(negNaNasShort);\n+\n+            \/\/ Mask-off high-order 16 bits to avoid sign extension woes\n+            checkInt(nanImage & 0xffff, float16ToShortBits(posf16) & 0xffff, \"positive NaN\");\n+            checkInt(nanImage & 0xffff, float16ToShortBits(negf16) & 0xffff, \"negative NaN\");\n+\n+            checkInt(posNaNasShort & 0xffff, float16ToRawShortBits(posf16) & 0xffff , \"positive NaN\");\n+            checkInt(negNaNasShort & 0xffff, float16ToRawShortBits(negf16) & 0xffff, \"negative NaN\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify correct number of hashValue's from Float16's.\n+     *\/\n+    private static void checkHash() {\n+        \/\/ Slightly over-allocate the HashSet.\n+        HashSet<Integer> set = HashSet.newHashSet(Short.MAX_VALUE - Short.MIN_VALUE + 1);\n+\n+        \/\/ Each non-NaN value should have a distinct hashCode. All NaN\n+        \/\/ values should share a single hashCode. Check the latter\n+        \/\/ property by verifying the overall count of entries in the\n+        \/\/ set.\n+        for(int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; i++) {\n+            Float16 f16 = Float16.shortBitsToFloat16((short)i);\n+            boolean addedToSet = set.add(f16.hashCode());\n+\n+            if (!Float16.isNaN(f16)) {\n+                if (!addedToSet) {\n+                    throwRE(\"Existing hash value for \" + f16);\n+                }\n+            }\n+        }\n+\n+        \/\/ There are 2^16 = 65,536 total short values. Each of these\n+        \/\/ bit patterns is a valid representation of a Float16\n+        \/\/ value. However, NaNs have multiple possible encodings.\n+        \/\/ With an exponent = 0x7c00, each nonzero significand 0x1 to\n+        \/\/ 0x3ff is a NaN, for both positive and negative sign bits.\n+        \/\/\n+        \/\/ Therefore, the total number of distinct hash codes for\n+        \/\/ Float16 values should be:\n+        \/\/ 65_536 - 2*(1_023) + 1 = 63_491\n+\n+        int setSize = set.size();\n+        if (setSize != 63_491) {\n+            throwRE(\"Unexpected number of distinct hash values \" + setSize);\n+        }\n+\n+\n+        System.out.println();\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/BasicFloat16ArithTests.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"}]}