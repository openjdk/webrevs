{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import sun.nio.cs.UTF_8;\n+\n@@ -101,3 +103,1 @@\n-        \/\/ NOTE: can not use str.getBytes(\"UTF-8\") here because of\n-        \/\/ bootstrapping issues with the character set converters.\n-        byte[] bytes = UTF8.encode(str);\n+        byte[] bytes = str.getBytes(UTF_8.INSTANCE);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassFileAssembler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/** It is necessary to use a \"bootstrap\" UTF-8 encoder for encoding\n-    constant pool entries because the character set converters rely on\n-    Class.newInstance(). *\/\n-\n-class UTF8 {\n-    \/\/ This encoder is not quite correct.  It does not handle surrogate pairs.\n-    static byte[] encode(String str) {\n-        int len = str.length();\n-        byte[] res = new byte[utf8Length(str)];\n-        int utf8Idx = 0;\n-        try {\n-            for (int i = 0; i < len; i++) {\n-                int c = str.charAt(i) & 0xFFFF;\n-                if (c >= 0x0001 && c <= 0x007F) {\n-                    res[utf8Idx++] = (byte) c;\n-                } else if (c == 0x0000 ||\n-                           (c >= 0x0080 && c <= 0x07FF)) {\n-                    res[utf8Idx++] = (byte) (0xC0 + (c >> 6));\n-                    res[utf8Idx++] = (byte) (0x80 + (c & 0x3F));\n-                } else {\n-                    res[utf8Idx++] = (byte) (0xE0 + (c >> 12));\n-                    res[utf8Idx++] = (byte) (0x80 + ((c >> 6) & 0x3F));\n-                    res[utf8Idx++] = (byte) (0x80 + (c & 0x3F));\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new InternalError\n-                (\"Bug in sun.reflect bootstrap UTF-8 encoder\", e);\n-        }\n-        return res;\n-    }\n-\n-    private static int utf8Length(String str) {\n-        int len = str.length();\n-        int utf8Len = 0;\n-        for (int i = 0; i < len; i++) {\n-            int c = str.charAt(i) & 0xFFFF;\n-            if (c >= 0x0001 && c <= 0x007F) {\n-                utf8Len += 1;\n-            } else if (c == 0x0000 ||\n-                       (c >= 0x0080 && c <= 0x07FF)) {\n-                utf8Len += 2;\n-            } else {\n-                utf8Len += 3;\n-            }\n-        }\n-        return utf8Len;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UTF8.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -226,0 +226,62 @@\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeUTF8InternalAllMixed(Blackhole bh) {\n+        bh.consume(encode(utf16String));\n+        bh.consume(encode(longUtf16StartString));\n+        bh.consume(encode(asciiString7));\n+        bh.consume(encode(longUtf16EndString));\n+        bh.consume(encode(latin1String3));\n+        bh.consume(encode(longUtf16OnlyString));\n+        bh.consume(encode(longLatin1EndString));\n+        bh.consume(encode(longLatin1StartString));\n+        bh.consume(encode(utf16String15));\n+        bh.consume(encode(longLatin1OnlyString));\n+        bh.consume(encode(latin1String));\n+        bh.consume(encode(asciiString));\n+        bh.consume(encode(longAsciiString));\n+    }\n+\n+    \/\/ Code from jdk.internal.reflect.UTF8\n+    static byte[] encode(String str) {\n+        int len = str.length();\n+        byte[] res = new byte[utf8Length(str)];\n+        int utf8Idx = 0;\n+        try {\n+            for (int i = 0; i < len; i++) {\n+                int c = str.charAt(i) & 0xFFFF;\n+                if (c >= 0x0001 && c <= 0x007F) {\n+                    res[utf8Idx++] = (byte) c;\n+                } else if (c == 0x0000 ||\n+                        (c >= 0x0080 && c <= 0x07FF)) {\n+                    res[utf8Idx++] = (byte) (0xC0 + (c >> 6));\n+                    res[utf8Idx++] = (byte) (0x80 + (c & 0x3F));\n+                } else {\n+                    res[utf8Idx++] = (byte) (0xE0 + (c >> 12));\n+                    res[utf8Idx++] = (byte) (0x80 + ((c >> 6) & 0x3F));\n+                    res[utf8Idx++] = (byte) (0x80 + (c & 0x3F));\n+                }\n+            }\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new InternalError\n+                    (\"Bug in sun.reflect bootstrap UTF-8 encoder\", e);\n+        }\n+        return res;\n+    }\n+\n+    private static int utf8Length(String str) {\n+        int len = str.length();\n+        int utf8Len = 0;\n+        for (int i = 0; i < len; i++) {\n+            int c = str.charAt(i) & 0xFFFF;\n+            if (c >= 0x0001 && c <= 0x007F) {\n+                utf8Len += 1;\n+            } else if (c == 0x0000 ||\n+                    (c >= 0x0080 && c <= 0x07FF)) {\n+                utf8Len += 2;\n+            } else {\n+                utf8Len += 3;\n+            }\n+        }\n+        return utf8Len;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringEncode.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"}]}