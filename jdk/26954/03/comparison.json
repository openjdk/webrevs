{"files":[{"patch":"@@ -1095,1 +1095,2 @@\n-  assert(allocation->harvested() + allocation->committed_capacity() == freed, \"must have freed all\");\n+  assert(allocation->harvested() + allocation->committed_capacity() == freed, \"must have freed all\"\n+         \" %zu + %zu == %zu\", allocation->harvested(), allocation->committed_capacity(), freed);\n@@ -1912,5 +1913,9 @@\n-\n-  const size_t committed = allocation->committed_capacity();\n-  const ZVirtualMemory non_harvested_vmem = vmem.last_part(allocation->harvested());\n-  const ZVirtualMemory committed_vmem = non_harvested_vmem.first_part(committed);\n-  const ZVirtualMemory non_committed_vmem = non_harvested_vmem.last_part(committed);\n+  assert(allocation->partial_vmems()->is_empty(), \"Invariant for single partition commit failure\");\n+\n+  \/\/ For a single partition we have unmapped the harvested memory before we\n+  \/\/ started committing, and moved its physical memory association to the start\n+  \/\/ of the vmem. As such the partial_vmems is empty. All the harvested and\n+  \/\/ partially successfully committed memory is mapped in the first part of vmem.\n+  const size_t harvested_and_committed = allocation->harvested() + allocation->committed_capacity();\n+  const ZVirtualMemory committed_vmem = vmem.first_part(harvested_and_committed);\n+  const ZVirtualMemory non_committed_vmem = vmem.last_part(harvested_and_committed);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,8 @@\n+\/*\n+ * @test id=Normal\n+ * @requires vm.gc.Z & vm.debug\n+ * @summary Test ZGC graceful failure when a commit fails\n+ * @library \/ \/test\/lib\n+ * @run driver gc.z.TestCommitFailure\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestCommitFailure.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}