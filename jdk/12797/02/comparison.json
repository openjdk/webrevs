{"files":[{"patch":"@@ -636,4 +636,4 @@\n-     * position is greater than or equal to the file's current size then no bytes are\n-     * transferred.  If the target channel has a position then bytes are\n-     * written starting at that position and then the position is incremented\n-     * by the number of bytes written.\n+     * position is greater than or equal to the file's current size then no\n+     * bytes are transferred.  If the target channel has a position then bytes\n+     * are written starting at that position and then the position\n+     * is incremented by the number of bytes written.\n@@ -704,2 +704,4 @@\n-     * position is greater than the file's current size then no bytes are\n-     * transferred.  If the source channel has a position then bytes are read\n+     * position is greater than or equal to the file's current size then the\n+     * file will be grown to accommodate the new bytes; the values of any bytes\n+     * between the previous end-of-file and the newly-written bytes are\n+     * unspecified.  If the source channel has a position then bytes are read\n@@ -764,1 +766,2 @@\n-     * is greater than or equal to the file's current size then no bytes are read.  <\/p>\n+     * is greater than or equal to the file's current size then no bytes are\n+     * read.  <\/p>\n@@ -809,3 +812,4 @@\n-     * position is greater than or equal to the file's current size then the file will be\n-     * grown to accommodate the new bytes; the values of any bytes between the\n-     * previous end-of-file and the newly-written bytes are unspecified.  <\/p>\n+     * position is greater than or equal to the file's current size then the\n+     * file will be grown to accommodate the new bytes; the values of any bytes\n+     * between the previous end-of-file and the newly-written bytes are\n+     * unspecified.  <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -938,2 +938,0 @@\n-        if (position > size())\n-            return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8303260\n+ * @summary Test transferFrom to a position greater than size\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run junit TransferFromExtend\n+ * @key randomness\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.stream.Stream;\n+\n+import static java.nio.file.StandardOpenOption.*;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class TransferFromExtend {\n+    private static final Random RND = RandomFactory.getRandom();\n+\n+    private static final Path DIR = Path.of(System.getProperty(\"test.dir\", \".\"));\n+\n+    private static Stream<Arguments> paramProvider(int transferSizeMin,\n+                                                   int transferSizeMax) {\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        int sizeDelta = transferSizeMax - transferSizeMin;\n+        for (int i = 0; i < 10; i++) {\n+            Arguments args =\n+                Arguments.of(RND.nextInt(1024),\n+                             transferSizeMin + RND.nextInt(sizeDelta),\n+                             1 + RND.nextInt(2047));\n+            list.add(args);\n+        }\n+        return list.stream();\n+    }\n+\n+    \/\/\n+    \/\/ transfer size must be greater than the threshold\n+    \/\/ sun.nio.ch.FileChannelImpl::MAPPED_TRANSFER_THRESHOLD (16K)\n+    \/\/ for a mapped transfer to be used when direct is unavailable\n+    \/\/\n+    private static Stream<Arguments> fastParamProvider() {\n+        return paramProvider(16*1024 + 1, 500*1024);\n+    }\n+\n+    private static Stream<Arguments> readingByteChannelParamProvider() {\n+        return paramProvider(1, 64*1024);\n+    }\n+\n+    \/\/\n+    \/\/ Test the direct and memory-mapped paths. At present the direct path\n+    \/\/ is implemented only on Linux. The mapped path will be taken only if\n+    \/\/ there is no direct path and the size of the transfer is more than\n+    \/\/ sun.nio.ch.FileChannelImpl::MAPPED_TRANSFER_THRESHOLD (16K).\n+    \/\/ This method therefore tests the direct path on Linux and the mapped\n+    \/\/ path on other platforms.\n+    \/\/\n+    @ParameterizedTest\n+    @MethodSource(\"fastParamProvider\")\n+    void fromFast(long initialPosition, int bufSize, long offset) throws IOException {\n+        Path file = Files.createTempFile(DIR, \"foo\", \"bar\");\n+        try (FileChannel src = FileChannel.open(file, DELETE_ON_CLOSE,\n+                                                READ, WRITE)) {\n+            byte[] bytes = new byte[bufSize];\n+            RND.nextBytes(bytes);\n+            ByteBuffer buf = ByteBuffer.wrap(bytes);\n+            int total = 0;\n+            while (total < bufSize) {\n+                int n = src.write(ByteBuffer.wrap(bytes), 0);\n+                assertTrue(n >= 0, n + \" < \" + 0);\n+                total += n;\n+            }\n+            transferFrom(src, src.size(), initialPosition, offset, bytes);\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Test the arbitrary source path. This method tests the\n+    \/\/ generic path on all platforms.\n+    \/\/\n+    @ParameterizedTest\n+    @MethodSource(\"readingByteChannelParamProvider\")\n+    void fromReadingByteChannel(long initialPosition, int bufSize, long offset)\n+        throws IOException {\n+        byte[] bytes = new byte[bufSize];\n+        RND.nextBytes(bytes);\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        try (ReadableByteChannel src = Channels.newChannel(bais)) {\n+            transferFrom(src, bufSize, initialPosition, offset, bytes);\n+        }\n+    }\n+\n+    \/**\n+     * Tests transferring bytes to a FileChannel from a ReadableByteChannel.\n+     *\n+     * @param src        the source of the bytes to transfer\n+     * @param count the  number of bytes to transfer\n+     * @param initialPos the position of the target channel before the transfer\n+     * @param offset     the offset beyong the end of the target channel\n+     * @param bytes      the bytes expected to be transferred\n+     *\/\n+    private static void transferFrom(ReadableByteChannel src, long count,\n+                                     long initialPos, long offset, byte[] bytes)\n+        throws IOException {\n+        Path file = Files.createTempFile(DIR, \"foo\", \"bar\");\n+        try (FileChannel target = FileChannel.open(file, DELETE_ON_CLOSE,\n+                                                   READ, WRITE)) {\n+            target.position(initialPos);\n+            assertEquals(1, target.write(ByteBuffer.wrap(new byte[] {(byte)42})));\n+\n+            long position = target.size() + offset;\n+            long transferred = target.transferFrom(src, position, count);\n+            assertTrue(transferred >= 0, \"transferFrom returned negative\");\n+            assertFalse(transferred > count, transferred + \" > \" + count);\n+            ByteBuffer buf = ByteBuffer.allocate((int)transferred);\n+            target.read(buf, position);\n+            assertArrayEquals(Arrays.copyOf(bytes, (int)transferred),\n+                              buf.array(), \"arrays unequal\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/TransferFromExtend.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"}]}