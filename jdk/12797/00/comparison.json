{"files":[{"patch":"@@ -636,4 +636,4 @@\n-     * position is greater than or equal to the file's current size then no bytes are\n-     * transferred.  If the target channel has a position then bytes are\n-     * written starting at that position and then the position is incremented\n-     * by the number of bytes written.\n+     * position is greater than or equal to the file's current size then no\n+     * bytes are transferred.  If the target channel has a position then bytes\n+     * are written starting at that position and then the position\n+     * is incremented by the number of bytes written.\n@@ -704,2 +704,4 @@\n-     * position is greater than the file's current size then no bytes are\n-     * transferred.  If the source channel has a position then bytes are read\n+     * position is greater than or equal to the file's current size then the\n+     * file will be grown to accommodate the new bytes; the values of any bytes\n+     * between the previous end-of-file and the newly-written bytes are\n+     * unspecified.  If the source channel has a position then bytes are read\n@@ -764,1 +766,2 @@\n-     * is greater than or equal to the file's current size then no bytes are read.  <\/p>\n+     * is greater than or equal to the file's current size then no bytes are\n+     * read.  <\/p>\n@@ -809,3 +812,4 @@\n-     * position is greater than or equal to the file's current size then the file will be\n-     * grown to accommodate the new bytes; the values of any bytes between the\n-     * previous end-of-file and the newly-written bytes are unspecified.  <\/p>\n+     * position is greater than or equal to the file's current size then the\n+     * file will be grown to accommodate the new bytes; the values of any bytes\n+     * between the previous end-of-file and the newly-written bytes are\n+     * unspecified.  <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -938,2 +938,0 @@\n-        if (position > size())\n-            return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8303260\n+ * @summary Test transferFrom to a position greater than size\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main TransferFromExtend\n+ * @key randomness\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.RandomFactory;\n+\n+import static java.nio.file.StandardOpenOption.*;\n+\n+public class TransferFromExtend {\n+    private static final Random RND = RandomFactory.getRandom();\n+\n+    private static final int ITERATIONS = 10;\n+\n+    private static final int TARGET_INITIAL_POS_MAX    = 1024;\n+    private static final int FAST_TRANSFER_SIZE_MIN    = 16*1024 + 1;\n+    private static final int FAST_TRANSFER_SIZE_MAX    = 500*1024;\n+    private static final int TARGET_OFFSET_POS_MIN     = 1;\n+    private static final int TARGET_OFFSET_POS_MAX     = 2048;\n+    private static final int GENERIC_TRANSFER_SIZE_MAX = 64*1024;\n+\n+    public static void main(String[] args) throws IOException {\n+        for (int i = 1; i <= ITERATIONS; i++) {\n+            System.out.printf(\"Iteration %d of %d%n\", i, ITERATIONS);\n+            test();\n+        }\n+    }\n+\n+    private static final void test() throws IOException {\n+        Path dir = Path.of(System.getProperty(\"test.dir\", \".\"));\n+        Path file = Files.createTempFile(dir, \"foo\", \"bar\");\n+        try (FileChannel fc = FileChannel.open(file, DELETE_ON_CLOSE,\n+                                               READ, WRITE)) {\n+            fc.position(RND.nextInt(TARGET_INITIAL_POS_MAX));\n+            fc.write(ByteBuffer.wrap(new byte[] {(byte)42}));\n+            fromDirectlyOrMapped(dir, fc);\n+            fromArbitrary(fc);\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Test the direct and memory-mapped paths. At present the direct path\n+    \/\/ is implemented only on Linux. The mapped path will be taken only if\n+    \/\/ there is no direct path and the size of the transfer is more than 16K.\n+    \/\/ This method therefore tests the direct path on Linux and the mapped\n+    \/\/ path on other platforms.\n+    \/\/\n+    private static void fromDirectlyOrMapped(Path dir, FileChannel target)\n+        throws IOException {\n+        Path file = Files.createTempFile(dir, \"foo\", \"bar\");\n+        try (FileChannel src = FileChannel.open(file, DELETE_ON_CLOSE,\n+                                                READ, WRITE)) {\n+            int bufSize = FAST_TRANSFER_SIZE_MIN +\n+                RND.nextInt(FAST_TRANSFER_SIZE_MAX - FAST_TRANSFER_SIZE_MIN);\n+            byte[] bytes = new byte[bufSize];\n+            RND.nextBytes(bytes);\n+            src.write(ByteBuffer.wrap(bytes), 0);\n+\n+            final long size = target.size();\n+            final long position = size + TARGET_OFFSET_POS_MIN +\n+                RND.nextInt(TARGET_OFFSET_POS_MAX - TARGET_OFFSET_POS_MIN);\n+            final long count = src.size();\n+            final long transferred = target.transferFrom(src, position, count);\n+            if (transferred != count)\n+                throw new RuntimeException(transferred + \" != \" + count);\n+            ByteBuffer buf = ByteBuffer.allocate((int)count);\n+            target.read(buf, position);\n+            if (!Arrays.equals(buf.array(), bytes))\n+                throw new RuntimeException(\"arrays unequal\");\n+        }\n+    }\n+\n+    \/\/\n+    \/\/ Test the arbitrary source path. This method tests the\n+    \/\/ generic path on all platforms.\n+    \/\/\n+    private static void fromArbitrary(FileChannel target)\n+        throws IOException {\n+        int bufSize = 1 + RND.nextInt(GENERIC_TRANSFER_SIZE_MAX - 1);\n+        byte[] bytes = new byte[bufSize];\n+        RND.nextBytes(bytes);\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        try (ReadableByteChannel src = Channels.newChannel(bais)) {\n+            final long size = target.size();\n+            final long position = size + TARGET_OFFSET_POS_MIN +\n+                RND.nextInt(TARGET_OFFSET_POS_MAX - TARGET_OFFSET_POS_MIN);\n+            final long count = bytes.length;\n+            final long transferred = target.transferFrom(src, position, count);\n+            if (transferred != count)\n+                throw new RuntimeException(transferred + \" != \" + count);\n+            ByteBuffer buf = ByteBuffer.allocate((int)count);\n+            target.read(buf, position);\n+            if (!Arrays.equals(buf.array(), bytes))\n+                throw new RuntimeException(\"arrays unequal\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/TransferFromExtend.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"}]}