{"files":[{"patch":"@@ -29,1 +29,1 @@\n- * @run main TransferFromExtend\n+ * @run junit TransferFromExtend\n@@ -41,0 +41,1 @@\n+import java.util.ArrayList;\n@@ -42,0 +43,1 @@\n+import java.util.List;\n@@ -43,1 +45,1 @@\n-import jdk.test.lib.RandomFactory;\n+import java.util.stream.Stream;\n@@ -47,0 +49,6 @@\n+import jdk.test.lib.RandomFactory;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -50,8 +58,1 @@\n-    private static final int ITERATIONS = 10;\n-\n-    private static final int TARGET_INITIAL_POS_MAX    = 1024;\n-    private static final int FAST_TRANSFER_SIZE_MIN    = 16*1024 + 1;\n-    private static final int FAST_TRANSFER_SIZE_MAX    = 500*1024;\n-    private static final int TARGET_OFFSET_POS_MIN     = 1;\n-    private static final int TARGET_OFFSET_POS_MAX     = 2048;\n-    private static final int GENERIC_TRANSFER_SIZE_MAX = 64*1024;\n+    private static final Path DIR = Path.of(System.getProperty(\"test.dir\", \".\"));\n@@ -59,4 +60,10 @@\n-    public static void main(String[] args) throws IOException {\n-        for (int i = 1; i <= ITERATIONS; i++) {\n-            System.out.printf(\"Iteration %d of %d%n\", i, ITERATIONS);\n-            test();\n+    private static Stream<Arguments> paramProvider(int transferSizeMin,\n+                                                   int transferSizeMax) {\n+        List<Arguments> list = new ArrayList<Arguments>();\n+        int sizeDelta = transferSizeMax - transferSizeMin;\n+        for (int i = 0; i < 10; i++) {\n+            Arguments args =\n+                Arguments.of(RND.nextInt(1024),\n+                             transferSizeMin + RND.nextInt(sizeDelta),\n+                             1 + RND.nextInt(2047));\n+            list.add(args);\n@@ -64,0 +71,1 @@\n+        return list.stream();\n@@ -66,10 +74,11 @@\n-    private static final void test() throws IOException {\n-        Path dir = Path.of(System.getProperty(\"test.dir\", \".\"));\n-        Path file = Files.createTempFile(dir, \"foo\", \"bar\");\n-        try (FileChannel fc = FileChannel.open(file, DELETE_ON_CLOSE,\n-                                               READ, WRITE)) {\n-            fc.position(RND.nextInt(TARGET_INITIAL_POS_MAX));\n-            fc.write(ByteBuffer.wrap(new byte[] {(byte)42}));\n-            fromDirectlyOrMapped(dir, fc);\n-            fromArbitrary(fc);\n-        }\n+    \/\/\n+    \/\/ transfer size must be greater than the threshold\n+    \/\/ sun.nio.ch.FileChannelImpl::MAPPED_TRANSFER_THRESHOLD (16K)\n+    \/\/ for a mapped transfer to be used when direct is unavailable\n+    \/\/\n+    private static Stream<Arguments> fastParamProvider() {\n+        return paramProvider(16*1024 + 1, 500*1024);\n+    }\n+\n+    private static Stream<Arguments> slowParamProvider() {\n+        return paramProvider(1, 64*1024);\n@@ -81,1 +90,2 @@\n-    \/\/ there is no direct path and the size of the transfer is more than 16K.\n+    \/\/ there is no direct path and the size of the transfer is more than\n+    \/\/ sun.nio.ch.FileChannelImpl::MAPPED_TRANSFER_THRESHOLD (16K).\n@@ -85,1 +95,3 @@\n-    private static void fromDirectlyOrMapped(Path dir, FileChannel target)\n+    @ParameterizedTest\n+    @MethodSource(\"fastParamProvider\")\n+    void fromFast(long initialPosition, int bufSize, long offset)\n@@ -87,1 +99,1 @@\n-        Path file = Files.createTempFile(dir, \"foo\", \"bar\");\n+        Path file = Files.createTempFile(DIR, \"foo\", \"bar\");\n@@ -90,2 +102,0 @@\n-            int bufSize = FAST_TRANSFER_SIZE_MIN +\n-                RND.nextInt(FAST_TRANSFER_SIZE_MAX - FAST_TRANSFER_SIZE_MIN);\n@@ -95,12 +105,1 @@\n-\n-            final long size = target.size();\n-            final long position = size + TARGET_OFFSET_POS_MIN +\n-                RND.nextInt(TARGET_OFFSET_POS_MAX - TARGET_OFFSET_POS_MIN);\n-            final long count = src.size();\n-            final long transferred = target.transferFrom(src, position, count);\n-            if (transferred != count)\n-                throw new RuntimeException(transferred + \" != \" + count);\n-            ByteBuffer buf = ByteBuffer.allocate((int)count);\n-            target.read(buf, position);\n-            if (!Arrays.equals(buf.array(), bytes))\n-                throw new RuntimeException(\"arrays unequal\");\n+            transferFrom(src, src.size(), initialPosition, offset, bytes);\n@@ -114,1 +113,3 @@\n-    private static void fromArbitrary(FileChannel target)\n+    @ParameterizedTest\n+    @MethodSource(\"slowParamProvider\")\n+    void fromSlow(long initialPosition, int bufSize, long offset)\n@@ -116,1 +117,0 @@\n-        int bufSize = 1 + RND.nextInt(GENERIC_TRANSFER_SIZE_MAX - 1);\n@@ -121,5 +121,27 @@\n-            final long size = target.size();\n-            final long position = size + TARGET_OFFSET_POS_MIN +\n-                RND.nextInt(TARGET_OFFSET_POS_MAX - TARGET_OFFSET_POS_MIN);\n-            final long count = bytes.length;\n-            final long transferred = target.transferFrom(src, position, count);\n+            transferFrom(src, bufSize, initialPosition, offset, bytes);\n+        }\n+    }\n+\n+    \/**\n+     * Tests transferring bytes to a FileChannel from a ReadableByteChannel.\n+     *\n+     * @param src        the source of the bytes to transfer\n+     * @param count the  number of bytes to transfer\n+     * @param initialPos the position of the target channel before the transfer\n+     * @param offset     the offset beyong the end of the target channel\n+     * @param bytes      the bytes expected to be transferred\n+     *\n+     * @throws RuntimeException if an unexpected number of bytes is transferred\n+     *                          or the transferred values are not as expected\n+     *\/\n+    private static void transferFrom(ReadableByteChannel src, long count,\n+                                     long initialPos, long offset, byte[] bytes)\n+        throws IOException {\n+        Path file = Files.createTempFile(DIR, \"foo\", \"bar\");\n+        try (FileChannel target = FileChannel.open(file, DELETE_ON_CLOSE,\n+                                                   READ, WRITE)) {\n+            target.position(initialPos);\n+            target.write(ByteBuffer.wrap(new byte[] {(byte)42}));\n+\n+            long position = target.size() + offset;\n+            long transferred = target.transferFrom(src, position, count);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/TransferFromExtend.java","additions":70,"deletions":48,"binary":false,"changes":118,"status":"modified"}]}