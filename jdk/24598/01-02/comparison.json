{"files":[{"patch":"@@ -728,0 +728,4 @@\n+\n+            \/\/ data and tempBuilder do not need to be copied because they do\n+            \/\/ not carry significant information. They will be recreated on demand.\n+            \/\/ Setting them to null is needed to avoid sharing across clones.\n@@ -730,0 +734,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -41,1 +42,2 @@\n-    \/\/ Specifically tests that when DecimalFormat is cloned after use with\n+\n+    \/\/ Tests that when DecimalFormat is cloned after use with\n@@ -43,1 +45,3 @@\n-    \/\/ exhaustive test.\n+    \/\/ exhaustive test. This tests for the issue of the same DigitList.data\n+    \/\/ array being reused across clones of DecimalFormat.\n+\n@@ -48,0 +52,5 @@\n+        CountDownLatch startSignal = new CountDownLatch(1);\n+\n+        \/\/ This initial use of the formatter initialises its internal state, which could\n+        \/\/ subsequently be shared across clones. This is key to reproducing this specific\n+        \/\/ issue.\n@@ -49,0 +58,1 @@\n+\n@@ -50,1 +60,2 @@\n-            for (int i = 0; i < 50; i++) {\n+            for (int i = 0; i < 5; i++) {\n+                final int finalI = i;\n@@ -54,7 +65,12 @@\n-                    for (int j = 0; j < 1000000; j++) {\n-                        String dfString = threadDf.format(BigDecimal.valueOf(j));\n-                        String str1 = String.valueOf(j);\n-                        if (!str1.equals(dfString)) {\n-                            System.err.println(\"mismatch: str = \" + str1 + \" dfString = \" + dfString);\n-                            mismatchCount.incrementAndGet();\n-                            break;\n+                    try {\n+                        startSignal.await();\n+                        for (int j = 0; j < 1_000; j++) {\n+                            int value = finalI * j;\n+                            String dfString = threadDf.format(BigDecimal.valueOf(value));\n+                            String str1 = String.valueOf(value);\n+                            if (!str1.equals(dfString)) {\n+                                int count = mismatchCount.getAndIncrement();\n+                                if (count < 5) { \/\/ limit lines of output\n+                                    System.err.println(\"mismatch: str = \" + str1 + \" dfString = \" + dfString);\n+                                }\n+                            }\n@@ -62,0 +78,2 @@\n+                    } catch (InterruptedException e) {\n+                        \/\/ just end\n@@ -66,0 +84,1 @@\n+            startSignal.countDown(); \/\/ let all tasks start working at the same time\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/CloneTest.java","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"}]}