{"files":[{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib\n@@ -31,1 +32,1 @@\n-import org.junit.jupiter.api.BeforeAll;\n+import jtreg.SkippedException;\n@@ -44,18 +45,0 @@\n-    private static Field DIGIT_LIST_FIELD;\n-    private static Class<?> DIGIT_LIST_CLASS;\n-\n-    @BeforeAll\n-    static void setup() throws Exception {\n-        DIGIT_LIST_FIELD = DecimalFormat.class.getDeclaredField(\"digitList\");\n-        DIGIT_LIST_FIELD.setAccessible(true);\n-\n-        DecimalFormat df = new DecimalFormat();\n-        Object digitList = DIGIT_LIST_FIELD.get(df);\n-\n-        DIGIT_LIST_CLASS = digitList.getClass();\n-    }\n-\n-    \/\/ Tests that when DecimalFormat is cloned after use with\n-    \/\/ a long double\/BigDecimal, clones will be independent. This is not an\n-    \/\/ exhaustive test. This tests for the issue of the same DigitList.data\n-    \/\/ array being reused across clones of DecimalFormat.\n@@ -63,0 +46,1 @@\n+    \/\/ Note: this is a white-box test that may fail if the implementation is changed\n@@ -64,1 +48,1 @@\n-    public void testClone() throws Exception {\n+    public void testClone() {\n@@ -66,1 +50,1 @@\n-        assertCloneValidity(df);\n+        new CloneTester(df).testClone();\n@@ -69,0 +53,1 @@\n+    \/\/ Note: this is a white-box test that may fail if the implementation is changed\n@@ -70,1 +55,1 @@\n-    public void testCloneAfterInit() throws Exception {\n+    public void testCloneAfterInit() {\n@@ -77,1 +62,1 @@\n-        assertCloneValidity(df);\n+        new CloneTester(df).testClone();\n@@ -80,2 +65,25 @@\n-    private static void assertCloneValidity(DecimalFormat df) throws Exception {\n-        DecimalFormat dfClone = (DecimalFormat) df.clone();\n+    private static class CloneTester {\n+        private final Field digitListField;\n+        private final Class<?> digitListClass;\n+        private final DecimalFormat original;\n+\n+        public CloneTester(DecimalFormat original) {\n+            this.original = original;\n+            try {\n+                digitListField = DecimalFormat.class.getDeclaredField(\"digitList\");\n+                digitListField.setAccessible(true);\n+\n+                DecimalFormat df = new DecimalFormat();\n+                Object digitList = digitListField.get(df);\n+\n+                digitListClass = digitList.getClass();\n+            } catch (NoSuchFieldException e) {\n+                throw new RuntimeException(e);\n+            } catch (ReflectiveOperationException e) {\n+                throw new SkippedException(\"reflective access in white-box test failed\", e);\n+            }\n+        }\n+\n+        public void testClone() {\n+            try {\n+                DecimalFormat dfClone = (DecimalFormat) original.clone();\n@@ -83,2 +91,2 @@\n-        Object digits = valFromDigitList(df, \"digits\");\n-        assertNotSame(digits, valFromDigitList(dfClone, \"digits\"));\n+                Object digits = valFromDigitList(original, \"digits\");\n+                assertNotSame(digits, valFromDigitList(dfClone, \"digits\"));\n@@ -87,4 +95,4 @@\n-        Object data = valFromDigitList(df, \"data\");\n-        if (data != null) {\n-            assertNotSame(data, valFromDigitList(dfClone, \"data\"));\n-        }\n+                Object data = valFromDigitList(original, \"data\");\n+                if (data != null) {\n+                    assertNotSame(data, valFromDigitList(dfClone, \"data\"));\n+                }\n@@ -92,4 +100,4 @@\n-        Object tempBuilder = valFromDigitList(df, \"tempBuilder\");\n-        if (tempBuilder != null) {\n-            assertNotSame(data, valFromDigitList(dfClone, \"data\"));\n-        }\n+                Object tempBuilder = valFromDigitList(original, \"tempBuilder\");\n+                if (tempBuilder != null) {\n+                    assertNotSame(data, valFromDigitList(dfClone, \"data\"));\n+                }\n@@ -97,2 +105,5 @@\n-        assertEquals(DIGIT_LIST_FIELD.get(df), DIGIT_LIST_FIELD.get(dfClone));\n-    }\n+                assertEquals(digitListField.get(original), digitListField.get(dfClone));\n+            } catch (ReflectiveOperationException e) {\n+                throw new SkippedException(\"reflective access in white-box test failed\", e);\n+            }\n+        }\n@@ -100,4 +111,3 @@\n-    private static Object valFromDigitList(DecimalFormat df, String fieldName) {\n-        try {\n-            Object digitList = DIGIT_LIST_FIELD.get(df);\n-            Field field = DIGIT_LIST_CLASS.getDeclaredField(fieldName);\n+        private Object valFromDigitList(DecimalFormat df, String fieldName) throws ReflectiveOperationException {\n+            Object digitList = digitListField.get(df);\n+            Field field = digitListClass.getDeclaredField(fieldName);\n@@ -107,2 +117,0 @@\n-        } catch (ReflectiveOperationException e) {\n-            throw new RuntimeException(e);\n@@ -112,0 +120,5 @@\n+    \/\/ Tests that when DecimalFormat is cloned after use with\n+    \/\/ a long double\/BigDecimal, clones will be independent. This is not an\n+    \/\/ exhaustive test. This tests for the issue of the same DigitList.data\n+    \/\/ array being reused across clones of DecimalFormat.\n+\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/CloneTest.java","additions":56,"deletions":43,"binary":false,"changes":99,"status":"modified"}]}