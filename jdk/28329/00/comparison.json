{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -37,5 +38,8 @@\n-\/\/ To be used in a LockFreeStack of objects of type T, an object of\n-\/\/ type T must have a list entry member of type T* volatile, with an\n-\/\/ non-member accessor function returning a pointer to that member.  A\n-\/\/ LockFreeStack is associated with the class of its elements and an\n-\/\/ entry member from that class.\n+\/\/ To be used in a LockFreeStack of objects of type T, an object of type T\n+\/\/ must have a list entry member. A list entry member is a data member whose\n+\/\/ type is either (1) Atomic<T*>, or (2) T* volatile. There must be a\n+\/\/ non-member or static member function returning a pointer to that member,\n+\/\/ which is used to provide access to it by a LockFreeStack.  A LockFreeStack\n+\/\/ is associated with the class of its elements and an entry member from that\n+\/\/ class by being specialized on the element class and a pointer to the\n+\/\/ function for accessing that entry member.\n@@ -55,1 +59,1 @@\n-\/\/ \\tparam next_ptr is a function pointer.  Applying this function to\n+\/\/ \\tparam next_access is a function pointer.  Applying this function to\n@@ -58,1 +62,1 @@\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n+template<typename T, auto next_access>\n@@ -60,1 +64,1 @@\n-  T* volatile _top;\n+  Atomic<T*> _top;\n@@ -68,1 +72,1 @@\n-      cur = AtomicAccess::cmpxchg(&_top, cur, first);\n+      cur = _top.compare_exchange(cur, first);\n@@ -74,0 +78,9 @@\n+  template<typename NextAccessor>\n+  static constexpr void use_atomic_access_impl(NextAccessor) {\n+    static_assert(DependentAlwaysFalse<NextAccessor>, \"Invalid next accessor\");\n+  }\n+  static constexpr bool use_atomic_access_impl(T* volatile* (*)(T&)) { return true; }\n+  static constexpr bool use_atomic_access_impl(Atomic<T*>* (*)(T&)) { return false; }\n+\n+  static constexpr bool use_atomic_access = use_atomic_access_impl(next_access);\n+\n@@ -92,1 +105,1 @@\n-      result = AtomicAccess::cmpxchg(&_top, result, new_top);\n+      result = _top.compare_exchange(result, new_top);\n@@ -104,1 +117,1 @@\n-    return AtomicAccess::xchg(&_top, (T*)nullptr);\n+    return _top.exchange(nullptr);\n@@ -146,1 +159,1 @@\n-  \/\/ Return the most recently pushed element, or nullptr if the stack is empty.\n+  \/\/ Return the most recently pushed element, or null if the stack is empty.\n@@ -148,1 +161,1 @@\n-  T* top() const { return AtomicAccess::load(&_top); }\n+  T* top() const { return _top.load_relaxed(); }\n@@ -163,1 +176,5 @@\n-    return AtomicAccess::load(next_ptr(const_cast<T&>(value)));\n+    if constexpr (use_atomic_access) {\n+      return AtomicAccess::load(next_access(const_cast<T&>(value)));\n+    } else {\n+      return next_access(const_cast<T&>(value))->load_relaxed();\n+    }\n@@ -171,1 +188,5 @@\n-    AtomicAccess::store(next_ptr(value), new_next);\n+    if constexpr (use_atomic_access) {\n+      AtomicAccess::store(next_access(value), new_next);\n+    } else {\n+      next_access(value)->store_relaxed(new_next);\n+    }\n","filename":"src\/hotspot\/share\/utilities\/lockFreeStack.hpp","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -36,2 +36,2 @@\n-  Element* volatile _entry;\n-  Element* volatile _entry1;\n+  Atomic<Element*> _entry;\n+  Atomic<Element*> _entry1;\n@@ -40,2 +40,2 @@\n-  static Element* volatile* entry_ptr(Element& e) { return &e._entry; }\n-  static Element* volatile* entry1_ptr(Element& e) { return &e._entry1; }\n+  static Atomic<Element*>* entry_ptr(Element& e) { return &e._entry; }\n+  static Atomic<Element*>* entry1_ptr(Element& e) { return &e._entry1; }\n@@ -205,1 +205,1 @@\n-  volatile size_t* _processed;\n+  Atomic<size_t>* _processed;\n@@ -208,1 +208,1 @@\n-  volatile bool _ready;\n+  Atomic<bool> _ready;\n@@ -215,1 +215,1 @@\n-                          volatile size_t* processed,\n+                          Atomic<size_t>* processed,\n@@ -228,1 +228,1 @@\n-    AtomicAccess::release_store_fence(&_ready, true);\n+    _ready.release_store_fence(true);\n@@ -233,1 +233,1 @@\n-        AtomicAccess::inc(_processed);\n+        _processed->fetch_then_add(1u);\n@@ -235,1 +235,1 @@\n-      } else if (AtomicAccess::load_acquire(_processed) == _process_limit) {\n+      } else if (_processed->load_acquire() == _process_limit) {\n@@ -242,1 +242,1 @@\n-  bool ready() const { return AtomicAccess::load_acquire(&_ready); }\n+  bool ready() const { return _ready.load_acquire(); }\n@@ -251,2 +251,2 @@\n-  volatile size_t stage1_processed = 0;\n-  volatile size_t stage2_processed = 0;\n+  Atomic<size_t> stage1_processed{0};\n+  Atomic<size_t> stage2_processed{0};\n@@ -275,1 +275,1 @@\n-    volatile size_t* processed = &stage1_processed;\n+    Atomic<size_t>* processed = &stage1_processed;\n@@ -296,2 +296,2 @@\n-  ASSERT_EQ(nelements, stage1_processed);\n-  ASSERT_EQ(nelements, stage2_processed);\n+  ASSERT_EQ(nelements, stage1_processed.load_relaxed());\n+  ASSERT_EQ(nelements, stage2_processed.load_relaxed());\n","filename":"test\/hotspot\/gtest\/utilities\/test_lockFreeStack.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"}]}