{"files":[{"patch":"@@ -115,1 +115,1 @@\n-    if (!scaleI.is_zero() && !scaleL.is_NaN()) {\n+    if (!scaleI.is_zero() && !scaleL.is_zero()) {\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,4 @@\n- *\n+ * - Generate cases that would catch bugs like JDK-8369902:\n+ *   - Large long constants, or scales. Probably only possible for MemorySegment.\n+ *   - Large number of invar, and reuse of invar so that they could cancle\n+ *     to zero, and need to be filtered out.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAliasingFuzzer.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8369902\n+ * @summary Bug in MemPointerParser::canonicalize_raw_summands let to wrong result, because a\n+ *          NaN summand was filtered out, instead of making the MemPointer \/ VPointer invalid.\n+ * @run main\/othervm\n+ *      -XX:+IgnoreUnrecognizedVMOptions\n+ *      -XX:CompileCommand=compileonly,*TestDoNotFilterNaNSummands::test\n+ *      -Xbatch\n+ *      compiler.loopopts.superword.TestDoNotFilterNaNSummands\n+ * @run main compiler.loopopts.superword.TestDoNotFilterNaNSummands\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+\/\/ This was the test found by the fuzzer. If you are looking for a simpler example with the same issue,\n+\/\/ please look at TestMemorySegmentFilterSummands::test2.\n+public class TestDoNotFilterNaNSummands {\n+    static final int N = 100;\n+    static int zero = 0;\n+\n+    static int[] test() {\n+        int x = -4;\n+        int aI[] = new int[N];\n+        for (int k = 0; k < N; k++) {\n+            \/\/ Note that x is always \"-4\", and N is a compile time constant. The modulo \"%\"\n+            \/\/ gets optimized with magic numbers and shift\/mul\/sub trick, in the long domain,\n+            \/\/ which somehow creates some large long constant that cannot be represented\n+            \/\/ as an int.\n+            int idx = (x >>> 1) % N;\n+            \/\/ This is the CountedLoop that we may try to auto vectorize.\n+            \/\/ We have a linear access (i) and a constant index access (idx), which eventually\n+            \/\/ cross, so there is aliasing. If there is vectorization with an aliasing runtime\n+            \/\/ check, this check must fail.\n+            for (int i = 1; i < 63; i++) {\n+                aI[i] = 2;\n+                \/\/ The MemPointer \/ VPointer for the accesses below contain a large constant\n+                \/\/ long constant offset that cannot be represented as an int, so the scaleL\n+                \/\/ NoOverflowInt becomes NaN. In MemPointerParser::canonicalize_raw_summands\n+                \/\/ we are supposed to filter out zero summands, but since we WRONGLY filtered\n+                \/\/ out NaNs instead, this summand got filtered out, and later we did not detect\n+                \/\/ that the MemPointer contains a NaN. Instead, we just get a \"valid\" looking\n+                \/\/ VPointer, and generate runtime checks that are missing the long constant\n+                \/\/ offset, leading to wrong decisions, and hence vectorization even though\n+                \/\/ we have aliasing. This means that the accesses from above and below get\n+                \/\/ reordered in an illegal way, leading to wrong results.\n+                aI[idx] += 1;\n+            }\n+            for (int i = 0; i < 100; i++) {\n+                \/\/ It is a no-op, but the compiler can't know statically that zero=0.\n+                \/\/ Seems to be required in the graph, no idea why.\n+                x >>= zero;\n+            }\n+        }\n+        return aI;\n+    }\n+\n+    \/\/ Use the sum as an easy way to compare the results.\n+    public static int sum(int[] aI) {\n+        int sum = 0;\n+        for (int i = 0; i < aI.length; i++) { sum += aI[i]; }\n+        return sum;\n+    }\n+\n+    public static void main(String[] args) {\n+        \/\/ Run once, hopefully before compilation, so get interpreter results.\n+        int[] aIG = test();\n+        int gold = sum(aIG);\n+\n+        \/\/ Repeat execution, until eventually compilation happens, compare\n+        \/\/ compiler results to interpreter results.\n+        for (int k = 0; k < 1000; k++) {\n+            int[] aI = test();\n+            int val = sum(aI);\n+            if (gold != val) {\n+                System.out.println(\"Detected wrong result, printing values of arrays:\");\n+                for (int i = 0; i < aI.length; i++) {\n+                    System.out.println(\"at \" + i + \": \" + aIG[i] + \" vs \" + aI[i]);\n+                }\n+                throw new RuntimeException(\"wrong result: \" + gold + \" \" + val);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDoNotFilterNaNSummands.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import java.lang.foreign.*;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.verify.*;\n+\n+\/*\n+ * @test\n+ * @bug 8369902\n+ * @summary Bug in MemPointerParser::canonicalize_raw_summands let to wrong results or assert.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentFilterSummands\n+ *\/\n+\n+public class TestMemorySegmentFilterSummands {\n+\n+    static long init  = 1000;\n+    static long limit = 9000;\n+\n+    static long invar0 = 0;\n+    static long invar1 = 0;\n+    static long invar2 = 0;\n+    static long invar3 = 0;\n+    static long invar4 = 0;\n+    static long invarX = 0;\n+\n+    public static final long BIG = 0x200000000L;\n+    public static long big = -BIG;\n+\n+    static MemorySegment a1 = Arena.ofAuto().allocate(10_000);\n+    static MemorySegment b1 = Arena.ofAuto().allocate(10_000);\n+    static {\n+        for (long i = init; i < limit; i++) {\n+            a1.set(ValueLayout.JAVA_BYTE, i, (byte)((i & 0xf) + 1));\n+        }\n+    }\n+\n+    static MemorySegment a2 = MemorySegment.ofArray(new byte[40_000]);\n+    static MemorySegment b2 = a2;\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_VECTOR,   \"> 0\",\n+                  IRNode.LOAD_VECTOR_B,  \"> 0\",\n+                  \".*multiversion.*\",    \"= 0\"}, \/\/ AutoVectorization Predicate SUFFICES, there is no aliasing\n+        phase = CompilePhase.PRINT_IDEAL,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    public static void test1() {\n+        long invar = 0;\n+        invar += invarX; \/\/ cancles out with above\n+        invar += invar0;\n+        invar += invar1;\n+        invar += invar2;\n+        invar += invar3;\n+        invar += invar4;\n+        invar -= invarX; \/\/ cancles out with above\n+        \/\/ invar contains a raw summand for invarX, which has a scaleL=0. It needs to be filtered out.\n+        \/\/ The two occurances of invarX are conveniently put in a long chain, so that IGVN cannot see\n+        \/\/ that they cancle out, so that they are not optimized out before loop-opts.\n+        for (long i = init; i < limit; i++) {\n+            byte v = a1.get(ValueLayout.JAVA_BYTE, i + invar);\n+            b1.set(ValueLayout.JAVA_BYTE, i + invar, v);\n+        }\n+    }\n+\n+    @Check(test = \"test1\")\n+    static void check1() {\n+        Verify.checkEQ(a1, b1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ This test could in principle show vectorization, but it would probably need to do some special\n+    \/\/ tricks to only vectorize around the overlap. Still, it could happen that at some point we end\n+    \/\/ up multiversioning, and having a vectorized loop that is never entered.\n+    \/\/\n+    \/\/ For now, the long constant BIG leads to an invalid VPointer, which means we do not vectorize.\n+    static void test2() {\n+        \/\/ At runtime, \"BIG + big\" is zero. But BIG is a long constant that cannot be represented as\n+        \/\/ an int, and so the scaleL NoOverflowInt is a NaN. We should not filter it out from the summands,\n+        \/\/ but instead make the MemPointer \/ VPointer invalid, which prevents vectorization.\n+        long adr = 4L * 5000 + BIG + big;\n+\n+        for (long i = init; i < limit; i++) {\n+            \/\/ The reference to a2 iterates linearly, while the reference to \"b2\" stays at the same adr.\n+            \/\/ But the two alias: in the middle of the \"a2\" range it crosses over \"b2\" adr, so the\n+            \/\/ aliasing runtime check (if we generate one) should fail. But if \"BIG\" is just filtered\n+            \/\/ out from the summands, we instead just create a runtime check without it, which leads\n+            \/\/ to a wrong answer, and the check does not fail, and we get wrong results.\n+            a2.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * i, 0);\n+            int v = b2.get(ValueLayout.JAVA_INT_UNALIGNED, adr);\n+            b2.set(ValueLayout.JAVA_INT_UNALIGNED, adr, v + 1);\n+        }\n+    }\n+\n+    @Check(test = \"test2\")\n+    static void check2() {\n+        int s = 0;\n+        for (long i = init; i < limit; i++) {\n+            s += a2.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * i);\n+        }\n+        if (s != 4000) {\n+            throw new RuntimeException(\"wrong value\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentFilterSummands.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}