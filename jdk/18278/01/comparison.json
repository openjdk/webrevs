{"files":[{"patch":"@@ -82,7 +82,0 @@\n-  \/\/ Par compact uses lower default values since they are treated as\n-  \/\/ minimums.  These are different defaults because of the different\n-  \/\/ interpretation and are not ergonomically set.\n-  if (FLAG_IS_DEFAULT(MarkSweepDeadRatio)) {\n-    FLAG_SET_DEFAULT(MarkSweepDeadRatio, 1);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -48,10 +48,0 @@\n-  product(size_t, ParallelOldDeadWoodLimiterMean, 50,                       \\\n-          \"The mean used by the parallel compact dead wood \"                \\\n-          \"limiter (a number between 0-100)\")                               \\\n-          range(0, 100)                                                     \\\n-                                                                            \\\n-  product(size_t, ParallelOldDeadWoodLimiterStdDev, 80,                     \\\n-          \"The standard deviation used by the parallel compact dead wood \"  \\\n-          \"limiter (a number between 0-100)\")                               \\\n-          range(0, 100)                                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallel_globals.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -142,8 +142,0 @@\n-double PSParallelCompact::_dwl_mean;\n-double PSParallelCompact::_dwl_std_dev;\n-double PSParallelCompact::_dwl_first_term;\n-double PSParallelCompact::_dwl_adjustment;\n-#ifdef  ASSERT\n-bool   PSParallelCompact::_dwl_initialized = false;\n-#endif  \/\/ #ifdef ASSERT\n-\n@@ -834,1 +826,0 @@\n-  initialize_dead_wood_limiter();\n@@ -870,10 +861,0 @@\n-void PSParallelCompact::initialize_dead_wood_limiter()\n-{\n-  const size_t max = 100;\n-  _dwl_mean = double(MIN2(ParallelOldDeadWoodLimiterMean, max)) \/ 100.0;\n-  _dwl_std_dev = double(MIN2(ParallelOldDeadWoodLimiterStdDev, max)) \/ 100.0;\n-  _dwl_first_term = 1.0 \/ (sqrt(2.0 * M_PI) * _dwl_std_dev);\n-  DEBUG_ONLY(_dwl_initialized = true;)\n-  _dwl_adjustment = normal_distribution(1.0);\n-}\n-\n@@ -1010,54 +991,0 @@\n-\/\/ Return a fraction indicating how much of the generation can be treated as\n-\/\/ \"dead wood\" (i.e., not reclaimed).  The function uses a normal distribution\n-\/\/ based on the density of live objects in the generation to determine a limit,\n-\/\/ which is then adjusted so the return value is min_percent when the density is\n-\/\/ 1.\n-\/\/\n-\/\/ The following table shows some return values for a different values of the\n-\/\/ standard deviation (ParallelOldDeadWoodLimiterStdDev); the mean is 0.5 and\n-\/\/ min_percent is 1.\n-\/\/\n-\/\/                          fraction allowed as dead wood\n-\/\/         -----------------------------------------------------------------\n-\/\/ density std_dev=70 std_dev=75 std_dev=80 std_dev=85 std_dev=90 std_dev=95\n-\/\/ ------- ---------- ---------- ---------- ---------- ---------- ----------\n-\/\/ 0.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000\n-\/\/ 0.05000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941\n-\/\/ 0.10000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272\n-\/\/ 0.15000 0.07135702 0.06111390 0.05296419 0.04641639 0.04110601 0.03676066\n-\/\/ 0.20000 0.08831616 0.07509618 0.06461766 0.05622444 0.04943437 0.04388975\n-\/\/ 0.25000 0.10311208 0.08724696 0.07471205 0.06469760 0.05661313 0.05002313\n-\/\/ 0.30000 0.11553050 0.09741183 0.08313394 0.07175114 0.06257797 0.05511132\n-\/\/ 0.35000 0.12538832 0.10545958 0.08978741 0.07731366 0.06727491 0.05911289\n-\/\/ 0.40000 0.13253818 0.11128511 0.09459590 0.08132834 0.07066107 0.06199500\n-\/\/ 0.45000 0.13687208 0.11481163 0.09750361 0.08375387 0.07270534 0.06373386\n-\/\/ 0.50000 0.13832410 0.11599237 0.09847664 0.08456518 0.07338887 0.06431510\n-\/\/ 0.55000 0.13687208 0.11481163 0.09750361 0.08375387 0.07270534 0.06373386\n-\/\/ 0.60000 0.13253818 0.11128511 0.09459590 0.08132834 0.07066107 0.06199500\n-\/\/ 0.65000 0.12538832 0.10545958 0.08978741 0.07731366 0.06727491 0.05911289\n-\/\/ 0.70000 0.11553050 0.09741183 0.08313394 0.07175114 0.06257797 0.05511132\n-\/\/ 0.75000 0.10311208 0.08724696 0.07471205 0.06469760 0.05661313 0.05002313\n-\/\/ 0.80000 0.08831616 0.07509618 0.06461766 0.05622444 0.04943437 0.04388975\n-\/\/ 0.85000 0.07135702 0.06111390 0.05296419 0.04641639 0.04110601 0.03676066\n-\/\/ 0.90000 0.05247504 0.04547452 0.03988045 0.03537016 0.03170171 0.02869272\n-\/\/ 0.95000 0.03193096 0.02836880 0.02550828 0.02319280 0.02130337 0.01974941\n-\/\/ 1.00000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000 0.01000000\n-\n-double PSParallelCompact::dead_wood_limiter(double density, size_t min_percent)\n-{\n-  assert(_dwl_initialized, \"uninitialized\");\n-\n-  \/\/ The raw limit is the value of the normal distribution at x = density.\n-  const double raw_limit = normal_distribution(density);\n-\n-  \/\/ Adjust the raw limit so it becomes the minimum when the density is 1.\n-  \/\/\n-  \/\/ First subtract the adjustment value (which is simply the precomputed value\n-  \/\/ normal_distribution(1.0)); this yields a value of 0 when the density is 1.\n-  \/\/ Then add the minimum value, so the minimum is returned when the density is\n-  \/\/ 1.  Finally, prevent negative values, which occur when the mean is not 0.5.\n-  const double min = double(min_percent) \/ 100.0;\n-  const double limit = raw_limit - _dwl_adjustment + min;\n-  return MAX2(limit, 0.0);\n-}\n-\n@@ -1094,61 +1021,0 @@\n-ParallelCompactData::RegionData*\n-PSParallelCompact::dead_wood_limit_region(const RegionData* beg,\n-                                          const RegionData* end,\n-                                          size_t dead_words)\n-{\n-  ParallelCompactData& sd = summary_data();\n-  size_t left = sd.region(beg);\n-  size_t right = end > beg ? sd.region(end) - 1 : left;\n-\n-  \/\/ Binary search.\n-  while (left < right) {\n-    \/\/ Equivalent to (left + right) \/ 2, but does not overflow.\n-    const size_t middle = left + (right - left) \/ 2;\n-    RegionData* const middle_ptr = sd.region(middle);\n-    HeapWord* const dest = middle_ptr->destination();\n-    HeapWord* const addr = sd.region_to_addr(middle);\n-    assert(dest != nullptr, \"sanity\");\n-    assert(dest <= addr, \"must move left\");\n-\n-    const size_t dead_to_left = pointer_delta(addr, dest);\n-    if (middle > left && dead_to_left > dead_words) {\n-      right = middle - 1;\n-    } else if (middle < right && dead_to_left < dead_words) {\n-      left = middle + 1;\n-    } else {\n-      return middle_ptr;\n-    }\n-  }\n-  return sd.region(left);\n-}\n-\n-\/\/ The result is valid during the summary phase, after the initial summarization\n-\/\/ of each space into itself, and before final summarization.\n-inline double\n-PSParallelCompact::reclaimed_ratio(const RegionData* const cp,\n-                                   HeapWord* const bottom,\n-                                   HeapWord* const top,\n-                                   HeapWord* const new_top)\n-{\n-  ParallelCompactData& sd = summary_data();\n-\n-  assert(cp != nullptr, \"sanity\");\n-  assert(bottom != nullptr, \"sanity\");\n-  assert(top != nullptr, \"sanity\");\n-  assert(new_top != nullptr, \"sanity\");\n-  assert(top >= new_top, \"summary data problem?\");\n-  assert(new_top > bottom, \"space is empty; should not be here\");\n-  assert(new_top >= cp->destination(), \"sanity\");\n-  assert(top >= sd.region_to_addr(cp), \"sanity\");\n-\n-  HeapWord* const destination = cp->destination();\n-  const size_t dense_prefix_live  = pointer_delta(destination, bottom);\n-  const size_t compacted_region_live = pointer_delta(new_top, destination);\n-  const size_t compacted_region_used = pointer_delta(top,\n-                                                     sd.region_to_addr(cp));\n-  const size_t reclaimable = compacted_region_used - compacted_region_live;\n-\n-  const double divisor = dense_prefix_live + 1.25 * compacted_region_live;\n-  return double(reclaimable) \/ divisor;\n-}\n-\n@@ -1204,35 +1070,14 @@\n-  const size_t space_live = pointer_delta(new_top, bottom);\n-  const size_t space_used = space->used_in_words();\n-  const size_t space_capacity = space->capacity_in_words();\n-\n-  const double density = double(space_live) \/ double(space_capacity);\n-  const size_t min_percent_free = MarkSweepDeadRatio;\n-  const double limiter = dead_wood_limiter(density, min_percent_free);\n-  const size_t dead_wood_max = space_used - space_live;\n-  const size_t dead_wood_limit = MIN2(size_t(space_capacity * limiter),\n-                                      dead_wood_max);\n-\n-  log_develop_debug(gc, compaction)(\n-      \"space_live=\" SIZE_FORMAT \" space_used=\" SIZE_FORMAT \" \"\n-      \"space_cap=\" SIZE_FORMAT,\n-      space_live, space_used,\n-      space_capacity);\n-  log_develop_debug(gc, compaction)(\n-      \"dead_wood_limiter(%6.4f, \" SIZE_FORMAT \")=%6.4f \"\n-      \"dead_wood_max=\" SIZE_FORMAT \" dead_wood_limit=\" SIZE_FORMAT,\n-      density, min_percent_free, limiter,\n-      dead_wood_max, dead_wood_limit);\n-\n-  \/\/ Locate the region with the desired amount of dead space to the left.\n-  const RegionData* const limit_cp =\n-    dead_wood_limit_region(full_cp, top_cp, dead_wood_limit);\n-\n-  \/\/ Scan from the first region with dead space to the limit region and find the\n-  \/\/ one with the best (largest) reclaimed ratio.\n-  double best_ratio = 0.0;\n-  const RegionData* best_cp = full_cp;\n-  for (const RegionData* cp = full_cp; cp < limit_cp; ++cp) {\n-    double tmp_ratio = reclaimed_ratio(cp, bottom, top, new_top);\n-    if (tmp_ratio > best_ratio) {\n-      best_cp = cp;\n-      best_ratio = tmp_ratio;\n+  \/\/ Iteration starts with the region *after* the full-region-prefix-end.\n+  const RegionData* const start_region = full_cp;\n+  \/\/ If final region is not full, iteration stops before that region,\n+  \/\/ because fill_dense_prefix_end assumes that prefix_end <= top.\n+  const RegionData* const end_region = sd.addr_to_region_ptr(space->top());\n+  assert(start_region <= end_region, \"inv\");\n+\n+  size_t max_waste = space->capacity_in_words() * (MarkSweepDeadRatio \/ 100.0);\n+  const RegionData* cur_region = start_region;\n+  for (\/* empty *\/; cur_region < end_region; ++cur_region) {\n+    assert(region_size >= cur_region->data_size(), \"inv\");\n+    size_t dead_size = region_size - cur_region->data_size();\n+    if (max_waste < dead_size) {\n+      break;\n@@ -1240,0 +1085,1 @@\n+    max_waste -= dead_size;\n@@ -1242,1 +1088,5 @@\n-  return sd.region_to_addr(best_cp);\n+  HeapWord* const prefix_end = sd.region_to_addr(cur_region);\n+  assert(sd.is_region_aligned(prefix_end), \"postcondition\");\n+  assert(prefix_end >= sd.region_to_addr(full_cp), \"in-range\");\n+  assert(prefix_end <= space->top(), \"in-range\");\n+  return prefix_end;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":20,"deletions":170,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -925,9 +925,0 @@\n-  \/\/ Values computed at initialization and used by dead_wood_limiter().\n-  static double _dwl_mean;\n-  static double _dwl_std_dev;\n-  static double _dwl_first_term;\n-  static double _dwl_adjustment;\n-#ifdef  ASSERT\n-  static bool   _dwl_initialized;\n-#endif  \/\/ #ifdef ASSERT\n-\n@@ -952,18 +943,0 @@\n-  \/\/ Compute the value of the normal distribution at x = density.  The mean and\n-  \/\/ standard deviation are values saved by initialize_dead_wood_limiter().\n-  static inline double normal_distribution(double density);\n-\n-  \/\/ Initialize the static vars used by dead_wood_limiter().\n-  static void initialize_dead_wood_limiter();\n-\n-  \/\/ Return the percentage of space that can be treated as \"dead wood\" (i.e.,\n-  \/\/ not reclaimed).\n-  static double dead_wood_limiter(double density, size_t min_percent);\n-\n-  \/\/ Find the first (left-most) region in the range [beg, end) that has at least\n-  \/\/ dead_words of dead space to the left.  The argument beg must be the first\n-  \/\/ region in the space that is not completely live.\n-  static RegionData* dead_wood_limit_region(const RegionData* beg,\n-                                            const RegionData* end,\n-                                            size_t dead_words);\n-\n@@ -975,12 +948,0 @@\n-  \/\/ Return a value indicating the benefit or 'yield' if the compacted region\n-  \/\/ were to start (or equivalently if the dense prefix were to end) at the\n-  \/\/ candidate region.  Higher values are better.\n-  \/\/\n-  \/\/ The value is based on the amount of space reclaimed vs. the costs of (a)\n-  \/\/ updating references in the dense prefix plus (b) copying objects and\n-  \/\/ updating references in the compacted region.\n-  static inline double reclaimed_ratio(const RegionData* const candidate,\n-                                       HeapWord* const bottom,\n-                                       HeapWord* const top,\n-                                       HeapWord* const new_top);\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -43,6 +43,0 @@\n-inline double PSParallelCompact::normal_distribution(double density) {\n-  assert(_dwl_initialized, \"uninitialized\");\n-  const double squared_term = (density - _dwl_mean) \/ _dwl_std_dev;\n-  return _dwl_first_term * exp(-0.5 * squared_term * squared_term);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -622,4 +622,2 @@\n-          \"Par compact uses a variable scale based on the density of the \"  \\\n-          \"generation and treats this as the maximum value when the heap \"  \\\n-          \"is either completely full or completely empty.  Par compact \"    \\\n-          \"also has a smaller default value; see arguments.cpp. \"           \\\n+          \"Parallel full gc treats this as maximum value, i.e. a non-fully\" \\\n+          \"compact full gc cycle wastes at most this value of space. \"      \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -533,0 +533,3 @@\n+\n+  { \"ParallelOldDeadWoodLimiterMean\",   JDK_Version::undefined(), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n+  { \"ParallelOldDeadWoodLimiterStdDev\", JDK_Version::undefined(), JDK_Version::jdk(23), JDK_Version::jdk(24) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}