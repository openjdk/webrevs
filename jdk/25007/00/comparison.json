{"files":[{"patch":"@@ -987,1 +987,1 @@\n-    const TemplateAssertionPredicate& template_assertion_predicate, Node* new_control) const {\n+  const TemplateAssertionPredicate& template_assertion_predicate, IfTrueNode* cloned_template_predicate_tail) const {\n@@ -992,1 +992,2 @@\n-      initialized_assertion_predicate_creator.create_from_template(template_head, new_control, _init, _stride);\n+      initialized_assertion_predicate_creator.create_from_template(template_head, cloned_template_predicate_tail, _init,\n+                                                                   _stride);\n@@ -995,1 +996,1 @@\n-  template_assertion_predicate.rewire_loop_data_dependencies(initialized_assertion_predicate.tail(),\n+  template_assertion_predicate.rewire_loop_data_dependencies(cloned_template_predicate_tail,\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1101,1 +1101,1 @@\n-                                                         Node* new_control) const;\n+                                                         IfTrueNode* cloned_template_predicate_tail) const;\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,0 +182,12 @@\n+\/*\n+ * @test id=StressXcompMaxUnroll0\n+ * @key randomness\n+ * @bug 8288981\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:+AbortVMOnCompilationFailure\n+ *                   -XX:LoopMaxUnroll=0 -XX:+IgnoreUnrecognizedVMOptions -XX:-KillPathsReachableByDeadTypeNode\n+ *                   -XX:CompileCommand=compileonly,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   -XX:CompileCommand=dontinline,compiler.predicates.assertion.TestAssertionPredicates::*\n+ *                   compiler.predicates.assertion.TestAssertionPredicates StressXcompMaxUnroll0\n+ *\/\n+\n@@ -229,0 +241,1 @@\n+    static int two = 2;\n@@ -241,1 +254,1 @@\n-\n+    static int fooArrSize = 10000001;\n@@ -318,1 +331,1 @@\n-            case \"DataUpdate\" -> {\n+            case \"DataUpdate\", \"StressXcompMaxUnroll0\" -> {\n@@ -326,0 +339,1 @@\n+                    testPeelingThreeTimesDataUpdate();\n@@ -1067,1 +1081,1 @@\n-        \/\/ 9) This loop is not optimized in any way because we have a call inside the loop. This loop is only required\n+        \/\/ 10) This loop is not optimized in any way because we have a call inside the loop. This loop is only required\n@@ -1069,1 +1083,1 @@\n-        \/\/ 10) During GCM with StressGCM, we could schedule the LoadN from the main loop before checking if we should\n+        \/\/ 11) During GCM with StressGCM, we could schedule the LoadN from the main loop before checking if we should\n@@ -1074,1 +1088,1 @@\n-            \/\/ 3) Both loop are peeled (we focus on one of those since both are almost identical except for the\n+            \/\/ 4) Both loop are peeled (we focus on one of those since both are almost identical except for the\n@@ -1078,1 +1092,1 @@\n-            \/\/ 4) Loop unroll policy now returns true.\n+            \/\/ 5) Loop unroll policy now returns true.\n@@ -1088,1 +1102,1 @@\n-            \/\/ 5) During IGVN, we find that the backedge is never taken for main loop (we would over-iteratre) and it\n+            \/\/ 6) During IGVN, we find that the backedge is never taken for main loop (we would over-iteratre) and it\n@@ -1090,1 +1104,1 @@\n-            \/\/ 6) After loop opts, the pre-loop is removed.\n+            \/\/ 7) After loop opts, the pre-loop is removed.\n@@ -1093,1 +1107,1 @@\n-                \/\/ 7) The 'i = 1' value is propagated to the single main loop iteration and we have the following\n+                \/\/ 8) The 'i = 1' value is propagated to the single main loop iteration and we have the following\n@@ -1097,1 +1111,1 @@\n-                \/\/ 8) Without explicitly pinning the LoadN from the main loop at the main loop entry (i.e. below the\n+                \/\/ 9) Without explicitly pinning the LoadN from the main loop at the main loop entry (i.e. below the\n@@ -1330,0 +1344,64 @@\n+\n+    \/\/ -Xcomp -XX:LoopMaxUnroll=0 -XX:+StressGCM -XX:CompileCommand=compileonly,Test*::*\n+    private static void testPeelingThreeTimesDataUpdate() {\n+        Foo[] fooArr = new Foo[fooArrSize];\n+        for (int i = 0; i < two; i++) {\n+            fooArr[10000000 * i] = foo;\n+        }\n+        int x = 0;\n+\n+        \/\/ 2) The Hoisted Range Check Predicate is accompanied by two Template Assertion Predicates. The LoadN node,\n+        \/\/    previously pinned at the hoisted range check, is now pinned at the Template Assertion Predicate. Note\n+        \/\/    that the LoadN is still inside the loop body.\n+        \/\/ 3) The loop is now peeled 3 times which also peels 3 loads from 'fooArr' out of the loop:\n+        \/\/       \/\/ Peeled section from 1st Loop Peeling\n+        \/\/       ...\n+        \/\/       LoadN[0]\n+        \/\/       ...\n+        \/\/       <loop entry guard>\n+        \/\/       \/\/ Peeled section from 2nd Loop Peeling\n+        \/\/       ...\n+        \/\/       LoadN[10000000]\n+        \/\/       Initialized Assertion Predicate (***)\n+        \/\/       <loop entry guard>\n+        \/\/       \/\/ Peeled section from 3rd Loop Peeling\n+        \/\/       ...\n+        \/\/       LoadN[20000000]\n+        \/\/       ...\n+        \/\/       Initialized Assertion Predicate\n+        \/\/       <loop entry guard>\n+        \/\/       Template Assertion Predicate\n+        \/\/       Initialized Assertion Predicate\n+        \/\/ Loop:\n+        \/\/   LoadN[i*10000000]\n+        \/\/\n+        \/\/ To avoid that the peeled LoadN nodes float above the corresponding loop entry guards, we need to pin them\n+        \/\/ below. That is done by updating the dependency of the peeled LoadN to the new Template Assertion Predicate.\n+        \/\/ This is currently broken: We wrongly set the dependency to the Initialized Assertion Predicate instead of the\n+        \/\/ Template Assertion Predicate. We can then no longer find the dependency and miss to update it in the next\n+        \/\/ Loop Peeling application. As a result, all the LoadN pile up at the originally added Initialized Assertion\n+        \/\/ Predicate of the first Loop Peeling application at (***).\n+        \/\/\n+        \/\/ With GCM, we could schedule LoadN[20000000] at (***), before the loop entry corresponding loop entry guard\n+        \/\/ for this load. We then crash during runtime because we are accessing an out-of-range index. The fix is to\n+        \/\/ properly update the data dependencies to the Template Assertion Predicates and not the Initialized Assertion\n+        \/\/ Predicates.\n+        for (int i = 0; i < two; i++) {\n+            \/\/ 1) Hoisted with a Hoisted Range Check Predicate\n+            x += fooArr[i * 10000000].iFld;\n+\n+            if (iFld2 == 4) {\n+                return;\n+            }\n+\n+            if (i > 0 && iFld2 == 3) {\n+                iFld2 = 42;\n+                return;\n+            }\n+\n+            if (i > 1 && iFld2 == 2) {\n+                return;\n+            }\n+        }\n+    }\n+\n@@ -1334,1 +1412,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/assertion\/TestAssertionPredicates.java","additions":88,"deletions":11,"binary":false,"changes":99,"status":"modified"}]}