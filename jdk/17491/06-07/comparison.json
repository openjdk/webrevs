{"files":[{"patch":"@@ -4158,1 +4158,1 @@\n-     * and unicode escape sequences translated as if in a string literal.\n+     * and unicode escapes translated as if in a string literal.\n@@ -4160,1 +4160,1 @@\n-     * Escape sequences are translated as follows;\n+     * Escapes are translated as follows;\n@@ -4227,1 +4227,1 @@\n-     *     <th scope=\"row\">{@code \\u005CuXXXX}<\/th>\n+     *     <th scope=\"row\">{@code \\u005Cu...uXXXX}<\/th>\n@@ -4229,1 +4229,1 @@\n-     *     <td>unicode equivalent<\/td>\n+     *     <td>single character UTF-16 equivalent<\/td>\n@@ -4236,1 +4236,1 @@\n-     * @return String with escape sequences translated.\n+     * @return String with escape sequences and unicode escapes translated.\n@@ -4238,0 +4238,6 @@\n+     * @implNote Normally, unicode escapes are translated by the compiler before string\n+     * literals are translated. However, as a convenience for use with constructed\n+     * strings, this method also translates unicode escapes. For example, this\n+     * method could be used when ASCII encoded text files need to maintain unicode\n+     * content.\n+     * \n@@ -4275,0 +4281,3 @@\n+                    while (from < length && chars[from] == 'u') {\n+                        from++;\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+        verifyEscape(\"\\\\uuuuu2022\", \"\\uuuuu2022\");\n","filename":"test\/jdk\/java\/lang\/String\/TranslateEscapes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}