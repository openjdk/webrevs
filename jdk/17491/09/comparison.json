{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4158,1 +4158,1 @@\n-     * translated as if in a string literal.\n+     * and unicode escapes translated as if in a string literal.\n@@ -4160,1 +4160,1 @@\n-     * Escape sequences are translated as follows;\n+     * Escapes are translated as follows;\n@@ -4226,0 +4226,5 @@\n+     *   <tr>\n+     *     <th scope=\"row\">{@code \\u005Cu...uXXXX}<\/th>\n+     *     <td>unicode escape<\/td>\n+     *     <td>single UTF-16 code unit equivalent<\/td>\n+     *   <\/tr>\n@@ -4229,5 +4234,0 @@\n-     * @implNote\n-     * This method does <em>not<\/em> translate Unicode escapes such as \"{@code \\u005cu2022}\".\n-     * Unicode escapes are translated by the Java compiler when reading input characters and\n-     * are not part of the string literal specification.\n-     *\n@@ -4236,1 +4236,10 @@\n-     * @return String with escape sequences translated.\n+     * @return String with escape sequences and unicode escapes translated.\n+     *\n+     * @implNote Unicode escapes are translated by the compiler before string\n+     * literals are translated. As a convenience for use with constructed\n+     * strings, this method also translates unicode escapes. For example, this\n+     * method could be used when ASCII encoded text files need to maintain unicode\n+     * content. The translation is done in a single pass and is non-recursive. That is,\n+     * escape sequences and unicode escapes are translated as encountered in one pass and\n+     * <strong>not<\/strong> done as an unicode escapes pass followed by an escape sequences\n+     * pass.\n@@ -4239,0 +4248,1 @@\n+     * @jls 3.3 Unicode Escapes\n@@ -4273,0 +4283,15 @@\n+                case 'u':\n+                    while (from < length && chars[from] == 'u') {\n+                        from++;\n+                    }\n+                    if (from <= length - 4) {\n+                        from += 4;\n+                        try {\n+                            ch = (char) Integer.parseInt(this, from - 4, from, 16);\n+                        } catch (NumberFormatException ex) {\n+                            throw new IllegalArgumentException(\"Invalid unicode sequence: \" + substring(from - 4, from));\n+                        }\n+                    } else {\n+                        throw new IllegalArgumentException(\"Invalid unicode sequence: \" + substring(from));\n+                    }\n+                    break;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":34,"deletions":9,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8223780\n+ * @bug 8223780 8263261\n@@ -38,0 +38,1 @@\n+        test5();\n@@ -89,0 +90,16 @@\n+    \/*\n+     * Unicode escapes.\n+     *\/\n+    static void test5() {\n+        verifyUnicodeEscape(\"\\\\u0000\", \"\\u0000\");\n+        verifyUnicodeEscape(\"\\\\u2022\", \"\\u2022\");\n+        verifyUnicodeEscape(\"\\\\ud83c\\\\udf09\", \"\\ud83c\\udf09\");\n+        verifyUnicodeEscape(\"\\\\uuuuu2022\", \"\\uuuuu2022\");\n+\n+        verifyIllegalUnicodeEscape(\"\\\\u000x\");\n+        verifyIllegalUnicodeEscape(\"\\\\u000\");\n+        verifyIllegalUnicodeEscape(\"\\\\u00\");\n+        verifyIllegalUnicodeEscape(\"\\\\u0\");\n+        verifyIllegalUnicodeEscape(\"\\\\u\");\n+    }\n+\n@@ -92,1 +109,1 @@\n-            System.err.format(\"\\\"%s\\\" not escape \\\"%s\\\"'%n\", string, escapes);\n+            System.err.format(\"\\\"%s\\\" does not escape \\\"%s\\\"'%n\", string, escapes);\n@@ -97,0 +114,23 @@\n+    static void verifyEscape(String string1, String string2) {\n+        if (!string1.translateEscapes().equals(string2)) {\n+            System.err.format(\"\\\"%s\\\" does not escape \\\"%s\\\"%n\", string1, string2);\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    static void verifyUnicodeEscape(String string1, String string2) {\n+        if (!string1.translateEscapes().equals(string2)) {\n+            System.err.format(\"\\\"%s\\\" does not unicode escape \\\"%s\\\"%n\", string1, string2);\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    static void verifyIllegalUnicodeEscape(String string) {\n+        try {\n+            string.translateEscapes();\n+            System.err.format(\"\\\"%s\\\" should be an error%n\", string);\n+            throw new RuntimeException();\n+        } catch (IllegalArgumentException ex) {\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/String\/TranslateEscapes.java","additions":43,"deletions":3,"binary":false,"changes":46,"status":"modified"}]}