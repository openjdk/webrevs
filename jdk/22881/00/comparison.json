{"files":[{"patch":"@@ -297,0 +297,2 @@\n+    RLWNM_OPCODE  = (23u << OPCODE_SHIFT),\n+\n@@ -427,0 +429,3 @@\n+    RLDCL_OPCODE  = (30u << OPCODE_SHIFT |   8u << 1),\n+    RLDCR_OPCODE  = (30u << OPCODE_SHIFT |   9u << 1),\n+\n@@ -1699,0 +1704,8 @@\n+  \/\/ Rotate variable\n+  inline void rlwnm( Register a, Register s, Register b, int mb, int me);\n+  inline void rlwnm_(Register a, Register s, Register b, int mb, int me);\n+  inline void rldcl( Register a, Register s, Register b, int mb);\n+  inline void rldcl_(Register a, Register s, Register b, int mb);\n+  inline void rldcr( Register a, Register s, Register b, int me);\n+  inline void rldcr_(Register a, Register s, Register b, int me);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -339,0 +339,7 @@\n+inline void Assembler::rlwnm( Register a, Register s, Register b, int mb, int me) { emit_int32(RLWNM_OPCODE | rta(a) | rs(s) | rb(b) | mb2125(mb) | me2630(me) | rc(0)); }\n+inline void Assembler::rlwnm_(Register a, Register s, Register b, int mb, int me) { emit_int32(RLWNM_OPCODE | rta(a) | rs(s) | rb(b) | mb2125(mb) | me2630(me) | rc(1)); }\n+inline void Assembler::rldcl(  Register a, Register s, Register b, int mb)        { emit_int32(RLDCL_OPCODE | rta(a) | rs(s) | rb(b) | mb2126(mb) | rc(0)); }\n+inline void Assembler::rldcl_( Register a, Register s, Register b, int mb)        { emit_int32(RLDCL_OPCODE | rta(a) | rs(s) | rb(b) | mb2126(mb) | rc(1)); }\n+inline void Assembler::rldcr(  Register a, Register s, Register b, int me)        { emit_int32(RLDCR_OPCODE | rta(a) | rs(s) | rb(b) | me2126(me) | rc(0)); }\n+inline void Assembler::rldcr_( Register a, Register s, Register b, int me)        { emit_int32(RLDCR_OPCODE | rta(a) | rs(s) | rb(b) | me2126(me) | rc(1)); }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -606,4 +606,3 @@\n-                       temp1_reg = R6,\n-                       temp2_reg = R0;\n-        __ check_klass_subtype_slow_path(sub_klass, super_klass, temp1_reg, temp2_reg); \/\/ returns with CR0.eq if successful\n-        __ crandc(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ failed: CR0.ne\n+                       temp1_reg = R6;\n+        __ check_klass_subtype_slow_path(sub_klass, super_klass, temp1_reg, noreg); \/\/ may return with CR0.eq if successful\n+        \/\/ Otherwise, result is in CR0.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2110,6 +2110,6 @@\n-void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n-                                                   Register super_klass,\n-                                                   Register temp1_reg,\n-                                                   Register temp2_reg,\n-                                                   Label* L_success,\n-                                                   Register result_reg) {\n+void MacroAssembler::check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                                          Register super_klass,\n+                                                          Register temp1_reg,\n+                                                          Register temp2_reg,\n+                                                          Label* L_success,\n+                                                          Register result_reg) {\n@@ -2157,0 +2157,90 @@\n+  if (L_success != nullptr && result_reg == noreg) {\n+    crandc(CCR0, Assembler::equal, CCR0, Assembler::equal); \/\/ failed: CR0.ne\n+  }\n+}\n+\n+Register MacroAssembler::allocate_if_noreg(Register r,\n+                                  RegSetIterator<Register> &available_regs,\n+                                  RegSet &regs_to_push) {\n+  if (!r->is_valid()) {\n+    r = *available_regs++;\n+    regs_to_push += r;\n+  }\n+  return r;\n+}\n+\n+void MacroAssembler::push_set(RegSet set)\n+{\n+  int spill_offset = 0;\n+  for (RegSetIterator<Register> it = set.begin(); *it != noreg; ++it) {\n+    spill_offset += wordSize;\n+    std(*it, -spill_offset, R1_SP);\n+  }\n+}\n+\n+void MacroAssembler::pop_set(RegSet set)\n+{\n+  int spill_offset = 0;\n+  for (RegSetIterator<Register> it = set.begin(); *it != noreg; ++it) {\n+    spill_offset += wordSize;\n+    ld(*it, -spill_offset, R1_SP);\n+  }\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path_table(Register sub_klass,\n+                                                         Register super_klass,\n+                                                         Register temp1_reg,\n+                                                         Register temp2_reg,\n+                                                         Label* L_success,\n+                                                         Register result_reg) {\n+  RegSet temps = RegSet::of(temp1_reg, temp2_reg);\n+\n+  assert_different_registers(sub_klass, super_klass, temp1_reg, temp2_reg, result_reg, R0);\n+\n+  Register temp3_reg = noreg, temp4_reg = noreg;\n+  bool result_reg_provided = (result_reg != noreg); \/\/ otherwise, result will be in CR0\n+\n+  BLOCK_COMMENT(\"check_klass_subtype_slow_path_table\");\n+\n+  RegSetIterator<Register> available_regs\n+    = (RegSet::range(R2, R12) - temps - sub_klass - super_klass).begin();\n+\n+  RegSet pushed_regs;\n+\n+  temp1_reg = allocate_if_noreg(temp1_reg, available_regs, pushed_regs);\n+  temp2_reg = allocate_if_noreg(temp2_reg, available_regs, pushed_regs);\n+  temp3_reg = allocate_if_noreg(temp3_reg, available_regs, pushed_regs);\n+  temp4_reg = allocate_if_noreg(temp4_reg, available_regs, pushed_regs);\n+  result_reg = allocate_if_noreg(result_reg, available_regs, pushed_regs);\n+\n+  push_set(pushed_regs);\n+\n+  lookup_secondary_supers_table_var(sub_klass, super_klass,\n+                                    temp1_reg, temp2_reg, temp3_reg, temp4_reg,\n+                                    result_reg);\n+\n+  if (L_success != nullptr || !result_reg_provided) {\n+    \/\/ result_reg may get overwritten by pop_set\n+    cmpdi(CCR0, result_reg, 0);\n+  }\n+\n+  \/\/ Unspill the temp. registers:\n+  pop_set(pushed_regs);\n+\n+  if (L_success != nullptr) {\n+    beq(CCR0, *L_success);\n+  }\n+}\n+\n+void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,\n+                                                   Register super_klass,\n+                                                   Register temp1_reg,\n+                                                   Register temp2_reg,\n+                                                   Label* L_success,\n+                                                   Register result_reg) {\n+  if (UseSecondarySupersTable) {\n+    check_klass_subtype_slow_path_table(sub_klass, super_klass, temp1_reg, temp2_reg, L_success, result_reg);\n+  } else {\n+    if (temp2_reg == noreg) temp2_reg = R0;\n+    check_klass_subtype_slow_path_linear(sub_klass, super_klass, temp1_reg, temp2_reg, L_success, result_reg);\n+  }\n@@ -2211,8 +2301,8 @@\n-void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n-                                                   Register r_super_klass,\n-                                                   Register temp1,\n-                                                   Register temp2,\n-                                                   Register temp3,\n-                                                   Register temp4,\n-                                                   Register result,\n-                                                   u1 super_klass_slot) {\n+void MacroAssembler::lookup_secondary_supers_table_const(Register r_sub_klass,\n+                                                         Register r_super_klass,\n+                                                         Register temp1,\n+                                                         Register temp2,\n+                                                         Register temp3,\n+                                                         Register temp4,\n+                                                         Register result,\n+                                                         u1 super_klass_slot) {\n@@ -2223,1 +2313,1 @@\n-  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table_const {\");\n@@ -2231,1 +2321,1 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS; \/\/ Required for stub call below.\n@@ -2293,1 +2383,84 @@\n-  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table_const\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                  temp1, temp2, temp3);\n+  }\n+}\n+\n+\/\/ At runtime, return 0 in result if r_super_klass is a superclass of\n+\/\/ r_sub_klass, otherwise return nonzero. Use this version of\n+\/\/ lookup_secondary_supers_table() if you don't know ahead of time\n+\/\/ which superclass will be searched for. Used by interpreter and\n+\/\/ runtime stubs. It is larger and has somewhat greater latency than\n+\/\/ the version above, which takes a constant super_klass_slot.\n+void MacroAssembler::lookup_secondary_supers_table_var(Register r_sub_klass,\n+                                                       Register r_super_klass,\n+                                                       Register temp1,\n+                                                       Register temp2,\n+                                                       Register temp3,\n+                                                       Register temp4,\n+                                                       Register result) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, temp3, temp4, result, R0);\n+\n+  Label L_done;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table_var {\");\n+\n+  const Register\n+    r_array_base   = temp1,\n+    slot           = temp2,\n+    r_array_index  = temp3,\n+    r_bitmap       = temp4;\n+\n+  lbz(slot, in_bytes(Klass::hash_slot_offset()), r_super_klass);\n+  ld(r_bitmap, in_bytes(Klass::secondary_supers_bitmap_offset()), r_sub_klass);\n+\n+  li(result, 1); \/\/ Make sure that result is nonzero if the test below misses.\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  xori(R0, slot, Klass::SECONDARY_SUPERS_TABLE_SIZE - 1); \/\/ slot ^ 63 === 63 - slot (mod 64)\n+  sld_(r_array_index, r_bitmap, R0); \/\/ shift left by 63-slot\n+\n+  \/\/ We test the MSB of r_array_index, i.e. its sign bit\n+  bge(CCR0, L_done);\n+\n+  \/\/ We will consult the secondary-super array.\n+  ld(r_array_base, in_bytes(Klass::secondary_supers_offset()), r_sub_klass);\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  popcntd(r_array_index, r_array_index);\n+\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+  sldi(r_array_index, r_array_index, LogBytesPerWord); \/\/ scale\n+\n+  ldx(R0, r_array_base, r_array_index);\n+  xor_(result, R0, r_super_klass);\n+  beq(CCR0, L_done); \/\/ found a match, result is 0 in this case\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 1.\n+  neg(R0, slot); \/\/ rotate right\n+  rldcl(r_bitmap, r_bitmap, R0, 0);\n+  Register temp = slot;\n+  andi_(temp, r_bitmap, 2);\n+  beq(CCR0, L_done); \/\/ fail (result != 0)\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the logic we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index,\n+                                          r_bitmap, result, temp);\n+  \/\/ return whatever we got from slow path\n+\n+  bind(L_done);\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table_var\");\n@@ -2316,2 +2489,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n-\n@@ -2408,2 +2579,0 @@\n-  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n-\n@@ -2436,7 +2605,11 @@\n-  assert_different_registers(R3_ARG1, r_sub_klass, linear_result, result);\n-  mr_if_needed(R3_ARG1, r_super_klass);\n-  assert_different_registers(R4_ARG2, linear_result, result);\n-  mr_if_needed(R4_ARG2, r_sub_klass);\n-  assert_different_registers(R5_ARG3, result);\n-  neg(R5_ARG3, linear_result);\n-  neg(R6_ARG4, result);\n+  \/\/ report fatal error and terminate VM\n+\n+  \/\/ Argument shuffle. Using stack to avoid clashes.\n+  std(r_super_klass, -8, R1_SP);\n+  std(r_sub_klass, -16, R1_SP);\n+  std(linear_result, -24, R1_SP);\n+  mr_if_needed(R6_ARG4, result);\n+  ld(R3_ARG1, -8, R1_SP);\n+  ld(R4_ARG2, -16, R1_SP);\n+  ld(R5_ARG3, -24, R1_SP);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":201,"deletions":28,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -615,0 +615,14 @@\n+  void check_klass_subtype_slow_path_linear(Register sub_klass,\n+                                            Register super_klass,\n+                                            Register temp1_reg,\n+                                            Register temp2_reg,\n+                                            Label* L_success = nullptr,\n+                                            Register result_reg = noreg);\n+\n+  void check_klass_subtype_slow_path_table(Register sub_klass,\n+                                           Register super_klass,\n+                                           Register temp1_reg,\n+                                           Register temp2_reg,\n+                                           Label* L_success = nullptr,\n+                                           Register result_reg = noreg);\n+\n@@ -622,0 +636,19 @@\n+  void lookup_secondary_supers_table_var(Register sub_klass,\n+                                         Register r_super_klass,\n+                                         Register temp1,\n+                                         Register temp2,\n+                                         Register temp3,\n+                                         Register temp4,\n+                                         Register result);\n+\n+  \/\/ If r is valid, return r.\n+  \/\/ If r is invalid, remove a register r2 from available_regs, add r2\n+  \/\/ to regs_to_push, then return r2.\n+  Register allocate_if_noreg(const Register r,\n+                             RegSetIterator<Register> &available_regs,\n+                             RegSet &regs_to_push);\n+\n+  \/\/ Frameless register spills (negative offset from SP)\n+  void push_set(RegSet set);\n+  void pop_set(RegSet set);\n+\n@@ -634,8 +667,8 @@\n-  void lookup_secondary_supers_table(Register r_sub_klass,\n-                                     Register r_super_klass,\n-                                     Register temp1,\n-                                     Register temp2,\n-                                     Register temp3,\n-                                     Register temp4,\n-                                     Register result,\n-                                     u1 super_klass_slot);\n+  void lookup_secondary_supers_table_const(Register r_sub_klass,\n+                                           Register r_super_klass,\n+                                           Register temp1,\n+                                           Register temp2,\n+                                           Register temp3,\n+                                           Register temp4,\n+                                           Register result,\n+                                           u1 super_klass_slot);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":41,"deletions":8,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -12072,0 +12072,1 @@\n+  predicate(!UseSecondarySupersTable);\n@@ -12083,0 +12084,24 @@\n+\/\/ Two versions of partialSubtypeCheck, both used when we need to\n+\/\/ search for a super class in the secondary supers array. The first\n+\/\/ is used when we don't know _a priori_ the class being searched\n+\/\/ for. The second, far more common, is used when we do know: this is\n+\/\/ used for instanceof, checkcast, and any case where C2 can determine\n+\/\/ it by constant propagation.\n+instruct partialSubtypeCheckVarSuper(iRegPsrc sub, iRegPsrc super, iRegPdst result,\n+                                     iRegPdst tempR1, iRegPdst tempR2, iRegPdst tempR3, iRegPdst tempR4,\n+                                     flagsRegCR0 cr0, regCTR ctr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub super));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr0, KILL ctr, TEMP_DEF result, TEMP tempR1, TEMP tempR2, TEMP tempR3, TEMP tempR4);\n+\n+  ins_cost(DEFAULT_COST * 10);  \/\/ slightly larger than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, $super\" %}\n+  ins_encode %{\n+    __ lookup_secondary_supers_table_var($sub$$Register, $super$$Register,\n+                                         $tempR1$$Register, $tempR2$$Register, $tempR3$$Register, $tempR4$$Register,\n+                                         $result$$Register);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -12097,3 +12122,3 @@\n-      __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register,\n-                                       $tempR1$$Register, $tempR2$$Register, $tempR3$$Register, $tempR4$$Register,\n-                                       $result$$Register, super_klass_slot);\n+      __ lookup_secondary_supers_table_const($sub$$Register, $super_reg$$Register,\n+                                             $tempR1$$Register, $tempR2$$Register, $tempR3$$Register, $tempR4$$Register,\n+                                             $result$$Register, super_klass_slot);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2042,1 +2042,2 @@\n-                           Register temp,\n+                           Register temp1,\n+                           Register temp2,\n@@ -2050,1 +2051,1 @@\n-    __ check_klass_subtype_fast_path(sub_klass, super_klass, temp, R0, &L_success, &L_miss, nullptr,\n+    __ check_klass_subtype_fast_path(sub_klass, super_klass, temp1, temp2, &L_success, &L_miss, nullptr,\n@@ -2052,1 +2053,1 @@\n-    __ check_klass_subtype_slow_path(sub_klass, super_klass, temp, R0, &L_success);\n+    __ check_klass_subtype_slow_path(sub_klass, super_klass, temp1, temp2, &L_success);\n@@ -2082,2 +2083,1 @@\n-\n-    const Register R2_minus1 = R2;\n+    const Register R2_tmp    = R2;\n@@ -2121,1 +2121,0 @@\n-    __ li(R2_minus1, -1);\n@@ -2149,1 +2148,1 @@\n-    __ add_(R9_remain, R2_minus1, R9_remain);     \/\/ Decrement the count.\n+    __ addic_(R9_remain, R9_remain, -1);          \/\/ Decrement the count.\n@@ -2169,1 +2168,1 @@\n-    generate_type_check(R11_klass, R6_ckoff, R7_ckval, R12_tmp,\n+    generate_type_check(R11_klass, R6_ckoff, R7_ckval, R12_tmp, R2_tmp,\n@@ -2503,1 +2502,1 @@\n-                          temp, L_disjoint_plain_copy);\n+                          temp, \/* temp *\/ R10_ARG8, L_disjoint_plain_copy);\n@@ -4461,3 +4460,3 @@\n-    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n-                                     r_array_base, r_array_length, r_array_index,\n-                                     r_bitmap, result, super_klass_index);\n+    __ lookup_secondary_supers_table_const(r_sub_klass, r_super_klass,\n+                                           r_array_base, r_array_length, r_array_index,\n+                                           r_bitmap, result, super_klass_index);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"}]}