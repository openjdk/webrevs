{"files":[{"patch":"@@ -1006,1 +1006,5 @@\n-  ShenandoahHeapLocker locker(lock());\n+  \/\/ If we are dealing with mutator allocation, then we may need to block for safepoint.\n+  \/\/ We cannot block for safepoint for GC allocations, because there is a high chance\n+  \/\/ we are already running at safepoint or from stack watermark machinery, and we cannot\n+  \/\/ block again.\n+  ShenandoahHeapLocker locker(lock(), req.is_mutator_alloc());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -34,0 +35,48 @@\n+\/\/ These are inline variants of Thread::SpinAcquire with optional blocking in VM.\n+\/\/ Unfortunately, there is no good way to do a conditional RAII object in the\n+\/\/ middle of the method without dealing with macros.\n+\n+void ShenandoahLock::contended_lock(bool allow_block_for_safepoint) {\n+  Thread* thread = Thread::current();\n+  if (allow_block_for_safepoint && thread->is_Java_thread()) {\n+    contended_lock_or_block(JavaThread::cast(thread));\n+  } else {\n+    contended_lock_no_block();\n+  }\n+}\n+\n+void ShenandoahLock::contended_lock_no_block() {\n+  int ctr = 0;\n+  int yields = 0;\n+  while (Atomic::cmpxchg(&_state, 0, 1) != 0) {\n+    if ((++ctr & 0xFFF) == 0) {\n+      if (yields > 5) {\n+        os::naked_short_sleep(1);\n+      } else {\n+        os::naked_yield();\n+        yields++;\n+      }\n+    } else {\n+      SpinPause();\n+    }\n+  }\n+}\n+\n+void ShenandoahLock::contended_lock_or_block(JavaThread* java_thread) {\n+  int ctr = 0;\n+  int yields = 0;\n+  while (Atomic::cmpxchg(&_state, 0, 1) != 0) {\n+    if ((++ctr & 0xFFF) == 0) {\n+      ThreadBlockInVM tbivm(java_thread);\n+      if (yields > 5) {\n+        os::naked_short_sleep(1);\n+      } else {\n+        os::naked_yield();\n+        yields++;\n+      }\n+    } else {\n+      SpinPause();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-  enum LockState { unlocked = 0, locked = 1 };\n-\n@@ -43,0 +41,3 @@\n+  void contended_lock_or_block(JavaThread* java_thread);\n+  void contended_lock_no_block();\n+\n@@ -44,1 +45,1 @@\n-  ShenandoahLock() : _state(unlocked), _owner(nullptr) {};\n+  ShenandoahLock() : _state(0), _owner(nullptr) {};\n@@ -46,2 +47,1 @@\n-  void lock() {\n-#ifdef ASSERT\n+  void lock(bool allow_block_for_safepoint) {\n@@ -49,4 +49,7 @@\n-#endif\n-    Thread::SpinAcquire(&_state, \"Shenandoah Heap Lock\");\n-#ifdef ASSERT\n-    assert(_state == locked, \"must be locked\");\n+\n+    \/\/ Try to lock fast, or dive into contended lock handling.\n+    if (Atomic::cmpxchg(&_state, 0, 1) != 0) {\n+      contended_lock(allow_block_for_safepoint);\n+    }\n+\n+    assert(_state == 1, \"must be locked\");\n@@ -54,2 +57,1 @@\n-    _owner = Thread::current();\n-#endif\n+    DEBUG_ONLY(_owner = Thread::current();)\n@@ -59,5 +61,4 @@\n-#ifdef ASSERT\n-    assert (_owner == Thread::current(), \"sanity\");\n-    _owner = nullptr;\n-#endif\n-    Thread::SpinRelease(&_state);\n+    assert(_owner == Thread::current(), \"sanity\");\n+    DEBUG_ONLY(_owner = nullptr;)\n+    OrderAccess::fence();\n+    Atomic::store(&_state, 0);\n@@ -66,0 +67,2 @@\n+  void contended_lock(bool allow_block_for_safepoint);\n+\n@@ -68,1 +71,1 @@\n-    return _state == locked && _owner == Thread::current();\n+    return _state == 1 && _owner == Thread::current();\n@@ -80,1 +83,1 @@\n-  ShenandoahLocker(ShenandoahLock* lock) : _lock(lock) {\n+  ShenandoahLocker(ShenandoahLock* lock, bool allow_block_for_safepoint = false) : _lock(lock) {\n@@ -82,1 +85,1 @@\n-      _lock->lock();\n+      _lock->lock(allow_block_for_safepoint);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahLock.hpp","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"}]}