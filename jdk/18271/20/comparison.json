{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -28,2 +29,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.misc\n@@ -35,1 +35,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -37,0 +36,5 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -38,4 +42,3 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -45,0 +48,4 @@\n+    private static final ClassDesc CD_System = ClassDesc.of(\"java.lang.System\");\n+    private static final ClassDesc CD_PrintStream = ClassDesc.of(\"java.io.PrintStream\");\n+    private static final ClassDesc CD_MethodHandle = ClassDesc.of(\"java.lang.invoke.MethodHandle\");\n+\n@@ -46,61 +53,41 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(52, ACC_PUBLIC | ACC_SUPER, \"BadInterfaceMethodref\", null, \"java\/lang\/Object\", null);\n-        Handle handle1 =\n-            new Handle(Opcodes.H_INVOKEINTERFACE, \"BadInterfaceMethodref\", \"m\", \"()V\", true);\n-        Handle handle2 =\n-            new Handle(Opcodes.H_INVOKEINTERFACE, \"BadInterfaceMethodref\", \"staticM\", \"()V\", true);\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-            mv.visitLdcInsn(\"hello from m\");\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false\/*intf*\/);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(3, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"staticM\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-            mv.visitLdcInsn(\"hello from staticM\");\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false\/*intf*\/);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(3, 1);\n-            mv.visitEnd();\n-        }\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"runm\", \"()V\", null, null);\n-            mv.visitCode();\n-            \/\/ REF_invokeStatic\n-            mv.visitLdcInsn(handle1);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invoke\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"runStaticM\", \"()V\", null, null);\n-            mv.visitCode();\n-            \/\/ REF_invokeStatic\n-            mv.visitLdcInsn(handle2);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invoke\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+\n+        DirectMethodHandleDesc handle_1 = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL,\n+                ClassDesc.of(\"BadInterfaceMethodref\"), \"m\", \"()V\");\n+\n+        DirectMethodHandleDesc handle_2 = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL,\n+                ClassDesc.of(\"BadInterfaceMethodref\"), \"staticM\", \"()V\");\n+\n+        return ClassFile.of().build(ClassDesc.of(\"BadInterfaceMethodref\"),\n+                    clb -> clb\n+                            .withVersion(JAVA_8_VERSION, 0)\n+                            .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                            .withSuperclass(CD_Object)\n+                            .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .aload(0)\n+                                            .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                            .return_())\n+                            .withMethodBody(\"m\", MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .getstatic(CD_System, \"out\", CD_PrintStream)\n+                                            .ldc(\"hello from m\")\n+                                            .invokevirtual(CD_PrintStream, \"println\", MethodTypeDesc.of(CD_void, CD_String))\n+                                            .return_())\n+                            .withMethodBody(\"staticM\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .getstatic(CD_System, \"out\", CD_PrintStream)\n+                                            .ldc(\"hello from staticM\")\n+                                            .invokevirtual(CD_PrintStream, \"println\", MethodTypeDesc.of(CD_void, CD_String))\n+                                            .return_())\n+                            .withMethodBody(\"runm\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .ldc(handle_1)\n+                                            .invokevirtual(CD_MethodHandle, \"invoke\", MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+                            .withMethodBody(\"runStaticM\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .ldc(handle_2)\n+                                            .invokevirtual(CD_MethodHandle, \"invoke\", MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+\n+        );\n@@ -110,24 +97,19 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(52, ACC_PUBLIC | ACC_ABSTRACT | ACC_INTERFACE, \"IBad\", null, \"java\/lang\/Object\", null);\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-            mv.visitLdcInsn(\"hello from m\");\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false\/*intf*\/);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(3, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"staticM\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-            mv.visitLdcInsn(\"hello from staticM\");\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false\/*intf*\/);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(3, 1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+\n+        return ClassFile.of().build(ClassDesc.of(\"IBad\"),\n+                    clb -> clb\n+                            .withVersion(JAVA_8_VERSION, 0)\n+                            .withFlags(ACC_PUBLIC | ACC_ABSTRACT | ACC_INTERFACE)\n+                            .withSuperclass(CD_Object)\n+                            .withMethodBody(\"m\", MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .getstatic(CD_System, \"out\", CD_PrintStream)\n+                                            .ldc(\"hello from m\")\n+                                            .invokevirtual(CD_PrintStream, \"println\", MethodTypeDesc.of(CD_void, CD_String))\n+                                            .return_())\n+                            .withMethodBody(\"staticM\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .getstatic(CD_System, \"out\", CD_PrintStream)\n+                                            .ldc(\"hello from staticM\")\n+                                            .invokevirtual(CD_PrintStream, \"println\", MethodTypeDesc.of(CD_void, CD_String))\n+                                            .return_())\n+        );\n@@ -137,41 +119,29 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(52, ACC_PUBLIC | ACC_SUPER,  \"BadMethodref\", null, \"java\/lang\/Object\", new String[]{\"IBad\"});\n-        Handle handle1 =\n-            new Handle(Opcodes.H_INVOKEINTERFACE, \"BadMethodref\", \"m\", \"()V\", true);\n-        Handle handle2 =\n-            new Handle(Opcodes.H_INVOKEINTERFACE, \"BadMethodref\", \"staticM\", \"()V\", true);\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"runm\", \"()V\", null, null);\n-            mv.visitCode();\n-            \/\/ REF_invokeStatic\n-            mv.visitLdcInsn(handle1);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invoke\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"runStaticM\", \"()V\", null, null);\n-            mv.visitCode();\n-            \/\/ REF_invokeStatic\n-            mv.visitLdcInsn(handle2);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invoke\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+\n+\n+        DirectMethodHandleDesc handle_1 = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL,\n+                ClassDesc.of(\"BadMethodref\"), \"m\", \"()V\");\n+        DirectMethodHandleDesc handle_2 = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL,\n+                ClassDesc.of(\"BadMethodref\"), \"staticM\", \"()V\");\n+\n+        return ClassFile.of().build(ClassDesc.of(\"BadMethodref\"),\n+                    clb -> clb\n+                            .withVersion(JAVA_8_VERSION, 0)\n+                            .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                            .withSuperclass(CD_Object)\n+                            .withInterfaceSymbols(ClassDesc.of(\"IBad\"))\n+                            .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .aload(0)\n+                                            .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                            .return_())\n+                            .withMethodBody(\"runm\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .ldc(handle_1)\n+                                            .invokevirtual(CD_MethodHandle, \"invoke\", MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+                            .withMethodBody(\"runStaticM\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .ldc(handle_2)\n+                                            .invokevirtual(CD_MethodHandle, \"invoke\", MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+        );\n@@ -181,27 +151,21 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(52, ACC_PUBLIC | ACC_SUPER,  \"InvokeBasicref\", null, \"java\/lang\/Object\", null);\n-        Handle handle =\n-                new Handle(Opcodes.H_INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeBasic\", \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"runInvokeBasicM\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitLdcInsn(handle);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invoke\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+\n+        DirectMethodHandleDesc handle = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.VIRTUAL,\n+                CD_MethodHandle, \"invokeBasic\", \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n+\n+        return ClassFile.of().build(ClassDesc.of(\"InvokeBasicref\"),\n+                    clb -> clb\n+                            .withVersion(JAVA_8_VERSION, 0)\n+                            .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                            .withSuperclass(CD_Object)\n+                            .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .aload(0)\n+                                            .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                            .return_())\n+                            .withMethodBody(\"runInvokeBasicM\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .ldc(handle)\n+                                            .invokevirtual(CD_MethodHandle, \"invoke\", MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+        );\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/ConstantPool\/BadMethodHandles.java","additions":125,"deletions":161,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -28,2 +29,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.misc\n@@ -38,1 +38,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -40,0 +39,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n@@ -41,1 +43,3 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -45,37 +49,31 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(52, ACC_PUBLIC | ACC_SUPER, \"C\", null, \"java\/lang\/Object\", new String[]{\"I\"});\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"testSpecialIntf\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"I\", \"f1\", \"()V\", \/*itf=*\/false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"testStaticIntf\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitMethodInsn(INVOKESTATIC, \"I\", \"f2\", \"()V\", \/*itf=*\/false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"testSpecialClass\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"C\", \"f1\", \"()V\", \/*itf=*\/true);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n+        return ClassFile.of(StackMapsOption.DROP_STACK_MAPS).build(ClassDesc.of(\"C\"),\n+                clb -> clb\n+                        .withVersion(JAVA_8_VERSION, 0)\n+                        .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                        .withSuperclass(CD_Object)\n+                        .withInterfaceSymbols(ClassDesc.of(\"I\"))\n+                        .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                cob -> cob\n+                                        .aload(0)\n+                                        .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                        .return_())\n+                        .withMethodBody(\"testSpecialIntf\", MTD_void, ACC_PUBLIC,\n+                                cob -> cob\n+                                        .aload(0)\n+                                        .invokespecial(ClassDesc.of(\"I\"), \"f1\", MTD_void)\n+                                        .return_())\n+                        .withMethodBody(\"testStaticIntf\", MTD_void, ACC_PUBLIC,\n+                                cob -> cob\n+                                        .invokestatic(ClassDesc.of(\"I\"), \"f2\", MTD_void)\n+                                        .return_())\n+                        .withMethodBody(\"testSpecialClass\", MTD_void, ACC_PUBLIC,\n+                                cob -> cob\n+                                        .aload(0)\n+                                        .invokespecial(ClassDesc.of(\"C\"), \"f1\", MTD_void, true)\n+                                        .return_())\n+                        .withMethodBody(\"f2\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                CodeBuilder::return_)\n+                        .withMethodBody(\"testStaticClass\", MTD_void, ACC_PUBLIC,\n+                                cob -> cob\n+                                        .invokestatic(ClassDesc.of(\"C\"), \"f2\", MTD_void, true)\n+                                        .return_())\n@@ -83,17 +81,1 @@\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"f2\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"testStaticClass\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitMethodInsn(INVOKESTATIC, \"C\", \"f2\", \"()V\", \/*itf=*\/true);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+                );\n@@ -103,18 +85,10 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(52, ACC_PUBLIC | ACC_ABSTRACT | ACC_INTERFACE, \"I\", null, \"java\/lang\/Object\", null);\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"f1\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"f2\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of().build(ClassDesc.of(\"I\"),\n+                clb -> clb\n+                        .withVersion(JAVA_8_VERSION, 0)\n+                        .withSuperclass(CD_Object)\n+                        .withFlags(ACC_PUBLIC | ACC_ABSTRACT | ACC_INTERFACE)\n+                        .withMethodBody(\"f1\", MTD_void, ACC_PUBLIC,\n+                                CodeBuilder::return_)\n+                        .withMethodBody(\"f2\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                CodeBuilder::return_)\n+        );\n@@ -153,1 +127,0 @@\n-                    continue;\n","filename":"test\/hotspot\/jtreg\/runtime\/ConstantPool\/IntfMethod.java","additions":51,"deletions":78,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -29,3 +30,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n- * @run driver LargeClassTest\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main LargeClassTest\n@@ -36,6 +36,5 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.FieldVisitor;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n@@ -45,1 +44,4 @@\n-public class LargeClassTest implements Opcodes {\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+public class LargeClassTest{\n@@ -56,6 +58,7 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        FieldVisitor fv;\n-        MethodVisitor mv;\n-        AnnotationVisitor av0;\n-\n-        cw.visit(55, ACC_PUBLIC + ACC_SUPER, \"Large\", null, \"java\/lang\/Object\", null);\n+        ClassDesc CD_Large = ClassDesc.of(\"Large\");\n+        ClassDesc CD_Random = ClassDesc.ofInternalName(\"java\/util\/Random\");\n+        ClassDesc CD_System = ClassDesc.ofInternalName(\"java\/lang\/System\");\n+        ClassDesc CD_PrintStream = ClassDesc.ofInternalName(\"java\/io\/PrintStream\");\n+        ClassDesc CD_Thread = ClassDesc.ofInternalName(\"java\/lang\/Thread\");\n+        ClassDesc CD_StackTraceElement = ClassDesc.ofInternalName(\"java\/lang\/StackTraceElement\");\n+        ClassDesc CD_Arrays = ClassDesc.ofInternalName(\"java\/util\/Arrays\");\n@@ -63,80 +66,29 @@\n-        {\n-          mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-          mv.visitCode();\n-          mv.visitVarInsn(ALOAD, 0);\n-          mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-          mv.visitInsn(RETURN);\n-          mv.visitMaxs(1, 1);\n-          mv.visitEnd();\n-        }\n-        {\n-          \/\/ public static void main(String[] args) {\n-          \/\/     Large large = new Large();\n-          \/\/     large.f_1(55);\n-          \/\/ }\n-          mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"main\", \"([Ljava\/lang\/String;)V\", null, null);\n-          mv.visitCode();\n-          mv.visitTypeInsn(NEW, \"Large\");\n-          mv.visitInsn(DUP);\n-          mv.visitMethodInsn(INVOKESPECIAL, \"Large\", \"<init>\", \"()V\", false);\n-          mv.visitVarInsn(ASTORE, 1);\n-          mv.visitVarInsn(ALOAD, 1);\n-          mv.visitIntInsn(BIPUSH, 55);\n-          mv.visitMethodInsn(INVOKEVIRTUAL, \"Large\", \"f_1\", \"(I)I\", false);\n-          mv.visitInsn(POP);\n-          mv.visitInsn(RETURN);\n-          mv.visitMaxs(2, 2);\n-          mv.visitEnd();\n-        }\n-\n-        \/\/ Write 33560 methods called f_$i\n-        for (int i = 1000; i < 34560; i++)\n-        {\n-          mv = cw.visitMethod(ACC_PUBLIC, \"f_\" + i, \"()V\", null, null);\n-          mv.visitCode();\n-          mv.visitInsn(RETURN);\n-          mv.visitMaxs(0, 1);\n-          mv.visitEnd();\n-        }\n-        {\n-          \/\/ public int f_1(int prior) {\n-          \/\/   int total = prior + new java.util.Random(1).nextInt();\n-          \/\/   return total + f_2(total);\n-          \/\/ }\n-          mv = cw.visitMethod(ACC_PUBLIC, \"f_1\", \"(I)I\", null, null);\n-          mv.visitCode();\n-          mv.visitVarInsn(ILOAD, 1);\n-          mv.visitTypeInsn(NEW, \"java\/util\/Random\");\n-          mv.visitInsn(DUP);\n-          mv.visitInsn(LCONST_1);\n-          mv.visitMethodInsn(INVOKESPECIAL, \"java\/util\/Random\", \"<init>\", \"(J)V\", false);\n-          mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/util\/Random\", \"nextInt\", \"()I\", false);\n-          mv.visitInsn(IADD);\n-          mv.visitVarInsn(ISTORE, 2);\n-          mv.visitVarInsn(ILOAD, 2);\n-          mv.visitVarInsn(ALOAD, 0);\n-          mv.visitVarInsn(ILOAD, 2);\n-          mv.visitMethodInsn(INVOKEVIRTUAL, \"Large\", \"f_2\", \"(I)I\", false);\n-          mv.visitInsn(IADD);\n-          mv.visitInsn(IRETURN);\n-          mv.visitMaxs(5, 3);\n-          mv.visitEnd();\n-        }\n-        {\n-          \/\/ public int f_2(int total) {\n-          \/\/   System.out.println(java.util.Arrays.toString(Thread.currentThread().getStackTrace()));\n-          \/\/   return 10;\n-          \/\/ }\n-          mv = cw.visitMethod(ACC_PUBLIC, \"f_2\", \"(I)I\", null, null);\n-          mv.visitCode();\n-          mv.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-          mv.visitMethodInsn(INVOKESTATIC, \"java\/lang\/Thread\", \"currentThread\", \"()Ljava\/lang\/Thread;\", false);\n-          mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/Thread\", \"getStackTrace\", \"()[Ljava\/lang\/StackTraceElement;\", false);\n-          mv.visitMethodInsn(INVOKESTATIC, \"java\/util\/Arrays\", \"toString\", \"([Ljava\/lang\/Object;)Ljava\/lang\/String;\", false);\n-          mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false);\n-          mv.visitIntInsn(BIPUSH, 10);\n-          mv.visitInsn(IRETURN);\n-          mv.visitMaxs(2, 2);\n-          mv.visitEnd();\n-        }\n-        cw.visitEnd();\n+        byte[] bytes = ClassFile.of().build(CD_Large,\n+                clb -> {\n+                    clb.withVersion(JAVA_11_VERSION, 0);\n+                            clb.withSuperclass(CD_Object);\n+                            clb.withFlags(ACC_PUBLIC | ACC_SUPER);\n+                            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .aload(0)\n+                                            .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                            .return_());\n+                    \/\/ public static void main(String[] args) {\n+                    \/\/     Large large = new Large();\n+                    \/\/     large.f_1(55);\n+                    \/\/ }\n+                    clb.withMethodBody(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()), ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .new_(CD_Large)\n+                                            .dup()\n+                                            .invokespecial(CD_Large, INIT_NAME, MTD_void)\n+                                            .astore(1)\n+                                            .aload(1)\n+                                            .bipush(55)\n+                                            .invokevirtual(CD_Large, \"f_1\", MethodTypeDesc.of(CD_int, CD_int))\n+                                            .pop()\n+                                            .return_());\n+                    \/\/ Write 34560 methods called f_$i\n+                    for (int i = 1000; i < 34560 ; i++) {\n+                        clb.withMethodBody(\"f_\" + i, MethodTypeDesc.of(CD_void), ACC_PUBLIC,\n+                                CodeBuilder::return_);\n@@ -144,0 +96,36 @@\n+                    }\n+                    \/\/ public int f_1(int prior) {\n+                    \/\/   int total = prior + new java.util.Random(1).nextInt();\n+                    \/\/   return total + f_2(total);\n+                    \/\/ }\n+                    clb.withMethodBody(\"f_1\", MethodTypeDesc.of(CD_int, CD_int), ACC_PUBLIC,\n+                            cob -> cob\n+                                    .iload(1)\n+                                    .new_(CD_Random)\n+                                    .dup()\n+                                    .lconst_1()\n+                                    .invokespecial(CD_Random, INIT_NAME, MethodTypeDesc.of(CD_void, CD_long))\n+                                    .invokevirtual(CD_Random, \"nextInt\", MethodTypeDesc.of(CD_int))\n+                                    .iadd()\n+                                    .istore(2)\n+                                    .iload(2)\n+                                    .aload(0)\n+                                    .iload(2)\n+                                    .invokevirtual(CD_Large, \"f_2\", MethodTypeDesc.of(CD_int, CD_int))\n+                                    .iadd()\n+                                    .ireturn());\n+                    \/\/ public int f_2(int total) {\n+                    \/\/   System.out.println(java.util.Arrays.toString(Thread.currentThread().getStackTrace()));\n+                    \/\/   return 10;\n+                    \/\/ }\n+                    clb.withMethodBody(\"f_2\", MethodTypeDesc.of(CD_int, CD_int), ACC_PUBLIC,\n+                            cob -> cob\n+                                    .getstatic(CD_System, \"out\", CD_PrintStream)\n+                                    .invokestatic(CD_Thread, \"currentThread\", MethodTypeDesc.of(CD_Thread))\n+                                    .invokevirtual(CD_Thread, \"getStackTrace\", MethodTypeDesc.of(CD_StackTraceElement.arrayType()))\n+                                    .invokestatic(CD_Arrays, \"toString\", MethodTypeDesc.of(CD_String, CD_Object.arrayType()))\n+                                    .invokevirtual(CD_PrintStream, \"println\", MethodTypeDesc.of(CD_void, CD_String))\n+                                    .bipush(10)\n+                                    .ireturn());\n+                }\n+        );\n@@ -145,1 +133,1 @@\n-          fos.write(cw.toByteArray());\n+          fos.write(bytes);\n","filename":"test\/hotspot\/jtreg\/runtime\/StackTrace\/LargeClassTest.java","additions":86,"deletions":98,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n@@ -32,0 +32,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -33,3 +36,3 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -54,1 +57,1 @@\n-    static class TestClassLoader extends ClassLoader implements Opcodes {\n+    static class TestClassLoader extends ClassLoader{\n@@ -69,2 +72,1 @@\n-            ClassWriter cw = new ClassWriter(0);\n-            MethodVisitor mv;\n+\n@@ -72,10 +74,13 @@\n-               case CLASS_NAME_A:\n-                    cw.visit(52, ACC_SUPER | ACC_PUBLIC, CLASS_NAME_A, null, \"java\/lang\/Object\", null);\n-                    {\n-                        mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-                        mv.visitCode();\n-                        mv.visitVarInsn(ALOAD, 0);\n-                        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\");\n-                        mv.visitInsn(RETURN);\n-                        mv.visitMaxs(1, 1);\n-                        mv.visitEnd();\n+                case CLASS_NAME_A:\n+                    return ClassFile.of().build(ClassDesc.of(CLASS_NAME_A),\n+                            clb -> clb.withVersion(JAVA_8_VERSION, 0)\n+                                    .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                                    .withSuperclass(CD_Object)\n+                                    .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                            cob -> cob\n+                                                    .aload(0)\n+                                                    .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                                    .return_())\n+                                    .withMethodBody(\"m\", MethodTypeDesc.of(CD_int), ACC_STATIC | ACC_FINAL,\n+                                            cob -> cob.ldc(FAILED).ireturn())\n+                    );\n@@ -83,8 +88,0 @@\n-                        mv = cw.visitMethod(ACC_FINAL | ACC_STATIC, \"m\", \"()I\", null, null);\n-                        mv.visitCode();\n-                        mv.visitLdcInsn(FAILED);\n-                        mv.visitInsn(IRETURN);\n-                        mv.visitMaxs(1, 1);\n-                        mv.visitEnd();\n-                    }\n-                    break;\n@@ -92,19 +89,12 @@\n-                    cw.visit(52, ACC_SUPER | ACC_PUBLIC, CLASS_NAME_B, null, CLASS_NAME_A, null);\n-                    {\n-                        mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-                        mv.visitCode();\n-                        mv.visitVarInsn(ALOAD, 0);\n-                        mv.visitMethodInsn(INVOKESPECIAL, CLASS_NAME_A, \"<init>\", \"()V\");\n-                        mv.visitInsn(RETURN);\n-                        mv.visitMaxs(1, 1);\n-                        mv.visitEnd();\n-\n-                        mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"()I\", null, null);\n-                        mv.visitCode();\n-                        mv.visitLdcInsn(EXPECTED);\n-                        mv.visitInsn(IRETURN);\n-                        mv.visitMaxs(1, 1);\n-                        mv.visitEnd();\n-\n-                    }\n-                    break;\n+                    return ClassFile.of().build(ClassDesc.ofInternalName(CLASS_NAME_B),\n+                            clb -> clb.withVersion(JAVA_8_VERSION, 0)\n+                                    .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                                    .withSuperclass(ClassDesc.ofInternalName(CLASS_NAME_A))\n+                                    .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                            cob -> cob\n+                                                    .aload(0)\n+                                                    .invokespecial(ClassDesc.ofInternalName(CLASS_NAME_A), INIT_NAME, MTD_void)\n+                                                    .return_())\n+                                    .withMethodBody(\"m\", MethodTypeDesc.of(CD_int), ACC_PUBLIC,\n+                                            cob -> cob.ldc(EXPECTED).ireturn())\n+                    );\n@@ -114,3 +104,1 @@\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n+            throw new AssertionError(\"Unknown class \" + name);\n","filename":"test\/hotspot\/jtreg\/runtime\/finalStatic\/FinalStatic.java","additions":36,"deletions":48,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n@@ -32,4 +32,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n@@ -37,0 +33,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.*;\n@@ -46,0 +45,3 @@\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n+\n@@ -48,1 +50,1 @@\n-    static abstract class IndyClassloader extends ClassLoader implements Opcodes {\n+    static abstract class IndyClassloader extends ClassLoader {\n@@ -77,2 +79,0 @@\n-            ClassWriter cw = new ClassWriter(\n-                    ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);\n@@ -80,2 +80,2 @@\n-                defineIndyBootstrapMethodClass(cw);\n-                return cw.toByteArray();\n+                return defineIndyBootstrapMethodClass();\n+\n@@ -84,2 +84,1 @@\n-                defineIndyCallingClass(cw);\n-                return cw.toByteArray();\n+                return defineIndyCallingClass();\n@@ -90,12 +89,17 @@\n-        void defineIndyCallingClass(ClassWriter cw) {\n-            cw.visit(52, ACC_SUPER | ACC_PUBLIC, INDY_CALLER_CLASS_NAME, null, \"java\/lang\/Object\", null);\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"invoke\", \"()V\", null, null);\n-            mv.visitCode();\n-            Handle h = new Handle(H_INVOKESTATIC,\n-                                  BOOTSTRAP_METHOD_CLASS_NAME, BOOTSTRAP_METHOD_NAME,\n-                                  BOOTSTRAP_METHOD_DESC, false);\n-            mv.visitInvokeDynamicInsn(BOOTSTRAP_METHOD_CLASS_NAME, \"()V\", h);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-            cw.visitEnd();\n+        byte[] defineIndyCallingClass() {\n+                return ClassFile.of().build(ClassDesc.of(INDY_CALLER_CLASS_NAME),\n+                        clb -> clb\n+                                .withVersion(JAVA_8_VERSION, 0)\n+                                .withFlags(ACC_SUPER | ACC_PUBLIC)\n+                                .withSuperclass(CD_Object)\n+                                .withMethodBody(\"invoke\", MethodTypeDesc.of(CD_void), ACC_PUBLIC | ACC_STATIC,\n+                                        cob -> {\n+                                            DirectMethodHandleDesc h = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.STATIC,\n+                                                    ClassDesc.of(BOOTSTRAP_METHOD_CLASS_NAME),\n+                                                    BOOTSTRAP_METHOD_NAME,\n+                                                    BOOTSTRAP_METHOD_DESC);\n+                                            cob.invokedynamic(DynamicCallSiteDesc.of(h, MethodTypeDesc.of(CD_void)));\n+                                            cob.return_();\n+                                        }\n+                                )\n+                );\n@@ -104,9 +108,10 @@\n-        void defineIndyBootstrapMethodClass(ClassWriter cw) {\n-            cw.visit(52, ACC_SUPER | ACC_PUBLIC,\n-                     BOOTSTRAP_METHOD_CLASS_NAME, null, \"java\/lang\/Object\", null);\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC,\n-                                              BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_DESC, null, null);\n-            mv.visitCode();\n-            defineIndyBootstrapMethodBody(mv);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+        byte[] defineIndyBootstrapMethodClass() {\n+            return ClassFile.of().build(ClassDesc.of(BOOTSTRAP_METHOD_CLASS_NAME),\n+                    clb -> clb\n+                            .withVersion(JAVA_8_VERSION, 0)\n+                            .withFlags(ACC_SUPER | ACC_PUBLIC)\n+                            .withSuperclass(CD_Object)\n+                            .withMethodBody(BOOTSTRAP_METHOD_NAME, MethodTypeDesc.ofDescriptor(BOOTSTRAP_METHOD_DESC), ACC_PUBLIC | ACC_STATIC,\n+                                    this::defineIndyBootstrapMethodBody\n+                            )\n+            );\n@@ -115,3 +120,3 @@\n-        void defineIndyBootstrapMethodBody(MethodVisitor mv) {\n-            mv.visitInsn(ACONST_NULL);\n-            mv.visitInsn(ARETURN);\n+        void defineIndyBootstrapMethodBody(CodeBuilder cob) {\n+            cob.aconst_null();\n+            cob.areturn();\n@@ -191,10 +196,10 @@\n-        void defineIndyBootstrapMethodClass(ClassWriter cw) {\n-            cw.visit(52, ACC_SUPER | ACC_PUBLIC,\n-                     BOOTSTRAP_METHOD_CLASS_NAME, null, \"java\/lang\/Object\", null);\n-            \/\/ Bootstrap method is declared to be private\n-            MethodVisitor mv = cw.visitMethod(ACC_PRIVATE | ACC_STATIC,\n-                                              BOOTSTRAP_METHOD_NAME, BOOTSTRAP_METHOD_DESC, null, null);\n-            mv.visitCode();\n-            defineIndyBootstrapMethodBody(mv);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+        byte[] defineIndyBootstrapMethodClass() {\n+            return ClassFile.of().build(ClassDesc.of(BOOTSTRAP_METHOD_CLASS_NAME),\n+                    clb -> clb\n+                            .withVersion(JAVA_8_VERSION, 0)\n+                            .withFlags(ACC_SUPER | ACC_PUBLIC)\n+                            .withSuperclass(CD_Object)\n+                            .withMethodBody(BOOTSTRAP_METHOD_NAME, MethodTypeDesc.ofDescriptor(BOOTSTRAP_METHOD_DESC), ACC_PRIVATE | ACC_STATIC,\n+                                    this::defineIndyBootstrapMethodBody\n+                            )\n+            );\n@@ -211,1 +216,1 @@\n-        void defineIndyBootstrapMethodBody(MethodVisitor mv) {\n+        void defineIndyBootstrapMethodBody(CodeBuilder cob) {\n@@ -214,2 +219,2 @@\n-            mv.visitInsn(ACONST_NULL);\n-            mv.visitInsn(ARETURN);\n+            cob.aconst_null();\n+            cob.areturn();\n@@ -227,1 +232,1 @@\n-        void defineIndyBootstrapMethodBody(MethodVisitor mv) {\n+        void defineIndyBootstrapMethodBody(CodeBuilder cob) {\n@@ -231,3 +236,3 @@\n-            mv.visitMethodInsn(INVOKESTATIC, \"BootstrapMethodErrorTest\",\n-                               \"getCallSite\", \"()Ljava\/lang\/invoke\/CallSite;\", false);\n-            mv.visitInsn(ARETURN);\n+            cob.invokestatic(ClassDesc.of(\"BootstrapMethodErrorTest\"), \"getCallSite\",\n+                             MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/invoke\/CallSite;\"));\n+            cob.areturn();\n@@ -250,1 +255,1 @@\n-        void defineIndyBootstrapMethodBody(MethodVisitor mv) {\n+        void defineIndyBootstrapMethodBody(CodeBuilder cob) {\n@@ -253,4 +258,4 @@\n-            mv.visitMethodInsn(INVOKESTATIC, \"BootstrapMethodErrorTest\",\n-                               methodName, \"()V\", false);\n-            mv.visitInsn(ACONST_NULL);\n-            mv.visitInsn(ARETURN);\n+            cob.invokestatic(ClassDesc.of(\"BootstrapMethodErrorTest\"), methodName,\n+                             MethodTypeDesc.of(CD_void));\n+            cob.aconst_null();\n+            cob.areturn();\n","filename":"test\/hotspot\/jtreg\/runtime\/invokedynamic\/BootstrapMethodErrorTest.java","additions":63,"deletions":58,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,8 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n+\n@@ -35,0 +40,1 @@\n+ * @enablePreview\n@@ -36,2 +42,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.misc\n@@ -40,1 +45,1 @@\n- * @run driver OverriderMsg\n+ * @run main\/othervm --enable-preview OverriderMsg\n@@ -45,1 +50,1 @@\n-\/\/ asm part of the test creates these two classes:\n+\/\/ ClassFile part of the test creates these two classes:\n@@ -60,2 +65,1 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n+        byte[] bytes;\n@@ -63,1 +67,15 @@\n-        cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, \"HasFinal\", null, \"java\/lang\/Object\", null);\n+        bytes = ClassFile.of().build(ClassDesc.of(\"HasFinal\"),\n+                    clb -> clb\n+                            .withVersion(JAVA_7_VERSION, 0)\n+                            .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                            .withSuperclass(CD_Object)\n+\n+                            .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .aload(0)\n+                                            .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                            .return_())\n+\n+                            .withMethodBody(\"m\", MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;)V\"), ACC_PUBLIC | ACC_FINAL, CodeBuilder::return_)\n+\n+        );\n@@ -65,17 +83,0 @@\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\");\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC + ACC_FINAL, \"m\", \"(Ljava\/lang\/String;)V\", null, null);\n-            mv.visitCode();\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 2);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n@@ -83,1 +84,1 @@\n-             fos.write(cw.toByteArray());\n+             fos.write(bytes);\n@@ -90,28 +91,19 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-        cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, \"Overrider\", null, \"HasFinal\", null);\n-\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"HasFinal\", \"<init>\", \"()V\");\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"(Ljava\/lang\/String;)V\", null, null);\n-            mv.visitCode();\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 2);\n-            mv.visitEnd();\n-        }\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"main\", \"([Ljava\/lang\/String;)V\", null, null);\n-            mv.visitCode();\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n+        byte[] bytes;\n+\n+        bytes = ClassFile.of().build(ClassDesc.of(\"Overrider\"),\n+                clb -> clb\n+                        .withVersion(JAVA_7_VERSION, 0)\n+                        .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                        .withSuperclass(ClassDesc.of(\"HasFinal\"))\n+\n+                        .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                cob -> cob\n+                                        .aload(0)\n+                                        .invokespecial(ClassDesc.ofInternalName(\"HasFinal\"), INIT_NAME, MTD_void)\n+                                        .return_())\n+\n+                        .withMethodBody(\"m\", MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;)V\"), ACC_PUBLIC, CodeBuilder::return_)\n+\n+                        .withMethodBody(\"main\", MethodTypeDesc.ofDescriptor(\"([Ljava\/lang\/String;)V\"), ACC_PUBLIC | ACC_STATIC, CodeBuilder::return_)\n+\n+        );\n@@ -120,1 +112,1 @@\n-             fos.write(cw.toByteArray());\n+             fos.write(bytes);\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/OverriderMsg.java","additions":50,"deletions":58,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -27,3 +30,2 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -36,0 +38,1 @@\n+ * @enablePreview\n@@ -39,1 +42,0 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n@@ -41,2 +43,2 @@\n- * @run driver TestANewArray 49\n- * @run driver TestANewArray 52\n+ * @run main TestANewArray 49\n+ * @run main TestANewArray 52\n@@ -104,3 +106,1 @@\n-    public static byte[] dumpClassFile(int cfv, int testDimension264, String arrayDim) throws Exception {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        MethodVisitor mv;\n+    public static byte[] dumpClassFile(int cfv, int testDimension264, String arrayType) throws IllegalArgumentException {\n@@ -110,21 +110,16 @@\n-        cw.visit(cfv, ACC_PUBLIC + ACC_SUPER, classCName, null, \"java\/lang\/Object\", null);\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {   \/\/ classCName main method\n-            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"main\", \"([Ljava\/lang\/String;)V\", null, null);\n-            mv.visitCode();\n-            mv.visitIntInsn(BIPUSH, 1);\n-            mv.visitTypeInsn(ANEWARRAY, arrayDim); \/\/ Test ANEWARRAY bytecode with various dimensions\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(2, 2);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS).build(ClassDesc.of(classCName),\n+                    clb -> clb\n+                            .withVersion(cfv, 0)\n+                            .withSuperclass(CD_Object)\n+                            .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                            .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .aload(0)\n+                                            .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                            .return_())\n+                            .withMethodBody(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()), ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .bipush(1)\n+                                            .anewarray(cob.constantPool().classEntry(cob.constantPool().utf8Entry(arrayType)))\n+                                            .return_())\n+        );\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TestANewArray.java","additions":25,"deletions":30,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n@@ -26,5 +29,6 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -34,0 +38,1 @@\n+ * @enablePreview\n@@ -36,2 +41,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.misc\n@@ -40,4 +44,4 @@\n- * @run driver TestMultiANewArray 49\n- * @run driver TestMultiANewArray 50\n- * @run driver TestMultiANewArray 51\n- * @run driver TestMultiANewArray 52\n+ * @run main\/othervm --enable-preview TestMultiANewArray 49\n+ * @run main\/othervm --enable-preview TestMultiANewArray 50\n+ * @run main\/othervm --enable-preview TestMultiANewArray 51\n+ * @run main\/othervm --enable-preview TestMultiANewArray 52\n@@ -51,1 +55,1 @@\n-        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"-cp\", \".\",  \"ClassFile\");\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\"-cp\", \".\", \"ClassFile\");\n@@ -58,21 +62,1 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(cfv, ACC_PUBLIC + ACC_SUPER, \"ClassFile\", null, \"java\/lang\/Object\", null);\n-        mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitCode();\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"main\", \"([Ljava\/lang\/String;)V\", null, null);\n-        mv.visitCode();\n-        mv.visitInsn(ICONST_1);\n-        mv.visitInsn(ICONST_2);\n-        mv.visitMultiANewArrayInsn(\"[I\", 2);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(2, 2);\n-        mv.visitEnd();\n+        byte[] bytes;\n@@ -80,1 +64,19 @@\n-        cw.visitEnd();\n+        bytes = ClassFile.of().build(ClassDesc.of(\"ClassFile\"),\n+                clb -> clb\n+                        .withVersion(cfv, 0)\n+                        .withSuperclass(CD_Object)\n+                        .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                        .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                cob -> cob\n+                                        .aload(0)\n+                                        .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                        .return_())\n+                        .withMethodBody(\"main\", MethodTypeDesc.of(CD_void, CD_String.arrayType()), ACC_PUBLIC | ACC_STATIC,\n+                                cob -> cob\n+                                        .iconst_1()\n+                                        .iconst_2()\n+                                        .multianewarray(CD_int.arrayType(), 2)\n+                                        .astore(1)\n+                                        .return_()\n+                        )\n+        );\n@@ -83,1 +85,1 @@\n-             fos.write(cw.toByteArray());\n+            fos.write(bytes);\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/TestMultiANewArray.java","additions":38,"deletions":36,"binary":false,"changes":74,"status":"modified"}]}