{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @enablePreview\n@@ -28,2 +29,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.misc\n@@ -35,1 +35,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -37,0 +36,5 @@\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -38,4 +42,3 @@\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -45,0 +48,5 @@\n+    private static final ClassDesc CD_System = ClassDesc.of(\"java.lang.System\");\n+    private static final ClassDesc CD_PrintStream = ClassDesc.of(\"java.io.PrintStream\");\n+    private static final ClassDesc CD_LPrintStream = ClassDesc.ofDescriptor(\"Ljava\/io\/PrintStream;\");\n+    private static final ClassDesc CD_MethodHandle = ClassDesc.of(\"java.lang.invoke.MethodHandle\");\n+\n@@ -46,61 +54,44 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(52, ACC_PUBLIC | ACC_SUPER, \"BadInterfaceMethodref\", null, \"java\/lang\/Object\", null);\n-        Handle handle1 =\n-            new Handle(Opcodes.H_INVOKEINTERFACE, \"BadInterfaceMethodref\", \"m\", \"()V\", true);\n-        Handle handle2 =\n-            new Handle(Opcodes.H_INVOKEINTERFACE, \"BadInterfaceMethodref\", \"staticM\", \"()V\", true);\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-            mv.visitLdcInsn(\"hello from m\");\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false\/*intf*\/);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(3, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"staticM\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-            mv.visitLdcInsn(\"hello from staticM\");\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false\/*intf*\/);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(3, 1);\n-            mv.visitEnd();\n-        }\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"runm\", \"()V\", null, null);\n-            mv.visitCode();\n-            \/\/ REF_invokeStatic\n-            mv.visitLdcInsn(handle1);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invoke\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"runStaticM\", \"()V\", null, null);\n-            mv.visitCode();\n-            \/\/ REF_invokeStatic\n-            mv.visitLdcInsn(handle2);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invoke\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        byte[] bytes;\n+\n+        DirectMethodHandleDesc handle_1 = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL,\n+                ClassDesc.of(\"BadInterfaceMethodref\"), \"m\", \"()V\");\n+\n+        DirectMethodHandleDesc handle_2 = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL,\n+                ClassDesc.of(\"BadInterfaceMethodref\"), \"staticM\", \"()V\");\n+\n+        bytes = ClassFile.of().build(ClassDesc.of(\"BadInterfaceMethodref\"),\n+                    clb -> clb\n+                            .withVersion(JAVA_8_VERSION, 0)\n+                            .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                            .withSuperclass(CD_Object)\n+                            .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .aload(0)\n+                                            .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                            .return_())\n+                            .withMethodBody(\"m\", MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .getstatic(CD_System, \"out\", CD_LPrintStream)\n+                                            .ldc(\"hello from m\")\n+                                            .invokevirtual(CD_PrintStream, \"println\", MethodTypeDesc.of(CD_void, CD_String))\n+                                            .return_())\n+                            .withMethodBody(\"staticM\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .getstatic(CD_System, \"out\", CD_LPrintStream)\n+                                            .ldc(\"hello from staticM\")\n+                                            .invokevirtual(CD_PrintStream, \"println\", MethodTypeDesc.of(CD_void, CD_String))\n+                                            .return_())\n+                            .withMethodBody(\"runm\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .ldc(handle_1)\n+                                            .invokevirtual(CD_MethodHandle, \"invoke\", MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+                            .withMethodBody(\"runStaticM\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .ldc(handle_2)\n+                                            .invokevirtual(CD_MethodHandle, \"invoke\", MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+\n+        );\n+\n+        return bytes;\n@@ -110,24 +101,22 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(52, ACC_PUBLIC | ACC_ABSTRACT | ACC_INTERFACE, \"IBad\", null, \"java\/lang\/Object\", null);\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-            mv.visitLdcInsn(\"hello from m\");\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false\/*intf*\/);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(3, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"staticM\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, \"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-            mv.visitLdcInsn(\"hello from staticM\");\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\", false\/*intf*\/);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(3, 1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        byte[] bytes;\n+\n+        bytes = ClassFile.of().build(ClassDesc.of(\"IBad\"),\n+                    clb -> clb\n+                            .withVersion(JAVA_8_VERSION, 0)\n+                            .withFlags(ACC_PUBLIC | ACC_ABSTRACT | ACC_INTERFACE)\n+                            .withSuperclass(CD_Object)\n+                            .withMethodBody(\"m\", MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .getstatic(CD_System, \"out\", CD_LPrintStream)\n+                                            .ldc(\"hello from m\")\n+                                            .invokevirtual(CD_PrintStream, \"println\", MethodTypeDesc.of(CD_void, CD_String))\n+                                            .return_())\n+                            .withMethodBody(\"staticM\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .getstatic(CD_System, \"out\", CD_LPrintStream)\n+                                            .ldc(\"hello from staticM\")\n+                                            .invokevirtual(CD_PrintStream, \"println\", MethodTypeDesc.of(CD_void, CD_String))\n+                                            .return_())\n+        );\n+\n+        return bytes;\n@@ -137,41 +126,31 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(52, ACC_PUBLIC | ACC_SUPER,  \"BadMethodref\", null, \"java\/lang\/Object\", new String[]{\"IBad\"});\n-        Handle handle1 =\n-            new Handle(Opcodes.H_INVOKEINTERFACE, \"BadMethodref\", \"m\", \"()V\", true);\n-        Handle handle2 =\n-            new Handle(Opcodes.H_INVOKEINTERFACE, \"BadMethodref\", \"staticM\", \"()V\", true);\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"runm\", \"()V\", null, null);\n-            mv.visitCode();\n-            \/\/ REF_invokeStatic\n-            mv.visitLdcInsn(handle1);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invoke\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"runStaticM\", \"()V\", null, null);\n-            mv.visitCode();\n-            \/\/ REF_invokeStatic\n-            mv.visitLdcInsn(handle2);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invoke\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        byte[] bytes;\n+\n+        DirectMethodHandleDesc handle_1 = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL,\n+                ClassDesc.of(\"BadMethodref\"), \"m\", \"()V\");\n+        DirectMethodHandleDesc handle_2 = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL,\n+                ClassDesc.of(\"BadMethodref\"), \"staticM\", \"()V\");\n+\n+        bytes = ClassFile.of().build(ClassDesc.of(\"BadMethodref\"),\n+                    clb -> clb\n+                            .withVersion(JAVA_8_VERSION, 0)\n+                            .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                            .withSuperclass(CD_Object)\n+                            .withInterfaceSymbols(ClassDesc.of(\"IBad\"))\n+                            .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .aload(0)\n+                                            .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                            .return_())\n+                            .withMethodBody(\"runm\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .ldc(handle_1)\n+                                            .invokevirtual(CD_MethodHandle, \"invoke\", MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+                            .withMethodBody(\"runStaticM\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .ldc(handle_2)\n+                                            .invokevirtual(CD_MethodHandle, \"invoke\", MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+        );\n+\n+        return bytes;\n@@ -181,27 +160,23 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(52, ACC_PUBLIC | ACC_SUPER,  \"InvokeBasicref\", null, \"java\/lang\/Object\", null);\n-        Handle handle =\n-                new Handle(Opcodes.H_INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeBasic\", \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"runInvokeBasicM\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitLdcInsn(handle);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invoke\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        byte[] bytes;\n+\n+        DirectMethodHandleDesc handle = MethodHandleDesc.of(DirectMethodHandleDesc.Kind.VIRTUAL,\n+                ClassDesc.of(\"InvokeBasicref\"), \"runInvokeBasicM\", \"()V\");\n+\n+        bytes = ClassFile.of().build(ClassDesc.of(\"InvokeBasicref\"),\n+                    clb -> clb\n+                            .withVersion(JAVA_8_VERSION, 0)\n+                            .withFlags(ACC_PUBLIC | ACC_SUPER)\n+                            .withSuperclass(CD_Object)\n+                            .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC,\n+                                    cob -> cob\n+                                            .aload(0)\n+                                            .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                                            .return_())\n+                            .withMethodBody(\"runInvokeBasicM\", MTD_void, ACC_PUBLIC | ACC_STATIC,\n+                                    cob -> cob\n+                                            .ldc(handle)\n+                                            .invokevirtual(CD_MethodHandle, \"invoke\", MethodTypeDesc.of(CD_void))\n+                                            .return_())\n+        );\n+\n+        return bytes;\n","filename":"test\/hotspot\/jtreg\/runtime\/ConstantPool\/BadMethodHandles.java","additions":136,"deletions":161,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-     * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/runtime\/verifier\/OverriderMsg.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}