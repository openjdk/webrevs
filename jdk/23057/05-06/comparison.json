{"files":[{"patch":"@@ -40,2 +40,2 @@\n-    static int loopCount = 100000;\n-    static int anotherInt = 1;\n+    static int someInts0 = 1;\n+    static int someInts1 = 2;\n@@ -46,3 +46,11 @@\n-    @DontInline\n-    private int constInt() {\n-        return 100000;\n+    \/\/ Test for a top-level counted loop.\n+    \/\/ There should be a non-call safepoint in the loop.\n+    @Test\n+    @IR(counts = {IRNode.SAFEPOINT, \"1\"},\n+        phase = CompilePhase.AFTER_LOOP_OPTS)\n+    public int testTopLevelCountedLoop() {\n+        int sum = 0;\n+        for (int i = 0; i < 100000; i++) {\n+            sum += someInts0;\n+        }\n+        return sum;\n@@ -51,0 +59,4 @@\n+    \/\/ Test for a top-level counted loop with a call that dominates\n+    \/\/ the tail of the loop.\n+    \/\/ There should be no safepoint in the loop, because the call is\n+    \/\/ guaranteed to have a safepoint.\n@@ -52,2 +64,4 @@\n-    @IR(failOn = IRNode.SAFEPOINT)\n-    public void loopConst() {\n+    @IR(counts = {IRNode.SAFEPOINT, \"0\"},\n+        phase = CompilePhase.AFTER_LOOP_OPTS)\n+    public int testTopLevelCountedLoopWithDomCall() {\n+        int sum = 0;\n@@ -56,0 +70,1 @@\n+            sum += someInts0;\n@@ -57,0 +72,1 @@\n+        return sum;\n@@ -59,0 +75,2 @@\n+    \/\/ Test for a top-level uncounted loop.\n+    \/\/ There should be a non-call safepoint in the loop.\n@@ -60,3 +78,22 @@\n-    @IR(failOn = IRNode.SAFEPOINT)\n-    public void loopVar() {\n-        for (int i = 0; i < loopCount; i++) {\n+    @IR(counts = {IRNode.SAFEPOINT, \"1\"},\n+        phase = CompilePhase.AFTER_LOOP_OPTS)\n+    public int testTopLevelUncountedLoop() {\n+        int sum = 0;\n+        for (int i = 0; i < 100000; i += someInts0) {\n+            sum += someInts1;\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ Test for a top-level uncounted loop with a call that dominates\n+    \/\/ the tail of the loop.\n+    \/\/ There should be no safepoint in the loop, because the call is\n+    \/\/ guaranteed to have a safepoint.\n+    \/\/ Before JDK-8347499, this test would fail due to C2 exiting\n+    \/\/ prematurely when encountering the local non-call safepoint.\n+    @Test\n+    @IR(counts = {IRNode.SAFEPOINT, \"0\"},\n+        phase = CompilePhase.AFTER_LOOP_OPTS)\n+    public int testTopLevelUncountedLoopWithDomCall() {\n+        int sum = 0;\n+        for (int i = 0; i < 100000; i += someInts0) {\n@@ -64,0 +101,1 @@\n+            sum += someInts1;\n@@ -65,0 +103,1 @@\n+        return sum;\n@@ -67,0 +106,5 @@\n+    \/\/ Test for nested loops, where the outer loop has a call that\n+    \/\/ dominates its own tail.\n+    \/\/ There should be only one safepoint in the inner loop.\n+    \/\/ Before JDK-8347499, this test would fail due to C2 exiting\n+    \/\/ prematurely when encountering the local non-call safepoint.\n@@ -68,2 +112,3 @@\n-    @IR(counts = {IRNode.SAFEPOINT, \"1\"})\n-    public int loopVarWithoutCall() {\n+    @IR(counts = {IRNode.SAFEPOINT, \"1\"},\n+        phase = CompilePhase.AFTER_LOOP_OPTS)\n+    public int testOuterLoopWithDomCall() {\n@@ -71,2 +116,5 @@\n-        for (int i = 0; i < loopCount; i++) {\n-            sum += anotherInt;\n+        for (int i = 0; i < 100; i += someInts0) {\n+            empty();\n+            for (int j = 0; j < 1000; j++) {\n+                sum += someInts1;\n+            }\n@@ -77,0 +125,6 @@\n+    \/\/ Test for nested loops, where both the outer and inner loops\n+    \/\/ have a call that dominates their tails.\n+    \/\/ There should be no safepoint in both loops, because calls\n+    \/\/ within them are guaranteed to have a safepoint.\n+    \/\/ Before JDK-8347499, this test would fail due to C2 exiting\n+    \/\/ prematurely when encountering the local non-call safepoint.\n@@ -78,3 +132,5 @@\n-    @IR(failOn = IRNode.SAFEPOINT)\n-    public void loopFunc() {\n-        for (int i = 0; i < constInt(); i++) {\n+    @IR(counts = {IRNode.SAFEPOINT, \"0\"},\n+        phase = CompilePhase.AFTER_LOOP_OPTS)\n+    public int testOuterAndInnerLoopWithDomCall() {\n+        int sum = 0;\n+        for (int i = 0; i < 100; i += someInts0) {\n@@ -82,0 +138,37 @@\n+            for (int j = 0; j < 1000; j++) {\n+                empty();\n+                sum += someInts1;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ Test for nested loops, where the outer loop has a local\n+    \/\/ non-call safepoint.\n+    \/\/ There should be a safepoint in both loops.\n+    @Test\n+    @IR(counts = {IRNode.SAFEPOINT, \"2\"},\n+        phase = CompilePhase.AFTER_LOOP_OPTS)\n+    public int testOuterLoopWithLocalNonCallSafepoint() {\n+        int sum = 0;\n+        for (int i = 0; i < 100; i += someInts0) {\n+            for (int j = 0; j < 1000; j++) {\n+                sum += someInts1;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ Test for nested loops, where the outer loop has no local\n+    \/\/ safepoints, and it must preserve a non-local safepoint.\n+    \/\/ There should be two safepoints in the loop tree.\n+    @Test\n+    @IR(counts = {IRNode.SAFEPOINT, \"2\"},\n+        phase = CompilePhase.AFTER_LOOP_OPTS)\n+    public void testLoopNeedsToPreserveSafepoint() {\n+        int i = 0, stop;\n+        while (i < 1000) {\n+            stop = i + 10;\n+            while (i < stop) {\n+                i += 1;\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestRedundantSafepointElimination.java","additions":110,"deletions":17,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    static int loopCount = 100000;\n-    static int anotherInt = 1;\n+    static int someInts0 = 1;\n+    static int someInts1 = 2;\n@@ -43,3 +43,11 @@\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    private int constInt() {\n-        return 100000;\n+    \/\/ All benchmarks below are in sync with the IR test\n+    \/\/ `compiler.loopopts.TestRedundantSafepointElimination.java`.\n+    \/\/ Check the comments in the IR test for more details.\n+\n+    @Benchmark\n+    public int topLevelCountedLoop() {\n+        int sum = 0;\n+        for (int i = 0; i < 100000; i++) {\n+            sum += someInts0;\n+        }\n+        return sum;\n@@ -49,1 +57,1 @@\n-    public int loopConst() {\n+    public int topLevelCountedLoopWithDomCall() {\n@@ -52,1 +60,0 @@\n-            sum += anotherInt;\n@@ -54,0 +61,20 @@\n+            sum += someInts0;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int topLevelUncountedLoop() {\n+        int sum = 0;\n+        for (int i = 0; i < 100000; i += someInts0) {\n+            sum += someInts1;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int topLevelUncountedLoopWithDomCall() {\n+        int sum = 0;\n+        for (int i = 0; i < 100000; i += someInts0) {\n+            empty();\n+            sum += someInts1;\n@@ -59,1 +86,1 @@\n-    public int loopVar() {\n+    public int outerLoopWithDomCall() {\n@@ -61,2 +88,1 @@\n-        for (int i = 0; i < loopCount; i++) {\n-            sum += anotherInt;\n+        for (int i = 0; i < 100; i += someInts0) {\n@@ -64,0 +90,3 @@\n+            for (int j = 0; j < 1000; j++) {\n+                sum += someInts1;\n+            }\n@@ -69,1 +98,1 @@\n-    public int loopFunc() {\n+    public int outerAndInnerLoopWithDomCall() {\n@@ -71,2 +100,1 @@\n-        for (int i = 0; i < constInt(); i++) {\n-            sum += anotherInt;\n+        for (int i = 0; i < 100; i += someInts0) {\n@@ -74,0 +102,4 @@\n+            for (int j = 0; j < 1000; j++) {\n+                empty();\n+                sum += someInts1;\n+            }\n@@ -77,0 +109,22 @@\n+\n+    @Benchmark\n+    public int outerLoopWithLocalNonCallSafepoint() {\n+        int sum = 0;\n+        for (int i = 0; i < 100; i += someInts0) {\n+            for (int j = 0; j < 1000; j++) {\n+                sum += someInts1;\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void loopNeedsToPreserveSafepoint() {\n+        int i = 0, stop;\n+        while (i < 1000) {\n+            stop = i + 10;\n+            while (i < stop) {\n+                i += 1;\n+            }\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/LoopSafepoint.java","additions":67,"deletions":13,"binary":false,"changes":80,"status":"modified"}]}