{"files":[{"patch":"@@ -119,0 +119,2 @@\n+    enum UseVTForSelector { ALWAYS, NEVER, DEFAULT }\n+    static final UseVTForSelector USE_VT_FOR_SELECTOR;\n@@ -145,0 +147,5 @@\n+        String useVtForSelector =\n+                System.getProperty(\"jdk.internal.httpclient.quic.selector.useVirtualThreads\", \"default\");\n+        USE_VT_FOR_SELECTOR = Stream.of(UseVTForSelector.values())\n+                .filter((v) -> v.name().equalsIgnoreCase(useVtForSelector))\n+                .findFirst().orElse(UseVTForSelector.DEFAULT);\n@@ -824,1 +831,1 @@\n-                            assert Thread.currentThread() instanceof QuicSelector.QuicSelectorThread;\n+                            assert QuicSelector.isSelectorThread();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicEndpoint.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+import jdk.internal.net.http.quic.QuicEndpoint.UseVTForSelector;\n+\n+import static jdk.internal.net.http.quic.QuicEndpoint.USE_VT_FOR_SELECTOR;\n@@ -65,0 +68,3 @@\n+    private static final ScopedValue<Boolean> IS_SELECTOR =\n+            ScopedValue.newInstance();\n+\n@@ -77,1 +83,5 @@\n-        this.thread = new QuicSelectorThread(this);\n+        this.thread = QuicSelectorThread.of(USE_VT_FOR_SELECTOR, this);\n+    }\n+\n+    public static boolean isSelectorThread() {\n+        return IS_SELECTOR.orElse(Boolean.FALSE);\n@@ -98,0 +108,7 @@\n+    @Override\n+    public final void run() {\n+        ScopedValue.where(IS_SELECTOR, true).run(this::runSelector);\n+    }\n+\n+    abstract void runSelector();\n+\n@@ -119,0 +136,1 @@\n+            @Override\n@@ -203,1 +221,1 @@\n-        public void run() {\n+        void runSelector() {\n@@ -324,1 +342,1 @@\n-        public void run() {\n+        void runSelector() {\n@@ -458,1 +476,2 @@\n-        if (Thread.currentThread() == thread) {\n+        if (isSelectorThread()) {\n+            assert Thread.currentThread() == thread.thread();\n@@ -491,6 +510,31 @@\n-    static class QuicSelectorThread extends Thread {\n-        QuicSelectorThread(QuicSelector<?> selector)  {\n-            super(null, selector,\n-                    \"Thread(%s)\".formatted(selector.name()),\n-                    0, false);\n-            this.setDaemon(true);\n+    private record QuicSelectorThread(Thread thread) {\n+        void start() {\n+            thread.start();\n+        }\n+        void join(long millis) throws InterruptedException {\n+            thread.join(millis);\n+        }\n+        static QuicSelectorThread ofPlatform(QuicSelector<?> selector) {\n+            Thread thread = Thread.ofPlatform()\n+                    .name(\"Thread(%s)\".formatted(selector.name()))\n+                    .stackSize(0)\n+                    .inheritInheritableThreadLocals(false)\n+                    .daemon()\n+                    .unstarted(selector);\n+            return new QuicSelectorThread(thread);\n+        }\n+        static QuicSelectorThread ofVirtual(QuicSelector<?> selector) {\n+            Thread thread = Thread.ofVirtual()\n+                    .name(\"Thread(%s)\".formatted(selector.name()))\n+                    .inheritInheritableThreadLocals(false)\n+                    .unstarted(selector);\n+            return new QuicSelectorThread(thread);\n+        }\n+        static QuicSelectorThread of(UseVTForSelector config, QuicSelector<?> selector) {\n+            return switch (config) {\n+                case ALWAYS -> ofVirtual(selector);\n+                case NEVER -> ofPlatform(selector);\n+                default -> selector instanceof QuicNioSelector\n+                        ? ofPlatform(selector)\n+                        : ofVirtual(selector);\n+            };\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicSelector.java","additions":54,"deletions":10,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.net.SimpleSSLContext;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Assertions;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_3;\n+import static java.net.http.HttpOption.H3_DISCOVERY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+\n+\/*\n+ * @test id=default\n+ * @bug 8369920\n+ * @summary Verifies whether `QuicSelector` uses virtual threads when\n+            no explicit configuration is provided\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors,http3\n+ *              H3QuicVTTest\n+ *\/\n+\/*\n+ * @test id=never\n+ * @bug 8369920\n+ * @summary Verifies that `QuicSelector` does *not* use virtual threads\n+            when explicitly configured so\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.quic.useVTForSelector=never\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors,http3\n+ *              H3QuicVTTest\n+ *\/\n+\/*\n+ * @test id=always\n+ * @bug 8369920\n+ * @summary Verifies that `QuicSelector` does *always* use virtual threads\n+            when explicitly configured so\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.quic.useVTForSelector=always\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors,http3\n+ *              H3QuicVTTest\n+ *\/\n+\/*\n+ * @test id=explicit-default\n+ * @bug 8369920\n+ * @summary Verifies whether `QuicSelector` uses virtual threads when\n+            `default` is explicitly configured\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.quic.useVTForSelector=default\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors,http3\n+ *              H3QuicVTTest\n+ *\/\n+\/*\n+ * @test id=garbage\n+ * @bug 8369920\n+ * @summary Verifies whether `QuicSelector` uses virtual threads when\n+            it is configured using an invalid value\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.quic.useVTForSelector=garbage\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors,http3\n+ *              H3QuicVTTest\n+ *\/\n+\/\/ -Djava.security.debug=all\n+class H3QuicVTTest implements HttpServerAdapters {\n+\n+    private static SSLContext sslContext;\n+    private static HttpTestServer h3Server;\n+    private static String requestURI;\n+\n+    enum UseVTForSelector { ALWAYS, NEVER, DEFAULT }\n+    private static final String PROP_NAME = \"jdk.internal.httpclient.quic.useVTForSelector\";\n+    private static final UseVTForSelector USE_VT_FOR_SELECTOR;\n+    static {\n+        String useVtForSelector =\n+                System.getProperty(PROP_NAME, \"default\");\n+        USE_VT_FOR_SELECTOR = Stream.of(UseVTForSelector.values())\n+                .filter((v) -> v.name().equalsIgnoreCase(useVtForSelector))\n+                .findFirst().orElse(UseVTForSelector.DEFAULT);\n+    }\n+\n+    private static boolean isQuicSelectorThreadVirtual() {\n+        return switch (USE_VT_FOR_SELECTOR) {\n+            case ALWAYS -> true;\n+            case NEVER  -> false;\n+            default     -> !Platform.isWindows();\n+        };\n+    }\n+\n+    @BeforeAll\n+    public static void beforeClass() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null) {\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+        }\n+        \/\/ create an H3 only server\n+        h3Server = HttpTestServer.create(HTTP_3_URI_ONLY, sslContext);\n+        h3Server.addHandler((exchange) -> exchange.sendResponseHeaders(200, 0), \"\/hello\");\n+        h3Server.start();\n+        System.out.println(\"Server started at \" + h3Server.getAddress());\n+        requestURI = \"https:\/\/\" + h3Server.serverAuthority() + \"\/hello\";\n+    }\n+\n+    @AfterAll\n+    static void afterClass() throws Exception {\n+        if (h3Server != null) {\n+            System.out.println(\"Stopping server \" + h3Server.getAddress());\n+            h3Server.stop();\n+        }\n+    }\n+\n+    \/**\n+     * Issues various HTTP3 requests and verifies the responses are received\n+     *\/\n+    @Test\n+    void testBasicRequests() throws Exception {\n+        try (final HttpClient client = newClientBuilderForH3()\n+                .proxy(NO_PROXY)\n+                .version(HTTP_3)\n+                .sslContext(sslContext).build()) {\n+            final URI reqURI = new URI(requestURI);\n+            final HttpRequest.Builder reqBuilder = HttpRequest.newBuilder(reqURI)\n+                    .version(HTTP_3)\n+                    .setOption(H3_DISCOVERY, HTTP_3_URI_ONLY);\n+\n+            \/\/ GET\n+            final HttpRequest req1 = reqBuilder.copy().GET().build();\n+            System.out.println(\"\\nIssuing request: \" + req1);\n+            final HttpResponse<Void> resp1 = client.send(req1, BodyHandlers.discarding());\n+            Assertions.assertEquals(200, resp1.statusCode(), \"unexpected response code for GET request\");\n+            assertSelectorThread(client);\n+\n+            \/\/ POST\n+            final HttpRequest req2 = reqBuilder.copy().POST(BodyPublishers.ofString(\"foo\")).build();\n+            System.out.println(\"\\nIssuing request: \" + req2);\n+            final HttpResponse<Void> resp2 = client.send(req2, BodyHandlers.discarding());\n+            Assertions.assertEquals(200, resp2.statusCode(), \"unexpected response code for POST request\");\n+            assertSelectorThread(client);\n+\n+            \/\/ HEAD\n+            final HttpRequest req3 = reqBuilder.copy().HEAD().build();\n+            System.out.println(\"\\nIssuing request: \" + req3);\n+            final HttpResponse<Void> resp3 = client.send(req3, BodyHandlers.discarding());\n+            Assertions.assertEquals(200, resp3.statusCode(), \"unexpected response code for HEAD request\");\n+            assertSelectorThread(client);\n+        }\n+    }\n+\n+    private static void assertSelectorThread(HttpClient client) {\n+        Objects.requireNonNull(client);\n+        String clientId = client.toString().substring(client.toString().indexOf('('));\n+        String name = \"Thread(QuicSelector(HttpClientImpl\" + clientId + \"))\";\n+        Set<String> threads = new HashSet<>(Thread.getAllStackTraces().keySet().stream()\n+                .map(Thread::getName)\n+                .toList());\n+        boolean found = threads.contains(name);\n+        String status = found == isQuicSelectorThreadVirtual() ? \"ERROR\" : \"SUCCESS\";\n+        String propval = System.getProperty(PROP_NAME);\n+        if (propval == null) {\n+            System.out.printf(\"%s not defined, virtual=%s, thread found=%s%n\",\n+                    PROP_NAME, isQuicSelectorThreadVirtual(), found);\n+        } else {\n+            System.out.printf(\"%s=%s, virtual=%s, thread found=%s%n\",\n+                    PROP_NAME, propval, isQuicSelectorThreadVirtual(), found);\n+        }\n+        final String msg;\n+        if (found) {\n+            msg = \"%s found in %s\".formatted(name, threads);\n+            System.out.printf(\"%s: %s%n\", status, msg);\n+        } else {\n+            msg = \"%s not found in %s\".formatted(name, threads);\n+            System.out.printf(\"%s: %s%n\", status, msg);\n+        }\n+        Assertions.assertEquals(!isQuicSelectorThreadVirtual(), found, msg);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3QuicVTTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"}]}