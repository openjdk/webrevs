{"files":[{"patch":"@@ -70,0 +70,1 @@\n+import jdk.jpackage.internal.model.ExternalApplication;\n@@ -119,1 +120,1 @@\n-                    var launcherParams = mapLauncherInfo(launcherInfo);\n+                    var launcherParams = mapLauncherInfo(appImageFile, launcherInfo);\n@@ -223,1 +224,1 @@\n-    private static Map<String, ? super Object> mapLauncherInfo(LauncherInfo launcherInfo) {\n+    private static Map<String, ? super Object> mapLauncherInfo(ExternalApplication appImageFile, LauncherInfo launcherInfo) {\n@@ -226,1 +227,5 @@\n-        launcherParams.put(LAUNCHER_AS_SERVICE.getID(), Boolean.toString(launcherInfo.service()));\n+        if (!appImageFile.getLauncherName().equals(launcherInfo.name())) {\n+            \/\/ This is not the main launcher, accept the value\n+            \/\/ of \"launcher-as-service\" from the app image file (.jpackage.xml).\n+            launcherParams.put(LAUNCHER_AS_SERVICE.getID(), Boolean.toString(launcherInfo.service()));\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -104,0 +104,5 @@\n+    public AdditionalLauncher removeProperty(String name) {\n+        rawProperties.remove(Objects.requireNonNull(name));\n+        return this;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.IOException;\n@@ -37,0 +36,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n@@ -119,1 +119,1 @@\n-    public static CfgFile load(Path path) throws IOException {\n+    public static CfgFile load(Path path) {\n@@ -129,1 +129,1 @@\n-        for (String line : Files.readAllLines(path)) {\n+        for (String line : ThrowingFunction.<Path, List<String>>toFunction(Files::readAllLines).apply(path)) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CfgFile.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.UncheckedIOException;\n@@ -217,16 +216,3 @@\n-        boolean[] withServices = new boolean[1];\n-        withServices[0] = cmd.hasArgument(\"--launcher-as-service\");\n-        if (!withServices[0]) {\n-            AdditionalLauncher.forEachAdditionalLauncher(cmd, (launcherName, propertyFilePath) -> {\n-                try {\n-                    final var launcherAsService = new AdditionalLauncher.PropertyFile(propertyFilePath)\n-                            .findBooleanProperty(\"launcher-as-service\").orElse(false);\n-                    if (launcherAsService) {\n-                        withServices[0] = true;\n-                    }\n-                } catch (IOException ex) {\n-                    throw new UncheckedIOException(ex);\n-                }\n-            });\n-        }\n-        return withServices[0];\n+        return cmd.launcherNames(true).stream().anyMatch(launcherName -> {\n+            return LauncherAsServiceVerifier.launcherAsService(cmd, launcherName);\n+        });\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigFilesStasher.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Collections;\n@@ -576,0 +577,18 @@\n+    \/**\n+     * Returns the name of the main launcher. It will read the name of the main\n+     * launcher from the external app image if such is specified.\n+     *\n+     * @return the name of the main launcher\n+     *\n+     * @throws IllegalArgumentException if the command is configured for packaging\n+     *                                  Java runtime\n+     *\/\n+    public String mainLauncherName() {\n+        verifyNotRuntime();\n+        return name();\n+    }\n+\n+    boolean isMainLauncher(String launcherName) {\n+        return launcherName == null || mainLauncherName().equals(launcherName);\n+    }\n+\n@@ -592,1 +611,1 @@\n-            launcherName = name();\n+            launcherName = mainLauncherName();\n@@ -610,2 +629,10 @@\n-     * Returns names of all additional launchers or empty list if none\n-     * configured.\n+     * Returns names of additional launchers or an empty list if none configured.\n+     * <p>\n+     * If {@code lookupInPrederfinedAppImage} is {@code true} and the command is\n+     * configured with an external app image, it will read names of the additional\n+     * launchers from the external app image.\n+     *\n+     * @param lookupInPrederfinedAppImage if to read names of additional launchers\n+     *                                    from an external app image\n+     *\n+     * @return the names of additional launchers\n@@ -613,1 +640,5 @@\n-    public List<String> addLauncherNames() {\n+    public List<String> addLauncherNames(boolean lookupInPrederfinedAppImage) {\n+        if (isRuntime()) {\n+            return List.of();\n+        }\n+\n@@ -615,0 +646,8 @@\n+        if (lookupInPrederfinedAppImage) {\n+            Optional.ofNullable(getArgumentValue(\"--app-image\"))\n+                    .map(Path::of)\n+                    .map(AppImageFile::load)\n+                    .map(AppImageFile::addLaunchers)\n+                    .map(Map::keySet)\n+                    .ifPresent(names::addAll);\n+        }\n@@ -618,1 +657,20 @@\n-        return names;\n+        return Collections.unmodifiableList(names);\n+    }\n+\n+    \/**\n+     * Returns names of all launchers.\n+     * <p>\n+     * If the list is not empty, the first element is {@code null} referencing the\n+     * main launcher. In the case of runtime packaging, the list is empty.\n+     *\n+     * @return the names of all launchers\n+     *\/\n+    public List<String> launcherNames(boolean lookupInPrederfinedAppImage) {\n+        if (isRuntime()) {\n+            return List.of();\n+        }\n+\n+        List<String> names = new ArrayList<>();\n+        names.add(null);\n+        names.addAll(addLauncherNames(lookupInPrederfinedAppImage));\n+        return Collections.unmodifiableList(names);\n@@ -642,1 +700,1 @@\n-            launcherName = name();\n+            launcherName = mainLauncherName();\n@@ -1247,1 +1305,1 @@\n-                        addLauncherNames().stream().sorted().toList(),\n+                        addLauncherNames(false).stream().sorted().toList(),\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":65,"deletions":7,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -25,3 +25,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingBiConsumer.toBiConsumer;\n-import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n-import static jdk.jpackage.test.AdditionalLauncher.forEachAdditionalLauncher;\n@@ -33,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -39,0 +37,1 @@\n+import java.util.Map;\n@@ -47,0 +46,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n@@ -48,1 +48,0 @@\n-import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n@@ -70,0 +69,13 @@\n+        public Builder setAppOutputFileNamePrefix(String v) {\n+            appOutputFileNamePrefix = v;\n+            return this;\n+        }\n+\n+        public Builder appendAppOutputFileNamePrefix(String v) {\n+            return setAppOutputFileNamePrefix(appOutputFileNamePrefix() + Objects.requireNonNull(v));\n+        }\n+\n+        public Builder setAppOutputFileNamePrefixToAppName() {\n+            return setAppOutputFileNamePrefix(TKit.getCurrentDefaultAppName());\n+        }\n+\n@@ -75,0 +87,5 @@\n+        public Builder mutate(Consumer<Builder> mutator) {\n+            mutator.accept(this);\n+            return this;\n+        }\n+\n@@ -77,1 +94,4 @@\n-            return new LauncherAsServiceVerifier(launcherName, appOutputFileName,\n+            return new LauncherAsServiceVerifier(\n+                    launcherName,\n+                    appOutputFileNamePrefix()\n+                            + Optional.ofNullable(appOutputFileName).orElse(\"launcher-as-service.txt\"),\n@@ -79,1 +99,5 @@\n-                    launcherName != null ? additionalLauncherCallback : null);\n+                    Optional.ofNullable(additionalLauncherCallback));\n+        }\n+\n+        public Builder applyTo(PackageTest test) {\n+            return applyTo(new ConfigurationTarget(test));\n@@ -82,2 +106,2 @@\n-        public Builder applyTo(PackageTest pkg) {\n-            create().applyTo(pkg);\n+        public Builder applyTo(ConfigurationTarget target) {\n+            create().applyTo(target);\n@@ -87,0 +111,4 @@\n+        private String appOutputFileNamePrefix() {\n+            return Optional.ofNullable(appOutputFileNamePrefix).orElse(\"\");\n+        }\n+\n@@ -89,1 +117,2 @@\n-        private String appOutputFileName = \"launcher-as-service.txt\";\n+        private String appOutputFileName;\n+        private String appOutputFileNamePrefix;\n@@ -100,2 +129,7 @@\n-            Consumer<AdditionalLauncher> additionalLauncherCallback) {\n-        this.expectedValue = expectedArgValue;\n+            Optional<Consumer<AdditionalLauncher>> additionalLauncherCallback) {\n+\n+        if (launcherName == null && additionalLauncherCallback.isPresent()) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        this.expectedValue = Objects.requireNonNull(expectedArgValue);\n@@ -107,1 +141,1 @@\n-    public void applyTo(PackageTest pkg) {\n+    public void applyTo(ConfigurationTarget target) {\n@@ -109,5 +143,3 @@\n-            pkg.forTypes(WINDOWS, () -> {\n-                pkg.addInitializer(cmd -> {\n-                    \/\/ Remove parameter added to jpackage command line in HelloApp.addTo()\n-                    cmd.removeArgument(\"--win-console\");\n-                });\n+            target.addInitializer(cmd -> {\n+                \/\/ Remove parameter added to jpackage command line in HelloApp.addTo()\n+                cmd.removeArgument(\"--win-console\");\n@@ -115,1 +147,1 @@\n-            applyToMainLauncher(pkg);\n+            applyToMainLauncher(target);\n@@ -117,1 +149,1 @@\n-            applyToAdditionalLauncher(pkg);\n+            applyToAdditionalLauncher(target);\n@@ -119,1 +151,3 @@\n-        pkg.addInstallVerifier(this::verifyLauncherExecuted);\n+        target.test().ifPresent(pkg -> {\n+            pkg.addInstallVerifier(this::verifyLauncherExecuted);\n+        });\n@@ -125,1 +159,1 @@\n-        var launcherNames = getLaunchersAsServices(cmd);\n+        var partitionedLauncherNames = partitionLaunchers(cmd);\n@@ -127,3 +161,7 @@\n-        launcherNames.forEach(toConsumer(launcherName -> {\n-            verify(cmd, launcherName);\n-        }));\n+        var launcherAsServiceNames = partitionedLauncherNames.get(true);\n+\n+        for (var launcherAsService : List.of(true, false)) {\n+            partitionedLauncherNames.get(launcherAsService).forEach(launcherName -> {\n+                verify(cmd, launcherName, launcherAsService);\n+            });\n+        }\n@@ -134,1 +172,1 @@\n-            if (launcherNames.isEmpty()) {\n+            if (launcherAsServiceNames.isEmpty()) {\n@@ -149,1 +187,1 @@\n-                        cmd, null).getParent());\n+                        cmd, \"foo\").getParent());\n@@ -154,1 +192,1 @@\n-                        cmd, null).getParent());\n+                        cmd, \"foo\").getParent());\n@@ -158,1 +196,1 @@\n-        if (launcherNames.isEmpty() || cmd.isRuntime()) {\n+        if (launcherAsServiceNames.isEmpty() || cmd.isRuntime()) {\n@@ -190,1 +228,2 @@\n-        List<String> launcherNames = new ArrayList<>();\n+        return Objects.requireNonNull(partitionLaunchers(cmd).get(true));\n+    }\n@@ -192,2 +231,7 @@\n-        if (cmd.hasArgument(\"--launcher-as-service\")) {\n-            launcherNames.add(null);\n+    private static Map<Boolean, List<String>> partitionLaunchers(JPackageCommand cmd) {\n+        if (cmd.isRuntime()) {\n+            return Map.of(true, List.of(), false, List.of());\n+        } else {\n+            return cmd.launcherNames(true).stream().collect(Collectors.partitioningBy(launcherName -> {\n+                return launcherAsService(cmd, launcherName);\n+            }));\n@@ -195,0 +239,1 @@\n+    }\n@@ -196,7 +241,22 @@\n-        forEachAdditionalLauncher(cmd, toBiConsumer((launcherName, propFilePath) -> {\n-            if (new PropertyFile(propFilePath).findBooleanProperty(\"launcher-as-service\").orElse(false)) {\n-                launcherNames.add(launcherName);\n-            }\n-        }));\n-\n-        return launcherNames;\n+    static boolean launcherAsService(JPackageCommand cmd, String launcherName) {\n+        if (cmd.isMainLauncher(launcherName)) {\n+            return PropertyFinder.findLauncherProperty(cmd, null,\n+                    PropertyFinder.cmdlineBooleanOption(\"--launcher-as-service\"),\n+                    PropertyFinder.nop(),\n+                    PropertyFinder.nop()\n+            ).map(Boolean::parseBoolean).orElse(false);\n+        } else {\n+            var mainLauncherValue = PropertyFinder.findLauncherProperty(cmd, null,\n+                    PropertyFinder.cmdlineBooleanOption(\"--launcher-as-service\"),\n+                    PropertyFinder.nop(),\n+                    PropertyFinder.nop()\n+            ).map(Boolean::parseBoolean).orElse(false);\n+\n+            var value = PropertyFinder.findLauncherProperty(cmd, launcherName,\n+                    PropertyFinder.nop(),\n+                    PropertyFinder.launcherPropertyFile(\"launcher-as-service\"),\n+                    PropertyFinder.appImageFileLauncher(cmd, launcherName, \"service\").defaultValue(Boolean.FALSE.toString())\n+            ).map(Boolean::parseBoolean);\n+\n+            return value.orElse(mainLauncherValue);\n+        }\n@@ -205,1 +265,3 @@\n-    private boolean canVerifyInstall(JPackageCommand cmd) throws IOException {\n+    private boolean canVerifyInstall(JPackageCommand cmd) {\n+        cmd.verifyIsOfType(SUPPORTED_PACKAGES);\n+\n@@ -224,2 +286,2 @@\n-    private void applyToMainLauncher(PackageTest pkg) {\n-        pkg.addInitializer(cmd -> {\n+    private void applyToMainLauncher(ConfigurationTarget target) {\n+        target.addInitializer(cmd -> {\n@@ -235,1 +297,1 @@\n-    private void applyToAdditionalLauncher(PackageTest pkg) {\n+    private void applyToAdditionalLauncher(ConfigurationTarget target) {\n@@ -243,1 +305,1 @@\n-        Optional.ofNullable(additionalLauncherCallback).ifPresent(v -> v.accept(al));\n+        additionalLauncherCallback.ifPresent(v -> v.accept(al));\n@@ -245,1 +307,1 @@\n-        al.applyTo(pkg);\n+        target.add(al);\n@@ -248,1 +310,1 @@\n-    private void verifyLauncherExecuted(JPackageCommand cmd) throws IOException {\n+    public void verifyLauncherExecuted(JPackageCommand cmd) {\n@@ -252,1 +314,1 @@\n-            HelloApp.assertApp(cmd.appLauncherPath())\n+            HelloApp.assertApp(cmd.appLauncherPath(launcherName))\n@@ -260,1 +322,1 @@\n-    private static void deleteOutputFile(Path file) throws IOException {\n+    private static void deleteOutputFile(Path file) {\n@@ -267,2 +329,1 @@\n-                Executor.of(\"sudo\", \"rm\", \"-f\").addArgument(file.toString()).\n-                        execute();\n+                Executor.of(\"sudo\", \"rm\", \"-f\").addArgument(file.toString()).execute();\n@@ -270,1 +331,1 @@\n-                throw ex;\n+                throw new UncheckedIOException(ex);\n@@ -272,0 +333,2 @@\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n@@ -275,1 +338,1 @@\n-    private static void verify(JPackageCommand cmd, String launcherName) throws IOException {\n+    private static void verify(JPackageCommand cmd, String launcherName, boolean launcherAsService) {\n@@ -277,1 +340,6 @@\n-            verifyLinuxUnitFile(cmd, launcherName);\n+            if (launcherAsService) {\n+                verifyLinuxUnitFile(cmd, launcherName);\n+            } else {\n+                var serviceUnitFile = LinuxHelper.getServiceUnitFilePath(cmd, launcherName);\n+                TKit.assertPathExists(serviceUnitFile, false);\n+            }\n@@ -279,1 +347,6 @@\n-            verifyMacDaemonPlistFile(cmd, launcherName);\n+            if (launcherAsService) {\n+                verifyMacDaemonPlistFile(cmd, launcherName);\n+            } else {\n+                var servicePlistFile = MacHelper.getServicePlistFilePath(cmd, launcherName);\n+                TKit.assertPathExists(servicePlistFile, false);\n+            }\n@@ -283,2 +356,1 @@\n-    private static void verifyLinuxUnitFile(JPackageCommand cmd,\n-            String launcherName) throws IOException {\n+    private static void verifyLinuxUnitFile(JPackageCommand cmd, String launcherName) {\n@@ -299,1 +371,1 @@\n-                .apply(Files.readAllLines(serviceUnitFile));\n+                .apply(ThrowingFunction.<Path, List<String>>toFunction(Files::readAllLines).apply(serviceUnitFile));\n@@ -302,2 +374,1 @@\n-    private static void verifyMacDaemonPlistFile(JPackageCommand cmd,\n-            String launcherName) throws IOException {\n+    private static void verifyMacDaemonPlistFile(JPackageCommand cmd, String launcherName) {\n@@ -351,1 +422,1 @@\n-    private final Consumer<AdditionalLauncher> additionalLauncherCallback;\n+    private final Optional<Consumer<AdditionalLauncher>> additionalLauncherCallback;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":130,"deletions":59,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -106,3 +106,1 @@\n-        final var name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n-\n-        if (name.equals(cmd.name())) {\n+        if (cmd.isMainLauncher(launcherName)) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherShortcut.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import java.util.function.Consumer;\n@@ -104,1 +103,1 @@\n-                        Optional.ofNullable(launcherName).orElseGet(cmd::name))));\n+                        Optional.ofNullable(launcherName).orElseGet(cmd::mainLauncherName))));\n@@ -374,1 +373,0 @@\n-        final var predefinedAppImage = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of).map(AppImageFile::load);\n@@ -379,1 +377,1 @@\n-                    launcherNameFromDesktopFile(cmd, predefinedAppImage, desktopFile),\n+                    launcherNameFromDesktopFile(cmd, desktopFile),\n@@ -533,1 +531,1 @@\n-    private static String launcherNameFromDesktopFile(JPackageCommand cmd, Optional<AppImageFile> predefinedAppImage, Path desktopFile) {\n+    private static String launcherNameFromDesktopFile(JPackageCommand cmd, Path desktopFile) {\n@@ -535,1 +533,0 @@\n-        Objects.requireNonNull(predefinedAppImage);\n@@ -538,5 +535,1 @@\n-        return predefinedAppImage.map(v -> {\n-            return v.launchers().keySet().stream();\n-        }).orElseGet(() -> {\n-            return Stream.concat(Stream.of(cmd.name()), cmd.addLauncherNames().stream());\n-        }).filter(name-> {\n+        return Stream.concat(Stream.of(cmd.mainLauncherName()), cmd.addLauncherNames(true).stream()).filter(name-> {\n@@ -558,1 +551,1 @@\n-        var launcherName = launcherNameFromDesktopFile(cmd, predefinedAppImage, desktopFile);\n+        var launcherName = launcherNameFromDesktopFile(cmd, desktopFile);\n@@ -888,2 +881,3 @@\n-    private static String getServiceUnitFileName(String packageName,\n-            String launcherName) {\n+    private static String getServiceUnitFileName(String packageName, String launcherName) {\n+        Objects.requireNonNull(packageName);\n+        Objects.requireNonNull(launcherName);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import java.util.function.UnaryOperator;\n@@ -665,10 +666,15 @@\n-        return cmd.getArgumentValue(\"--mac-package-identifier\", () -> {\n-            return cmd.getArgumentValue(\"--main-class\", cmd::name, className -> {\n-                var packageName = ClassDesc.of(className).packageName();\n-                if (packageName.isEmpty()) {\n-                    return className;\n-                } else {\n-                    return packageName;\n-                }\n-            });\n-        });\n+        UnaryOperator<String> getPackageIdFromClassName = className -> {\n+            var packageName = ClassDesc.of(className).packageName();\n+            if (packageName.isEmpty()) {\n+                return className;\n+            } else {\n+                return packageName;\n+            }\n+        };\n+\n+        return PropertyFinder.findAppProperty(cmd,\n+                PropertyFinder.cmdlineOptionWithValue(\"--mac-package-identifier\").or(\n+                        PropertyFinder.cmdlineOptionWithValue(\"--main-class\").map(getPackageIdFromClassName)\n+                ),\n+                PropertyFinder.appImageFile(AppImageFile::mainLauncherClassName).map(getPackageIdFromClassName)\n+        ).orElseGet(cmd::name);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -64,5 +64,3 @@\n-        if (!cmd.isRuntime()) {\n-            cmd.addLauncherNames().stream().map(cmd::appLauncherPath).forEach(launcherPath -> {\n-                assertSigned(launcherPath, certRequest);\n-            });\n-        }\n+        cmd.addLauncherNames(true).stream().map(cmd::appLauncherPath).forEach(launcherPath -> {\n+            assertSigned(launcherPath, certRequest);\n+        });\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.UnaryOperator;\n+import jdk.jpackage.test.AdditionalLauncher.PropertyFile;\n+\n+final class PropertyFinder {\n+\n+    @FunctionalInterface\n+    static interface Finder<T> {\n+        Optional<String> find(T target);\n+\n+        default Finder<T> defaultValue(String v) {\n+            return target -> {\n+                return Optional.of(find(target).orElse(v));\n+            };\n+        }\n+\n+        default Finder<T> map(UnaryOperator<String> v) {\n+            Objects.requireNonNull(v);\n+            return target -> {\n+                return find(target).map(v);\n+            };\n+        }\n+\n+        default Finder<T> or(Finder<T> other) {\n+            return target -> {\n+                return find(target).or(() -> {\n+                    return other.find(target);\n+                });\n+            };\n+        }\n+    }\n+\n+    static <T> Finder<T> nop() {\n+        return target -> {\n+            return Optional.empty();\n+        };\n+    }\n+\n+    static Finder<AppImageFile> appImageFileLauncher(JPackageCommand cmd, String launcherName, String propertyName) {\n+        Objects.requireNonNull(propertyName);\n+        if (cmd.isMainLauncher(launcherName)) {\n+            return target -> {\n+                return Optional.ofNullable(target.launchers().get(target.mainLauncherName()).get(propertyName));\n+            };\n+        } else {\n+            return target -> {\n+                return Optional.ofNullable(target.addLaunchers().get(launcherName).get(propertyName));\n+            };\n+        }\n+    }\n+\n+    static Finder<AppImageFile> appImageFile(Function<AppImageFile, String> propertyGetter) {\n+        Objects.requireNonNull(propertyGetter);\n+        return target -> {\n+            return Optional.of(propertyGetter.apply(target));\n+        };\n+    }\n+\n+    static Finder<AppImageFile> appImageFileOptional(Function<AppImageFile, Optional<String>> propertyGetter) {\n+        Objects.requireNonNull(propertyGetter);\n+        return target -> {\n+            return propertyGetter.apply(target);\n+        };\n+    }\n+\n+    static Finder<PropertyFile> launcherPropertyFile(String propertyName) {\n+        return target -> {\n+            return target.findProperty(propertyName);\n+        };\n+    }\n+\n+    static Finder<JPackageCommand> cmdlineBooleanOption(String optionName) {\n+        return target -> {\n+            return Optional.of(target.hasArgument(optionName)).map(Boolean::valueOf).map(Object::toString);\n+        };\n+    }\n+\n+    static Finder<JPackageCommand> cmdlineOptionWithValue(String optionName) {\n+        return target -> {\n+            return Optional.ofNullable(target.getArgumentValue(optionName));\n+        };\n+    }\n+\n+    static Optional<String> findAppProperty(\n+            JPackageCommand cmd,\n+            Finder<JPackageCommand> cmdlineFinder,\n+            Finder<AppImageFile> appImageFileFinder) {\n+\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(cmdlineFinder);\n+        Objects.requireNonNull(appImageFileFinder);\n+\n+        var reply = cmdlineFinder.find(cmd);\n+        if (reply.isPresent()) {\n+            return reply;\n+        } else {\n+            var appImageFilePath = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of);\n+            return appImageFilePath.map(AppImageFile::load).flatMap(appImageFileFinder::find);\n+        }\n+    }\n+\n+    static Optional<String> findLauncherProperty(\n+            JPackageCommand cmd,\n+            String launcherName,\n+            Finder<JPackageCommand> cmdlineFinder,\n+            Finder<PropertyFile> addLauncherPropertyFileFinder,\n+            Finder<AppImageFile> appImageFileFinder) {\n+\n+        Objects.requireNonNull(cmd);\n+        Objects.requireNonNull(cmdlineFinder);\n+        Objects.requireNonNull(addLauncherPropertyFileFinder);\n+        Objects.requireNonNull(appImageFileFinder);\n+\n+        var mainLauncher = cmd.isMainLauncher(launcherName);\n+\n+        var appImageFilePath = Optional.ofNullable(cmd.getArgumentValue(\"--app-image\")).map(Path::of);\n+\n+        Optional<String> reply;\n+\n+        if (mainLauncher) {\n+            reply = cmdlineFinder.find(cmd);\n+        } else if (appImageFilePath.isEmpty()) {\n+            var props = getAdditionalLauncherProperties(cmd, launcherName);\n+            reply = addLauncherPropertyFileFinder.find(props);\n+        } else {\n+            reply = Optional.empty();\n+        }\n+\n+        if (reply.isPresent()) {\n+            return reply;\n+        } else {\n+            return appImageFilePath.map(AppImageFile::load).flatMap(appImageFileFinder::find);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PropertyFinder.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -317,2 +317,5 @@\n-        ThrowingRunnable.toRunnable(() -> Files.write(filename,\n-                lines.peek(TKit::trace).collect(Collectors.toList()))).run();\n+        try {\n+            Files.write(filename, lines.peek(TKit::trace).toList());\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n@@ -326,3 +329,7 @@\n-        ThrowingRunnable.toRunnable(() -> Files.write(propsFilename,\n-                props.stream().map(e -> String.join(\"=\", e.getKey(),\n-                e.getValue())).peek(TKit::trace).collect(Collectors.toList()))).run();\n+        try {\n+            Files.write(propsFilename, props.stream().map(e -> {\n+                return String.join(\"=\", e.getKey(), e.getValue());\n+            }).peek(TKit::trace).toList());\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n@@ -332,1 +339,1 @@\n-    public static void traceFileContents(Path path, String label) throws IOException {\n+    public static void traceFileContents(Path path, String label) {\n@@ -335,1 +342,5 @@\n-        Files.readAllLines(path).forEach(TKit::trace);\n+        try {\n+            Files.readAllLines(path).forEach(TKit::trace);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import static java.util.stream.Collectors.toUnmodifiableMap;\n@@ -35,1 +36,0 @@\n-import java.util.HashMap;\n@@ -54,1 +54,1 @@\n-        if (Stream.of(\"--win-menu\", \"--win-shortcut\").noneMatch(cmd::hasArgument) && cmd.addLauncherNames().isEmpty()) {\n+        if (Stream.of(\"--win-menu\", \"--win-shortcut\").noneMatch(cmd::hasArgument) && cmd.addLauncherNames(true).isEmpty()) {\n@@ -173,1 +173,1 @@\n-        var name = Optional.ofNullable(launcherName).orElseGet(cmd::name);\n+        var name = Optional.ofNullable(launcherName).orElseGet(cmd::mainLauncherName);\n@@ -253,1 +253,0 @@\n-        Map<String, Collection<Shortcut>> expectedShortcuts = new HashMap<>();\n@@ -257,5 +256,3 @@\n-        predefinedAppImage.map(v -> {\n-            return v.launchers().keySet().stream();\n-        }).orElseGet(() -> {\n-            return Stream.concat(Stream.of(cmd.name()), cmd.addLauncherNames().stream());\n-        }).forEach(launcherName -> {\n+        return cmd.launcherNames(true).stream().map(launcherName -> {\n+            return Optional.ofNullable(launcherName).orElseGet(cmd::mainLauncherName);\n+        }).map(launcherName -> {\n@@ -263,2 +260,4 @@\n-            if (!shortcuts.isEmpty()) {\n-                expectedShortcuts.put(launcherName, shortcuts);\n+            if (shortcuts.isEmpty()) {\n+                return null;\n+            } else {\n+                return Map.entry(launcherName, shortcuts);\n@@ -266,3 +265,1 @@\n-        });\n-\n-        return expectedShortcuts;\n+        }).filter(Objects::nonNull).collect(toUnmodifiableMap(Map.Entry::getKey, Map.Entry::getValue));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WinShortcutVerifier.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import static jdk.jpackage.test.PackageType.MAC_DMG;\n+import static jdk.jpackage.test.PackageType.WINDOWS;\n+\n@@ -25,0 +28,1 @@\n+import java.io.UncheckedIOException;\n@@ -27,0 +31,1 @@\n+import java.util.HexFormat;\n@@ -28,0 +33,1 @@\n+import java.util.function.Consumer;\n@@ -29,1 +35,2 @@\n-import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.AdditionalLauncher;\n+import jdk.jpackage.test.Annotations.Parameter;\n@@ -31,0 +38,1 @@\n+import jdk.jpackage.test.ConfigurationTarget;\n@@ -34,2 +42,2 @@\n-import static jdk.jpackage.test.PackageType.MAC_DMG;\n-import static jdk.jpackage.test.PackageType.WINDOWS;\n+import jdk.jpackage.test.LauncherVerifier.Action;\n+import jdk.jpackage.test.PackageTest;\n@@ -50,0 +58,1 @@\n+ * @requires (jpackage.test.SQETest != null)\n@@ -51,1 +60,14 @@\n- * @run main\/othervm\/timeout=360 -Xmx512m\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n+ *  jdk.jpackage.test.Main\n+ *  --jpt-run=ServiceTest.test,ServiceTest.testUpdate\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Launcher as service packaging test\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @key jpackagePlatformPackage\n+ * @requires (jpackage.test.SQETest == null)\n+ * @compile -Xlint:all -Werror ServiceTest.java\n+ * @run main\/othervm\/timeout=2880 -Xmx512m\n@@ -55,0 +77,1 @@\n+\n@@ -89,1 +112,0 @@\n-        var testInitializer = createTestInitializer();\n@@ -92,1 +114,1 @@\n-        testInitializer.applyTo(pkg);\n+        createTestInitializer().applyTo(pkg);\n@@ -135,0 +157,102 @@\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testAddL(boolean mainLauncherAsService) {\n+\n+        final var uniqueOutputFile = uniqueOutputFile();\n+\n+        createPackageTest()\n+                .addHelloAppInitializer(\"com.buz.AddLaunchersServiceTest\")\n+                .mutate(test -> {\n+                    if (mainLauncherAsService) {\n+                        LauncherAsServiceVerifier.build()\n+                                .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-\")\n+                                .setExpectedValue(\"Main\").applyTo(test);\n+                    }\n+                })\n+                \/\/ Regular launcher. The installer should not automatically execute it.\n+                .mutate(new AdditionalLauncher(\"notservice\")\n+                        .withoutVerifyActions(Action.EXECUTE_LAUNCHER)\n+                        .setProperty(\"launcher-as-service\", Boolean.FALSE)\n+                        .addJavaOptions(\"-Djpackage.test.noexit=true\")::applyTo)\n+                \/\/ Additional launcher with explicit \"launcher-as-service=true\" property in the property file.\n+                .mutate(LauncherAsServiceVerifier.build()\n+                        .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-A1-\")\n+                        .setLauncherName(\"AL1\")\n+                        .setExpectedValue(\"AL1\")::applyTo)\n+                .mutate(test -> {\n+                    if (mainLauncherAsService) {\n+                        \/\/ Additional launcher without \"launcher-as-service\" property in the property file.\n+                        \/\/ Still, should be installed as a service.\n+                        LauncherAsServiceVerifier.build()\n+                                .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-A2-\")\n+                                .setLauncherName(\"AL2\")\n+                                .setExpectedValue(\"AL2\")\n+                                .setAdditionalLauncherCallback(al -> {\n+                                    al.removeProperty(\"launcher-as-service\");\n+                                })\n+                                .applyTo(test);\n+                    }\n+                })\n+                .mutate(createTestInitializer()::applyTo)\n+                .run();\n+        }\n+\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testAddLFromAppImage(boolean mainLauncherAsService) {\n+\n+        var uniqueOutputFile = uniqueOutputFile();\n+\n+        var appImageCmd = new ConfigurationTarget(JPackageCommand.helloAppImage(\"com.bar.AddLaunchersFromAppImageServiceTest\"));\n+\n+        if (RunnablePackageTest.hasAction(RunnablePackageTest.Action.INSTALL)) {\n+            \/\/ Ensure launchers are executable because the output bundle will be installed\n+            \/\/ and we want to verify launchers are automatically started by the installer.\n+            appImageCmd.addInitializer(JPackageCommand::ignoreFakeRuntime);\n+        }\n+\n+        if (mainLauncherAsService) {\n+            LauncherAsServiceVerifier.build()\n+                    .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-\")\n+                    .setExpectedValue(\"Main\")\n+                    .applyTo(appImageCmd);\n+            \/\/ Can not use \"--launcher-as-service\" option with app image packaging.\n+            appImageCmd.cmd().orElseThrow().removeArgument(\"--launcher-as-service\");\n+        } else {\n+            appImageCmd.addInitializer(cmd -> {\n+                \/\/ Configure the main launcher to hang at the end of the execution.\n+                \/\/ The main launcher should not be executed in this test.\n+                \/\/ If it is executed, it indicates it was started as a service,\n+                \/\/ which must fail the test. The launcher's hang-up will be the event failing the test.\n+                cmd.addArguments(\"--java-options\", \"-Djpackage.test.noexit=true\");\n+            });\n+        }\n+\n+        \/\/ Additional launcher with explicit \"launcher-as-service=true\" property in the property file.\n+        LauncherAsServiceVerifier.build()\n+                .mutate(uniqueOutputFile).appendAppOutputFileNamePrefix(\"-A1-\")\n+                .setLauncherName(\"AL1\")\n+                .setExpectedValue(\"AL1\").applyTo(appImageCmd);\n+\n+        \/\/ Regular launcher. The installer should not automatically execute it.\n+        appImageCmd.add(new AdditionalLauncher(\"notservice\")\n+                .withoutVerifyActions(Action.EXECUTE_LAUNCHER)\n+                .addJavaOptions(\"-Djpackage.test.noexit=true\"));\n+\n+        new PackageTest().excludeTypes(MAC_DMG)\n+                .addRunOnceInitializer(appImageCmd.cmd().orElseThrow()::execute)\n+                .addInitializer(cmd -> {\n+                    cmd.removeArgumentWithValue(\"--input\");\n+                    cmd.addArguments(\"--app-image\", appImageCmd.cmd().orElseThrow().outputBundle());\n+                })\n+                .addInitializer(cmd -> {\n+                    if (mainLauncherAsService) {\n+                        cmd.addArgument(\"--launcher-as-service\");\n+                    }\n+                })\n+                .mutate(createTestInitializer()::applyTo)\n+                .run();\n+    }\n+\n@@ -142,1 +266,1 @@\n-        void applyTo(PackageTest test) throws IOException {\n+        void applyTo(PackageTest test) {\n@@ -145,2 +269,5 @@\n-                Files.copy(winServiceInstaller, resourceDir.resolve(\n-                        \"service-installer.exe\"));\n+                try {\n+                    Files.copy(winServiceInstaller, resourceDir.resolve(\"service-installer.exe\"));\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n@@ -168,1 +295,1 @@\n-        return new PackageTest()\n+        var test = new PackageTest()\n@@ -171,0 +298,19 @@\n+        if (RunnablePackageTest.hasAction(RunnablePackageTest.Action.INSTALL)) {\n+            \/\/ Ensure launchers are executable because the output bundle will be installed\n+            \/\/ and we want to verify launchers are automatically started by the installer.\n+            test.addInitializer(JPackageCommand::ignoreFakeRuntime);\n+        }\n+        return test;\n+    }\n+\n+    private static Consumer<LauncherAsServiceVerifier.Builder> uniqueOutputFile() {\n+        var prefix = uniquePrefix();\n+        return builder -> {\n+            builder.setAppOutputFileNamePrefixToAppName()\n+                    .appendAppOutputFileNamePrefix(\"-\")\n+                    .appendAppOutputFileNamePrefix(prefix);\n+        };\n+    }\n+\n+    private static String uniquePrefix() {\n+        return HexFormat.of().toHexDigits(System.currentTimeMillis());\n","filename":"test\/jdk\/tools\/jpackage\/share\/ServiceTest.java","additions":156,"deletions":10,"binary":false,"changes":166,"status":"modified"}]}