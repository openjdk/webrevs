{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,12 @@\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.ConstantValueEntry;\n+import java.lang.classfile.constantpool.IntegerEntry;\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -91,57 +103,0 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Annotation;\n-import com.sun.tools.classfile.Annotation.Annotation_element_value;\n-import com.sun.tools.classfile.Annotation.Array_element_value;\n-import com.sun.tools.classfile.Annotation.Class_element_value;\n-import com.sun.tools.classfile.Annotation.Enum_element_value;\n-import com.sun.tools.classfile.Annotation.Primitive_element_value;\n-import com.sun.tools.classfile.Annotation.element_value;\n-import com.sun.tools.classfile.Annotation.element_value_pair;\n-import com.sun.tools.classfile.AnnotationDefault_attribute;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Double_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Float_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Integer_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Long_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Module_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Package_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_String_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.ConstantPool.InvalidIndex;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.ConstantValue_attribute;\n-import com.sun.tools.classfile.Deprecated_attribute;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Exceptions_attribute;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.InnerClasses_attribute;\n-import com.sun.tools.classfile.InnerClasses_attribute.Info;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.ModulePackages_attribute;\n-import com.sun.tools.classfile.MethodParameters_attribute;\n-import com.sun.tools.classfile.ModuleMainClass_attribute;\n-import com.sun.tools.classfile.ModuleResolution_attribute;\n-import com.sun.tools.classfile.ModuleTarget_attribute;\n-import com.sun.tools.classfile.Module_attribute;\n-import com.sun.tools.classfile.Module_attribute.ExportsEntry;\n-import com.sun.tools.classfile.Module_attribute.OpensEntry;\n-import com.sun.tools.classfile.Module_attribute.ProvidesEntry;\n-import com.sun.tools.classfile.Module_attribute.RequiresEntry;\n-import com.sun.tools.classfile.NestHost_attribute;\n-import com.sun.tools.classfile.NestMembers_attribute;\n-import com.sun.tools.classfile.PermittedSubclasses_attribute;\n-import com.sun.tools.classfile.Record_attribute;\n-import com.sun.tools.classfile.Record_attribute.ComponentInfo;\n-import com.sun.tools.classfile.RuntimeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.Signature_attribute;\n@@ -157,0 +112,3 @@\n+import static java.lang.classfile.ClassFile.ACC_PROTECTED;\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+\n@@ -162,2 +120,1 @@\n- *  * <jdk-N>\/bin\/java --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED \\\n- *                     --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n+ *  * <jdk-N>\/bin\/java --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n@@ -412,1 +369,1 @@\n-                            throw new IllegalStateException(\"Unknown key: \" + reader.lineKey);\n+                            throw new IllegalArgumentException(\"Unknown key: \" + reader.lineKey);\n@@ -435,1 +392,1 @@\n-                        throw new IllegalStateException(\"Unknown key: \" + reader.lineKey);\n+                        throw new IllegalArgumentException(\"Unknown key: \" + reader.lineKey);\n@@ -833,24 +790,4 @@\n-        List<CPInfo> constantPool = new ArrayList<>();\n-        constantPool.add(null);\n-        int currentClass = addClass(constantPool, \"module-info\");\n-        int superclass = 0;\n-        int[] interfaces = new int[0];\n-        AccessFlags flags = new AccessFlags(header.flags);\n-        Map<String, Attribute> attributesMap = new HashMap<>();\n-        String versionString = Character.toString(version);\n-        addAttributes(moduleDescription, header, constantPool, attributesMap,\n-                      version2ModuleVersion.apply(version));\n-        Attributes attributes = new Attributes(attributesMap);\n-        CPInfo[] cpData = constantPool.toArray(new CPInfo[constantPool.size()]);\n-        ConstantPool cp = new ConstantPool(cpData);\n-        ClassFile classFile = new ClassFile(0xCAFEBABE,\n-                Target.DEFAULT.minorVersion,\n-                Target.DEFAULT.majorVersion,\n-                cp,\n-                flags,\n-                currentClass,\n-                superclass,\n-                interfaces,\n-                new Field[0],\n-                new Method[0],\n-                attributes);\n+        var classFile = ClassFile.of().build(ClassDesc.of(\"module-info\"), clb -> {\n+            clb.withFlags(header.flags);\n+            addAttributes(moduleDescription, header, clb, version2ModuleVersion.apply(version));\n+        });\n@@ -858,0 +795,1 @@\n+        String versionString = Character.toString(version);\n@@ -866,51 +804,20 @@\n-        List<CPInfo> constantPool = new ArrayList<>();\n-        constantPool.add(null);\n-        List<Method> methods = new ArrayList<>();\n-        for (MethodDescription methDesc : classDescription.methods) {\n-            if (disjoint(methDesc.versions, version))\n-                continue;\n-            Descriptor descriptor = new Descriptor(addString(constantPool, methDesc.descriptor));\n-            \/\/TODO: LinkedHashMap to avoid param annotations vs. Signature problem in javac's ClassReader:\n-            Map<String, Attribute> attributesMap = new LinkedHashMap<>();\n-            addAttributes(methDesc, constantPool, attributesMap);\n-            Attributes attributes = new Attributes(attributesMap);\n-            AccessFlags flags = new AccessFlags(methDesc.flags);\n-            int nameString = addString(constantPool, methDesc.name);\n-            methods.add(new Method(flags, nameString, descriptor, attributes));\n-        }\n-        List<Field> fields = new ArrayList<>();\n-        for (FieldDescription fieldDesc : classDescription.fields) {\n-            if (disjoint(fieldDesc.versions, version))\n-                continue;\n-            Descriptor descriptor = new Descriptor(addString(constantPool, fieldDesc.descriptor));\n-            Map<String, Attribute> attributesMap = new HashMap<>();\n-            addAttributes(fieldDesc, constantPool, attributesMap);\n-            Attributes attributes = new Attributes(attributesMap);\n-            AccessFlags flags = new AccessFlags(fieldDesc.flags);\n-            int nameString = addString(constantPool, fieldDesc.name);\n-            fields.add(new Field(flags, nameString, descriptor, attributes));\n-        }\n-        int currentClass = addClass(constantPool, classDescription.name);\n-        int superclass = header.extendsAttr != null ? addClass(constantPool, header.extendsAttr) : 0;\n-        int[] interfaces = new int[header.implementsAttr.size()];\n-        int i = 0;\n-        for (String intf : header.implementsAttr) {\n-            interfaces[i++] = addClass(constantPool, intf);\n-        }\n-        AccessFlags flags = new AccessFlags(header.flags);\n-        Map<String, Attribute> attributesMap = new HashMap<>();\n-        addAttributes(header, constantPool, attributesMap);\n-        Attributes attributes = new Attributes(attributesMap);\n-        ConstantPool cp = new ConstantPool(constantPool.toArray(new CPInfo[constantPool.size()]));\n-        ClassFile classFile = new ClassFile(0xCAFEBABE,\n-                Target.DEFAULT.minorVersion,\n-                Target.DEFAULT.majorVersion,\n-                cp,\n-                flags,\n-                currentClass,\n-                superclass,\n-                interfaces,\n-                fields.toArray(new Field[0]),\n-                methods.toArray(new Method[0]),\n-                attributes);\n-\n+        var classFile = ClassFile.of().build(ClassDesc.ofInternalName(classDescription.name), clb -> {\n+            if (header.extendsAttr != null)\n+                clb.withSuperclass(ClassDesc.ofInternalName(header.extendsAttr));\n+            clb.withInterfaceSymbols(header.implementsAttr.stream().map(ClassDesc::ofInternalName).collect(Collectors.toList()))\n+                    .withFlags(header.flags);\n+            for (FieldDescription fieldDesc : classDescription.fields) {\n+                if (disjoint(fieldDesc.versions, version))\n+                    continue;\n+                clb.withField(fieldDesc.name, ClassDesc.ofDescriptor(fieldDesc.descriptor), fb -> {\n+                    addAttributes(fieldDesc, fb);\n+                    fb.withFlags(fieldDesc.flags);\n+                });\n+            }\n+            for (MethodDescription methDesc : classDescription.methods) {\n+                if (disjoint(methDesc.versions, version))\n+                    continue;\n+                clb.withMethod(methDesc.name, MethodTypeDesc.ofDescriptor(methDesc.descriptor), methDesc.flags, mb -> addAttributes(methDesc, mb));\n+            }\n+            addAttributes(header, clb);\n+        });\n@@ -924,1 +831,1 @@\n-                         ClassFile classFile) throws IOException {\n+                         byte[] classFile) throws IOException {\n@@ -929,8 +836,2 @@\n-        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n-            ClassWriter w = new ClassWriter();\n-\n-            w.write(classFile, out);\n-\n-            openDirectory(directory2FileData, directory)\n-                .add(new FileData(fullFileName, out.toByteArray()));\n-        }\n+        openDirectory(directory2FileData, directory)\n+                .add(new FileData(fullFileName, classFile));\n@@ -958,2 +859,1 @@\n-                               List<CPInfo> cp,\n-                               Map<String, Attribute> attributes,\n+                               ClassBuilder builder,\n@@ -961,1 +861,1 @@\n-        addGenericAttributes(header, cp, attributes);\n+        addGenericAttributes(header, builder);\n@@ -963,5 +863,1 @@\n-            int attrIdx = addString(cp, Attribute.ModuleResolution);\n-            final ModuleResolution_attribute resIdx =\n-                    new ModuleResolution_attribute(attrIdx,\n-                                                   header.moduleResolution);\n-            attributes.put(Attribute.ModuleResolution, resIdx);\n+            builder.with(ModuleResolutionAttribute.of(header.moduleResolution));\n@@ -970,4 +866,1 @@\n-            int attrIdx = addString(cp, Attribute.ModuleTarget);\n-            int targetIdx = addString(cp, header.moduleTarget);\n-            attributes.put(Attribute.ModuleTarget,\n-                           new ModuleTarget_attribute(attrIdx, targetIdx));\n+            builder.with(ModuleTargetAttribute.of(header.moduleTarget));\n@@ -976,58 +869,1 @@\n-            int attrIdx = addString(cp, Attribute.ModuleMainClass);\n-            int targetIdx = addClassName(cp, header.moduleMainClass);\n-            attributes.put(Attribute.ModuleMainClass,\n-                           new ModuleMainClass_attribute(attrIdx, targetIdx));\n-        }\n-        int versionIdx = addString(cp, moduleVersion);\n-        int attrIdx = addString(cp, Attribute.Module);\n-        attributes.put(Attribute.Module,\n-                       new Module_attribute(attrIdx,\n-                             addModuleName(cp, md.name),\n-                             0,\n-                             versionIdx,\n-                             header.requires\n-                                   .stream()\n-                                   .map(r -> createRequiresEntry(cp, r))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new RequiresEntry[0]),\n-                             header.exports\n-                                   .stream()\n-                                   .map(e -> createExportsEntry(cp, e))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new ExportsEntry[0]),\n-                             header.opens\n-                                   .stream()\n-                                   .map(e -> createOpensEntry(cp, e))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new OpensEntry[0]),\n-                             header.uses\n-                                   .stream()\n-                                   .mapToInt(u -> addClassName(cp, u))\n-                                   .toArray(),\n-                             header.provides\n-                                   .stream()\n-                                   .map(p -> createProvidesEntry(cp, p))\n-                                   .collect(Collectors.toList())\n-                                   .toArray(new ProvidesEntry[0])));\n-        addInnerClassesAttribute(header, cp, attributes);\n-    }\n-\n-    private static RequiresEntry createRequiresEntry(List<CPInfo> cp,\n-            RequiresDescription r) {\n-        final int idx = addModuleName(cp, r.moduleName);\n-        return new RequiresEntry(idx,\n-                                 r.flags,\n-                                 r.version != null\n-                                         ? addString(cp, r.version)\n-                                         : 0);\n-    }\n-\n-    private static ExportsEntry createExportsEntry(List<CPInfo> cp,\n-                                                   ExportsDescription export) {\n-        int[] to;\n-        if (export.isQualified()) {\n-            to = export.to.stream()\n-                          .mapToInt(module -> addModuleName(cp, module))\n-                          .toArray();\n-        } else {\n-            to = new int[0];\n+            builder.with(ModuleMainClassAttribute.of(ClassDesc.ofInternalName(header.moduleMainClass)));\n@@ -1035,14 +871,24 @@\n-        return new ExportsEntry(addPackageName(cp, export.packageName()), 0, to);\n-    }\n-\n-    private static OpensEntry createOpensEntry(List<CPInfo> cp, String e) {\n-        return new OpensEntry(addPackageName(cp, e), 0, new int[0]);\n-    }\n-\n-    private static ProvidesEntry createProvidesEntry(List<CPInfo> cp,\n-            ModuleHeaderDescription.ProvidesDescription p) {\n-        final int idx = addClassName(cp, p.interfaceName);\n-        return new ProvidesEntry(idx, p.implNames\n-                                       .stream()\n-                                       .mapToInt(i -> addClassName(cp, i))\n-                                       .toArray());\n+        builder.with(ModuleAttribute.of(ModuleDesc.of(md.name), mb -> {\n+            mb.moduleVersion(moduleVersion);\n+            for (var req : header.requires) {\n+                mb.requires(ModuleDesc.of(req.moduleName), req.flags, req.version); \/\/ nullable version\n+            }\n+            for (var exp : header.exports) {\n+                if (exp.isQualified()) {\n+                    mb.exports(PackageDesc.ofInternalName(exp.packageName()), 0, exp.to.stream().map(ModuleDesc::of).toArray(ModuleDesc[]::new));\n+                } else {\n+                    mb.exports(PackageDesc.ofInternalName(exp.packageName()), 0);\n+                }\n+            }\n+            for (var open : header.opens) {\n+                mb.opens(PackageDesc.ofInternalName(open), 0);\n+            }\n+            for (var use : header.uses) {\n+                mb.uses(ClassDesc.ofInternalName(use));\n+            }\n+            for (var provide : header.provides) {\n+                mb.provides(ClassDesc.ofInternalName(provide.interfaceName),\n+                        provide.implNames.stream().map(ClassDesc::ofInternalName).toArray(ClassDesc[]::new));\n+            }\n+        }));\n+        addInnerClassesAttribute(header, builder);\n@@ -1051,3 +897,2 @@\n-    private void addAttributes(ClassHeaderDescription header,\n-            List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n-        addGenericAttributes(header, constantPool, attributes);\n+    private void addAttributes(ClassHeaderDescription header, ClassBuilder builder) {\n+        addGenericAttributes(header, builder);\n@@ -1055,4 +900,1 @@\n-            int attributeString = addString(constantPool, Attribute.NestHost);\n-            int nestHost = addClass(constantPool, header.nestHost);\n-            attributes.put(Attribute.NestHost,\n-                           new NestHost_attribute(attributeString, nestHost));\n+            builder.with(NestHostAttribute.of(ClassDesc.ofInternalName(header.nestHost)));\n@@ -1061,8 +903,1 @@\n-            int attributeString = addString(constantPool, Attribute.NestMembers);\n-            int[] nestMembers = new int[header.nestMembers.size()];\n-            int i = 0;\n-            for (String intf : header.nestMembers) {\n-                nestMembers[i++] = addClass(constantPool, intf);\n-            }\n-            attributes.put(Attribute.NestMembers,\n-                           new NestMembers_attribute(attributeString, nestMembers));\n+            builder.with(NestMembersAttribute.ofSymbols(header.nestMembers.stream().map(ClassDesc::ofInternalName).collect(Collectors.toList())));\n@@ -1071,14 +906,5 @@\n-            assert header.recordComponents != null;\n-            int attributeString = addString(constantPool, Attribute.Record);\n-            ComponentInfo[] recordComponents = new ComponentInfo[header.recordComponents.size()];\n-            int i = 0;\n-            for (RecordComponentDescription rcd : header.recordComponents) {\n-                int name = addString(constantPool, rcd.name);\n-                Descriptor desc = new Descriptor(addString(constantPool, rcd.descriptor));\n-                Map<String, Attribute> nestedAttrs = new HashMap<>();\n-                addGenericAttributes(rcd, constantPool, nestedAttrs);\n-                Attributes attrs = new Attributes(nestedAttrs);\n-                recordComponents[i++] = new ComponentInfo(name, desc, attrs);\n-            }\n-            attributes.put(Attribute.Record,\n-                           new Record_attribute(attributeString, recordComponents));\n+            builder.with(RecordAttribute.of(header.recordComponents.stream().map(desc -> {\n+                List<Attribute<?>> attributes = new ArrayList<>();\n+                addGenericAttributes(desc, attributes::add, builder.constantPool());\n+                return RecordComponentInfo.of(desc.name, ClassDesc.ofDescriptor(desc.descriptor), attributes);\n+            }).collect(Collectors.toList())));\n@@ -1087,8 +913,1 @@\n-            int attributeString = addString(constantPool, Attribute.PermittedSubclasses);\n-            int[] subclasses = new int[header.permittedSubclasses.size()];\n-            int i = 0;\n-            for (String intf : header.permittedSubclasses) {\n-                subclasses[i++] = addClass(constantPool, intf);\n-            }\n-            attributes.put(Attribute.PermittedSubclasses,\n-                    new PermittedSubclasses_attribute(attributeString, subclasses));\n+            builder.with(PermittedSubclassesAttribute.ofSymbols(header.permittedSubclasses.stream().map(ClassDesc::ofInternalName).collect(Collectors.toList())));\n@@ -1096,1 +915,1 @@\n-        addInnerClassesAttribute(header, constantPool, attributes);\n+        addInnerClassesAttribute(header, builder);\n@@ -1099,2 +918,1 @@\n-    private void addInnerClassesAttribute(HeaderDescription header,\n-            List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n+    private void addInnerClassesAttribute(HeaderDescription header, ClassBuilder builder) {\n@@ -1102,12 +920,7 @@\n-            Info[] innerClasses = new Info[header.innerClasses.size()];\n-            int i = 0;\n-            for (InnerClassInfo info : header.innerClasses) {\n-                innerClasses[i++] =\n-                        new Info(info.innerClass == null ? 0 : addClass(constantPool, info.innerClass),\n-                                 info.outerClass == null ? 0 : addClass(constantPool, info.outerClass),\n-                                 info.innerClassName == null ? 0 : addString(constantPool, info.innerClassName),\n-                                 new AccessFlags(info.innerClassFlags));\n-            }\n-            int attributeString = addString(constantPool, Attribute.InnerClasses);\n-            attributes.put(Attribute.InnerClasses,\n-                           new InnerClasses_attribute(attributeString, innerClasses));\n+            builder.with(InnerClassesAttribute.of(header.innerClasses.stream()\n+                    .map(info -> java.lang.classfile.attribute.InnerClassInfo.of(\n+                            ClassDesc.ofInternalName(info.innerClass),\n+                            Optional.ofNullable(info.outerClass).map(ClassDesc::ofInternalName),\n+                            Optional.ofNullable(info.innerClassName),\n+                            info.innerClassFlags\n+                    )).collect(Collectors.toList())));\n@@ -1117,2 +930,2 @@\n-    private void addAttributes(MethodDescription desc, List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n-        addGenericAttributes(desc, constantPool, attributes);\n+    private void addAttributes(MethodDescription desc, MethodBuilder builder) {\n+        addGenericAttributes(desc, builder);\n@@ -1120,8 +933,2 @@\n-            int[] exceptions = new int[desc.thrownTypes.size()];\n-            int i = 0;\n-            for (String exc : desc.thrownTypes) {\n-                exceptions[i++] = addClass(constantPool, exc);\n-            }\n-            int attributeString = addString(constantPool, Attribute.Exceptions);\n-            attributes.put(Attribute.Exceptions,\n-                           new Exceptions_attribute(attributeString, exceptions));\n+            builder.with(ExceptionsAttribute.ofSymbols(desc.thrownTypes.stream()\n+                    .map(ClassDesc::ofInternalName).collect(Collectors.toList())));\n@@ -1130,5 +937,1 @@\n-            int attributeString = addString(constantPool, Attribute.AnnotationDefault);\n-            element_value attributeValue = createAttributeValue(constantPool,\n-                                                                desc.annotationDefaultValue);\n-            attributes.put(Attribute.AnnotationDefault,\n-                           new AnnotationDefault_attribute(attributeString, attributeValue));\n+            builder.with(AnnotationDefaultAttribute.of(createAttributeValue(desc.annotationDefaultValue)));\n@@ -1137,7 +940,1 @@\n-            int attributeString =\n-                    addString(constantPool, Attribute.RuntimeInvisibleParameterAnnotations);\n-            Annotation[][] annotations =\n-                    createParameterAnnotations(constantPool, desc.classParameterAnnotations);\n-            attributes.put(Attribute.RuntimeInvisibleParameterAnnotations,\n-                           new RuntimeInvisibleParameterAnnotations_attribute(attributeString,\n-                                   annotations));\n+            builder.with(RuntimeInvisibleParameterAnnotationsAttribute.of(createParameterAnnotations(desc.classParameterAnnotations)));\n@@ -1146,7 +943,1 @@\n-            int attributeString =\n-                    addString(constantPool, Attribute.RuntimeVisibleParameterAnnotations);\n-            Annotation[][] annotations =\n-                    createParameterAnnotations(constantPool, desc.runtimeParameterAnnotations);\n-            attributes.put(Attribute.RuntimeVisibleParameterAnnotations,\n-                           new RuntimeVisibleParameterAnnotations_attribute(attributeString,\n-                                   annotations));\n+            builder.with(RuntimeVisibleParameterAnnotationsAttribute.of(createParameterAnnotations(desc.runtimeParameterAnnotations)));\n@@ -1155,11 +946,2 @@\n-            int attributeString =\n-                    addString(constantPool, Attribute.MethodParameters);\n-            MethodParameters_attribute.Entry[] entries =\n-                    desc.methodParameters\n-                        .stream()\n-                        .map(p -> new MethodParameters_attribute.Entry(p.name == null || p.name.isEmpty() ? 0\n-                                                                                                          : addString(constantPool, p.name),\n-                                                                       p.flags))\n-                        .toArray(s -> new MethodParameters_attribute.Entry[s]);\n-            attributes.put(Attribute.MethodParameters,\n-                           new MethodParameters_attribute(attributeString, entries));\n+            builder.with(MethodParametersAttribute.of(desc.methodParameters.stream()\n+                    .map(mp -> MethodParameterInfo.ofParameter(Optional.ofNullable(mp.name), mp.flags)).collect(Collectors.toList())));\n@@ -1169,2 +951,2 @@\n-    private void addAttributes(FieldDescription desc, List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n-        addGenericAttributes(desc, constantPool, attributes);\n+    private void addAttributes(FieldDescription desc, FieldBuilder builder) {\n+        addGenericAttributes(desc, builder);\n@@ -1172,6 +954,12 @@\n-            Pair<Integer, Character> constantPoolEntry =\n-                    addConstant(constantPool, desc.constantValue, false);\n-            Assert.checkNonNull(constantPoolEntry);\n-            int constantValueString = addString(constantPool, Attribute.ConstantValue);\n-            attributes.put(Attribute.ConstantValue,\n-                           new ConstantValue_attribute(constantValueString, constantPoolEntry.fst));\n+            var cp = builder.constantPool();\n+            ConstantValueEntry entry = switch (desc.constantValue) {\n+                case Boolean v -> cp.intEntry(v ? 1 : 0);\n+                case Character v -> cp.intEntry(v);\n+                case Integer v -> cp.intEntry(v);\n+                case Long v -> cp.longEntry(v);\n+                case Float v -> cp.floatEntry(v);\n+                case Double v -> cp.doubleEntry(v);\n+                case String v -> cp.stringEntry(v);\n+                default -> throw new IllegalArgumentException(desc.constantValue.getClass().toString());\n+            };\n+            builder.with(ConstantValueAttribute.of(entry));\n@@ -1181,1 +969,8 @@\n-    private void addGenericAttributes(FeatureDescription desc, List<CPInfo> constantPool, Map<String, Attribute> attributes) {\n+    @SuppressWarnings(\"unchecked\")\n+    private void addGenericAttributes(FeatureDescription desc, ClassFileBuilder<?, ?> builder) {\n+        addGenericAttributes(desc, (Consumer<? super Attribute<?>>) builder, builder.constantPool());\n+    }\n+\n+    private void addGenericAttributes(FeatureDescription desc, Consumer<? super Attribute<?>> sink, ConstantPoolBuilder cpb) {\n+        @SuppressWarnings(\"unchecked\")\n+        var builder = (Consumer<Attribute<?>>) sink;\n@@ -1183,3 +978,1 @@\n-            int attributeString = addString(constantPool, Attribute.Deprecated);\n-            attributes.put(Attribute.Deprecated,\n-                           new Deprecated_attribute(attributeString));\n+            builder.accept(DeprecatedAttribute.of());\n@@ -1188,4 +981,1 @@\n-            int attributeString = addString(constantPool, Attribute.Signature);\n-            int signatureString = addString(constantPool, desc.signature);\n-            attributes.put(Attribute.Signature,\n-                           new Signature_attribute(attributeString, signatureString));\n+            builder.accept(SignatureAttribute.of(cpb.utf8Entry(desc.signature)));\n@@ -1194,4 +984,1 @@\n-            int attributeString = addString(constantPool, Attribute.RuntimeInvisibleAnnotations);\n-            Annotation[] annotations = createAnnotations(constantPool, desc.classAnnotations);\n-            attributes.put(Attribute.RuntimeInvisibleAnnotations,\n-                           new RuntimeInvisibleAnnotations_attribute(attributeString, annotations));\n+            builder.accept(RuntimeInvisibleAnnotationsAttribute.of(createAnnotations(desc.classAnnotations)));\n@@ -1200,4 +987,1 @@\n-            int attributeString = addString(constantPool, Attribute.RuntimeVisibleAnnotations);\n-            Annotation[] annotations = createAnnotations(constantPool, desc.runtimeAnnotations);\n-            attributes.put(Attribute.RuntimeVisibleAnnotations,\n-                           new RuntimeVisibleAnnotations_attribute(attributeString, annotations));\n+            builder.accept(RuntimeVisibleAnnotationsAttribute.of(createAnnotations(desc.runtimeAnnotations)));\n@@ -1207,9 +991,2 @@\n-    private Annotation[] createAnnotations(List<CPInfo> constantPool, List<AnnotationDescription> desc) {\n-        Annotation[] result = new Annotation[desc.size()];\n-        int i = 0;\n-\n-        for (AnnotationDescription ad : desc) {\n-            result[i++] = createAnnotation(constantPool, ad);\n-        }\n-\n-        return result;\n+    private List<Annotation> createAnnotations(List<AnnotationDescription> desc) {\n+        return desc.stream().map(this::createAnnotation).collect(Collectors.toList());\n@@ -1218,9 +995,2 @@\n-    private Annotation[][] createParameterAnnotations(List<CPInfo> constantPool, List<List<AnnotationDescription>> desc) {\n-        Annotation[][] result = new Annotation[desc.size()][];\n-        int i = 0;\n-\n-        for (List<AnnotationDescription> paramAnnos : desc) {\n-            result[i++] = createAnnotations(constantPool, paramAnnos);\n-        }\n-\n-        return result;\n+    private List<List<Annotation>> createParameterAnnotations(List<List<AnnotationDescription>> desc) {\n+        return desc.stream().map(this::createAnnotations).collect(Collectors.toList());\n@@ -1229,1 +999,1 @@\n-    private Annotation createAnnotation(List<CPInfo> constantPool, AnnotationDescription desc) {\n+    private Annotation createAnnotation(AnnotationDescription desc) {\n@@ -1260,178 +1030,27 @@\n-        return new Annotation(null,\n-                              addString(constantPool, annotationType),\n-                              createElementPairs(constantPool, values));\n-    }\n-\n-    private element_value_pair[] createElementPairs(List<CPInfo> constantPool, Map<String, Object> annotationAttributes) {\n-        element_value_pair[] pairs = new element_value_pair[annotationAttributes.size()];\n-        int i = 0;\n-\n-        for (Entry<String, Object> e : annotationAttributes.entrySet()) {\n-            int elementNameString = addString(constantPool, e.getKey());\n-            element_value value = createAttributeValue(constantPool, e.getValue());\n-            pairs[i++] = new element_value_pair(elementNameString, value);\n-        }\n-\n-        return pairs;\n-    }\n-\n-    private element_value createAttributeValue(List<CPInfo> constantPool, Object value) {\n-        Pair<Integer, Character> constantPoolEntry = addConstant(constantPool, value, true);\n-        if (constantPoolEntry != null) {\n-            return new Primitive_element_value(constantPoolEntry.fst, constantPoolEntry.snd);\n-        } else if (value instanceof EnumConstant) {\n-            EnumConstant ec = (EnumConstant) value;\n-            return new Enum_element_value(addString(constantPool, ec.type),\n-                                          addString(constantPool, ec.constant),\n-                                          'e');\n-        } else if (value instanceof ClassConstant) {\n-            ClassConstant cc = (ClassConstant) value;\n-            return new Class_element_value(addString(constantPool, cc.type), 'c');\n-        } else if (value instanceof AnnotationDescription) {\n-            Annotation annotation = createAnnotation(constantPool, ((AnnotationDescription) value));\n-            return new Annotation_element_value(annotation, '@');\n-        } else if (value instanceof Collection) {\n-            @SuppressWarnings(\"unchecked\")\n-                    Collection<Object> array = (Collection<Object>) value;\n-            element_value[] values = new element_value[array.size()];\n-            int i = 0;\n-\n-            for (Object elem : array) {\n-                values[i++] = createAttributeValue(constantPool, elem);\n-            }\n-\n-            return new Array_element_value(values, '[');\n-        }\n-        throw new IllegalStateException(value.getClass().getName());\n-    }\n-\n-    private static Pair<Integer, Character> addConstant(List<CPInfo> constantPool, Object value, boolean annotation) {\n-        if (value instanceof Boolean) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info(((Boolean) value) ? 1 : 0)), 'Z');\n-        } else if (value instanceof Byte) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((byte) value)), 'B');\n-        } else if (value instanceof Character) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((char) value)), 'C');\n-        } else if (value instanceof Short) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((short) value)), 'S');\n-        } else if (value instanceof Integer) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Integer_info((int) value)), 'I');\n-        } else if (value instanceof Long) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Long_info((long) value)), 'J');\n-        } else if (value instanceof Float) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Float_info((float) value)), 'F');\n-        } else if (value instanceof Double) {\n-            return Pair.of(addToCP(constantPool, new CONSTANT_Double_info((double) value)), 'D');\n-        } else if (value instanceof String) {\n-            int stringIndex = addString(constantPool, (String) value);\n-            if (annotation) {\n-                return Pair.of(stringIndex, 's');\n-            } else {\n-                return Pair.of(addToCP(constantPool, new CONSTANT_String_info(null, stringIndex)), 's');\n-            }\n-        }\n-\n-        return null;\n-    }\n-\n-    private static int addString(List<CPInfo> constantPool, String string) {\n-        Assert.checkNonNull(string);\n-\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Utf8_info) {\n-                if (((CONSTANT_Utf8_info) info).value.equals(string)) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Utf8_info(string));\n-    }\n-\n-    private static int addInt(List<CPInfo> constantPool, int value) {\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Integer_info) {\n-                if (((CONSTANT_Integer_info) info).value == value) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Integer_info(value));\n-    }\n-\n-    private static int addModuleName(List<CPInfo> constantPool, String moduleName) {\n-        int nameIdx = addString(constantPool, moduleName);\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Module_info) {\n-                if (((CONSTANT_Module_info) info).name_index == nameIdx) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Module_info(null, nameIdx));\n-    }\n-\n-    private static int addPackageName(List<CPInfo> constantPool, String packageName) {\n-        int nameIdx = addString(constantPool, packageName);\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Package_info) {\n-                if (((CONSTANT_Package_info) info).name_index == nameIdx) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Package_info(null, nameIdx));\n-    }\n-\n-    private static int addClassName(List<CPInfo> constantPool, String className) {\n-        int nameIdx = addString(constantPool, className);\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Class_info) {\n-                if (((CONSTANT_Class_info) info).name_index == nameIdx) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Class_info(null, nameIdx));\n-    }\n-\n-    private static int addToCP(List<CPInfo> constantPool, CPInfo entry) {\n-        int result = constantPool.size();\n-\n-        constantPool.add(entry);\n-\n-        if (entry.size() > 1) {\n-            constantPool.add(null);\n-        }\n-\n-        return result;\n-    }\n-\n-    private static int addClass(List<CPInfo> constantPool, String className) {\n-        int classNameIndex = addString(constantPool, className);\n-\n-        int i = 0;\n-        for (CPInfo info : constantPool) {\n-            if (info instanceof CONSTANT_Class_info) {\n-                if (((CONSTANT_Class_info) info).name_index == classNameIndex) {\n-                    return i;\n-                }\n-            }\n-            i++;\n-        }\n-\n-        return addToCP(constantPool, new CONSTANT_Class_info(null, classNameIndex));\n+        return Annotation.of(ClassDesc.ofDescriptor(annotationType),\n+                createElementPairs(values));\n+    }\n+\n+    private List<AnnotationElement> createElementPairs(Map<String, Object> annotationAttributes) {\n+        return annotationAttributes.entrySet().stream()\n+                .map(e -> AnnotationElement.of(e.getKey(), createAttributeValue(e.getValue())))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private AnnotationValue createAttributeValue(Object value) {\n+        return switch (value) {\n+            case Boolean v -> AnnotationValue.ofBoolean(v);\n+            case Byte v -> AnnotationValue.ofByte(v);\n+            case Character v -> AnnotationValue.ofChar(v);\n+            case Short v -> AnnotationValue.ofShort(v);\n+            case Integer v -> AnnotationValue.ofInt(v);\n+            case Long v -> AnnotationValue.ofLong(v);\n+            case Float v -> AnnotationValue.ofFloat(v);\n+            case Double v -> AnnotationValue.ofDouble(v);\n+            case String v -> AnnotationValue.ofString(v);\n+            case EnumConstant v -> AnnotationValue.ofEnum(ClassDesc.ofDescriptor(v.type), v.constant);\n+            case ClassConstant v -> AnnotationValue.ofClass(ClassDesc.ofDescriptor(v.type));\n+            case AnnotationDescription v -> AnnotationValue.ofAnnotation(createAnnotation(v));\n+            case Collection<?> v -> AnnotationValue.ofArray(v.stream().map(this::createAttributeValue).collect(Collectors.toList()));\n+            default -> throw new IllegalArgumentException(value.getClass().getName());\n+        };\n@@ -1512,1 +1131,1 @@\n-                throw new IllegalStateException(ex);\n+                throw new IllegalArgumentException(ex);\n@@ -1528,6 +1147,2 @@\n-            try (InputStream in = new ByteArrayInputStream(classFileData)) {\n-                inspectModuleInfoClassFile(in,\n-                                           currentVersionModules, version);\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n+            inspectModuleInfoClassFile(classFileData,\n+                    currentVersionModules, version);\n@@ -1564,2 +1179,2 @@\n-                                 cf -> {\n-                                     PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n+                                 cm -> {\n+                                     var permitted = cm.findAttribute(Attributes.permittedSubclasses()).orElse(null);\n@@ -1567,2 +1182,2 @@\n-                                         try {\n-                                             String currentPack = cf.getName().substring(0, cf.getName().lastIndexOf('\/'));\n+                                         var name = cm.thisClass().asInternalName();\n+                                         String currentPack = name.substring(0, name.lastIndexOf('\/'));\n@@ -1570,4 +1185,4 @@\n-                                             for (int i = 0; i < permitted.subtypes.length; i++) {\n-                                                 String permittedClassName = cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName();\n-                                                 if (!currentEIList.accepts(permittedClassName, false)) {\n-                                                     String permittedPack = permittedClassName.substring(0, permittedClassName.lastIndexOf('\/'));\n+                                         for (var sub : permitted.permittedSubclasses()) {\n+                                             String permittedClassName = sub.asInternalName();\n+                                             if (!currentEIList.accepts(permittedClassName, false)) {\n+                                                 String permittedPack = permittedClassName.substring(0, permittedClassName.lastIndexOf('\/'));\n@@ -1575,3 +1190,2 @@\n-                                                     extraModulesPackagesToDerive.computeIfAbsent(permittedPack, x -> new HashSet<>())\n-                                                                                 .add(currentPack);\n-                                                 }\n+                                                 extraModulesPackagesToDerive.computeIfAbsent(permittedPack, x -> new HashSet<>())\n+                                                                             .add(currentPack);\n@@ -1579,2 +1193,0 @@\n-                                         } catch (ConstantPoolException ex) {\n-                                             throw new IllegalStateException(ex);\n@@ -1584,2 +1196,2 @@\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n+            } catch (IOException ex) {\n+                throw new IllegalArgumentException(ex);\n@@ -1651,4 +1263,1 @@\n-                        ModuleDescription md;\n-\n-                        try (InputStream in = Files.newInputStream(moduleInfo)) {\n-                            md = inspectModuleInfoClassFile(in,\n+                        ModuleDescription md = inspectModuleInfoClassFile(Files.readAllBytes(moduleInfo),\n@@ -1656,1 +1265,0 @@\n-                        }\n@@ -1718,2 +1326,2 @@\n-        } catch (IOException | ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n+        } catch (IOException ex) {\n+            throw new IllegalArgumentException(ex);\n@@ -1727,1 +1335,1 @@\n-                                                  List<String> todo) throws IOException, ConstantPoolException {\n+                                                  List<String> todo) throws IOException {\n@@ -2247,1 +1855,1 @@\n-    private void inspectClassFile(InputStream in, ClassList classes, ExcludeIncludeList excludesIncludes, String version) throws IOException, ConstantPoolException {\n+    private void inspectClassFile(InputStream in, ClassList classes, ExcludeIncludeList excludesIncludes, String version) throws IOException {\n@@ -2252,2 +1860,2 @@\n-                                  Consumer<ClassFile> extraTask) throws IOException, ConstantPoolException {\n-        ClassFile cf = ClassFile.read(in);\n+                                  Consumer<ClassModel> extraTask) throws IOException {\n+        ClassModel cm = ClassFile.of().parse(in.readAllBytes());\n@@ -2255,1 +1863,1 @@\n-        if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n+        if (cm.isModuleInfo()) {\n@@ -2259,1 +1867,1 @@\n-        if (!excludesIncludes.accepts(cf.getName(), true)) {\n+        if (!excludesIncludes.accepts(cm.thisClass().asInternalName(), true)) {\n@@ -2263,1 +1871,1 @@\n-        extraTask.accept(cf);\n+        extraTask.accept(cm);\n@@ -2267,1 +1875,1 @@\n-        headerDesc.flags = cf.access_flags.flags;\n+        headerDesc.flags = cm.flags().flagsMask();\n@@ -2269,6 +1877,2 @@\n-        if (cf.super_class != 0) {\n-            headerDesc.extendsAttr = cf.getSuperclassName();\n-        }\n-        List<String> interfaces = new ArrayList<>();\n-        for (int i = 0; i < cf.interfaces.length; i++) {\n-            interfaces.add(cf.getInterfaceName(i));\n+        if (cm.superclass().isPresent()) {\n+            headerDesc.extendsAttr = cm.superclass().get().asInternalName();\n@@ -2276,3 +1880,3 @@\n-        headerDesc.implementsAttr = interfaces;\n-        for (Attribute attr : cf.attributes) {\n-            if (!readAttribute(cf, headerDesc, attr))\n+        headerDesc.implementsAttr = cm.interfaces().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+        for (var attr : cm.attributes()) {\n+            if (!readAttribute(headerDesc, attr))\n@@ -2285,1 +1889,1 @@\n-            if (cd.name.equals(cf.getName())) {\n+            if (cd.name.equals(cm.thisClass().asInternalName())) {\n@@ -2293,1 +1897,1 @@\n-            clazzDesc.name = cf.getName();\n+            clazzDesc.name = cm.thisClass().asInternalName();\n@@ -2299,2 +1903,2 @@\n-        for (Method m : cf.methods) {\n-            if (!include(m.access_flags.flags))\n+        for (var m : cm.methods()) {\n+            if (!include(m.flags().flagsMask()))\n@@ -2303,5 +1907,5 @@\n-            methDesc.flags = m.access_flags.flags;\n-            methDesc.name = m.getName(cf.constant_pool);\n-            methDesc.descriptor = m.descriptor.getValue(cf.constant_pool);\n-            for (Attribute attr : m.attributes) {\n-                readAttribute(cf, methDesc, attr);\n+            methDesc.flags = m.flags().flagsMask();\n+            methDesc.name = m.methodName().stringValue();\n+            methDesc.descriptor = m.methodType().stringValue();\n+            for (var attr : m.attributes()) {\n+                readAttribute(methDesc, attr);\n@@ -2311,2 +1915,2 @@\n-        for (Field f : cf.fields) {\n-            if (!include(f.access_flags.flags))\n+        for (var f : cm.fields()) {\n+            if (!include(f.flags().flagsMask()))\n@@ -2315,5 +1919,5 @@\n-            fieldDesc.flags = f.access_flags.flags;\n-            fieldDesc.name = f.getName(cf.constant_pool);\n-            fieldDesc.descriptor = f.descriptor.getValue(cf.constant_pool);\n-            for (Attribute attr : f.attributes) {\n-                readAttribute(cf, fieldDesc, attr);\n+            fieldDesc.flags = f.flags().flagsMask();\n+            fieldDesc.name = f.fieldName().stringValue();\n+            fieldDesc.descriptor = f.fieldType().stringValue();\n+            for (var attr : f.attributes()) {\n+                readAttribute(fieldDesc, attr);\n@@ -2325,1 +1929,1 @@\n-    private ModuleDescription inspectModuleInfoClassFile(InputStream in,\n+    private ModuleDescription inspectModuleInfoClassFile(byte[] data,\n@@ -2327,2 +1931,2 @@\n-            String version) throws IOException, ConstantPoolException {\n-        ClassFile cf = ClassFile.read(in);\n+            String version) {\n+        ClassModel cm = ClassFile.of().parse(data);\n@@ -2330,1 +1934,1 @@\n-        if (!cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n+        if (!cm.flags().has(AccessFlag.MODULE)) {\n@@ -2337,1 +1941,1 @@\n-        headerDesc.flags = cf.access_flags.flags;\n+        headerDesc.flags = cm.flags().flagsMask();\n@@ -2339,2 +1943,2 @@\n-        for (Attribute attr : cf.attributes) {\n-            if (!readAttribute(cf, headerDesc, attr))\n+        for (var attr : cm.attributes()) {\n+            if (!readAttribute(headerDesc, attr))\n@@ -2364,7 +1968,1 @@\n-            try (InputStream in = new ByteArrayInputStream(classFileData)) {\n-                ClassFile cf = ClassFile.read(in);\n-\n-                additionalIncludes.addAll(otherRelevantTypesWithOwners(cf));\n-            } catch (IOException | ConstantPoolException ex) {\n-                throw new IllegalStateException(ex);\n-            }\n+            additionalIncludes.addAll(otherRelevantTypesWithOwners(ClassFile.of().parse(classFileData)));\n@@ -2376,1 +1974,1 @@\n-    private Set<String> otherRelevantTypesWithOwners(ClassFile cf) {\n+    private Set<String> otherRelevantTypesWithOwners(ClassModel cm) {\n@@ -2379,4 +1977,3 @@\n-        try {\n-            if (cf.access_flags.is(AccessFlags.ACC_MODULE)) {\n-                return supertypes;\n-            }\n+        if (cm.flags().has(AccessFlag.MODULE)) {\n+            return supertypes;\n+        }\n@@ -2384,1 +1981,1 @@\n-            Set<String> additionalClasses = new HashSet<>();\n+        Set<String> additionalClasses = new HashSet<>();\n@@ -2386,11 +1983,10 @@\n-            if (cf.super_class != 0) {\n-                additionalClasses.add(cf.getSuperclassName());\n-            }\n-            for (int i = 0; i < cf.interfaces.length; i++) {\n-                additionalClasses.add(cf.getInterfaceName(i));\n-            }\n-            PermittedSubclasses_attribute permitted = (PermittedSubclasses_attribute) cf.getAttribute(Attribute.PermittedSubclasses);\n-            if (permitted != null) {\n-                for (int i = 0; i < permitted.subtypes.length; i++) {\n-                    additionalClasses.add(cf.constant_pool.getClassInfo(permitted.subtypes[i]).getName());\n-                }\n+        if (cm.superclass().isPresent()) {\n+            additionalClasses.add(cm.superclass().get().asInternalName());\n+        }\n+        for (var iface : cm.interfaces()) {\n+            additionalClasses.add(iface.asInternalName());\n+        }\n+        var permitted = cm.findAttribute(Attributes.permittedSubclasses()).orElse(null);\n+        if (permitted != null) {\n+            for (var sub : permitted.permittedSubclasses()) {\n+                additionalClasses.add(sub.asInternalName());\n@@ -2398,0 +1994,1 @@\n+        }\n@@ -2399,2 +1996,2 @@\n-            for (String additional : additionalClasses) {\n-                int dollar;\n+        for (String additional : additionalClasses) {\n+            int dollar;\n@@ -2402,1 +1999,1 @@\n-                supertypes.add(additional);\n+            supertypes.add(additional);\n@@ -2404,4 +2001,3 @@\n-                while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n-                    additional = additional.substring(0, dollar);\n-                    supertypes.add(additional);\n-                }\n+            while ((dollar = additional.lastIndexOf('$')) != (-1)) {\n+                additional = additional.substring(0, dollar);\n+                supertypes.add(additional);\n@@ -2409,4 +2005,0 @@\n-\n-            return supertypes;\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n@@ -2414,0 +2006,2 @@\n+\n+        return supertypes;\n@@ -2438,1 +2032,1 @@\n-        return (accessFlags & (AccessFlags.ACC_PUBLIC | AccessFlags.ACC_PROTECTED)) != 0;\n+        return (accessFlags & (ACC_PUBLIC | ACC_PROTECTED)) != 0;\n@@ -2534,22 +2128,7 @@\n-    private boolean readAttribute(ClassFile cf, FeatureDescription feature, Attribute attr) throws ConstantPoolException {\n-        String attrName = attr.getName(cf.constant_pool);\n-        switch (attrName) {\n-            case Attribute.AnnotationDefault:\n-                assert feature instanceof MethodDescription;\n-                element_value defaultValue = ((AnnotationDefault_attribute) attr).default_value;\n-                ((MethodDescription) feature).annotationDefaultValue =\n-                        convertElementValue(cf.constant_pool, defaultValue);\n-                break;\n-            case \"Deprecated\":\n-                feature.deprecated = true;\n-                break;\n-            case \"Exceptions\":\n-                assert feature instanceof MethodDescription;\n-                List<String> thrownTypes = new ArrayList<>();\n-                Exceptions_attribute exceptionAttr = (Exceptions_attribute) attr;\n-                for (int i = 0; i < exceptionAttr.exception_index_table.length; i++) {\n-                    thrownTypes.add(exceptionAttr.getException(i, cf.constant_pool));\n-                }\n-                ((MethodDescription) feature).thrownTypes = thrownTypes;\n-                break;\n-            case Attribute.InnerClasses:\n+    private boolean readAttribute(FeatureDescription feature, Attribute<?> attr) {\n+        switch (attr) {\n+            case AnnotationDefaultAttribute a ->\n+                    ((MethodDescription) feature).annotationDefaultValue = convertElementValue(a.defaultValue());\n+            case DeprecatedAttribute _ -> feature.deprecated = true;\n+            case ExceptionsAttribute a -> ((MethodDescription) feature).thrownTypes = a.exceptions().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+            case InnerClassesAttribute a -> {\n@@ -2558,71 +2137,26 @@\n-                assert feature instanceof ClassHeaderDescription;\n-                List<InnerClassInfo> innerClasses = new ArrayList<>();\n-                InnerClasses_attribute innerClassesAttr = (InnerClasses_attribute) attr;\n-                for (int i = 0; i < innerClassesAttr.number_of_classes; i++) {\n-                    CONSTANT_Class_info outerClassInfo =\n-                            innerClassesAttr.classes[i].getOuterClassInfo(cf.constant_pool);\n-                    InnerClassInfo info = new InnerClassInfo();\n-                    CONSTANT_Class_info innerClassInfo =\n-                            innerClassesAttr.classes[i].getInnerClassInfo(cf.constant_pool);\n-                    info.innerClass = innerClassInfo != null ? innerClassInfo.getName() : null;\n-                    info.outerClass = outerClassInfo != null ? outerClassInfo.getName() : null;\n-                    info.innerClassName = innerClassesAttr.classes[i].getInnerName(cf.constant_pool);\n-                    info.innerClassFlags = innerClassesAttr.classes[i].inner_class_access_flags.flags;\n-                    innerClasses.add(info);\n-                }\n-                ((ClassHeaderDescription) feature).innerClasses = innerClasses;\n-                break;\n-            case \"RuntimeInvisibleAnnotations\":\n-                feature.classAnnotations = annotations2Description(cf.constant_pool, attr);\n-                break;\n-            case \"RuntimeVisibleAnnotations\":\n-                feature.runtimeAnnotations = annotations2Description(cf.constant_pool, attr);\n-                break;\n-            case \"Signature\":\n-                feature.signature = ((Signature_attribute) attr).getSignature(cf.constant_pool);\n-                break;\n-            case \"ConstantValue\":\n-                assert feature instanceof FieldDescription;\n-                Object value = convertConstantValue(cf.constant_pool.get(((ConstantValue_attribute) attr).constantvalue_index), ((FieldDescription) feature).descriptor);\n-                if (((FieldDescription) feature).descriptor.equals(\"C\")) {\n-                    value = (char) (int) value;\n-                }\n-                ((FieldDescription) feature).constantValue = value;\n-                break;\n-            case \"SourceFile\":\n-                \/\/ignore, not needed\n-                break;\n-            case \"BootstrapMethods\":\n-                \/\/ignore, not needed\n-                break;\n-            case \"Code\":\n-                \/\/ignore, not needed\n-                break;\n-            case \"EnclosingMethod\":\n-                return false;\n-            case \"Synthetic\":\n-                break;\n-            case \"RuntimeVisibleParameterAnnotations\":\n-                assert feature instanceof MethodDescription;\n-                ((MethodDescription) feature).runtimeParameterAnnotations =\n-                        parameterAnnotations2Description(cf.constant_pool, attr);\n-                break;\n-            case \"RuntimeInvisibleParameterAnnotations\":\n-                assert feature instanceof MethodDescription;\n-                ((MethodDescription) feature).classParameterAnnotations =\n-                        parameterAnnotations2Description(cf.constant_pool, attr);\n-                break;\n-            case Attribute.Module: {\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                Module_attribute mod = (Module_attribute) attr;\n-\n-                header.name = cf.constant_pool\n-                                .getModuleInfo(mod.module_name)\n-                                .getName();\n-\n-                header.exports =\n-                        Arrays.stream(mod.exports)\n-                              .map(ee -> ExportsDescription.create(cf, ee))\n-                              .collect(Collectors.toList());\n+                ((ClassHeaderDescription) feature).innerClasses = a.classes().stream().map(cfi -> {\n+                    var info = new InnerClassInfo();\n+                    info.innerClass = cfi.innerClass().asInternalName();\n+                    info.outerClass = cfi.outerClass().map(ClassEntry::asInternalName).orElse(null);\n+                    info.innerClassName = cfi.innerName().map(Utf8Entry::stringValue).orElse(null);\n+                    info.innerClassFlags = cfi.flagsMask();\n+                    return info;\n+                }).collect(Collectors.toList());\n+            }\n+            case RuntimeInvisibleAnnotationsAttribute a -> feature.classAnnotations = annotations2Description(a.annotations());\n+            case RuntimeVisibleAnnotationsAttribute a -> feature.runtimeAnnotations = annotations2Description(a.annotations());\n+            case SignatureAttribute a -> feature.signature = a.signature().stringValue();\n+            case ConstantValueAttribute a -> {\n+                var f = (FieldDescription) feature;\n+                f.constantValue = convertConstantValue(a.constant(), f.descriptor);\n+            }\n+            case SourceFileAttribute _, BootstrapMethodsAttribute _, CodeAttribute _, SyntheticAttribute _ -> {}\n+            case EnclosingMethodAttribute _ -> {\n+                return false;\n+            }\n+            case RuntimeVisibleParameterAnnotationsAttribute a -> ((MethodDescription) feature).runtimeParameterAnnotations = parameterAnnotations2Description(a.parameterAnnotations());\n+            case RuntimeInvisibleParameterAnnotationsAttribute a -> ((MethodDescription) feature).classParameterAnnotations = parameterAnnotations2Description(a.parameterAnnotations());\n+            case ModuleAttribute a -> {\n+                ModuleHeaderDescription header = (ModuleHeaderDescription) feature;\n+                header.name = a.moduleName().name().stringValue();\n+                header.exports = a.exports().stream().map(ExportsDescription::create).collect(Collectors.toList());\n@@ -2632,24 +2166,3 @@\n-                header.requires =\n-                        Arrays.stream(mod.requires)\n-                              .map(r -> RequiresDescription.create(cf, r))\n-                              .collect(Collectors.toList());\n-                header.uses = Arrays.stream(mod.uses_index)\n-                                    .mapToObj(use -> getClassName(cf, use))\n-                                    .collect(Collectors.toList());\n-                header.provides =\n-                        Arrays.stream(mod.provides)\n-                              .map(p -> ProvidesDescription.create(cf, p))\n-                              .collect(Collectors.toList());\n-                break;\n-            }\n-            case Attribute.ModuleTarget: {\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                ModuleTarget_attribute mod = (ModuleTarget_attribute) attr;\n-                if (mod.target_platform_index != 0) {\n-                    header.moduleTarget =\n-                            cf.constant_pool\n-                              .getUTF8Value(mod.target_platform_index);\n-                }\n-                break;\n+                header.requires = a.requires().stream().map(RequiresDescription::create).collect(Collectors.toList());\n+                header.uses = a.uses().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+                header.provides = a.provides().stream().map(ProvidesDescription::create).collect(Collectors.toList());\n@@ -2657,18 +2170,6 @@\n-            case Attribute.ModuleResolution: {\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                ModuleResolution_attribute mod =\n-                        (ModuleResolution_attribute) attr;\n-                header.moduleResolution = mod.resolution_flags;\n-                break;\n-            }\n-            case Attribute.ModulePackages:\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription header =\n-                        (ModuleHeaderDescription) feature;\n-                ModulePackages_attribute mod =\n-                        (ModulePackages_attribute) attr;\n-                header.extraModulePackages = new ArrayList<>();\n-                for (int i = 0; i < mod.packages_count; i++) {\n-                    String packageName = getPackageName(cf, mod.packages_index[i]);\n+            case ModuleTargetAttribute a -> ((ModuleHeaderDescription) feature).moduleTarget = a.targetPlatform().stringValue();\n+            case ModuleResolutionAttribute a -> ((ModuleHeaderDescription) feature).moduleResolution = a.resolutionFlags();\n+            case ModulePackagesAttribute a -> {\n+                var header = (ModuleHeaderDescription) feature;\n+                header.extraModulePackages = a.packages().stream().<String>mapMulti((packageItem, sink) -> {\n+                    var packageName = packageItem.name().stringValue();\n@@ -2676,2 +2177,2 @@\n-                        header.exports.stream().noneMatch(ed -> ed.packageName().equals(packageName))) {\n-                        header.extraModulePackages.add(packageName);\n+                            header.exports.stream().noneMatch(ed -> ed.packageName().equals(packageName))) {\n+                        sink.accept(packageName);\n@@ -2679,19 +2180,1 @@\n-                }\n-                break;\n-            case Attribute.ModuleHashes:\n-                break;\n-            case Attribute.NestHost: {\n-                assert feature instanceof ClassHeaderDescription;\n-                NestHost_attribute nestHost = (NestHost_attribute) attr;\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n-                chd.nestHost = nestHost.getNestTop(cf.constant_pool).getName();\n-                break;\n-            }\n-            case Attribute.NestMembers: {\n-                assert feature instanceof ClassHeaderDescription;\n-                NestMembers_attribute nestMembers = (NestMembers_attribute) attr;\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n-                chd.nestMembers = Arrays.stream(nestMembers.members_indexes)\n-                                        .mapToObj(i -> getClassName(cf, i))\n-                                        .collect(Collectors.toList());\n-                break;\n+                }).collect(Collectors.toList());\n@@ -2699,14 +2182,5 @@\n-            case Attribute.Record: {\n-                assert feature instanceof ClassHeaderDescription;\n-                Record_attribute record = (Record_attribute) attr;\n-                List<RecordComponentDescription> components = new ArrayList<>();\n-                for (ComponentInfo info : record.component_info_arr) {\n-                    RecordComponentDescription rcd = new RecordComponentDescription();\n-                    rcd.name = info.getName(cf.constant_pool);\n-                    rcd.descriptor = info.descriptor.getValue(cf.constant_pool);\n-                    for (Attribute nestedAttr : info.attributes) {\n-                        readAttribute(cf, rcd, nestedAttr);\n-                    }\n-                    components.add(rcd);\n-                }\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n+            case ModuleHashesAttribute _ -> {}\n+            case NestHostAttribute a -> ((ClassHeaderDescription) feature).nestHost = a.nestHost().asInternalName();\n+            case NestMembersAttribute a -> ((ClassHeaderDescription) feature).nestMembers = a.nestMembers().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n+            case RecordAttribute a -> {\n+                var chd = (ClassHeaderDescription) feature;\n@@ -2714,24 +2188,13 @@\n-                chd.recordComponents = components;\n-                break;\n-            }\n-            case Attribute.MethodParameters: {\n-                assert feature instanceof MethodDescription;\n-                MethodParameters_attribute params = (MethodParameters_attribute) attr;\n-                MethodDescription method = (MethodDescription) feature;\n-                method.methodParameters = new ArrayList<>();\n-                for (MethodParameters_attribute.Entry e : params.method_parameter_table) {\n-                    String name = e.name_index == 0 ? null\n-                            : cf.constant_pool.getUTF8Value(e.name_index);\n-                    MethodDescription.MethodParam param =\n-                            new MethodDescription.MethodParam(e.flags, name);\n-                    method.methodParameters.add(param);\n-                }\n-                break;\n-            }\n-            case Attribute.PermittedSubclasses: {\n-                assert feature instanceof ClassHeaderDescription;\n-                PermittedSubclasses_attribute permittedSubclasses = (PermittedSubclasses_attribute) attr;\n-                ClassHeaderDescription chd = (ClassHeaderDescription) feature;\n-                chd.permittedSubclasses = Arrays.stream(permittedSubclasses.subtypes)\n-                        .mapToObj(i -> getClassName(cf, i))\n-                        .collect(Collectors.toList());\n+                chd.recordComponents = a.components().stream().map(rci -> {\n+                    var rcd = new RecordComponentDescription();\n+                    rcd.name = rci.name().stringValue();\n+                    rcd.descriptor = rci.descriptor().stringValue();\n+                    rci.attributes().forEach(child -> readAttribute(rcd, child));\n+                    return rcd;\n+                }).collect(Collectors.toList());\n+            }\n+            case MethodParametersAttribute a -> ((MethodDescription) feature).methodParameters = a.parameters().stream()\n+                    .map(mpi -> new MethodDescription.MethodParam(mpi.flagsMask(), mpi.name().map(Utf8Entry::stringValue).orElse(null)))\n+                    .collect(Collectors.toList());\n+            case PermittedSubclassesAttribute a -> {\n+                var chd = (ClassHeaderDescription) feature;\n@@ -2739,1 +2202,1 @@\n-                break;\n+                chd.permittedSubclasses = a.permittedSubclasses().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n@@ -2741,10 +2204,2 @@\n-            case Attribute.ModuleMainClass: {\n-                ModuleMainClass_attribute moduleMainClass = (ModuleMainClass_attribute) attr;\n-                assert feature instanceof ModuleHeaderDescription;\n-                ModuleHeaderDescription mhd = (ModuleHeaderDescription) feature;\n-                mhd.moduleMainClass = moduleMainClass.getMainClassName(cf.constant_pool);\n-                break;\n-            }\n-            default:\n-                throw new IllegalStateException(\"Unhandled attribute: \" +\n-                                                attrName);\n+            case ModuleMainClassAttribute a -> ((ModuleHeaderDescription) feature).moduleMainClass = a.mainClass().asInternalName();\n+            default -> throw new IllegalArgumentException(\"Unhandled attribute: \" + attr.attributeName()); \/\/ Do nothing\n@@ -2756,36 +2211,0 @@\n-    private static String getClassName(ClassFile cf, int idx) {\n-        try {\n-            return cf.constant_pool.getClassInfo(idx).getName();\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPool.UnexpectedEntry ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    private static String getPackageName(ClassFile cf, int idx) {\n-        try {\n-            return cf.constant_pool.getPackageInfo(idx).getName();\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPool.UnexpectedEntry ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n-    private static String getModuleName(ClassFile cf, int idx) {\n-        try {\n-            return cf.constant_pool.getModuleInfo(idx).getName();\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPool.UnexpectedEntry ex) {\n-            throw new IllegalStateException(ex);\n-        } catch (ConstantPoolException ex) {\n-            throw new IllegalStateException(ex);\n-        }\n-    }\n-\n@@ -2794,1 +2213,1 @@\n-    private static String getVersion(ClassFile cf, int idx) {\n+    private static String getVersion(Optional<Utf8Entry> version) {\n@@ -2798,7 +2217,1 @@\n-        if (idx == 0)\n-            return null;\n-        try {\n-            return ((CONSTANT_Utf8_info) cf.constant_pool.get(idx)).value;\n-        } catch (InvalidIndex ex) {\n-            throw new IllegalStateException(ex);\n-        }\n+        return version.map(Utf8Entry::stringValue).orElse(null);\n@@ -2807,16 +2220,11 @@\n-    Object convertConstantValue(CPInfo info, String descriptor) throws ConstantPoolException {\n-        if (info instanceof CONSTANT_Integer_info) {\n-            if (\"Z\".equals(descriptor))\n-                return ((CONSTANT_Integer_info) info).value == 1;\n-            else\n-                return ((CONSTANT_Integer_info) info).value;\n-        } else if (info instanceof CONSTANT_Long_info) {\n-            return ((CONSTANT_Long_info) info).value;\n-        } else if (info instanceof CONSTANT_Float_info) {\n-            return ((CONSTANT_Float_info) info).value;\n-        } else if (info instanceof CONSTANT_Double_info) {\n-            return ((CONSTANT_Double_info) info).value;\n-        } else if (info instanceof CONSTANT_String_info) {\n-            return ((CONSTANT_String_info) info).getString();\n-        }\n-        throw new IllegalStateException(info.getClass().getName());\n+    Object convertConstantValue(ConstantValueEntry info, String descriptor) {\n+        if (descriptor.length() == 1 && info instanceof IntegerEntry ie) {\n+            var i = ie.intValue();\n+            return switch (descriptor.charAt(0)) {\n+                case 'I', 'B', 'S' -> i;\n+                case 'C' -> (char) i;\n+                case 'Z' -> i == 1;\n+                default -> throw new IllegalArgumentException(descriptor);\n+            };\n+        }\n+        return info.constantValue();\n@@ -2825,39 +2233,8 @@\n-    Object convertElementValue(ConstantPool cp, element_value val) throws InvalidIndex, ConstantPoolException {\n-        switch (val.tag) {\n-            case 'Z':\n-                return ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value != 0;\n-            case 'B':\n-                return (byte) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'C':\n-                return (char) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'S':\n-                return (short) ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'I':\n-                return ((CONSTANT_Integer_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'J':\n-                return ((CONSTANT_Long_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'F':\n-                return ((CONSTANT_Float_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 'D':\n-                return ((CONSTANT_Double_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-            case 's':\n-                return ((CONSTANT_Utf8_info) cp.get(((Primitive_element_value) val).const_value_index)).value;\n-\n-            case 'e':\n-                return new EnumConstant(cp.getUTF8Value(((Enum_element_value) val).type_name_index),\n-                        cp.getUTF8Value(((Enum_element_value) val).const_name_index));\n-            case 'c':\n-                return new ClassConstant(cp.getUTF8Value(((Class_element_value) val).class_info_index));\n-\n-            case '@':\n-                return annotation2Description(cp, ((Annotation_element_value) val).annotation_value);\n-\n-            case '[':\n-                List<Object> values = new ArrayList<>();\n-                for (element_value elem : ((Array_element_value) val).values) {\n-                    values.add(convertElementValue(cp, elem));\n-                }\n-                return values;\n-            default:\n-                throw new IllegalStateException(\"Currently unhandled tag: \" + val.tag);\n-        }\n+    Object convertElementValue(AnnotationValue val) {\n+        return switch (val) {\n+            case AnnotationValue.OfConstant oc -> oc.resolvedValue();\n+            case AnnotationValue.OfEnum oe -> new EnumConstant(oe.className().stringValue(), oe.constantName().stringValue());\n+            case AnnotationValue.OfClass oc -> new ClassConstant(oc.className().stringValue());\n+            case AnnotationValue.OfArray oa -> oa.values().stream().map(this::convertElementValue).collect(Collectors.toList());\n+            case AnnotationValue.OfAnnotation oa -> annotation2Description(oa.annotation());\n+        };\n@@ -2866,7 +2243,2 @@\n-    private List<AnnotationDescription> annotations2Description(ConstantPool cp, Attribute attr) throws ConstantPoolException {\n-        RuntimeAnnotations_attribute annotationsAttr = (RuntimeAnnotations_attribute) attr;\n-        List<AnnotationDescription> descs = new ArrayList<>();\n-        for (Annotation a : annotationsAttr.annotations) {\n-            descs.add(annotation2Description(cp, a));\n-        }\n-        return descs;\n+    private List<AnnotationDescription> annotations2Description(List<java.lang.classfile.Annotation> annos) {\n+        return annos.stream().map(this::annotation2Description).collect(Collectors.toList());\n@@ -2875,12 +2247,2 @@\n-    private List<List<AnnotationDescription>> parameterAnnotations2Description(ConstantPool cp, Attribute attr) throws ConstantPoolException {\n-        RuntimeParameterAnnotations_attribute annotationsAttr =\n-                (RuntimeParameterAnnotations_attribute) attr;\n-        List<List<AnnotationDescription>> descs = new ArrayList<>();\n-        for (Annotation[] attrAnnos : annotationsAttr.parameter_annotations) {\n-            List<AnnotationDescription> paramDescs = new ArrayList<>();\n-            for (Annotation ann : attrAnnos) {\n-                paramDescs.add(annotation2Description(cp, ann));\n-            }\n-            descs.add(paramDescs);\n-        }\n-        return descs;\n+    private List<List<AnnotationDescription>> parameterAnnotations2Description(List<List<java.lang.classfile.Annotation>> annos) {\n+        return annos.stream().map(this::annotations2Description).collect(Collectors.toList());\n@@ -2889,2 +2251,2 @@\n-    private AnnotationDescription annotation2Description(ConstantPool cp, Annotation a) throws ConstantPoolException {\n-        String annotationType = cp.getUTF8Value(a.type_index);\n+    private AnnotationDescription annotation2Description(java.lang.classfile.Annotation a) {\n+        String annotationType = a.className().stringValue();\n@@ -2893,2 +2255,2 @@\n-        for (element_value_pair e : a.element_value_pairs) {\n-            values.put(cp.getUTF8Value(e.element_name_index), convertElementValue(cp, e.value));\n+        for (var e : a.elements()) {\n+            values.put(e.name().stringValue(), convertElementValue(e.value()));\n@@ -3184,1 +2546,1 @@\n-                        throw new IllegalStateException(reader.lineKey);\n+                        throw new IllegalArgumentException(reader.lineKey);\n@@ -3399,3 +2761,2 @@\n-            public static ExportsDescription create(ClassFile cf,\n-                                                    ExportsEntry ee) {\n-                String packageName = getPackageName(cf, ee.exports_index);\n+            public static ExportsDescription create(ModuleExportInfo ee) {\n+                String packageName = ee.exportedPackage().name().stringValue();\n@@ -3403,5 +2764,2 @@\n-                if (ee.exports_to_count > 0) {\n-                    to = new ArrayList<>();\n-                    for (int moduleIndex : ee.exports_to_index) {\n-                        to.add(getModuleName(cf, moduleIndex));\n-                    }\n+                if (!ee.exportsTo().isEmpty()) {\n+                    to = ee.exportsTo().stream().map(m -> m.name().stringValue()).collect(Collectors.toList());\n@@ -3450,4 +2808,3 @@\n-            public static RequiresDescription create(ClassFile cf,\n-                                                     RequiresEntry req) {\n-                String mod = getModuleName(cf, req.requires_index);\n-                String ver = getVersion(cf, req.requires_version_index);\n+            public static RequiresDescription create(ModuleRequireInfo req) {\n+                String mod = req.requires().name().stringValue();\n+                String ver = getVersion(req.requiresVersion());\n@@ -3455,1 +2812,1 @@\n-                                               req.requires_flags,\n+                                               req.requiresFlagsMask(),\n@@ -3518,7 +2875,3 @@\n-            public static ProvidesDescription create(ClassFile cf,\n-                                                     ProvidesEntry prov) {\n-                String api = getClassName(cf, prov.provides_index);\n-                List<String> impls =\n-                        Arrays.stream(prov.with_index)\n-                              .mapToObj(wi -> getClassName(cf, wi))\n-                              .collect(Collectors.toList());\n+            public static ProvidesDescription create(ModuleProvideInfo prov) {\n+                String api = prov.provides().asInternalName();\n+                List<String> impls = prov.providesWith().stream().map(ClassEntry::asInternalName).collect(Collectors.toList());\n@@ -3679,1 +3032,1 @@\n-                        throw new IllegalStateException(reader.lineKey);\n+                        throw new IllegalArgumentException(reader.lineKey);\n@@ -4076,1 +3429,1 @@\n-        Object constantValue;\n+        Object constantValue; \/\/ Uses (unsigned) Integer for byte\/short\n@@ -4152,1 +3505,1 @@\n-                        throw new IllegalStateException(\"Unrecognized field type: \" + descriptor);\n+                        throw new IllegalArgumentException(\"Unrecognized field type: \" + descriptor);\n@@ -4419,1 +3772,1 @@\n-            throw new IllegalStateException(\"Cannot find: \" + name);\n+            throw new IllegalArgumentException(\"Cannot find: \" + name);\n@@ -4568,1 +3921,1 @@\n-                    throw new IllegalStateException(\"Unrecognized boolean structure: \" + value);\n+                    throw new IllegalArgumentException(\"Unrecognized boolean structure: \" + value);\n@@ -4596,1 +3949,1 @@\n-                throw new IllegalStateException(\"Unrecognized signature type: \" + value.charAt(valuePointer[0] - 1) + \"; value=\" + value);\n+                throw new IllegalArgumentException(\"Unrecognized signature type: \" + value.charAt(valuePointer[0] - 1) + \"; value=\" + value);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":355,"deletions":1002,"binary":false,"changes":1357,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-    --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED \\\n@@ -64,1 +63,1 @@\n-    INCLUDES := build\/tools\/symbolgenerator com\/sun\/tools\/classfile, \\\n+    INCLUDES := build\/tools\/symbolgenerator, \\\n","filename":"make\/modules\/jdk.compiler\/Gendata.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    INCLUDES := build\/tools\/symbolgenerator com\/sun\/tools\/classfile, \\\n+    INCLUDES := build\/tools\/symbolgenerator, \\\n","filename":"make\/modules\/jdk.javadoc\/Gendata.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,2 +71,1 @@\n-$1\/bin\/java --add-exports jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED \\\n-            --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n+$1\/bin\/java --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n","filename":"make\/scripts\/generate-symbol-data.sh","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-\/\/ Code duplicated in com.sun.tools.classfile.TypeAnnotation.TargetType\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TargetType.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-\/\/ Code duplicated in com.sun.tools.classfile.TypeAnnotation.Position\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotationPosition.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,259 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-import java.util.LinkedHashSet;\n-import java.util.Set;\n-\n-\/**\n- * See JVMS, sections 4.2, 4.6, 4.7.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class AccessFlags {\n-    public static final int ACC_PUBLIC        = 0x0001; \/\/ class, inner, field, method\n-    public static final int ACC_PRIVATE       = 0x0002; \/\/        inner, field, method\n-    public static final int ACC_PROTECTED     = 0x0004; \/\/        inner, field, method\n-    public static final int ACC_STATIC        = 0x0008; \/\/        inner, field, method\n-    public static final int ACC_FINAL         = 0x0010; \/\/ class, inner, field, method\n-    public static final int ACC_SUPER         = 0x0020; \/\/ class\n-    public static final int ACC_SYNCHRONIZED  = 0x0020; \/\/                      method\n-    public static final int ACC_VOLATILE      = 0x0040; \/\/               field\n-    public static final int ACC_BRIDGE        = 0x0040; \/\/                      method\n-    public static final int ACC_TRANSIENT     = 0x0080; \/\/               field\n-    public static final int ACC_VARARGS       = 0x0080; \/\/                      method\n-    public static final int ACC_NATIVE        = 0x0100; \/\/                      method\n-    public static final int ACC_INTERFACE     = 0x0200; \/\/ class, inner\n-    public static final int ACC_ABSTRACT      = 0x0400; \/\/ class, inner,        method\n-    public static final int ACC_STRICT        = 0x0800; \/\/                      method\n-    public static final int ACC_SYNTHETIC     = 0x1000; \/\/ class, inner, field, method\n-    public static final int ACC_ANNOTATION    = 0x2000; \/\/ class, inner\n-    public static final int ACC_ENUM          = 0x4000; \/\/ class, inner, field\n-    public static final int ACC_MANDATED      = 0x8000; \/\/                          method parameter\n-    public static final int ACC_MODULE        = 0x8000; \/\/ class\n-\n-    public static enum Kind { Class, InnerClass, Field, Method}\n-\n-    AccessFlags(ClassReader cr) throws IOException {\n-        this(cr.readUnsignedShort());\n-    }\n-\n-    public AccessFlags(int flags) {\n-        this.flags = flags;\n-    }\n-\n-    public AccessFlags ignore(int mask) {\n-        return new AccessFlags(flags & ~mask);\n-    }\n-\n-    public boolean is(int mask) {\n-        return (flags & mask) != 0;\n-    }\n-\n-    public int byteLength() {\n-        return 2;\n-    }\n-\n-    private static final int[] classModifiers = {\n-        ACC_PUBLIC, ACC_FINAL, ACC_ABSTRACT\n-    };\n-\n-    private static final int[] classFlags = {\n-        ACC_PUBLIC, ACC_FINAL, ACC_SUPER, ACC_INTERFACE, ACC_ABSTRACT,\n-        ACC_SYNTHETIC, ACC_ANNOTATION, ACC_ENUM, ACC_MODULE\n-    };\n-\n-    public Set<String> getClassModifiers() {\n-        int f = ((flags & ACC_INTERFACE) != 0 ? flags & ~ACC_ABSTRACT : flags);\n-        return getModifiers(f, classModifiers, Kind.Class);\n-    }\n-\n-    public Set<String> getClassFlags() {\n-        return getFlags(classFlags, Kind.Class);\n-    }\n-\n-    private static final int[] innerClassModifiers = {\n-        ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,\n-        ACC_ABSTRACT\n-    };\n-\n-    private static final int[] innerClassFlags = {\n-        ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SUPER,\n-        ACC_INTERFACE, ACC_ABSTRACT, ACC_SYNTHETIC, ACC_ANNOTATION, ACC_ENUM\n-    };\n-\n-    public Set<String> getInnerClassModifiers() {\n-        int f = ((flags & ACC_INTERFACE) != 0 ? flags & ~ACC_ABSTRACT : flags);\n-        return getModifiers(f, innerClassModifiers, Kind.InnerClass);\n-    }\n-\n-    public Set<String> getInnerClassFlags() {\n-        return getFlags(innerClassFlags, Kind.InnerClass);\n-    }\n-\n-    private static final int[] fieldModifiers = {\n-        ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,\n-        ACC_VOLATILE, ACC_TRANSIENT\n-    };\n-\n-    private static final int[] fieldFlags = {\n-        ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,\n-        ACC_VOLATILE, ACC_TRANSIENT, ACC_SYNTHETIC, ACC_ENUM\n-    };\n-\n-    public Set<String> getFieldModifiers() {\n-        return getModifiers(fieldModifiers, Kind.Field);\n-    }\n-\n-    public Set<String> getFieldFlags() {\n-        return getFlags(fieldFlags, Kind.Field);\n-    }\n-\n-    private static final int[] methodModifiers = {\n-        ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,\n-        ACC_SYNCHRONIZED, ACC_NATIVE, ACC_ABSTRACT, ACC_STRICT\n-    };\n-\n-    private static final int[] methodFlags = {\n-        ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL,\n-        ACC_SYNCHRONIZED, ACC_BRIDGE, ACC_VARARGS, ACC_NATIVE, ACC_ABSTRACT,\n-        ACC_STRICT, ACC_SYNTHETIC\n-    };\n-\n-    public Set<String> getMethodModifiers() {\n-        return getModifiers(methodModifiers, Kind.Method);\n-    }\n-\n-    public Set<String> getMethodFlags() {\n-        return getFlags(methodFlags, Kind.Method);\n-    }\n-\n-    private Set<String> getModifiers(int[] modifierFlags, Kind t) {\n-        return getModifiers(flags, modifierFlags, t);\n-    }\n-\n-    private static Set<String> getModifiers(int flags, int[] modifierFlags, Kind t) {\n-        Set<String> s = new LinkedHashSet<>();\n-        for (int m: modifierFlags) {\n-            if ((flags & m) != 0)\n-                s.add(flagToModifier(m, t));\n-        }\n-        return s;\n-    }\n-\n-    private Set<String> getFlags(int[] expectedFlags, Kind t) {\n-        Set<String> s = new LinkedHashSet<>();\n-        int f = flags;\n-        for (int e: expectedFlags) {\n-            if ((f & e) != 0) {\n-                s.add(flagToName(e, t));\n-                f = f & ~e;\n-            }\n-        }\n-        while (f != 0) {\n-            int bit = Integer.highestOneBit(f);\n-            s.add(\"0x\" + Integer.toHexString(bit));\n-            f = f & ~bit;\n-        }\n-        return s;\n-    }\n-\n-    private static String flagToModifier(int flag, Kind t) {\n-        switch (flag) {\n-            case ACC_PUBLIC:\n-                return \"public\";\n-            case ACC_PRIVATE:\n-                return \"private\";\n-            case ACC_PROTECTED:\n-                return \"protected\";\n-            case ACC_STATIC:\n-                return \"static\";\n-            case ACC_FINAL:\n-                return \"final\";\n-            case ACC_SYNCHRONIZED:\n-                return \"synchronized\";\n-            case 0x80:\n-                return (t == Kind.Field ? \"transient\" : null);\n-            case ACC_VOLATILE:\n-                return \"volatile\";\n-            case ACC_NATIVE:\n-                return \"native\";\n-            case ACC_ABSTRACT:\n-                return \"abstract\";\n-            case ACC_STRICT:\n-                return \"strictfp\";\n-            case ACC_MANDATED:\n-                return \"mandated\";\n-            default:\n-                return null;\n-        }\n-    }\n-\n-    private static String flagToName(int flag, Kind t) {\n-        switch (flag) {\n-        case ACC_PUBLIC:\n-            return \"ACC_PUBLIC\";\n-        case ACC_PRIVATE:\n-            return \"ACC_PRIVATE\";\n-        case ACC_PROTECTED:\n-            return \"ACC_PROTECTED\";\n-        case ACC_STATIC:\n-            return \"ACC_STATIC\";\n-        case ACC_FINAL:\n-            return \"ACC_FINAL\";\n-        case 0x20:\n-            return (t == Kind.Class ? \"ACC_SUPER\" : \"ACC_SYNCHRONIZED\");\n-        case 0x40:\n-            return (t == Kind.Field ? \"ACC_VOLATILE\" : \"ACC_BRIDGE\");\n-        case 0x80:\n-            return (t == Kind.Field ? \"ACC_TRANSIENT\" : \"ACC_VARARGS\");\n-        case ACC_NATIVE:\n-            return \"ACC_NATIVE\";\n-        case ACC_INTERFACE:\n-            return \"ACC_INTERFACE\";\n-        case ACC_ABSTRACT:\n-            return \"ACC_ABSTRACT\";\n-        case ACC_STRICT:\n-            return \"ACC_STRICT\";\n-        case ACC_SYNTHETIC:\n-            return \"ACC_SYNTHETIC\";\n-        case ACC_ANNOTATION:\n-            return \"ACC_ANNOTATION\";\n-        case ACC_ENUM:\n-            return \"ACC_ENUM\";\n-        case 0x8000:\n-            return (t == Kind.Class ? \"ACC_MODULE\" : \"ACC_MANDATED\");\n-        default:\n-            return null;\n-        }\n-    }\n-\n-    public final int flags;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AccessFlags.java","additions":0,"deletions":259,"binary":false,"changes":259,"status":"deleted"},{"patch":"@@ -1,276 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2009, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.16.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Annotation {\n-    static class InvalidAnnotation extends AttributeException {\n-        private static final long serialVersionUID = -4620480740735772708L;\n-        InvalidAnnotation(String msg) {\n-            super(msg);\n-        }\n-    }\n-\n-    Annotation(ClassReader cr) throws IOException, InvalidAnnotation {\n-        type_index = cr.readUnsignedShort();\n-        num_element_value_pairs = cr.readUnsignedShort();\n-        element_value_pairs = new element_value_pair[num_element_value_pairs];\n-        for (int i = 0; i < element_value_pairs.length; i++)\n-            element_value_pairs[i] = new element_value_pair(cr);\n-    }\n-\n-    public Annotation(ConstantPool constant_pool,\n-            int type_index,\n-            element_value_pair[] element_value_pairs) {\n-        this.type_index = type_index;\n-        num_element_value_pairs = element_value_pairs.length;\n-        this.element_value_pairs = element_value_pairs;\n-    }\n-\n-    public int length() {\n-        int n = 2 \/*type_index*\/ + 2 \/*num_element_value_pairs*\/;\n-        for (element_value_pair pair: element_value_pairs)\n-            n += pair.length();\n-        return n;\n-    }\n-\n-    public final int type_index;\n-    public final int num_element_value_pairs;\n-    public final element_value_pair element_value_pairs[];\n-\n-    \/**\n-     * See JVMS, section 4.8.16.1.\n-     *\/\n-    public abstract static class element_value {\n-        public static element_value read(ClassReader cr)\n-                throws IOException, InvalidAnnotation {\n-            int tag = cr.readUnsignedByte();\n-            switch (tag) {\n-            case 'B':\n-            case 'C':\n-            case 'D':\n-            case 'F':\n-            case 'I':\n-            case 'J':\n-            case 'S':\n-            case 'Z':\n-            case 's':\n-                return new Primitive_element_value(cr, tag);\n-\n-            case 'e':\n-                return new Enum_element_value(cr, tag);\n-\n-            case 'c':\n-                return new Class_element_value(cr, tag);\n-\n-            case '@':\n-                return new Annotation_element_value(cr, tag);\n-\n-            case '[':\n-                return new Array_element_value(cr, tag);\n-\n-            default:\n-                throw new InvalidAnnotation(\"unrecognized tag: \" + tag);\n-            }\n-        }\n-\n-        protected element_value(int tag) {\n-            this.tag = tag;\n-        }\n-\n-        public abstract int length();\n-\n-        public abstract <R,P> R accept(Visitor<R,P> visitor, P p);\n-\n-        public interface Visitor<R,P> {\n-            R visitPrimitive(Primitive_element_value ev, P p);\n-            R visitEnum(Enum_element_value ev, P p);\n-            R visitClass(Class_element_value ev, P p);\n-            R visitAnnotation(Annotation_element_value ev, P p);\n-            R visitArray(Array_element_value ev, P p);\n-        }\n-\n-        public final int tag;\n-    }\n-\n-    public static class Primitive_element_value extends element_value {\n-        Primitive_element_value(ClassReader cr, int tag) throws IOException {\n-            super(tag);\n-            const_value_index = cr.readUnsignedShort();\n-        }\n-\n-        public Primitive_element_value(int const_value_index, int tag) {\n-            super(tag);\n-            this.const_value_index = const_value_index;\n-        }\n-\n-        @Override\n-        public int length() {\n-            return 2;\n-        }\n-\n-        public <R,P> R accept(Visitor<R,P> visitor, P p) {\n-            return visitor.visitPrimitive(this, p);\n-        }\n-\n-        public final int const_value_index;\n-\n-    }\n-\n-    public static class Enum_element_value extends element_value {\n-        Enum_element_value(ClassReader cr, int tag) throws IOException {\n-            super(tag);\n-            type_name_index = cr.readUnsignedShort();\n-            const_name_index = cr.readUnsignedShort();\n-        }\n-\n-        public Enum_element_value(int type_name_index, int const_name_index, int tag) {\n-            super(tag);\n-            this.type_name_index = type_name_index;\n-            this.const_name_index = const_name_index;\n-        }\n-\n-        @Override\n-        public int length() {\n-            return 4;\n-        }\n-\n-        public <R,P> R accept(Visitor<R,P> visitor, P p) {\n-            return visitor.visitEnum(this, p);\n-        }\n-\n-        public final int type_name_index;\n-        public final int const_name_index;\n-    }\n-\n-    public static class Class_element_value extends element_value {\n-        Class_element_value(ClassReader cr, int tag) throws IOException {\n-            super(tag);\n-            class_info_index = cr.readUnsignedShort();\n-        }\n-\n-        public Class_element_value(int class_info_index, int tag) {\n-            super(tag);\n-            this.class_info_index = class_info_index;\n-        }\n-\n-        @Override\n-        public int length() {\n-            return 2;\n-        }\n-\n-        public <R,P> R accept(Visitor<R,P> visitor, P p) {\n-            return visitor.visitClass(this, p);\n-        }\n-\n-        public final int class_info_index;\n-    }\n-\n-    public static class Annotation_element_value extends element_value {\n-        Annotation_element_value(ClassReader cr, int tag)\n-                throws IOException, InvalidAnnotation {\n-            super(tag);\n-            annotation_value = new Annotation(cr);\n-        }\n-\n-        public Annotation_element_value(Annotation annotation_value, int tag) {\n-            super(tag);\n-            this.annotation_value = annotation_value;\n-        }\n-\n-        @Override\n-        public int length() {\n-            return annotation_value.length();\n-        }\n-\n-        public <R,P> R accept(Visitor<R,P> visitor, P p) {\n-            return visitor.visitAnnotation(this, p);\n-        }\n-\n-        public final Annotation annotation_value;\n-    }\n-\n-    public static class Array_element_value extends element_value {\n-        Array_element_value(ClassReader cr, int tag)\n-                throws IOException, InvalidAnnotation {\n-            super(tag);\n-            num_values = cr.readUnsignedShort();\n-            values = new element_value[num_values];\n-            for (int i = 0; i < values.length; i++)\n-                values[i] = element_value.read(cr);\n-        }\n-\n-        public Array_element_value(element_value[] values, int tag) {\n-            super(tag);\n-            this.num_values = values.length;\n-            this.values = values;\n-        }\n-\n-        @Override\n-        public int length() {\n-            int n = 2;\n-            for (int i = 0; i < values.length; i++)\n-                n += values[i].length();\n-            return n;\n-        }\n-\n-        public <R,P> R accept(Visitor<R,P> visitor, P p) {\n-            return visitor.visitArray(this, p);\n-        }\n-\n-        public final int num_values;\n-        public final element_value[] values;\n-    }\n-\n-    public static class element_value_pair {\n-        element_value_pair(ClassReader cr)\n-                throws IOException, InvalidAnnotation {\n-            element_name_index = cr.readUnsignedShort();\n-            value = element_value.read(cr);\n-        }\n-\n-        public element_value_pair(int element_name_index, element_value value) {\n-            this.element_name_index = element_name_index;\n-            this.value = value;\n-        }\n-\n-        public int length() {\n-            return 2 + value.length();\n-        }\n-\n-        public final int element_name_index;\n-        public final element_value value;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Annotation.java","additions":0,"deletions":276,"binary":false,"changes":276,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.15.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class AnnotationDefault_attribute extends Attribute {\n-    AnnotationDefault_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, Annotation.InvalidAnnotation {\n-        super(name_index, length);\n-        default_value = Annotation.element_value.read(cr);\n-    }\n-\n-    public AnnotationDefault_attribute(ConstantPool constant_pool, Annotation.element_value default_value)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.AnnotationDefault), default_value);\n-    }\n-\n-    public AnnotationDefault_attribute(int name_index, Annotation.element_value default_value) {\n-        super(name_index, default_value.length());\n-        this.default_value = default_value;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitAnnotationDefault(this, data);\n-    }\n-\n-    public final Annotation.element_value default_value;\n-}\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AnnotationDefault_attribute.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,222 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Constructor;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-\n-public abstract class Attribute {\n-    public static final String AnnotationDefault        = \"AnnotationDefault\";\n-    public static final String BootstrapMethods         = \"BootstrapMethods\";\n-    public static final String CharacterRangeTable      = \"CharacterRangeTable\";\n-    public static final String Code                     = \"Code\";\n-    public static final String ConstantValue            = \"ConstantValue\";\n-    public static final String CompilationID            = \"CompilationID\";\n-    public static final String Deprecated               = \"Deprecated\";\n-    public static final String EnclosingMethod          = \"EnclosingMethod\";\n-    public static final String Exceptions               = \"Exceptions\";\n-    public static final String InnerClasses             = \"InnerClasses\";\n-    public static final String LineNumberTable          = \"LineNumberTable\";\n-    public static final String LocalVariableTable       = \"LocalVariableTable\";\n-    public static final String LocalVariableTypeTable   = \"LocalVariableTypeTable\";\n-    public static final String MethodParameters         = \"MethodParameters\";\n-    public static final String Module                   = \"Module\";\n-    public static final String ModuleHashes             = \"ModuleHashes\";\n-    public static final String ModuleMainClass          = \"ModuleMainClass\";\n-    public static final String ModulePackages           = \"ModulePackages\";\n-    public static final String ModuleResolution         = \"ModuleResolution\";\n-    public static final String ModuleTarget             = \"ModuleTarget\";\n-    public static final String NestHost                 = \"NestHost\";\n-    public static final String NestMembers              = \"NestMembers\";\n-    public static final String Record                   = \"Record\";\n-    public static final String RuntimeVisibleAnnotations = \"RuntimeVisibleAnnotations\";\n-    public static final String RuntimeInvisibleAnnotations = \"RuntimeInvisibleAnnotations\";\n-    public static final String RuntimeVisibleParameterAnnotations = \"RuntimeVisibleParameterAnnotations\";\n-    public static final String RuntimeInvisibleParameterAnnotations = \"RuntimeInvisibleParameterAnnotations\";\n-    public static final String RuntimeVisibleTypeAnnotations = \"RuntimeVisibleTypeAnnotations\";\n-    public static final String RuntimeInvisibleTypeAnnotations = \"RuntimeInvisibleTypeAnnotations\";\n-    public static final String PermittedSubclasses      = \"PermittedSubclasses\";\n-    public static final String Signature                = \"Signature\";\n-    public static final String SourceDebugExtension     = \"SourceDebugExtension\";\n-    public static final String SourceFile               = \"SourceFile\";\n-    public static final String SourceID                 = \"SourceID\";\n-    public static final String StackMap                 = \"StackMap\";\n-    public static final String StackMapTable            = \"StackMapTable\";\n-    public static final String Synthetic                = \"Synthetic\";\n-\n-    public static class Factory {\n-        public Factory() {\n-            \/\/ defer init of standardAttributeClasses until after options set up\n-        }\n-\n-        public Attribute createAttribute(ClassReader cr, int name_index, byte[] data)\n-                throws IOException {\n-            if (standardAttributes == null) {\n-                init();\n-            }\n-\n-            ConstantPool cp = cr.getConstantPool();\n-            String reasonForDefaultAttr;\n-            try {\n-                String name = cp.getUTF8Value(name_index);\n-                Class<? extends Attribute> attrClass = standardAttributes.get(name);\n-                if (attrClass != null) {\n-                    try {\n-                        Class<?>[] constrArgTypes = {ClassReader.class, int.class, int.class};\n-                        Constructor<? extends Attribute> constr = attrClass.getDeclaredConstructor(constrArgTypes);\n-                        return constr.newInstance(cr, name_index, data.length);\n-                    } catch (Throwable t) {\n-                        reasonForDefaultAttr = t.toString();\n-                        \/\/ fall through and use DefaultAttribute\n-                        \/\/ t.printStackTrace();\n-                    }\n-                } else {\n-                    reasonForDefaultAttr = \"unknown attribute\";\n-                }\n-            } catch (ConstantPoolException e) {\n-                reasonForDefaultAttr = e.toString();\n-                \/\/ fall through and use DefaultAttribute\n-            }\n-            return new DefaultAttribute(cr, name_index, data, reasonForDefaultAttr);\n-        }\n-\n-        protected void init() {\n-            standardAttributes = new HashMap<>();\n-            standardAttributes.put(AnnotationDefault, AnnotationDefault_attribute.class);\n-            standardAttributes.put(BootstrapMethods,  BootstrapMethods_attribute.class);\n-            standardAttributes.put(CharacterRangeTable, CharacterRangeTable_attribute.class);\n-            standardAttributes.put(Code,              Code_attribute.class);\n-            standardAttributes.put(CompilationID,     CompilationID_attribute.class);\n-            standardAttributes.put(ConstantValue,     ConstantValue_attribute.class);\n-            standardAttributes.put(Deprecated,        Deprecated_attribute.class);\n-            standardAttributes.put(EnclosingMethod,   EnclosingMethod_attribute.class);\n-            standardAttributes.put(Exceptions,        Exceptions_attribute.class);\n-            standardAttributes.put(InnerClasses,      InnerClasses_attribute.class);\n-            standardAttributes.put(LineNumberTable,   LineNumberTable_attribute.class);\n-            standardAttributes.put(LocalVariableTable, LocalVariableTable_attribute.class);\n-            standardAttributes.put(LocalVariableTypeTable, LocalVariableTypeTable_attribute.class);\n-            standardAttributes.put(MethodParameters,  MethodParameters_attribute.class);\n-            standardAttributes.put(Module,            Module_attribute.class);\n-            standardAttributes.put(ModuleHashes,      ModuleHashes_attribute.class);\n-            standardAttributes.put(ModuleMainClass,   ModuleMainClass_attribute.class);\n-            standardAttributes.put(ModulePackages,    ModulePackages_attribute.class);\n-            standardAttributes.put(ModuleResolution,  ModuleResolution_attribute.class);\n-            standardAttributes.put(ModuleTarget,      ModuleTarget_attribute.class);\n-            standardAttributes.put(NestHost, NestHost_attribute.class);\n-            standardAttributes.put(NestMembers, NestMembers_attribute.class);\n-            standardAttributes.put(Record, Record_attribute.class);\n-            standardAttributes.put(RuntimeInvisibleAnnotations, RuntimeInvisibleAnnotations_attribute.class);\n-            standardAttributes.put(RuntimeInvisibleParameterAnnotations, RuntimeInvisibleParameterAnnotations_attribute.class);\n-            standardAttributes.put(RuntimeVisibleAnnotations, RuntimeVisibleAnnotations_attribute.class);\n-            standardAttributes.put(RuntimeVisibleParameterAnnotations, RuntimeVisibleParameterAnnotations_attribute.class);\n-            standardAttributes.put(RuntimeVisibleTypeAnnotations, RuntimeVisibleTypeAnnotations_attribute.class);\n-            standardAttributes.put(RuntimeInvisibleTypeAnnotations, RuntimeInvisibleTypeAnnotations_attribute.class);\n-            standardAttributes.put(PermittedSubclasses, PermittedSubclasses_attribute.class);\n-            standardAttributes.put(Signature,         Signature_attribute.class);\n-            standardAttributes.put(SourceDebugExtension, SourceDebugExtension_attribute.class);\n-            standardAttributes.put(SourceFile,        SourceFile_attribute.class);\n-            standardAttributes.put(SourceID,          SourceID_attribute.class);\n-            standardAttributes.put(StackMap,          StackMap_attribute.class);\n-            standardAttributes.put(StackMapTable,     StackMapTable_attribute.class);\n-            standardAttributes.put(Synthetic,         Synthetic_attribute.class);\n-        }\n-\n-        private Map<String,Class<? extends Attribute>> standardAttributes;\n-    }\n-\n-    public static Attribute read(ClassReader cr) throws IOException {\n-        return cr.readAttribute();\n-    }\n-\n-    protected Attribute(int name_index, int length) {\n-        attribute_name_index = name_index;\n-        attribute_length = length;\n-    }\n-\n-    public String getName(ConstantPool constant_pool) throws ConstantPoolException {\n-        return constant_pool.getUTF8Value(attribute_name_index);\n-    }\n-\n-    public abstract <R,D> R accept(Attribute.Visitor<R,D> visitor, D data);\n-\n-    public int byteLength() {\n-        return 6 + attribute_length;\n-    }\n-\n-    public final int attribute_name_index;\n-    public final int attribute_length;\n-\n-\n-    public interface Visitor<R,P> {\n-        R visitBootstrapMethods(BootstrapMethods_attribute attr, P p);\n-        R visitDefault(DefaultAttribute attr, P p);\n-        R visitAnnotationDefault(AnnotationDefault_attribute attr, P p);\n-        R visitCharacterRangeTable(CharacterRangeTable_attribute attr, P p);\n-        R visitCode(Code_attribute attr, P p);\n-        R visitCompilationID(CompilationID_attribute attr, P p);\n-        R visitConstantValue(ConstantValue_attribute attr, P p);\n-        R visitDeprecated(Deprecated_attribute attr, P p);\n-        R visitEnclosingMethod(EnclosingMethod_attribute attr, P p);\n-        R visitExceptions(Exceptions_attribute attr, P p);\n-        R visitInnerClasses(InnerClasses_attribute attr, P p);\n-        R visitLineNumberTable(LineNumberTable_attribute attr, P p);\n-        R visitLocalVariableTable(LocalVariableTable_attribute attr, P p);\n-        R visitLocalVariableTypeTable(LocalVariableTypeTable_attribute attr, P p);\n-        R visitMethodParameters(MethodParameters_attribute attr, P p);\n-        R visitModule(Module_attribute attr, P p);\n-        R visitModuleHashes(ModuleHashes_attribute attr, P p);\n-        R visitModuleMainClass(ModuleMainClass_attribute attr, P p);\n-        R visitModulePackages(ModulePackages_attribute attr, P p);\n-        R visitModuleResolution(ModuleResolution_attribute attr, P p);\n-        R visitModuleTarget(ModuleTarget_attribute attr, P p);\n-        R visitNestHost(NestHost_attribute attr, P p);\n-        R visitNestMembers(NestMembers_attribute attr, P p);\n-        R visitRecord(Record_attribute attr, P p);\n-        R visitRuntimeVisibleAnnotations(RuntimeVisibleAnnotations_attribute attr, P p);\n-        R visitRuntimeInvisibleAnnotations(RuntimeInvisibleAnnotations_attribute attr, P p);\n-        R visitRuntimeVisibleParameterAnnotations(RuntimeVisibleParameterAnnotations_attribute attr, P p);\n-        R visitRuntimeInvisibleParameterAnnotations(RuntimeInvisibleParameterAnnotations_attribute attr, P p);\n-        R visitRuntimeVisibleTypeAnnotations(RuntimeVisibleTypeAnnotations_attribute attr, P p);\n-        R visitRuntimeInvisibleTypeAnnotations(RuntimeInvisibleTypeAnnotations_attribute attr, P p);\n-        R visitPermittedSubclasses(PermittedSubclasses_attribute attr, P p);\n-        R visitSignature(Signature_attribute attr, P p);\n-        R visitSourceDebugExtension(SourceDebugExtension_attribute attr, P p);\n-        R visitSourceFile(SourceFile_attribute attr, P p);\n-        R visitSourceID(SourceID_attribute attr, P p);\n-        R visitStackMap(StackMap_attribute attr, P p);\n-        R visitStackMapTable(StackMapTable_attribute attr, P p);\n-        R visitSynthetic(Synthetic_attribute attr, P p);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attribute.java","additions":0,"deletions":222,"binary":false,"changes":222,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2009, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-\/*\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class AttributeException extends Exception {\n-    private static final long serialVersionUID = -4231486387714867770L;\n-    AttributeException() { }\n-\n-    AttributeException(String msg) {\n-        super(msg);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/AttributeException.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-\n-\/*\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Attributes implements Iterable<Attribute> {\n-\n-    public final Attribute[] attrs;\n-    public final Map<String, Attribute> map;\n-\n-    Attributes(ClassReader cr) throws IOException {\n-        map = new HashMap<>();\n-        int attrs_count = cr.readUnsignedShort();\n-        attrs = new Attribute[attrs_count];\n-        for (int i = 0; i < attrs_count; i++) {\n-            Attribute attr = Attribute.read(cr);\n-            attrs[i] = attr;\n-            try {\n-                map.put(attr.getName(cr.getConstantPool()), attr);\n-            } catch (ConstantPoolException e) {\n-                \/\/ don't enter invalid names in map\n-            }\n-        }\n-    }\n-\n-    public Attributes(ConstantPool constant_pool, Attribute[] attrs) {\n-        this.attrs = attrs;\n-        map = new HashMap<>();\n-        for (Attribute attr : attrs) {\n-            try {\n-                map.put(attr.getName(constant_pool), attr);\n-            } catch (ConstantPoolException e) {\n-                \/\/ don't enter invalid names in map\n-            }\n-        }\n-    }\n-\n-    public Attributes(Map<String, Attribute> attributes) {\n-        this.attrs = attributes.values().toArray(new Attribute[attributes.size()]);\n-        map = attributes;\n-    }\n-\n-    public Iterator<Attribute> iterator() {\n-        return Arrays.asList(attrs).iterator();\n-    }\n-\n-    public Attribute get(int index) {\n-        return attrs[index];\n-    }\n-\n-    public Attribute get(String name) {\n-        return map.get(name);\n-    }\n-\n-    public int getIndex(ConstantPool constant_pool, String name) {\n-        for (int i = 0; i < attrs.length; i++) {\n-            Attribute attr = attrs[i];\n-            try {\n-                if (attr != null && attr.getName(constant_pool).equals(name))\n-                    return i;\n-            } catch (ConstantPoolException e) {\n-                \/\/ ignore invalid entries\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    public int size() {\n-        return attrs.length;\n-    }\n-\n-    public int byteLength() {\n-        int length = 2;\n-        for (Attribute a: attrs)\n-            length += a.byteLength();\n-        return length;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Attributes.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS 4.7.21\n- * http:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.7.21\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class BootstrapMethods_attribute extends Attribute {\n-    public final BootstrapMethodSpecifier[] bootstrap_method_specifiers;\n-\n-    BootstrapMethods_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, AttributeException {\n-        super(name_index, length);\n-        int bootstrap_method_count = cr.readUnsignedShort();\n-        bootstrap_method_specifiers = new BootstrapMethodSpecifier[bootstrap_method_count];\n-        for (int i = 0; i < bootstrap_method_specifiers.length; i++)\n-            bootstrap_method_specifiers[i] = new BootstrapMethodSpecifier(cr);\n-    }\n-\n-    public  BootstrapMethods_attribute(int name_index, BootstrapMethodSpecifier[] bootstrap_method_specifiers) {\n-        super(name_index, length(bootstrap_method_specifiers));\n-        this.bootstrap_method_specifiers = bootstrap_method_specifiers;\n-    }\n-\n-    public static int length(BootstrapMethodSpecifier[] bootstrap_method_specifiers) {\n-        int n = 2;\n-        for (BootstrapMethodSpecifier b : bootstrap_method_specifiers)\n-            n += b.length();\n-        return n;\n-    }\n-\n-    @Override\n-    public <R, P> R accept(Visitor<R, P> visitor, P p) {\n-        return visitor.visitBootstrapMethods(this, p);\n-    }\n-\n-    public static class BootstrapMethodSpecifier {\n-        public int bootstrap_method_ref;\n-        public int[] bootstrap_arguments;\n-\n-        public BootstrapMethodSpecifier(int bootstrap_method_ref, int[] bootstrap_arguments) {\n-            this.bootstrap_method_ref = bootstrap_method_ref;\n-            this.bootstrap_arguments = bootstrap_arguments;\n-        }\n-        BootstrapMethodSpecifier(ClassReader cr) throws IOException {\n-            bootstrap_method_ref = cr.readUnsignedShort();\n-            int method_count = cr.readUnsignedShort();\n-            bootstrap_arguments = new int[method_count];\n-            for (int i = 0; i < bootstrap_arguments.length; i++) {\n-                bootstrap_arguments[i] = cr.readUnsignedShort();\n-            }\n-        }\n-\n-        int length() {\n-            \/\/ u2 (method_ref) + u2 (argc) + u2 * argc\n-            return 2 + 2 + (bootstrap_arguments.length * 2);\n-        }\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/BootstrapMethods_attribute.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class CharacterRangeTable_attribute  extends Attribute {\n-    public static final int CRT_STATEMENT       = 0x0001;\n-    public static final int CRT_BLOCK           = 0x0002;\n-    public static final int CRT_ASSIGNMENT      = 0x0004;\n-    public static final int CRT_FLOW_CONTROLLER = 0x0008;\n-    public static final int CRT_FLOW_TARGET     = 0x0010;\n-    public static final int CRT_INVOKE          = 0x0020;\n-    public static final int CRT_CREATE          = 0x0040;\n-    public static final int CRT_BRANCH_TRUE     = 0x0080;\n-    public static final int CRT_BRANCH_FALSE    = 0x0100;\n-\n-    CharacterRangeTable_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        int character_range_table_length = cr.readUnsignedShort();\n-        character_range_table = new Entry[character_range_table_length];\n-        for (int i = 0; i < character_range_table_length; i++)\n-            character_range_table[i] = new Entry(cr);\n-    }\n-\n-    public CharacterRangeTable_attribute(ConstantPool constant_pool, Entry[] character_range_table)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.CharacterRangeTable), character_range_table);\n-    }\n-\n-    public CharacterRangeTable_attribute(int name_index, Entry[] character_range_table) {\n-        super(name_index, 2 + character_range_table.length * Entry.length());\n-        this.character_range_table = character_range_table;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitCharacterRangeTable(this, data);\n-    }\n-\n-    public final Entry[] character_range_table;\n-\n-    public static class Entry {\n-        Entry(ClassReader cr) throws IOException {\n-            start_pc = cr.readUnsignedShort();\n-            end_pc = cr.readUnsignedShort();\n-            character_range_start = cr.readInt();\n-            character_range_end = cr.readInt();\n-            flags = cr.readUnsignedShort();\n-        }\n-\n-        public static int length() {\n-            return 14;\n-        }\n-\n-        public final int start_pc;\n-        public final int end_pc;\n-        public final int character_range_start;\n-        public final int character_range_end;\n-        public final int flags;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/CharacterRangeTable_attribute.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-\n-import static com.sun.tools.classfile.AccessFlags.*;\n-\n-\/**\n- * See JVMS, section 4.2.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ClassFile {\n-    public static ClassFile read(File file)\n-            throws IOException, ConstantPoolException {\n-        return read(file.toPath(), new Attribute.Factory());\n-    }\n-\n-    public static ClassFile read(Path input)\n-            throws IOException, ConstantPoolException {\n-        return read(input, new Attribute.Factory());\n-    }\n-\n-    public static ClassFile read(Path input, Attribute.Factory attributeFactory)\n-            throws IOException, ConstantPoolException {\n-        try (InputStream in = Files.newInputStream(input)) {\n-            return new ClassFile(in, attributeFactory);\n-        }\n-    }\n-\n-    public static ClassFile read(File file, Attribute.Factory attributeFactory)\n-            throws IOException, ConstantPoolException {\n-        return read(file.toPath(), attributeFactory);\n-    }\n-\n-    public static ClassFile read(InputStream in)\n-            throws IOException, ConstantPoolException {\n-        return new ClassFile(in, new Attribute.Factory());\n-    }\n-\n-    public static ClassFile read(InputStream in, Attribute.Factory attributeFactory)\n-            throws IOException, ConstantPoolException {\n-        return new ClassFile(in, attributeFactory);\n-    }\n-\n-    ClassFile(InputStream in, Attribute.Factory attributeFactory) throws IOException, ConstantPoolException {\n-        ClassReader cr = new ClassReader(this, in, attributeFactory);\n-        magic = cr.readInt();\n-        minor_version = cr.readUnsignedShort();\n-        major_version = cr.readUnsignedShort();\n-        constant_pool = new ConstantPool(cr);\n-        access_flags = new AccessFlags(cr);\n-        this_class = cr.readUnsignedShort();\n-        super_class = cr.readUnsignedShort();\n-\n-        int interfaces_count = cr.readUnsignedShort();\n-        interfaces = new int[interfaces_count];\n-        for (int i = 0; i < interfaces_count; i++)\n-            interfaces[i] = cr.readUnsignedShort();\n-\n-        int fields_count = cr.readUnsignedShort();\n-        fields = new Field[fields_count];\n-        for (int i = 0; i < fields_count; i++)\n-            fields[i] = new Field(cr);\n-\n-        int methods_count = cr.readUnsignedShort();\n-        methods = new Method[methods_count];\n-        for (int i = 0; i < methods_count; i++)\n-            methods[i] = new Method(cr);\n-\n-        attributes = new Attributes(cr);\n-    }\n-\n-    public ClassFile(int magic, int minor_version, int major_version,\n-            ConstantPool constant_pool, AccessFlags access_flags,\n-            int this_class, int super_class, int[] interfaces,\n-            Field[] fields, Method[] methods, Attributes attributes) {\n-        this.magic = magic;\n-        this.minor_version = minor_version;\n-        this.major_version = major_version;\n-        this.constant_pool = constant_pool;\n-        this.access_flags = access_flags;\n-        this.this_class = this_class;\n-        this.super_class = super_class;\n-        this.interfaces = interfaces;\n-        this.fields = fields;\n-        this.methods = methods;\n-        this.attributes = attributes;\n-    }\n-\n-    public String getName() throws ConstantPoolException {\n-        return constant_pool.getClassInfo(this_class).getName();\n-    }\n-\n-    public String getSuperclassName() throws ConstantPoolException {\n-        return constant_pool.getClassInfo(super_class).getName();\n-    }\n-\n-    public String getInterfaceName(int i) throws ConstantPoolException {\n-        return constant_pool.getClassInfo(interfaces[i]).getName();\n-    }\n-\n-    public Attribute getAttribute(String name) {\n-        return attributes.get(name);\n-    }\n-\n-    public boolean isClass() {\n-        return !isInterface();\n-    }\n-\n-    public boolean isInterface() {\n-        return access_flags.is(ACC_INTERFACE);\n-    }\n-\n-    public int byteLength() {\n-        return  4 +     \/\/ magic\n-                2 +     \/\/ minor\n-                2 +     \/\/ major\n-                constant_pool.byteLength() +\n-                2 +     \/\/ access flags\n-                2 +     \/\/ this_class\n-                2 +     \/\/ super_class\n-                byteLength(interfaces) +\n-                byteLength(fields) +\n-                byteLength(methods) +\n-                attributes.byteLength();\n-    }\n-\n-    private int byteLength(int[] indices) {\n-        return 2 + 2 * indices.length;\n-    }\n-\n-    private int byteLength(Field[] fields) {\n-        int length = 2;\n-        for (Field f: fields)\n-            length += f.byteLength();\n-        return length;\n-    }\n-\n-    private int byteLength(Method[] methods) {\n-        int length = 2;\n-        for (Method m: methods)\n-            length += m.byteLength();\n-        return length;\n-    }\n-\n-    public final int magic;\n-    public final int minor_version;\n-    public final int major_version;\n-    public final ConstantPool constant_pool;\n-    public final AccessFlags access_flags;\n-    public final int this_class;\n-    public final int super_class;\n-    public final int[] interfaces;\n-    public final Field[] fields;\n-    public final Method[] methods;\n-    public final Attributes attributes;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassFile.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.BufferedInputStream;\n-import java.io.ByteArrayInputStream;\n-import java.io.DataInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.util.Objects;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ClassReader {\n-    ClassReader(ClassFile classFile, InputStream in, Attribute.Factory attributeFactory) throws IOException {\n-        this.classFile = Objects.requireNonNull(classFile);\n-        this.attributeFactory = Objects.requireNonNull(attributeFactory);\n-        this.in = new DataInputStream(new BufferedInputStream(in));\n-    }\n-\n-    ClassFile getClassFile() {\n-        return classFile;\n-    }\n-\n-    ConstantPool getConstantPool() {\n-        return classFile.constant_pool;\n-    }\n-\n-    public Attribute readAttribute() throws IOException {\n-        int name_index = readUnsignedShort();\n-        int length = readInt();\n-        if (length < 0) { \/\/ we have an overflow as max_value(u4) > max_value(int)\n-            String attrName;\n-            try {\n-                attrName = getConstantPool().getUTF8Value(name_index);\n-            } catch (ConstantPool.InvalidIndex | ConstantPool.UnexpectedEntry e) {\n-                attrName = \"\";\n-            }\n-            throw new FatalError(String.format(\"attribute %s too big to handle\", attrName));\n-        }\n-        byte[] data = new byte[length];\n-        readFully(data);\n-\n-        DataInputStream prev = in;\n-        in = new DataInputStream(new ByteArrayInputStream(data));\n-        try {\n-            return attributeFactory.createAttribute(this, name_index, data);\n-        } finally {\n-            in = prev;\n-        }\n-    }\n-\n-    public void readFully(byte[] b) throws IOException {\n-        in.readFully(b);\n-    }\n-\n-    public int readUnsignedByte() throws IOException {\n-        return in.readUnsignedByte();\n-    }\n-\n-    public int readUnsignedShort() throws IOException {\n-        return in.readUnsignedShort();\n-    }\n-\n-    public int readInt() throws IOException {\n-        return in.readInt();\n-    }\n-\n-    public long readLong() throws IOException {\n-        return in.readLong();\n-    }\n-\n-    public float readFloat() throws IOException {\n-        return in.readFloat();\n-    }\n-\n-    public double readDouble() throws IOException {\n-        return in.readDouble();\n-    }\n-\n-    public String readUTF() throws IOException {\n-        return in.readUTF();\n-    }\n-\n-    private DataInputStream in;\n-    private ClassFile classFile;\n-    private Attribute.Factory attributeFactory;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassReader.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -1,469 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.util.Map;\n-\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Dynamic_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Double_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Fieldref_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Float_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Integer_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_InterfaceMethodref_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_InvokeDynamic_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Long_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_MethodHandle_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_MethodType_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Methodref_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Module_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_NameAndType_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Package_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_String_info;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Utf8_info;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-\n-\/**\n- * Rewrites a class file using a map of translations.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ClassTranslator\n-        implements ConstantPool.Visitor<ConstantPool.CPInfo,Map<Object,Object>> {\n-    \/**\n-     * Create a new ClassFile from {@code cf}, such that for all entries\n-     * {@code k&nbsp;-\\&gt;&nbsp;v} in {@code translations},\n-     * each occurrence of {@code k} in {@code cf} will be replaced by {@code v}.\n-     * in\n-     * @param cf the class file to be processed\n-     * @param translations the set of translations to be applied\n-     * @return a copy of {@code} with the values in {@code translations} substituted\n-     *\/\n-    public ClassFile translate(ClassFile cf, Map<Object,Object> translations) {\n-        ClassFile cf2 = (ClassFile) translations.get(cf);\n-        if (cf2 == null) {\n-            ConstantPool constant_pool2 = translate(cf.constant_pool, translations);\n-            Field[] fields2 = translate(cf.fields, cf.constant_pool, translations);\n-            Method[] methods2 = translateMethods(cf.methods, cf.constant_pool, translations);\n-            Attributes attributes2 = translateAttributes(cf.attributes, cf.constant_pool,\n-                    translations);\n-\n-            if (constant_pool2 == cf.constant_pool &&\n-                    fields2 == cf.fields &&\n-                    methods2 == cf.methods &&\n-                    attributes2 == cf.attributes)\n-                cf2 = cf;\n-            else\n-                cf2 = new ClassFile(\n-                        cf.magic,\n-                        cf.minor_version,\n-                        cf.major_version,\n-                        constant_pool2,\n-                        cf.access_flags,\n-                        cf.this_class,\n-                        cf.super_class,\n-                        cf.interfaces,\n-                        fields2,\n-                        methods2,\n-                        attributes2);\n-            translations.put(cf, cf2);\n-        }\n-        return cf2;\n-    }\n-\n-    ConstantPool translate(ConstantPool cp, Map<Object,Object> translations) {\n-        ConstantPool cp2 = (ConstantPool) translations.get(cp);\n-        if (cp2 == null) {\n-            ConstantPool.CPInfo[] pool2 = new ConstantPool.CPInfo[cp.size()];\n-            boolean eq = true;\n-            for (int i = 0; i < cp.size(); ) {\n-                ConstantPool.CPInfo cpInfo;\n-                try {\n-                    cpInfo = cp.get(i);\n-                } catch (ConstantPool.InvalidIndex e) {\n-                    throw new IllegalStateException(e);\n-                }\n-                ConstantPool.CPInfo cpInfo2 = translate(cpInfo, translations);\n-                eq &= (cpInfo == cpInfo2);\n-                pool2[i] = cpInfo2;\n-                if (cpInfo.getTag() != cpInfo2.getTag())\n-                    throw new IllegalStateException();\n-                i += cpInfo.size();\n-            }\n-\n-            if (eq)\n-                cp2 = cp;\n-            else\n-                cp2 = new ConstantPool(pool2);\n-\n-            translations.put(cp, cp2);\n-        }\n-        return cp2;\n-    }\n-\n-    ConstantPool.CPInfo translate(ConstantPool.CPInfo cpInfo, Map<Object,Object> translations) {\n-        ConstantPool.CPInfo cpInfo2 = (ConstantPool.CPInfo) translations.get(cpInfo);\n-        if (cpInfo2 == null) {\n-            cpInfo2 = cpInfo.accept(this, translations);\n-            translations.put(cpInfo, cpInfo2);\n-        }\n-        return cpInfo2;\n-    }\n-\n-    Field[] translate(Field[] fields, ConstantPool constant_pool, Map<Object,Object> translations) {\n-        Field[] fields2 = (Field[]) translations.get(fields);\n-        if (fields2 == null) {\n-            fields2 = new Field[fields.length];\n-            for (int i = 0; i < fields.length; i++)\n-                fields2[i] = translate(fields[i], constant_pool, translations);\n-            if (equal(fields, fields2))\n-                fields2 = fields;\n-            translations.put(fields, fields2);\n-        }\n-        return fields2;\n-    }\n-\n-    Field translate(Field field, ConstantPool constant_pool, Map<Object,Object> translations) {\n-        Field field2 = (Field) translations.get(field);\n-        if (field2 == null) {\n-            Attributes attributes2 = translateAttributes(field.attributes, constant_pool,\n-                    translations);\n-\n-            if (attributes2 == field.attributes)\n-                field2 = field;\n-            else\n-                field2 = new Field(\n-                        field.access_flags,\n-                        field.name_index,\n-                        field.descriptor,\n-                        attributes2);\n-            translations.put(field, field2);\n-        }\n-        return field2;\n-    }\n-\n-    Method[] translateMethods(Method[] methods, ConstantPool constant_pool, Map<Object,Object> translations) {\n-        Method[] methods2 = (Method[]) translations.get(methods);\n-        if (methods2 == null) {\n-            methods2 = new Method[methods.length];\n-            for (int i = 0; i < methods.length; i++)\n-                methods2[i] = translate(methods[i], constant_pool, translations);\n-            if (equal(methods, methods2))\n-                methods2 = methods;\n-            translations.put(methods, methods2);\n-        }\n-        return methods2;\n-    }\n-\n-    Method translate(Method method, ConstantPool constant_pool, Map<Object,Object> translations) {\n-        Method method2 = (Method) translations.get(method);\n-        if (method2 == null) {\n-            Attributes attributes2 = translateAttributes(method.attributes, constant_pool,\n-                    translations);\n-\n-            if (attributes2 == method.attributes)\n-                method2 = method;\n-            else\n-                method2 = new Method(\n-                        method.access_flags,\n-                        method.name_index,\n-                        method.descriptor,\n-                        attributes2);\n-            translations.put(method, method2);\n-        }\n-        return method2;\n-    }\n-\n-    Attributes translateAttributes(Attributes attributes,\n-            ConstantPool constant_pool, Map<Object,Object> translations) {\n-        Attributes attributes2 = (Attributes) translations.get(attributes);\n-        if (attributes2 == null) {\n-            Attribute[] attrArray2 = new Attribute[attributes.size()];\n-            ConstantPool constant_pool2 = translate(constant_pool, translations);\n-            boolean attrsEqual = true;\n-            for (int i = 0; i < attributes.size(); i++) {\n-                Attribute attr = attributes.get(i);\n-                Attribute attr2 = translate(attr, translations);\n-                if (attr2 != attr)\n-                    attrsEqual = false;\n-                attrArray2[i] = attr2;\n-            }\n-            if ((constant_pool2 == constant_pool) && attrsEqual)\n-                attributes2 = attributes;\n-            else\n-                attributes2 = new Attributes(constant_pool2, attrArray2);\n-            translations.put(attributes, attributes2);\n-        }\n-        return attributes2;\n-    }\n-\n-    Attribute translate(Attribute attribute, Map<Object,Object> translations) {\n-        Attribute attribute2 = (Attribute) translations.get(attribute);\n-        if (attribute2 == null) {\n-            attribute2 = attribute; \/\/ don't support translation within attributes yet\n-                                    \/\/ (what about Code attribute)\n-            translations.put(attribute, attribute2);\n-        }\n-        return attribute2;\n-    }\n-\n-    private static <T> boolean equal(T[] a1, T[] a2) {\n-        if (a1 == null || a2 == null)\n-            return (a1 == a2);\n-        if (a1.length != a2.length)\n-            return false;\n-        for (int i = 0; i < a1.length; i++) {\n-            if (a1[i] != a2[i])\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    @Override\n-    public CPInfo visitClass(CONSTANT_Class_info info, Map<Object, Object> translations) {\n-        CONSTANT_Class_info info2 = (CONSTANT_Class_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp)\n-                info2 = info;\n-            else\n-                info2 = new CONSTANT_Class_info(cp2, info.name_index);\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitDouble(CONSTANT_Double_info info, Map<Object, Object> translations) {\n-        CONSTANT_Double_info info2 = (CONSTANT_Double_info) translations.get(info);\n-        if (info2 == null) {\n-            info2 = info;\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitFieldref(CONSTANT_Fieldref_info info, Map<Object, Object> translations) {\n-        CONSTANT_Fieldref_info info2 = (CONSTANT_Fieldref_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp)\n-                info2 = info;\n-            else\n-                info2 = new CONSTANT_Fieldref_info(cp2, info.class_index, info.name_and_type_index);\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitFloat(CONSTANT_Float_info info, Map<Object, Object> translations) {\n-        CONSTANT_Float_info info2 = (CONSTANT_Float_info) translations.get(info);\n-        if (info2 == null) {\n-            info2 = info;\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitInteger(CONSTANT_Integer_info info, Map<Object, Object> translations) {\n-        CONSTANT_Integer_info info2 = (CONSTANT_Integer_info) translations.get(info);\n-        if (info2 == null) {\n-            info2 = info;\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info info, Map<Object, Object> translations) {\n-        CONSTANT_InterfaceMethodref_info info2 = (CONSTANT_InterfaceMethodref_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp)\n-                info2 = info;\n-            else\n-                info2 = new CONSTANT_InterfaceMethodref_info(cp2, info.class_index, info.name_and_type_index);\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitInvokeDynamic(CONSTANT_InvokeDynamic_info info, Map<Object, Object> translations) {\n-        CONSTANT_InvokeDynamic_info info2 = (CONSTANT_InvokeDynamic_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp) {\n-                info2 = info;\n-            } else {\n-                info2 = new CONSTANT_InvokeDynamic_info(cp2, info.bootstrap_method_attr_index, info.name_and_type_index);\n-            }\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    public CPInfo visitDynamicConstant(CONSTANT_Dynamic_info info, Map<Object, Object> translations) {\n-        CONSTANT_Dynamic_info info2 = (CONSTANT_Dynamic_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp) {\n-                info2 = info;\n-            } else {\n-                info2 = new CONSTANT_Dynamic_info(cp2, info.bootstrap_method_attr_index, info.name_and_type_index);\n-            }\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitLong(CONSTANT_Long_info info, Map<Object, Object> translations) {\n-        CONSTANT_Long_info info2 = (CONSTANT_Long_info) translations.get(info);\n-        if (info2 == null) {\n-            info2 = info;\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitMethodref(CONSTANT_Methodref_info info, Map<Object, Object> translations) {\n-        CONSTANT_Methodref_info info2 = (CONSTANT_Methodref_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp)\n-                info2 = info;\n-            else\n-                info2 = new CONSTANT_Methodref_info(cp2, info.class_index, info.name_and_type_index);\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitMethodHandle(CONSTANT_MethodHandle_info info, Map<Object, Object> translations) {\n-        CONSTANT_MethodHandle_info info2 = (CONSTANT_MethodHandle_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp) {\n-                info2 = info;\n-            } else {\n-                info2 = new CONSTANT_MethodHandle_info(cp2, info.reference_kind, info.reference_index);\n-            }\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitMethodType(CONSTANT_MethodType_info info, Map<Object, Object> translations) {\n-        CONSTANT_MethodType_info info2 = (CONSTANT_MethodType_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp) {\n-                info2 = info;\n-            } else {\n-                info2 = new CONSTANT_MethodType_info(cp2, info.descriptor_index);\n-            }\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitModule(CONSTANT_Module_info info, Map<Object, Object> translations) {\n-        CONSTANT_Module_info info2 = (CONSTANT_Module_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp)\n-                info2 = info;\n-            else\n-                info2 = new CONSTANT_Module_info(cp2, info.name_index);\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitNameAndType(CONSTANT_NameAndType_info info, Map<Object, Object> translations) {\n-        CONSTANT_NameAndType_info info2 = (CONSTANT_NameAndType_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp)\n-                info2 = info;\n-            else\n-                info2 = new CONSTANT_NameAndType_info(cp2, info.name_index, info.type_index);\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitPackage(CONSTANT_Package_info info, Map<Object, Object> translations) {\n-        CONSTANT_Package_info info2 = (CONSTANT_Package_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp)\n-                info2 = info;\n-            else\n-                info2 = new CONSTANT_Package_info(cp2, info.name_index);\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitString(CONSTANT_String_info info, Map<Object, Object> translations) {\n-        CONSTANT_String_info info2 = (CONSTANT_String_info) translations.get(info);\n-        if (info2 == null) {\n-            ConstantPool cp2 = translate(info.cp, translations);\n-            if (cp2 == info.cp)\n-                info2 = info;\n-            else\n-                info2 = new CONSTANT_String_info(cp2, info.string_index);\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-    @Override\n-    public CPInfo visitUtf8(CONSTANT_Utf8_info info, Map<Object, Object> translations) {\n-        CONSTANT_Utf8_info info2 = (CONSTANT_Utf8_info) translations.get(info);\n-        if (info2 == null) {\n-            info2 = info;\n-            translations.put(info, info2);\n-        }\n-        return info;\n-    }\n-\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassTranslator.java","additions":0,"deletions":469,"binary":false,"changes":469,"status":"deleted"},{"patch":"@@ -1,1011 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataOutputStream;\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-\n-import static com.sun.tools.classfile.Annotation.*;\n-import static com.sun.tools.classfile.ConstantPool.*;\n-import static com.sun.tools.classfile.StackMapTable_attribute.*;\n-import static com.sun.tools.classfile.StackMapTable_attribute.verification_type_info.*;\n-\n-\/**\n- * Write a ClassFile data structure to a file or stream.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ClassWriter {\n-    public ClassWriter() {\n-        attributeWriter = new AttributeWriter();\n-        constantPoolWriter = new ConstantPoolWriter();\n-        out = new ClassOutputStream();\n-    }\n-\n-    \/**\n-     * Write a ClassFile data structure to a file.\n-     * @param classFile the classfile object to be written\n-     * @param f the file\n-     * @throws IOException if an error occurs while writing the file\n-     *\/\n-    public void write(ClassFile classFile, File f) throws IOException {\n-        try (FileOutputStream f_out = new FileOutputStream(f)) {\n-            write(classFile, f_out);\n-        }\n-    }\n-\n-    \/**\n-     * Write a ClassFile data structure to a stream.\n-     * @param classFile the classfile object to be written\n-     * @param s the stream\n-     * @throws IOException if an error occurs while writing the file\n-     *\/\n-    public void write(ClassFile classFile, OutputStream s) throws IOException {\n-        this.classFile = classFile;\n-        out.reset();\n-        write();\n-        out.writeTo(s);\n-    }\n-\n-    protected void write() throws IOException {\n-        writeHeader();\n-        writeConstantPool();\n-        writeAccessFlags(classFile.access_flags);\n-        writeClassInfo();\n-        writeFields();\n-        writeMethods();\n-        writeAttributes(classFile.attributes);\n-    }\n-\n-    protected void writeHeader() {\n-        out.writeInt(classFile.magic);\n-        out.writeShort(classFile.minor_version);\n-        out.writeShort(classFile.major_version);\n-    }\n-\n-    protected void writeAccessFlags(AccessFlags flags) {\n-        out.writeShort(flags.flags);\n-    }\n-\n-    protected void writeAttributes(Attributes attributes) {\n-        int size = attributes.size();\n-        out.writeShort(size);\n-        for (Attribute attr: attributes)\n-            attributeWriter.write(attr, out);\n-    }\n-\n-    protected void writeClassInfo() {\n-        out.writeShort(classFile.this_class);\n-        out.writeShort(classFile.super_class);\n-        int[] interfaces = classFile.interfaces;\n-        out.writeShort(interfaces.length);\n-        for (int i: interfaces)\n-            out.writeShort(i);\n-    }\n-\n-    protected void writeDescriptor(Descriptor d) {\n-        out.writeShort(d.index);\n-    }\n-\n-    protected void writeConstantPool() {\n-        ConstantPool pool = classFile.constant_pool;\n-        int size = pool.size();\n-        out.writeShort(size);\n-        for (CPInfo cpInfo: pool.entries())\n-            constantPoolWriter.write(cpInfo, out);\n-    }\n-\n-    protected void writeFields() throws IOException {\n-        Field[] fields = classFile.fields;\n-        out.writeShort(fields.length);\n-        for (Field f: fields)\n-            writeField(f);\n-    }\n-\n-    protected void writeField(Field f) throws IOException {\n-        writeAccessFlags(f.access_flags);\n-        out.writeShort(f.name_index);\n-        writeDescriptor(f.descriptor);\n-        writeAttributes(f.attributes);\n-    }\n-\n-    protected void writeMethods() throws IOException {\n-        Method[] methods = classFile.methods;\n-        out.writeShort(methods.length);\n-        for (Method m: methods) {\n-            writeMethod(m);\n-        }\n-    }\n-\n-    protected void writeMethod(Method m) throws IOException {\n-        writeAccessFlags(m.access_flags);\n-        out.writeShort(m.name_index);\n-        writeDescriptor(m.descriptor);\n-        writeAttributes(m.attributes);\n-    }\n-\n-    protected ClassFile classFile;\n-    protected ClassOutputStream out;\n-    protected AttributeWriter attributeWriter;\n-    protected ConstantPoolWriter constantPoolWriter;\n-\n-    \/**\n-     * Subtype of ByteArrayOutputStream with the convenience methods of\n-     * a DataOutputStream. Since ByteArrayOutputStream does not throw\n-     * IOException, there are no exceptions from the additional\n-     * convenience methods either,\n-     *\/\n-    protected static class ClassOutputStream extends ByteArrayOutputStream {\n-        public ClassOutputStream() {\n-            d = new DataOutputStream(this);\n-        }\n-\n-        public void writeByte(int value) {\n-            try {\n-                d.writeByte(value);\n-            } catch (IOException ignore) {\n-            }\n-        }\n-\n-        public void writeShort(int value) {\n-            try {\n-                d.writeShort(value);\n-            } catch (IOException ignore) {\n-            }\n-        }\n-\n-        public void writeInt(int value) {\n-            try {\n-                d.writeInt(value);\n-            } catch (IOException ignore) {\n-            }\n-        }\n-\n-        public void writeLong(long value) {\n-            try {\n-                d.writeLong(value);\n-            } catch (IOException ignore) {\n-            }\n-        }\n-\n-        public void writeFloat(float value) {\n-            try {\n-                d.writeFloat(value);\n-            } catch (IOException ignore) {\n-            }\n-        }\n-\n-        public void writeDouble(double value) {\n-            try {\n-                d.writeDouble(value);\n-            } catch (IOException ignore) {\n-            }\n-        }\n-\n-        public void writeUTF(String value) {\n-            try {\n-                d.writeUTF(value);\n-            } catch (IOException ignore) {\n-            }\n-        }\n-\n-        public void writeTo(ClassOutputStream s) {\n-            try {\n-                super.writeTo(s);\n-            } catch (IOException ignore) {\n-            }\n-        }\n-\n-        private final DataOutputStream d;\n-    }\n-\n-    \/**\n-     * Writer for the entries in the constant pool.\n-     *\/\n-    protected static class ConstantPoolWriter\n-           implements ConstantPool.Visitor<Integer,ClassOutputStream> {\n-        protected int write(CPInfo info, ClassOutputStream out) {\n-            out.writeByte(info.getTag());\n-            return info.accept(this, out);\n-        }\n-\n-        @Override\n-        public Integer visitClass(CONSTANT_Class_info info, ClassOutputStream out) {\n-            out.writeShort(info.name_index);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitDouble(CONSTANT_Double_info info, ClassOutputStream out) {\n-            out.writeDouble(info.value);\n-            return 2;\n-        }\n-\n-        @Override\n-        public Integer visitFieldref(CONSTANT_Fieldref_info info, ClassOutputStream out) {\n-            writeRef(info, out);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitFloat(CONSTANT_Float_info info, ClassOutputStream out) {\n-            out.writeFloat(info.value);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitInteger(CONSTANT_Integer_info info, ClassOutputStream out) {\n-            out.writeInt(info.value);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info info, ClassOutputStream out) {\n-            writeRef(info, out);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitInvokeDynamic(CONSTANT_InvokeDynamic_info info, ClassOutputStream out) {\n-            out.writeShort(info.bootstrap_method_attr_index);\n-            out.writeShort(info.name_and_type_index);\n-            return 1;\n-        }\n-\n-        public Integer visitDynamicConstant(CONSTANT_Dynamic_info info, ClassOutputStream out) {\n-            out.writeShort(info.bootstrap_method_attr_index);\n-            out.writeShort(info.name_and_type_index);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitLong(CONSTANT_Long_info info, ClassOutputStream out) {\n-            out.writeLong(info.value);\n-            return 2;\n-        }\n-\n-        @Override\n-        public Integer visitMethodHandle(CONSTANT_MethodHandle_info info, ClassOutputStream out) {\n-            out.writeByte(info.reference_kind.tag);\n-            out.writeShort(info.reference_index);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitMethodType(CONSTANT_MethodType_info info, ClassOutputStream out) {\n-            out.writeShort(info.descriptor_index);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitMethodref(CONSTANT_Methodref_info info, ClassOutputStream out) {\n-            return writeRef(info, out);\n-        }\n-\n-        @Override\n-        public Integer visitModule(CONSTANT_Module_info info, ClassOutputStream out) {\n-            out.writeShort(info.name_index);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitNameAndType(CONSTANT_NameAndType_info info, ClassOutputStream out) {\n-            out.writeShort(info.name_index);\n-            out.writeShort(info.type_index);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitPackage(CONSTANT_Package_info info, ClassOutputStream out) {\n-            out.writeShort(info.name_index);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitString(CONSTANT_String_info info, ClassOutputStream out) {\n-            out.writeShort(info.string_index);\n-            return 1;\n-        }\n-\n-        @Override\n-        public Integer visitUtf8(CONSTANT_Utf8_info info, ClassOutputStream out) {\n-            out.writeUTF(info.value);\n-            return 1;\n-        }\n-\n-        protected Integer writeRef(CPRefInfo info, ClassOutputStream out) {\n-            out.writeShort(info.class_index);\n-            out.writeShort(info.name_and_type_index);\n-            return 1;\n-        }\n-    }\n-\n-    \/**\n-     * Writer for the different types of attribute.\n-     *\/\n-    protected static class AttributeWriter implements Attribute.Visitor<Void,ClassOutputStream> {\n-        public void write(Attributes attributes, ClassOutputStream out) {\n-            int size = attributes.size();\n-            out.writeShort(size);\n-            for (Attribute a: attributes)\n-                write(a, out);\n-        }\n-\n-        public void write(Attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.attribute_name_index);\n-            ClassOutputStream nestedOut = new ClassOutputStream();\n-            attr.accept(this, nestedOut);\n-            out.writeInt(nestedOut.size());\n-            nestedOut.writeTo(out);\n-        }\n-\n-        protected AnnotationWriter annotationWriter = new AnnotationWriter();\n-\n-        @Override\n-        public Void visitDefault(DefaultAttribute attr, ClassOutputStream out) {\n-            out.write(attr.info, 0, attr.info.length);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitAnnotationDefault(AnnotationDefault_attribute attr, ClassOutputStream out) {\n-            annotationWriter.write(attr.default_value, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitBootstrapMethods(BootstrapMethods_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.bootstrap_method_specifiers.length);\n-            for (BootstrapMethods_attribute.BootstrapMethodSpecifier bsm : attr.bootstrap_method_specifiers) {\n-                out.writeShort(bsm.bootstrap_method_ref);\n-                int bsm_args_count = bsm.bootstrap_arguments.length;\n-                out.writeShort(bsm_args_count);\n-                for (int i : bsm.bootstrap_arguments) {\n-                    out.writeShort(i);\n-                }\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitCharacterRangeTable(CharacterRangeTable_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.character_range_table.length);\n-            for (CharacterRangeTable_attribute.Entry e: attr.character_range_table)\n-                writeCharacterRangeTableEntry(e, out);\n-            return null;\n-        }\n-\n-        protected void writeCharacterRangeTableEntry(CharacterRangeTable_attribute.Entry entry, ClassOutputStream out) {\n-            out.writeShort(entry.start_pc);\n-            out.writeShort(entry.end_pc);\n-            out.writeInt(entry.character_range_start);\n-            out.writeInt(entry.character_range_end);\n-            out.writeShort(entry.flags);\n-        }\n-\n-        @Override\n-        public Void visitCode(Code_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.max_stack);\n-            out.writeShort(attr.max_locals);\n-            out.writeInt(attr.code.length);\n-            out.write(attr.code, 0, attr.code.length);\n-            out.writeShort(attr.exception_table.length);\n-            for (Code_attribute.Exception_data e: attr.exception_table)\n-                writeExceptionTableEntry(e, out);\n-            new AttributeWriter().write(attr.attributes, out);\n-            return null;\n-        }\n-\n-        protected void writeExceptionTableEntry(Code_attribute.Exception_data exception_data, ClassOutputStream out) {\n-            out.writeShort(exception_data.start_pc);\n-            out.writeShort(exception_data.end_pc);\n-            out.writeShort(exception_data.handler_pc);\n-            out.writeShort(exception_data.catch_type);\n-        }\n-\n-        @Override\n-        public Void visitCompilationID(CompilationID_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.compilationID_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitConstantValue(ConstantValue_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.constantvalue_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitDeprecated(Deprecated_attribute attr, ClassOutputStream out) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitEnclosingMethod(EnclosingMethod_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.class_index);\n-            out.writeShort(attr.method_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitExceptions(Exceptions_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.exception_index_table.length);\n-            for (int i: attr.exception_index_table)\n-                out.writeShort(i);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitInnerClasses(InnerClasses_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.classes.length);\n-            for (InnerClasses_attribute.Info info: attr.classes)\n-                writeInnerClassesInfo(info, out);\n-            return null;\n-        }\n-\n-        protected void writeInnerClassesInfo(InnerClasses_attribute.Info info, ClassOutputStream out) {\n-            out.writeShort(info.inner_class_info_index);\n-            out.writeShort(info.outer_class_info_index);\n-            out.writeShort(info.inner_name_index);\n-            writeAccessFlags(info.inner_class_access_flags, out);\n-        }\n-\n-        @Override\n-        public Void visitLineNumberTable(LineNumberTable_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.line_number_table.length);\n-            for (LineNumberTable_attribute.Entry e: attr.line_number_table)\n-                writeLineNumberTableEntry(e, out);\n-            return null;\n-        }\n-\n-        protected void writeLineNumberTableEntry(LineNumberTable_attribute.Entry entry, ClassOutputStream out) {\n-            out.writeShort(entry.start_pc);\n-            out.writeShort(entry.line_number);\n-        }\n-\n-        @Override\n-        public Void visitLocalVariableTable(LocalVariableTable_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.local_variable_table.length);\n-            for (LocalVariableTable_attribute.Entry e: attr.local_variable_table)\n-                writeLocalVariableTableEntry(e, out);\n-            return null;\n-        }\n-\n-        protected void writeLocalVariableTableEntry(LocalVariableTable_attribute.Entry entry, ClassOutputStream out) {\n-            out.writeShort(entry.start_pc);\n-            out.writeShort(entry.length);\n-            out.writeShort(entry.name_index);\n-            out.writeShort(entry.descriptor_index);\n-            out.writeShort(entry.index);\n-        }\n-\n-        @Override\n-        public Void visitLocalVariableTypeTable(LocalVariableTypeTable_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.local_variable_table.length);\n-            for (LocalVariableTypeTable_attribute.Entry e: attr.local_variable_table)\n-                writeLocalVariableTypeTableEntry(e, out);\n-            return null;\n-        }\n-\n-        protected void writeLocalVariableTypeTableEntry(LocalVariableTypeTable_attribute.Entry entry, ClassOutputStream out) {\n-            out.writeShort(entry.start_pc);\n-            out.writeShort(entry.length);\n-            out.writeShort(entry.name_index);\n-            out.writeShort(entry.signature_index);\n-            out.writeShort(entry.index);\n-        }\n-\n-        @Override\n-        public Void visitNestHost(NestHost_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.top_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitMethodParameters(MethodParameters_attribute attr, ClassOutputStream out) {\n-            out.writeByte(attr.method_parameter_table.length);\n-            for (MethodParameters_attribute.Entry e : attr.method_parameter_table) {\n-                out.writeShort(e.name_index);\n-                out.writeShort(e.flags);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitModule(Module_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.module_name);\n-            out.writeShort(attr.module_flags);\n-            out.writeShort(attr.module_version_index);\n-\n-            out.writeShort(attr.requires.length);\n-            for (Module_attribute.RequiresEntry e: attr.requires) {\n-                out.writeShort(e.requires_index);\n-                out.writeShort(e.requires_flags);\n-                out.writeShort(e.requires_version_index);\n-            }\n-\n-            out.writeShort(attr.exports.length);\n-            for (Module_attribute.ExportsEntry e: attr.exports) {\n-                out.writeShort(e.exports_index);\n-                out.writeShort(e.exports_flags);\n-                out.writeShort(e.exports_to_index.length);\n-                for (int index: e.exports_to_index)\n-                    out.writeShort(index);\n-            }\n-\n-            out.writeShort(attr.opens.length);\n-            for (Module_attribute.OpensEntry e: attr.opens) {\n-                out.writeShort(e.opens_index);\n-                out.writeShort(e.opens_flags);\n-                out.writeShort(e.opens_to_index.length);\n-                for (int index: e.opens_to_index)\n-                    out.writeShort(index);\n-            }\n-\n-            out.writeShort(attr.uses_index.length);\n-            for (int index: attr.uses_index) {\n-                out.writeShort(index);\n-            }\n-\n-            out.writeShort(attr.provides.length);\n-            for (Module_attribute.ProvidesEntry e: attr.provides) {\n-                out.writeShort(e.provides_index);\n-                out.writeShort(e.with_count);\n-                for (int with : e.with_index) {\n-                    out.writeShort(with);\n-                }\n-            }\n-\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitModuleHashes(ModuleHashes_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.algorithm_index);\n-            out.writeShort(attr.hashes_table.length);\n-            for (ModuleHashes_attribute.Entry e: attr.hashes_table) {\n-                out.writeShort(e.module_name_index);\n-                out.writeShort(e.hash.length);\n-                for (byte b: e.hash) {\n-                    out.writeByte(b);\n-                }\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitModuleMainClass(ModuleMainClass_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.main_class_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitModulePackages(ModulePackages_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.packages_count);\n-            for (int i: attr.packages_index)\n-                out.writeShort(i);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitModuleResolution(ModuleResolution_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.resolution_flags);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitModuleTarget(ModuleTarget_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.target_platform_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitNestMembers(NestMembers_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.members_indexes.length);\n-            for (int i : attr.members_indexes) {\n-                out.writeShort(i);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitRecord(Record_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.component_count);\n-            for (Record_attribute.ComponentInfo info: attr.component_info_arr) {\n-                out.writeShort(info.name_index);\n-                out.writeShort(info.descriptor.index);\n-                int size = info.attributes.size();\n-                out.writeShort(size);\n-                for (Attribute componentAttr: info.attributes)\n-                    write(componentAttr, out);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitRuntimeInvisibleAnnotations(RuntimeInvisibleAnnotations_attribute attr, ClassOutputStream out) {\n-            annotationWriter.write(attr.annotations, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitRuntimeInvisibleParameterAnnotations(RuntimeInvisibleParameterAnnotations_attribute attr, ClassOutputStream out) {\n-            out.writeByte(attr.parameter_annotations.length);\n-            for (Annotation[] annos: attr.parameter_annotations)\n-                annotationWriter.write(annos, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitRuntimeInvisibleTypeAnnotations(RuntimeInvisibleTypeAnnotations_attribute attr, ClassOutputStream out) {\n-            annotationWriter.write(attr.annotations, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitRuntimeVisibleAnnotations(RuntimeVisibleAnnotations_attribute attr, ClassOutputStream out) {\n-            annotationWriter.write(attr.annotations, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitRuntimeVisibleParameterAnnotations(RuntimeVisibleParameterAnnotations_attribute attr, ClassOutputStream out) {\n-            out.writeByte(attr.parameter_annotations.length);\n-            for (Annotation[] annos: attr.parameter_annotations)\n-                annotationWriter.write(annos, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitRuntimeVisibleTypeAnnotations(RuntimeVisibleTypeAnnotations_attribute attr, ClassOutputStream out) {\n-            annotationWriter.write(attr.annotations, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitPermittedSubclasses(PermittedSubclasses_attribute attr, ClassOutputStream out) {\n-            int n = attr.subtypes.length;\n-            out.writeShort(n);\n-            for (int i = 0 ; i < n ; i++) {\n-                out.writeShort(attr.subtypes[i]);\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitSignature(Signature_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.signature_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitSourceDebugExtension(SourceDebugExtension_attribute attr, ClassOutputStream out) {\n-            out.write(attr.debug_extension, 0, attr.debug_extension.length);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitSourceFile(SourceFile_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.sourcefile_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitSourceID(SourceID_attribute attr, ClassOutputStream out) {\n-            out.writeShort(attr.sourceID_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitStackMap(StackMap_attribute attr, ClassOutputStream out) {\n-            if (stackMapWriter == null)\n-                stackMapWriter = new StackMapTableWriter();\n-\n-            out.writeShort(attr.entries.length);\n-            for (stack_map_frame f: attr.entries)\n-                stackMapWriter.write(f, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitStackMapTable(StackMapTable_attribute attr, ClassOutputStream out) {\n-            if (stackMapWriter == null)\n-                stackMapWriter = new StackMapTableWriter();\n-\n-            out.writeShort(attr.entries.length);\n-            for (stack_map_frame f: attr.entries)\n-                stackMapWriter.write(f, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitSynthetic(Synthetic_attribute attr, ClassOutputStream out) {\n-            return null;\n-        }\n-\n-        protected void writeAccessFlags(AccessFlags flags, ClassOutputStream out) {\n-            out.writeShort(flags.flags);\n-        }\n-\n-        protected StackMapTableWriter stackMapWriter;\n-    }\n-\n-    \/**\n-     * Writer for the frames of StackMap and StackMapTable attributes.\n-     *\/\n-    protected static class StackMapTableWriter\n-            implements stack_map_frame.Visitor<Void,ClassOutputStream> {\n-\n-        public void write(stack_map_frame frame, ClassOutputStream out) {\n-            out.write(frame.frame_type);\n-            frame.accept(this, out);\n-        }\n-\n-        @Override\n-        public Void visit_same_frame(same_frame frame, ClassOutputStream p) {\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_same_locals_1_stack_item_frame(same_locals_1_stack_item_frame frame, ClassOutputStream out) {\n-            writeVerificationTypeInfo(frame.stack[0], out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_same_locals_1_stack_item_frame_extended(same_locals_1_stack_item_frame_extended frame, ClassOutputStream out) {\n-            out.writeShort(frame.offset_delta);\n-            writeVerificationTypeInfo(frame.stack[0], out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_chop_frame(chop_frame frame, ClassOutputStream out) {\n-            out.writeShort(frame.offset_delta);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_same_frame_extended(same_frame_extended frame, ClassOutputStream out) {\n-            out.writeShort(frame.offset_delta);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_append_frame(append_frame frame, ClassOutputStream out) {\n-            out.writeShort(frame.offset_delta);\n-            for (verification_type_info l: frame.locals)\n-                writeVerificationTypeInfo(l, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_full_frame(full_frame frame, ClassOutputStream out) {\n-            out.writeShort(frame.offset_delta);\n-            out.writeShort(frame.locals.length);\n-            for (verification_type_info l: frame.locals)\n-                writeVerificationTypeInfo(l, out);\n-            out.writeShort(frame.stack.length);\n-            for (verification_type_info s: frame.stack)\n-                writeVerificationTypeInfo(s, out);\n-            return null;\n-        }\n-\n-        protected void writeVerificationTypeInfo(verification_type_info info,\n-                ClassOutputStream out)  {\n-            out.write(info.tag);\n-            switch (info.tag) {\n-            case ITEM_Top:\n-            case ITEM_Integer:\n-            case ITEM_Float:\n-            case ITEM_Long:\n-            case ITEM_Double:\n-            case ITEM_Null:\n-            case ITEM_UninitializedThis:\n-                break;\n-\n-            case ITEM_Object:\n-                Object_variable_info o = (Object_variable_info) info;\n-                out.writeShort(o.cpool_index);\n-                break;\n-\n-            case ITEM_Uninitialized:\n-                Uninitialized_variable_info u = (Uninitialized_variable_info) info;\n-                out.writeShort(u.offset);\n-                break;\n-\n-            default:\n-                throw new Error();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Writer for annotations and the values they contain.\n-     *\/\n-    protected static class AnnotationWriter\n-            implements Annotation.element_value.Visitor<Void,ClassOutputStream> {\n-        public void write(Annotation[] annos, ClassOutputStream out) {\n-            out.writeShort(annos.length);\n-            for (Annotation anno: annos)\n-                write(anno, out);\n-        }\n-\n-        public void write(TypeAnnotation[] annos, ClassOutputStream out) {\n-            out.writeShort(annos.length);\n-            for (TypeAnnotation anno: annos)\n-                write(anno, out);\n-        }\n-\n-        public void write(Annotation anno, ClassOutputStream out) {\n-            out.writeShort(anno.type_index);\n-            out.writeShort(anno.element_value_pairs.length);\n-            for (element_value_pair p: anno.element_value_pairs)\n-                write(p, out);\n-        }\n-\n-        public void write(TypeAnnotation anno, ClassOutputStream out) {\n-            write(anno.position, out);\n-            write(anno.annotation, out);\n-        }\n-\n-        public void write(element_value_pair pair, ClassOutputStream out) {\n-            out.writeShort(pair.element_name_index);\n-            write(pair.value, out);\n-        }\n-\n-        public void write(element_value ev, ClassOutputStream out) {\n-            out.writeByte(ev.tag);\n-            ev.accept(this, out);\n-        }\n-\n-        @Override\n-        public Void visitPrimitive(Primitive_element_value ev, ClassOutputStream out) {\n-            out.writeShort(ev.const_value_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitEnum(Enum_element_value ev, ClassOutputStream out) {\n-            out.writeShort(ev.type_name_index);\n-            out.writeShort(ev.const_name_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitClass(Class_element_value ev, ClassOutputStream out) {\n-            out.writeShort(ev.class_info_index);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitAnnotation(Annotation_element_value ev, ClassOutputStream out) {\n-            write(ev.annotation_value, out);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitArray(Array_element_value ev, ClassOutputStream out) {\n-            out.writeShort(ev.num_values);\n-            for (element_value v: ev.values)\n-                write(v, out);\n-            return null;\n-        }\n-\n-        \/\/ TODO: Move this to TypeAnnotation to be closer with similar logic?\n-        private void write(TypeAnnotation.Position p, ClassOutputStream out) {\n-            out.writeByte(p.type.targetTypeValue());\n-            switch (p.type) {\n-            \/\/ instanceof\n-            case INSTANCEOF:\n-            \/\/ new expression\n-            case NEW:\n-            \/\/ constructor\/method reference receiver\n-            case CONSTRUCTOR_REFERENCE:\n-            case METHOD_REFERENCE:\n-                out.writeShort(p.offset);\n-                break;\n-            \/\/ local variable\n-            case LOCAL_VARIABLE:\n-            \/\/ resource variable\n-            case RESOURCE_VARIABLE:\n-                int table_length = p.lvarOffset.length;\n-                out.writeShort(table_length);\n-                for (int i = 0; i < table_length; ++i) {\n-                    out.writeShort(1);  \/\/ for table length\n-                    out.writeShort(p.lvarOffset[i]);\n-                    out.writeShort(p.lvarLength[i]);\n-                    out.writeShort(p.lvarIndex[i]);\n-                }\n-                break;\n-            \/\/ exception parameter\n-            case EXCEPTION_PARAMETER:\n-                out.writeShort(p.exception_index);\n-                break;\n-            \/\/ method receiver\n-            case METHOD_RECEIVER:\n-                \/\/ Do nothing\n-                break;\n-            \/\/ type parameters\n-            case CLASS_TYPE_PARAMETER:\n-            case METHOD_TYPE_PARAMETER:\n-                out.writeByte(p.parameter_index);\n-                break;\n-            \/\/ type parameters bounds\n-            case CLASS_TYPE_PARAMETER_BOUND:\n-            case METHOD_TYPE_PARAMETER_BOUND:\n-                out.writeByte(p.parameter_index);\n-                out.writeByte(p.bound_index);\n-                break;\n-            \/\/ class extends or implements clause\n-            case CLASS_EXTENDS:\n-                out.writeShort(p.type_index);\n-                break;\n-            \/\/ throws\n-            case THROWS:\n-                out.writeShort(p.type_index);\n-                break;\n-            \/\/ method parameter\n-            case METHOD_FORMAL_PARAMETER:\n-                out.writeByte(p.parameter_index);\n-                break;\n-            \/\/ type cast\n-            case CAST:\n-            \/\/ method\/constructor\/reference type argument\n-            case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n-            case METHOD_INVOCATION_TYPE_ARGUMENT:\n-            case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n-            case METHOD_REFERENCE_TYPE_ARGUMENT:\n-                out.writeShort(p.offset);\n-                out.writeByte(p.type_index);\n-                break;\n-            \/\/ We don't need to worry about these\n-            case METHOD_RETURN:\n-            case FIELD:\n-                break;\n-            case UNKNOWN:\n-                throw new AssertionError(\"ClassWriter: UNKNOWN target type should never occur!\");\n-            default:\n-                throw new AssertionError(\"ClassWriter: Unknown target type for position: \" + p);\n-            }\n-\n-            { \/\/ Append location data for generics\/arrays.\n-                \/\/ TODO: check for overrun?\n-                out.writeByte((byte)p.location.size());\n-                for (int i : TypeAnnotation.Position.getBinaryFromTypePath(p.location))\n-                    out.writeByte((byte)i);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ClassWriter.java","additions":0,"deletions":1011,"binary":false,"changes":1011,"status":"deleted"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-import java.util.Iterator;\n-import java.util.NoSuchElementException;\n-\n-\/**\n- * See JVMS, section 4.8.3.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Code_attribute extends Attribute {\n-    public static class InvalidIndex extends AttributeException {\n-        private static final long serialVersionUID = -8904527774589382802L;\n-        InvalidIndex(int index) {\n-            this.index = index;\n-        }\n-\n-        @Override\n-        public String getMessage() {\n-            \/\/ i18n\n-            return \"invalid index \" + index + \" in Code attribute\";\n-        }\n-\n-        public final int index;\n-    }\n-\n-    Code_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, ConstantPoolException {\n-        super(name_index, length);\n-        max_stack = cr.readUnsignedShort();\n-        max_locals = cr.readUnsignedShort();\n-        code_length = cr.readInt();\n-        code = new byte[code_length];\n-        cr.readFully(code);\n-        exception_table_length = cr.readUnsignedShort();\n-        exception_table = new Exception_data[exception_table_length];\n-        for (int i = 0; i < exception_table_length; i++)\n-            exception_table[i] = new Exception_data(cr);\n-        attributes = new Attributes(cr);\n-    }\n-\n-    public int getByte(int offset) throws InvalidIndex {\n-        if (offset < 0 || offset >= code.length)\n-            throw new InvalidIndex(offset);\n-        return code[offset];\n-    }\n-\n-    public int getUnsignedByte(int offset) throws InvalidIndex {\n-        if (offset < 0 || offset >= code.length)\n-            throw new InvalidIndex(offset);\n-        return code[offset] & 0xff;\n-    }\n-\n-    public int getShort(int offset) throws InvalidIndex {\n-        if (offset < 0 || offset + 1 >= code.length)\n-            throw new InvalidIndex(offset);\n-        return (code[offset] << 8) | (code[offset + 1] & 0xFF);\n-    }\n-\n-    public int getUnsignedShort(int offset) throws InvalidIndex {\n-        if (offset < 0 || offset + 1 >= code.length)\n-            throw new InvalidIndex(offset);\n-        return ((code[offset] << 8) | (code[offset + 1] & 0xFF)) & 0xFFFF;\n-    }\n-\n-    public int getInt(int offset) throws InvalidIndex {\n-        if (offset < 0 || offset + 3 >= code.length)\n-            throw new InvalidIndex(offset);\n-        return (getShort(offset) << 16) | (getShort(offset + 2) & 0xFFFF);\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitCode(this, data);\n-    }\n-\n-    public Iterable<Instruction> getInstructions() {\n-        return () -> new Iterator<Instruction>() {\n-\n-            public boolean hasNext() {\n-                return (next != null);\n-            }\n-\n-            public Instruction next() {\n-                if (next == null)\n-                    throw new NoSuchElementException();\n-\n-                current = next;\n-                pc += current.length();\n-                next = (pc < code.length ? new Instruction(code, pc) : null);\n-                return current;\n-            }\n-\n-            public void remove() {\n-                throw new UnsupportedOperationException(\"Not supported.\");\n-            }\n-\n-            Instruction current = null;\n-            int pc = 0;\n-            Instruction next = (pc < code.length ? new Instruction(code, pc) : null);\n-\n-        };\n-    }\n-\n-    public final int max_stack;\n-    public final int max_locals;\n-    public final int code_length;\n-    public final byte[] code;\n-    public final int exception_table_length;\n-    public final Exception_data[] exception_table;\n-    public final Attributes attributes;\n-\n-    public static class Exception_data {\n-        Exception_data(ClassReader cr) throws IOException {\n-            start_pc = cr.readUnsignedShort();\n-            end_pc = cr.readUnsignedShort();\n-            handler_pc = cr.readUnsignedShort();\n-            catch_type = cr.readUnsignedShort();\n-        }\n-\n-        public final int start_pc;\n-        public final int end_pc;\n-        public final int handler_pc;\n-        public final int catch_type;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Code_attribute.java","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class CompilationID_attribute extends Attribute {\n-\n-    CompilationID_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        compilationID_index = cr.readUnsignedShort();\n-    }\n-\n-    public CompilationID_attribute(ConstantPool constant_pool, int compilationID_index)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.CompilationID), compilationID_index);\n-    }\n-\n-    public CompilationID_attribute(int name_index, int compilationID_index) {\n-        super(name_index, 2);\n-        this.compilationID_index = compilationID_index;\n-    }\n-\n-    String getCompilationID(ConstantPool constant_pool)\n-            throws ConstantPoolException {\n-        return constant_pool.getUTF8Value(compilationID_index);\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitCompilationID(this, data);\n-    }\n-\n-    public final int compilationID_index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/CompilationID_attribute.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,1053 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.util.Iterator;\n-\n-\/**\n- * See JVMS, section 4.5.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ConstantPool {\n-\n-    public static class InvalidIndex extends ConstantPoolException {\n-        private static final long serialVersionUID = -4350294289300939730L;\n-        InvalidIndex(int index) {\n-            super(index);\n-        }\n-\n-        @Override\n-        public String getMessage() {\n-            \/\/ i18n\n-            return \"invalid index #\" + index;\n-        }\n-    }\n-\n-    public static class UnexpectedEntry extends ConstantPoolException {\n-        private static final long serialVersionUID = 6986335935377933211L;\n-        UnexpectedEntry(int index, int expected_tag, int found_tag) {\n-            super(index);\n-            this.expected_tag = expected_tag;\n-            this.found_tag = found_tag;\n-        }\n-\n-        @Override\n-        public String getMessage() {\n-            \/\/ i18n?\n-            return \"unexpected entry at #\" + index + \" -- expected tag \" + expected_tag + \", found \" + found_tag;\n-        }\n-\n-        public final int expected_tag;\n-        public final int found_tag;\n-    }\n-\n-    public static class InvalidEntry extends ConstantPoolException {\n-        private static final long serialVersionUID = 1000087545585204447L;\n-        InvalidEntry(int index, int tag) {\n-            super(index);\n-            this.tag = tag;\n-        }\n-\n-        @Override\n-        public String getMessage() {\n-            \/\/ i18n?\n-            return \"unexpected tag at #\" + index + \": \" + tag;\n-        }\n-\n-        public final int tag;\n-    }\n-\n-    public static class EntryNotFound extends ConstantPoolException {\n-        private static final long serialVersionUID = 2885537606468581850L;\n-        EntryNotFound(Object value) {\n-            super(-1);\n-            this.value = value;\n-        }\n-\n-        @Override\n-        public String getMessage() {\n-            \/\/ i18n?\n-            return \"value not found: \" + value;\n-        }\n-\n-        @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n-        public final Object value;\n-    }\n-\n-    public static final int CONSTANT_Utf8 = 1;\n-    public static final int CONSTANT_Integer = 3;\n-    public static final int CONSTANT_Float = 4;\n-    public static final int CONSTANT_Long = 5;\n-    public static final int CONSTANT_Double = 6;\n-    public static final int CONSTANT_Class = 7;\n-    public static final int CONSTANT_String = 8;\n-    public static final int CONSTANT_Fieldref = 9;\n-    public static final int CONSTANT_Methodref = 10;\n-    public static final int CONSTANT_InterfaceMethodref = 11;\n-    public static final int CONSTANT_NameAndType = 12;\n-    public static final int CONSTANT_MethodHandle = 15;\n-    public static final int CONSTANT_MethodType = 16;\n-    public static final int CONSTANT_Dynamic = 17;\n-    public static final int CONSTANT_InvokeDynamic = 18;\n-    public static final int CONSTANT_Module = 19;\n-    public static final int CONSTANT_Package = 20;\n-\n-    public static enum RefKind {\n-        REF_getField(1),\n-        REF_getStatic(2),\n-        REF_putField(3),\n-        REF_putStatic(4),\n-        REF_invokeVirtual(5),\n-        REF_invokeStatic(6),\n-        REF_invokeSpecial(7),\n-        REF_newInvokeSpecial(8),\n-        REF_invokeInterface(9);\n-\n-        public final int tag;\n-\n-        RefKind(int tag) {\n-            this.tag = tag;\n-        }\n-\n-        static RefKind getRefkind(int tag) {\n-            switch(tag) {\n-                case 1:\n-                    return REF_getField;\n-                case 2:\n-                    return REF_getStatic;\n-                case 3:\n-                    return REF_putField;\n-                case 4:\n-                    return REF_putStatic;\n-                case 5:\n-                    return REF_invokeVirtual;\n-                case 6:\n-                    return REF_invokeStatic;\n-                case 7:\n-                    return REF_invokeSpecial;\n-                case 8:\n-                    return REF_newInvokeSpecial;\n-                case 9:\n-                    return REF_invokeInterface;\n-                default:\n-                    return null;\n-            }\n-        }\n-    }\n-\n-    ConstantPool(ClassReader cr) throws IOException, InvalidEntry {\n-        int count = cr.readUnsignedShort();\n-        pool = new CPInfo[count];\n-        for (int i = 1; i < count; i++) {\n-            int tag = cr.readUnsignedByte();\n-            switch (tag) {\n-            case CONSTANT_Class:\n-                pool[i] = new CONSTANT_Class_info(this, cr);\n-                break;\n-\n-            case CONSTANT_Double:\n-                pool[i] = new CONSTANT_Double_info(cr);\n-                i++;\n-                break;\n-\n-            case CONSTANT_Fieldref:\n-                pool[i] = new CONSTANT_Fieldref_info(this, cr);\n-                break;\n-\n-            case CONSTANT_Float:\n-                pool[i] = new CONSTANT_Float_info(cr);\n-                break;\n-\n-            case CONSTANT_Integer:\n-                pool[i] = new CONSTANT_Integer_info(cr);\n-                break;\n-\n-            case CONSTANT_InterfaceMethodref:\n-                pool[i] = new CONSTANT_InterfaceMethodref_info(this, cr);\n-                break;\n-\n-            case CONSTANT_InvokeDynamic:\n-                pool[i] = new CONSTANT_InvokeDynamic_info(this, cr);\n-                break;\n-\n-            case CONSTANT_Dynamic:\n-                pool[i] = new CONSTANT_Dynamic_info(this, cr);\n-                break;\n-\n-            case CONSTANT_Long:\n-                pool[i] = new CONSTANT_Long_info(cr);\n-                i++;\n-                break;\n-\n-            case CONSTANT_MethodHandle:\n-                pool[i] = new CONSTANT_MethodHandle_info(this, cr);\n-                break;\n-\n-            case CONSTANT_MethodType:\n-                pool[i] = new CONSTANT_MethodType_info(this, cr);\n-                break;\n-\n-            case CONSTANT_Methodref:\n-                pool[i] = new CONSTANT_Methodref_info(this, cr);\n-                break;\n-\n-            case CONSTANT_Module:\n-                pool[i] = new CONSTANT_Module_info(this, cr);\n-                break;\n-\n-            case CONSTANT_NameAndType:\n-                pool[i] = new CONSTANT_NameAndType_info(this, cr);\n-                break;\n-\n-            case CONSTANT_Package:\n-                pool[i] = new CONSTANT_Package_info(this, cr);\n-                break;\n-\n-            case CONSTANT_String:\n-                pool[i] = new CONSTANT_String_info(this, cr);\n-                break;\n-\n-            case CONSTANT_Utf8:\n-                pool[i] = new CONSTANT_Utf8_info(cr);\n-                break;\n-\n-            default:\n-                throw new InvalidEntry(i, tag);\n-            }\n-        }\n-    }\n-\n-    public ConstantPool(CPInfo[] pool) {\n-        this.pool = pool;\n-    }\n-\n-    public int size() {\n-        return pool.length;\n-    }\n-\n-    public int byteLength() {\n-        int length = 2;\n-        for (int i = 1; i < size(); ) {\n-            CPInfo cpInfo = pool[i];\n-            length += cpInfo.byteLength();\n-            i += cpInfo.size();\n-        }\n-        return length;\n-    }\n-\n-    public CPInfo get(int index) throws InvalidIndex {\n-        if (index <= 0 || index >= pool.length)\n-            throw new InvalidIndex(index);\n-        CPInfo info = pool[index];\n-        if (info == null) {\n-            \/\/ this occurs for indices referencing the \"second half\" of an\n-            \/\/ 8 byte constant, such as CONSTANT_Double or CONSTANT_Long\n-            throw new InvalidIndex(index);\n-        }\n-        return pool[index];\n-    }\n-\n-    private CPInfo get(int index, int expected_type) throws InvalidIndex, UnexpectedEntry {\n-        CPInfo info = get(index);\n-        if (info.getTag() != expected_type)\n-            throw new UnexpectedEntry(index, expected_type, info.getTag());\n-        return info;\n-    }\n-\n-    public CONSTANT_Utf8_info getUTF8Info(int index) throws InvalidIndex, UnexpectedEntry {\n-        return ((CONSTANT_Utf8_info) get(index, CONSTANT_Utf8));\n-    }\n-\n-    public CONSTANT_Class_info getClassInfo(int index) throws InvalidIndex, UnexpectedEntry {\n-        return ((CONSTANT_Class_info) get(index, CONSTANT_Class));\n-    }\n-\n-    public CONSTANT_Module_info getModuleInfo(int index) throws InvalidIndex, UnexpectedEntry {\n-        return ((CONSTANT_Module_info) get(index, CONSTANT_Module));\n-    }\n-\n-    public CONSTANT_NameAndType_info getNameAndTypeInfo(int index) throws InvalidIndex, UnexpectedEntry {\n-        return ((CONSTANT_NameAndType_info) get(index, CONSTANT_NameAndType));\n-    }\n-\n-    public CONSTANT_Package_info getPackageInfo(int index) throws InvalidIndex, UnexpectedEntry {\n-        return ((CONSTANT_Package_info) get(index, CONSTANT_Package));\n-    }\n-\n-    public String getUTF8Value(int index) throws InvalidIndex, UnexpectedEntry {\n-        return getUTF8Info(index).value;\n-    }\n-\n-    public int getUTF8Index(String value) throws EntryNotFound {\n-        for (int i = 1; i < pool.length; i++) {\n-            CPInfo info = pool[i];\n-            if (info instanceof CONSTANT_Utf8_info &&\n-                    ((CONSTANT_Utf8_info) info).value.equals(value))\n-                return i;\n-        }\n-        throw new EntryNotFound(value);\n-    }\n-\n-    public Iterable<CPInfo> entries() {\n-        return () -> new Iterator<CPInfo>() {\n-\n-            public boolean hasNext() {\n-                return next < pool.length;\n-            }\n-\n-            public CPInfo next() {\n-                current = pool[next];\n-                switch (current.getTag()) {\n-                    case CONSTANT_Double:\n-                    case CONSTANT_Long:\n-                        next += 2;\n-                        break;\n-                    default:\n-                        next += 1;\n-                }\n-                return current;\n-            }\n-\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            private CPInfo current;\n-            private int next = 1;\n-\n-        };\n-    }\n-\n-    private CPInfo[] pool;\n-\n-    public interface Visitor<R,P> {\n-        R visitClass(CONSTANT_Class_info info, P p);\n-        R visitDouble(CONSTANT_Double_info info, P p);\n-        R visitFieldref(CONSTANT_Fieldref_info info, P p);\n-        R visitFloat(CONSTANT_Float_info info, P p);\n-        R visitInteger(CONSTANT_Integer_info info, P p);\n-        R visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info info, P p);\n-        R visitInvokeDynamic(CONSTANT_InvokeDynamic_info info, P p);\n-        R visitDynamicConstant(CONSTANT_Dynamic_info info, P p);\n-        R visitLong(CONSTANT_Long_info info, P p);\n-        R visitMethodref(CONSTANT_Methodref_info info, P p);\n-        R visitMethodHandle(CONSTANT_MethodHandle_info info, P p);\n-        R visitMethodType(CONSTANT_MethodType_info info, P p);\n-        R visitModule(CONSTANT_Module_info info, P p);\n-        R visitNameAndType(CONSTANT_NameAndType_info info, P p);\n-        R visitPackage(CONSTANT_Package_info info, P p);\n-        R visitString(CONSTANT_String_info info, P p);\n-        R visitUtf8(CONSTANT_Utf8_info info, P p);\n-    }\n-\n-    public abstract static class CPInfo {\n-        CPInfo() {\n-            this.cp = null;\n-        }\n-\n-        CPInfo(ConstantPool cp) {\n-            this.cp = cp;\n-        }\n-\n-        public abstract int getTag();\n-\n-        \/** The number of slots in the constant pool used by this entry.\n-         * 2 for CONSTANT_Double and CONSTANT_Long; 1 for everything else. *\/\n-        public int size() {\n-            return 1;\n-        }\n-\n-        public abstract int byteLength();\n-\n-        public abstract <R,D> R accept(Visitor<R,D> visitor, D data);\n-\n-        protected final ConstantPool cp;\n-    }\n-\n-    public abstract static class CPRefInfo extends CPInfo {\n-        protected CPRefInfo(ConstantPool cp, ClassReader cr, int tag) throws IOException {\n-            super(cp);\n-            this.tag = tag;\n-            class_index = cr.readUnsignedShort();\n-            name_and_type_index = cr.readUnsignedShort();\n-        }\n-\n-        protected CPRefInfo(ConstantPool cp, int tag, int class_index, int name_and_type_index) {\n-            super(cp);\n-            this.tag = tag;\n-            this.class_index = class_index;\n-            this.name_and_type_index = name_and_type_index;\n-        }\n-\n-        public int getTag() {\n-            return tag;\n-        }\n-\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        public CONSTANT_Class_info getClassInfo() throws ConstantPoolException {\n-            return cp.getClassInfo(class_index);\n-        }\n-\n-        public String getClassName() throws ConstantPoolException {\n-            return cp.getClassInfo(class_index).getName();\n-        }\n-\n-        public CONSTANT_NameAndType_info getNameAndTypeInfo() throws ConstantPoolException {\n-            return cp.getNameAndTypeInfo(name_and_type_index);\n-        }\n-\n-        public final int tag;\n-        public final int class_index;\n-        public final int name_and_type_index;\n-    }\n-\n-    public static class CONSTANT_Class_info extends CPInfo {\n-        CONSTANT_Class_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp);\n-            name_index = cr.readUnsignedShort();\n-        }\n-\n-        public CONSTANT_Class_info(ConstantPool cp, int name_index) {\n-            super(cp);\n-            this.name_index = name_index;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_Class;\n-        }\n-\n-        public int  byteLength() {\n-            return 3;\n-        }\n-\n-        \/**\n-         * Get the raw value of the class referenced by this constant pool entry.\n-         * This will either be the name of the class, in internal form, or a\n-         * descriptor for an array class.\n-         * @return the raw value of the class\n-         *\/\n-        public String getName() throws ConstantPoolException {\n-            return cp.getUTF8Value(name_index);\n-        }\n-\n-        \/**\n-         * If this constant pool entry identifies either a class or interface type,\n-         * or a possibly multi-dimensional array of a class of interface type,\n-         * return the name of the class or interface in internal form. Otherwise,\n-         * (i.e. if this is a possibly multi-dimensional array of a primitive type),\n-         * return null.\n-         * @return the base class or interface name\n-         *\/\n-        public String getBaseName() throws ConstantPoolException {\n-            String name = getName();\n-            if (name.startsWith(\"[\")) {\n-                int index = name.indexOf(\"[L\");\n-                if (index == -1)\n-                    return null;\n-                return name.substring(index + 2, name.length() - 1);\n-            } else\n-                return name;\n-        }\n-\n-        public int getDimensionCount() throws ConstantPoolException {\n-            String name = getName();\n-            int count = 0;\n-            while (name.charAt(count) == '[')\n-                count++;\n-            return count;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Class_info[name_index: \" + name_index + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitClass(this, data);\n-        }\n-\n-        public final int name_index;\n-    }\n-\n-    public static class CONSTANT_Double_info extends CPInfo {\n-        CONSTANT_Double_info(ClassReader cr) throws IOException {\n-            value = cr.readDouble();\n-        }\n-\n-        public CONSTANT_Double_info(double value) {\n-            this.value = value;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_Double;\n-        }\n-\n-        public int  byteLength() {\n-            return 9;\n-        }\n-\n-        @Override\n-        public int size() {\n-            return 2;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Double_info[value: \" + value + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitDouble(this, data);\n-        }\n-\n-        public final double value;\n-    }\n-\n-    public static class CONSTANT_Fieldref_info extends CPRefInfo {\n-        CONSTANT_Fieldref_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp, cr, CONSTANT_Fieldref);\n-        }\n-\n-        public CONSTANT_Fieldref_info(ConstantPool cp, int class_index, int name_and_type_index) {\n-            super(cp, CONSTANT_Fieldref, class_index, name_and_type_index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Fieldref_info[class_index: \" + class_index + \", name_and_type_index: \" + name_and_type_index + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitFieldref(this, data);\n-        }\n-    }\n-\n-    public static class CONSTANT_Float_info extends CPInfo {\n-        CONSTANT_Float_info(ClassReader cr) throws IOException {\n-            value = cr.readFloat();\n-        }\n-\n-        public CONSTANT_Float_info(float value) {\n-            this.value = value;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_Float;\n-        }\n-\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Float_info[value: \" + value + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitFloat(this, data);\n-        }\n-\n-        public final float value;\n-    }\n-\n-    public static class CONSTANT_Integer_info extends CPInfo {\n-        CONSTANT_Integer_info(ClassReader cr) throws IOException {\n-            value = cr.readInt();\n-        }\n-\n-        public CONSTANT_Integer_info(int value) {\n-            this.value = value;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_Integer;\n-        }\n-\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Integer_info[value: \" + value + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitInteger(this, data);\n-        }\n-\n-        public final int value;\n-    }\n-\n-    public static class CONSTANT_InterfaceMethodref_info extends CPRefInfo {\n-        CONSTANT_InterfaceMethodref_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp, cr, CONSTANT_InterfaceMethodref);\n-        }\n-\n-        public CONSTANT_InterfaceMethodref_info(ConstantPool cp, int class_index, int name_and_type_index) {\n-            super(cp, CONSTANT_InterfaceMethodref, class_index, name_and_type_index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_InterfaceMethodref_info[class_index: \" + class_index + \", name_and_type_index: \" + name_and_type_index + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitInterfaceMethodref(this, data);\n-        }\n-    }\n-\n-    public static class CONSTANT_InvokeDynamic_info extends CPInfo {\n-        CONSTANT_InvokeDynamic_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp);\n-            bootstrap_method_attr_index = cr.readUnsignedShort();\n-            name_and_type_index = cr.readUnsignedShort();\n-        }\n-\n-        public CONSTANT_InvokeDynamic_info(ConstantPool cp, int bootstrap_method_index, int name_and_type_index) {\n-            super(cp);\n-            this.bootstrap_method_attr_index = bootstrap_method_index;\n-            this.name_and_type_index = name_and_type_index;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_InvokeDynamic;\n-        }\n-\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_InvokeDynamic_info[bootstrap_method_index: \" + bootstrap_method_attr_index + \", name_and_type_index: \" + name_and_type_index + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitInvokeDynamic(this, data);\n-        }\n-\n-        public CONSTANT_NameAndType_info getNameAndTypeInfo() throws ConstantPoolException {\n-            return cp.getNameAndTypeInfo(name_and_type_index);\n-        }\n-\n-        public final int bootstrap_method_attr_index;\n-        public final int name_and_type_index;\n-    }\n-\n-    public static class CONSTANT_Long_info extends CPInfo {\n-        CONSTANT_Long_info(ClassReader cr) throws IOException {\n-            value = cr.readLong();\n-        }\n-\n-        public CONSTANT_Long_info(long value) {\n-            this.value = value;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_Long;\n-        }\n-\n-        @Override\n-        public int size() {\n-            return 2;\n-        }\n-\n-        public int byteLength() {\n-            return 9;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Long_info[value: \" + value + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitLong(this, data);\n-        }\n-\n-        public final long value;\n-    }\n-\n-    public static class CONSTANT_MethodHandle_info extends CPInfo {\n-        CONSTANT_MethodHandle_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp);\n-            reference_kind =  RefKind.getRefkind(cr.readUnsignedByte());\n-            reference_index = cr.readUnsignedShort();\n-        }\n-\n-        public CONSTANT_MethodHandle_info(ConstantPool cp, RefKind ref_kind, int member_index) {\n-            super(cp);\n-            this.reference_kind = ref_kind;\n-            this.reference_index = member_index;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_MethodHandle;\n-        }\n-\n-        public int byteLength() {\n-            return 4;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_MethodHandle_info[ref_kind: \" + reference_kind + \", member_index: \" + reference_index + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitMethodHandle(this, data);\n-        }\n-\n-        public CPRefInfo getCPRefInfo() throws ConstantPoolException {\n-            int expected = CONSTANT_Methodref;\n-            int actual = cp.get(reference_index).getTag();\n-            \/\/ allow these tag types also:\n-            switch (actual) {\n-                case CONSTANT_Fieldref:\n-                case CONSTANT_InterfaceMethodref:\n-                    expected = actual;\n-            }\n-            return (CPRefInfo) cp.get(reference_index, expected);\n-        }\n-\n-        public final RefKind reference_kind;\n-        public final int reference_index;\n-    }\n-\n-    public static class CONSTANT_MethodType_info extends CPInfo {\n-        CONSTANT_MethodType_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp);\n-            descriptor_index = cr.readUnsignedShort();\n-        }\n-\n-        public CONSTANT_MethodType_info(ConstantPool cp, int signature_index) {\n-            super(cp);\n-            this.descriptor_index = signature_index;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_MethodType;\n-        }\n-\n-        public int byteLength() {\n-            return 3;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_MethodType_info[signature_index: \" + descriptor_index + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitMethodType(this, data);\n-        }\n-\n-        public String getType() throws ConstantPoolException {\n-            return cp.getUTF8Value(descriptor_index);\n-        }\n-\n-        public final int descriptor_index;\n-    }\n-\n-    public static class CONSTANT_Methodref_info extends CPRefInfo {\n-        CONSTANT_Methodref_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp, cr, CONSTANT_Methodref);\n-        }\n-\n-        public CONSTANT_Methodref_info(ConstantPool cp, int class_index, int name_and_type_index) {\n-            super(cp, CONSTANT_Methodref, class_index, name_and_type_index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Methodref_info[class_index: \" + class_index + \", name_and_type_index: \" + name_and_type_index + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitMethodref(this, data);\n-        }\n-    }\n-\n-    public static class CONSTANT_Module_info extends CPInfo {\n-        CONSTANT_Module_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp);\n-            name_index = cr.readUnsignedShort();\n-        }\n-\n-        public CONSTANT_Module_info(ConstantPool cp, int name_index) {\n-            super(cp);\n-            this.name_index = name_index;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_Module;\n-        }\n-\n-        public int  byteLength() {\n-            return 3;\n-        }\n-\n-        \/**\n-         * Get the raw value of the module name referenced by this constant pool entry.\n-         * This will be the name of the module.\n-         * @return the raw value of the module name\n-         *\/\n-        public String getName() throws ConstantPoolException {\n-            return cp.getUTF8Value(name_index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Module_info[name_index: \" + name_index + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitModule(this, data);\n-        }\n-\n-        public final int name_index;\n-    }\n-\n-    public static class CONSTANT_NameAndType_info extends CPInfo {\n-        CONSTANT_NameAndType_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp);\n-            name_index = cr.readUnsignedShort();\n-            type_index = cr.readUnsignedShort();\n-        }\n-\n-        public CONSTANT_NameAndType_info(ConstantPool cp, int name_index, int type_index) {\n-            super(cp);\n-            this.name_index = name_index;\n-            this.type_index = type_index;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_NameAndType;\n-        }\n-\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        public String getName() throws ConstantPoolException {\n-            return cp.getUTF8Value(name_index);\n-        }\n-\n-        public String getType() throws ConstantPoolException {\n-            return cp.getUTF8Value(type_index);\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitNameAndType(this, data);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_NameAndType_info[name_index: \" + name_index + \", type_index: \" + type_index + \"]\";\n-        }\n-\n-        public final int name_index;\n-        public final int type_index;\n-    }\n-\n-    public static class CONSTANT_Dynamic_info extends CPInfo {\n-        CONSTANT_Dynamic_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp);\n-            bootstrap_method_attr_index = cr.readUnsignedShort();\n-            name_and_type_index = cr.readUnsignedShort();\n-        }\n-\n-        public CONSTANT_Dynamic_info(ConstantPool cp, int bootstrap_method_index, int name_and_type_index) {\n-            super(cp);\n-            this.bootstrap_method_attr_index = bootstrap_method_index;\n-            this.name_and_type_index = name_and_type_index;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_Dynamic;\n-        }\n-\n-        public int byteLength() {\n-            return 5;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Dynamic_info[bootstrap_method_index: \" + bootstrap_method_attr_index + \", name_and_type_index: \" + name_and_type_index + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitDynamicConstant(this, data);\n-        }\n-\n-        public CONSTANT_NameAndType_info getNameAndTypeInfo() throws ConstantPoolException {\n-            return cp.getNameAndTypeInfo(name_and_type_index);\n-        }\n-\n-        public final int bootstrap_method_attr_index;\n-        public final int name_and_type_index;\n-    }\n-\n-    public static class CONSTANT_Package_info extends CPInfo {\n-        CONSTANT_Package_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp);\n-            name_index = cr.readUnsignedShort();\n-        }\n-\n-        public CONSTANT_Package_info(ConstantPool cp, int name_index) {\n-            super(cp);\n-            this.name_index = name_index;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_Package;\n-        }\n-\n-        public int  byteLength() {\n-            return 3;\n-        }\n-\n-        \/**\n-         * Get the raw value of the package name referenced by this constant pool entry.\n-         * This will be the name of the package, in internal form.\n-         * @return the raw value of the module name\n-         *\/\n-        public String getName() throws ConstantPoolException {\n-            return cp.getUTF8Value(name_index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_Package_info[name_index: \" + name_index + \"]\";\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitPackage(this, data);\n-        }\n-\n-        public final int name_index;\n-    }\n-\n-    public static class CONSTANT_String_info extends CPInfo {\n-        CONSTANT_String_info(ConstantPool cp, ClassReader cr) throws IOException {\n-            super(cp);\n-            string_index = cr.readUnsignedShort();\n-        }\n-\n-        public CONSTANT_String_info(ConstantPool cp, int string_index) {\n-            super(cp);\n-            this.string_index = string_index;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_String;\n-        }\n-\n-        public int byteLength() {\n-            return 3;\n-        }\n-\n-        public String getString() throws ConstantPoolException {\n-            return cp.getUTF8Value(string_index);\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitString(this, data);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"CONSTANT_String_info[class_index: \" + string_index + \"]\";\n-        }\n-\n-        public final int string_index;\n-    }\n-\n-    public static class CONSTANT_Utf8_info extends CPInfo {\n-        CONSTANT_Utf8_info(ClassReader cr) throws IOException {\n-            value = cr.readUTF();\n-        }\n-\n-        public CONSTANT_Utf8_info(String value) {\n-            this.value = value;\n-        }\n-\n-        public int getTag() {\n-            return CONSTANT_Utf8;\n-        }\n-\n-        public int byteLength() {\n-            class SizeOutputStream extends OutputStream {\n-                @Override\n-                public void write(int b) {\n-                    size++;\n-                }\n-                int size;\n-            }\n-            SizeOutputStream sizeOut = new SizeOutputStream();\n-            DataOutputStream out = new DataOutputStream(sizeOut);\n-            try { out.writeUTF(value); } catch (IOException ignore) { }\n-            return 1 + sizeOut.size;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            if (value.length() < 32 && isPrintableAscii(value))\n-                return \"CONSTANT_Utf8_info[value: \\\"\" + value + \"\\\"]\";\n-            else\n-                return \"CONSTANT_Utf8_info[value: (\" + value.length() + \" chars)]\";\n-        }\n-\n-        static boolean isPrintableAscii(String s) {\n-            for (int i = 0; i < s.length(); i++) {\n-                char c = s.charAt(i);\n-                if (c < 32 || c >= 127)\n-                    return false;\n-            }\n-            return true;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitUtf8(this, data);\n-        }\n-\n-        public final String value;\n-    }\n-\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ConstantPool.java","additions":0,"deletions":1053,"binary":false,"changes":1053,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2009, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-\/*\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ConstantPoolException extends Exception {\n-    private static final long serialVersionUID = -2324397349644754565L;\n-    ConstantPoolException(int index) {\n-        this.index = index;\n-    }\n-\n-    public final int index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ConstantPoolException.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.2.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ConstantValue_attribute extends Attribute {\n-    ConstantValue_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        constantvalue_index = cr.readUnsignedShort();\n-    }\n-\n-    public ConstantValue_attribute(ConstantPool constant_pool, int constantvalue_index)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.ConstantValue), constantvalue_index);\n-    }\n-\n-    public ConstantValue_attribute(int name_index, int constantvalue_index) {\n-        super(name_index, 2);\n-        this.constantvalue_index = constantvalue_index;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitConstantValue(this, data);\n-    }\n-\n-    public final int constantvalue_index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ConstantValue_attribute.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-\/*\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class DefaultAttribute extends Attribute {\n-    DefaultAttribute(ClassReader cr, int name_index, byte[] data) {\n-        this(cr, name_index, data, null);\n-    }\n-\n-    DefaultAttribute(ClassReader cr, int name_index, byte[] data, String reason) {\n-        super(name_index, data.length);\n-        info = data;\n-        this.reason = reason;\n-    }\n-\n-    public DefaultAttribute(ConstantPool constant_pool, int name_index, byte[] info) {\n-        this(constant_pool, name_index, info, null);\n-    }\n-\n-    public DefaultAttribute(ConstantPool constant_pool, int name_index,\n-            byte[] info, String reason) {\n-        super(name_index, info.length);\n-        this.info = info;\n-        this.reason = reason;\n-    }\n-\n-    public <R, P> R accept(Visitor<R, P> visitor, P p) {\n-        return visitor.visitDefault(this, p);\n-    }\n-\n-    public final byte[] info;\n-    \/** Why did we need to generate a DefaultAttribute\n-     *\/\n-    public final String reason;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/DefaultAttribute.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.15.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Deprecated_attribute extends Attribute {\n-    Deprecated_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-    }\n-\n-    public Deprecated_attribute(ConstantPool constant_pool)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.Deprecated));\n-    }\n-\n-    public Deprecated_attribute(int name_index) {\n-        super(name_index, 0);\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitDeprecated(this, data);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Deprecated_attribute.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,198 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.4.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Descriptor {\n-    public static class InvalidDescriptor extends DescriptorException {\n-        private static final long serialVersionUID = 1L;\n-        InvalidDescriptor(String desc) {\n-            this.desc = desc;\n-            this.index = -1;\n-        }\n-\n-        InvalidDescriptor(String desc, int index) {\n-            this.desc = desc;\n-            this.index = index;\n-        }\n-\n-        @Override\n-        public String getMessage() {\n-            \/\/ i18n\n-            if (index == -1)\n-                return \"invalid descriptor \\\"\" + desc + \"\\\"\";\n-            else\n-                return \"descriptor is invalid at offset \" + index + \" in \\\"\" + desc + \"\\\"\";\n-        }\n-\n-        public final String desc;\n-        public final int index;\n-\n-    }\n-\n-    public Descriptor(ClassReader cr) throws IOException {\n-        this(cr.readUnsignedShort());\n-    }\n-\n-    public Descriptor(int index) {\n-        this.index = index;\n-\n-    }\n-\n-    public String getValue(ConstantPool constant_pool) throws ConstantPoolException {\n-        return constant_pool.getUTF8Value(index);\n-    }\n-\n-    public int getParameterCount(ConstantPool constant_pool)\n-            throws ConstantPoolException, InvalidDescriptor {\n-        String desc = getValue(constant_pool);\n-        int end = desc.indexOf(\")\");\n-        if (end == -1)\n-            throw new InvalidDescriptor(desc);\n-        parse(desc, 0, end + 1);\n-        return count;\n-\n-    }\n-\n-    public String getParameterTypes(ConstantPool constant_pool)\n-            throws ConstantPoolException, InvalidDescriptor {\n-        String desc = getValue(constant_pool);\n-        int end = desc.indexOf(\")\");\n-        if (end == -1)\n-            throw new InvalidDescriptor(desc);\n-        return parse(desc, 0, end + 1);\n-    }\n-\n-    public String getReturnType(ConstantPool constant_pool)\n-            throws ConstantPoolException, InvalidDescriptor {\n-        String desc = getValue(constant_pool);\n-        int end = desc.indexOf(\")\");\n-        if (end == -1)\n-            throw new InvalidDescriptor(desc);\n-        return parse(desc, end + 1, desc.length());\n-    }\n-\n-    public String getFieldType(ConstantPool constant_pool)\n-            throws ConstantPoolException, InvalidDescriptor {\n-        String desc = getValue(constant_pool);\n-        return parse(desc, 0, desc.length());\n-    }\n-\n-    private String parse(String desc, int start, int end)\n-            throws InvalidDescriptor {\n-        int p = start;\n-        StringBuilder sb = new StringBuilder();\n-        int dims = 0;\n-        count = 0;\n-\n-        while (p < end) {\n-            String type;\n-            char ch;\n-            switch (ch = desc.charAt(p++)) {\n-                case '(':\n-                    sb.append('(');\n-                    continue;\n-\n-                case ')':\n-                    sb.append(')');\n-                    continue;\n-\n-                case '[':\n-                    dims++;\n-                    continue;\n-\n-                case 'B':\n-                    type = \"byte\";\n-                    break;\n-\n-                case 'C':\n-                    type = \"char\";\n-                    break;\n-\n-                case 'D':\n-                    type = \"double\";\n-                    break;\n-\n-                case 'F':\n-                    type = \"float\";\n-                    break;\n-\n-                case 'I':\n-                    type = \"int\";\n-                    break;\n-\n-                case 'J':\n-                    type = \"long\";\n-                    break;\n-\n-                case 'L':\n-                    int sep = desc.indexOf(';', p);\n-                    if (sep == -1)\n-                        throw new InvalidDescriptor(desc, p - 1);\n-                    type = desc.substring(p, sep).replace('\/', '.');\n-                    p = sep + 1;\n-                    break;\n-\n-                case 'S':\n-                    type = \"short\";\n-                    break;\n-\n-                case 'Z':\n-                    type = \"boolean\";\n-                    break;\n-\n-                case 'V':\n-                    type = \"void\";\n-                    break;\n-\n-                default:\n-                    throw new InvalidDescriptor(desc, p - 1);\n-            }\n-\n-            if (sb.length() > 1 && sb.charAt(0) == '(')\n-                sb.append(\", \");\n-            sb.append(type);\n-            for ( ; dims > 0; dims-- )\n-                sb.append(\"[]\");\n-\n-            count++;\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-    public final int index;\n-    private int count;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Descriptor.java","additions":0,"deletions":198,"binary":false,"changes":198,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2009, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-\/*\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class DescriptorException extends Exception {\n-    private static final long serialVersionUID = 2411890273788901032L;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/DescriptorException.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.7.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class EnclosingMethod_attribute extends Attribute {\n-    EnclosingMethod_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        class_index = cr.readUnsignedShort();\n-        method_index = cr.readUnsignedShort();\n-    }\n-\n-    public EnclosingMethod_attribute(ConstantPool constant_pool, int class_index, int method_index)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.EnclosingMethod), class_index, method_index);\n-    }\n-\n-    public EnclosingMethod_attribute(int name_index, int class_index, int method_index) {\n-        super(name_index, 4);\n-        this.class_index = class_index;\n-        this.method_index = method_index;\n-    }\n-\n-    public String getClassName(ConstantPool constant_pool) throws ConstantPoolException {\n-        return constant_pool.getClassInfo(class_index).getName();\n-    }\n-\n-    public String getMethodName(ConstantPool constant_pool) throws ConstantPoolException {\n-        if (method_index == 0)\n-            return \"\";\n-        return constant_pool.getNameAndTypeInfo(method_index).getName();\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitEnclosingMethod(this, data);\n-    }\n-\n-    public final int class_index;\n-    public final int method_index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/EnclosingMethod_attribute.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.5.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Exceptions_attribute extends Attribute {\n-    Exceptions_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        number_of_exceptions = cr.readUnsignedShort();\n-        exception_index_table = new int[number_of_exceptions];\n-        for (int i = 0; i < number_of_exceptions; i++)\n-            exception_index_table[i] = cr.readUnsignedShort();\n-    }\n-\n-    public Exceptions_attribute(ConstantPool constant_pool, int[] exception_index_table)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.Exceptions), exception_index_table);\n-    }\n-\n-    public Exceptions_attribute(int name_index, int[] exception_index_table) {\n-        super(name_index, 2 + 2 * exception_index_table.length);\n-        this.number_of_exceptions = exception_index_table.length;\n-        this.exception_index_table = exception_index_table;\n-    }\n-\n-    public String getException(int index, ConstantPool constant_pool) throws ConstantPoolException {\n-        int exception_index = exception_index_table[index];\n-        return constant_pool.getClassInfo(exception_index).getName();\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitExceptions(this, data);\n-    }\n-\n-    public final int number_of_exceptions;\n-    public final int[] exception_index_table;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Exceptions_attribute.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class FatalError extends Error {\n-    private static final long serialVersionUID = 8114054446416187030L;\n-\n-    FatalError(String message) {\n-        super(message);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/FatalError.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/*\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Field {\n-    Field(ClassReader cr) throws IOException {\n-        access_flags = new AccessFlags(cr);\n-        name_index = cr.readUnsignedShort();\n-        descriptor = new Descriptor(cr);\n-        attributes = new Attributes(cr);\n-    }\n-\n-    public Field(AccessFlags access_flags,\n-            int name_index, Descriptor descriptor,\n-            Attributes attributes) {\n-        this.access_flags = access_flags;\n-        this.name_index = name_index;\n-        this.descriptor = descriptor;\n-        this.attributes = attributes;\n-    }\n-\n-    public int byteLength() {\n-        return 6 + attributes.byteLength();\n-    }\n-\n-    public String getName(ConstantPool constant_pool) throws ConstantPoolException {\n-        return constant_pool.getUTF8Value(name_index);\n-    }\n-\n-    public final AccessFlags access_flags;\n-    public final int name_index;\n-    public final Descriptor descriptor;\n-    public final Attributes attributes;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Field.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-import com.sun.tools.classfile.ConstantPool.*;\n-\n-\/**\n- * See JVMS, section 4.8.6.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class InnerClasses_attribute extends Attribute {\n-    InnerClasses_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        number_of_classes = cr.readUnsignedShort();\n-        classes = new Info[number_of_classes];\n-        for (int i = 0; i < number_of_classes; i++)\n-            classes[i] = new Info(cr);\n-    }\n-\n-    public InnerClasses_attribute(ConstantPool constant_pool, Info[] classes)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.InnerClasses), classes);\n-    }\n-\n-    public InnerClasses_attribute(int name_index, Info[] classes) {\n-        super(name_index, 2 + Info.length() * classes.length);\n-        this.number_of_classes = classes.length;\n-        this.classes = classes;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitInnerClasses(this, data);\n-    }\n-\n-    public final int number_of_classes;\n-    public final Info[] classes;\n-\n-    public static class Info {\n-        Info(ClassReader cr) throws IOException {\n-            inner_class_info_index = cr.readUnsignedShort();\n-            outer_class_info_index = cr.readUnsignedShort();\n-            inner_name_index = cr.readUnsignedShort();\n-            inner_class_access_flags = new AccessFlags(cr.readUnsignedShort());\n-        }\n-\n-        public Info(int inner_class_info_index, int outer_class_info_index, int inner_name_index, AccessFlags inner_class_access_flags) {\n-            this.inner_class_info_index = inner_class_info_index;\n-            this.outer_class_info_index = outer_class_info_index;\n-            this.inner_name_index = inner_name_index;\n-            this.inner_class_access_flags = inner_class_access_flags;\n-        }\n-\n-        public CONSTANT_Class_info getInnerClassInfo(ConstantPool constant_pool) throws ConstantPoolException {\n-            if (inner_class_info_index == 0)\n-                return null;\n-            return constant_pool.getClassInfo(inner_class_info_index);\n-        }\n-\n-        public CONSTANT_Class_info getOuterClassInfo(ConstantPool constant_pool) throws ConstantPoolException {\n-            if (outer_class_info_index == 0)\n-                return null;\n-            return constant_pool.getClassInfo(outer_class_info_index);\n-        }\n-\n-        public String getInnerName(ConstantPool constant_pool) throws ConstantPoolException {\n-            if (inner_name_index == 0)\n-                return null;\n-            return constant_pool.getUTF8Value(inner_name_index);\n-        }\n-\n-        public static int length() {\n-            return 8;\n-        }\n-\n-        public final int inner_class_info_index;\n-        public final int outer_class_info_index;\n-        public final int inner_name_index;\n-        public final AccessFlags inner_class_access_flags;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/InnerClasses_attribute.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,357 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.util.Locale;\n-\n-\/**\n- * See JVMS, chapter 6.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\n- * @see Code_attribute#getInstructions\n- *\/\n-public class Instruction {\n-    \/** The kind of an instruction, as determined by the position, size and\n-     *  types of its operands. *\/\n-    public static enum Kind {\n-        \/** Opcode is not followed by any operands. *\/\n-        NO_OPERANDS(1),\n-        \/** Opcode is followed by a byte indicating a type. *\/\n-        ATYPE(2),\n-        \/** Opcode is followed by a 2-byte branch offset. *\/\n-        BRANCH(3),\n-        \/** Opcode is followed by a 4-byte branch offset. *\/\n-        BRANCH_W(5),\n-        \/** Opcode is followed by a signed byte value. *\/\n-        BYTE(2),\n-        \/** Opcode is followed by a 1-byte index into the constant pool. *\/\n-        CPREF(2),\n-        \/** Opcode is followed by a 2-byte index into the constant pool. *\/\n-        CPREF_W(3),\n-        \/** Opcode is followed by a 2-byte index into the constant pool,\n-         *  an unsigned byte value. *\/\n-        CPREF_W_UBYTE(4),\n-        \/** Opcode is followed by a 2-byte index into the constant pool.,\n-         *  an unsigned byte value, and a zero byte. *\/\n-        CPREF_W_UBYTE_ZERO(5),\n-        \/** Opcode is followed by variable number of operands, depending\n-         * on the instruction.*\/\n-        DYNAMIC(-1),\n-        \/** Opcode is followed by a 1-byte reference to a local variable. *\/\n-        LOCAL(2),\n-        \/** Opcode is followed by a 1-byte reference to a local variable,\n-         *  and a signed byte value. *\/\n-        LOCAL_BYTE(3),\n-        \/** Opcode is followed by a signed short value. *\/\n-        SHORT(3),\n-        \/** Wide opcode is not followed by any operands. *\/\n-        WIDE_NO_OPERANDS(2),\n-        \/** Wide opcode is followed by a 2-byte index into the local variables array. *\/\n-        WIDE_LOCAL(4),\n-        \/** Wide opcode is followed by a 2-byte index into the constant pool. *\/\n-        WIDE_CPREF_W(4),\n-        \/** Wide opcode is followed by a 2-byte index into the constant pool,\n-         *  and a signed short value. *\/\n-        WIDE_CPREF_W_SHORT(6),\n-        \/** Wide opcode is followed by a 2-byte reference to a local variable,\n-         *  and a signed short value. *\/\n-        WIDE_LOCAL_SHORT(6),\n-        \/** Opcode was not recognized. *\/\n-        UNKNOWN(1);\n-\n-        Kind(int length) {\n-            this.length = length;\n-        }\n-\n-        \/** The length, in bytes, of this kind of instruction, or -1 is the\n-         *  length depends on the specific instruction. *\/\n-        public final int length;\n-    }\n-\n-    \/** A utility visitor to help decode the operands of an instruction.\n-     *  @see Instruction#accept *\/\n-    public interface KindVisitor<R,P> {\n-        \/** See {@link Kind#NO_OPERANDS}, {@link Kind#WIDE_NO_OPERANDS}. *\/\n-        R visitNoOperands(Instruction instr, P p);\n-        \/** See {@link Kind#ATYPE}. *\/\n-        R visitArrayType(Instruction instr, TypeKind kind, P p);\n-        \/** See {@link Kind#BRANCH}, {@link Kind#BRANCH_W}. *\/\n-        R visitBranch(Instruction instr, int offset, P p);\n-        \/** See {@link Kind#CPREF}, {@link Kind#CPREF_W}, {@link Kind#WIDE_CPREF_W}. *\/\n-        R visitConstantPoolRef(Instruction instr, int index, P p);\n-        \/** See {@link Kind#CPREF_W_UBYTE}, {@link Kind#CPREF_W_UBYTE_ZERO}, {@link Kind#WIDE_CPREF_W_SHORT}. *\/\n-        R visitConstantPoolRefAndValue(Instruction instr, int index, int value, P p);\n-        \/** See {@link Kind#LOCAL}, {@link Kind#WIDE_LOCAL}. *\/\n-        R visitLocal(Instruction instr, int index, P p);\n-        \/** See {@link Kind#LOCAL_BYTE}. *\/\n-        R visitLocalAndValue(Instruction instr, int index, int value, P p);\n-        \/** See {@link Kind#DYNAMIC}. *\/\n-        R visitLookupSwitch(Instruction instr, int default_, int npairs, int[] matches, int[] offsets, P p);\n-        \/** See {@link Kind#DYNAMIC}. *\/\n-        R visitTableSwitch(Instruction instr, int default_, int low, int high, int[] offsets, P p);\n-        \/** See {@link Kind#BYTE}, {@link Kind#SHORT}. *\/\n-        R visitValue(Instruction instr, int value, P p);\n-        \/** Instruction is unrecognized. *\/\n-        R visitUnknown(Instruction instr, P p);\n-\n-    }\n-\n-    \/** The kind of primitive array type to create.\n-     *  See JVMS chapter 6, newarray. *\/\n-    public static enum TypeKind {\n-        T_BOOLEAN(4, \"boolean\"),\n-        T_CHAR(5, \"char\"),\n-        T_FLOAT(6, \"float\"),\n-        T_DOUBLE(7, \"double\"),\n-        T_BYTE(8, \"byte\"),\n-        T_SHORT(9, \"short\"),\n-        T_INT (10, \"int\"),\n-        T_LONG (11, \"long\");\n-        TypeKind(int value, String name) {\n-            this.value = value;\n-            this.name = name;\n-        }\n-\n-        public static TypeKind get(int value) {\n-            switch (value) {\n-                case  4: return T_BOOLEAN;\n-                case  5: return T_CHAR;\n-                case  6: return T_FLOAT;\n-                case  7: return T_DOUBLE;\n-                case  8: return T_BYTE;\n-                case  9: return T_SHORT;\n-                case  10: return T_INT;\n-                case  11: return T_LONG;\n-                default: return null;\n-            }\n-        }\n-\n-        public final int value;\n-        public final String name;\n-    }\n-\n-    \/** An instruction is defined by its position in a bytecode array. *\/\n-    public Instruction(byte[] bytes, int pc) {\n-        this.bytes = bytes;\n-        this.pc = pc;\n-    }\n-\n-    \/** Get the position of the instruction within the bytecode array. *\/\n-    public int getPC() {\n-        return pc;\n-    }\n-\n-    \/** Get a byte value, relative to the start of this instruction. *\/\n-    public int getByte(int offset) {\n-        return bytes[pc + offset];\n-    }\n-\n-    \/** Get an unsigned byte value, relative to the start of this instruction. *\/\n-    public int getUnsignedByte(int offset) {\n-        return getByte(offset) & 0xff;\n-    }\n-\n-    \/** Get a 2-byte value, relative to the start of this instruction. *\/\n-    public int getShort(int offset) {\n-        return (getByte(offset) << 8) | getUnsignedByte(offset + 1);\n-    }\n-\n-    \/** Get a unsigned 2-byte value, relative to the start of this instruction. *\/\n-    public int getUnsignedShort(int offset) {\n-        return getShort(offset) & 0xFFFF;\n-    }\n-\n-    \/** Get a 4-byte value, relative to the start of this instruction. *\/\n-    public int getInt(int offset) {\n-        return (getShort(offset) << 16) | (getUnsignedShort(offset + 2));\n-    }\n-\n-    \/** Get the Opcode for this instruction, or null if the instruction is\n-     * unrecognized. *\/\n-    public Opcode getOpcode() {\n-        int b = getUnsignedByte(0);\n-        switch (b) {\n-            case Opcode.NONPRIV:\n-            case Opcode.PRIV:\n-            case Opcode.WIDE:\n-                return Opcode.get(b, getUnsignedByte(1));\n-        }\n-        return Opcode.get(b);\n-    }\n-\n-    \/** Get the mnemonic for this instruction, or a default string if the\n-     * instruction is unrecognized. *\/\n-    public String getMnemonic() {\n-        Opcode opcode = getOpcode();\n-        if (opcode == null)\n-            return \"bytecode \" + getUnsignedByte(0);\n-        else\n-            return opcode.toString().toLowerCase(Locale.US);\n-    }\n-\n-    \/** Get the length, in bytes, of this instruction, including the opcode\n-     * and all its operands. *\/\n-    public int length() {\n-        Opcode opcode = getOpcode();\n-        if (opcode == null)\n-            return 1;\n-\n-        switch (opcode) {\n-            case TABLESWITCH: {\n-                int pad = align(pc + 1) - pc;\n-                int low = getInt(pad + 4);\n-                int high = getInt(pad + 8);\n-                return pad + 12 + 4 * (high - low + 1);\n-            }\n-            case LOOKUPSWITCH: {\n-                int pad = align(pc + 1) - pc;\n-                int npairs = getInt(pad + 4);\n-                return pad + 8 + 8 * npairs;\n-\n-            }\n-            default:\n-                return opcode.kind.length;\n-        }\n-    }\n-\n-    \/** Get the {@link Kind} of this instruction. *\/\n-    public Kind getKind() {\n-        Opcode opcode = getOpcode();\n-        return (opcode != null ? opcode.kind : Kind.UNKNOWN);\n-    }\n-\n-    \/** Invoke a method on the visitor according to the kind of this\n-     * instruction, passing in the decoded operands for the instruction. *\/\n-    public <R,P> R accept(KindVisitor<R,P> visitor, P p) {\n-        switch (getKind()) {\n-            case NO_OPERANDS:\n-                return visitor.visitNoOperands(this, p);\n-\n-            case ATYPE:\n-                return visitor.visitArrayType(\n-                        this, TypeKind.get(getUnsignedByte(1)), p);\n-\n-            case BRANCH:\n-                return visitor.visitBranch(this, getShort(1), p);\n-\n-            case BRANCH_W:\n-                return visitor.visitBranch(this, getInt(1), p);\n-\n-            case BYTE:\n-                return visitor.visitValue(this, getByte(1), p);\n-\n-            case CPREF:\n-                return visitor.visitConstantPoolRef(this, getUnsignedByte(1), p);\n-\n-            case CPREF_W:\n-                return visitor.visitConstantPoolRef(this, getUnsignedShort(1), p);\n-\n-            case CPREF_W_UBYTE:\n-            case CPREF_W_UBYTE_ZERO:\n-                return visitor.visitConstantPoolRefAndValue(\n-                        this, getUnsignedShort(1), getUnsignedByte(3), p);\n-\n-            case DYNAMIC: {\n-                switch (getOpcode()) {\n-                    case TABLESWITCH: {\n-                        int pad = align(pc + 1) - pc;\n-                        int default_ = getInt(pad);\n-                        int low = getInt(pad + 4);\n-                        int high = getInt(pad + 8);\n-                        if (low > high)\n-                            throw new IllegalStateException();\n-                        int[] values = new int[high - low + 1];\n-                        for (int i = 0; i < values.length; i++)\n-                            values[i] = getInt(pad + 12 + 4 * i);\n-                        return visitor.visitTableSwitch(\n-                                this, default_, low, high, values, p);\n-                    }\n-                    case LOOKUPSWITCH: {\n-                        int pad = align(pc + 1) - pc;\n-                        int default_ = getInt(pad);\n-                        int npairs = getInt(pad + 4);\n-                        if (npairs < 0)\n-                            throw new IllegalStateException();\n-                        int[] matches = new int[npairs];\n-                        int[] offsets = new int[npairs];\n-                        for (int i = 0; i < npairs; i++) {\n-                            matches[i] = getInt(pad +  8 + i * 8);\n-                            offsets[i] = getInt(pad + 12 + i * 8);\n-                        }\n-                        return visitor.visitLookupSwitch(\n-                                this, default_, npairs, matches, offsets, p);\n-                    }\n-                    default:\n-                        throw new IllegalStateException();\n-                }\n-            }\n-\n-            case LOCAL:\n-                return visitor.visitLocal(this, getUnsignedByte(1), p);\n-\n-            case LOCAL_BYTE:\n-                return visitor.visitLocalAndValue(\n-                        this, getUnsignedByte(1), getByte(2), p);\n-\n-            case SHORT:\n-                return visitor.visitValue(this, getShort(1), p);\n-\n-            case WIDE_NO_OPERANDS:\n-                return visitor.visitNoOperands(this, p);\n-\n-            case WIDE_LOCAL:\n-                return visitor.visitLocal(this, getUnsignedShort(2), p);\n-\n-            case WIDE_CPREF_W:\n-                return visitor.visitConstantPoolRef(this, getUnsignedShort(2), p);\n-\n-            case WIDE_CPREF_W_SHORT:\n-                return visitor.visitConstantPoolRefAndValue(\n-                        this, getUnsignedShort(2), getUnsignedByte(4), p);\n-\n-            case WIDE_LOCAL_SHORT:\n-                return visitor.visitLocalAndValue(\n-                        this, getUnsignedShort(2), getShort(4), p);\n-\n-            case UNKNOWN:\n-                return visitor.visitUnknown(this, p);\n-\n-            default:\n-                throw new IllegalStateException();\n-        }\n-    }\n-\n-    private static int align(int n) {\n-        return (n + 3) & ~3;\n-    }\n-\n-    private byte[] bytes;\n-    private int pc;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Instruction.java","additions":0,"deletions":357,"binary":false,"changes":357,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.12.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class LineNumberTable_attribute extends Attribute {\n-    LineNumberTable_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        line_number_table_length = cr.readUnsignedShort();\n-        line_number_table = new Entry[line_number_table_length];\n-        for (int i = 0; i < line_number_table_length; i++)\n-            line_number_table[i] = new Entry(cr);\n-    }\n-\n-    public LineNumberTable_attribute(ConstantPool constant_pool, Entry[] line_number_table)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.LineNumberTable), line_number_table);\n-    }\n-\n-    public LineNumberTable_attribute(int name_index, Entry[] line_number_table) {\n-        super(name_index, 2 + line_number_table.length * Entry.length());\n-        this.line_number_table_length = line_number_table.length;\n-        this.line_number_table = line_number_table;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitLineNumberTable(this, data);\n-    }\n-\n-    public final int line_number_table_length;\n-    public final Entry[] line_number_table;\n-\n-    public static class Entry {\n-        Entry(ClassReader cr) throws IOException {\n-            start_pc = cr.readUnsignedShort();\n-            line_number = cr.readUnsignedShort();\n-        }\n-\n-        public static int length() {\n-            return 4;\n-        }\n-\n-        public final int start_pc;\n-        public final int line_number;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/LineNumberTable_attribute.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.13.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class LocalVariableTable_attribute extends Attribute {\n-    LocalVariableTable_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        local_variable_table_length = cr.readUnsignedShort();\n-        local_variable_table = new Entry[local_variable_table_length];\n-        for (int i = 0; i < local_variable_table_length; i++)\n-            local_variable_table[i] = new Entry(cr);\n-    }\n-\n-    public LocalVariableTable_attribute(ConstantPool constant_pool, Entry[] local_variable_table)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.LocalVariableTable), local_variable_table);\n-    }\n-\n-    public LocalVariableTable_attribute(int name_index, Entry[] local_variable_table) {\n-        super(name_index, 2 + local_variable_table.length * Entry.length());\n-        this.local_variable_table_length = local_variable_table.length;\n-        this.local_variable_table = local_variable_table;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitLocalVariableTable(this, data);\n-    }\n-\n-    public final int local_variable_table_length;\n-    public final Entry[] local_variable_table;\n-\n-    public static class Entry {\n-        Entry(ClassReader cr) throws IOException {\n-            start_pc = cr.readUnsignedShort();\n-            length = cr.readUnsignedShort();\n-            name_index = cr.readUnsignedShort();\n-            descriptor_index = cr.readUnsignedShort();\n-            index = cr.readUnsignedShort();\n-        }\n-\n-        public static int length() {\n-            return 10;\n-        }\n-\n-        public final int start_pc;\n-        public final int length;\n-        public final int name_index;\n-        public final int descriptor_index;\n-        public final int index;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/LocalVariableTable_attribute.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.14.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class LocalVariableTypeTable_attribute extends Attribute {\n-    LocalVariableTypeTable_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        local_variable_table_length = cr.readUnsignedShort();\n-        local_variable_table = new Entry[local_variable_table_length];\n-        for (int i = 0; i < local_variable_table_length; i++)\n-            local_variable_table[i] = new Entry(cr);\n-    }\n-\n-    public LocalVariableTypeTable_attribute(ConstantPool constant_pool, Entry[] local_variable_table)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.LocalVariableTypeTable), local_variable_table);\n-    }\n-\n-    public LocalVariableTypeTable_attribute(int name_index, Entry[] local_variable_table) {\n-        super(name_index, 2 + local_variable_table.length * Entry.length());\n-        this.local_variable_table_length = local_variable_table.length;\n-        this.local_variable_table = local_variable_table;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitLocalVariableTypeTable(this, data);\n-    }\n-\n-    public final int local_variable_table_length;\n-    public final Entry[] local_variable_table;\n-\n-    public static class Entry {\n-        Entry(ClassReader cr) throws IOException {\n-            start_pc = cr.readUnsignedShort();\n-            length = cr.readUnsignedShort();\n-            name_index = cr.readUnsignedShort();\n-            signature_index = cr.readUnsignedShort();\n-            index = cr.readUnsignedShort();\n-        }\n-\n-        public static int length() {\n-            return 10;\n-        }\n-\n-        public final int start_pc;\n-        public final int length;\n-        public final int name_index;\n-        public final int signature_index;\n-        public final int index;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/LocalVariableTypeTable_attribute.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/*\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Method {\n-    Method(ClassReader cr) throws IOException {\n-        access_flags = new AccessFlags(cr);\n-        name_index = cr.readUnsignedShort();\n-        descriptor = new Descriptor(cr);\n-        attributes = new Attributes(cr);\n-    }\n-\n-    public Method(AccessFlags access_flags,\n-            int name_index, Descriptor descriptor,\n-            Attributes attributes) {\n-        this.access_flags = access_flags;\n-        this.name_index = name_index;\n-        this.descriptor = descriptor;\n-        this.attributes = attributes;\n-    }\n-\n-    public int byteLength() {\n-        return 6 + attributes.byteLength();\n-    }\n-\n-    public String getName(ConstantPool constant_pool) throws ConstantPoolException {\n-        return constant_pool.getUTF8Value(name_index);\n-    }\n-\n-    public final AccessFlags access_flags;\n-    public final int name_index;\n-    public final Descriptor descriptor;\n-    public final Attributes attributes;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Method.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.13.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class MethodParameters_attribute extends Attribute {\n-\n-    public final int method_parameter_table_length;\n-    public final Entry[] method_parameter_table;\n-\n-    MethodParameters_attribute(ClassReader cr,\n-                              int name_index,\n-                              int length)\n-        throws IOException {\n-        super(name_index, length);\n-\n-        method_parameter_table_length = cr.readUnsignedByte();\n-        method_parameter_table = new Entry[method_parameter_table_length];\n-        for (int i = 0; i < method_parameter_table_length; i++)\n-            method_parameter_table[i] = new Entry(cr);\n-    }\n-\n-    public MethodParameters_attribute(ConstantPool constant_pool,\n-                                      Entry[] method_parameter_table)\n-        throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.MethodParameters),\n-             method_parameter_table);\n-    }\n-\n-    public MethodParameters_attribute(int name_index,\n-                                      Entry[] method_parameter_table) {\n-        super(name_index, 1 + method_parameter_table.length * Entry.length());\n-        this.method_parameter_table_length = method_parameter_table.length;\n-        this.method_parameter_table = method_parameter_table;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitMethodParameters(this, data);\n-    }\n-\n-    public static class Entry {\n-        Entry(ClassReader cr) throws IOException {\n-            name_index = cr.readUnsignedShort();\n-            flags = cr.readUnsignedShort();\n-        }\n-\n-        public Entry(int name_index, int flags) {\n-            this.name_index = name_index;\n-            this.flags = flags;\n-        }\n-\n-        public static int length() {\n-            return 6;\n-        }\n-\n-        public final int name_index;\n-        public final int flags;\n-    }\n-\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/MethodParameters_attribute.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.15.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ModuleHashes_attribute extends Attribute {\n-    ModuleHashes_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        algorithm_index = cr.readUnsignedShort();\n-        hashes_table_length = cr.readUnsignedShort();\n-        hashes_table = new Entry[hashes_table_length];\n-        for (int i = 0; i < hashes_table_length; i++)\n-            hashes_table[i] = new Entry(cr);\n-    }\n-\n-    public ModuleHashes_attribute(ConstantPool constant_pool, int algorithm_index, Entry[] hashes_table)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.ModuleHashes), algorithm_index, hashes_table);\n-    }\n-\n-    public ModuleHashes_attribute(int name_index, int algorithm_index, Entry[] hashes_table) {\n-        super(name_index, 2 + 2 + length(hashes_table));\n-        this.algorithm_index = algorithm_index;\n-        this.hashes_table_length = hashes_table.length;\n-        this.hashes_table = hashes_table;\n-    }\n-\n-    @Override\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitModuleHashes(this, data);\n-    }\n-\n-    private static int length(Entry[] hashes_table) {\n-        int len = 0;\n-        for (Entry e: hashes_table) {\n-            len += e.length();\n-        }\n-        return len;\n-    }\n-\n-    public final int algorithm_index;\n-    public final int hashes_table_length;\n-    public final Entry[] hashes_table;\n-\n-    public static class Entry {\n-        Entry(ClassReader cr) throws IOException {\n-            module_name_index = cr.readUnsignedShort();\n-            int hash_length = cr.readUnsignedShort();\n-            hash = new byte[hash_length];\n-            for (int i=0; i<hash_length; i++) {\n-                hash[i] = (byte) cr.readUnsignedByte();\n-            }\n-        }\n-\n-        public int length() {\n-            return 4 + hash.length;\n-        }\n-\n-        public final int module_name_index;\n-        public final byte[] hash;\n-    }\n-\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ModuleHashes_attribute.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.15.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ModuleMainClass_attribute extends Attribute {\n-    ModuleMainClass_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        main_class_index = cr.readUnsignedShort();\n-    }\n-\n-    public ModuleMainClass_attribute(ConstantPool constant_pool, int mainClass_index)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.ModuleMainClass), mainClass_index);\n-    }\n-\n-    public ModuleMainClass_attribute(int name_index, int mainClass_index) {\n-        super(name_index, 2);\n-        this.main_class_index = mainClass_index;\n-    }\n-\n-    public String getMainClassName(ConstantPool constant_pool) throws ConstantPoolException {\n-        return constant_pool.getClassInfo(main_class_index).getName();\n-    }\n-\n-    @Override\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitModuleMainClass(this, data);\n-    }\n-\n-    public final int main_class_index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ModuleMainClass_attribute.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Package_info;\n-\n-\/**\n- * See JVMS, section 4.8.15.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ModulePackages_attribute extends Attribute {\n-    ModulePackages_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException {\n-        super(name_index, length);\n-        packages_count = cr.readUnsignedShort();\n-        packages_index = new int[packages_count];\n-        for (int i = 0; i < packages_count; i++)\n-            packages_index[i] = cr.readUnsignedShort();\n-    }\n-\n-    public ModulePackages_attribute(ConstantPool constant_pool,\n-                              int[] packages_index)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.ModulePackages),\n-             packages_index);\n-    }\n-\n-    public ModulePackages_attribute(int name_index,\n-                              int[] packages_index) {\n-        super(name_index, 2 + packages_index.length * 2);\n-        this.packages_count = packages_index.length;\n-        this.packages_index = packages_index;\n-    }\n-\n-    public String getPackage(int index, ConstantPool constant_pool) throws ConstantPoolException {\n-        int package_index = packages_index[index];\n-        CONSTANT_Package_info info = constant_pool.getPackageInfo(package_index);\n-        return info.getName();\n-    }\n-\n-    @Override\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitModulePackages(this, data);\n-    }\n-\n-    public final int packages_count;\n-    public final int[] packages_index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ModulePackages_attribute.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.15.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ModuleResolution_attribute extends Attribute {\n-    public static final int DO_NOT_RESOLVE_BY_DEFAULT   = 0x0001;\n-    public static final int WARN_DEPRECATED             = 0x0002;\n-    public static final int WARN_DEPRECATED_FOR_REMOVAL = 0x0004;\n-    public static final int WARN_INCUBATING             = 0x0008;\n-\n-    ModuleResolution_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException {\n-        super(name_index, length);\n-        resolution_flags = cr.readUnsignedShort();\n-    }\n-\n-    public ModuleResolution_attribute(ConstantPool constant_pool,\n-                              int resolution_flags)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.ModuleResolution),\n-             resolution_flags);\n-    }\n-\n-    public ModuleResolution_attribute(int name_index,\n-                              int resolution_flags) {\n-        super(name_index, 2);\n-        this.resolution_flags = resolution_flags;\n-    }\n-\n-    @Override\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitModuleResolution(this, data);\n-    }\n-\n-    public final int resolution_flags;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ModuleResolution_attribute.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.15.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ModuleTarget_attribute extends Attribute {\n-    ModuleTarget_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        target_platform_index = cr.readUnsignedShort();\n-    }\n-\n-    public ModuleTarget_attribute(int name_index, int target_platform_index) {\n-        super(name_index, 2);\n-        this.target_platform_index = target_platform_index;\n-    }\n-\n-    @Override\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitModuleTarget(this, data);\n-    }\n-\n-    public final int target_platform_index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ModuleTarget_attribute.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,230 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Module_info;\n-\n-\/**\n- * See Jigsaw.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Module_attribute extends Attribute {\n-    public static final int ACC_TRANSITIVE      =   0x20;\n-    public static final int ACC_STATIC_PHASE    =   0x40;\n-    public static final int ACC_OPEN            =   0x20;\n-    public static final int ACC_SYNTHETIC       = 0x1000;\n-    public static final int ACC_MANDATED        = 0x8000;\n-\n-    Module_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-\n-        module_name = cr.readUnsignedShort();\n-        module_flags = cr.readUnsignedShort();\n-\n-        module_version_index = cr.readUnsignedShort();\n-\n-        requires_count = cr.readUnsignedShort();\n-        requires = new RequiresEntry[requires_count];\n-        for (int i = 0; i < requires_count; i++)\n-            requires[i] = new RequiresEntry(cr);\n-\n-        exports_count = cr.readUnsignedShort();\n-        exports = new ExportsEntry[exports_count];\n-        for (int i = 0; i < exports_count; i++)\n-            exports[i] = new ExportsEntry(cr);\n-\n-        opens_count = cr.readUnsignedShort();\n-        opens = new OpensEntry[opens_count];\n-        for (int i = 0; i < opens_count; i++)\n-            opens[i] = new OpensEntry(cr);\n-\n-        uses_count = cr.readUnsignedShort();\n-        uses_index = new int[uses_count];\n-        for (int i = 0; i < uses_count; i++)\n-            uses_index[i] = cr.readUnsignedShort();\n-\n-        provides_count = cr.readUnsignedShort();\n-        provides = new ProvidesEntry[provides_count];\n-        for (int i = 0; i < provides_count; i++)\n-            provides[i] = new ProvidesEntry(cr);\n-    }\n-\n-    public Module_attribute(int name_index,\n-            int module_name,\n-            int module_flags,\n-            int module_version_index,\n-            RequiresEntry[] requires,\n-            ExportsEntry[] exports,\n-            OpensEntry[] opens,\n-            int[] uses,\n-            ProvidesEntry[] provides) {\n-        super(name_index, 2);\n-        this.module_name = module_name;\n-        this.module_flags = module_flags;\n-        this.module_version_index = module_version_index;\n-        requires_count = requires.length;\n-        this.requires = requires;\n-        exports_count = exports.length;\n-        this.exports = exports;\n-        opens_count = opens.length;\n-        this.opens = opens;\n-        uses_count = uses.length;\n-        this.uses_index = uses;\n-        provides_count = provides.length;\n-        this.provides = provides;\n-    }\n-\n-    public String getUses(int index, ConstantPool constant_pool) throws ConstantPoolException {\n-        int i = uses_index[index];\n-        return constant_pool.getClassInfo(i).getName();\n-    }\n-\n-    @Override\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitModule(this, data);\n-    }\n-\n-    public final int module_name;\n-    public final int module_flags;\n-    public final int module_version_index;\n-    public final int requires_count;\n-    public final RequiresEntry[] requires;\n-    public final int exports_count;\n-    public final ExportsEntry[] exports;\n-    public final int opens_count;\n-    public final OpensEntry[] opens;\n-    public final int uses_count;\n-    public final int[] uses_index;\n-    public final int provides_count;\n-    public final ProvidesEntry[] provides;\n-\n-    public static class RequiresEntry {\n-        RequiresEntry(ClassReader cr) throws IOException {\n-            requires_index = cr.readUnsignedShort();\n-            requires_flags = cr.readUnsignedShort();\n-            requires_version_index = cr.readUnsignedShort();\n-        }\n-\n-        public RequiresEntry(int index, int flags, int version_index) {\n-            this.requires_index = index;\n-            this.requires_flags = flags;\n-            this.requires_version_index = version_index;\n-        }\n-\n-        public String getRequires(ConstantPool constant_pool) throws ConstantPoolException {\n-            CONSTANT_Module_info info = constant_pool.getModuleInfo(requires_index);\n-            return info.getName();\n-        }\n-\n-        public static final int length = 4;\n-\n-        public final int requires_index;\n-        public final int requires_flags;\n-        public final int requires_version_index;\n-    }\n-\n-    public static class ExportsEntry {\n-        ExportsEntry(ClassReader cr) throws IOException {\n-            exports_index = cr.readUnsignedShort();\n-            exports_flags = cr.readUnsignedShort();\n-            exports_to_count = cr.readUnsignedShort();\n-            exports_to_index = new int[exports_to_count];\n-            for (int i = 0; i < exports_to_count; i++)\n-                exports_to_index[i] = cr.readUnsignedShort();\n-        }\n-\n-        public ExportsEntry(int index, int flags, int[] to) {\n-            this.exports_index = index;\n-            this.exports_flags = flags;\n-            this.exports_to_count = to.length;\n-            this.exports_to_index = to;\n-        }\n-\n-        public int length() {\n-            return 4 + 2 * exports_to_index.length;\n-        }\n-\n-        public final int exports_index;\n-        public final int exports_flags;\n-        public final int exports_to_count;\n-        public final int[] exports_to_index;\n-    }\n-\n-    public static class OpensEntry {\n-        OpensEntry(ClassReader cr) throws IOException {\n-            opens_index = cr.readUnsignedShort();\n-            opens_flags = cr.readUnsignedShort();\n-            opens_to_count = cr.readUnsignedShort();\n-            opens_to_index = new int[opens_to_count];\n-            for (int i = 0; i < opens_to_count; i++)\n-                opens_to_index[i] = cr.readUnsignedShort();\n-        }\n-\n-        public OpensEntry(int index, int flags, int[] to) {\n-            this.opens_index = index;\n-            this.opens_flags = flags;\n-            this.opens_to_count = to.length;\n-            this.opens_to_index = to;\n-        }\n-\n-        public int length() {\n-            return 4 + 2 * opens_to_index.length;\n-        }\n-\n-        public final int opens_index;\n-        public final int opens_flags;\n-        public final int opens_to_count;\n-        public final int[] opens_to_index;\n-    }\n-\n-    public static class ProvidesEntry {\n-        ProvidesEntry(ClassReader cr) throws IOException {\n-            provides_index = cr.readUnsignedShort();\n-            with_count = cr.readUnsignedShort();\n-            with_index = new int[with_count];\n-            for (int i = 0; i < with_count; i++)\n-                with_index[i] = cr.readUnsignedShort();\n-        }\n-\n-        public ProvidesEntry(int provides, int[] with) {\n-            this.provides_index = provides;\n-            this.with_count = with.length;\n-            this.with_index = with;\n-        }\n-\n-        public static final int length = 4;\n-\n-        public final int provides_index;\n-        public final int with_count;\n-        public final int[] with_index;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Module_attribute.java","additions":0,"deletions":230,"binary":false,"changes":230,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-\n-import java.io.IOException;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class NestHost_attribute extends Attribute {\n-    NestHost_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        top_index = cr.readUnsignedShort();\n-    }\n-\n-    public NestHost_attribute(ConstantPool constant_pool, int signature_index)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.Signature), signature_index);\n-    }\n-\n-    public NestHost_attribute(int name_index, int top_index) {\n-        super(name_index, 2);\n-        this.top_index = top_index;\n-    }\n-\n-    public CONSTANT_Class_info getNestTop(ConstantPool constant_pool) throws ConstantPoolException {\n-        return constant_pool.getClassInfo(top_index);\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitNestHost(this, data);\n-    }\n-\n-    public final int top_index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/NestHost_attribute.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-\n-import java.io.IOException;\n-import java.util.stream.IntStream;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class NestMembers_attribute extends Attribute {\n-    NestMembers_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        int len = cr.readUnsignedShort();\n-        members_indexes = new int[len];\n-        for (int i = 0 ; i < len ; i++) {\n-            members_indexes[i] = cr.readUnsignedShort();\n-        }\n-    }\n-\n-    public NestMembers_attribute(int name_index, int[] members_indexes) {\n-        super(name_index, 2);\n-        this.members_indexes = members_indexes;\n-    }\n-\n-    public CONSTANT_Class_info[] getChildren(ConstantPool constant_pool) throws ConstantPoolException {\n-        return IntStream.of(members_indexes)\n-                .mapToObj(i -> {\n-                    try {\n-                        return constant_pool.getClassInfo(i);\n-                    } catch (ConstantPoolException ex) {\n-                        throw new AssertionError(ex);\n-                    }\n-                }).toArray(CONSTANT_Class_info[]::new);\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitNestMembers(this, data);\n-    }\n-\n-    public final int[] members_indexes;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/NestMembers_attribute.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,472 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import static com.sun.tools.classfile.Instruction.Kind.*;\n-import static com.sun.tools.classfile.Opcode.Set.*;\n-\n-\/**\n- * See JVMS, chapter 6.\n- *\n- * <p>In addition to providing all the standard opcodes defined in JVMS,\n- * this class also provides legacy support for the PicoJava extensions.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public enum Opcode {\n-    NOP(0x0),\n-    ACONST_NULL(0x1),\n-    ICONST_M1(0x2),\n-    ICONST_0(0x3),\n-    ICONST_1(0x4),\n-    ICONST_2(0x5),\n-    ICONST_3(0x6),\n-    ICONST_4(0x7),\n-    ICONST_5(0x8),\n-    LCONST_0(0x9),\n-    LCONST_1(0xa),\n-    FCONST_0(0xb),\n-    FCONST_1(0xc),\n-    FCONST_2(0xd),\n-    DCONST_0(0xe),\n-    DCONST_1(0xf),\n-    BIPUSH(0x10, BYTE),\n-    SIPUSH(0x11, SHORT),\n-    LDC(0x12, CPREF),\n-    LDC_W(0x13, CPREF_W),\n-    LDC2_W(0x14, CPREF_W),\n-    ILOAD(0x15, LOCAL),\n-    LLOAD(0x16, LOCAL),\n-    FLOAD(0x17, LOCAL),\n-    DLOAD(0x18, LOCAL),\n-    ALOAD(0x19, LOCAL),\n-    ILOAD_0(0x1a),\n-    ILOAD_1(0x1b),\n-    ILOAD_2(0x1c),\n-    ILOAD_3(0x1d),\n-    LLOAD_0(0x1e),\n-    LLOAD_1(0x1f),\n-    LLOAD_2(0x20),\n-    LLOAD_3(0x21),\n-    FLOAD_0(0x22),\n-    FLOAD_1(0x23),\n-    FLOAD_2(0x24),\n-    FLOAD_3(0x25),\n-    DLOAD_0(0x26),\n-    DLOAD_1(0x27),\n-    DLOAD_2(0x28),\n-    DLOAD_3(0x29),\n-    ALOAD_0(0x2a),\n-    ALOAD_1(0x2b),\n-    ALOAD_2(0x2c),\n-    ALOAD_3(0x2d),\n-    IALOAD(0x2e),\n-    LALOAD(0x2f),\n-    FALOAD(0x30),\n-    DALOAD(0x31),\n-    AALOAD(0x32),\n-    BALOAD(0x33),\n-    CALOAD(0x34),\n-    SALOAD(0x35),\n-    ISTORE(0x36, LOCAL),\n-    LSTORE(0x37, LOCAL),\n-    FSTORE(0x38, LOCAL),\n-    DSTORE(0x39, LOCAL),\n-    ASTORE(0x3a, LOCAL),\n-    ISTORE_0(0x3b),\n-    ISTORE_1(0x3c),\n-    ISTORE_2(0x3d),\n-    ISTORE_3(0x3e),\n-    LSTORE_0(0x3f),\n-    LSTORE_1(0x40),\n-    LSTORE_2(0x41),\n-    LSTORE_3(0x42),\n-    FSTORE_0(0x43),\n-    FSTORE_1(0x44),\n-    FSTORE_2(0x45),\n-    FSTORE_3(0x46),\n-    DSTORE_0(0x47),\n-    DSTORE_1(0x48),\n-    DSTORE_2(0x49),\n-    DSTORE_3(0x4a),\n-    ASTORE_0(0x4b),\n-    ASTORE_1(0x4c),\n-    ASTORE_2(0x4d),\n-    ASTORE_3(0x4e),\n-    IASTORE(0x4f),\n-    LASTORE(0x50),\n-    FASTORE(0x51),\n-    DASTORE(0x52),\n-    AASTORE(0x53),\n-    BASTORE(0x54),\n-    CASTORE(0x55),\n-    SASTORE(0x56),\n-    POP(0x57),\n-    POP2(0x58),\n-    DUP(0x59),\n-    DUP_X1(0x5a),\n-    DUP_X2(0x5b),\n-    DUP2(0x5c),\n-    DUP2_X1(0x5d),\n-    DUP2_X2(0x5e),\n-    SWAP(0x5f),\n-    IADD(0x60),\n-    LADD(0x61),\n-    FADD(0x62),\n-    DADD(0x63),\n-    ISUB(0x64),\n-    LSUB(0x65),\n-    FSUB(0x66),\n-    DSUB(0x67),\n-    IMUL(0x68),\n-    LMUL(0x69),\n-    FMUL(0x6a),\n-    DMUL(0x6b),\n-    IDIV(0x6c),\n-    LDIV(0x6d),\n-    FDIV(0x6e),\n-    DDIV(0x6f),\n-    IREM(0x70),\n-    LREM(0x71),\n-    FREM(0x72),\n-    DREM(0x73),\n-    INEG(0x74),\n-    LNEG(0x75),\n-    FNEG(0x76),\n-    DNEG(0x77),\n-    ISHL(0x78),\n-    LSHL(0x79),\n-    ISHR(0x7a),\n-    LSHR(0x7b),\n-    IUSHR(0x7c),\n-    LUSHR(0x7d),\n-    IAND(0x7e),\n-    LAND(0x7f),\n-    IOR(0x80),\n-    LOR(0x81),\n-    IXOR(0x82),\n-    LXOR(0x83),\n-    IINC(0x84, LOCAL_BYTE),\n-    I2L(0x85),\n-    I2F(0x86),\n-    I2D(0x87),\n-    L2I(0x88),\n-    L2F(0x89),\n-    L2D(0x8a),\n-    F2I(0x8b),\n-    F2L(0x8c),\n-    F2D(0x8d),\n-    D2I(0x8e),\n-    D2L(0x8f),\n-    D2F(0x90),\n-    I2B(0x91),\n-    I2C(0x92),\n-    I2S(0x93),\n-    LCMP(0x94),\n-    FCMPL(0x95),\n-    FCMPG(0x96),\n-    DCMPL(0x97),\n-    DCMPG(0x98),\n-    IFEQ(0x99, BRANCH),\n-    IFNE(0x9a, BRANCH),\n-    IFLT(0x9b, BRANCH),\n-    IFGE(0x9c, BRANCH),\n-    IFGT(0x9d, BRANCH),\n-    IFLE(0x9e, BRANCH),\n-    IF_ICMPEQ(0x9f, BRANCH),\n-    IF_ICMPNE(0xa0, BRANCH),\n-    IF_ICMPLT(0xa1, BRANCH),\n-    IF_ICMPGE(0xa2, BRANCH),\n-    IF_ICMPGT(0xa3, BRANCH),\n-    IF_ICMPLE(0xa4, BRANCH),\n-    IF_ACMPEQ(0xa5, BRANCH),\n-    IF_ACMPNE(0xa6, BRANCH),\n-    GOTO(0xa7, BRANCH),\n-    JSR(0xa8, BRANCH),\n-    RET(0xa9, LOCAL),\n-    TABLESWITCH(0xaa, DYNAMIC),\n-    LOOKUPSWITCH(0xab, DYNAMIC),\n-    IRETURN(0xac),\n-    LRETURN(0xad),\n-    FRETURN(0xae),\n-    DRETURN(0xaf),\n-    ARETURN(0xb0),\n-    RETURN(0xb1),\n-    GETSTATIC(0xb2, CPREF_W),\n-    PUTSTATIC(0xb3, CPREF_W),\n-    GETFIELD(0xb4, CPREF_W),\n-    PUTFIELD(0xb5, CPREF_W),\n-    INVOKEVIRTUAL(0xb6, CPREF_W),\n-    INVOKESPECIAL(0xb7, CPREF_W),\n-    INVOKESTATIC(0xb8, CPREF_W),\n-    INVOKEINTERFACE(0xb9, CPREF_W_UBYTE_ZERO),\n-    INVOKEDYNAMIC(0xba, CPREF_W_UBYTE_ZERO),\n-    NEW(0xbb, CPREF_W),\n-    NEWARRAY(0xbc, ATYPE),\n-    ANEWARRAY(0xbd, CPREF_W),\n-    ARRAYLENGTH(0xbe),\n-    ATHROW(0xbf),\n-    CHECKCAST(0xc0, CPREF_W),\n-    INSTANCEOF(0xc1, CPREF_W),\n-    MONITORENTER(0xc2),\n-    MONITOREXIT(0xc3),\n-    \/\/ wide 0xc4\n-    MULTIANEWARRAY(0xc5, CPREF_W_UBYTE),\n-    IFNULL(0xc6, BRANCH),\n-    IFNONNULL(0xc7, BRANCH),\n-    GOTO_W(0xc8, BRANCH_W),\n-    JSR_W(0xc9, BRANCH_W),\n-    \/\/ impdep 0xfe: PicoJava nonpriv\n-    \/\/ impdep 0xff: Picojava priv\n-\n-    \/\/ wide opcodes\n-    ILOAD_W(0xc415, WIDE_LOCAL),\n-    LLOAD_W(0xc416, WIDE_LOCAL),\n-    FLOAD_W(0xc417, WIDE_LOCAL),\n-    DLOAD_W(0xc418, WIDE_LOCAL),\n-    ALOAD_W(0xc419, WIDE_LOCAL),\n-    ISTORE_W(0xc436, WIDE_LOCAL),\n-    LSTORE_W(0xc437, WIDE_LOCAL),\n-    FSTORE_W(0xc438, WIDE_LOCAL),\n-    DSTORE_W(0xc439, WIDE_LOCAL),\n-    ASTORE_W(0xc43a, WIDE_LOCAL),\n-    IINC_W(0xc484, WIDE_LOCAL_SHORT),\n-    RET_W(0xc4a9, WIDE_LOCAL),\n-\n-    \/\/ PicoJava nonpriv instructions\n-    LOAD_UBYTE(PICOJAVA, 0xfe00),\n-    LOAD_BYTE(PICOJAVA, 0xfe01),\n-    LOAD_CHAR(PICOJAVA, 0xfe02),\n-    LOAD_SHORT(PICOJAVA, 0xfe03),\n-    LOAD_WORD(PICOJAVA, 0xfe04),\n-    RET_FROM_SUB(PICOJAVA, 0xfe05),\n-    LOAD_CHAR_OE(PICOJAVA, 0xfe0a),\n-    LOAD_SHORT_OE(PICOJAVA, 0xfe0b),\n-    LOAD_WORD_OE(PICOJAVA, 0xfe0c),\n-    NCLOAD_UBYTE(PICOJAVA, 0xfe10),\n-    NCLOAD_BYTE(PICOJAVA, 0xfe11),\n-    NCLOAD_CHAR(PICOJAVA, 0xfe12),\n-    NCLOAD_SHORT(PICOJAVA, 0xfe13),\n-    NCLOAD_WORD(PICOJAVA, 0xfe14),\n-    NCLOAD_CHAR_OE(PICOJAVA, 0xfe1a),\n-    NCLOAD_SHORT_OE(PICOJAVA, 0xfe1b),\n-    NCLOAD_WORD_OE(PICOJAVA, 0xfe1c),\n-    CACHE_FLUSH(PICOJAVA, 0xfe1e),\n-    STORE_BYTE(PICOJAVA, 0xfe20),\n-    STORE_SHORT(PICOJAVA, 0xfe22),\n-    STORE_WORD(PICOJAVA, 0xfe24),\n-    STORE_SHORT_OE(PICOJAVA, 0xfe2a),\n-    STORE_WORD_OE(PICOJAVA, 0xfe2c),\n-    NCSTORE_BYTE(PICOJAVA, 0xfe30),\n-    NCSTORE_SHORT(PICOJAVA, 0xfe32),\n-    NCSTORE_WORD(PICOJAVA, 0xfe34),\n-    NCSTORE_SHORT_OE(PICOJAVA, 0xfe3a),\n-    NCSTORE_WORD_OE(PICOJAVA, 0xfe3c),\n-    ZERO_LINE(PICOJAVA, 0xfe3e),\n-    ENTER_SYNC_METHOD(PICOJAVA, 0xfe3f),\n-\n-    \/\/ PicoJava priv instructions\n-    PRIV_LOAD_UBYTE(PICOJAVA, 0xff00),\n-    PRIV_LOAD_BYTE(PICOJAVA, 0xff01),\n-    PRIV_LOAD_CHAR(PICOJAVA, 0xff02),\n-    PRIV_LOAD_SHORT(PICOJAVA, 0xff03),\n-    PRIV_LOAD_WORD(PICOJAVA, 0xff04),\n-    PRIV_RET_FROM_TRAP(PICOJAVA, 0xff05),\n-    PRIV_READ_DCACHE_TAG(PICOJAVA, 0xff06),\n-    PRIV_READ_DCACHE_DATA(PICOJAVA, 0xff07),\n-    PRIV_LOAD_CHAR_OE(PICOJAVA, 0xff0a),\n-    PRIV_LOAD_SHORT_OE(PICOJAVA, 0xff0b),\n-    PRIV_LOAD_WORD_OE(PICOJAVA, 0xff0c),\n-    PRIV_READ_ICACHE_TAG(PICOJAVA, 0xff0e),\n-    PRIV_READ_ICACHE_DATA(PICOJAVA, 0xff0f),\n-    PRIV_NCLOAD_UBYTE(PICOJAVA, 0xff10),\n-    PRIV_NCLOAD_BYTE(PICOJAVA, 0xff11),\n-    PRIV_NCLOAD_CHAR(PICOJAVA, 0xff12),\n-    PRIV_NCLOAD_SHORT(PICOJAVA, 0xff13),\n-    PRIV_NCLOAD_WORD(PICOJAVA, 0xff14),\n-    PRIV_POWERDOWN(PICOJAVA, 0xff16),\n-    PRIV_READ_SCACHE_DATA(PICOJAVA, 0xff17),\n-    PRIV_NCLOAD_CHAR_OE(PICOJAVA, 0xff1a),\n-    PRIV_NCLOAD_SHORT_OE(PICOJAVA, 0xff1b),\n-    PRIV_NCLOAD_WORD_OE(PICOJAVA, 0xff1c),\n-    PRIV_CACHE_FLUSH(PICOJAVA, 0xff1e),\n-    PRIV_CACHE_INDEX_FLUSH(PICOJAVA, 0xff1f),\n-    PRIV_STORE_BYTE(PICOJAVA, 0xff20),\n-    PRIV_STORE_SHORT(PICOJAVA, 0xff22),\n-    PRIV_STORE_WORD(PICOJAVA, 0xff24),\n-    PRIV_WRITE_DCACHE_TAG(PICOJAVA, 0xff26),\n-    PRIV_WRITE_DCACHE_DATA(PICOJAVA, 0xff27),\n-    PRIV_STORE_SHORT_OE(PICOJAVA, 0xff2a),\n-    PRIV_STORE_WORD_OE(PICOJAVA, 0xff2c),\n-    PRIV_WRITE_ICACHE_TAG(PICOJAVA, 0xff2e),\n-    PRIV_WRITE_ICACHE_DATA(PICOJAVA, 0xff2f),\n-    PRIV_NCSTORE_BYTE(PICOJAVA, 0xff30),\n-    PRIV_NCSTORE_SHORT(PICOJAVA, 0xff32),\n-    PRIV_NCSTORE_WORD(PICOJAVA, 0xff34),\n-    PRIV_RESET(PICOJAVA, 0xff36),\n-    PRIV_WRITE_SCACHE_DATA(PICOJAVA, 0xff37),\n-    PRIV_NCSTORE_SHORT_OE(PICOJAVA, 0xff3a),\n-    PRIV_NCSTORE_WORD_OE(PICOJAVA, 0xff3c),\n-    PRIV_ZERO_LINE(PICOJAVA, 0xff3e),\n-    PRIV_READ_REG_0(PICOJAVA, 0xff40),\n-    PRIV_READ_REG_1(PICOJAVA, 0xff41),\n-    PRIV_READ_REG_2(PICOJAVA, 0xff42),\n-    PRIV_READ_REG_3(PICOJAVA, 0xff43),\n-    PRIV_READ_REG_4(PICOJAVA, 0xff44),\n-    PRIV_READ_REG_5(PICOJAVA, 0xff45),\n-    PRIV_READ_REG_6(PICOJAVA, 0xff46),\n-    PRIV_READ_REG_7(PICOJAVA, 0xff47),\n-    PRIV_READ_REG_8(PICOJAVA, 0xff48),\n-    PRIV_READ_REG_9(PICOJAVA, 0xff49),\n-    PRIV_READ_REG_10(PICOJAVA, 0xff4a),\n-    PRIV_READ_REG_11(PICOJAVA, 0xff4b),\n-    PRIV_READ_REG_12(PICOJAVA, 0xff4c),\n-    PRIV_READ_REG_13(PICOJAVA, 0xff4d),\n-    PRIV_READ_REG_14(PICOJAVA, 0xff4e),\n-    PRIV_READ_REG_15(PICOJAVA, 0xff4f),\n-    PRIV_READ_REG_16(PICOJAVA, 0xff50),\n-    PRIV_READ_REG_17(PICOJAVA, 0xff51),\n-    PRIV_READ_REG_18(PICOJAVA, 0xff52),\n-    PRIV_READ_REG_19(PICOJAVA, 0xff53),\n-    PRIV_READ_REG_20(PICOJAVA, 0xff54),\n-    PRIV_READ_REG_21(PICOJAVA, 0xff55),\n-    PRIV_READ_REG_22(PICOJAVA, 0xff56),\n-    PRIV_READ_REG_23(PICOJAVA, 0xff57),\n-    PRIV_READ_REG_24(PICOJAVA, 0xff58),\n-    PRIV_READ_REG_25(PICOJAVA, 0xff59),\n-    PRIV_READ_REG_26(PICOJAVA, 0xff5a),\n-    PRIV_READ_REG_27(PICOJAVA, 0xff5b),\n-    PRIV_READ_REG_28(PICOJAVA, 0xff5c),\n-    PRIV_READ_REG_29(PICOJAVA, 0xff5d),\n-    PRIV_READ_REG_30(PICOJAVA, 0xff5e),\n-    PRIV_READ_REG_31(PICOJAVA, 0xff5f),\n-    PRIV_WRITE_REG_0(PICOJAVA, 0xff60),\n-    PRIV_WRITE_REG_1(PICOJAVA, 0xff61),\n-    PRIV_WRITE_REG_2(PICOJAVA, 0xff62),\n-    PRIV_WRITE_REG_3(PICOJAVA, 0xff63),\n-    PRIV_WRITE_REG_4(PICOJAVA, 0xff64),\n-    PRIV_WRITE_REG_5(PICOJAVA, 0xff65),\n-    PRIV_WRITE_REG_6(PICOJAVA, 0xff66),\n-    PRIV_WRITE_REG_7(PICOJAVA, 0xff67),\n-    PRIV_WRITE_REG_8(PICOJAVA, 0xff68),\n-    PRIV_WRITE_REG_9(PICOJAVA, 0xff69),\n-    PRIV_WRITE_REG_10(PICOJAVA, 0xff6a),\n-    PRIV_WRITE_REG_11(PICOJAVA, 0xff6b),\n-    PRIV_WRITE_REG_12(PICOJAVA, 0xff6c),\n-    PRIV_WRITE_REG_13(PICOJAVA, 0xff6d),\n-    PRIV_WRITE_REG_14(PICOJAVA, 0xff6e),\n-    PRIV_WRITE_REG_15(PICOJAVA, 0xff6f),\n-    PRIV_WRITE_REG_16(PICOJAVA, 0xff70),\n-    PRIV_WRITE_REG_17(PICOJAVA, 0xff71),\n-    PRIV_WRITE_REG_18(PICOJAVA, 0xff72),\n-    PRIV_WRITE_REG_19(PICOJAVA, 0xff73),\n-    PRIV_WRITE_REG_20(PICOJAVA, 0xff74),\n-    PRIV_WRITE_REG_21(PICOJAVA, 0xff75),\n-    PRIV_WRITE_REG_22(PICOJAVA, 0xff76),\n-    PRIV_WRITE_REG_23(PICOJAVA, 0xff77),\n-    PRIV_WRITE_REG_24(PICOJAVA, 0xff78),\n-    PRIV_WRITE_REG_25(PICOJAVA, 0xff79),\n-    PRIV_WRITE_REG_26(PICOJAVA, 0xff7a),\n-    PRIV_WRITE_REG_27(PICOJAVA, 0xff7b),\n-    PRIV_WRITE_REG_28(PICOJAVA, 0xff7c),\n-    PRIV_WRITE_REG_29(PICOJAVA, 0xff7d),\n-    PRIV_WRITE_REG_30(PICOJAVA, 0xff7e),\n-    PRIV_WRITE_REG_31(PICOJAVA, 0xff7f);\n-\n-    Opcode(int opcode) {\n-        this(STANDARD, opcode, NO_OPERANDS);\n-    }\n-\n-    Opcode(int opcode, Instruction.Kind kind) {\n-        this(STANDARD, opcode, kind);\n-    }\n-\n-    Opcode(Set set, int opcode) {\n-        this(set, opcode, (set == STANDARD ? NO_OPERANDS : WIDE_NO_OPERANDS));\n-    }\n-\n-    Opcode(Set set, int opcode, Instruction.Kind kind) {\n-        this.set = set;\n-        this.opcode = opcode;\n-        this.kind = kind;\n-    }\n-\n-    public final Set set;\n-    public final int opcode;\n-    public final Instruction.Kind kind;\n-\n-    \/** Get the Opcode for a simple standard 1-byte opcode. *\/\n-    public static Opcode get(int opcode) {\n-        return stdOpcodes[opcode];\n-    }\n-\n-    \/** Get the Opcode for 1- or 2-byte opcode. *\/\n-    public static Opcode get(int opcodePrefix, int opcode) {\n-        Opcode[] block = getOpcodeBlock(opcodePrefix);\n-        return (block == null ? null : block[opcode]);\n-    }\n-\n-    private static Opcode[] getOpcodeBlock(int opcodePrefix) {\n-        switch (opcodePrefix) {\n-            case 0:\n-                return stdOpcodes;\n-            case WIDE:\n-                return wideOpcodes;\n-            case NONPRIV:\n-                return nonPrivOpcodes;\n-            case PRIV:\n-                return privOpcodes;\n-            default:\n-                return null;\n-        }\n-\n-    }\n-\n-    private static final Opcode[] stdOpcodes = new Opcode[256];\n-    private static final Opcode[] wideOpcodes = new Opcode[256];\n-    private static final Opcode[] nonPrivOpcodes = new Opcode[256];\n-    private static final Opcode[] privOpcodes = new Opcode[256];\n-    static {\n-        for (Opcode o: values())\n-            getOpcodeBlock(o.opcode >> 8)[o.opcode & 0xff] = o;\n-    }\n-\n-    \/** The byte prefix for the wide instructions. *\/\n-    public static final int WIDE = 0xc4;\n-    \/** The byte prefix for the PicoJava nonpriv instructions. *\/\n-    public static final int NONPRIV = 0xfe;\n-    \/** The byte prefix for the PicoJava priv instructions. *\/\n-    public static final int PRIV = 0xff;\n-\n-    public enum Set {\n-        \/** Standard opcodes. *\/\n-        STANDARD,\n-        \/** Legacy support for PicoJava opcodes. *\/\n-        PICOJAVA  }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Opcode.java","additions":0,"deletions":472,"binary":false,"changes":472,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-import java.util.stream.IntStream;\n-\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-\n-public class PermittedSubclasses_attribute extends Attribute {\n-\n-    public int[] subtypes;\n-\n-    PermittedSubclasses_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        int number_of_classes = cr.readUnsignedShort();\n-        subtypes = new int[number_of_classes];\n-        for (int i = 0; i < number_of_classes; i++)\n-            subtypes[i] = cr.readUnsignedShort();\n-    }\n-\n-    public PermittedSubclasses_attribute(int name_index, int[] subtypes) {\n-        super(name_index, 2);\n-        this.subtypes = subtypes;\n-    }\n-\n-    public CONSTANT_Class_info[] getSubtypes(ConstantPool constant_pool) throws ConstantPoolException {\n-        return IntStream.of(subtypes)\n-                .mapToObj(i -> {\n-                    try {\n-                        return constant_pool.getClassInfo(i);\n-                    } catch (ConstantPoolException ex) {\n-                        throw new AssertionError(ex);\n-                    }\n-                }).toArray(CONSTANT_Class_info[]::new);\n-    }\n-\n-    @Override\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitPermittedSubclasses(this, data);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/PermittedSubclasses_attribute.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-import com.sun.tools.classfile.Attribute.Visitor;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Record_attribute extends Attribute {\n-    Record_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        component_count = cr.readUnsignedShort();\n-        component_info_arr = new ComponentInfo[component_count];\n-        for (int i = 0; i < component_count; i++) {\n-            component_info_arr[i] = new ComponentInfo(cr);\n-        }\n-    }\n-\n-    public Record_attribute(int name_index, ComponentInfo[] component_info_arr) {\n-        super(name_index, 2);\n-        this.component_count = component_info_arr.length;\n-        this.component_info_arr = component_info_arr;\n-    }\n-\n-    @Override\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitRecord(this, data);\n-    }\n-\n-    public final int component_count;\n-    public final ComponentInfo[] component_info_arr;\n-\n-    public static class ComponentInfo {\n-        ComponentInfo(ClassReader cr) throws IOException {\n-            name_index = cr.readUnsignedShort();\n-            descriptor = new Descriptor(cr);\n-            attributes = new Attributes(cr);\n-        }\n-\n-        public ComponentInfo(int name_index, Descriptor descriptor, Attributes attributes) {\n-            this.name_index = name_index;\n-            this.descriptor = descriptor;\n-            this.attributes = attributes;\n-        }\n-\n-        public String getName(ConstantPool constant_pool) throws ConstantPoolException {\n-            return constant_pool.getUTF8Value(name_index);\n-        }\n-\n-        public final int name_index;\n-        public final Descriptor descriptor;\n-        public final Attributes attributes;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Record_attribute.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,253 +0,0 @@\n-\/*\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Set;\n-import com.sun.tools.classfile.Instruction.TypeKind;\n-import static com.sun.tools.classfile.ConstantPool.*;\n-\n-\/**\n- * A utility class to find where in a ClassFile references\n- * a {@link CONSTANT_Methodref_info method},\n- * a {@link CONSTANT_InterfaceMethodref_info interface method},\n- * or a {@link CONSTANT_Fieldref_info field}.\n- *\/\n-public final class ReferenceFinder {\n-    \/**\n-     * Filter for ReferenceFinder of what constant pool entries for reference lookup.\n-     *\/\n-    public interface Filter {\n-        \/**\n-         * Decides if the given CPRefInfo entry should be accepted or filtered.\n-         *\n-         * @param cpool  ConstantPool of the ClassFile being parsed\n-         * @param cpref  constant pool entry representing a reference to\n-         *               a fields method, and interface method.\n-         * @return {@code true} if accepted; otherwise {@code false}\n-         *\/\n-        boolean accept(ConstantPool cpool, CPRefInfo cpref);\n-    }\n-\n-    \/**\n-     * Visitor of individual method of a ClassFile that references the\n-     * accepted field, method, or interface method references.\n-     *\/\n-    public interface Visitor {\n-        \/**\n-         * Invoked for a method containing one or more accepted CPRefInfo entries\n-         *\n-         * @param cf      ClassFile\n-         * @param method  Method that does the references the accepted references\n-         * @param refs    Accepted constant pool method\/field reference\n-         *\/\n-        void visit(ClassFile cf, Method method, List<CPRefInfo> refConstantPool);\n-    }\n-\n-    private final Filter filter;\n-    private final Visitor visitor;\n-\n-    \/**\n-     * Constructor.\n-     *\/\n-    public ReferenceFinder(Filter filter, Visitor visitor) {\n-        this.filter = Objects.requireNonNull(filter);\n-        this.visitor = Objects.requireNonNull(visitor);\n-    }\n-\n-    \/**\n-     * Parses a given ClassFile and invoke the visitor if there is any reference\n-     * to the constant pool entries referencing field, method, or\n-     * interface method that are accepted. This method will return\n-     * {@code true} if there is one or more accepted constant pool entries\n-     * to lookup; otherwise, it will return {@code false}.\n-     *\n-     * @param  cf  ClassFile\n-     * @return {@code true} if the given class file is processed to lookup\n-     *         references\n-     * @throws ConstantPoolException if an error of the constant pool\n-     *\/\n-    public boolean parse(ClassFile cf) throws ConstantPoolException {\n-        List<Integer> cprefs = new ArrayList<>();\n-        int index = 1;\n-        for (ConstantPool.CPInfo cpInfo : cf.constant_pool.entries()) {\n-            if (cpInfo.accept(cpVisitor, cf.constant_pool)) {\n-                cprefs.add(index);\n-            }\n-            index += cpInfo.size();\n-        }\n-\n-        if (cprefs.isEmpty()) {\n-            return false;\n-        }\n-\n-        for (Method m : cf.methods) {\n-            Set<Integer> ids = new HashSet<>();\n-            Code_attribute c_attr = (Code_attribute) m.attributes.get(Attribute.Code);\n-            if (c_attr != null) {\n-                for (Instruction instr : c_attr.getInstructions()) {\n-                    int idx = instr.accept(codeVisitor, cprefs);\n-                    if (idx > 0) {\n-                        ids.add(idx);\n-                    }\n-                }\n-            }\n-            if (ids.size() > 0) {\n-                List<CPRefInfo> refInfos = new ArrayList<>(ids.size());\n-                for (int id : ids) {\n-                    refInfos.add(CPRefInfo.class.cast(cf.constant_pool.get(id)));\n-                }\n-                visitor.visit(cf, m, refInfos);\n-            }\n-        }\n-        return true;\n-    }\n-\n-    private ConstantPool.Visitor<Boolean,ConstantPool> cpVisitor =\n-            new ConstantPool.Visitor<Boolean,ConstantPool>()\n-    {\n-        public Boolean visitClass(CONSTANT_Class_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitFieldref(CONSTANT_Fieldref_info info, ConstantPool cpool) {\n-            return filter.accept(cpool, info);\n-        }\n-\n-        public Boolean visitDouble(CONSTANT_Double_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitFloat(CONSTANT_Float_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitInteger(CONSTANT_Integer_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info info, ConstantPool cpool) {\n-            return filter.accept(cpool, info);\n-        }\n-\n-        public Boolean visitInvokeDynamic(CONSTANT_InvokeDynamic_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        @Override\n-        public Boolean visitDynamicConstant(CONSTANT_Dynamic_info info, ConstantPool constantPool) {\n-            return false;\n-        }\n-\n-        public Boolean visitLong(CONSTANT_Long_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitMethodHandle(CONSTANT_MethodHandle_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitMethodref(CONSTANT_Methodref_info info, ConstantPool cpool) {\n-            return filter.accept(cpool, info);\n-        }\n-\n-        public Boolean visitMethodType(CONSTANT_MethodType_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitModule(CONSTANT_Module_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitNameAndType(CONSTANT_NameAndType_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitPackage(CONSTANT_Package_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitString(CONSTANT_String_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-\n-        public Boolean visitUtf8(CONSTANT_Utf8_info info, ConstantPool cpool) {\n-            return false;\n-        }\n-    };\n-\n-    private Instruction.KindVisitor<Integer, List<Integer>> codeVisitor =\n-            new Instruction.KindVisitor<Integer, List<Integer>>()\n-    {\n-        public Integer visitNoOperands(Instruction instr, List<Integer> p) {\n-            return 0;\n-        }\n-\n-        public Integer visitArrayType(Instruction instr, TypeKind kind, List<Integer> p) {\n-            return 0;\n-        }\n-\n-        public Integer visitBranch(Instruction instr, int offset, List<Integer> p) {\n-            return 0;\n-        }\n-\n-        public Integer visitConstantPoolRef(Instruction instr, int index, List<Integer> p) {\n-            return p.contains(index) ? index : 0;\n-        }\n-\n-        public Integer visitConstantPoolRefAndValue(Instruction instr, int index, int value, List<Integer> p) {\n-            return p.contains(index) ? index : 0;\n-        }\n-\n-        public Integer visitLocal(Instruction instr, int index, List<Integer> p) {\n-            return 0;\n-        }\n-\n-        public Integer visitLocalAndValue(Instruction instr, int index, int value, List<Integer> p) {\n-            return 0;\n-        }\n-\n-        public Integer visitLookupSwitch(Instruction instr, int default_, int npairs, int[] matches, int[] offsets, List<Integer> p) {\n-            return 0;\n-        }\n-\n-        public Integer visitTableSwitch(Instruction instr, int default_, int low, int high, int[] offsets, List<Integer> p) {\n-            return 0;\n-        }\n-\n-        public Integer visitValue(Instruction instr, int value, List<Integer> p) {\n-            return 0;\n-        }\n-\n-        public Integer visitUnknown(Instruction instr, List<Integer> p) {\n-            return 0;\n-        }\n-    };\n-}\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/ReferenceFinder.java","additions":0,"deletions":253,"binary":false,"changes":253,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.16 and 4.8.17.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public abstract class RuntimeAnnotations_attribute extends Attribute {\n-    protected RuntimeAnnotations_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, Annotation.InvalidAnnotation {\n-        super(name_index, length);\n-        int num_annotations = cr.readUnsignedShort();\n-        annotations = new Annotation[num_annotations];\n-        for (int i = 0; i < annotations.length; i++)\n-            annotations[i] = new Annotation(cr);\n-    }\n-\n-    protected RuntimeAnnotations_attribute(int name_index, Annotation[] annotations) {\n-        super(name_index, length(annotations));\n-        this.annotations = annotations;\n-    }\n-\n-    private static int length(Annotation[] annos) {\n-        int n = 2;\n-        for (Annotation anno: annos)\n-            n += anno.length();\n-        return n;\n-    }\n-\n-    public final Annotation[] annotations;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RuntimeAnnotations_attribute.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.17.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class RuntimeInvisibleAnnotations_attribute extends RuntimeAnnotations_attribute {\n-    RuntimeInvisibleAnnotations_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, AttributeException {\n-        super(cr, name_index, length);\n-    }\n-\n-    public RuntimeInvisibleAnnotations_attribute(ConstantPool cp, Annotation[] annotations)\n-            throws ConstantPoolException {\n-        this(cp.getUTF8Index(Attribute.RuntimeInvisibleAnnotations), annotations);\n-    }\n-\n-    public RuntimeInvisibleAnnotations_attribute(int name_index, Annotation[] annotations) {\n-        super(name_index, annotations);\n-    }\n-\n-    public <R, P> R accept(Visitor<R, P> visitor, P p) {\n-        return visitor.visitRuntimeInvisibleAnnotations(this, p);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RuntimeInvisibleAnnotations_attribute.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.18.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class RuntimeInvisibleParameterAnnotations_attribute extends RuntimeParameterAnnotations_attribute {\n-    RuntimeInvisibleParameterAnnotations_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, Annotation.InvalidAnnotation {\n-        super(cr, name_index, length);\n-    }\n-\n-    public RuntimeInvisibleParameterAnnotations_attribute(ConstantPool cp, Annotation[][] parameter_annotations)\n-            throws ConstantPoolException {\n-        this(cp.getUTF8Index(Attribute.RuntimeInvisibleParameterAnnotations), parameter_annotations);\n-    }\n-\n-    public RuntimeInvisibleParameterAnnotations_attribute(int name_index, Annotation[][] parameter_annotations) {\n-        super(name_index, parameter_annotations);\n-    }\n-\n-    public <R, P> R accept(Visitor<R, P> visitor, P p) {\n-        return visitor.visitRuntimeInvisibleParameterAnnotations(this, p);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RuntimeInvisibleParameterAnnotations_attribute.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JSR 308 specification, Section 3.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class RuntimeInvisibleTypeAnnotations_attribute extends RuntimeTypeAnnotations_attribute {\n-    RuntimeInvisibleTypeAnnotations_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, Annotation.InvalidAnnotation {\n-        super(cr, name_index, length);\n-    }\n-\n-    public RuntimeInvisibleTypeAnnotations_attribute(ConstantPool cp, TypeAnnotation[] annotations)\n-            throws ConstantPoolException {\n-        this(cp.getUTF8Index(Attribute.RuntimeInvisibleTypeAnnotations), annotations);\n-    }\n-\n-    public RuntimeInvisibleTypeAnnotations_attribute(int name_index, TypeAnnotation[] annotations) {\n-        super(name_index, annotations);\n-    }\n-\n-    public <R, P> R accept(Visitor<R, P> visitor, P p) {\n-        return visitor.visitRuntimeInvisibleTypeAnnotations(this, p);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RuntimeInvisibleTypeAnnotations_attribute.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.18 and 4.8.19.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public abstract class RuntimeParameterAnnotations_attribute extends Attribute {\n-    RuntimeParameterAnnotations_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, Annotation.InvalidAnnotation {\n-        super(name_index, length);\n-        int num_parameters = cr.readUnsignedByte();\n-        parameter_annotations = new Annotation[num_parameters][];\n-        for (int p = 0; p < parameter_annotations.length; p++) {\n-            int num_annotations = cr.readUnsignedShort();\n-            Annotation[] annotations = new Annotation[num_annotations];\n-            for (int i = 0; i < num_annotations; i++)\n-                annotations[i] = new Annotation(cr);\n-            parameter_annotations[p] = annotations;\n-        }\n-    }\n-\n-    protected RuntimeParameterAnnotations_attribute(int name_index, Annotation[][] parameter_annotations) {\n-        super(name_index, length(parameter_annotations));\n-        this.parameter_annotations = parameter_annotations;\n-    }\n-\n-    private static int length(Annotation[][] anno_arrays) {\n-        int n = 1;\n-        for (Annotation[] anno_array: anno_arrays) {\n-            n += 2;\n-            for (Annotation anno: anno_array)\n-                n += anno.length();\n-        }\n-        return n;\n-    }\n-\n-    public final Annotation[][] parameter_annotations;\n-}\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RuntimeParameterAnnotations_attribute.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JSR 308 specification, Section 3.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public abstract class RuntimeTypeAnnotations_attribute extends Attribute {\n-    protected RuntimeTypeAnnotations_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, Annotation.InvalidAnnotation {\n-        super(name_index, length);\n-        int num_annotations = cr.readUnsignedShort();\n-        annotations = new TypeAnnotation[num_annotations];\n-        for (int i = 0; i < annotations.length; i++)\n-            annotations[i] = new TypeAnnotation(cr);\n-    }\n-\n-    protected RuntimeTypeAnnotations_attribute(int name_index, TypeAnnotation[] annotations) {\n-        super(name_index, length(annotations));\n-        this.annotations = annotations;\n-    }\n-\n-    private static int length(TypeAnnotation[] annos) {\n-        int n = 2;\n-        for (TypeAnnotation anno: annos)\n-            n += anno.length();\n-        return n;\n-    }\n-\n-    public final TypeAnnotation[] annotations;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RuntimeTypeAnnotations_attribute.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.16.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class RuntimeVisibleAnnotations_attribute extends RuntimeAnnotations_attribute {\n-    RuntimeVisibleAnnotations_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, Annotation.InvalidAnnotation {\n-        super(cr, name_index, length);\n-    }\n-\n-    public RuntimeVisibleAnnotations_attribute(ConstantPool cp, Annotation[] annotations)\n-            throws ConstantPoolException {\n-        this(cp.getUTF8Index(Attribute.RuntimeVisibleAnnotations), annotations);\n-    }\n-\n-    public RuntimeVisibleAnnotations_attribute(int name_index, Annotation[] annotations) {\n-        super(name_index, annotations);\n-    }\n-\n-    public <R, P> R accept(Visitor<R, P> visitor, P p) {\n-        return visitor.visitRuntimeVisibleAnnotations(this, p);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RuntimeVisibleAnnotations_attribute.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.18.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class RuntimeVisibleParameterAnnotations_attribute extends RuntimeParameterAnnotations_attribute {\n-    RuntimeVisibleParameterAnnotations_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, Annotation.InvalidAnnotation {\n-        super(cr, name_index, length);\n-    }\n-\n-    public RuntimeVisibleParameterAnnotations_attribute(ConstantPool cp, Annotation[][] parameter_annotations)\n-            throws ConstantPoolException {\n-        this(cp.getUTF8Index(Attribute.RuntimeVisibleParameterAnnotations), parameter_annotations);\n-    }\n-\n-    public RuntimeVisibleParameterAnnotations_attribute(int name_index, Annotation[][] parameter_annotations) {\n-        super(name_index, parameter_annotations);\n-    }\n-\n-    public <R, P> R accept(Visitor<R, P> visitor, P p) {\n-        return visitor.visitRuntimeVisibleParameterAnnotations(this, p);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RuntimeVisibleParameterAnnotations_attribute.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JSR 308 specification, Section 3.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class RuntimeVisibleTypeAnnotations_attribute extends RuntimeTypeAnnotations_attribute {\n-    RuntimeVisibleTypeAnnotations_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, Annotation.InvalidAnnotation {\n-        super(cr, name_index, length);\n-    }\n-\n-    public RuntimeVisibleTypeAnnotations_attribute(ConstantPool cp, TypeAnnotation[] annotations)\n-            throws ConstantPoolException {\n-        this(cp.getUTF8Index(Attribute.RuntimeVisibleTypeAnnotations), annotations);\n-    }\n-\n-    public RuntimeVisibleTypeAnnotations_attribute(int name_index, TypeAnnotation[] annotations) {\n-        super(name_index, annotations);\n-    }\n-\n-    public <R, P> R accept(Visitor<R, P> visitor, P p) {\n-        return visitor.visitRuntimeVisibleTypeAnnotations(this, p);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/RuntimeVisibleTypeAnnotations_attribute.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,272 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import com.sun.tools.classfile.Type.*;\n-\n-\/**\n- * See JVMS 4.4.4.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Signature extends Descriptor {\n-\n-    public Signature(int index) {\n-        super(index);\n-    }\n-\n-    public Type getType(ConstantPool constant_pool) throws ConstantPoolException {\n-        if (type == null)\n-            type = parse(getValue(constant_pool));\n-        return type;\n-    }\n-\n-    @Override\n-    public int getParameterCount(ConstantPool constant_pool) throws ConstantPoolException {\n-        MethodType m = (MethodType) getType(constant_pool);\n-        return m.paramTypes.size();\n-    }\n-\n-    @Override\n-    public String getParameterTypes(ConstantPool constant_pool) throws ConstantPoolException {\n-        MethodType m = (MethodType) getType(constant_pool);\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"(\");\n-        String sep = \"\";\n-        for (Type paramType: m.paramTypes) {\n-            sb.append(sep);\n-            sb.append(paramType);\n-            sep = \", \";\n-        }\n-        sb.append(\")\");\n-        return sb.toString();\n-    }\n-\n-    @Override\n-    public String getReturnType(ConstantPool constant_pool) throws ConstantPoolException {\n-        MethodType m = (MethodType) getType(constant_pool);\n-        return m.returnType.toString();\n-    }\n-\n-    @Override\n-    public String getFieldType(ConstantPool constant_pool) throws ConstantPoolException {\n-        return getType(constant_pool).toString();\n-    }\n-\n-    private Type parse(String sig) {\n-        this.sig = sig;\n-        sigp = 0;\n-\n-        List<TypeParamType> typeParamTypes = null;\n-        if (sig.charAt(sigp) == '<')\n-            typeParamTypes = parseTypeParamTypes();\n-\n-        if (sig.charAt(sigp) == '(') {\n-            List<Type> paramTypes = parseTypeSignatures(')');\n-            Type returnType = parseTypeSignature();\n-            List<Type> throwsTypes = null;\n-            while (sigp < sig.length() && sig.charAt(sigp) == '^') {\n-                sigp++;\n-                if (throwsTypes == null)\n-                    throwsTypes = new ArrayList<>();\n-                throwsTypes.add(parseTypeSignature());\n-            }\n-            return new MethodType(typeParamTypes, paramTypes, returnType, throwsTypes);\n-        } else {\n-            Type t = parseTypeSignature();\n-            if (typeParamTypes == null && sigp == sig.length())\n-                return t;\n-            Type superclass = t;\n-            List<Type> superinterfaces = null;\n-            while (sigp < sig.length()) {\n-                if (superinterfaces == null)\n-                    superinterfaces = new ArrayList<>();\n-                superinterfaces.add(parseTypeSignature());\n-            }\n-            return new ClassSigType(typeParamTypes, superclass, superinterfaces);\n-\n-        }\n-    }\n-\n-    private Type parseTypeSignature() {\n-        switch (sig.charAt(sigp)) {\n-            case 'B':\n-                sigp++;\n-                return new SimpleType(\"byte\");\n-\n-            case 'C':\n-                sigp++;\n-                return new SimpleType(\"char\");\n-\n-            case 'D':\n-                sigp++;\n-                return new SimpleType(\"double\");\n-\n-            case 'F':\n-                sigp++;\n-                return new SimpleType(\"float\");\n-\n-            case 'I':\n-                sigp++;\n-                return new SimpleType(\"int\");\n-\n-            case 'J':\n-                sigp++;\n-                return new SimpleType(\"long\");\n-\n-            case 'L':\n-                return parseClassTypeSignature();\n-\n-            case 'S':\n-                sigp++;\n-                return new SimpleType(\"short\");\n-\n-            case 'T':\n-                return parseTypeVariableSignature();\n-\n-            case 'V':\n-                sigp++;\n-                return new SimpleType(\"void\");\n-\n-            case 'Z':\n-                sigp++;\n-                return new SimpleType(\"boolean\");\n-\n-            case '[':\n-                sigp++;\n-                return new ArrayType(parseTypeSignature());\n-\n-            case '*':\n-                sigp++;\n-                return new WildcardType();\n-\n-            case '+':\n-                sigp++;\n-                return new WildcardType(WildcardType.Kind.EXTENDS, parseTypeSignature());\n-\n-            case '-':\n-                sigp++;\n-                return new WildcardType(WildcardType.Kind.SUPER, parseTypeSignature());\n-\n-            default:\n-                throw new IllegalStateException(debugInfo());\n-        }\n-    }\n-\n-    private List<Type> parseTypeSignatures(char term) {\n-        sigp++;\n-        List<Type> types = new ArrayList<>();\n-        while (sig.charAt(sigp) != term)\n-            types.add(parseTypeSignature());\n-        sigp++;\n-        return types;\n-    }\n-\n-    private Type parseClassTypeSignature() {\n-        assert sig.charAt(sigp) == 'L';\n-        sigp++;\n-        return parseClassTypeSignatureRest();\n-    }\n-\n-    private Type parseClassTypeSignatureRest() {\n-        StringBuilder sb = new StringBuilder();\n-        List<Type> argTypes = null;\n-        ClassType t = null;\n-        char sigch ;\n-\n-        do {\n-            switch  (sigch = sig.charAt(sigp)) {\n-                case '<':\n-                    argTypes = parseTypeSignatures('>');\n-                    break;\n-\n-                case '.':\n-                case ';':\n-                    sigp++;\n-                    t = new ClassType(t, sb.toString(), argTypes);\n-                    sb.setLength(0);\n-                    argTypes = null;\n-                    break;\n-\n-                default:\n-                    sigp++;\n-                    sb.append(sigch);\n-                    break;\n-            }\n-        } while (sigch != ';');\n-\n-        return t;\n-    }\n-\n-    private List<TypeParamType> parseTypeParamTypes() {\n-        assert sig.charAt(sigp) == '<';\n-        sigp++;\n-        List<TypeParamType> types = new ArrayList<>();\n-        while (sig.charAt(sigp) != '>')\n-            types.add(parseTypeParamType());\n-        sigp++;\n-        return types;\n-    }\n-\n-    private TypeParamType parseTypeParamType() {\n-        int sep = sig.indexOf(\":\", sigp);\n-        String name = sig.substring(sigp, sep);\n-        Type classBound = null;\n-        List<Type> interfaceBounds = null;\n-        sigp = sep + 1;\n-        if (sig.charAt(sigp) != ':')\n-            classBound = parseTypeSignature();\n-        while (sig.charAt(sigp) == ':') {\n-            sigp++;\n-            if (interfaceBounds == null)\n-                interfaceBounds = new ArrayList<>();\n-            interfaceBounds.add(parseTypeSignature());\n-        }\n-        return new TypeParamType(name, classBound, interfaceBounds);\n-    }\n-\n-    private Type parseTypeVariableSignature() {\n-        sigp++;\n-        int sep = sig.indexOf(';', sigp);\n-        Type t = new SimpleType(sig.substring(sigp, sep));\n-        sigp = sep + 1;\n-        return t;\n-    }\n-\n-    private String debugInfo() {\n-        return sig.substring(0, sigp) + \"!\" + sig.charAt(sigp) + \"!\" + sig.substring(sigp+1);\n-    }\n-\n-    private String sig;\n-    private int sigp;\n-\n-    private Type type;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Signature.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.9.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Signature_attribute extends Attribute {\n-    Signature_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        signature_index = cr.readUnsignedShort();\n-    }\n-\n-    public Signature_attribute(ConstantPool constant_pool, int signature_index)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.Signature), signature_index);\n-    }\n-\n-    public Signature_attribute(int name_index, int signature_index) {\n-        super(name_index, 2);\n-        this.signature_index = signature_index;\n-    }\n-\n-    public String getSignature(ConstantPool constant_pool) throws ConstantPoolException {\n-        return constant_pool.getUTF8Value(signature_index);\n-    }\n-\n-    public Signature getParsedSignature() {\n-        return new Signature(signature_index);\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitSignature(this, data);\n-    }\n-\n-    public final int signature_index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Signature_attribute.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.DataInputStream;\n-import java.io.IOException;\n-\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-\n-\/**\n- * See JVMS, section 4.8.15.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SourceDebugExtension_attribute extends Attribute {\n-\n-    SourceDebugExtension_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        debug_extension = new byte[attribute_length];\n-        cr.readFully(debug_extension);\n-    }\n-\n-    public SourceDebugExtension_attribute(ConstantPool constant_pool, byte[] debug_extension)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.SourceDebugExtension), debug_extension);\n-    }\n-\n-    public SourceDebugExtension_attribute(int name_index, byte[] debug_extension) {\n-        super(name_index, debug_extension.length);\n-        this.debug_extension = debug_extension;\n-    }\n-\n-    public String getValue() {\n-        return new String(debug_extension, UTF_8);\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitSourceDebugExtension(this, data);\n-    }\n-\n-    public final byte[] debug_extension;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/SourceDebugExtension_attribute.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.10.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SourceFile_attribute extends Attribute {\n-    SourceFile_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        sourcefile_index = cr.readUnsignedShort();\n-    }\n-\n-    public SourceFile_attribute(ConstantPool constant_pool, int sourcefile_index)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.SourceFile), sourcefile_index);\n-    }\n-\n-    public SourceFile_attribute(int name_index, int sourcefile_index) {\n-        super(name_index, 2);\n-        this.sourcefile_index = sourcefile_index;\n-    }\n-\n-    public String getSourceFile(ConstantPool constant_pool) throws ConstantPoolException {\n-        return constant_pool.getUTF8Value(sourcefile_index);\n-    }\n-\n-    public <R, P> R accept(Visitor<R, P> visitor, P p) {\n-        return visitor.visitSourceFile(this, p);\n-    }\n-\n-    public final int sourcefile_index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/SourceFile_attribute.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SourceID_attribute extends Attribute {\n-\n-    SourceID_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-        sourceID_index = cr.readUnsignedShort();\n-    }\n-\n-    public SourceID_attribute(ConstantPool constant_pool, int sourceID_index)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.SourceID), sourceID_index);\n-    }\n-\n-    public SourceID_attribute(int name_index, int sourceID_index) {\n-        super(name_index, 2);\n-        this.sourceID_index = sourceID_index;\n-    }\n-\n-    String getSourceID(ConstantPool constant_pool) throws ConstantPoolException {\n-        return constant_pool.getUTF8Value(sourceID_index);\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitSourceID(this, data);\n-    }\n-\n-    public final int sourceID_index;\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/SourceID_attribute.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,380 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2009, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.4.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class StackMapTable_attribute extends Attribute {\n-    static class InvalidStackMap extends AttributeException {\n-        private static final long serialVersionUID = -5659038410855089780L;\n-        InvalidStackMap(String msg) {\n-            super(msg);\n-        }\n-    }\n-\n-    StackMapTable_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, InvalidStackMap {\n-        super(name_index, length);\n-        number_of_entries = cr.readUnsignedShort();\n-        entries = new stack_map_frame[number_of_entries];\n-        for (int i = 0; i < number_of_entries; i++)\n-            entries[i] = stack_map_frame.read(cr);\n-    }\n-\n-    public StackMapTable_attribute(ConstantPool constant_pool, stack_map_frame[] entries)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.StackMapTable), entries);\n-    }\n-\n-    public StackMapTable_attribute(int name_index, stack_map_frame[] entries) {\n-        super(name_index, length(entries));\n-        this.number_of_entries = entries.length;\n-        this.entries = entries;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitStackMapTable(this, data);\n-    }\n-\n-    static int length(stack_map_frame[] entries) {\n-        int n = 2;\n-        for (stack_map_frame entry: entries)\n-            n += entry.length();\n-        return n;\n-    }\n-\n-    public final int number_of_entries;\n-    public final stack_map_frame entries[];\n-\n-    public abstract static class stack_map_frame {\n-        static stack_map_frame read(ClassReader cr)\n-                throws IOException, InvalidStackMap {\n-            int frame_type = cr.readUnsignedByte();\n-            if (frame_type <= 63)\n-                return new same_frame(frame_type);\n-            else if (frame_type <= 127)\n-                return new same_locals_1_stack_item_frame(frame_type, cr);\n-            else if (frame_type <= 246)\n-                throw new Error(\"unknown frame_type \" + frame_type);\n-            else if (frame_type == 247)\n-                return new same_locals_1_stack_item_frame_extended(frame_type, cr);\n-            else if (frame_type <= 250)\n-                return new chop_frame(frame_type, cr);\n-            else if (frame_type == 251)\n-                return new same_frame_extended(frame_type, cr);\n-            else if (frame_type <= 254)\n-                return new append_frame(frame_type, cr);\n-            else\n-                return new full_frame(frame_type, cr);\n-        }\n-\n-        protected stack_map_frame(int frame_type) {\n-            this.frame_type = frame_type;\n-        }\n-\n-        public int length() {\n-            return 1;\n-        }\n-\n-        public abstract int getOffsetDelta();\n-\n-        public abstract <R,D> R accept(Visitor<R,D> visitor, D data);\n-\n-        public final int frame_type;\n-\n-        public static interface Visitor<R,P> {\n-            R visit_same_frame(same_frame frame, P p);\n-            R visit_same_locals_1_stack_item_frame(same_locals_1_stack_item_frame frame, P p);\n-            R visit_same_locals_1_stack_item_frame_extended(same_locals_1_stack_item_frame_extended frame, P p);\n-            R visit_chop_frame(chop_frame frame, P p);\n-            R visit_same_frame_extended(same_frame_extended frame, P p);\n-            R visit_append_frame(append_frame frame, P p);\n-            R visit_full_frame(full_frame frame, P p);\n-        }\n-    }\n-\n-    public static class same_frame extends stack_map_frame {\n-        same_frame(int frame_type) {\n-            super(frame_type);\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visit_same_frame(this, data);\n-        }\n-\n-        public int getOffsetDelta() {\n-            return frame_type;\n-        }\n-    }\n-\n-    public static class same_locals_1_stack_item_frame extends stack_map_frame {\n-        same_locals_1_stack_item_frame(int frame_type, ClassReader cr)\n-                throws IOException, InvalidStackMap {\n-            super(frame_type);\n-            stack = new verification_type_info[1];\n-            stack[0] = verification_type_info.read(cr);\n-        }\n-\n-        @Override\n-        public int length() {\n-            return super.length() + stack[0].length();\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visit_same_locals_1_stack_item_frame(this, data);\n-        }\n-\n-        public int getOffsetDelta() {\n-            return frame_type - 64;\n-        }\n-\n-        public final verification_type_info[] stack;\n-    }\n-\n-    public static class same_locals_1_stack_item_frame_extended extends stack_map_frame {\n-        same_locals_1_stack_item_frame_extended(int frame_type, ClassReader cr)\n-                throws IOException, InvalidStackMap {\n-            super(frame_type);\n-            offset_delta = cr.readUnsignedShort();\n-            stack = new verification_type_info[1];\n-            stack[0] = verification_type_info.read(cr);\n-        }\n-\n-        @Override\n-        public int length() {\n-            return super.length() + 2 + stack[0].length();\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visit_same_locals_1_stack_item_frame_extended(this, data);\n-        }\n-\n-        public int getOffsetDelta() {\n-            return offset_delta;\n-        }\n-\n-        public final int offset_delta;\n-        public final verification_type_info[] stack;\n-    }\n-\n-    public static class chop_frame extends stack_map_frame {\n-        chop_frame(int frame_type, ClassReader cr) throws IOException {\n-            super(frame_type);\n-            offset_delta = cr.readUnsignedShort();\n-        }\n-\n-        @Override\n-        public int length() {\n-            return super.length() + 2;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visit_chop_frame(this, data);\n-        }\n-\n-        public int getOffsetDelta() {\n-            return offset_delta;\n-        }\n-\n-        public final int offset_delta;\n-    }\n-\n-    public static class same_frame_extended extends stack_map_frame {\n-        same_frame_extended(int frame_type, ClassReader cr) throws IOException {\n-            super(frame_type);\n-            offset_delta = cr.readUnsignedShort();\n-        }\n-\n-        @Override\n-        public int length() {\n-            return super.length() + 2;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visit_same_frame_extended(this, data);\n-        }\n-\n-        public int getOffsetDelta() {\n-            return offset_delta;\n-        }\n-\n-        public final int offset_delta;\n-    }\n-\n-    public static class append_frame extends stack_map_frame {\n-        append_frame(int frame_type, ClassReader cr)\n-                throws IOException, InvalidStackMap {\n-            super(frame_type);\n-            offset_delta = cr.readUnsignedShort();\n-            locals = new verification_type_info[frame_type - 251];\n-            for (int i = 0; i < locals.length; i++)\n-                locals[i] = verification_type_info.read(cr);\n-        }\n-\n-        @Override\n-        public int length() {\n-            int n = super.length() + 2;\n-            for (verification_type_info local: locals)\n-                n += local.length();\n-            return n;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visit_append_frame(this, data);\n-        }\n-\n-        public int getOffsetDelta() {\n-            return offset_delta;\n-        }\n-\n-        public final int offset_delta;\n-        public final verification_type_info[] locals;\n-    }\n-\n-    public static class full_frame extends stack_map_frame {\n-        full_frame(int frame_type, ClassReader cr)\n-                throws IOException, InvalidStackMap {\n-            super(frame_type);\n-            offset_delta = cr.readUnsignedShort();\n-            number_of_locals = cr.readUnsignedShort();\n-            locals = new verification_type_info[number_of_locals];\n-            for (int i = 0; i < locals.length; i++)\n-                locals[i] = verification_type_info.read(cr);\n-            number_of_stack_items = cr.readUnsignedShort();\n-            stack = new verification_type_info[number_of_stack_items];\n-            for (int i = 0; i < stack.length; i++)\n-                stack[i] = verification_type_info.read(cr);\n-        }\n-\n-        @Override\n-        public int length() {\n-            int n = super.length() + 2;\n-            for (verification_type_info local: locals)\n-                n += local.length();\n-            n += 2;\n-            for (verification_type_info item: stack)\n-                n += item.length();\n-            return n;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visit_full_frame(this, data);\n-        }\n-\n-        public int getOffsetDelta() {\n-            return offset_delta;\n-        }\n-\n-        public final int offset_delta;\n-        public final int number_of_locals;\n-        public final verification_type_info[] locals;\n-        public final int number_of_stack_items;\n-        public final verification_type_info[] stack;\n-    }\n-\n-    public static class verification_type_info {\n-        public static final int ITEM_Top = 0;\n-        public static final int ITEM_Integer = 1;\n-        public static final int ITEM_Float = 2;\n-        public static final int ITEM_Long = 4;\n-        public static final int ITEM_Double = 3;\n-        public static final int ITEM_Null = 5;\n-        public static final int ITEM_UninitializedThis = 6;\n-        public static final int ITEM_Object = 7;\n-        public static final int ITEM_Uninitialized = 8;\n-\n-        static verification_type_info read(ClassReader cr)\n-                throws IOException, InvalidStackMap {\n-            int tag = cr.readUnsignedByte();\n-            switch (tag) {\n-            case ITEM_Top:\n-            case ITEM_Integer:\n-            case ITEM_Float:\n-            case ITEM_Long:\n-            case ITEM_Double:\n-            case ITEM_Null:\n-            case ITEM_UninitializedThis:\n-                return new verification_type_info(tag);\n-\n-            case ITEM_Object:\n-                return new Object_variable_info(cr);\n-\n-            case ITEM_Uninitialized:\n-                return new Uninitialized_variable_info(cr);\n-\n-            default:\n-                throw new InvalidStackMap(\"unrecognized verification_type_info tag\");\n-            }\n-        }\n-\n-        protected verification_type_info(int tag) {\n-            this.tag = tag;\n-        }\n-\n-        public int length() {\n-            return 1;\n-        }\n-\n-        public final int tag;\n-    }\n-\n-    public static class Object_variable_info extends verification_type_info {\n-        Object_variable_info(ClassReader cr) throws IOException {\n-            super(ITEM_Object);\n-            cpool_index = cr.readUnsignedShort();\n-        }\n-\n-        @Override\n-        public int length() {\n-            return super.length() + 2;\n-        }\n-\n-        public final int cpool_index;\n-    }\n-\n-    public static class Uninitialized_variable_info extends verification_type_info {\n-        Uninitialized_variable_info(ClassReader cr) throws IOException {\n-            super(ITEM_Uninitialized);\n-            offset = cr.readUnsignedShort();\n-        }\n-\n-        @Override\n-        public int length() {\n-            return super.length() + 2;\n-        }\n-\n-        public final int offset;\n-\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/StackMapTable_attribute.java","additions":0,"deletions":380,"binary":false,"changes":380,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class StackMap_attribute extends Attribute {\n-    StackMap_attribute(ClassReader cr, int name_index, int length)\n-            throws IOException, StackMapTable_attribute.InvalidStackMap {\n-        super(name_index, length);\n-        number_of_entries = cr.readUnsignedShort();\n-        entries = new stack_map_frame[number_of_entries];\n-        for (int i = 0; i < number_of_entries; i++)\n-            entries[i] = new stack_map_frame(cr);\n-    }\n-\n-    public StackMap_attribute(ConstantPool constant_pool, stack_map_frame[] entries)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.StackMap), entries);\n-    }\n-\n-    public StackMap_attribute(int name_index, stack_map_frame[] entries) {\n-        super(name_index, StackMapTable_attribute.length(entries));\n-        this.number_of_entries = entries.length;\n-        this.entries = entries;\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitStackMap(this, data);\n-    }\n-\n-    public final int number_of_entries;\n-    public final stack_map_frame entries[];\n-\n-    public static class stack_map_frame extends StackMapTable_attribute.full_frame {\n-        stack_map_frame(ClassReader cr)\n-                throws IOException, StackMapTable_attribute.InvalidStackMap {\n-            super(255, cr);\n-        }\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/StackMap_attribute.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-\n-\/**\n- * See JVMS, section 4.8.8.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Synthetic_attribute extends Attribute {\n-    Synthetic_attribute(ClassReader cr, int name_index, int length) throws IOException {\n-        super(name_index, length);\n-    }\n-\n-    public Synthetic_attribute(ConstantPool constant_pool)\n-            throws ConstantPoolException {\n-        this(constant_pool.getUTF8Index(Attribute.Synthetic));\n-    }\n-\n-    public Synthetic_attribute(int name_index) {\n-        super(name_index, 0);\n-    }\n-\n-    public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-        return visitor.visitSynthetic(this, data);\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Synthetic_attribute.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,378 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-\/*\n- *  Family of classes used to represent the parsed form of a {@link Descriptor}\n- *  or {@link Signature}.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public abstract class Type {\n-    protected Type() { }\n-\n-    public boolean isObject() {\n-        return false;\n-    }\n-\n-    public abstract <R,D> R accept(Visitor<R,D> visitor, D data);\n-\n-    protected static void append(StringBuilder sb, String prefix, List<? extends Type> types, String suffix) {\n-        sb.append(prefix);\n-        String sep = \"\";\n-        for (Type t: types) {\n-            sb.append(sep);\n-            sb.append(t);\n-            sep = \", \";\n-        }\n-        sb.append(suffix);\n-    }\n-\n-    protected static void appendIfNotEmpty(StringBuilder sb, String prefix, List<? extends Type> types, String suffix) {\n-        if (types != null && types.size() > 0)\n-            append(sb, prefix, types, suffix);\n-    }\n-\n-    public interface Visitor<R,P> {\n-        R visitSimpleType(SimpleType type, P p);\n-        R visitArrayType(ArrayType type, P p);\n-        R visitMethodType(MethodType type, P p);\n-        R visitClassSigType(ClassSigType type, P p);\n-        R visitClassType(ClassType type, P p);\n-        R visitTypeParamType(TypeParamType type, P p);\n-        R visitWildcardType(WildcardType type, P p);\n-    }\n-\n-    \/**\n-     * Represents a type signature with a simple name. The name may be that of a\n-     * primitive type, such \"{@code int}, {@code float}, etc\n-     * or that of a type argument, such as {@code T}, {@code K}, {@code V}, etc.\n-     *\n-     * See:\n-     * JVMS 4.3.2\n-     *      BaseType:\n-     *          {@code B}, {@code C}, {@code D}, {@code F}, {@code I},\n-     *          {@code J}, {@code S}, {@code Z};\n-     *      VoidDescriptor:\n-     *          {@code V};\n-     * JVMS 4.3.4\n-     *      TypeVariableSignature:\n-     *          {@code T} Identifier {@code ;}\n-     *\/\n-    public static class SimpleType extends Type {\n-        public SimpleType(String name) {\n-            this.name = name;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitSimpleType(this, data);\n-        }\n-\n-        public boolean isPrimitiveType() {\n-            return primitiveTypes.contains(name);\n-        }\n-        \/\/ where\n-        private static final Set<String> primitiveTypes = new HashSet<>(Arrays.asList(\n-            \"boolean\", \"byte\", \"char\", \"double\", \"float\", \"int\", \"long\", \"short\", \"void\"));\n-\n-        @Override\n-        public String toString() {\n-            return name;\n-        }\n-\n-        public final String name;\n-    }\n-\n-    \/**\n-     * Represents an array type signature.\n-     *\n-     * See:\n-     * JVMS 4.3.4\n-     *      ArrayTypeSignature:\n-     *          {@code [} TypeSignature {@code ]}\n-     *\/\n-    public static class ArrayType extends Type {\n-        public ArrayType(Type elemType) {\n-            this.elemType = elemType;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitArrayType(this, data);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return elemType + \"[]\";\n-        }\n-\n-        public final Type elemType;\n-    }\n-\n-    \/**\n-     * Represents a method type signature.\n-     *\n-     * See;\n-     * JVMS 4.3.4\n-     *      MethodTypeSignature:\n-     *          FormalTypeParameters_opt {@code (} TypeSignature* {@code)} ReturnType\n-     *              ThrowsSignature*\n-     *\/\n-    public static class MethodType extends Type {\n-        public MethodType(List<? extends Type> paramTypes, Type resultType) {\n-            this(null, paramTypes, resultType, null);\n-        }\n-\n-        public MethodType(List<? extends TypeParamType> typeParamTypes,\n-                List<? extends Type> paramTypes,\n-                Type returnType,\n-                List<? extends Type> throwsTypes) {\n-            this.typeParamTypes = typeParamTypes;\n-            this.paramTypes = paramTypes;\n-            this.returnType = returnType;\n-            this.throwsTypes = throwsTypes;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitMethodType(this, data);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            appendIfNotEmpty(sb, \"<\", typeParamTypes, \"> \");\n-            sb.append(returnType);\n-            append(sb, \" (\", paramTypes, \")\");\n-            appendIfNotEmpty(sb, \" throws \", throwsTypes, \"\");\n-            return sb.toString();\n-        }\n-\n-        public final List<? extends TypeParamType> typeParamTypes;\n-        public final List<? extends Type> paramTypes;\n-        public final Type returnType;\n-        public final List<? extends Type> throwsTypes;\n-    }\n-\n-    \/**\n-     * Represents a class signature. These describe the signature of\n-     * a class that has type arguments.\n-     *\n-     * See:\n-     * JVMS 4.3.4\n-     *      ClassSignature:\n-     *          FormalTypeParameters_opt SuperclassSignature SuperinterfaceSignature*\n-     *\/\n-    public static class ClassSigType extends Type {\n-        public ClassSigType(List<TypeParamType> typeParamTypes, Type superclassType,\n-                List<Type> superinterfaceTypes) {\n-            this.typeParamTypes = typeParamTypes;\n-            this.superclassType = superclassType;\n-            this.superinterfaceTypes = superinterfaceTypes;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitClassSigType(this, data);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            appendIfNotEmpty(sb, \"<\", typeParamTypes, \">\");\n-            if (superclassType != null) {\n-                sb.append(\" extends \");\n-                sb.append(superclassType);\n-            }\n-            appendIfNotEmpty(sb, \" implements \", superinterfaceTypes, \"\");\n-            return sb.toString();\n-        }\n-\n-        public final List<TypeParamType> typeParamTypes;\n-        public final Type superclassType;\n-        public final List<Type> superinterfaceTypes;\n-    }\n-\n-    \/**\n-     * Represents a class type signature. This is used to represent a\n-     * reference to a class, such as in a field, parameter, return type, etc.\n-     *\n-     * See:\n-     * JVMS 4.3.4\n-     *      ClassTypeSignature:\n-     *          {@code L} PackageSpecifier_opt SimpleClassTypeSignature\n-     *                  ClassTypeSignatureSuffix* {@code ;}\n-     *      PackageSpecifier:\n-     *          Identifier {@code \/} PackageSpecifier*\n-     *      SimpleClassTypeSignature:\n-     *          Identifier TypeArguments_opt }\n-     *      ClassTypeSignatureSuffix:\n-     *          {@code .} SimpleClassTypeSignature\n-     *\/\n-    public static class ClassType extends Type {\n-        public ClassType(ClassType outerType, String name, List<Type> typeArgs) {\n-            this.outerType = outerType;\n-            this.name = name;\n-            this.typeArgs = typeArgs;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitClassType(this, data);\n-        }\n-\n-        public String getBinaryName() {\n-            if (outerType == null)\n-                return name;\n-            else\n-                return (outerType.getBinaryName() + \"$\" + name);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            if (outerType != null) {\n-                sb.append(outerType);\n-                sb.append(\".\");\n-            }\n-            sb.append(name);\n-            appendIfNotEmpty(sb, \"<\", typeArgs, \">\");\n-            return sb.toString();\n-        }\n-\n-        @Override\n-        public boolean isObject() {\n-            return (outerType == null)\n-                    && name.equals(\"java\/lang\/Object\")\n-                    && (typeArgs == null || typeArgs.isEmpty());\n-        }\n-\n-        public final ClassType outerType;\n-        public final String name;\n-        public final List<Type> typeArgs;\n-    }\n-\n-    \/**\n-     * Represents a FormalTypeParameter. These are used to declare the type\n-     * parameters for generic classes and methods.\n-     *\n-     * See:\n-     * JVMS 4.3.4\n-     *     FormalTypeParameters:\n-     *          {@code <} FormalTypeParameter+ {@code >}\n-     *     FormalTypeParameter:\n-     *          Identifier ClassBound InterfaceBound*\n-     *     ClassBound:\n-     *          {@code :} FieldTypeSignature_opt\n-     *     InterfaceBound:\n-     *          {@code :} FieldTypeSignature\n-     *\/\n-    public static class TypeParamType extends Type {\n-        public TypeParamType(String name, Type classBound, List<Type> interfaceBounds) {\n-            this.name = name;\n-            this.classBound = classBound;\n-            this.interfaceBounds = interfaceBounds;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitTypeParamType(this, data);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            sb.append(name);\n-            String sep = \" extends \";\n-            if (classBound != null) {\n-                sb.append(sep);\n-                sb.append(classBound);\n-                sep = \" & \";\n-            }\n-            if (interfaceBounds != null) {\n-                for (Type bound: interfaceBounds) {\n-                    sb.append(sep);\n-                    sb.append(bound);\n-                    sep = \" & \";\n-                }\n-            }\n-            return sb.toString();\n-        }\n-\n-        public final String name;\n-        public final Type classBound;\n-        public final List<Type> interfaceBounds;\n-    }\n-\n-    \/**\n-     * Represents a wildcard type argument.  A type argument that is not a\n-     * wildcard type argument will be represented by a ClassType, ArrayType, etc.\n-     *\n-     * See:\n-     * JVMS 4.3.4\n-     *      TypeArgument:\n-     *          WildcardIndicator_opt FieldTypeSignature\n-     *          {@code *}\n-     *      WildcardIndicator:\n-     *          {@code +}\n-     *          {@code -}\n-     *\/\n-    public static class WildcardType extends Type {\n-        public enum Kind { UNBOUNDED, EXTENDS, SUPER }\n-\n-        public WildcardType() {\n-            this(Kind.UNBOUNDED, null);\n-        }\n-        public WildcardType(Kind kind, Type boundType) {\n-            this.kind = kind;\n-            this.boundType = boundType;\n-        }\n-\n-        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n-            return visitor.visitWildcardType(this, data);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            switch (kind) {\n-                case UNBOUNDED:\n-                    return \"?\";\n-                case EXTENDS:\n-                    return \"? extends \" + boundType;\n-                case SUPER:\n-                    return \"? super \" + boundType;\n-                default:\n-                    throw new AssertionError();\n-            }\n-        }\n-\n-        public final Kind kind;\n-        public final Type boundType;\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/Type.java","additions":0,"deletions":378,"binary":false,"changes":378,"status":"deleted"},{"patch":"@@ -1,654 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.classfile;\n-\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import com.sun.tools.classfile.TypeAnnotation.Position.TypePathEntry;\n-\n-\/**\n- * See JSR 308 specification, Section 3.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class TypeAnnotation {\n-    TypeAnnotation(ClassReader cr) throws IOException, Annotation.InvalidAnnotation {\n-        constant_pool = cr.getConstantPool();\n-        position = read_position(cr);\n-        annotation = new Annotation(cr);\n-    }\n-\n-    public TypeAnnotation(ConstantPool constant_pool,\n-            Annotation annotation, Position position) {\n-        this.constant_pool = constant_pool;\n-        this.position = position;\n-        this.annotation = annotation;\n-    }\n-\n-    public int length() {\n-        int n = annotation.length();\n-        n += position_length(position);\n-        return n;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        try {\n-            return \"@\" + constant_pool.getUTF8Value(annotation.type_index).substring(1) +\n-                    \" pos: \" + position.toString();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-            return e.toString();\n-        }\n-    }\n-\n-    public final ConstantPool constant_pool;\n-    public final Position position;\n-    public final Annotation annotation;\n-\n-    private static Position read_position(ClassReader cr) throws IOException, Annotation.InvalidAnnotation {\n-        \/\/ Copied from ClassReader\n-        int tag = cr.readUnsignedByte(); \/\/ TargetType tag is a byte\n-        if (!TargetType.isValidTargetTypeValue(tag))\n-            throw new Annotation.InvalidAnnotation(\"TypeAnnotation: Invalid type annotation target type value: \" + String.format(\"0x%02X\", tag));\n-\n-        TargetType type = TargetType.fromTargetTypeValue(tag);\n-\n-        Position position = new Position();\n-        position.type = type;\n-\n-        switch (type) {\n-        \/\/ instanceof\n-        case INSTANCEOF:\n-        \/\/ new expression\n-        case NEW:\n-        \/\/ constructor\/method reference receiver\n-        case CONSTRUCTOR_REFERENCE:\n-        case METHOD_REFERENCE:\n-            position.offset = cr.readUnsignedShort();\n-            break;\n-        \/\/ local variable\n-        case LOCAL_VARIABLE:\n-        \/\/ resource variable\n-        case RESOURCE_VARIABLE:\n-            int table_length = cr.readUnsignedShort();\n-            position.lvarOffset = new int[table_length];\n-            position.lvarLength = new int[table_length];\n-            position.lvarIndex = new int[table_length];\n-            for (int i = 0; i < table_length; ++i) {\n-                position.lvarOffset[i] = cr.readUnsignedShort();\n-                position.lvarLength[i] = cr.readUnsignedShort();\n-                position.lvarIndex[i] = cr.readUnsignedShort();\n-            }\n-            break;\n-        \/\/ exception parameter\n-        case EXCEPTION_PARAMETER:\n-            position.exception_index = cr.readUnsignedShort();\n-            break;\n-        \/\/ method receiver\n-        case METHOD_RECEIVER:\n-            \/\/ Do nothing\n-            break;\n-        \/\/ type parameter\n-        case CLASS_TYPE_PARAMETER:\n-        case METHOD_TYPE_PARAMETER:\n-            position.parameter_index = cr.readUnsignedByte();\n-            break;\n-        \/\/ type parameter bound\n-        case CLASS_TYPE_PARAMETER_BOUND:\n-        case METHOD_TYPE_PARAMETER_BOUND:\n-            position.parameter_index = cr.readUnsignedByte();\n-            position.bound_index = cr.readUnsignedByte();\n-            break;\n-        \/\/ class extends or implements clause\n-        case CLASS_EXTENDS:\n-            position.type_index = cr.readUnsignedShort();\n-            break;\n-        \/\/ throws\n-        case THROWS:\n-            position.type_index = cr.readUnsignedShort();\n-            break;\n-        \/\/ method parameter\n-        case METHOD_FORMAL_PARAMETER:\n-            position.parameter_index = cr.readUnsignedByte();\n-            break;\n-        \/\/ type cast\n-        case CAST:\n-        \/\/ method\/constructor\/reference type argument\n-        case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n-        case METHOD_INVOCATION_TYPE_ARGUMENT:\n-        case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n-        case METHOD_REFERENCE_TYPE_ARGUMENT:\n-            position.offset = cr.readUnsignedShort();\n-            position.type_index = cr.readUnsignedByte();\n-            break;\n-        \/\/ We don't need to worry about these\n-        case METHOD_RETURN:\n-        case FIELD:\n-            break;\n-        case UNKNOWN:\n-            throw new AssertionError(\"TypeAnnotation: UNKNOWN target type should never occur!\");\n-        default:\n-            throw new AssertionError(\"TypeAnnotation: Unknown target type: \" + type);\n-        }\n-\n-        { \/\/ Write type path\n-            int len = cr.readUnsignedByte();\n-            List<Integer> loc = new ArrayList<>(len);\n-            for (int i = 0; i < len * TypePathEntry.bytesPerEntry; ++i)\n-                loc.add(cr.readUnsignedByte());\n-            position.location = Position.getTypePathFromBinary(loc);\n-        }\n-        return position;\n-    }\n-\n-    private static int position_length(Position pos) {\n-        int n = 0;\n-        n += 1; \/\/ TargetType tag is a byte\n-        switch (pos.type) {\n-        \/\/ instanceof\n-        case INSTANCEOF:\n-        \/\/ new expression\n-        case NEW:\n-        \/\/ constructor\/method reference receiver\n-        case CONSTRUCTOR_REFERENCE:\n-        case METHOD_REFERENCE:\n-            n += 2; \/\/ offset\n-            break;\n-        \/\/ local variable\n-        case LOCAL_VARIABLE:\n-        \/\/ resource variable\n-        case RESOURCE_VARIABLE:\n-            n += 2; \/\/ table_length;\n-            int table_length = pos.lvarOffset.length;\n-            n += 2 * table_length; \/\/ offset\n-            n += 2 * table_length; \/\/ length\n-            n += 2 * table_length; \/\/ index\n-            break;\n-        \/\/ exception parameter\n-        case EXCEPTION_PARAMETER:\n-            n += 2; \/\/ exception_index\n-            break;\n-        \/\/ method receiver\n-        case METHOD_RECEIVER:\n-            \/\/ Do nothing\n-            break;\n-        \/\/ type parameter\n-        case CLASS_TYPE_PARAMETER:\n-        case METHOD_TYPE_PARAMETER:\n-            n += 1; \/\/ parameter_index\n-            break;\n-        \/\/ type parameter bound\n-        case CLASS_TYPE_PARAMETER_BOUND:\n-        case METHOD_TYPE_PARAMETER_BOUND:\n-            n += 1; \/\/ parameter_index\n-            n += 1; \/\/ bound_index\n-            break;\n-        \/\/ class extends or implements clause\n-        case CLASS_EXTENDS:\n-            n += 2; \/\/ type_index\n-            break;\n-        \/\/ throws\n-        case THROWS:\n-            n += 2; \/\/ type_index\n-            break;\n-        \/\/ method parameter\n-        case METHOD_FORMAL_PARAMETER:\n-            n += 1; \/\/ parameter_index\n-            break;\n-        \/\/ type cast\n-        case CAST:\n-        \/\/ method\/constructor\/reference type argument\n-        case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n-        case METHOD_INVOCATION_TYPE_ARGUMENT:\n-        case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n-        case METHOD_REFERENCE_TYPE_ARGUMENT:\n-            n += 2; \/\/ offset\n-            n += 1; \/\/ type index\n-            break;\n-        \/\/ We don't need to worry about these\n-        case METHOD_RETURN:\n-        case FIELD:\n-            break;\n-        case UNKNOWN:\n-            throw new AssertionError(\"TypeAnnotation: UNKNOWN target type should never occur!\");\n-        default:\n-            throw new AssertionError(\"TypeAnnotation: Unknown target type: \" + pos.type);\n-        }\n-\n-        {\n-            n += 1; \/\/ length\n-            n += TypePathEntry.bytesPerEntry * pos.location.size(); \/\/ bytes for actual array\n-        }\n-\n-        return n;\n-    }\n-\n-    \/\/ Code duplicated from com.sun.tools.javac.code.TypeAnnotationPosition\n-    public static class Position {\n-        public enum TypePathEntryKind {\n-            ARRAY(0),\n-            INNER_TYPE(1),\n-            WILDCARD(2),\n-            TYPE_ARGUMENT(3);\n-\n-            public final int tag;\n-\n-            private TypePathEntryKind(int tag) {\n-                this.tag = tag;\n-            }\n-        }\n-\n-        public static class TypePathEntry {\n-            \/** The fixed number of bytes per TypePathEntry. *\/\n-            public static final int bytesPerEntry = 2;\n-\n-            public final TypePathEntryKind tag;\n-            public final int arg;\n-\n-            public static final TypePathEntry ARRAY = new TypePathEntry(TypePathEntryKind.ARRAY);\n-            public static final TypePathEntry INNER_TYPE = new TypePathEntry(TypePathEntryKind.INNER_TYPE);\n-            public static final TypePathEntry WILDCARD = new TypePathEntry(TypePathEntryKind.WILDCARD);\n-\n-            private TypePathEntry(TypePathEntryKind tag) {\n-                if (!(tag == TypePathEntryKind.ARRAY ||\n-                        tag == TypePathEntryKind.INNER_TYPE ||\n-                        tag == TypePathEntryKind.WILDCARD)) {\n-                    throw new AssertionError(\"Invalid TypePathEntryKind: \" + tag);\n-                }\n-                this.tag = tag;\n-                this.arg = 0;\n-            }\n-\n-            public TypePathEntry(TypePathEntryKind tag, int arg) {\n-                if (tag != TypePathEntryKind.TYPE_ARGUMENT) {\n-                    throw new AssertionError(\"Invalid TypePathEntryKind: \" + tag);\n-                }\n-                this.tag = tag;\n-                this.arg = arg;\n-            }\n-\n-            public static TypePathEntry fromBinary(int tag, int arg) {\n-                if (arg != 0 && tag != TypePathEntryKind.TYPE_ARGUMENT.tag) {\n-                    throw new AssertionError(\"Invalid TypePathEntry tag\/arg: \" + tag + \"\/\" + arg);\n-                }\n-                switch (tag) {\n-                case 0:\n-                    return ARRAY;\n-                case 1:\n-                    return INNER_TYPE;\n-                case 2:\n-                    return WILDCARD;\n-                case 3:\n-                    return new TypePathEntry(TypePathEntryKind.TYPE_ARGUMENT, arg);\n-                default:\n-                    throw new AssertionError(\"Invalid TypePathEntryKind tag: \" + tag);\n-                }\n-            }\n-\n-            @Override\n-            public String toString() {\n-                return tag.toString() +\n-                        (tag == TypePathEntryKind.TYPE_ARGUMENT ? (\"(\" + arg + \")\") : \"\");\n-            }\n-\n-            @Override\n-            public boolean equals(Object other) {\n-                if (! (other instanceof TypePathEntry)) {\n-                    return false;\n-                }\n-                TypePathEntry tpe = (TypePathEntry) other;\n-                return this.tag == tpe.tag && this.arg == tpe.arg;\n-            }\n-\n-            @Override\n-            public int hashCode() {\n-                return this.tag.hashCode() * 17 + this.arg;\n-            }\n-        }\n-\n-        public TargetType type = TargetType.UNKNOWN;\n-\n-        \/\/ For generic\/array types.\n-        \/\/ TODO: or should we use null? No one will use this object.\n-        public List<TypePathEntry> location = new ArrayList<>(0);\n-\n-        \/\/ Tree position.\n-        public int pos = -1;\n-\n-        \/\/ For typecasts, type tests, new (and locals, as start_pc).\n-        public boolean isValidOffset = false;\n-        public int offset = -1;\n-\n-        \/\/ For locals. arrays same length\n-        public int[] lvarOffset = null;\n-        public int[] lvarLength = null;\n-        public int[] lvarIndex = null;\n-\n-        \/\/ For type parameter bound\n-        public int bound_index = Integer.MIN_VALUE;\n-\n-        \/\/ For type parameter and method parameter\n-        public int parameter_index = Integer.MIN_VALUE;\n-\n-        \/\/ For class extends, implements, and throws clauses\n-        public int type_index = Integer.MIN_VALUE;\n-\n-        \/\/ For exception parameters, index into exception table\n-        public int exception_index = Integer.MIN_VALUE;\n-\n-        public Position() {}\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder sb = new StringBuilder();\n-            sb.append('[');\n-            sb.append(type);\n-\n-            switch (type) {\n-            \/\/ instanceof\n-            case INSTANCEOF:\n-            \/\/ new expression\n-            case NEW:\n-            \/\/ constructor\/method reference receiver\n-            case CONSTRUCTOR_REFERENCE:\n-            case METHOD_REFERENCE:\n-                sb.append(\", offset = \");\n-                sb.append(offset);\n-                break;\n-            \/\/ local variable\n-            case LOCAL_VARIABLE:\n-            \/\/ resource variable\n-            case RESOURCE_VARIABLE:\n-                if (lvarOffset == null) {\n-                    sb.append(\", lvarOffset is null!\");\n-                    break;\n-                }\n-                sb.append(\", {\");\n-                for (int i = 0; i < lvarOffset.length; ++i) {\n-                    if (i != 0) sb.append(\"; \");\n-                    sb.append(\"start_pc = \");\n-                    sb.append(lvarOffset[i]);\n-                    sb.append(\", length = \");\n-                    sb.append(lvarLength[i]);\n-                    sb.append(\", index = \");\n-                    sb.append(lvarIndex[i]);\n-                }\n-                sb.append(\"}\");\n-                break;\n-            \/\/ method receiver\n-            case METHOD_RECEIVER:\n-                \/\/ Do nothing\n-                break;\n-            \/\/ type parameter\n-            case CLASS_TYPE_PARAMETER:\n-            case METHOD_TYPE_PARAMETER:\n-                sb.append(\", param_index = \");\n-                sb.append(parameter_index);\n-                break;\n-            \/\/ type parameter bound\n-            case CLASS_TYPE_PARAMETER_BOUND:\n-            case METHOD_TYPE_PARAMETER_BOUND:\n-                sb.append(\", param_index = \");\n-                sb.append(parameter_index);\n-                sb.append(\", bound_index = \");\n-                sb.append(bound_index);\n-                break;\n-            \/\/ class extends or implements clause\n-            case CLASS_EXTENDS:\n-                sb.append(\", type_index = \");\n-                sb.append(type_index);\n-                break;\n-            \/\/ throws\n-            case THROWS:\n-                sb.append(\", type_index = \");\n-                sb.append(type_index);\n-                break;\n-            \/\/ exception parameter\n-            case EXCEPTION_PARAMETER:\n-                sb.append(\", exception_index = \");\n-                sb.append(exception_index);\n-                break;\n-            \/\/ method parameter\n-            case METHOD_FORMAL_PARAMETER:\n-                sb.append(\", param_index = \");\n-                sb.append(parameter_index);\n-                break;\n-            \/\/ type cast\n-            case CAST:\n-            \/\/ method\/constructor\/reference type argument\n-            case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n-            case METHOD_INVOCATION_TYPE_ARGUMENT:\n-            case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n-            case METHOD_REFERENCE_TYPE_ARGUMENT:\n-                sb.append(\", offset = \");\n-                sb.append(offset);\n-                sb.append(\", type_index = \");\n-                sb.append(type_index);\n-                break;\n-            \/\/ We don't need to worry about these\n-            case METHOD_RETURN:\n-            case FIELD:\n-                break;\n-            case UNKNOWN:\n-                sb.append(\", position UNKNOWN!\");\n-                break;\n-            default:\n-                throw new AssertionError(\"Unknown target type: \" + type);\n-            }\n-\n-            \/\/ Append location data for generics\/arrays.\n-            if (!location.isEmpty()) {\n-                sb.append(\", location = (\");\n-                sb.append(location);\n-                sb.append(\")\");\n-            }\n-\n-            sb.append(\", pos = \");\n-            sb.append(pos);\n-\n-            sb.append(']');\n-            return sb.toString();\n-        }\n-\n-        \/**\n-         * Indicates whether the target tree of the annotation has been optimized\n-         * away from classfile or not.\n-         * @return true if the target has not been optimized away\n-         *\/\n-        public boolean emitToClassfile() {\n-            return !type.isLocal() || isValidOffset;\n-        }\n-\n-        \/**\n-         * Decode the binary representation for a type path and set\n-         * the {@code location} field.\n-         *\n-         * @param list The bytecode representation of the type path.\n-         *\/\n-        public static List<TypePathEntry> getTypePathFromBinary(List<Integer> list) {\n-            List<TypePathEntry> loc = new ArrayList<>(list.size() \/ TypePathEntry.bytesPerEntry);\n-            int idx = 0;\n-            while (idx < list.size()) {\n-                if (idx + 1 == list.size()) {\n-                    throw new AssertionError(\"Could not decode type path: \" + list);\n-                }\n-                loc.add(TypePathEntry.fromBinary(list.get(idx), list.get(idx + 1)));\n-                idx += 2;\n-            }\n-            return loc;\n-        }\n-\n-        public static List<Integer> getBinaryFromTypePath(List<TypePathEntry> locs) {\n-            List<Integer> loc = new ArrayList<>(locs.size() * TypePathEntry.bytesPerEntry);\n-            for (TypePathEntry tpe : locs) {\n-                loc.add(tpe.tag.tag);\n-                loc.add(tpe.arg);\n-            }\n-            return loc;\n-        }\n-    }\n-\n-    \/\/ Code duplicated from com.sun.tools.javac.code.TargetType\n-    \/\/ The IsLocal flag could be removed here.\n-    public enum TargetType {\n-        \/** For annotations on a class type parameter declaration. *\/\n-        CLASS_TYPE_PARAMETER(0x00),\n-\n-        \/** For annotations on a method type parameter declaration. *\/\n-        METHOD_TYPE_PARAMETER(0x01),\n-\n-        \/** For annotations on the type of an \"extends\" or \"implements\" clause. *\/\n-        CLASS_EXTENDS(0x10),\n-\n-        \/** For annotations on a bound of a type parameter of a class. *\/\n-        CLASS_TYPE_PARAMETER_BOUND(0x11),\n-\n-        \/** For annotations on a bound of a type parameter of a method. *\/\n-        METHOD_TYPE_PARAMETER_BOUND(0x12),\n-\n-        \/** For annotations on a field. *\/\n-        FIELD(0x13),\n-\n-        \/** For annotations on a method return type. *\/\n-        METHOD_RETURN(0x14),\n-\n-        \/** For annotations on the method receiver. *\/\n-        METHOD_RECEIVER(0x15),\n-\n-        \/** For annotations on a method parameter. *\/\n-        METHOD_FORMAL_PARAMETER(0x16),\n-\n-        \/** For annotations on a throws clause in a method declaration. *\/\n-        THROWS(0x17),\n-\n-        \/** For annotations on a local variable. *\/\n-        LOCAL_VARIABLE(0x40, true),\n-\n-        \/** For annotations on a resource variable. *\/\n-        RESOURCE_VARIABLE(0x41, true),\n-\n-        \/** For annotations on an exception parameter. *\/\n-        EXCEPTION_PARAMETER(0x42, true),\n-\n-        \/** For annotations on a type test. *\/\n-        INSTANCEOF(0x43, true),\n-\n-        \/** For annotations on an object creation expression. *\/\n-        NEW(0x44, true),\n-\n-        \/** For annotations on a constructor reference receiver. *\/\n-        CONSTRUCTOR_REFERENCE(0x45, true),\n-\n-        \/** For annotations on a method reference receiver. *\/\n-        METHOD_REFERENCE(0x46, true),\n-\n-        \/** For annotations on a typecast. *\/\n-        CAST(0x47, true),\n-\n-        \/** For annotations on a type argument of an object creation expression. *\/\n-        CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT(0x48, true),\n-\n-        \/** For annotations on a type argument of a method call. *\/\n-        METHOD_INVOCATION_TYPE_ARGUMENT(0x49, true),\n-\n-        \/** For annotations on a type argument of a constructor reference. *\/\n-        CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT(0x4A, true),\n-\n-        \/** For annotations on a type argument of a method reference. *\/\n-        METHOD_REFERENCE_TYPE_ARGUMENT(0x4B, true),\n-\n-        \/** For annotations with an unknown target. *\/\n-        UNKNOWN(0xFF);\n-\n-        private static final int MAXIMUM_TARGET_TYPE_VALUE = 0x4B;\n-\n-        private final int targetTypeValue;\n-        private final boolean isLocal;\n-\n-        private TargetType(int targetTypeValue) {\n-            this(targetTypeValue, false);\n-        }\n-\n-        private TargetType(int targetTypeValue, boolean isLocal) {\n-            if (targetTypeValue < 0\n-                    || targetTypeValue > 255)\n-                    throw new AssertionError(\"Attribute type value needs to be an unsigned byte: \" + String.format(\"0x%02X\", targetTypeValue));\n-            this.targetTypeValue = targetTypeValue;\n-            this.isLocal = isLocal;\n-        }\n-\n-        \/**\n-         * Returns whether or not this TargetType represents an annotation whose\n-         * target is exclusively a tree in a method body\n-         *\n-         * Note: wildcard bound targets could target a local tree and a class\n-         * member declaration signature tree\n-         *\/\n-        public boolean isLocal() {\n-            return isLocal;\n-        }\n-\n-        public int targetTypeValue() {\n-            return this.targetTypeValue;\n-        }\n-\n-        private static final TargetType[] targets;\n-\n-        static {\n-            targets = new TargetType[MAXIMUM_TARGET_TYPE_VALUE + 1];\n-            TargetType[] alltargets = values();\n-            for (TargetType target : alltargets) {\n-                if (target.targetTypeValue != UNKNOWN.targetTypeValue)\n-                    targets[target.targetTypeValue] = target;\n-            }\n-            for (int i = 0; i <= MAXIMUM_TARGET_TYPE_VALUE; ++i) {\n-                if (targets[i] == null)\n-                    targets[i] = UNKNOWN;\n-            }\n-        }\n-\n-        public static boolean isValidTargetTypeValue(int tag) {\n-            if (tag == UNKNOWN.targetTypeValue)\n-                return true;\n-            return (tag >= 0 && tag < targets.length);\n-        }\n-\n-        public static TargetType fromTargetTypeValue(int tag) {\n-            if (tag == UNKNOWN.targetTypeValue)\n-                return UNKNOWN;\n-\n-            if (tag < 0 || tag >= targets.length)\n-                throw new AssertionError(\"Unknown TargetType: \" + tag);\n-            return targets[tag];\n-        }\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/TypeAnnotation.java","additions":0,"deletions":654,"binary":false,"changes":654,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n-    A minimalist library to read and write class files into objects closely\n-    based on the corresponding definitions in\n-    <cite>The Java Virtual Machine Specification<\/cite> (JVMS).\n-\n-    <p><b>This is NOT part of any supported API.\n-    If you write code that depends on this, you do so at your own risk.\n-    This code and its internal interfaces are subject to change or\n-    deletion without notice.<\/b>\n-*\/\n-package com.sun.tools.classfile;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/classfile\/package-info.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,2 +73,0 @@\n-    exports com.sun.tools.classfile to jdk.jlink;\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/module-info.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n- *      jdk.jdeps\/com.sun.tools.classfile\n@@ -45,1 +44,0 @@\n-import com.sun.tools.classfile.ClassFile;\n","filename":"test\/langtools\/tools\/javac\/generics\/wildcards\/separate_compilation\/WildcardBoundsNotReadFromClassFileTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- *          jdk.jdeps\/com.sun.tools.classfile:+open\n@@ -79,2 +78,1 @@\n-              .options(\"--add-exports\", \"jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\",\n-                       \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED\",\n+              .options(\"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED\",\n@@ -105,2 +103,1 @@\n-                      \"jdk.compiler\/com.sun.tools.javac.util\",\n-                      \"jdk.jdeps\/com.sun.tools.classfile\")\n+                      \"jdk.compiler\/com.sun.tools.javac.util\")\n","filename":"test\/langtools\/tools\/javac\/platform\/CanHandleClassFilesTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- *          jdk.jdeps\/com.sun.tools.classfile\n@@ -110,2 +109,1 @@\n-                                              \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\",\n-                                              \"--add-exports\", \"jdk.jdeps\/com.sun.tools.classfile=ALL-UNNAMED\"),\n+                                              \"--add-exports\", \"jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED\"),\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}