{"files":[{"patch":"@@ -34,3 +34,36 @@\n- * <p>{@code Array} permits widening conversions to occur during a get or set\n- * operation, but throws an {@code IllegalArgumentException} if a narrowing\n- * conversion would occur.\n+ * <p id=\"value-conversion\">\n+ * {@code Array} declares {@link #get get} and {@link #set set} access\n+ * operations with overloads for all primitive types.  They convert their\n+ * retrieved and new values depending on whether the array's component type\n+ * is primitive or reference:\n+ * <ul>\n+ * <li>If the array component type is a primitive type P:\n+ *     <ul>\n+ *     <li>{@link #get get} wraps the retrieved value in an instance of the\n+ *         {@linkplain java.lang##wrapperClass wrapper class} of P.\n+ *     <li>The get overload for primitive type O converts the retrieved value\n+ *         from P to O via an identity conversion (JLS {@jls 5.1.1}) or a\n+ *         widening primitive conversion (JLS {@jls 5.1.2}), or throws an {@code\n+ *         IllegalArgumentException} if no such conversion exists.\n+ *     <li>{@link #set set} requires the new value to be an instance of a\n+ *         wrapper class, or throws an {@code IllegalArgumentException}. The\n+ *         new value is unwrapped (JLS {@jls 5.1.8}) to a value of the wrapper\n+ *         class's corresponding primitive type I, and then converted from I to\n+ *         P via an identity conversion or a widening primitive conversion, or\n+ *         throws an {@code IllegalArgumentException} if no such conversion\n+ *         exists.\n+ *     <li>The set overload for primitive type I converts the new value from\n+ *         I to P via an identity conversion or a widening primitive conversion,\n+ *         or throws an {@code IllegalArgumentException} if no such conversion\n+ *         exists.\n+ *     <\/ul>\n+ * <li>If the array component type is a reference type R:\n+ *     <ul>\n+ *     <li>{@code get} performs no conversion.\n+ *     <li>The primitive get overloads throw an {@code IllegalArgumentException}.\n+ *     <li>{@code set} converts the new value to R as if through a narrowing\n+ *         reference conversion (JLS {@jls 5.1.6.3}), but throws an {@code\n+ *         IllegalArgumentException} instead of a {@code ClassCastException}.\n+ *     <li>The primitive set overloads throw an {@code IllegalArgumentException}.\n+ *     <\/ul>\n+ * <\/ul>\n@@ -300,5 +333,2 @@\n-     * object to the specified new value.  If the array has a primitive\n-     * component type, the new value is first converted to a value of a\n-     * primitive type by an unboxing conversion.  The possibly unboxed new\n-     * value is converted to the array's component type by an identity or\n-     * widening conversion and stored into the array.\n+     * object to the specified new value after {@linkplain ##value-conversion\n+     * possible conversions}.\n@@ -323,3 +353,1 @@\n-     * object to the specified {@code boolean} value. This method never performs\n-     * a boxing conversion.\n-     *\n+     * object to the specified {@code boolean} value.\n@@ -345,3 +373,1 @@\n-     * object to the specified {@code byte} value. This method never performs\n-     * a boxing conversion.\n-     *\n+     * object to the specified {@code byte} value.\n@@ -367,3 +393,1 @@\n-     * object to the specified {@code char} value. This method never performs\n-     * a boxing conversion.\n-     *\n+     * object to the specified {@code char} value.\n@@ -389,3 +413,1 @@\n-     * object to the specified {@code short} value. This method never performs\n-     * a boxing conversion.\n-     *\n+     * object to the specified {@code short} value.\n@@ -411,3 +433,1 @@\n-     * object to the specified {@code int} value. This method never performs\n-     * a boxing conversion.\n-     *\n+     * object to the specified {@code int} value.\n@@ -433,3 +453,1 @@\n-     * object to the specified {@code long} value. This method never performs\n-     * a boxing conversion.\n-     *\n+     * object to the specified {@code long} value.\n@@ -455,3 +473,1 @@\n-     * object to the specified {@code float} value. This method never performs\n-     * a boxing conversion.\n-     *\n+     * object to the specified {@code float} value.\n@@ -477,3 +493,1 @@\n-     * object to the specified {@code double} value. This method never performs\n-     * a boxing conversion.\n-     *\n+     * object to the specified {@code double} value.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Array.java","additions":46,"deletions":32,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -51,4 +51,36 @@\n- *\n- * <p>A {@code Field} permits widening primitive conversions to occur during a\n- * primitive get or set access operation, but throws an {@code IllegalArgumentException}\n- * if a narrowing primitive conversion would occur.\n+ * <p id=\"value-conversion\">\n+ * A {@code Field} declares {@link #get get} and {@link #set set} access\n+ * operations with overloads for all primitive types.  They convert the\n+ * retrieved and new values depending on whether the underlying field is of a\n+ * primitive or a reference type:\n+ * <ul>\n+ * <li>If the underlying field is of a primitive type P:\n+ *     <ul>\n+ *     <li>{@link #get get} wraps the retrieved value in an instance of the\n+ *         {@linkplain java.lang##wrapperClass wrapper class} of P.\n+ *     <li>The get overload for primitive type O converts the retrieved value\n+ *         from P to O via an identity conversion (JLS {@jls 5.1.1}) or a\n+ *         widening primitive conversion (JLS {@jls 5.1.2}), or throws an {@code\n+ *         IllegalArgumentException} if no such conversion exists.\n+ *     <li>{@link #set set} requires the new value to be an instance of a\n+ *         wrapper class, or throws an {@code IllegalArgumentException}. The\n+ *         new value is unwrapped (JLS {@jls 5.1.8}) to a value of the wrapper\n+ *         class's corresponding primitive type I, and then converted from I to\n+ *         P via an identity conversion or a widening primitive conversion, or\n+ *         throws an {@code IllegalArgumentException} if no such conversion\n+ *         exists.\n+ *     <li>The set overload for primitive type I converts the new value from\n+ *         I to P via an identity conversion or a widening primitive conversion,\n+ *         or throws an {@code IllegalArgumentException} if no such conversion\n+ *         exists.\n+ *     <\/ul>\n+ * <li>If the underlying field is of a reference type R:\n+ *     <ul>\n+ *     <li>{@code get} performs no conversion.\n+ *     <li>The primitive get overloads throw an {@code IllegalArgumentException}.\n+ *     <li>{@code set} converts the new value to R as if through a narrowing\n+ *         reference conversion (JLS {@jls 5.1.6.3}), but throws an {@code\n+ *         IllegalArgumentException} instead of a {@code ClassCastException}.\n+ *     <li>The primitive set overloads throw an {@code IllegalArgumentException}.\n+ *     <\/ul>\n+ * <\/ul>\n@@ -787,9 +819,2 @@\n-     * <p>If the underlying field is of a primitive type, an unwrapping\n-     * conversion is attempted to convert the new value to a value of\n-     * a primitive type.  If this attempt fails, the method throws an\n-     * {@code IllegalArgumentException}.\n-     *\n-     * <p>If, after possible unwrapping, the new value cannot be\n-     * converted to the type of the underlying field by an identity or\n-     * widening conversion, the method throws an\n-     * {@code IllegalArgumentException}.\n+     * <p>The new value is {@linkplain ##value-conversion converted to be\n+     * compatible} with the type of the underlying field.\n@@ -800,1 +825,1 @@\n-     * <p>The field is set to the possibly unwrapped and widened new value.\n+     * <p>The field is set to the possibly converted new value.\n@@ -841,2 +866,1 @@\n-     * and {@code zObj.booleanValue() == z}. This method never performs a boxing\n-     * conversion.\n+     * and {@code zObj.booleanValue() == z}.\n@@ -880,2 +904,1 @@\n-     * {@code bObj.byteValue() == b}. This method never performs a boxing\n-     * conversion.\n+     * {@code bObj.byteValue() == b}.\n@@ -919,2 +942,1 @@\n-     * and {@code cObj.charValue() == c}. This method never performs a boxing\n-     * conversion.\n+     * and {@code cObj.charValue() == c}.\n@@ -958,2 +980,1 @@\n-     * {@code sObj.shortValue() == s}. This method never performs a boxing\n-     * conversion.\n+     * {@code sObj.shortValue() == s}.\n@@ -997,2 +1018,1 @@\n-     * and {@code iObj.intValue() == i}. This method never performs a boxing\n-     * conversion.\n+     * and {@code iObj.intValue() == i}.\n@@ -1036,2 +1056,1 @@\n-     * {@code lObj.longValue() == l}. This method never performs a boxing\n-     * conversion.\n+     * {@code lObj.longValue() == l}.\n@@ -1075,2 +1094,1 @@\n-     * {@code fObj.floatValue() == f}. This method never performs a boxing\n-     * conversion.\n+     * {@code fObj.floatValue() == f}.\n@@ -1114,2 +1132,1 @@\n-     * {@code dObj.doubleValue() == d}. This method never performs a boxing\n-     * conversion.\n+     * {@code dObj.doubleValue() == d}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":47,"deletions":30,"binary":false,"changes":77,"status":"modified"}]}