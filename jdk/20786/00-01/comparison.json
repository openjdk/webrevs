{"files":[{"patch":"@@ -30,0 +30,2 @@\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n@@ -40,0 +42,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -43,1 +46,24 @@\n-        if (args.length == 1 && args[0].equals(\"Run\")) {\n+       ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+           \"-Xbootclasspath\/a:.\",\n+           \"-Xbatch\", \"-XX:-UseOnStackReplacement\",\n+           \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+WhiteBoxAPI\",\n+           \"-XX:Tier3InvocationThreshold=200\", \"-XX:Tier4InvocationThreshold=5000\",\n+           Launcher.class.getName());\n+       OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+       System.out.println(\"debug output\");\n+       System.out.println(output.getOutput());\n+       System.out.println(\"debug output end\");\n+       output.shouldHaveExitValue(0);\n+       output.shouldNotContain(\"failed to inline: virtual call\");\n+       Pattern pattern = Pattern.compile(\"Child1::m.*  inline \");\n+       Matcher matcher = pattern.matcher(output.getOutput());\n+       int matchCnt = 0;\n+       while (matcher.find()) {\n+         matchCnt++;\n+       }\n+       Asserts.assertEquals(matchCnt, 2);  \/\/ inline Child1::m() twice\n+    }\n+\n+    static class Launcher {\n+        public static void main(String[] args) throws Exception {\n+            addCompilerDirectives();\n@@ -53,1 +79,1 @@\n-            Parent c = new Child2();\n+            Parent c = new TypeProfileFinalMethod.Child2();\n@@ -59,18 +85,32 @@\n-        } else {\n-            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n-                \"-Xbatch\", \"-XX:-UseOnStackReplacement\",\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:CompilerDirectivesFile=\"+System.getProperty(\"test.src\", \".\") + File.separator + \"cha_control.txt\",\n-                \"-XX:Tier3InvocationThreshold=200\", \"-XX:Tier4InvocationThreshold=5000\",\n-                \"compiler.cha.TypeProfileFinalMethod\", \"Run\");\n-            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n-            System.out.println(\"debug output\");\n-            System.out.println(output.getOutput());\n-            System.out.println(\"debug output end\");\n-            output.shouldHaveExitValue(0);\n-            output.shouldNotContain(\"failed to inline: virtual call\");\n-            Pattern pattern = Pattern.compile(\"Child1::m.*  inline \");\n-            Matcher matcher = pattern.matcher(output.getOutput());\n-            int matchCnt = 0;\n-            while (matcher.find()) {\n-              matchCnt++;\n+        }\n+\n+        static void addCompilerDirectives() {\n+            WhiteBox WB = WhiteBox.getWhiteBox();\n+            \/\/ do not inline getInstance() for test1() and test2()\n+            String directive = \"[{ match: [\\\"\" + Launcher.class.getName() + \"::test1\\\"],\" +\n+                \"inline:[\\\"-\" + Launcher.class.getName()+\"::getInstance()\\\"] }]\";\n+            WB.addCompilerDirective(directive);\n+\n+            directive = \"[{ match: [\\\"\" + Launcher.class.getName() + \"::test2\\\"],\" +\n+                \"inline:[\\\"-\" + Launcher.class.getName()+\"::getInstance()\\\"] }]\";\n+            WB.addCompilerDirective(directive);\n+\n+            \/\/ do not inline test1() for test2() in c1 compilation\n+            directive = \"[{ match: [\\\"\" + Launcher.class.getName() + \"::test2\\\"],\" +\n+                \"c1: { inline:[\\\"-\" + Launcher.class.getName()+\"::test1()\\\"] } }]\";\n+            WB.addCompilerDirective(directive);\n+\n+            \/\/ print inline tree for checking\n+            directive = \"[{ match: [\\\"\" + Launcher.class.getName() + \"::test2\\\"],\" +\n+                \"c2: { PrintInlining: true } }]\";\n+            WB.addCompilerDirective(directive);\n+        }\n+\n+        static int test1(int i) {\n+            int ret = 0;\n+            Parent ix = getInstance();\n+            if (i<200) {\n+                return ix.m();\n+            }\n+            for (int j = 0; j < 50; j++) {\n+                ret += ix.m();     \/\/ the callsite we are interesting\n@@ -78,1 +118,1 @@\n-            Asserts.assertEquals(matchCnt, 2);  \/\/ inline Child1::m() twice\n+            return ret;\n@@ -80,1 +120,0 @@\n-    }\n@@ -82,5 +121,2 @@\n-    static int test1(int i) {\n-        int ret = 0;\n-        Parent ix = getInstance();\n-        if (i<200) {\n-            return ix.m();\n+        static int test2(int i) {\n+            return test1(i);\n@@ -88,2 +124,3 @@\n-        for (int j = 0; j < 50; j++) {\n-            ret += ix.m();     \/\/ the callsite we are interesting\n+\n+        static Parent getInstance() {\n+            return new TypeProfileFinalMethod.Child1();\n@@ -91,1 +128,0 @@\n-        return ret;\n@@ -94,2 +130,2 @@\n-    static int test2(int i) {\n-        return test1(i);\n+    static abstract class Parent {\n+        abstract public int m();\n@@ -98,2 +134,4 @@\n-    static Parent getInstance() {\n-        return new Child1();\n+    final static class Child1 extends Parent {\n+        public int m() {\n+            return 1;\n+        }\n@@ -101,5 +139,0 @@\n-}\n-\n-abstract class Parent {\n-    abstract public int m();\n-}\n@@ -107,3 +140,4 @@\n-final class Child1 extends Parent {\n-    public int m() {\n-        return 1;\n+    final static class Child2 extends Parent {\n+        public int m() {\n+            return 2;\n+        }\n@@ -113,5 +147,1 @@\n-final class Child2 extends Parent {\n-    public int m() {\n-        return 2;\n-    }\n-}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/TypeProfileFinalMethod.java","additions":77,"deletions":47,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-[\n-   { match: [\"compiler.cha.TypeProfileFinalMethod::main\"],\n-     Exclude: true,\n-   },\n-   { match: [\"compiler.cha.TypeProfileFinalMethod::test1\"],\n-     c1: {\n-       inline: [\n-         \"-compiler.cha.TypeProfileFinalMethod::getInstance\",\n-         \/\/ \"-compiler.cha.Child1::m\",\n-       ],\n-     },\n-     c2: {\n-       inline: [\"-compiler.cha.TypeProfileFinalMethod::getInstance\"],\n-     },\n-   },\n-   { match: [\"compiler.cha.TypeProfileFinalMethod::test2\"],\n-     c1: {\n-       inline: [\n-         \"-compiler.cha.TypeProfileFinalMethod::getInstance\",\n-         \"-compiler.cha.TypeProfileFinalMethod::test1\",\n-       ],\n-     },\n-     c2: {\n-       inline: [\n-         \"-compiler.cha.TypeProfileFinalMethod::getInstance\",\n-       ],\n-       PrintInlining: true,\n-     },\n-   },\n-]\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/cha_control.txt","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"}]}