{"files":[{"patch":"@@ -81,1 +81,1 @@\n-      if (!builder->is_in_buffer_space(ptr)) {\n+      if (ptr != nullptr && !builder->is_in_buffer_space(ptr)) {\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -46,2 +47,6 @@\n-void FinalImageRecipes::record_recipes_impl() {\n-  assert(CDSConfig::is_dumping_preimage_static_archive(), \"must be\");\n+void FinalImageRecipes::record_all_classes() {\n+  _all_klasses = ArchiveUtils::archive_array(ArchiveBuilder::current()->klasses());\n+  ArchivePtrMarker::mark_pointer(&_all_klasses);\n+}\n+\n+void FinalImageRecipes::record_recipes_for_constantpool() {\n@@ -49,1 +54,0 @@\n-  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n@@ -51,2 +55,6 @@\n-  \/\/ Record the indys that have been resolved in the training run. These indys will be\n-  \/\/ resolved during the final image assembly.\n+  \/\/ The recipes are recorded regardless of CDSConfig::is_dumping_{invokedynamic,dynamic_proxies,reflection_data}().\n+  \/\/ If some of these options are not enabled, the corresponding recipes will be\n+  \/\/ ignored during the final image assembly.\n+\n+  GrowableArray<Array<int>*> tmp_cp_recipes;\n+  GrowableArray<int> tmp_cp_flags;\n@@ -54,3 +62,1 @@\n-  GrowableArray<InstanceKlass*> tmp_indy_klasses;\n-  GrowableArray<Array<int>*> tmp_indy_cp_indices;\n-  int total_indys_to_resolve = 0;\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n@@ -58,0 +64,3 @@\n+    GrowableArray<int> cp_indices;\n+    int flags = 0;\n+\n@@ -61,1 +70,25 @@\n-      GrowableArray<int> indices;\n+      ConstantPool* cp = ik->constants();\n+      ConstantPoolCache* cp_cache = cp->cache();\n+\n+      for (int cp_index = 1; cp_index < cp->length(); cp_index++) { \/\/ Index 0 is unused\n+        if (cp->tag_at(cp_index).value() == JVM_CONSTANT_Class) {\n+          Klass* k = cp->resolved_klass_at(cp_index);\n+          if (k->is_instance_klass()) {\n+            cp_indices.append(cp_index);\n+            flags |= HAS_CLASS;\n+          }\n+        }\n+      }\n+\n+      if (cp_cache != nullptr) {\n+        Array<ResolvedFieldEntry>* field_entries = cp_cache->resolved_field_entries();\n+        if (field_entries != nullptr) {\n+          for (int i = 0; i < field_entries->length(); i++) {\n+            ResolvedFieldEntry* rfe = field_entries->adr_at(i);\n+            if (rfe->is_resolved(Bytecodes::_getfield) ||\n+                rfe->is_resolved(Bytecodes::_putfield)) {\n+              cp_indices.append(rfe->constant_pool_index());\n+              flags |= HAS_FIELD_AND_METHOD;\n+            }\n+          }\n+        }\n@@ -63,5 +96,19 @@\n-      if (ik->constants()->cache() != nullptr) {\n-        Array<ResolvedIndyEntry>* tmp_indy_entries = ik->constants()->cache()->resolved_indy_entries();\n-        if (tmp_indy_entries != nullptr) {\n-          for (int i = 0; i < tmp_indy_entries->length(); i++) {\n-            ResolvedIndyEntry* rie = tmp_indy_entries->adr_at(i);\n+        Array<ResolvedMethodEntry>* method_entries = cp_cache->resolved_method_entries();\n+        if (method_entries != nullptr) {\n+          for (int i = 0; i < method_entries->length(); i++) {\n+            ResolvedMethodEntry* rme = method_entries->adr_at(i);\n+            if (rme->is_resolved(Bytecodes::_invokevirtual) ||\n+                rme->is_resolved(Bytecodes::_invokespecial) ||\n+                rme->is_resolved(Bytecodes::_invokeinterface) ||\n+                rme->is_resolved(Bytecodes::_invokestatic) ||\n+                rme->is_resolved(Bytecodes::_invokehandle)) {\n+              cp_indices.append(rme->constant_pool_index());\n+              flags |= HAS_FIELD_AND_METHOD;\n+            }\n+          }\n+        }\n+\n+        Array<ResolvedIndyEntry>* indy_entries = cp_cache->resolved_indy_entries();\n+        if (indy_entries != nullptr) {\n+          for (int i = 0; i < indy_entries->length(); i++) {\n+            ResolvedIndyEntry* rie = indy_entries->adr_at(i);\n@@ -70,1 +117,2 @@\n-              indices.append(cp_index);\n+              cp_indices.append(cp_index);\n+              flags |= HAS_INDY;\n@@ -75,0 +123,1 @@\n+    }\n@@ -76,5 +125,4 @@\n-      if (indices.length() > 0) {\n-        tmp_indy_klasses.append(ArchiveBuilder::current()->get_buffered_addr(ik));\n-        tmp_indy_cp_indices.append(ArchiveUtils::archive_array(&indices));\n-        total_indys_to_resolve += indices.length();\n-      }\n+    if (cp_indices.length() > 0) {\n+      tmp_cp_recipes.append(ArchiveUtils::archive_array(&cp_indices));\n+    } else {\n+      tmp_cp_recipes.append(nullptr);\n@@ -82,0 +130,1 @@\n+    tmp_cp_flags.append(flags);\n@@ -84,2 +133,6 @@\n-  _all_klasses = ArchiveUtils::archive_array(klasses);\n-  ArchivePtrMarker::mark_pointer(&_all_klasses);\n+  _cp_recipes = ArchiveUtils::archive_array(&tmp_cp_recipes);\n+  ArchivePtrMarker::mark_pointer(&_cp_recipes);\n+\n+  _cp_flags = ArchiveUtils::archive_array(&tmp_cp_flags);\n+  ArchivePtrMarker::mark_pointer(&_cp_flags);\n+}\n@@ -87,4 +140,2 @@\n-  assert(tmp_indy_klasses.length() == tmp_indy_cp_indices.length(), \"must be\");\n-  if (tmp_indy_klasses.length() > 0) {\n-    _indy_klasses = ArchiveUtils::archive_array(&tmp_indy_klasses);\n-    _indy_cp_indices = ArchiveUtils::archive_array(&tmp_indy_cp_indices);\n+void FinalImageRecipes::apply_recipes_for_constantpool(JavaThread* current) {\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n@@ -92,2 +143,23 @@\n-    ArchivePtrMarker::mark_pointer(&_indy_klasses);\n-    ArchivePtrMarker::mark_pointer(&_indy_cp_indices);\n+  for (int i = 0; i < _all_klasses->length(); i++) {\n+    Array<int>* cp_indices = _cp_recipes->at(i);\n+    int flags = _cp_flags->at(i);\n+    if (cp_indices != nullptr) {\n+      InstanceKlass* ik = InstanceKlass::cast(_all_klasses->at(i));\n+      if (ik->is_loaded()) {\n+        ResourceMark rm(current);\n+        ConstantPool* cp = ik->constants();\n+        GrowableArray<bool> preresolve_list(cp->length(), cp->length(), false);\n+        for (int j = 0; j < cp_indices->length(); j++) {\n+          preresolve_list.at_put(cp_indices->at(j), true);\n+        }\n+        if ((flags & HAS_CLASS) != 0) {\n+          AOTConstantPoolResolver::preresolve_class_cp_entries(current, ik, &preresolve_list);\n+        }\n+        if ((flags & HAS_FIELD_AND_METHOD) != 0) {\n+          AOTConstantPoolResolver::preresolve_field_and_method_cp_entries(current, ik, &preresolve_list);\n+        }\n+        if ((flags & HAS_INDY) != 0) {\n+          AOTConstantPoolResolver::preresolve_indy_cp_entries(current, ik, &preresolve_list);\n+        }\n+      }\n+    }\n@@ -95,1 +167,0 @@\n-  log_info(cds)(\"%d indies in %d classes will be resolved in final CDS image\", total_indys_to_resolve, tmp_indy_klasses.length());\n@@ -121,18 +192,0 @@\n-void FinalImageRecipes::apply_recipes_for_invokedynamic(TRAPS) {\n-  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n-\n-  if (CDSConfig::is_dumping_invokedynamic() && _indy_klasses != nullptr) {\n-    assert(_indy_cp_indices != nullptr, \"must be\");\n-    for (int i = 0; i < _indy_klasses->length(); i++) {\n-      InstanceKlass* ik = _indy_klasses->at(i);\n-      ConstantPool* cp = ik->constants();\n-      Array<int>* cp_indices = _indy_cp_indices->at(i);\n-      GrowableArray<bool> preresolve_list(cp->length(), cp->length(), false);\n-      for (int j = 0; j < cp_indices->length(); j++) {\n-        preresolve_list.at_put(cp_indices->at(j), true);\n-      }\n-      AOTConstantPoolResolver::preresolve_indy_cp_entries(THREAD, ik, &preresolve_list);\n-    }\n-  }\n-}\n-\n@@ -140,0 +193,1 @@\n+  assert(CDSConfig::is_dumping_preimage_static_archive(), \"must be\");\n@@ -141,1 +195,2 @@\n-  _final_image_recipes->record_recipes_impl();\n+  _final_image_recipes->record_all_classes();\n+  _final_image_recipes->record_recipes_for_constantpool();\n@@ -162,1 +217,1 @@\n-  apply_recipes_for_invokedynamic(CHECK);\n+  apply_recipes_for_constantpool(THREAD);\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.cpp","additions":104,"deletions":49,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -45,0 +45,4 @@\n+  static constexpr int HAS_CLASS            = 0x1;\n+  static constexpr int HAS_FIELD_AND_METHOD = 0x2;\n+  static constexpr int HAS_INDY             = 0x4;\n+\n@@ -49,4 +53,4 @@\n-  \/\/ The classes who have resolved at least one indy CP entry during the training run.\n-  \/\/ _indy_cp_indices[i] is a list of all resolved CP entries for _indy_klasses[i].\n-  Array<InstanceKlass*>* _indy_klasses;\n-  Array<Array<int>*>*    _indy_cp_indices;\n+  \/\/ For each klass k _all_klasses->at(i), _cp_recipes->at(i) lists all the {klass,field,method,indy}\n+  \/\/ cp indices that were resolved for k during the training run.\n+  Array<Array<int>*>* _cp_recipes;\n+  Array<int>* _cp_flags;\n@@ -54,1 +58,1 @@\n-  FinalImageRecipes() : _indy_klasses(nullptr), _indy_cp_indices(nullptr) {}\n+  FinalImageRecipes() : _all_klasses(nullptr), _cp_recipes(nullptr), _cp_flags(nullptr) {}\n@@ -59,1 +63,2 @@\n-  void record_recipes_impl();\n+  void record_all_classes();\n+  void record_recipes_for_constantpool();\n@@ -64,1 +69,1 @@\n-  void apply_recipes_for_invokedynamic(TRAPS);\n+  void apply_recipes_for_constantpool(JavaThread* current);\n","filename":"src\/hotspot\/share\/cds\/finalImageRecipes.hpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+Mutex*   FinalImageRecipes_lock       = nullptr;\n@@ -301,0 +302,1 @@\n+  MUTEX_DEFN(FinalImageRecipes_lock          , PaddedMutex  , nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+extern Mutex*   FinalImageRecipes_lock;          \/\/ Protecting the tables used by FinalImageRecipes.\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}