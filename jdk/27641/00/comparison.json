{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,3 @@\n-    private int perpendiculardfddf(final double[] pts, final int off) {\n+    private int perpendiculardfddf(final double[] pts, final int off,\n+                                   final double A, final double B)\n+    {\n@@ -158,1 +160,1 @@\n-        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, 0.0d, 1.0d);\n+        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, A, B);\n@@ -174,1 +176,3 @@\n-    int rootsOfROCMinusW(final double[] roots, final int off, final double w2, final double err) {\n+    int rootsOfROCMinusW(final double[] roots, final int off, final double w2,\n+                         final double A, final double B)\n+    {\n@@ -179,1 +183,2 @@\n-        final int end = off + perpendiculardfddf(roots, off);\n+        final int end = off + perpendiculardfddf(roots, off, A, B);\n+        Helpers.isort(roots, off, end);\n@@ -182,1 +187,3 @@\n-        double t0 = 0.0d, ft0 = ROCsq(t0) - w2;\n+        double t0 = 0.0d;\n+        double ft0 = eliminateInf(ROCsq(t0) - w2);\n+        double t1, ft1;\n@@ -185,1 +192,2 @@\n-            double t1 = roots[i], ft1 = ROCsq(t1) - w2;\n+            t1 = roots[i];\n+            ft1 = eliminateInf(ROCsq(t1) - w2);\n@@ -191,1 +199,1 @@\n-                roots[ret++] = falsePositionROCsqMinusX(t0, t1, w2, err);\n+                roots[ret++] = falsePositionROCsqMinusX(t0, t1, ft0, ft1, w2, A); \/\/ A = err\n@@ -196,1 +204,0 @@\n-\n@@ -200,3 +207,6 @@\n-    private static double eliminateInf(final double x) {\n-        return (x == Double.POSITIVE_INFINITY ? Double.MAX_VALUE :\n-               (x == Double.NEGATIVE_INFINITY ? Double.MIN_VALUE : x));\n+    private final static double MAX_ROC_SQ = 1e20;\n+\n+    private static double eliminateInf(final double x2) {\n+        \/\/ limit the value of x to avoid numerical problems (smaller step):\n+        \/\/ must handle NaN and +Infinity:\n+        return (x2 <= MAX_ROC_SQ) ? x2 : MAX_ROC_SQ;\n@@ -213,0 +223,1 @@\n+                                            final double ft0, final double ft1,\n@@ -217,2 +228,2 @@\n-        double t = t1, ft = eliminateInf(ROCsq(t) - w2);\n-        double s = t0, fs = eliminateInf(ROCsq(s) - w2);\n+        double s = t0, fs = eliminateInf(ft0);\n+        double t = t1, ft = eliminateInf(ft1);\n@@ -221,1 +232,1 @@\n-        for (int i = 0; i < iterLimit && Math.abs(t - s) > err * Math.abs(t + s); i++) {\n+        for (int i = 0; i < iterLimit && Math.abs(t - s) > err; i++) {\n@@ -223,1 +234,1 @@\n-            fr = ROCsq(r) - w2;\n+            fr = eliminateInf(ROCsq(r) - w2);\n@@ -244,1 +255,1 @@\n-        return r;\n+        return (Math.abs(ft) <= Math.abs(fs)) ? t : s;\n@@ -259,4 +270,4 @@\n-        final double dx2dy2 = dx * dx + dy * dy;\n-        final double ddx2ddy2 = ddx * ddx + ddy * ddy;\n-        final double ddxdxddydy = ddx * dx + ddy * dy;\n-        return dx2dy2 * ((dx2dy2 * dx2dy2) \/ (dx2dy2 * ddx2ddy2 - ddxdxddydy * ddxdxddydy));\n+        final double dx2dy2 = dx * dx + dy * dy; \/\/ positive\n+        final double dxddyddxdy = dx * ddy - dy * ddx;\n+        \/\/ may return +Infinity if dxddyddxdy = 0 or NaN if 0\/0:\n+        return (dx2dy2 * dx2dy2 * dx2dy2) \/ (dxddyddxdy * dxddyddxdy); \/\/ both positive\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Curve.java","additions":32,"deletions":21,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -567,1 +567,1 @@\n-        return Math.abs(num) < 2.0d * Math.ulp(num);\n+        return Math.abs(num) < 2.0d * Helpers.ulp(num);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DMarlinRenderingEngine.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,4 @@\n+    private final static double T_ERR = 1e-4;\n+    private final static double T_A = T_ERR;\n+    private final static double T_B = 1.0 - T_ERR;\n+\n@@ -40,0 +44,3 @@\n+    \/** use lower precision like former Pisces and Marlin (float-precision) *\/\n+    static double ulp(final double value) { return Math.ulp((float)value); }\n+\n@@ -325,1 +332,1 @@\n-        ret += c.rootsOfROCMinusW(ts, ret, w2, 0.0001d);\n+        ret += c.rootsOfROCMinusW(ts, ret, w2, T_A, T_B);\n@@ -327,2 +334,2 @@\n-        ret = filterOutNotInAB(ts, 0, ret, 0.0001d, 0.9999d);\n-        isort(ts, ret);\n+        ret = filterOutNotInAB(ts, 0, ret, T_A, T_B);\n+        isort(ts, 0, ret);\n@@ -357,1 +364,1 @@\n-        isort(ts, ret);\n+        isort(ts, 0, ret);\n@@ -377,2 +384,2 @@\n-    static void isort(final double[] a, final int len) {\n-        for (int i = 1, j; i < len; i++) {\n+    static void isort(final double[] a, final int off, final int len) {\n+        for (int i = off + 1, j; i < len; i++) {\n@@ -381,1 +388,1 @@\n-            for (; j >= 0 && a[j] > ai; j--) {\n+            for (; j >= off && a[j] > ai; j--) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Helpers.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -889,2 +889,2 @@\n-        final boolean p1eqp2 = Helpers.withinD(dx1, dy1, 6.0d * Math.ulp(y2));\n-        final boolean p3eqp4 = Helpers.withinD(dx4, dy4, 6.0d * Math.ulp(y4));\n+        final boolean p1eqp2 = Helpers.withinD(dx1, dy1, 6.0d * Helpers.ulp(y2));\n+        final boolean p3eqp4 = Helpers.withinD(dx4, dy4, 6.0d * Helpers.ulp(y4));\n@@ -908,1 +908,1 @@\n-        if (Helpers.within(dotsq, l1sq * l4sq, 4.0d * Math.ulp(dotsq))) {\n+        if (Helpers.within(dotsq, l1sq * l4sq, 4.0d * Helpers.ulp(dotsq))) {\n@@ -1081,2 +1081,2 @@\n-        final boolean p1eqp2 = Helpers.withinD(dx12, dy12, 6.0d * Math.ulp(y2));\n-        final boolean p2eqp3 = Helpers.withinD(dx23, dy23, 6.0d * Math.ulp(y3));\n+        final boolean p1eqp2 = Helpers.withinD(dx12, dy12, 6.0d * Helpers.ulp(y2));\n+        final boolean p2eqp3 = Helpers.withinD(dx23, dy23, 6.0d * Helpers.ulp(y3));\n@@ -1094,1 +1094,1 @@\n-        if (Helpers.within(dotsq, l1sq * l3sq, 4.0d * Math.ulp(dotsq))) {\n+        if (Helpers.within(dotsq, l1sq * l3sq, 4.0d * Helpers.ulp(dotsq))) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Stroker.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,601 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.CubicCurve2D;\n+import java.awt.geom.Point2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.Raster;\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.logging.Handler;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.Timer;\n+\n+import static java.lang.System.out;\n+\n+\/**\n+ * @test\n+ * @bug 8341381\n+ * @summary fix cubic offsetting issue (numerical accuracy)\n+ * @run main\/othervm\/timeout=20 Bug8341381\n+ * @modules java.desktop\/sun.java2d.marlin\n+ *\/\n+public final class Bug8341381 {\n+\n+    static final boolean SHOW_GUI = false;\n+\n+    static final boolean CHECK_PIXELS = true;\n+    static final boolean TRACE_ALL = false;\n+    static final boolean TRACE_CHECK_PIXELS = false;\n+\n+    static final boolean SAVE_IMAGE = false;\n+\n+    static final boolean INTENSIVE = false;\n+\n+    static final double DPI = 96;\n+    static final float STROKE_WIDTH = 15f;\n+\n+    \/\/ delay is 1 frame at 60hz\n+    static final int DELAY = 16;\n+    \/\/ off-screen test step (1.0 by default)\n+    static final double STEP = (INTENSIVE) ? 1.0 \/ 117 : 1.0;\n+\n+    \/\/ stats:\n+    static int N_TEST = 0;\n+    static int N_FAIL = 0;\n+\n+    static final AtomicBoolean isMarlin = new AtomicBoolean();\n+    static final CountDownLatch latch = new CountDownLatch(1);\n+\n+    public static void main(final String[] args) {\n+        Locale.setDefault(Locale.US);\n+\n+        \/\/ FIRST: Get Marlin runtime state from its log:\n+\n+        \/\/ initialize j.u.l Logger:\n+        final Logger log = Logger.getLogger(\"sun.java2d.marlin\");\n+        log.addHandler(new Handler() {\n+            @Override\n+            public void publish(LogRecord record) {\n+                final String msg = record.getMessage();\n+                if (msg != null) {\n+                    \/\/ last space to avoid matching other settings:\n+                    if (msg.startsWith(\"sun.java2d.renderer \")) {\n+                        isMarlin.set(msg.contains(\"DMarlinRenderingEngine\"));\n+                    }\n+                }\n+\n+                final Throwable th = record.getThrown();\n+                \/\/ detect any Throwable:\n+                if (th != null) {\n+                    out.println(\"Test failed:\\n\" + record.getMessage());\n+                    th.printStackTrace(out);\n+                    throw new RuntimeException(\"Test failed: \", th);\n+                }\n+            }\n+\n+            @Override\n+            public void flush() {\n+            }\n+\n+            @Override\n+            public void close() throws SecurityException {\n+            }\n+        });\n+\n+        out.println(\"Bug8341381: start\");\n+        final long startTime = System.currentTimeMillis();\n+\n+        \/\/ enable Marlin logging & internal checks:\n+        System.setProperty(\"sun.java2d.renderer.log\", \"true\");\n+        System.setProperty(\"sun.java2d.renderer.useLogger\", \"true\");\n+\n+        try {\n+            startTest();\n+\n+            out.println(\"WAITING ...\");\n+            latch.await(15, TimeUnit.SECONDS); \/\/ 2s typically\n+\n+            if (isMarlin.get()) {\n+                out.println(\"Marlin renderer used at runtime.\");\n+            } else {\n+                throw new RuntimeException(\"Marlin renderer NOT used at runtime !\");\n+            }\n+\n+            \/\/ show test report:\n+            out.println(\"TESTS: \" + N_TEST + \" FAILS: \" + N_FAIL);\n+\n+            if (N_FAIL > 0) {\n+                throw new RuntimeException(\"Bug8341381: \" + N_FAIL + \" \/ \" + N_TEST + \" test(s) failed !\");\n+            }\n+\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        } catch (InvocationTargetException ite) {\n+            throw new RuntimeException(ite);\n+        } finally {\n+            final double elapsed = (System.currentTimeMillis() - startTime) \/ 1000.0;\n+            out.println(\"Bug8341381: end (\" + elapsed + \" s)\");\n+        }\n+    }\n+\n+    private static void startTest() throws InterruptedException, InvocationTargetException {\n+        if (SHOW_GUI) {\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+                    final JFrame viewer = new JFrame();\n+                    viewer.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+                    viewer.setContentPane(new CanvasPanel(viewer));\n+                    viewer.pack();\n+                    viewer.setVisible(true);\n+                }\n+            });\n+            return;\n+        } else {\n+            out.println(\"STEP: \" + STEP);\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    final Context ctx = new Context();\n+                    final Dimension initialDim = ctx.bugDisplay.getSize(DPI);\n+\n+                    double w = initialDim.width;\n+                    double h = initialDim.height;\n+                    do {\n+                        ctx.shouldScale(w, h);\n+                        ctx.paintImage();\n+\n+                        \/\/ resize component:\n+                        w -= STEP;\n+                        h -= STEP;\n+\n+                    } while (ctx.iterate());\n+                }\n+            }).start();\n+        }\n+    }\n+\n+    static final class Context {\n+\n+        final BugDisplay bugDisplay = new BugDisplay();\n+        double width = 0.0, height = 0.0;\n+\n+        BufferedImage bimg = null;\n+\n+        boolean shouldScale(final double w, final double h) {\n+            if ((w != width) || (h != height) || !bugDisplay.isScaled) {\n+                width = w;\n+                height = h;\n+                bugDisplay.scale(width, height);\n+                N_TEST++;\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        void paintImage() {\n+            final int w = bugDisplay.canvasWidth;\n+            final int h = bugDisplay.canvasHeight;\n+\n+            if ((bimg == null) || (w > bimg.getWidth()) || (h > bimg.getHeight())) {\n+                bimg = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB_PRE);\n+            }\n+            final Graphics gi = bimg.getGraphics();\n+            try {\n+                bugDisplay.paint(gi);\n+            } finally {\n+                gi.dispose();\n+            }\n+            if (!bugDisplay.checkImage(bimg)) {\n+                N_FAIL++;\n+            }\n+        }\n+\n+        boolean iterate() {\n+            if ((bugDisplay.canvasWidth > 10) || (bugDisplay.canvasHeight > 10)) {\n+                \/\/ continue:\n+                return true;\n+            }\n+            out.println(\"Stop\");\n+            latch.countDown();\n+            return false;\n+        }\n+    }\n+\n+    static final class CanvasPanel extends JPanel {\n+        private static final long serialVersionUID = 1L;\n+\n+        private final Context ctx = new Context();\n+        private boolean resized = false;\n+        private Timer timer = null;\n+\n+        public CanvasPanel(final JFrame frame) {\n+            timer = new Timer(DELAY, e -> {\n+                if (resized) {\n+                    resized = false;\n+\n+                    if (ctx.iterate()) {\n+                        \/\/ resize component:\n+                        setSize((int) Math.round(ctx.width - 1), (int) Math.round(ctx.height - 1));\n+                    } else {\n+                        timer.stop();\n+                        if (frame != null) {\n+                            frame.setVisible(false);\n+                        }\n+                    }\n+                }\n+            });\n+            timer.setCoalesce(true);\n+            timer.setRepeats(true);\n+            timer.start();\n+        }\n+\n+        @Override\n+        public void paint(final Graphics g) {\n+            final Dimension dim = getSize();\n+            if (ctx.shouldScale(dim.width, dim.height)) {\n+                this.resized = true;\n+            }\n+            super.paint(g);\n+\n+            \/\/ paint on buffered image:\n+            if (CHECK_PIXELS) {\n+                final int w = ctx.bugDisplay.canvasWidth;\n+                final int h = ctx.bugDisplay.canvasHeight;\n+                if (this.resized) {\n+                    ctx.paintImage();\n+                }\n+                g.drawImage(ctx.bimg.getSubimage(0, 0, w, h), 0, 0, null);\n+            } else {\n+                ctx.bugDisplay.paint(g);\n+            }\n+        }\n+\n+        @Override\n+        public Dimension getPreferredSize() {\n+            return ctx.bugDisplay.getSize(DPI);\n+        }\n+    }\n+\n+    static final class BugDisplay {\n+\n+        boolean isScaled = false;\n+        int canvasWidth;\n+        int canvasHeight;\n+\n+        private final static java.util.List<CubicCurve2D> curves1 = Arrays.asList(\n+                new CubicCurve2D.Double(2191.0, 7621.0, 2191.0, 7619.0, 2191.0, 7618.0, 2191.0, 7617.0),\n+                new CubicCurve2D.Double(2191.0, 7617.0, 2191.0, 7617.0, 2191.0, 7616.0, 2191.0, 7615.0),\n+                new CubicCurve2D.Double(2198.0, 7602.0, 2200.0, 7599.0, 2203.0, 7595.0, 2205.0, 7590.0),\n+                new CubicCurve2D.Double(2205.0, 7590.0, 2212.0, 7580.0, 2220.0, 7571.0, 2228.0, 7563.0),\n+                new CubicCurve2D.Double(2228.0, 7563.0, 2233.0, 7557.0, 2239.0, 7551.0, 2245.0, 7546.0),\n+                new CubicCurve2D.Double(2245.0, 7546.0, 2252.0, 7540.0, 2260.0, 7534.0, 2267.0, 7528.0),\n+                new CubicCurve2D.Double(2267.0, 7528.0, 2271.0, 7526.0, 2275.0, 7524.0, 2279.0, 7521.0),\n+                new CubicCurve2D.Double(2279.0, 7521.0, 2279.0, 7520.0, 2280.0, 7520.0, 2281.0, 7519.0)\n+        );\n+        private final static java.util.List<CubicCurve2D> curves2 = Arrays.asList(\n+                new CubicCurve2D.Double(2281.0, 7519.0, 2282.0, 7518.0, 2282.0, 7517.0, 2283.0, 7516.0),\n+                new CubicCurve2D.Double(2283.0, 7516.0, 2284.0, 7515.0, 2284.0, 7515.0, 2285.0, 7514.0),\n+                new CubicCurve2D.Double(2291.0, 7496.0, 2292.0, 7495.0, 2292.0, 7494.0, 2291.0, 7493.0),\n+                new CubicCurve2D.Double(2291.0, 7493.0, 2290.0, 7492.0, 2290.0, 7492.0, 2289.0, 7492.0),\n+                new CubicCurve2D.Double(2289.0, 7492.0, 2288.0, 7491.0, 2286.0, 7492.0, 2285.0, 7492.0),\n+                new CubicCurve2D.Double(2262.0, 7496.0, 2260.0, 7497.0, 2259.0, 7497.0, 2257.0, 7498.0),\n+                new CubicCurve2D.Double(2257.0, 7498.0, 2254.0, 7498.0, 2251.0, 7499.0, 2248.0, 7501.0),\n+                new CubicCurve2D.Double(2248.0, 7501.0, 2247.0, 7501.0, 2245.0, 7502.0, 2244.0, 7503.0),\n+                new CubicCurve2D.Double(2207.0, 7523.0, 2203.0, 7525.0, 2199.0, 7528.0, 2195.0, 7530.0),\n+                new CubicCurve2D.Double(2195.0, 7530.0, 2191.0, 7534.0, 2186.0, 7538.0, 2182.0, 7541.0)\n+        );\n+        private final static java.util.List<CubicCurve2D> curves3 = Arrays.asList(\n+                new CubicCurve2D.Double(2182.0, 7541.0, 2178.0, 7544.0, 2174.0, 7547.0, 2170.0, 7551.0),\n+                new CubicCurve2D.Double(2170.0, 7551.0, 2164.0, 7556.0, 2158.0, 7563.0, 2152.0, 7569.0),\n+                new CubicCurve2D.Double(2152.0, 7569.0, 2148.0, 7573.0, 2145.0, 7577.0, 2141.0, 7582.0),\n+                new CubicCurve2D.Double(2141.0, 7582.0, 2138.0, 7588.0, 2134.0, 7595.0, 2132.0, 7602.0),\n+                new CubicCurve2D.Double(2132.0, 7602.0, 2132.0, 7605.0, 2131.0, 7608.0, 2131.0, 7617.0),\n+                new CubicCurve2D.Double(2131.0, 7617.0, 2131.0, 7620.0, 2131.0, 7622.0, 2131.0, 7624.0),\n+                new CubicCurve2D.Double(2131.0, 7624.0, 2131.0, 7630.0, 2132.0, 7636.0, 2135.0, 7641.0),\n+                new CubicCurve2D.Double(2135.0, 7641.0, 2136.0, 7644.0, 2137.0, 7647.0, 2139.0, 7650.0),\n+                new CubicCurve2D.Double(2139.0, 7650.0, 2143.0, 7658.0, 2149.0, 7664.0, 2155.0, 7670.0),\n+                new CubicCurve2D.Double(2155.0, 7670.0, 2160.0, 7676.0, 2165.0, 7681.0, 2171.0, 7686.0)\n+        );\n+        private final static java.util.List<CubicCurve2D> curves4 = Arrays.asList(\n+                new CubicCurve2D.Double(2171.0, 7686.0, 2174.0, 7689.0, 2177.0, 7692.0, 2180.0, 7694.0),\n+                new CubicCurve2D.Double(2180.0, 7694.0, 2185.0, 7698.0, 2191.0, 7702.0, 2196.0, 7706.0),\n+                new CubicCurve2D.Double(2196.0, 7706.0, 2199.0, 7708.0, 2203.0, 7711.0, 2207.0, 7713.0),\n+                new CubicCurve2D.Double(2244.0, 7734.0, 2245.0, 7734.0, 2247.0, 7735.0, 2248.0, 7736.0),\n+                new CubicCurve2D.Double(2248.0, 7736.0, 2251.0, 7738.0, 2254.0, 7739.0, 2257.0, 7739.0),\n+                new CubicCurve2D.Double(2257.0, 7739.0, 2259.0, 7739.0, 2260.0, 7739.0, 2262.0, 7740.0),\n+                new CubicCurve2D.Double(2285.0, 7745.0, 2286.0, 7745.0, 2288.0, 7745.0, 2289.0, 7745.0),\n+                new CubicCurve2D.Double(2289.0, 7745.0, 2290.0, 7745.0, 2290.0, 7744.0, 2291.0, 7743.0),\n+                new CubicCurve2D.Double(2291.0, 7743.0, 2292.0, 7742.0, 2292.0, 7741.0, 2291.0, 7740.0),\n+                new CubicCurve2D.Double(2285.0, 7722.0, 2284.0, 7721.0, 2284.0, 7721.0, 2283.0, 7720.0),\n+                new CubicCurve2D.Double(2283.0, 7720.0, 2282.0, 7719.0, 2282.0, 7719.0, 2281.0, 7718.0),\n+                new CubicCurve2D.Double(2281.0, 7718.0, 2280.0, 7717.0, 2279.0, 7716.0, 2279.0, 7716.0),\n+                new CubicCurve2D.Double(2279.0, 7716.0, 2275.0, 7712.0, 2271.0, 7710.0, 2267.0, 7708.0),\n+                new CubicCurve2D.Double(2267.0, 7708.0, 2260.0, 7702.0, 2252.0, 7697.0, 2245.0, 7691.0),\n+                new CubicCurve2D.Double(2245.0, 7691.0, 2239.0, 7685.0, 2233.0, 7679.0, 2228.0, 7673.0),\n+                new CubicCurve2D.Double(2228.0, 7673.0, 2220.0, 7665.0, 2212.0, 7656.0, 2205.0, 7646.0),\n+                new CubicCurve2D.Double(2205.0, 7646.0, 2203.0, 7641.0, 2200.0, 7637.0, 2198.0, 7634.0)\n+        );\n+\n+        private final static Point2D.Double[] extent = {new Point2D.Double(0.0, 0.0), new Point2D.Double(7777.0, 10005.0)};\n+\n+        private final static Stroke STROKE = new BasicStroke(STROKE_WIDTH);\n+        private final static Stroke STROKE_DASHED = new BasicStroke(STROKE_WIDTH, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL,\n+                10.0f, new float[] {100f, 0f}, 0.0f);\n+\n+        \/\/ members:\n+        private final java.util.List<CubicCurve2D> allCurves = new ArrayList<>();\n+        private final Rectangle2D bboxAllCurves = new Rectangle2D.Double();\n+\n+        BugDisplay() {\n+            allCurves.addAll(curves1);\n+            allCurves.addAll(curves2);\n+            allCurves.addAll(curves3);\n+            allCurves.addAll(curves4);\n+\n+            \/\/ initialize bounding box:\n+            double x1 = Double.POSITIVE_INFINITY;\n+            double y1 = Double.POSITIVE_INFINITY;\n+            double x2 = Double.NEGATIVE_INFINITY;\n+            double y2 = Double.NEGATIVE_INFINITY;\n+\n+            for (final CubicCurve2D c : allCurves) {\n+                final Rectangle2D r = c.getBounds2D();\n+                if (r.getMinX() < x1) {\n+                    x1 = r.getMinX();\n+                }\n+                if (r.getMinY() < y1) {\n+                    y1 = r.getMinY();\n+                }\n+                if (r.getMaxX() > x2) {\n+                    x2 = r.getMaxX();\n+                }\n+                if (r.getMaxY() > y2) {\n+                    y2 = r.getMaxY();\n+                }\n+            }\n+            \/\/ add margin of 10%:\n+            final double m = 1.1 * STROKE_WIDTH;\n+            bboxAllCurves.setFrameFromDiagonal(x1 - m, y1 - m, x2 + m, y2 + m);\n+        }\n+\n+        public void paint(final Graphics g) {\n+            final Graphics2D g2d = (Graphics2D) g;\n+            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);\n+            g2d.setColor(Color.WHITE);\n+            g2d.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n+\n+            \/\/ ------ scale\n+            final AffineTransform tx_orig = g2d.getTransform();\n+            final AffineTransform tx = getDrawTransform();\n+            g2d.transform(tx);\n+\n+            \/\/ draw bbox:\n+            if (!CHECK_PIXELS) {\n+                g2d.setColor(Color.RED);\n+                g2d.setStroke(STROKE);\n+                g2d.draw(bboxAllCurves);\n+            }\n+            \/\/ draw curves:\n+            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+            g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);\n+            g2d.setColor(Color.BLACK);\n+\n+            \/\/ dasher + stroker:\n+            g2d.setStroke(STROKE_DASHED);\n+            this.allCurves.forEach(g2d::draw);\n+\n+            \/\/ reset\n+            g2d.setTransform(tx_orig);\n+        }\n+\n+        private AffineTransform getDrawTransform() {\n+            \/\/ ------ scale\n+            double minX = extent[0].x, maxX = extent[1].x;\n+            double minY = extent[0].y, maxY = extent[1].y;\n+\n+            \/\/ we're scaling and respecting the proportions, check which scale to use\n+            double sx = this.canvasWidth \/ Math.abs(maxX - minX);\n+            double sy = this.canvasHeight \/ Math.abs(maxY - minY);\n+            double s = Math.min(sx, sy);\n+\n+            double m00, m11, m02, m12;\n+            if (minX < maxX) {\n+                m00 = s;\n+                m02 = -s * minX;\n+            } else {\n+                \/\/ inverted X axis\n+                m00 = -s;\n+                m02 = this.canvasWidth + s * maxX;\n+            }\n+            if (minY < maxY) {\n+                m11 = s;\n+                m12 = -s * minY;\n+            } else {\n+                \/\/ inverted Y axis\n+                m11 = -s;\n+                m12 = this.canvasHeight + s * maxY;\n+            }\n+\n+            \/\/ scale to the available view port\n+            AffineTransform scaleTransform = new AffineTransform(m00, 0, 0, m11, m02, m12);\n+\n+            \/\/ invert the Y axis since (0, 0) is at top left for AWT\n+            AffineTransform invertY = new AffineTransform(1, 0, 0, -1, 0, this.canvasHeight);\n+            invertY.concatenate(scaleTransform);\n+\n+            return invertY;\n+        }\n+\n+        public Dimension getSize(double dpi) {\n+            double metricScalingFactor = 0.02539999969303608;\n+            \/\/ 1 inch = 25,4 millimeter\n+            final double factor = dpi * metricScalingFactor \/ 25.4;\n+\n+            int width = (int) Math.ceil(Math.abs(extent[1].x - extent[0].x) * factor);\n+            int height = (int) Math.ceil(Math.abs(extent[1].y - extent[0].y) * factor);\n+\n+            return new Dimension(width, height);\n+        }\n+\n+        public void scale(double w, double h) {\n+            double extentWidth = Math.abs(extent[1].x - extent[0].x);\n+            double extentHeight = Math.abs(extent[1].y - extent[0].y);\n+\n+            double fx = w \/ extentWidth;\n+            if (fx * extentHeight > h) {\n+                fx = h \/ extentHeight;\n+            }\n+            this.canvasWidth = (int) Math.round(fx * extentWidth);\n+            this.canvasHeight = (int) Math.round(fx * extentHeight);\n+\n+            \/\/ out.println(\"canvas scaled (\" + canvasWidth + \" x \" + canvasHeight + \")\");\n+\n+            this.isScaled = true;\n+        }\n+\n+        protected boolean checkImage(BufferedImage image) {\n+            final AffineTransform tx = getDrawTransform();\n+\n+            final Point2D pMin = new Point2D.Double(bboxAllCurves.getMinX(), bboxAllCurves.getMinY());\n+            final Point2D pMax = new Point2D.Double(bboxAllCurves.getMaxX(), bboxAllCurves.getMaxY());\n+\n+            final Point2D tMin = tx.transform(pMin, null);\n+            final Point2D tMax = tx.transform(pMax, null);\n+\n+            int xMin = (int) tMin.getX();\n+            int xMax = (int) tMax.getX();\n+            if (xMin > xMax) {\n+                int t = xMin;\n+                xMin = xMax;\n+                xMax = t;\n+            }\n+\n+            int yMin = (int) tMin.getY();\n+            int yMax = (int) tMax.getY();\n+            if (yMin > yMax) {\n+                int t = yMin;\n+                yMin = yMax;\n+                yMax = t;\n+            }\n+            \/\/ add pixel margin (AA):\n+            xMin -= 3;\n+            xMax += 4;\n+            yMin -= 3;\n+            yMax += 4;\n+\n+            if (xMin < 0 || xMax > image.getWidth()\n+                    || yMin < 0 || yMax > image.getHeight()) {\n+                return true;\n+            }\n+\n+            \/\/ out.println(\"Checking rectangle: \" + tMin + \" to \" + tMax);\n+            \/\/ out.println(\"X min: \" + xMin + \" - max: \" + xMax);\n+            \/\/ out.println(\"Y min: \" + yMin + \" - max: \" + yMax);\n+\n+            final Raster raster = image.getData();\n+            final int expected = Color.WHITE.getRGB();\n+            int nBadPixels = 0;\n+\n+            \/\/ horizontal lines:\n+            for (int x = xMin; x <= xMax; x++) {\n+                if (!checkPixel(raster, x, yMin, expected)) {\n+                    nBadPixels++;\n+                }\n+                if (!checkPixel(raster, x, yMax, expected)) {\n+                    nBadPixels++;\n+                }\n+            }\n+\n+            \/\/ vertical lines:\n+            for (int y = yMin; y <= yMax; y++) {\n+                if (!checkPixel(raster, xMin, y, expected)) {\n+                    nBadPixels++;\n+                }\n+                if (!checkPixel(raster, xMax, y, expected)) {\n+                    nBadPixels++;\n+                }\n+            }\n+\n+            if (nBadPixels != 0) {\n+                out.println(\"(\" + canvasWidth + \" x \" + canvasHeight + \") BAD pixels = \" + nBadPixels);\n+\n+                if (SAVE_IMAGE) {\n+                    try {\n+                        final File file = new File(\"Bug8341381-\" + canvasWidth + \"-\" + canvasHeight + \".png\");\n+\n+                        out.println(\"Writing file: \" + file.getAbsolutePath());\n+                        ImageIO.write(image.getSubimage(0, 0, canvasWidth, canvasHeight), \"PNG\", file);\n+                    } catch (IOException ioe) {\n+                        ioe.printStackTrace();\n+                    }\n+                }\n+                return false;\n+            } else if (TRACE_ALL) {\n+                out.println(\"(\" + canvasWidth + \" x \" + canvasHeight + \") OK\");\n+            }\n+            return true;\n+        }\n+\n+        private final static int[] TMP_RGB = new int[1];\n+\n+        private static boolean checkPixel(final Raster raster,\n+                                          final int x, final int y,\n+                                          final int expected) {\n+\n+            final int[] rgb = (int[]) raster.getDataElements(x, y, TMP_RGB);\n+\n+            if (rgb[0] != expected) {\n+                if (TRACE_CHECK_PIXELS) {\n+                    out.println(\"bad pixel at (\" + x + \", \" + y + \") = \" + rgb[0]\n+                            + \" expected = \" + expected);\n+                }\n+                return false;\n+            }\n+            return true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/marlin\/Bug8341381.java","additions":601,"deletions":0,"binary":false,"changes":601,"status":"added"}]}