{"files":[{"patch":"@@ -1579,8 +1579,0 @@\n-\n-#if INCLUDE_JVMCI\n-    if (jvmci_nmethod_data() != nullptr) {\n-      nm_copy->jvmci_nmethod_data()->relocate_nmethod_mirror(nm_copy);\n-      jvmci_nmethod_data()->clear_nmethod_mirror_index();\n-    }\n-#endif\n-\n@@ -1594,0 +1586,4 @@\n+  if (is_compiled_by_jvmci()) {\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -847,18 +847,0 @@\n-void JVMCINMethodData::clear_nmethod_mirror_index() {\n-  _nmethod_mirror_index = -1;\n-}\n-\n-void JVMCINMethodData::relocate_nmethod_mirror(nmethod* nm) {\n-  oop nmethod_mirror = get_nmethod_mirror(nm, \/* phantom_ref *\/ false);\n-  if (nmethod_mirror == nullptr) {\n-    return;\n-  }\n-\n-  JVMCIEnv* jvmciEnv = nullptr;\n-  HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, (jlong)(nm));\n-  HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, (jlong)(nm->entry_point()));\n-  HotSpotJVMCI::HotSpotInstalledCode::set_size(jvmciEnv, nmethod_mirror, (jlong)(nm->size()));\n-  HotSpotJVMCI::HotSpotInstalledCode::set_codeStart(jvmciEnv, nmethod_mirror, (jlong)(nm->code_begin()));\n-  HotSpotJVMCI::HotSpotInstalledCode::set_codeSize(jvmciEnv, nmethod_mirror, (jlong)(nm->code_size()));\n-}\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -124,8 +124,0 @@\n-  \/\/ Used during nmethod relocation to clear the mirror index of the original nmethod.\n-  \/\/ This prevents the original, non-entrant nmethod from interacting with the\n-  \/\/ HotSpotNmethod mirror after relocation.\n-  void clear_nmethod_mirror_index();\n-\n-  \/\/ Updates the HotSpotNmethod fields after nmethod relocation\n-  void relocate_nmethod_mirror(nmethod* nm);\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1560,1 +1560,2 @@\n-      address((jlong) blob) { }\n+      address((jlong) blob),\n+      is_nmethod((jboolean) blob->is_nmethod()) { }\n@@ -1566,0 +1567,1 @@\n+  const jboolean    is_nmethod;\n@@ -1572,1 +1574,1 @@\n-  jobjectArray result = env->NewObjectArray(4, clazz, nullptr);\n+  jobjectArray result = env->NewObjectArray(5, clazz, nullptr);\n@@ -1590,0 +1592,4 @@\n+  obj = booleanBox(thread, env, cb->is_nmethod);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  env->SetObjectArrayElement(result, 4, obj);\n+\n@@ -1639,1 +1645,1 @@\n-WB_ENTRY(void, WB_RelocateNMethodTo(JNIEnv* env, jobject o, jobject method, jint blob_type))\n+WB_ENTRY(void, WB_RelocateNMethodFromMethod(JNIEnv* env, jobject o, jobject method, jint blob_type))\n@@ -1650,0 +1656,9 @@\n+WB_ENTRY(void, WB_RelocateNMethodFromAddr(JNIEnv* env, jobject o, jlong addr, jint blob_type))\n+  ResourceMark rm(THREAD);\n+  CHECK_JNI_EXCEPTION(env);\n+  nmethod* code = (nmethod*) addr;\n+  if (code != nullptr) {\n+    code->relocate(static_cast<CodeBlobType>(blob_type));\n+  }\n+WB_END\n+\n@@ -2895,2 +2910,3 @@\n-  {CC\"relocateNMethodTo0\", CC\"(Ljava\/lang\/reflect\/Executable;I)V\",\n-                                                      (void*)&WB_RelocateNMethodTo  },\n+  {CC\"relocateNMethodFromMethod0\", CC\"(Ljava\/lang\/reflect\/Executable;I)V\",\n+                                                      (void*)&WB_RelocateNMethodFromMethod },\n+  {CC\"relocateNMethodFromAddr0\", CC\"(JI)V\",           (void*)&WB_RelocateNMethodFromAddr },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-        WHITE_BOX.relocateNMethodTo(method, BlobType.MethodProfiled.id);\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodProfiled.id);\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeRelocatedNMethod.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @summary test that WB::relocateNMethodTo() correctly creates a new nmethod\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n@@ -42,1 +42,1 @@\n- * @summary test that WB::relocateNMethodTo() correctly creates a new nmethod\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n@@ -56,1 +56,1 @@\n- * @summary test that WB::relocateNMethodTo() correctly creates a new nmethod\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n@@ -70,1 +70,1 @@\n- * @summary test that WB::relocateNMethodTo() correctly creates a new nmethod\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n@@ -84,1 +84,1 @@\n- * @summary test that WB::relocateNMethodTo() correctly creates a new nmethod\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n@@ -125,1 +125,1 @@\n-        WHITE_BOX.relocateNMethodTo(method, BlobType.MethodProfiled.id);\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodProfiled.id);\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/RelocateNMethod.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-        WHITE_BOX.relocateNMethodTo(method, BlobType.MethodNonProfiled.id);\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodNonProfiled.id);\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/RelocateNMethodMultiplePaths.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test StressNMethodRelocation\n+ * @summary Call and relocate methods concurrently\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache\n+ *                   compiler.whitebox.StressNMethodRelocation\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.CodeBlob;\n+import jdk.test.whitebox.code.NMethod;\n+\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.Random;\n+\n+public class StressNMethodRelocation {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final int C2_LEVEL = 4;\n+    private static final int ACTIVE_METHODS = 1024;\n+\n+    private static TestMethod[] methods;\n+    private static byte[] num1;\n+    private static byte[] num2;\n+\n+    private static long DURATION = 60_000;\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Initialize defaults\n+        initNums();\n+\n+        \/\/ Generate compiled code\n+        methods = new TestMethod[ACTIVE_METHODS];\n+        generateCode(methods);\n+\n+        \/\/ Create thread that runs compiled methods\n+        RunMethods runMethods = new RunMethods();\n+        Thread runMethodsThread = new Thread(runMethods);\n+\n+        \/\/ Create thread that relocates compiled methods\n+        RelocateNMethods relocate = new RelocateNMethods();\n+        Thread relocateThread = new Thread(relocate);\n+\n+        \/\/ Start theads\n+        runMethodsThread.start();\n+        relocateThread.start();\n+\n+        \/\/ Wait for threads to finish\n+        runMethodsThread.join();\n+        relocateThread.join();\n+    }\n+\n+    private static byte[] genNum(Random random, int digitCount) {\n+        byte[] num = new byte[digitCount];\n+        int d;\n+        do {\n+            d = random.nextInt(10);\n+        } while (d == 0);\n+\n+        num[0] = (byte)d;\n+        for (int i = 1; i < digitCount; ++i) {\n+            num[i] = (byte)random.nextInt(10);\n+        }\n+        return num;\n+    }\n+\n+    private static void initNums() {\n+        final long seed = 8374592837465123L;\n+        Random random = new Random(seed);\n+\n+        final int digitCount = 40;\n+        num1 = genNum(random, digitCount);\n+        num2 = genNum(random, digitCount);\n+    }\n+\n+    private static void generateCode(TestMethod[] m) throws Exception {\n+        byte[] result = new byte[num1.length + 1];\n+\n+        for (int i = 0; i < ACTIVE_METHODS; ++i) {\n+            m[i] = new TestMethod();\n+            m[i].profile(num1, num2, result);\n+            m[i].compileWithC2();\n+        }\n+    }\n+\n+    private static final class TestMethod {\n+        private static final String CLASS_NAME = \"A\";\n+        private static final String METHOD_TO_COMPILE = \"sum\";\n+        private static final String JAVA_CODE = \"\"\"\n+        public class A {\n+\n+            public static void sum(byte[] n1, byte[] n2, byte[] out) {\n+                final int digitCount = n1.length;\n+                int carry = 0;\n+                for (int i = digitCount - 1; i >= 0; --i) {\n+                    int sum = n1[i] + n2[i] + carry;\n+                    out[i] = (byte)(sum % 10);\n+                    carry = sum \/ 10;\n+                }\n+                if (carry != 0) {\n+                    for (int i = digitCount; i > 0; --i) {\n+                        out[i] = out[i - 1];\n+                    }\n+                    out[0] = (byte)carry;\n+                }\n+            }\n+        }\"\"\";\n+\n+        private static final byte[] BYTE_CODE;\n+\n+        static {\n+            BYTE_CODE = InMemoryJavaCompiler.compile(CLASS_NAME, JAVA_CODE);\n+        }\n+\n+        private final Method method;\n+\n+        private static ClassLoader createClassLoaderFor() {\n+            return new ClassLoader() {\n+                @Override\n+                public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                    if (!name.equals(CLASS_NAME)) {\n+                        return super.loadClass(name);\n+                    }\n+\n+                    return defineClass(name, BYTE_CODE, 0, BYTE_CODE.length);\n+                }\n+            };\n+        }\n+\n+        public TestMethod() throws Exception {\n+            var cl = createClassLoaderFor().loadClass(CLASS_NAME);\n+            method = cl.getMethod(METHOD_TO_COMPILE, byte[].class, byte[].class, byte[].class);\n+            WHITE_BOX.testSetDontInlineMethod(method, true);\n+        }\n+\n+        public void profile(byte[] num1, byte[] num2, byte[] result) throws Exception {\n+            method.invoke(null, num1, num2, result);\n+            WHITE_BOX.markMethodProfiled(method);\n+        }\n+\n+        public void invoke(byte[] num1, byte[] num2, byte[] result) throws Exception {\n+            method.invoke(null, num1, num2, result);\n+        }\n+\n+        public void compileWithC2() throws Exception {\n+            WHITE_BOX.enqueueMethodForCompilation(method, C2_LEVEL);\n+            while (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WHITE_BOX.getMethodCompilationLevel(method) != C2_LEVEL) {\n+                throw new IllegalStateException(\"Method \" + method + \" is not compiled by C2.\");\n+            }\n+        }\n+    }\n+\n+    private static final class RelocateNMethods implements Runnable {\n+        public RelocateNMethods() {}\n+\n+        \/\/ Move nmethod back and forth between NonProfiled and Profiled code heaps\n+        public void run() {\n+            long startTime = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - startTime < DURATION) {\n+                \/\/ Relocate NonProfiled to Profiled\n+                CodeBlob[] nonProfiledBlobs = CodeBlob.getCodeBlobs(BlobType.MethodNonProfiled);\n+                for (CodeBlob blob : nonProfiledBlobs) {\n+                    if (blob.isNMethod) {\n+                        WHITE_BOX.relocateNMethodFromAddr0(blob.address, BlobType.MethodProfiled.id);\n+                    }\n+                }\n+\n+                \/\/ Relocate Profiled to NonProfiled\n+                CodeBlob[] profiledBlobs = CodeBlob.getCodeBlobs(BlobType.MethodProfiled);\n+                for (CodeBlob blob : nonProfiledBlobs) {\n+                    if (blob.isNMethod) {\n+                        WHITE_BOX.relocateNMethodFromAddr0(blob.address, BlobType.MethodNonProfiled.id);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final class RunMethods implements Runnable {\n+        public RunMethods() {}\n+\n+        public void run() {\n+            try {\n+                long startTime = System.currentTimeMillis();\n+                while (System.currentTimeMillis() - startTime < DURATION) {\n+                    callMethods();\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e.getMessage());\n+            }\n+        }\n+\n+        private void callMethods() throws Exception {\n+            for (var m : methods) {\n+                byte[] result = new byte[num1.length + 1];\n+                m.invoke(num1, num2, result);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/StressNMethodRelocation.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -493,2 +493,2 @@\n-  private native void     relocateNMethodTo0(Executable method, int type);\n-  public         void     relocateNMethodTo(Executable method, int type) {\n+  private native void     relocateNMethodFromMethod0(Executable method, int type);\n+  public         void     relocateNMethodFromMethod(Executable method, int type) {\n@@ -496,1 +496,1 @@\n-    relocateNMethodTo0(method, type);\n+    relocateNMethodFromMethod0(method, type);\n@@ -498,0 +498,1 @@\n+  public native void    relocateNMethodFromAddr0(long address, int type);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    assert obj.length == 4;\n+    assert obj.length == 5;\n@@ -56,0 +56,1 @@\n+    isNMethod = (Boolean) obj[4];\n@@ -61,0 +62,1 @@\n+  public final boolean isNMethod;\n","filename":"test\/lib\/jdk\/test\/whitebox\/code\/CodeBlob.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}