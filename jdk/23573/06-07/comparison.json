{"files":[{"patch":"@@ -84,0 +84,3 @@\n+    if (!Assembler::reachable_from_branch_at(addr(), x)) {\n+      x = call->get_trampoline();\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1124,8 +1124,10 @@\n-  NoSafepointVerifier nsv;\n-  if (nm != nullptr) {\n-    \/\/ Compilation succeeded, post what we know about it\n-    nm->post_compiled_method(task());\n-    task()->set_num_inlined_bytecodes(num_inlined_bytecodes());\n-  } else {\n-    \/\/ The CodeCache is full.\n-    record_failure(\"code cache is full\");\n+  {\n+    NoSafepointVerifier nsv;\n+    if (nm != nullptr) {\n+      \/\/ Compilation succeeded, post what we know about it\n+      nm->post_compiled_method(task());\n+      task()->set_num_inlined_bytecodes(num_inlined_bytecodes());\n+    } else {\n+      \/\/ The CodeCache is full.\n+      record_failure(\"code cache is full\");\n+    }\n@@ -1133,1 +1135,0 @@\n-\n@@ -1135,0 +1136,5 @@\n+\n+  if (StressNMethodRelocation) {\n+    VM_RelocateNMethod relocate(nm, CodeBlobType::MethodNonProfiled);\n+    VMThread::execute(&relocate);\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1397,2 +1397,0 @@\n-nmethod* nmethod::clone(CodeBlobType code_blob_type) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"only called at safepoint\");\n@@ -1400,3 +1398,2 @@\n-  \/\/ Allocate memory in code heap and copy data from nmethod\n-  nmethod* nm_copy = (nmethod*) CodeCache::allocate(size(), code_blob_type);\n-  memcpy((void*) nm_copy, this, size());\n+nmethod::nmethod(nmethod* nm) : CodeBlob(nm->_name, nm->_kind, nm->_size, nm->_header_size)\n+{\n@@ -1404,3 +1401,2 @@\n-  \/\/ Increment number of references to immutable data to share it between nmethods\n-  if (immutable_data_size() > 0) {\n-    set_immutable_data_references(get_immutable_data_references() + 1);\n+  if (nm->_oop_maps != nullptr) {\n+    _oop_maps                   = nm->_oop_maps->clone();\n@@ -1408,1 +1404,1 @@\n-    nm_copy->_immutable_data = nm_copy->blob_end();\n+    _oop_maps                   = nullptr;\n@@ -1411,1 +1407,23 @@\n-  \/\/ Allocate memory and copy mutable data from C heap\n+  _size                         = nm->_size;\n+  _relocation_size              = nm->_relocation_size;\n+  _content_offset               = nm->_content_offset;\n+  _code_offset                  = nm->_code_offset;\n+  _data_offset                  = nm->_data_offset;\n+  _frame_size                   = nm->_frame_size;\n+\n+  S390_ONLY( _ctable_offset     = nm->_ctable_offset; )\n+\n+  _header_size                  = nm->_header_size;\n+  _frame_complete_offset        = nm->_frame_complete_offset;\n+\n+  _kind                         = nm->_kind;\n+\n+  _caller_must_gc_arguments     = nm->_caller_must_gc_arguments;\n+\n+#ifndef PRODUCT\n+  _asm_remarks.share(nm->_asm_remarks);\n+  _dbg_strings.share(nm->_dbg_strings);\n+#endif\n+\n+  \/\/ Allocate memory and copy mutable data to C heap\n+  _mutable_data_size            = nm->_mutable_data_size;\n@@ -1413,1 +1431,1 @@\n-    nm_copy->_mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n+    _mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n@@ -1417,1 +1435,1 @@\n-    memcpy(nm_copy->mutable_data_begin(), mutable_data_begin(), mutable_data_size());\n+    memcpy(mutable_data_begin(), nm->mutable_data_begin(), nm->mutable_data_size());\n@@ -1419,1 +1437,1 @@\n-    nm_copy->_mutable_data = nullptr;\n+    _mutable_data               = nullptr;\n@@ -1422,3 +1440,12 @@\n-  \/\/ Fix new nmethod specific data\n-  if (oop_maps() != nullptr) {\n-    nm_copy->_oop_maps = oop_maps()->clone();\n+  _deoptimization_generation    = 0;\n+  _gc_epoch                     = CodeCache::gc_epoch();\n+  _method                       = nm->_method;\n+  _osr_link                     = nullptr;\n+  \n+  \/\/ Increment number of references to immutable data to share it between nmethods\n+  _immutable_data_size          = nm->_immutable_data_size;\n+  if (_immutable_data_size > 0) {\n+    _immutable_data             = nm->_immutable_data;\n+    set_immutable_data_references(get_immutable_data_references() + 1);\n+  } else {\n+    _immutable_data             = blob_end();\n@@ -1427,3 +1454,34 @@\n-  nm_copy->_exception_cache = nullptr;\n-  nm_copy->_gc_data = nullptr;\n-  nm_copy->_compiled_ic_data = nullptr;\n+  _exception_cache              = nullptr;\n+  _gc_data                      = nullptr;\n+  _oops_do_mark_nmethods        = nullptr;\n+  _oops_do_mark_link            = nullptr;\n+  _compiled_ic_data             = nullptr;\n+  \n+  if (nm->_osr_entry_point != nullptr) {\n+    _osr_entry_point            = (nm->_osr_entry_point - (address) nm) + (address) this;\n+  } else {\n+    _osr_entry_point            = nullptr;\n+  }\n+  \n+  _entry_offset                 = nm->_entry_offset;\n+  _verified_entry_offset        = nm->_verified_entry_offset;\n+  _entry_bci                    = nm->_entry_bci;\n+  \n+  _skipped_instructions_size    = nm->_skipped_instructions_size;\n+  _stub_offset                  = nm->_stub_offset;\n+  _exception_offset             = nm->_exception_offset;\n+  _deopt_handler_offset         = nm->_deopt_handler_offset;\n+  _deopt_mh_handler_offset      = nm->_deopt_mh_handler_offset;\n+  _unwind_handler_offset        = nm->_unwind_handler_offset;\n+  _num_stack_arg_slots          = nm->_num_stack_arg_slots;\n+  _oops_size                    = nm->_oops_size;\n+#if INCLUDE_JVMCI\n+  _jvmci_data_size              = nm->_jvmci_data_size;\n+#endif\n+  _nul_chk_table_offset         = nm->_nul_chk_table_offset;\n+  _handler_table_offset         = nm->_handler_table_offset;\n+  _scopes_pcs_offset            = nm->_scopes_pcs_offset;\n+  _scopes_data_offset           = nm->_scopes_data_offset;\n+#if INCLUDE_JVMCI\n+  _speculations_offset          = nm->_speculations_offset;\n+#endif\n@@ -1431,2 +1489,22 @@\n-  if (_pc_desc_container != nullptr) {\n-    nm_copy->_pc_desc_container = new PcDescContainer(nm_copy->scopes_pcs_begin());\n+  _orig_pc_offset               = nm->_orig_pc_offset;\n+  _compile_id                   = nm->_compile_id;\n+  _comp_level                   = nm->_comp_level;\n+  _compiler_type                = nm->_compiler_type;\n+  _is_unloading_state           = nm->_is_unloading_state;\n+  _state                        = not_installed;\n+  \n+  _has_unsafe_access            = nm->_has_unsafe_access;\n+  _has_method_handle_invokes    = nm->_has_method_handle_invokes;\n+  _has_wide_vectors             = nm->_has_wide_vectors;\n+  _has_monitors                 = nm->_has_monitors;\n+  _has_scoped_access            = nm->_has_scoped_access;\n+  _has_flushed_dependencies     = nm->_has_flushed_dependencies;\n+  _is_unlinked                  = nm->_is_unlinked;\n+  _load_reported                = nm->_load_reported;\n+  \n+  _deoptimization_status        = nm->_deoptimization_status;\n+\n+  if (nm->_pc_desc_container != nullptr) {\n+    _pc_desc_container          = new PcDescContainer(scopes_pcs_begin());\n+  } else {\n+    _pc_desc_container          = nullptr;\n@@ -1435,4 +1513,17 @@\n-#ifndef PRODUCT\n-  _asm_remarks.reuse();\n-  _dbg_strings.reuse();\n-#endif\n+  \/\/ Copy nmethod contents excluding header\n+  \/\/ - Constant part          (doubles, longs and floats used in nmethod)\n+  \/\/ - Code part:\n+  \/\/   - Code body\n+  \/\/   - Exception handler\n+  \/\/   - Stub code\n+  \/\/   - OOP table\n+  memcpy(consts_begin(), nm->consts_begin(), nm->data_end() - nm->consts_begin());\n+}\n+\n+nmethod* nmethod::relocate(CodeBlobType code_blob_type) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"only called at safepoint\");\n+  assert_lock_strong(CodeCache_lock);\n+  assert_lock_strong(NMethodState_lock);\n+\n+  run_nmethod_entry_barrier();\n+  nmethod* nm_copy = new (size(), code_blob_type) nmethod(this);\n@@ -1442,1 +1533,1 @@\n-  CodeBuffer src((CodeBlob *)this);\n+  CodeBuffer src(this);\n@@ -1448,2 +1539,0 @@\n-  ICache::invalidate_range(nm_copy->code_begin(), nm_copy->code_size());\n-\n@@ -1452,7 +1541,0 @@\n-  \/\/ Update corresponding Java method to point to this nmethod\n-  if (nm_copy->method()->code() == this) {\n-    MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n-    methodHandle mh(Thread::current(), nm_copy->method());\n-    nm_copy->method()->set_code(mh, nm_copy);\n-  }\n-\n@@ -1482,0 +1564,2 @@\n+  ICache::invalidate_range(nm_copy->code_begin(), nm_copy->code_size());\n+\n@@ -1484,1 +1568,6 @@\n-  make_not_used();\n+  \/\/ Update corresponding Java method to point to this nmethod\n+  if (nm_copy->method() != nullptr && nm_copy->method()->code() == this && nm_copy->make_in_use()) {\n+    methodHandle mh(Thread::current(), nm_copy->method());\n+    nm_copy->method()->set_code(mh, nm_copy);\n+    make_not_used();\n+  }\n@@ -1489,11 +1578,3 @@\n-nmethod* nmethod::relocate_to(nmethod* nm, CodeBlobType code_blob_type) {\n-  \/\/ Relocate nmethod at safepoint\n-  VM_RelocateNMethod relocate_nmethod(nm, code_blob_type);\n-  VMThread::execute(&relocate_nmethod);\n-  nmethod* nm_copy = relocate_nmethod.getRelocatedNMethod();\n-\n-  \/\/ Do verification and logging outside safepoint\n-  if (nm_copy != nullptr) {\n-    NOT_PRODUCT(note_java_nmethod(nm_copy));\n-    DEBUG_ONLY(nm_copy->verify();)\n-    nm_copy->log_new_nmethod();\n+bool nmethod::is_relocatable() {\n+  if (is_not_entrant()) {\n+    return false;\n@@ -1502,2 +1583,3 @@\n-  return nm_copy;\n-}\n+  if (is_marked_for_deoptimization()) {\n+    return false;\n+  }\n@@ -1505,2 +1587,1 @@\n-bool nmethod::is_relocatable() const {\n-  if (is_not_entrant()) {\n+  if (is_unloading()) {\n@@ -1525,0 +1606,4 @@\n+void* nmethod::operator new(size_t size, int nmethod_size, CodeBlobType code_blob_type) throw () {\n+  return CodeCache::allocate(nmethod_size, code_blob_type);\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":136,"deletions":51,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -337,0 +337,2 @@\n+  nmethod(nmethod* nm);\n+\n@@ -339,0 +341,1 @@\n+  void* operator new(size_t size, int nmethod_size, CodeBlobType code_blob_type) throw();\n@@ -495,2 +498,0 @@\n-  nmethod* clone(CodeBlobType code_blob_type);\n-\n@@ -500,1 +501,1 @@\n-  static nmethod* relocate_to(nmethod* nm, CodeBlobType code_blob_type);\n+  nmethod* relocate(CodeBlobType code_blob_type);\n@@ -518,1 +519,1 @@\n-  bool is_relocatable() const;\n+  bool is_relocatable();\n@@ -892,2 +893,2 @@\n-  inline int  get_immutable_data_references()           { return *immutable_data_references_begin();    }\n-  inline void set_immutable_data_references(int count)  { (*immutable_data_references_begin()) = count; }\n+  inline int  get_immutable_data_references()           { return *((int*)immutable_data_references_begin());  }\n+  inline void set_immutable_data_references(int count)  { *((int*)immutable_data_references_begin()) = count; }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -370,2 +370,11 @@\n-  \/\/ Reassert the callee address, this time in the new copy of the code.\n-  pd_set_call_destination(callee);\n+\n+  if (src->contains(callee)) {\n+    \/\/ If the original call is to an address in the src CodeBuffer (such as a stub call)\n+    \/\/ the updated call should be to the corresponding address in dest CodeBuffer\n+    int offset = callee - orig_addr;\n+    address new_addr = addr() + offset;\n+    pd_set_call_destination(new_addr);\n+  } else {\n+    \/\/ Reassert the callee address, this time in the new copy of the code.\n+    pd_set_call_destination(callee);\n+  }\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -140,0 +140,3 @@\n+  product(bool, StressNMethodRelocation, false,                             \\\n+          \"Stress relocation nmethods\")                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1637,1 +1637,2 @@\n-  nmethod::relocate_to(code, static_cast<CodeBlobType>(blob_type));\n+  VM_RelocateNMethod relocate(code, static_cast<CodeBlobType>(blob_type));\n+  VMThread::execute(&relocate);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml_NMethodState_lock(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n@@ -106,1 +107,1 @@\n-    _nm_copy = _nm->clone(_code_blob_type);\n+    _nm_copy = _nm->relocate(_code_blob_type);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}