{"files":[{"patch":"@@ -928,5 +928,0 @@\n-  \/\/ The maximum range of a branch is fixed for the AArch64\n-  \/\/ architecture.  Max branch range is the largest value\n-  \/\/ that will fit in the instruction\n-  static const uint64_t max_branch_range = 128 * M;\n-\n@@ -937,1 +932,1 @@\n-  static const uint64_t branch_range = NOT_DEBUG(max_branch_range) DEBUG_ONLY(2 * M);\n+  static const uint64_t branch_range = NOT_DEBUG(128 * M) DEBUG_ONLY(2 * M);\n@@ -939,2 +934,2 @@\n-  static bool reachable_from_branch_at(address branch, address target, bool use_max=false) {\n-    return uabs(target - branch) < (use_max ? max_branch_range : branch_range);\n+  static bool reachable_from_branch_at(address branch, address target) {\n+    return uabs(target - branch) < branch_range;\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    if (!Assembler::reachable_from_branch_at(addr(), x, true)) {\n+    if (!Assembler::reachable_from_branch_at(addr(), x)) {\n@@ -86,2 +86,3 @@\n-      assert(trampoline != nullptr, \"branch is too large with no available trampoline\");\n-      x = call->get_trampoline();\n+      if (trampoline != nullptr) {\n+        x = call->get_trampoline();\n+      }\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1124,10 +1124,8 @@\n-  {\n-    NoSafepointVerifier nsv;\n-    if (nm != nullptr) {\n-      \/\/ Compilation succeeded, post what we know about it\n-      nm->post_compiled_method(task());\n-      task()->set_num_inlined_bytecodes(num_inlined_bytecodes());\n-    } else {\n-      \/\/ The CodeCache is full.\n-      record_failure(\"code cache is full\");\n-    }\n+  NoSafepointVerifier nsv;\n+  if (nm != nullptr) {\n+    \/\/ Compilation succeeded, post what we know about it\n+    nm->post_compiled_method(task());\n+    task()->set_num_inlined_bytecodes(num_inlined_bytecodes());\n+  } else {\n+    \/\/ The CodeCache is full.\n+    record_failure(\"code cache is full\");\n@@ -1135,1 +1133,0 @@\n-  \/\/ safepoints are allowed again\n@@ -1137,7 +1134,1 @@\n-  if (StressNMethodRelocation) {\n-    if (nm != nullptr) {\n-      methodHandle mh(Thread::current(), nm->method());\n-      VM_RelocateNMethod relocate(&mh, CodeBlobType::MethodNonProfiled);\n-      VMThread::execute(&relocate);\n-    }\n-  }\n+  \/\/ safepoints are allowed again\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -44,1 +45,1 @@\n-  return SafepointSynchronize::is_at_safepoint() || CompiledIC_lock->owned_by_self();\n+  return SafepointSynchronize::is_at_safepoint() || CompiledIC_lock->owned_by_self() || method->is_not_installed();\n","filename":"src\/hotspot\/share\/code\/codeBehaviours.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -770,1 +770,1 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"clearing of IC's only allowed at safepoint\");\n+  assert(SafepointSynchronize::is_at_safepoint() || is_not_installed(), \"clearing of IC's only allowed at safepoint\");\n@@ -1522,3 +1522,9 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"only called at safepoint\");\n-  assert_lock_strong(CodeCache_lock);\n-  assert_lock_strong(NMethodState_lock);\n+  if (!is_relocatable()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Check if memory should be freed before allocation\n+  CodeCache::gc_on_allocation();\n+\n+  MutexLocker ml_Compile_lock(Compile_lock);\n+  MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n@@ -1529,0 +1535,4 @@\n+  if (nm_copy == nullptr) {\n+    return nullptr;\n+  }\n+\n@@ -1565,0 +1575,1 @@\n+  MutexLocker ml_NMethodState_lock(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n@@ -1568,0 +1579,8 @@\n+\n+#if INCLUDE_JVMCI\n+    if (jvmci_nmethod_data() != nullptr) {\n+      nm_copy->jvmci_nmethod_data()->relocate_nmethod_mirror(nm_copy);\n+      jvmci_nmethod_data()->clear_nmethod_mirror_index();\n+    }\n+#endif\n+\n@@ -1591,0 +1610,11 @@\n+  if (!is_in_use()) {\n+    return false;\n+  }\n+\n+  {\n+    CompiledICLocker ic_locker(this);\n+    if (has_evol_metadata()) {\n+      return false;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -499,2 +499,3 @@\n-  \/\/ Returns nullptr if the code heap does not have enough space, otherwise\n-  \/\/ the relocated nmethod. The original nmethod will be invalidated.\n+  \/\/ Returns nullptr if the code heap does not have enough space or the\n+  \/\/ nmethod is unrelocatable, otherwise the relocated nmethod.\n+  \/\/ The original nmethod will be marked not entrant.\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -384,5 +384,1 @@\n-    address new_addr = addr() + offset;\n-    pd_set_call_destination(new_addr);\n-  } else {\n-    \/\/ Reassert the callee address, this time in the new copy of the code.\n-    pd_set_call_destination(callee);\n+    callee = addr() + offset;\n@@ -390,0 +386,3 @@\n+\n+  \/\/ Reassert the callee address, this time in the new copy of the code.\n+  pd_set_call_destination(callee);\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -140,3 +140,0 @@\n-  product(bool, StressNMethodRelocation, false,                             \\\n-          \"Stress relocation nmethods\")                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -847,0 +847,18 @@\n+void JVMCINMethodData::clear_nmethod_mirror_index() {\n+  _nmethod_mirror_index = -1;\n+}\n+\n+void JVMCINMethodData::relocate_nmethod_mirror(nmethod* nm) {\n+  oop nmethod_mirror = get_nmethod_mirror(nm, \/* phantom_ref *\/ false);\n+  if (nmethod_mirror == nullptr) {\n+    return;\n+  }\n+\n+  JVMCIEnv* jvmciEnv = nullptr;\n+  HotSpotJVMCI::InstalledCode::set_address(jvmciEnv, nmethod_mirror, (jlong)(nm));\n+  HotSpotJVMCI::InstalledCode::set_entryPoint(jvmciEnv, nmethod_mirror, (jlong)(nm->entry_point()));\n+  HotSpotJVMCI::HotSpotInstalledCode::set_size(jvmciEnv, nmethod_mirror, (jlong)(nm->size()));\n+  HotSpotJVMCI::HotSpotInstalledCode::set_codeStart(jvmciEnv, nmethod_mirror, (jlong)(nm->code_begin()));\n+  HotSpotJVMCI::HotSpotInstalledCode::set_codeSize(jvmciEnv, nmethod_mirror, (jlong)(nm->code_size()));\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -124,0 +124,8 @@\n+  \/\/ Used during nmethod relocation to clear the mirror index of the original nmethod.\n+  \/\/ This prevents the original, non-entrant nmethod from interacting with the\n+  \/\/ HotSpotNmethod mirror after relocation.\n+  void clear_nmethod_mirror_index();\n+\n+  \/\/ Updates the HotSpotNmethod fields after nmethod relocation\n+  void relocate_nmethod_mirror(nmethod* nm);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1644,2 +1644,4 @@\n-  VM_RelocateNMethod relocate(&mh, static_cast<CodeBlobType>(blob_type));\n-  VMThread::execute(&relocate);\n+  nmethod* code = mh->code();\n+  if (code != nullptr) {\n+    code->relocate(static_cast<CodeBlobType>(blob_type));\n+  }\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-  template(RelocateNMethod)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,11 +103,0 @@\n-void VM_RelocateNMethod::doit() {\n-  MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-  MutexLocker ml_NMethodState_lock(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n-  if (_mh != nullptr) {\n-    nmethod* nm = (*_mh)()->code();\n-    if (nm != nullptr && nm->is_relocatable()) {\n-      _nm_copy = nm->relocate(_code_blob_type);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"code\/codeBlob.hpp\"\n@@ -85,19 +84,0 @@\n-class VM_RelocateNMethod: public VM_Operation {\n-  private:\n-   methodHandle* _mh;\n-   nmethod* _nm_copy;\n-   CodeBlobType _code_blob_type;\n-  public:\n-   VM_RelocateNMethod(methodHandle* mh, CodeBlobType code_blob_type)\n-     : _mh(mh), _nm_copy(nullptr), _code_blob_type(code_blob_type)\n-   {\n-    Compile_lock->lock();\n-   }\n-   ~VM_RelocateNMethod() {\n-    Compile_lock->unlock();\n-   }\n-   void doit();\n-   VMOp_Type type() const { return VMOp_RelocateNMethod; }\n-   nmethod* getRelocatedNMethod() { return _nm_copy; }\n- };\n-\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"}]}