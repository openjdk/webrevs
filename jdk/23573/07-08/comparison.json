{"files":[{"patch":"@@ -1083,0 +1083,99 @@\n+\/\/ ----- CHeapString -----------------------------------------------------------\n+\n+class CHeapString : public CHeapObj<mtCode> {\n+  public:\n+   CHeapString(const char* str) : _string(os::strdup(str)) {}\n+  ~CHeapString() {\n+     os::free((void*)_string);\n+     _string = nullptr;\n+   }\n+   const char* string() const { return _string; }\n+ \n+  private:\n+   const char* _string;\n+ };\n+ \n+ \/\/ ----- AsmRemarkCollection ---------------------------------------------------\n+ \n+class AsmRemarkCollection : public CHeapObj<mtCode> {\n+public:\n+  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n+~AsmRemarkCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  AsmRemarkCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(uint offset, const char* remark);\n+  const char* lookup(uint offset) const;\n+  const char* next(uint offset) const;\n+\n+  bool is_empty() const { return _remarks == nullptr; }\n+  uint clear();\n+\n+private:\n+  struct Cell : CHeapString {\n+    Cell(const char* remark, uint offset) :\n+        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    uint offset;\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _remarks;\n+  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n+  \/\/ does not change the state of the list per se), supportig a simplistic\n+  \/\/ iteration scheme.\n+  mutable Cell* _next;\n+};\n+\n+\/\/ ----- DbgStringCollection ---------------------------------------------------\n+\n+class DbgStringCollection : public CHeapObj<mtCode> {\n+public:\n+  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n+~DbgStringCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  DbgStringCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(const char* str);\n+  const char* lookup(const char* str) const;\n+\n+  bool is_empty() const { return _strings == nullptr; }\n+  uint clear();\n+\n+private:\n+  struct Cell : CHeapString {\n+    Cell(const char* dbgstr) :\n+        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _strings;\n+};\n+\n@@ -1106,4 +1205,0 @@\n-void AsmRemarks::reuse() {\n-  _remarks->reuse();\n-}\n-\n@@ -1162,4 +1257,0 @@\n-void DbgStrings::reuse() {\n-  _strings->reuse();\n-}\n-\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":99,"deletions":8,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -311,1 +311,0 @@\n-  void reuse();\n@@ -335,1 +334,0 @@\n-  void reuse();\n@@ -346,98 +344,0 @@\n-\/\/ ----- CHeapString -----------------------------------------------------------\n-\n-class CHeapString : public CHeapObj<mtCode> {\n- public:\n-  CHeapString(const char* str) : _string(os::strdup(str)) {}\n- ~CHeapString() {\n-    os::free((void*)_string);\n-    _string = nullptr;\n-  }\n-  const char* string() const { return _string; }\n-\n- private:\n-  const char* _string;\n-};\n-\n-\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n-\n-class AsmRemarkCollection : public CHeapObj<mtCode> {\n- public:\n-  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n- ~AsmRemarkCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  AsmRemarkCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(uint offset, const char* remark);\n-  const char* lookup(uint offset) const;\n-  const char* next(uint offset) const;\n-\n-  bool is_empty() const { return _remarks == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* remark, uint offset) :\n-        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    uint offset;\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _remarks;\n-  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n-  \/\/ does not change the state of the list per se), supportig a simplistic\n-  \/\/ iteration scheme.\n-  mutable Cell* _next;\n-};\n-\n-\/\/ ----- DbgStringCollection ---------------------------------------------------\n-\n-class DbgStringCollection : public CHeapObj<mtCode> {\n- public:\n-  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n- ~DbgStringCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  DbgStringCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(const char* str);\n-  const char* lookup(const char* str) const;\n-\n-  bool is_empty() const { return _strings == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* dbgstr) :\n-        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _strings;\n-};\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":0,"deletions":100,"binary":false,"changes":100,"status":"modified"}]}