{"files":[{"patch":"@@ -1083,99 +1083,0 @@\n-\/\/ ----- CHeapString -----------------------------------------------------------\n-\n-class CHeapString : public CHeapObj<mtCode> {\n- public:\n-  CHeapString(const char* str) : _string(os::strdup(str)) {}\n- ~CHeapString() {\n-    os::free((void*)_string);\n-    _string = nullptr;\n-  }\n-  const char* string() const { return _string; }\n-\n- private:\n-  const char* _string;\n-};\n-\n-\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n-\n-class AsmRemarkCollection : public CHeapObj<mtCode> {\n- public:\n-  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n- ~AsmRemarkCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  AsmRemarkCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(uint offset, const char* remark);\n-  const char* lookup(uint offset) const;\n-  const char* next(uint offset) const;\n-\n-  bool is_empty() const { return _remarks == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* remark, uint offset) :\n-        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    uint offset;\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _remarks;\n-  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n-  \/\/ does not change the state of the list per se), supportig a simplistic\n-  \/\/ iteration scheme.\n-  mutable Cell* _next;\n-};\n-\n-\/\/ ----- DbgStringCollection ---------------------------------------------------\n-\n-class DbgStringCollection : public CHeapObj<mtCode> {\n- public:\n-  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n- ~DbgStringCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  DbgStringCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(const char* str);\n-  const char* lookup(const char* str) const;\n-\n-  bool is_empty() const { return _strings == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* dbgstr) :\n-        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _strings;\n-};\n-\n@@ -1205,0 +1106,4 @@\n+void AsmRemarks::reuse() {\n+  _remarks->reuse();\n+}\n+\n@@ -1257,0 +1162,4 @@\n+void DbgStrings::reuse() {\n+  _strings->reuse();\n+}\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":8,"deletions":99,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -310,0 +310,1 @@\n+  void reuse();\n@@ -333,0 +334,1 @@\n+  void reuse();\n@@ -342,0 +344,100 @@\n+\n+\/\/ ----- CHeapString -----------------------------------------------------------\n+\n+class CHeapString : public CHeapObj<mtCode> {\n+ public:\n+  CHeapString(const char* str) : _string(os::strdup(str)) {}\n+ ~CHeapString() {\n+    os::free((void*)_string);\n+    _string = nullptr;\n+  }\n+  const char* string() const { return _string; }\n+\n+ private:\n+  const char* _string;\n+};\n+\n+\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n+\n+class AsmRemarkCollection : public CHeapObj<mtCode> {\n+ public:\n+  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n+ ~AsmRemarkCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  AsmRemarkCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(uint offset, const char* remark);\n+  const char* lookup(uint offset) const;\n+  const char* next(uint offset) const;\n+\n+  bool is_empty() const { return _remarks == nullptr; }\n+  uint clear();\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* remark, uint offset) :\n+        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    uint offset;\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _remarks;\n+  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n+  \/\/ does not change the state of the list per se), supportig a simplistic\n+  \/\/ iteration scheme.\n+  mutable Cell* _next;\n+};\n+\n+\/\/ ----- DbgStringCollection ---------------------------------------------------\n+\n+class DbgStringCollection : public CHeapObj<mtCode> {\n+ public:\n+  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n+ ~DbgStringCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  DbgStringCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(const char* str);\n+  const char* lookup(const char* str) const;\n+\n+  bool is_empty() const { return _strings == nullptr; }\n+  uint clear();\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* dbgstr) :\n+        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _strings;\n+};\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -1106,1 +1106,1 @@\n-          method->set_code(method, nm, false);\n+          method->set_code(method, nm);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1396,2 +1396,1 @@\n-nmethod::nmethod(nmethod& nm) : CodeBlob(nm.name(), CodeBlobKind::Nmethod, nm.size(), nm.header_size())\n-{\n+nmethod* nmethod::clone(CodeBlobType code_blob_type) {\n@@ -1401,20 +1400,3 @@\n-  if (nm.oop_maps() == nullptr) {\n-    _oop_maps                   = nullptr;\n-  } else {\n-    _oop_maps                   = nm.oop_maps()->clone();\n-  }\n-  _relocation_size              = nm._relocation_size;\n-  _content_offset               = nm._content_offset;\n-  _code_offset                  = nm._code_offset;\n-  _data_offset                  = nm._data_offset;\n-  _frame_size                   = nm._frame_size;\n-  _frame_complete_offset        = nm._frame_complete_offset;\n-  _caller_must_gc_arguments     = nm._caller_must_gc_arguments;\n-\n-  _deoptimization_generation    = nm._deoptimization_generation;\n-\n-  _gc_epoch                     = nm._gc_epoch;\n-\n-  _osr_link                     = nm._osr_link;\n-  _native_receiver_sp_offset    = nm._native_receiver_sp_offset;\n-  _native_basic_lock_sp_offset  = nm._native_basic_lock_sp_offset;\n+  \/\/ Allocate memory in code heap and copy data from nmethod\n+  nmethod* nm_copy = (nmethod*) CodeCache::allocate(size(), code_blob_type);\n+  memcpy(nm_copy, this, size());\n@@ -1423,4 +1405,4 @@\n-  if (nm.immutable_data_size() > 0) {\n-    _immutable_data             = (address)os::malloc(nm.immutable_data_size(), mtCode);\n-    if (_immutable_data == nullptr) {\n-      vm_exit_out_of_memory(nm.immutable_data_size(), OOM_MALLOC_ERROR, \"nmethod: no space for immutable data\");\n+  if (immutable_data_size() > 0) {\n+    nm_copy->_immutable_data = (address)os::malloc(immutable_data_size(), mtCode);\n+    if (nm_copy->_immutable_data == nullptr) {\n+      vm_exit_out_of_memory(immutable_data_size(), OOM_MALLOC_ERROR, \"nmethod: no space for immutable data\");\n@@ -1428,1 +1410,1 @@\n-    memcpy(immutable_data_begin(), nm.immutable_data_begin(), nm.immutable_data_size());\n+    memcpy(nm_copy->immutable_data_begin(), immutable_data_begin(), immutable_data_size());\n@@ -1430,1 +1412,1 @@\n-    _immutable_data             = data_end();\n+    nm_copy->_immutable_data = nm_copy->data_end();\n@@ -1433,70 +1415,0 @@\n-  _exception_cache              = nullptr;\n-\n-  _gc_data                      = nullptr;\n-\n-  _oops_do_mark_nmethods        = nm._oops_do_mark_nmethods;\n-\n-  _oops_do_mark_link            = nm._oops_do_mark_link;\n-\n-  _compiled_ic_data             = nullptr;\n-\n-  _osr_entry_point              = code_begin() + (nm._osr_entry_point - nm.code_begin());\n-  _entry_offset                 = nm._entry_offset;\n-  _verified_entry_offset        = nm._verified_entry_offset;\n-  _entry_bci                    = nm._entry_bci;\n-  _immutable_data_size          = nm._immutable_data_size;\n-\n-  _skipped_instructions_size    = nm._skipped_instructions_size;\n-\n-  _stub_offset                  = nm._stub_offset;\n-\n-  _exception_offset             = nm._exception_offset;\n-\n-  _deopt_handler_offset         = nm._deopt_handler_offset;\n-  _deopt_mh_handler_offset      = nm._deopt_mh_handler_offset;\n-  _unwind_handler_offset        = nm._unwind_handler_offset;\n-\n-  _num_stack_arg_slots          = nm._num_stack_arg_slots;\n-\n-  _oops_size                    = nm._oops_size;\n-\n-#if INCLUDE_JVMCI\n-  _jvmci_data_size              = nm._jvmci_data_size;\n-#endif\n-\n-  _nul_chk_table_offset         = nm._nul_chk_table_offset;\n-  _handler_table_offset         = nm._handler_table_offset;\n-  _scopes_pcs_offset            = nm._scopes_pcs_offset;\n-  _scopes_data_offset           = nm._scopes_data_offset;\n-\n-  if (nm._pc_desc_container == nullptr) {\n-    _pc_desc_container          = nullptr;\n-  } else {\n-    _pc_desc_container          = new PcDescContainer(scopes_pcs_begin());\n-  }\n-\n-#if INCLUDE_JVMCI\n-  _speculations_offset          = nm._speculations_offset;\n-#endif\n-\n-  _orig_pc_offset               = nm._orig_pc_offset;\n-\n-  _compile_id                   = nm._compile_id;\n-  _comp_level                   = nm._comp_level;\n-  _compiler_type                = nm._compiler_type;\n-\n-  _is_unloading_state           = nm._is_unloading_state;\n-\n-  _state                        = nm._state;\n-\n-  _has_unsafe_access            = nm._has_method_handle_invokes;\n-  _has_method_handle_invokes    = nm._has_method_handle_invokes;\n-  _has_wide_vectors             = nm._has_wide_vectors;\n-  _has_monitors                 = nm._has_monitors;\n-  _has_scoped_access            = nm._has_scoped_access;\n-  _has_flushed_dependencies     = nm._has_flushed_dependencies;\n-  _is_unlinked                  = nm._is_unlinked;\n-  _load_reported                = nm._load_reported;\n-\n-  _deoptimization_status        = nm._deoptimization_status;\n-\n@@ -1504,1 +1416,0 @@\n-  _mutable_data_size            = nm._mutable_data_size;\n@@ -1506,1 +1417,1 @@\n-    _mutable_data               = (address)os::malloc(_mutable_data_size, mtCode);\n+    nm_copy->_mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n@@ -1510,1 +1421,1 @@\n-    memcpy(mutable_data_begin(), nm.mutable_data_begin(), nm.mutable_data_size());\n+    memcpy(nm_copy->mutable_data_begin(), mutable_data_begin(), mutable_data_size());\n@@ -1513,2 +1424,4 @@\n-  \/\/ Copy all nmethod data outside of header\n-  memcpy(content_begin(), nm.content_begin(), nm.size() - nm.header_size());\n+  \/\/ Fix new nmethod specific data\n+  if (oop_maps() != nullptr) {\n+    nm_copy->_oop_maps = oop_maps()->clone();\n+  }\n@@ -1516,3 +1429,17 @@\n-  RelocIterator iter(this);\n-  CodeBuffer src((CodeBlob *)&nm);\n-  CodeBuffer dst(this);\n+  nm_copy->_exception_cache = nullptr;\n+  nm_copy->_gc_data = nullptr;\n+  nm_copy->_compiled_ic_data = nullptr;\n+\n+  if (_pc_desc_container != nullptr) {\n+    nm_copy->_pc_desc_container = new PcDescContainer(nm_copy->scopes_pcs_begin());\n+  }\n+\n+#ifndef PRODUCT\n+  _asm_remarks.reuse();\n+  _dbg_strings.reuse();\n+#endif\n+\n+  \/\/ Fix relocation\n+  RelocIterator iter(nm_copy);\n+  CodeBuffer src((CodeBlob *)this);\n+  CodeBuffer dst(nm_copy);\n@@ -1523,1 +1450,1 @@\n-  ICache::invalidate_range(code_begin(), code_size());\n+  ICache::invalidate_range(nm_copy->code_begin(), nm_copy->code_size());\n@@ -1525,1 +1452,1 @@\n-  _method                       = nm._method;\n+  nm_copy->post_init();\n@@ -1527,8 +1454,1 @@\n-  post_init();\n-\n-  \/\/ Update corresponding Java method to point to this nmethod\n-  MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n-  if (_method != nullptr && _method->code() == &nm) {\n-    methodHandle mh(Thread::current(), _method);\n-    _method->set_code(mh, this, true);\n-  }\n+  return nm_copy;\n@@ -1555,1 +1475,1 @@\n-    nm_copy = new (nm->size(), code_blob_type) nmethod(*nm);\n+    nm_copy = nm->clone(code_blob_type);\n@@ -1580,0 +1500,8 @@\n+\n+      \/\/ Update corresponding Java method to point to this nmethod\n+      MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n+      if (nm_copy->method()->code() == nm) {\n+        methodHandle mh(Thread::current(), nm_copy->method());\n+        nm_copy->method()->set_code(mh, nm_copy);\n+        nm->make_not_used();\n+      }\n@@ -1590,2 +1518,0 @@\n-  nm->make_not_used();\n-\n@@ -1604,5 +1530,1 @@\n-  if (method()->is_method_handle_intrinsic()) {\n-    return false;\n-  }\n-\n-  if (method()->is_continuation_native_intrinsic()) {\n+  if (!is_java_method()) {\n@@ -1619,4 +1541,0 @@\n-void* nmethod::operator new(size_t size, int nmethod_size, CodeBlobType code_blob_type) throw () {\n-  return CodeCache::allocate(nmethod_size, code_blob_type);\n-}\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":46,"deletions":128,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -338,3 +338,0 @@\n-  \/\/ Create nmethod in a specific code heap\n-  void* operator new(size_t size, int nmethod_size, CodeBlobType code_blob_type) throw();\n-\n@@ -349,0 +346,2 @@\n+  nmethod* clone(CodeBlobType code_blob_type);\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2212,1 +2212,1 @@\n-              method->set_code(method, nm, false);\n+              method->set_code(method, nm);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1274,1 +1274,1 @@\n-void Method::set_code(const methodHandle& mh, nmethod *code, bool isRelocation) {\n+void Method::set_code(const methodHandle& mh, nmethod *code) {\n@@ -1298,1 +1298,1 @@\n-    assert(mh->_from_interpreted_entry == nullptr || isRelocation, \"initialized incorrectly\"); \/\/ see link_method\n+    assert(mh->_from_interpreted_entry == nullptr, \"initialized incorrectly\"); \/\/ see link_method\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-  static void set_code(const methodHandle& mh, nmethod* code, bool isRelocation);\n+  static void set_code(const methodHandle& mh, nmethod* code);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2852,1 +2852,1 @@\n-            method->set_code(method, nm, false);\n+            method->set_code(method, nm);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}