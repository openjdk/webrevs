{"files":[{"patch":"@@ -1171,1 +1171,1 @@\n-    + align_up(sizeof(int)                       , oopSize);\n+    + align_up((int)sizeof(int)                  , oopSize);\n@@ -1398,2 +1398,1 @@\n-  debug_only(NoSafepointVerifier nsv;)\n-  assert_locked_or_safepoint(CodeCache_lock);\n+  assert(SafepointSynchronize::is_at_safepoint(), \"only called at safepoint\");\n@@ -1451,0 +1450,32 @@\n+  nm_copy->clear_inline_caches();\n+\n+  \/\/ Update corresponding Java method to point to this nmethod\n+  if (nm_copy->method()->code() == this) {\n+    MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n+    methodHandle mh(Thread::current(), nm_copy->method());\n+    nm_copy->method()->set_code(mh, nm_copy);\n+  }\n+\n+  \/\/ To make dependency checking during class loading fast, record\n+  \/\/ the nmethod dependencies in the classes it is dependent on.\n+  \/\/ This allows the dependency checking code to simply walk the\n+  \/\/ class hierarchy above the loaded class, checking only nmethods\n+  \/\/ which are dependent on those classes.  The slow way is to\n+  \/\/ check every nmethod for dependencies which makes it linear in\n+  \/\/ the number of methods compiled.  For applications with a lot\n+  \/\/ classes the slow way is too slow.\n+  for (Dependencies::DepStream deps(nm_copy); deps.next(); ) {\n+    if (deps.type() == Dependencies::call_site_target_value) {\n+      \/\/ CallSite dependencies are managed on per-CallSite instance basis.\n+      oop call_site = deps.argument_oop(0);\n+      MethodHandles::add_dependent_nmethod(call_site, nm_copy);\n+    } else {\n+      InstanceKlass* ik = deps.context_type();\n+      if (ik == nullptr) {\n+        continue;  \/\/ ignore things like evol_method\n+      }\n+      \/\/ record this nmethod as dependent on this klass\n+      ik->add_dependent_nmethod(nm_copy);\n+    }\n+  }\n+\n@@ -1453,0 +1484,2 @@\n+  make_not_used();\n+\n@@ -1457,37 +1490,4 @@\n-  if (nm == nullptr || !nm->is_relocatable()) {\n-    return nullptr;\n-  }\n-\n-  nmethod* nm_copy = nullptr;\n-\n-  {\n-    \/\/ Clear inline caches before acquiring any locks\n-    VM_ClearNMethodICs clear_nmethod_ics(nm);\n-    VMThread::execute(&clear_nmethod_ics);\n-\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n-    nm_copy = nm->clone(code_blob_type);\n-\n-    if (nm_copy != nullptr) {\n-      \/\/ To make dependency checking during class loading fast, record\n-      \/\/ the nmethod dependencies in the classes it is dependent on.\n-      \/\/ This allows the dependency checking code to simply walk the\n-      \/\/ class hierarchy above the loaded class, checking only nmethods\n-      \/\/ which are dependent on those classes.  The slow way is to\n-      \/\/ check every nmethod for dependencies which makes it linear in\n-      \/\/ the number of methods compiled.  For applications with a lot\n-      \/\/ classes the slow way is too slow.\n-      for (Dependencies::DepStream deps(nm_copy); deps.next(); ) {\n-        if (deps.type() == Dependencies::call_site_target_value) {\n-          \/\/ CallSite dependencies are managed on per-CallSite instance basis.\n-          oop call_site = deps.argument_oop(0);\n-          MethodHandles::add_dependent_nmethod(call_site, nm_copy);\n-        } else {\n-          InstanceKlass* ik = deps.context_type();\n-          if (ik == nullptr) {\n-            continue;  \/\/ ignore things like evol_method\n-          }\n-          \/\/ record this nmethod as dependent on this klass\n-          ik->add_dependent_nmethod(nm_copy);\n-        }\n-      }\n+  \/\/ Relocate nmethod at safepoint\n+  VM_RelocateNMethod relocate_nmethod(nm, code_blob_type);\n+  VMThread::execute(&relocate_nmethod);\n+  nmethod* nm_copy = relocate_nmethod.getRelocatedNMethod();\n@@ -1495,10 +1495,1 @@\n-      \/\/ Update corresponding Java method to point to this nmethod\n-      MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n-      if (nm_copy->method()->code() == nm) {\n-        methodHandle mh(Thread::current(), nm_copy->method());\n-        nm_copy->method()->set_code(mh, nm_copy);\n-        nm->make_not_used();\n-      }\n-    }\n-  }\n-  \/\/ Do verification and logging outside CodeCache_lock.\n+  \/\/ Do verification and logging outside safepoint\n@@ -1507,1 +1498,0 @@\n-    \/\/ Safepoints in nmethod::verify aren't allowed because nm_copy hasn't been installed yet.\n@@ -1663,1 +1653,1 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset + align_up(speculations_len, oopSize) + align_up(sizeof(int), oopSize); )\n+    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset + align_up(speculations_len, oopSize) + align_up((int)sizeof(int), oopSize); )\n@@ -1665,1 +1655,1 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize) + align_up(sizeof(int), oopSize); )\n+    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize) + align_up((int)sizeof(int), oopSize); )\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":43,"deletions":53,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -345,2 +345,0 @@\n-  nmethod* clone(CodeBlobType code_blob_type);\n-\n@@ -497,0 +495,1 @@\n+  nmethod* clone(CodeBlobType code_blob_type);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  template(ClearNMethodICs)                       \\\n+  template(RelocateNMethod)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,2 +103,5 @@\n-void VM_ClearNMethodICs::doit() {\n-  _nm->clear_inline_caches();\n+void VM_RelocateNMethod::doit() {\n+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+  if (_nm != nullptr && _nm->is_relocatable()) {\n+    _nm_copy = _nm->clone(_code_blob_type);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/codeBlob.hpp\"\n@@ -84,1 +85,1 @@\n-class VM_ClearNMethodICs: public VM_Operation {\n+class VM_RelocateNMethod: public VM_Operation {\n@@ -87,0 +88,2 @@\n+   nmethod* _nm_copy;\n+   CodeBlobType _code_blob_type;\n@@ -88,1 +91,3 @@\n-   VM_ClearNMethodICs(nmethod* nm) { _nm = nm; }\n+   VM_RelocateNMethod(nmethod* nm, CodeBlobType code_blob_type)\n+    : _nm(nm), _nm_copy(nullptr), _code_blob_type(code_blob_type)\n+   {}\n@@ -90,1 +95,2 @@\n-   VMOp_Type type() const { return VMOp_ClearNMethodICs; }\n+   VMOp_Type type() const { return VMOp_RelocateNMethod; }\n+   nmethod* getRelocatedNMethod() { return _nm_copy; }\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"}]}