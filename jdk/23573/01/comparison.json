{"files":[{"patch":"@@ -93,1 +93,0 @@\n-  assert(call->raw_destination() == owner(), \"destination should be empty\");\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1083,99 +1083,0 @@\n-\/\/ ----- CHeapString -----------------------------------------------------------\n-\n-class CHeapString : public CHeapObj<mtCode> {\n- public:\n-  CHeapString(const char* str) : _string(os::strdup(str)) {}\n- ~CHeapString() {\n-    os::free((void*)_string);\n-    _string = nullptr;\n-  }\n-  const char* string() const { return _string; }\n-\n- private:\n-  const char* _string;\n-};\n-\n-\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n-\n-class AsmRemarkCollection : public CHeapObj<mtCode> {\n- public:\n-  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n- ~AsmRemarkCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  AsmRemarkCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(uint offset, const char* remark);\n-  const char* lookup(uint offset) const;\n-  const char* next(uint offset) const;\n-\n-  bool is_empty() const { return _remarks == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* remark, uint offset) :\n-        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    uint offset;\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _remarks;\n-  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n-  \/\/ does not change the state of the list per se), supportig a simplistic\n-  \/\/ iteration scheme.\n-  mutable Cell* _next;\n-};\n-\n-\/\/ ----- DbgStringCollection ---------------------------------------------------\n-\n-class DbgStringCollection : public CHeapObj<mtCode> {\n- public:\n-  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n- ~DbgStringCollection() {\n-    assert(is_empty(), \"Must 'clear()' before deleting!\");\n-    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n-  }\n-  DbgStringCollection* reuse() {\n-    precond(_ref_cnt > 0);\n-    return _ref_cnt++, this;\n-  }\n-\n-  const char* insert(const char* str);\n-  const char* lookup(const char* str) const;\n-\n-  bool is_empty() const { return _strings == nullptr; }\n-  uint clear();\n-\n- private:\n-  struct Cell : CHeapString {\n-    Cell(const char* dbgstr) :\n-        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n-    void push_back(Cell* cell) {\n-      Cell* head = this;\n-      Cell* tail = prev;\n-      tail->next = cell;\n-      cell->next = head;\n-      cell->prev = tail;\n-      prev = cell;\n-    }\n-    Cell* prev;\n-    Cell* next;\n-  };\n-  uint  _ref_cnt;\n-  Cell* _strings;\n-};\n-\n@@ -1205,0 +1106,4 @@\n+void AsmRemarks::reuse() {\n+  _remarks->reuse();\n+}\n+\n@@ -1257,0 +1162,4 @@\n+void DbgStrings::reuse() {\n+  _strings->reuse();\n+}\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":8,"deletions":99,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -310,0 +310,1 @@\n+  void reuse();\n@@ -333,0 +334,1 @@\n+  void reuse();\n@@ -342,0 +344,100 @@\n+\n+\/\/ ----- CHeapString -----------------------------------------------------------\n+\n+class CHeapString : public CHeapObj<mtCode> {\n+ public:\n+  CHeapString(const char* str) : _string(os::strdup(str)) {}\n+ ~CHeapString() {\n+    os::free((void*)_string);\n+    _string = nullptr;\n+  }\n+  const char* string() const { return _string; }\n+\n+ private:\n+  const char* _string;\n+};\n+\n+\/\/ ----- AsmRemarkCollection ---------------------------------------------------\n+\n+class AsmRemarkCollection : public CHeapObj<mtCode> {\n+ public:\n+  AsmRemarkCollection() : _ref_cnt(1), _remarks(nullptr), _next(nullptr) {}\n+ ~AsmRemarkCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  AsmRemarkCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(uint offset, const char* remark);\n+  const char* lookup(uint offset) const;\n+  const char* next(uint offset) const;\n+\n+  bool is_empty() const { return _remarks == nullptr; }\n+  uint clear();\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* remark, uint offset) :\n+        CHeapString(remark), offset(offset), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    uint offset;\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _remarks;\n+  \/\/ Using a 'mutable' iteration pointer to allow 'const' on lookup\/next (that\n+  \/\/ does not change the state of the list per se), supportig a simplistic\n+  \/\/ iteration scheme.\n+  mutable Cell* _next;\n+};\n+\n+\/\/ ----- DbgStringCollection ---------------------------------------------------\n+\n+class DbgStringCollection : public CHeapObj<mtCode> {\n+ public:\n+  DbgStringCollection() : _ref_cnt(1), _strings(nullptr) {}\n+ ~DbgStringCollection() {\n+    assert(is_empty(), \"Must 'clear()' before deleting!\");\n+    assert(_ref_cnt == 0, \"No uses must remain when deleting!\");\n+  }\n+  DbgStringCollection* reuse() {\n+    precond(_ref_cnt > 0);\n+    return _ref_cnt++, this;\n+  }\n+\n+  const char* insert(const char* str);\n+  const char* lookup(const char* str) const;\n+\n+  bool is_empty() const { return _strings == nullptr; }\n+  uint clear();\n+\n+ private:\n+  struct Cell : CHeapString {\n+    Cell(const char* dbgstr) :\n+        CHeapString(dbgstr), prev(nullptr), next(nullptr) {}\n+    void push_back(Cell* cell) {\n+      Cell* head = this;\n+      Cell* tail = prev;\n+      tail->next = cell;\n+      cell->next = head;\n+      cell->prev = tail;\n+      prev = cell;\n+    }\n+    Cell* prev;\n+    Cell* next;\n+  };\n+  uint  _ref_cnt;\n+  Cell* _strings;\n+};\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-  static CodeHeap* get_code_heap_containing(void* p);         \/\/ Returns the CodeHeap containing the given pointer, or nullptr\n@@ -164,0 +163,1 @@\n+  static CodeHeap* get_code_heap_containing(void* p);   \/\/ Returns the CodeHeap containing the given pointer, or nullptr\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1396,0 +1396,145 @@\n+nmethod* nmethod::clone(CodeBlobType code_blob_type) {\n+  debug_only(NoSafepointVerifier nsv;)\n+  assert_locked_or_safepoint(CodeCache_lock);\n+\n+  \/\/ Allocate memory in code heap and copy data from nmethod\n+  nmethod* nm_copy = (nmethod*) CodeCache::allocate(size(), code_blob_type);\n+  memcpy(nm_copy, this, size());\n+\n+  \/\/ Allocate memory and copy immutable data from C heap\n+  if (immutable_data_size() > 0) {\n+    nm_copy->_immutable_data = (address)os::malloc(immutable_data_size(), mtCode);\n+    if (nm_copy->_immutable_data == nullptr) {\n+      vm_exit_out_of_memory(immutable_data_size(), OOM_MALLOC_ERROR, \"nmethod: no space for immutable data\");\n+    }\n+    memcpy(nm_copy->immutable_data_begin(), immutable_data_begin(), immutable_data_size());\n+  } else {\n+    nm_copy->_immutable_data = nm_copy->data_end();\n+  }\n+\n+  \/\/ Allocate memory and copy mutable data from C heap\n+  if (_mutable_data_size > 0) {\n+    nm_copy->_mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n+    if (_mutable_data == nullptr) {\n+      vm_exit_out_of_memory(_mutable_data_size, OOM_MALLOC_ERROR, \"nmethod: no space for mutable data\");\n+    }\n+    memcpy(nm_copy->mutable_data_begin(), mutable_data_begin(), mutable_data_size());\n+  }\n+\n+  \/\/ Fix new nmethod specific data\n+  if (oop_maps() != nullptr) {\n+    nm_copy->_oop_maps = oop_maps()->clone();\n+  }\n+\n+  nm_copy->_exception_cache = nullptr;\n+  nm_copy->_gc_data = nullptr;\n+  nm_copy->_compiled_ic_data = nullptr;\n+\n+  if (_pc_desc_container != nullptr) {\n+    nm_copy->_pc_desc_container = new PcDescContainer(nm_copy->scopes_pcs_begin());\n+  }\n+\n+#ifndef PRODUCT\n+  _asm_remarks.reuse();\n+  _dbg_strings.reuse();\n+#endif\n+\n+  \/\/ Fix relocation\n+  RelocIterator iter(nm_copy);\n+  CodeBuffer src((CodeBlob *)this);\n+  CodeBuffer dst(nm_copy);\n+  while (iter.next()) {\n+    iter.reloc()->fix_relocation_after_move(&src, &dst);\n+  }\n+\n+  ICache::invalidate_range(nm_copy->code_begin(), nm_copy->code_size());\n+\n+  nm_copy->post_init();\n+\n+  return nm_copy;\n+}\n+\n+nmethod* nmethod::relocate_to(nmethod* nm, CodeBlobType code_blob_type) {\n+  if (nm == nullptr || !nm->is_relocatable()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ No need to relocate if already in correct code heap\n+  if (nm->lookup_code_blob_type() == code_blob_type) {\n+    return nm;\n+  }\n+\n+  nmethod* nm_copy = nullptr;\n+\n+  {\n+    \/\/ Clear inline caches before acquiring any locks\n+    VM_ClearNMethodICs clear_nmethod_ics(nm);\n+    VMThread::execute(&clear_nmethod_ics);\n+\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    nm_copy = nm->clone(code_blob_type);\n+\n+    if (nm_copy != nullptr) {\n+      \/\/ To make dependency checking during class loading fast, record\n+      \/\/ the nmethod dependencies in the classes it is dependent on.\n+      \/\/ This allows the dependency checking code to simply walk the\n+      \/\/ class hierarchy above the loaded class, checking only nmethods\n+      \/\/ which are dependent on those classes.  The slow way is to\n+      \/\/ check every nmethod for dependencies which makes it linear in\n+      \/\/ the number of methods compiled.  For applications with a lot\n+      \/\/ classes the slow way is too slow.\n+      for (Dependencies::DepStream deps(nm_copy); deps.next(); ) {\n+        if (deps.type() == Dependencies::call_site_target_value) {\n+          \/\/ CallSite dependencies are managed on per-CallSite instance basis.\n+          oop call_site = deps.argument_oop(0);\n+          MethodHandles::add_dependent_nmethod(call_site, nm_copy);\n+        } else {\n+          InstanceKlass* ik = deps.context_type();\n+          if (ik == nullptr) {\n+            continue;  \/\/ ignore things like evol_method\n+          }\n+          \/\/ record this nmethod as dependent on this klass\n+          ik->add_dependent_nmethod(nm_copy);\n+        }\n+      }\n+\n+      \/\/ Update corresponding Java method to point to this nmethod\n+      MutexLocker ml(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n+      if (nm_copy->method()->code() == nm) {\n+        methodHandle mh(Thread::current(), nm_copy->method());\n+        nm_copy->method()->set_code(mh, nm_copy);\n+        nm->make_not_used();\n+      }\n+    }\n+  }\n+  \/\/ Do verification and logging outside CodeCache_lock.\n+  if (nm_copy != nullptr) {\n+    NOT_PRODUCT(note_java_nmethod(nm_copy));\n+    \/\/ Safepoints in nmethod::verify aren't allowed because nm_copy hasn't been installed yet.\n+    DEBUG_ONLY(nm_copy->verify();)\n+    nm_copy->log_new_nmethod();\n+  }\n+\n+  return nm_copy;\n+}\n+\n+bool nmethod::is_relocatable() const {\n+  if (is_not_entrant()) {\n+    return false;\n+  }\n+\n+  if (is_osr_method()) {\n+    return false;\n+  }\n+\n+  if (!is_java_method()) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+CodeBlobType nmethod::lookup_code_blob_type() {\n+  return CodeCache::get_code_heap_containing(this)->code_blob_type();\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":145,"deletions":0,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -336,0 +336,2 @@\n+  nmethod(nmethod& nm);\n+\n@@ -344,0 +346,2 @@\n+  nmethod* clone(CodeBlobType code_blob_type);\n+\n@@ -494,0 +498,7 @@\n+\n+  \/\/ Relocate the nmethod to the code heap identified by code_blob_type.\n+  \/\/ Returns nullptr if the code heap does not have enough space, otherwise\n+  \/\/ the relocated nmethod. The original nmethod will be invalidated.\n+  \/\/ If nm is already in the needed code heap, it is not relocated and the function returns it.\n+  static nmethod* relocate_to(nmethod* nm, CodeBlobType code_blob_type);\n+\n@@ -510,0 +521,4 @@\n+  bool is_relocatable() const;\n+\n+  CodeBlobType lookup_code_blob_type();\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -379,0 +379,2 @@\n+  \/\/ We either relocate a nmethod residing in CodeCache or just generated code from CodeBuffer\n+  assert(src->blob() == nullptr || nativeCall_at(owner())->raw_destination() == owner(), \"destination should be empty\");\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -867,0 +867,6 @@\n+ImmutableOopMapSet* ImmutableOopMapSet::clone() const {\n+  address buffer = NEW_C_HEAP_ARRAY(unsigned char, _size, mtCode);\n+  memcpy(buffer, (address)this, _size);\n+  return (ImmutableOopMapSet*)buffer;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -353,0 +353,2 @@\n+  ImmutableOopMapSet* clone() const;\n+\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1627,0 +1627,48 @@\n+WB_ENTRY(void, WB_RelocateNMethodTo(JNIEnv* env, jobject o, jobject method, jint blob_type))\n+  ResourceMark rm(THREAD);\n+  jmethodID jmid = reflected_method_to_jmid(thread, env, method);\n+  CHECK_JNI_EXCEPTION(env);\n+  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+  nmethod* code = mh->code();\n+  if (code == nullptr) {\n+    return;\n+  }\n+\n+  nmethod::relocate_to(code, static_cast<CodeBlobType>(blob_type));\n+WB_END\n+\n+WB_ENTRY(void, WB_RelocateAllNMethods(JNIEnv* env))\n+  ResourceMark rm(THREAD);\n+\n+  \/\/ Get all nmethods in heap\n+  GrowableArray<nmethod*> nmethods;\n+  for (int codeBlobTypeIndex = 0; codeBlobTypeIndex < (int) CodeBlobType::NumTypes; codeBlobTypeIndex++) {\n+    CodeHeap* heap;\n+    {\n+      MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+      heap = WhiteBox::get_code_heap(static_cast<CodeBlobType>(codeBlobTypeIndex));\n+      if (heap == nullptr) {\n+        continue;\n+      }\n+    }\n+\n+    for (CodeBlob* cb = (CodeBlob*) heap->first(); cb != nullptr; cb = (CodeBlob*) heap->next(cb)) {\n+      if (cb->is_nmethod()) {\n+        nmethods.append(cb->as_nmethod());\n+      }\n+    }\n+\n+    if (!SegmentedCodeCache) {\n+      break;\n+    }\n+  }\n+\n+  \/\/ Replace all\n+  for (GrowableArrayIterator<nmethod*> it = nmethods.begin(); it != nmethods.end(); ++it) {\n+    \/\/ Destination should be different than current location\n+    CodeBlobType code_cache_dest = (*it)->lookup_code_blob_type() == CodeBlobType::MethodNonProfiled ? CodeBlobType::MethodProfiled : CodeBlobType::MethodNonProfiled;\n+    nmethod::relocate_to(*it, code_cache_dest);\n+  }\n+\n+WB_END\n+\n@@ -2870,0 +2918,3 @@\n+  {CC\"relocateNMethodTo0\", CC\"(Ljava\/lang\/reflect\/Executable;I)V\",\n+                                                      (void*)&WB_RelocateNMethodTo  },\n+  {CC\"relocateAllNMethods\", CC\"()V\",                  (void*)&WB_RelocateAllNMethods},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  template(ClearNMethodICs)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,0 +103,4 @@\n+void VM_ClearNMethodICs::doit() {\n+  _nm->clear_inline_caches();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,0 +84,9 @@\n+class VM_ClearNMethodICs: public VM_Operation {\n+  private:\n+   nmethod* _nm;\n+  public:\n+   VM_ClearNMethodICs(nmethod* nm) { _nm = nm; }\n+   void doit();\n+   VMOp_Type type() const { return VMOp_ClearNMethodICs; }\n+ };\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -224,2 +224,15 @@\n-        if (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n-            throw new RuntimeException(method + \" must not be in queue\");\n+        checkNotCompiled(method, isOsr);\n+    }\n+\n+    \/**\n+     * Checks, that the specified executable is not (OSR-)compiled.\n+     *\n+     * @param executable The method or constructor to check.\n+     * @param isOsr Check for OSR compilation if true\n+     * @throws RuntimeException if {@linkplain #method} is in compiler queue or\n+     *                          is compiled, or if {@linkplain #method} has zero\n+     *                          compilation level.\n+     *\/\n+    protected static final void checkNotCompiled(Executable executable, boolean isOsr) {\n+        if (WHITE_BOX.isMethodQueuedForCompilation(executable)) {\n+            throw new RuntimeException(executable + \" must not be in queue\");\n@@ -227,2 +240,2 @@\n-        if (WHITE_BOX.isMethodCompiled(method, isOsr)) {\n-            throw new RuntimeException(method + \" must not be \" +\n+        if (WHITE_BOX.isMethodCompiled(executable, isOsr)) {\n+            throw new RuntimeException(executable + \" must not be \" +\n@@ -231,2 +244,2 @@\n-        if (WHITE_BOX.getMethodCompilationLevel(method, isOsr) != 0) {\n-            throw new RuntimeException(method + (isOsr ? \" osr_\" : \" \") +\n+        if (WHITE_BOX.getMethodCompilationLevel(executable, isOsr) != 0) {\n+            throw new RuntimeException(executable + (isOsr ? \" osr_\" : \" \") +\n@@ -245,0 +258,13 @@\n+        checkCompiled(method, testCase.isOsr());\n+    }\n+\n+    \/**\n+     * Checks, that the specified executable is compiled.\n+     *\n+     * @param executable The method or constructor to check.\n+     * @param isOsr Check for OSR compilation if true\n+     * @throws RuntimeException if {@linkplain #method} isn't in compiler queue\n+     *                          and isn't compiled, or if {@linkplain #method}\n+     *                          has nonzero compilation level\n+     *\/\n+    protected static final void checkCompiled(Executable executable, boolean isOsr) {\n@@ -246,2 +272,2 @@\n-        waitBackgroundCompilation();\n-        if (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n+        waitBackgroundCompilation(executable);\n+        if (WHITE_BOX.isMethodQueuedForCompilation(executable)) {\n@@ -249,1 +275,1 @@\n-                    method, System.currentTimeMillis() - start);\n+                    executable, System.currentTimeMillis() - start);\n@@ -252,3 +278,3 @@\n-        if (!WHITE_BOX.isMethodCompiled(method, testCase.isOsr())) {\n-            throw new RuntimeException(method + \" must be \"\n-                    + (testCase.isOsr() ? \"osr_\" : \"\") + \"compiled\");\n+        if (!WHITE_BOX.isMethodCompiled(executable, isOsr)) {\n+            throw new RuntimeException(executable + \" must be \"\n+                    + (isOsr ? \"osr_\" : \"\") + \"compiled\");\n@@ -256,1 +282,1 @@\n-        if (WHITE_BOX.getMethodCompilationLevel(method, testCase.isOsr())\n+        if (WHITE_BOX.getMethodCompilationLevel(executable, isOsr)\n@@ -258,2 +284,2 @@\n-            throw new RuntimeException(method\n-                    + (testCase.isOsr() ? \" osr_\" : \" \")\n+            throw new RuntimeException(executable\n+                    + (isOsr ? \" osr_\" : \" \")\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/CompilerWhiteBoxTest.java","additions":41,"deletions":15,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseSerialGC compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseParallelGC compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseG1GC compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseShenandoahGC compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseZGC compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import java.lang.reflect.Method;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+\n+public class DeoptimizeRelocatedNMethod {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    public static double FUNCTION_RESULT = 0;\n+\n+    public static void main(String [] args) throws Exception {\n+        \/\/ Get method that will be relocated\n+        Method method = DeoptimizeRelocatedNMethod.class.getMethod(\"function\");\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+\n+        \/\/ Verify not initially compiled\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+\n+        \/\/ Call function enough to compile\n+        callFunction();\n+\n+        \/\/ Verify now compiled\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get newly created nmethod\n+        NMethod origNmethod = NMethod.get(method, false);\n+\n+        \/\/ Relocate nmethod and mark old for cleanup\n+        WHITE_BOX.relocateNMethodTo(method, BlobType.MethodProfiled.id);\n+\n+        \/\/ Trigger GC to clean up old nmethod\n+        WHITE_BOX.fullGC();\n+\n+        \/\/ Verify function still compiled after old was cleaned up\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get new nmethod and verify it's actually new\n+        NMethod newNmethod = NMethod.get(method, false);\n+        if (origNmethod.entry_point == newNmethod.entry_point) {\n+            throw new RuntimeException(\"Did not create new nmethod\");\n+        }\n+\n+        \/\/ Deoptimized method\n+        WHITE_BOX.deoptimizeMethod(method);\n+\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+\n+        \/\/ Call to verify everything still works\n+        function();\n+    }\n+\n+    \/\/ Call function multiple times to trigger compilation\n+    private static void callFunction() {\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD; i++) {\n+            function();\n+        }\n+    }\n+\n+    public static void function() {\n+        FUNCTION_RESULT = Math.random();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeRelocatedNMethod.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @bug 8316694\n+ * @summary Relocates all nmethods and runs garbage collector to cleanup old versions\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache -XX:+UseSerialGC compiler.whitebox.RelocateAllNMethods\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @bug 8316694\n+ * @summary Relocates all nmethods and runs garbage collector to cleanup old versions\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache -XX:+UseParallelGC compiler.whitebox.RelocateAllNMethods\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @bug 8316694\n+ * @summary Relocates all nmethods and runs garbage collector to cleanup old versions\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache -XX:+UseG1GC compiler.whitebox.RelocateAllNMethods\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @bug 8316694\n+ * @summary Relocates all nmethods and runs garbage collector to cleanup old versions\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache -XX:+UseShenandoahGC compiler.whitebox.RelocateAllNMethods\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8316694\n+ * @summary Relocates all nmethods and runs garbage collector to cleanup old versions\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache -XX:+UseZGC compiler.whitebox.RelocateAllNMethods\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class RelocateAllNMethods {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    public static void main(String [] args) throws Exception {\n+        WHITE_BOX.relocateAllNMethods();\n+\n+        WHITE_BOX.fullGC();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/RelocateAllNMethods.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @bug 8316694\n+ * @summary Relocates all nmethods and also deoptimizes to confirm no crashes\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache -XX:+UseSerialGC compiler.whitebox.RelocateAndDeoptmizeAllNMethods\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @bug 8316694\n+ * @summary Relocates all nmethods and also deoptimizes to confirm no crashes\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache -XX:+UseParallelGC compiler.whitebox.RelocateAndDeoptmizeAllNMethods\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @bug 8316694\n+ * @summary Relocates all nmethods and also deoptimizes to confirm no crashes\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache -XX:+UseG1GC compiler.whitebox.RelocateAndDeoptmizeAllNMethods\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @bug 8316694\n+ * @summary Relocates all nmethods and also deoptimizes to confirm no crashes\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache -XX:+UseShenandoahGC compiler.whitebox.RelocateAndDeoptmizeAllNMethods\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8316694\n+ * @summary Relocates all nmethods and also deoptimizes to confirm no crashes\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+SegmentedCodeCache -XX:+UseZGC compiler.whitebox.RelocateAndDeoptmizeAllNMethods\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class RelocateAndDeoptmizeAllNMethods {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    public static void main(String [] args) throws Exception {\n+        WHITE_BOX.relocateAllNMethods();\n+\n+        WHITE_BOX.fullGC();\n+\n+        WHITE_BOX.deoptimizeAll();\n+\n+        WHITE_BOX.fullGC();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/RelocateAndDeoptmizeAllNMethods.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @bug 8316694\n+ * @summary test that WB::relocateNMethodTo() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseSerialGC compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @bug 8316694\n+ * @summary test that WB::relocateNMethodTo() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseParallelGC compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @bug 8316694\n+ * @summary test that WB::relocateNMethodTo() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseG1GC compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @bug 8316694\n+ * @summary test that WB::relocateNMethodTo() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseShenandoahGC compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8316694\n+ * @summary test that WB::relocateNMethodTo() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseZGC compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import java.lang.reflect.Method;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+public class RelocateNMethod extends CompilerWhiteBoxTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        CompilerWhiteBoxTest.main(RelocateNMethod::new, new String[] {\"CONSTRUCTOR_TEST\", \"METHOD_TEST\", \"STATIC_TEST\"});\n+    }\n+\n+    private RelocateNMethod(TestCase testCase) {\n+        super(testCase);\n+        \/\/ to prevent inlining of #method\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+    }\n+\n+    @Override\n+    protected void test() throws Exception {\n+        checkNotCompiled();\n+\n+        compile();\n+\n+        checkCompiled();\n+        NMethod origNmethod = NMethod.get(method, false);\n+\n+        WHITE_BOX.relocateNMethodTo(method, BlobType.MethodProfiled.id);\n+\n+        WHITE_BOX.fullGC();\n+\n+        checkCompiled();\n+\n+        NMethod newNmethod = NMethod.get(method, false);\n+        if (origNmethod.entry_point == newNmethod.entry_point) {\n+            throw new RuntimeException(\"Did not create new nmethod\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/RelocateNMethod.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseSerialGC compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseParallelGC compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseG1GC compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseShenandoahGC compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseZGC compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import java.lang.reflect.Method;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+\n+public class RelocateNMethodMultiplePaths {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    public static double FUNCTION_RESULT = 0;\n+\n+    public static void main(String [] args) throws Exception {\n+        \/\/ Get method that will be relocated\n+        Method method = RelocateNMethodMultiplePaths.class.getMethod(\"function\", boolean.class);\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+\n+        \/\/ Verify not initially compiled\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+\n+        \/\/ Call function enough to compile\n+        callFunction(true);\n+\n+        \/\/ Verify now compiled\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get newly created nmethod\n+        NMethod origNmethod = NMethod.get(method, false);\n+\n+        \/\/ Relocate nmethod and mark old for cleanup\n+        WHITE_BOX.relocateNMethodTo(method, BlobType.MethodProfiled.id);\n+\n+        \/\/ Trigger GC to clean up old nmethod\n+        WHITE_BOX.fullGC();\n+\n+        \/\/ Verify function still compiled after old was cleaned up\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get new nmethod and verify it's actually new\n+        NMethod newNmethod = NMethod.get(method, false);\n+        if (origNmethod.entry_point == newNmethod.entry_point) {\n+            throw new RuntimeException(\"Did not create new nmethod\");\n+        }\n+\n+        \/\/ Call function again with different path so it gets deoptimized\n+        function(false);\n+\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+\n+        \/\/ Call both paths to verify everything still works\n+        function(true);\n+        function(false);\n+    }\n+\n+    \/\/ Call function multiple times to trigger compilation\n+    private static void callFunction(boolean pathOne) {\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD; i++) {\n+            function(pathOne);\n+        }\n+    }\n+\n+    public static void function(boolean pathOne) {\n+        if (pathOne) {\n+            FUNCTION_RESULT = 1;\n+        } else {\n+            FUNCTION_RESULT = 2;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/RelocateNMethodMultiplePaths.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -489,0 +489,6 @@\n+  private native void     relocateNMethodTo0(Executable method, int type);\n+  public         void     relocateNMethodTo(Executable method, int type) {\n+    Objects.requireNonNull(method);\n+    relocateNMethodTo0(method, type);\n+  }\n+  public native void    relocateAllNMethods();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}