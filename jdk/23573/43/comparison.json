{"files":[{"patch":"@@ -93,1 +93,0 @@\n-  assert(call->raw_destination() == owner(), \"destination should be empty\");\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -31,2 +32,2 @@\n-bool DefaultICProtectionBehaviour::lock(nmethod* method) {\n-  if (is_safe(method)) {\n+bool DefaultICProtectionBehaviour::lock(nmethod* nm) {\n+  if (is_safe(nm)) {\n@@ -39,1 +40,1 @@\n-void DefaultICProtectionBehaviour::unlock(nmethod* method) {\n+void DefaultICProtectionBehaviour::unlock(nmethod* nm) {\n@@ -43,2 +44,2 @@\n-bool DefaultICProtectionBehaviour::is_safe(nmethod* method) {\n-  return SafepointSynchronize::is_at_safepoint() || CompiledIC_lock->owned_by_self();\n+bool DefaultICProtectionBehaviour::is_safe(nmethod* nm) {\n+  return SafepointSynchronize::is_at_safepoint() || CompiledIC_lock->owned_by_self() || nm->is_not_installed();\n","filename":"src\/hotspot\/share\/code\/codeBehaviours.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n-  virtual bool lock(nmethod* method) = 0;\n-  virtual void unlock(nmethod* method) = 0;\n-  virtual bool is_safe(nmethod* method) = 0;\n+  virtual bool lock(nmethod* nm) = 0;\n+  virtual void unlock(nmethod* nm) = 0;\n+  virtual bool is_safe(nmethod* nm) = 0;\n@@ -45,3 +45,3 @@\n-  virtual bool lock(nmethod* method);\n-  virtual void unlock(nmethod* method);\n-  virtual bool is_safe(nmethod* method);\n+  virtual bool lock(nmethod* nm);\n+  virtual void unlock(nmethod* nm);\n+  virtual bool is_safe(nmethod* nm);\n","filename":"src\/hotspot\/share\/code\/codeBehaviours.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-  static CodeBlobType get_code_blob_type(nmethod* nm) {\n+  static CodeBlobType get_code_blob_type(const nmethod* nm) {\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-bool CompiledICLocker::is_safe(nmethod* method) {\n-  return CompiledICProtectionBehaviour::current()->is_safe(method);\n+bool CompiledICLocker::is_safe(nmethod* nm) {\n+  return CompiledICProtectionBehaviour::current()->is_safe(nm);\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  static bool is_safe(nmethod* method);\n+  static bool is_safe(nmethod* nm);\n","filename":"src\/hotspot\/share\/code\/compiledIC.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -765,1 +765,1 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"clearing of IC's only allowed at safepoint\");\n+  assert(SafepointSynchronize::is_at_safepoint() || is_not_installed(), \"clearing of IC's only allowed at safepoint or when not installed\");\n@@ -1163,1 +1163,2 @@\n-    + align_up(debug_info->data_size()           , oopSize);\n+    + align_up(debug_info->data_size()           , oopSize)\n+    + align_up(ImmutableDataReferencesCounterSize, oopSize);\n@@ -1390,0 +1391,254 @@\n+\n+nmethod::nmethod(const nmethod &nm) : CodeBlob(nm._name, nm._kind, nm._size, nm._header_size)\n+{\n+\n+  if (nm._oop_maps != nullptr) {\n+    _oop_maps                   = nm._oop_maps->clone();\n+  } else {\n+    _oop_maps                   = nullptr;\n+  }\n+\n+  _size                         = nm._size;\n+  _relocation_size              = nm._relocation_size;\n+  _content_offset               = nm._content_offset;\n+  _code_offset                  = nm._code_offset;\n+  _data_offset                  = nm._data_offset;\n+  _frame_size                   = nm._frame_size;\n+\n+  S390_ONLY( _ctable_offset     = nm._ctable_offset; )\n+\n+  _header_size                  = nm._header_size;\n+  _frame_complete_offset        = nm._frame_complete_offset;\n+\n+  _kind                         = nm._kind;\n+\n+  _caller_must_gc_arguments     = nm._caller_must_gc_arguments;\n+\n+#ifndef PRODUCT\n+  _asm_remarks.share(nm._asm_remarks);\n+  _dbg_strings.share(nm._dbg_strings);\n+#endif\n+\n+  \/\/ Allocate memory and copy mutable data to C heap\n+  _mutable_data_size            = nm._mutable_data_size;\n+  if (_mutable_data_size > 0) {\n+    _mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n+    if (_mutable_data == nullptr) {\n+      vm_exit_out_of_memory(_mutable_data_size, OOM_MALLOC_ERROR, \"nmethod: no space for mutable data\");\n+    }\n+    memcpy(mutable_data_begin(), nm.mutable_data_begin(), nm.mutable_data_size());\n+  } else {\n+    _mutable_data               = nullptr;\n+  }\n+\n+  _deoptimization_generation    = 0;\n+  _gc_epoch                     = CodeCache::gc_epoch();\n+  _method                       = nm._method;\n+  _osr_link                     = nullptr;\n+\n+  \/\/ Increment number of references to immutable data to share it between nmethods\n+  _immutable_data_size          = nm._immutable_data_size;\n+  if (_immutable_data_size > 0) {\n+    _immutable_data             = nm._immutable_data;\n+    set_immutable_data_references_counter(get_immutable_data_references_counter() + 1);\n+  } else {\n+    _immutable_data             = nullptr;\n+  }\n+\n+  _exception_cache              = nullptr;\n+  _gc_data                      = nullptr;\n+  _oops_do_mark_nmethods        = nullptr;\n+  _oops_do_mark_link            = nullptr;\n+  _compiled_ic_data             = nullptr;\n+\n+  if (nm._osr_entry_point != nullptr) {\n+    _osr_entry_point            = (nm._osr_entry_point - (address) &nm) + (address) this;\n+  } else {\n+    _osr_entry_point            = nullptr;\n+  }\n+\n+  _entry_offset                 = nm._entry_offset;\n+  _verified_entry_offset        = nm._verified_entry_offset;\n+  _entry_bci                    = nm._entry_bci;\n+\n+  _skipped_instructions_size    = nm._skipped_instructions_size;\n+  _stub_offset                  = nm._stub_offset;\n+  _exception_offset             = nm._exception_offset;\n+  _deopt_handler_offset         = nm._deopt_handler_offset;\n+  _deopt_mh_handler_offset      = nm._deopt_mh_handler_offset;\n+  _unwind_handler_offset        = nm._unwind_handler_offset;\n+  _num_stack_arg_slots          = nm._num_stack_arg_slots;\n+  _oops_size                    = nm._oops_size;\n+#if INCLUDE_JVMCI\n+  _metadata_size                = nm._metadata_size;\n+#endif\n+  _nul_chk_table_offset         = nm._nul_chk_table_offset;\n+  _handler_table_offset         = nm._handler_table_offset;\n+  _scopes_pcs_offset            = nm._scopes_pcs_offset;\n+  _scopes_data_offset           = nm._scopes_data_offset;\n+#if INCLUDE_JVMCI\n+  _speculations_offset          = nm._speculations_offset;\n+#endif\n+\n+  _orig_pc_offset               = nm._orig_pc_offset;\n+  _compile_id                   = nm._compile_id;\n+  _comp_level                   = nm._comp_level;\n+  _compiler_type                = nm._compiler_type;\n+  _is_unloading_state           = nm._is_unloading_state;\n+  _state                        = not_installed;\n+\n+  _has_unsafe_access            = nm._has_unsafe_access;\n+  _has_method_handle_invokes    = nm._has_method_handle_invokes;\n+  _has_wide_vectors             = nm._has_wide_vectors;\n+  _has_monitors                 = nm._has_monitors;\n+  _has_scoped_access            = nm._has_scoped_access;\n+  _has_flushed_dependencies     = nm._has_flushed_dependencies;\n+  _is_unlinked                  = nm._is_unlinked;\n+  _load_reported                = nm._load_reported;\n+\n+  _deoptimization_status        = nm._deoptimization_status;\n+\n+  if (nm._pc_desc_container != nullptr) {\n+    _pc_desc_container          = new PcDescContainer(scopes_pcs_begin());\n+  } else {\n+    _pc_desc_container          = nullptr;\n+  }\n+\n+  \/\/ Copy nmethod contents excluding header\n+  \/\/ - Constant part          (doubles, longs and floats used in nmethod)\n+  \/\/ - Code part:\n+  \/\/   - Code body\n+  \/\/   - Exception handler\n+  \/\/   - Stub code\n+  \/\/   - OOP table\n+  memcpy(consts_begin(), nm.consts_begin(), nm.data_end() - nm.consts_begin());\n+\n+  post_init();\n+}\n+\n+nmethod* nmethod::relocate(CodeBlobType code_blob_type) {\n+  assert(NMethodRelocation, \"must enable use of function\");\n+\n+  \/\/ Locks required to be held by caller to ensure the nmethod\n+  \/\/ is not modified or purged from code cache during relocation\n+  assert_lock_strong(CodeCache_lock);\n+  assert_lock_strong(Compile_lock);\n+  assert(CompiledICLocker::is_safe(this), \"mt unsafe call\");\n+\n+  if (!is_relocatable()) {\n+    return nullptr;\n+  }\n+\n+  run_nmethod_entry_barrier();\n+  nmethod* nm_copy = new (size(), code_blob_type) nmethod(*this);\n+\n+  if (nm_copy == nullptr) {\n+    return nullptr;\n+  }\n+\n+  \/\/ Fix relocation\n+  RelocIterator iter(nm_copy);\n+  CodeBuffer src(this);\n+  CodeBuffer dst(nm_copy);\n+  while (iter.next()) {\n+#ifdef USE_TRAMPOLINE_STUB_FIX_OWNER\n+    \/\/ Direct calls may no longer be in range and the use of a trampoline may now be required.\n+    \/\/ Instead, allow trampoline relocations to update their owners and perform the necessary checks.\n+    if (iter.reloc()->is_call()) {\n+      address trampoline = trampoline_stub_Relocation::get_trampoline_for(iter.reloc()->addr(), nm_copy);\n+      if (trampoline != nullptr) {\n+        continue;\n+      }\n+    }\n+#endif\n+\n+    iter.reloc()->fix_relocation_after_move(&src, &dst);\n+  }\n+\n+  nm_copy->clear_inline_caches();\n+\n+  \/\/ To make dependency checking during class loading fast, record\n+  \/\/ the nmethod dependencies in the classes it is dependent on.\n+  \/\/ This allows the dependency checking code to simply walk the\n+  \/\/ class hierarchy above the loaded class, checking only nmethods\n+  \/\/ which are dependent on those classes.  The slow way is to\n+  \/\/ check every nmethod for dependencies which makes it linear in\n+  \/\/ the number of methods compiled.  For applications with a lot\n+  \/\/ classes the slow way is too slow.\n+  for (Dependencies::DepStream deps(nm_copy); deps.next(); ) {\n+    if (deps.type() == Dependencies::call_site_target_value) {\n+      \/\/ CallSite dependencies are managed on per-CallSite instance basis.\n+      oop call_site = deps.argument_oop(0);\n+      MethodHandles::add_dependent_nmethod(call_site, nm_copy);\n+    } else {\n+      InstanceKlass* ik = deps.context_type();\n+      if (ik == nullptr) {\n+        continue;  \/\/ ignore things like evol_method\n+      }\n+      \/\/ record this nmethod as dependent on this klass\n+      ik->add_dependent_nmethod(nm_copy);\n+    }\n+  }\n+\n+  MutexLocker ml_NMethodState_lock(NMethodState_lock, Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ Verify the nm we copied from is still valid\n+  if (!is_marked_for_deoptimization() && is_in_use()) {\n+    assert(method() != nullptr && method()->code() == this, \"should be if is in use\");\n+\n+    \/\/ Attempt to start using the copy\n+    if (nm_copy->make_in_use()) {\n+      ICache::invalidate_range(nm_copy->code_begin(), nm_copy->code_size());\n+\n+      methodHandle mh(Thread::current(), nm_copy->method());\n+      nm_copy->method()->set_code(mh, nm_copy);\n+\n+      make_not_used();\n+\n+      nm_copy->post_compiled_method_load_event();\n+\n+      nm_copy->log_relocated_nmethod(this);\n+\n+      return nm_copy;\n+    }\n+  }\n+\n+  nm_copy->make_not_used();\n+\n+  return nullptr;\n+}\n+\n+bool nmethod::is_relocatable() {\n+  if (!is_java_method()) {\n+    return false;\n+  }\n+\n+  if (!is_in_use()) {\n+    return false;\n+  }\n+\n+  if (is_osr_method()) {\n+    return false;\n+  }\n+\n+  if (is_marked_for_deoptimization()) {\n+    return false;\n+  }\n+\n+#if INCLUDE_JVMCI\n+  if (jvmci_nmethod_data() != nullptr && jvmci_nmethod_data()->has_mirror()) {\n+    return false;\n+  }\n+#endif\n+\n+  if (is_unloading()) {\n+    return false;\n+  }\n+\n+  if (has_evol_metadata()) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -1394,0 +1649,4 @@\n+void* nmethod::operator new(size_t size, int nmethod_size, CodeBlobType code_blob_type) throw () {\n+  return CodeCache::allocate(nmethod_size, code_blob_type);\n+}\n+\n@@ -1522,1 +1781,1 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset  + align_up(speculations_len, oopSize); )\n+    DEBUG_ONLY( int immutable_data_end_offset = _speculations_offset + align_up(speculations_len, oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n@@ -1524,1 +1783,1 @@\n-    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize); )\n+    DEBUG_ONLY( int immutable_data_end_offset = _scopes_data_offset + align_up(debug_info->data_size(), oopSize) + align_up(ImmutableDataReferencesCounterSize, oopSize); )\n@@ -1557,0 +1816,1 @@\n+    set_immutable_data_references_counter(1);\n@@ -1623,0 +1883,34 @@\n+\n+void nmethod::log_relocated_nmethod(nmethod* original) const {\n+  if (LogCompilation && xtty != nullptr) {\n+    ttyLocker ttyl;\n+    xtty->begin_elem(\"relocated nmethod\");\n+    log_identity(xtty);\n+    xtty->print(\" entry='\" INTPTR_FORMAT \"' size='%d'\", p2i(code_begin()), size());\n+\n+    const char* original_code_heap_name = CodeCache::get_code_heap_name(CodeCache::get_code_blob_type(original));\n+    xtty->print(\" original_address='\" INTPTR_FORMAT \"'\", p2i(original));\n+    xtty->print(\" original_code_heap='%s'\", original_code_heap_name);\n+\n+    const char* new_code_heap_name = CodeCache::get_code_heap_name(CodeCache::get_code_blob_type(this));\n+    xtty->print(\" new_address='\" INTPTR_FORMAT \"'\", p2i(this));\n+    xtty->print(\" new_code_heap='%s'\", new_code_heap_name);\n+\n+    LOG_OFFSET(xtty, relocation);\n+    LOG_OFFSET(xtty, consts);\n+    LOG_OFFSET(xtty, insts);\n+    LOG_OFFSET(xtty, stub);\n+    LOG_OFFSET(xtty, scopes_data);\n+    LOG_OFFSET(xtty, scopes_pcs);\n+    LOG_OFFSET(xtty, dependencies);\n+    LOG_OFFSET(xtty, handler_table);\n+    LOG_OFFSET(xtty, nul_chk_table);\n+    LOG_OFFSET(xtty, oops);\n+    LOG_OFFSET(xtty, metadata);\n+\n+    xtty->method(method());\n+    xtty->stamp();\n+    xtty->end_elem();\n+  }\n+}\n+\n@@ -2153,1 +2447,12 @@\n-  os::free(_immutable_data);\n+  if (_immutable_data != nullptr) {\n+    int reference_count = get_immutable_data_references_counter();\n+    assert(reference_count > 0, \"immutable data has no references\");\n+\n+    set_immutable_data_references_counter(reference_count - 1);\n+\n+    \/\/ Free memory if this is the last nmethod referencing immutable data\n+    if (reference_count == 0) {\n+      os::free(_immutable_data);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":310,"deletions":5,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -158,0 +158,1 @@\n+\/\/  - Nmethod reference counter\n@@ -171,0 +172,2 @@\n+  #define ImmutableDataReferencesCounterSize ((int)sizeof(int))\n+\n@@ -338,0 +341,2 @@\n+  nmethod(const nmethod &nm);\n+\n@@ -340,0 +345,1 @@\n+  void* operator new(size_t size, int nmethod_size, CodeBlobType code_blob_type) throw();\n@@ -572,0 +578,6 @@\n+  \/\/ Relocate the nmethod to the code heap identified by code_blob_type.\n+  \/\/ Returns nullptr if the code heap does not have enough space, the\n+  \/\/ nmethod is unrelocatable, or the nmethod is invalidated during relocation,\n+  \/\/ otherwise the relocated nmethod. The original nmethod will be marked not entrant.\n+  nmethod* relocate(CodeBlobType code_blob_type);\n+\n@@ -588,0 +600,2 @@\n+  bool is_relocatable();\n+\n@@ -641,1 +655,1 @@\n-  address speculations_end      () const { return            immutable_data_end(); }\n+  address speculations_end      () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n@@ -643,1 +657,1 @@\n-  address scopes_data_end       () const { return            immutable_data_end(); }\n+  address scopes_data_end       () const { return           immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n@@ -646,0 +660,2 @@\n+  address immutable_data_references_counter_begin () const { return immutable_data_end() - ImmutableDataReferencesCounterSize ; }\n+\n@@ -961,0 +977,3 @@\n+  inline int  get_immutable_data_references_counter()           { return *((int*)immutable_data_references_counter_begin());  }\n+  inline void set_immutable_data_references_counter(int count)  { *((int*)immutable_data_references_counter_begin()) = count; }\n+\n@@ -1029,0 +1048,1 @@\n+  void log_relocated_nmethod(nmethod* original) const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -412,1 +412,0 @@\n-\n@@ -417,0 +416,2 @@\n+  \/\/ We either relocate a nmethod residing in CodeCache or just generated code from CodeBuffer\n+  assert(src->blob() == nullptr || nativeCall_at(owner())->raw_destination() == owner(), \"destination should be empty\");\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -865,0 +865,6 @@\n+ImmutableOopMapSet* ImmutableOopMapSet::clone() const {\n+  address buffer = NEW_C_HEAP_ARRAY(unsigned char, _size, mtCode);\n+  memcpy(buffer, (address)this, _size);\n+  return (ImmutableOopMapSet*)buffer;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -351,0 +351,2 @@\n+  ImmutableOopMapSet* clone() const;\n+\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading()) {\n+    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading() || nm->is_not_installed()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading()) {\n+    if (SafepointSynchronize::is_at_safepoint() || nm->is_unloading() || nm->is_not_installed()) {\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,0 +140,5 @@\n+  \/\/ Returns true if this nmethod has a mirror\n+  bool has_mirror() const {\n+    return _nmethod_mirror_index != -1;\n+  }\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"code\/compiledIC.hpp\"\n@@ -1550,1 +1551,3 @@\n-      address((jlong) blob) { }\n+      address((jlong) blob),\n+      code_begin((jlong) blob->code_begin()),\n+      is_nmethod((jboolean) blob->is_nmethod()) { }\n@@ -1556,0 +1559,2 @@\n+  const jlong       code_begin;\n+  const jboolean    is_nmethod;\n@@ -1562,1 +1567,1 @@\n-  jobjectArray result = env->NewObjectArray(4, clazz, nullptr);\n+  jobjectArray result = env->NewObjectArray(6, clazz, nullptr);\n@@ -1580,0 +1585,8 @@\n+  obj = longBox(thread, env, cb->code_begin);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  env->SetObjectArrayElement(result, 4, obj);\n+\n+  obj = booleanBox(thread, env, cb->is_nmethod);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  env->SetObjectArrayElement(result, 5, obj);\n+\n@@ -1629,0 +1642,38 @@\n+WB_ENTRY(void, WB_RelocateNMethodFromMethod(JNIEnv* env, jobject o, jobject method, jint blob_type))\n+  ResourceMark rm(THREAD);\n+  jmethodID jmid = reflected_method_to_jmid(thread, env, method);\n+  CHECK_JNI_EXCEPTION(env);\n+  methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));\n+  nmethod* code = mh->code();\n+  if (code != nullptr) {\n+    MutexLocker ml_Compile_lock(Compile_lock);\n+    CompiledICLocker ic_locker(code);\n+    MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    code->relocate(static_cast<CodeBlobType>(blob_type));\n+  }\n+WB_END\n+\n+WB_ENTRY(void, WB_RelocateNMethodFromAddr(JNIEnv* env, jobject o, jlong addr, jint blob_type))\n+  ResourceMark rm(THREAD);\n+  CHECK_JNI_EXCEPTION(env);\n+  void* address = (void*) addr;\n+\n+  if (address == nullptr) {\n+    return;\n+  }\n+\n+  MutexLocker ml_Compile_lock(Compile_lock);\n+  MutexLocker ml_CompiledIC_lock(CompiledIC_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+\n+  \/\/ Verify that nmethod address is still valid\n+  CodeBlob* blob = CodeCache::find_blob(address);\n+  if (blob != nullptr && blob->is_nmethod()) {\n+    nmethod* code = blob->as_nmethod();\n+    if (code->is_in_use()) {\n+      CompiledICLocker ic_locker(code);\n+      code->relocate(static_cast<CodeBlobType>(blob_type));\n+    }\n+  }\n+WB_END\n+\n@@ -2891,0 +2942,3 @@\n+  {CC\"relocateNMethodFromMethod0\", CC\"(Ljava\/lang\/reflect\/Executable;I)V\",\n+                                                      (void*)&WB_RelocateNMethodFromMethod },\n+  {CC\"relocateNMethodFromAddr\", CC\"(JI)V\",            (void*)&WB_RelocateNMethodFromAddr },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1572,0 +1572,3 @@\n+  product(bool, NMethodRelocation, false, EXPERIMENTAL,                     \\\n+          \"Enables use of experimental function nmethod::relocate()\")       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  private static long          immutableDataReferencesCounterSize;\n@@ -82,19 +83,20 @@\n-    methodField                 = type.getAddressField(\"_method\");\n-    entryBCIField               = type.getCIntegerField(\"_entry_bci\");\n-    osrLinkField                = type.getAddressField(\"_osr_link\");\n-    immutableDataField          = type.getAddressField(\"_immutable_data\");\n-    immutableDataSizeField      = type.getCIntegerField(\"_immutable_data_size\");\n-    exceptionOffsetField        = type.getCIntegerField(\"_exception_offset\");\n-    deoptHandlerOffsetField     = type.getCIntegerField(\"_deopt_handler_offset\");\n-    deoptMhHandlerOffsetField   = type.getCIntegerField(\"_deopt_mh_handler_offset\");\n-    origPCOffsetField           = type.getCIntegerField(\"_orig_pc_offset\");\n-    stubOffsetField             = type.getCIntegerField(\"_stub_offset\");\n-    scopesPCsOffsetField        = type.getCIntegerField(\"_scopes_pcs_offset\");\n-    scopesDataOffsetField       = type.getCIntegerField(\"_scopes_data_offset\");\n-    handlerTableOffsetField     = new CIntField(type.getCIntegerField(\"_handler_table_offset\"), 0);\n-    nulChkTableOffsetField      = new CIntField(type.getCIntegerField(\"_nul_chk_table_offset\"), 0);\n-    entryOffsetField            = new CIntField(type.getCIntegerField(\"_entry_offset\"), 0);\n-    verifiedEntryOffsetField    = new CIntField(type.getCIntegerField(\"_verified_entry_offset\"), 0);\n-    osrEntryPointField          = type.getAddressField(\"_osr_entry_point\");\n-    compLevelField              = new CIntField(type.getCIntegerField(\"_comp_level\"), 0);\n-    pcDescSize = db.lookupType(\"PcDesc\").getSize();\n+    methodField                        = type.getAddressField(\"_method\");\n+    entryBCIField                      = type.getCIntegerField(\"_entry_bci\");\n+    osrLinkField                       = type.getAddressField(\"_osr_link\");\n+    immutableDataField                 = type.getAddressField(\"_immutable_data\");\n+    immutableDataSizeField             = type.getCIntegerField(\"_immutable_data_size\");\n+    exceptionOffsetField               = type.getCIntegerField(\"_exception_offset\");\n+    deoptHandlerOffsetField            = type.getCIntegerField(\"_deopt_handler_offset\");\n+    deoptMhHandlerOffsetField          = type.getCIntegerField(\"_deopt_mh_handler_offset\");\n+    origPCOffsetField                  = type.getCIntegerField(\"_orig_pc_offset\");\n+    stubOffsetField                    = type.getCIntegerField(\"_stub_offset\");\n+    scopesPCsOffsetField               = type.getCIntegerField(\"_scopes_pcs_offset\");\n+    scopesDataOffsetField              = type.getCIntegerField(\"_scopes_data_offset\");\n+    handlerTableOffsetField            = new CIntField(type.getCIntegerField(\"_handler_table_offset\"), 0);\n+    nulChkTableOffsetField             = new CIntField(type.getCIntegerField(\"_nul_chk_table_offset\"), 0);\n+    entryOffsetField                   = new CIntField(type.getCIntegerField(\"_entry_offset\"), 0);\n+    verifiedEntryOffsetField           = new CIntField(type.getCIntegerField(\"_verified_entry_offset\"), 0);\n+    osrEntryPointField                 = type.getAddressField(\"_osr_entry_point\");\n+    compLevelField                     = new CIntField(type.getCIntegerField(\"_comp_level\"), 0);\n+    pcDescSize                         = db.lookupType(\"PcDesc\").getSize();\n+    immutableDataReferencesCounterSize = VM.getVM().getIntSize();\n@@ -145,1 +147,1 @@\n-  public Address scopesPCsEnd()         { return immutableDataEnd();                                        }\n+  public Address scopesPCsEnd()         { return immutableDataEnd().addOffsetTo(-immutableDataReferencesCounterSize); }\n@@ -175,1 +177,2 @@\n-      nulChkTableSize();\n+      nulChkTableSize()  +\n+      (int) immutableDataReferencesCounterSize;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":24,"deletions":21,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -224,2 +224,15 @@\n-        if (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n-            throw new RuntimeException(method + \" must not be in queue\");\n+        checkNotCompiled(method, isOsr);\n+    }\n+\n+    \/**\n+     * Checks, that the specified executable is not (OSR-)compiled.\n+     *\n+     * @param executable The method or constructor to check.\n+     * @param isOsr Check for OSR compilation if true\n+     * @throws RuntimeException if {@linkplain #method} is in compiler queue or\n+     *                          is compiled, or if {@linkplain #method} has zero\n+     *                          compilation level.\n+     *\/\n+    protected static final void checkNotCompiled(Executable executable, boolean isOsr) {\n+        if (WHITE_BOX.isMethodQueuedForCompilation(executable)) {\n+            throw new RuntimeException(executable + \" must not be in queue\");\n@@ -227,2 +240,2 @@\n-        if (WHITE_BOX.isMethodCompiled(method, isOsr)) {\n-            throw new RuntimeException(method + \" must not be \" +\n+        if (WHITE_BOX.isMethodCompiled(executable, isOsr)) {\n+            throw new RuntimeException(executable + \" must not be \" +\n@@ -231,2 +244,2 @@\n-        if (WHITE_BOX.getMethodCompilationLevel(method, isOsr) != 0) {\n-            throw new RuntimeException(method + (isOsr ? \" osr_\" : \" \") +\n+        if (WHITE_BOX.getMethodCompilationLevel(executable, isOsr) != 0) {\n+            throw new RuntimeException(executable + (isOsr ? \" osr_\" : \" \") +\n@@ -245,0 +258,13 @@\n+        checkCompiled(method, testCase.isOsr());\n+    }\n+\n+    \/**\n+     * Checks, that the specified executable is compiled.\n+     *\n+     * @param executable The method or constructor to check.\n+     * @param isOsr Check for OSR compilation if true\n+     * @throws RuntimeException if {@linkplain #method} isn't in compiler queue\n+     *                          and isn't compiled, or if {@linkplain #method}\n+     *                          has nonzero compilation level\n+     *\/\n+    protected static final void checkCompiled(Executable executable, boolean isOsr) {\n@@ -246,2 +272,2 @@\n-        waitBackgroundCompilation();\n-        if (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n+        waitBackgroundCompilation(executable);\n+        if (WHITE_BOX.isMethodQueuedForCompilation(executable)) {\n@@ -249,1 +275,1 @@\n-                    method, System.currentTimeMillis() - start);\n+                    executable, System.currentTimeMillis() - start);\n@@ -252,3 +278,3 @@\n-        if (!WHITE_BOX.isMethodCompiled(method, testCase.isOsr())) {\n-            throw new RuntimeException(method + \" must be \"\n-                    + (testCase.isOsr() ? \"osr_\" : \"\") + \"compiled\");\n+        if (!WHITE_BOX.isMethodCompiled(executable, isOsr)) {\n+            throw new RuntimeException(executable + \" must be \"\n+                    + (isOsr ? \"osr_\" : \"\") + \"compiled\");\n@@ -256,1 +282,1 @@\n-        if (WHITE_BOX.getMethodCompilationLevel(method, testCase.isOsr())\n+        if (WHITE_BOX.getMethodCompilationLevel(executable, isOsr)\n@@ -258,2 +284,2 @@\n-            throw new RuntimeException(method\n-                    + (testCase.isOsr() ? \" osr_\" : \" \")\n+            throw new RuntimeException(executable\n+                    + (isOsr ? \" osr_\" : \" \")\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/CompilerWhiteBoxTest.java","additions":41,"deletions":15,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Serial\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseSerialGC\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Parallel\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseParallelGC\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.G1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseG1GC\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Shenandoah\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseShenandoahGC\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8316694\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Z\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache -XX:+UseZGC\n+ * -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.DeoptimizeRelocatedNMethod\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import java.lang.reflect.Method;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+\n+public class DeoptimizeRelocatedNMethod {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    public static double FUNCTION_RESULT = 0;\n+\n+    public static void main(String [] args) throws Exception {\n+        \/\/ Get method that will be relocated\n+        Method method = DeoptimizeRelocatedNMethod.class.getMethod(\"function\");\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+\n+        \/\/ Verify not initially compiled\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+\n+        \/\/ Call function enough to compile\n+        callFunction();\n+\n+        \/\/ Verify now compiled\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get newly created nmethod\n+        NMethod origNmethod = NMethod.get(method, false);\n+\n+        \/\/ Relocate nmethod and mark old for cleanup\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodProfiled.id);\n+\n+        \/\/ Trigger GC to clean up old nmethod\n+        WHITE_BOX.fullGC();\n+\n+        \/\/ Verify function still compiled after old was cleaned up\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get new nmethod and verify it's actually new\n+        NMethod newNmethod = NMethod.get(method, false);\n+        if (origNmethod.entry_point == newNmethod.entry_point) {\n+            throw new RuntimeException(\"Did not create new nmethod\");\n+        }\n+\n+        \/\/ Call to verify everything still works\n+        function();\n+\n+        \/\/ Deoptimized method\n+        WHITE_BOX.deoptimizeMethod(method);\n+\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+\n+        \/\/ Call to verify everything still works\n+        function();\n+    }\n+\n+    \/\/ Call function multiple times to trigger compilation\n+    private static void callFunction() {\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD; i++) {\n+            function();\n+        }\n+    }\n+\n+    public static void function() {\n+        FUNCTION_RESULT = Math.random();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/DeoptimizeRelocatedNMethod.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Serial\n+ * @bug 8316694\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Serial\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+UseSerialGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Parallel\n+ * @bug 8316694\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Parallel\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+UseParallelGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=G1\n+ * @bug 8316694\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.G1\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=Shenandoah\n+ * @bug 8316694\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8316694\n+ * @summary test that nmethod::relocate() correctly creates a new nmethod\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @requires vm.gc.Z\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+SegmentedCodeCache\n+ * -XX:+UseZGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation compiler.whitebox.RelocateNMethod\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import java.lang.reflect.Method;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+public class RelocateNMethod extends CompilerWhiteBoxTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        CompilerWhiteBoxTest.main(RelocateNMethod::new, new String[] {\"CONSTRUCTOR_TEST\", \"METHOD_TEST\", \"STATIC_TEST\"});\n+    }\n+\n+    private RelocateNMethod(TestCase testCase) {\n+        super(testCase);\n+        \/\/ to prevent inlining of #method\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+    }\n+\n+    @Override\n+    protected void test() throws Exception {\n+        checkNotCompiled();\n+\n+        compile();\n+\n+        checkCompiled();\n+        NMethod origNmethod = NMethod.get(method, false);\n+\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodProfiled.id);\n+\n+        WHITE_BOX.fullGC();\n+\n+        checkCompiled();\n+\n+        NMethod newNmethod = NMethod.get(method, false);\n+        if (origNmethod.entry_point == newNmethod.entry_point) {\n+            throw new RuntimeException(\"Did not create new nmethod\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/RelocateNMethod.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=SerialC1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Serial\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseSerialGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=SerialC2\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Serial\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseSerialGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ParallelC1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Parallel\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseParallelGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ParallelC2\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Parallel\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseParallelGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=G1C1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.G1\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=G1C2\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.G1\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseG1GC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ShenandoahC1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Shenandoah\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ShenandoahC2\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Shenandoah\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ZGCC1\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Z\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseZGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+\/*\n+ * @test id=ZGCC2\n+ * @bug 8316694\n+ * @requires vm.debug == true\n+ * @requires vm.gc.Z\n+ * @summary test that relocated nmethod is correctly deoptimized\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbatch -XX:+TieredCompilation\n+ * -XX:+SegmentedCodeCache -XX:-DeoptimizeRandom -XX:+DeoptimizeALot -XX:+UseZGC -XX:+UnlockExperimentalVMOptions -XX:+NMethodRelocation\n+ * compiler.whitebox.RelocateNMethodMultiplePaths\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import java.lang.reflect.Method;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+\n+public class RelocateNMethodMultiplePaths {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    private static final int PATH_ONE_RESULT = 1;\n+    private static final int PATH_TWO_RESULT = 2;\n+\n+    public static void main(String [] args) throws Exception {\n+        \/\/ Get method that will be relocated\n+        Method method = RelocateNMethodMultiplePaths.class.getMethod(\"function\", boolean.class);\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+\n+        \/\/ Verify not initially compiled\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+\n+        \/\/ Call function enough to compile\n+        callFunction(true);\n+\n+        \/\/ Verify now compiled\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get newly created nmethod\n+        NMethod origNmethod = NMethod.get(method, false);\n+\n+        \/\/ Relocate nmethod and mark old for cleanup\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodNonProfiled.id);\n+\n+        \/\/ Trigger GC to clean up old nmethod\n+        WHITE_BOX.fullGC();\n+\n+        \/\/ Verify function still compiled after old was cleaned up\n+        CompilerWhiteBoxTest.checkCompiled(method, false);\n+\n+        \/\/ Get new nmethod and verify it's actually new\n+        NMethod newNmethod = NMethod.get(method, false);\n+        if (origNmethod.entry_point == newNmethod.entry_point) {\n+            throw new RuntimeException(\"Did not create new nmethod\");\n+        }\n+\n+        \/\/ Verify function still produces correct result\n+        if (function(true) != PATH_ONE_RESULT) {\n+            throw new RuntimeException(\"Relocated function produced incorrect result in path one\");\n+        }\n+\n+        \/\/ Call function again with different path and verify result\n+        if (function(false) != PATH_TWO_RESULT) {\n+            throw new RuntimeException(\"Relocated function produced incorrect result in path two\");\n+        }\n+\n+        \/\/ Verify function can be correctly deoptimized\n+        WHITE_BOX.deoptimizeMethod(method);\n+        CompilerWhiteBoxTest.checkNotCompiled(method, false);\n+    }\n+\n+    \/\/ Call function multiple times to trigger compilation\n+    private static void callFunction(boolean pathOne) {\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD; i++) {\n+            function(pathOne);\n+        }\n+    }\n+\n+    public static int function(boolean pathOne) {\n+        if (pathOne) {\n+            return PATH_ONE_RESULT;\n+        } else {\n+            return PATH_TWO_RESULT;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/RelocateNMethodMultiplePaths.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test StressNMethodRelocation\n+ * @summary Call and relocate methods concurrently\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+SegmentedCodeCache -XX:+UnlockExperimentalVMOptions\n+ *                   -XX:+NMethodRelocation compiler.whitebox.StressNMethodRelocation\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.CodeBlob;\n+import jdk.test.whitebox.code.NMethod;\n+\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.Random;\n+\n+public class StressNMethodRelocation {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final int C2_LEVEL = 4;\n+    private static final int ACTIVE_METHODS = 1024;\n+\n+    private static TestMethod[] methods;\n+    private static byte[] num1;\n+    private static byte[] num2;\n+\n+    private static long DURATION = 60_000;\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Initialize defaults\n+        initNums();\n+\n+        \/\/ Generate compiled code\n+        methods = new TestMethod[ACTIVE_METHODS];\n+        generateCode(methods);\n+\n+        \/\/ Create thread that runs compiled methods\n+        RunMethods runMethods = new RunMethods();\n+        Thread runMethodsThread = new Thread(runMethods);\n+\n+        \/\/ Create thread that relocates compiled methods\n+        RelocateNMethods relocate = new RelocateNMethods();\n+        Thread relocateThread = new Thread(relocate);\n+\n+        \/\/ Start theads\n+        runMethodsThread.start();\n+        relocateThread.start();\n+\n+        \/\/ Wait for threads to finish\n+        runMethodsThread.join();\n+        relocateThread.join();\n+    }\n+\n+    private static byte[] genNum(Random random, int digitCount) {\n+        byte[] num = new byte[digitCount];\n+        int d;\n+        do {\n+            d = random.nextInt(10);\n+        } while (d == 0);\n+\n+        num[0] = (byte)d;\n+        for (int i = 1; i < digitCount; ++i) {\n+            num[i] = (byte)random.nextInt(10);\n+        }\n+        return num;\n+    }\n+\n+    private static void initNums() {\n+        final long seed = 8374592837465123L;\n+        Random random = new Random(seed);\n+\n+        final int digitCount = 40;\n+        num1 = genNum(random, digitCount);\n+        num2 = genNum(random, digitCount);\n+    }\n+\n+    private static void generateCode(TestMethod[] m) throws Exception {\n+        byte[] result = new byte[num1.length + 1];\n+\n+        for (int i = 0; i < ACTIVE_METHODS; ++i) {\n+            m[i] = new TestMethod();\n+            m[i].profile(num1, num2, result);\n+            m[i].compileWithC2();\n+        }\n+    }\n+\n+    private static final class TestMethod {\n+        private static final String CLASS_NAME = \"A\";\n+        private static final String METHOD_TO_COMPILE = \"sum\";\n+        private static final String JAVA_CODE = \"\"\"\n+        public class A {\n+\n+            public static void sum(byte[] n1, byte[] n2, byte[] out) {\n+                final int digitCount = n1.length;\n+                int carry = 0;\n+                for (int i = digitCount - 1; i >= 0; --i) {\n+                    int sum = n1[i] + n2[i] + carry;\n+                    out[i] = (byte)(sum % 10);\n+                    carry = sum \/ 10;\n+                }\n+                if (carry != 0) {\n+                    for (int i = digitCount; i > 0; --i) {\n+                        out[i] = out[i - 1];\n+                    }\n+                    out[0] = (byte)carry;\n+                }\n+            }\n+        }\"\"\";\n+\n+        private static final byte[] BYTE_CODE;\n+\n+        static {\n+            BYTE_CODE = InMemoryJavaCompiler.compile(CLASS_NAME, JAVA_CODE);\n+        }\n+\n+        private final Method method;\n+\n+        private static ClassLoader createClassLoaderFor() {\n+            return new ClassLoader() {\n+                @Override\n+                public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                    if (!name.equals(CLASS_NAME)) {\n+                        return super.loadClass(name);\n+                    }\n+\n+                    return defineClass(name, BYTE_CODE, 0, BYTE_CODE.length);\n+                }\n+            };\n+        }\n+\n+        public TestMethod() throws Exception {\n+            var cl = createClassLoaderFor().loadClass(CLASS_NAME);\n+            method = cl.getMethod(METHOD_TO_COMPILE, byte[].class, byte[].class, byte[].class);\n+            WHITE_BOX.testSetDontInlineMethod(method, true);\n+        }\n+\n+        public void profile(byte[] num1, byte[] num2, byte[] result) throws Exception {\n+            method.invoke(null, num1, num2, result);\n+            WHITE_BOX.markMethodProfiled(method);\n+        }\n+\n+        public void invoke(byte[] num1, byte[] num2, byte[] result) throws Exception {\n+            method.invoke(null, num1, num2, result);\n+        }\n+\n+        public void compileWithC2() throws Exception {\n+            WHITE_BOX.enqueueMethodForCompilation(method, C2_LEVEL);\n+            while (WHITE_BOX.isMethodQueuedForCompilation(method)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WHITE_BOX.getMethodCompilationLevel(method) != C2_LEVEL) {\n+                throw new IllegalStateException(\"Method \" + method + \" is not compiled by C2.\");\n+            }\n+        }\n+    }\n+\n+    private static final class RelocateNMethods implements Runnable {\n+        public RelocateNMethods() {}\n+\n+        \/\/ Move nmethod back and forth between NonProfiled and Profiled code heaps\n+        public void run() {\n+            long startTime = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - startTime < DURATION) {\n+                \/\/ Relocate NonProfiled to Profiled\n+                CodeBlob[] nonProfiledBlobs = CodeBlob.getCodeBlobs(BlobType.MethodNonProfiled);\n+                for (CodeBlob blob : nonProfiledBlobs) {\n+                    if (blob.isNMethod) {\n+                        WHITE_BOX.relocateNMethodFromAddr(blob.address, BlobType.MethodProfiled.id);\n+                    }\n+                }\n+\n+                \/\/ Relocate Profiled to NonProfiled\n+                CodeBlob[] profiledBlobs = CodeBlob.getCodeBlobs(BlobType.MethodProfiled);\n+                for (CodeBlob blob : nonProfiledBlobs) {\n+                    if (blob.isNMethod) {\n+                        WHITE_BOX.relocateNMethodFromAddr(blob.address, BlobType.MethodNonProfiled.id);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static final class RunMethods implements Runnable {\n+        public RunMethods() {}\n+\n+        public void run() {\n+            try {\n+                long startTime = System.currentTimeMillis();\n+                while (System.currentTimeMillis() - startTime < DURATION) {\n+                    callMethods();\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e.getMessage());\n+            }\n+        }\n+\n+        private void callMethods() throws Exception {\n+            for (var m : methods) {\n+                byte[] result = new byte[num1.length + 1];\n+                m.invoke(num1, num2, result);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/StressNMethodRelocation.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jvmti.NMethodRelocation;\n+\n+import java.io.PrintStream;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+import nsk.share.*;\n+import nsk.share.jvmti.*;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.NMethod;\n+import jdk.test.whitebox.code.BlobType;\n+\n+public class nmethodrelocation extends DebugeeClass {\n+\n+    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    \/** Value of {@code -XX:CompileThreshold} *\/\n+    protected static final int COMPILE_THRESHOLD\n+        = Integer.parseInt(getVMOption(\"CompileThreshold\", \"10000\"));\n+\n+    \/** Load native library if required. *\/\n+    static {\n+        loadLibrary(\"agentnmethodrelocation001\");\n+    }\n+\n+    \/**\n+     * Returns value of VM option.\n+     *\n+     * @param name option's name\n+     * @return value of option or {@code null}, if option doesn't exist\n+     * @throws NullPointerException if name is null\n+     *\/\n+    protected static String getVMOption(String name) {\n+        Objects.requireNonNull(name);\n+        return Objects.toString(WHITE_BOX.getVMFlag(name), null);\n+    }\n+\n+    \/**\n+     * Returns value of VM option or default value.\n+     *\n+     * @param name         option's name\n+     * @param defaultValue default value\n+     * @return value of option or {@code defaultValue}, if option doesn't exist\n+     * @throws NullPointerException if name is null\n+     * @see #getVMOption(String)\n+     *\/\n+    protected static String getVMOption(String name, String defaultValue) {\n+        String result = getVMOption(name);\n+        return result == null ? defaultValue : result;\n+    }\n+    public static void main(String argv[]) throws Exception {\n+        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n+\n+        run();\n+    }\n+\n+    static int status = Consts.TEST_PASSED;\n+\n+    public static int run() throws Exception {\n+        Executable method = nmethodrelocation.class.getDeclaredMethod(\"compiledMethod\");\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+\n+        compile();\n+\n+        NMethod originalNMethod = NMethod.get(method, false);\n+        if (originalNMethod == null) {\n+            throw new AssertionError(\"Could not find original nmethod\");\n+        }\n+\n+        WHITE_BOX.relocateNMethodFromMethod(method, BlobType.MethodNonProfiled.id);\n+\n+        NMethod relocatedNMethod = NMethod.get(method, false);\n+        if (relocatedNMethod == null) {\n+            throw new AssertionError(\"Could not find relocated nmethod\");\n+        }\n+\n+        if (originalNMethod.address == relocatedNMethod.address) {\n+            throw new AssertionError(\"Relocated nmethod same as original\");\n+        }\n+\n+        WHITE_BOX.deoptimizeAll();\n+\n+        WHITE_BOX.fullGC();\n+        WHITE_BOX.fullGC();\n+\n+        status = checkStatus(status);\n+\n+        System.out.printf(\"Relocated nmethod from 0x%016x to 0x%016x%n\", originalNMethod.code_begin, relocatedNMethod.code_begin);\n+        System.out.flush();\n+\n+        return status;\n+    }\n+\n+    private static void compile() {\n+        for (int i = 0; i < COMPILE_THRESHOLD; i++) {\n+            compiledMethod();\n+        }\n+    }\n+\n+    public static long compiledMethod() {\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NMethodRelocation\/nmethodrelocation.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @bug 8316694\n+ * @summary Verify that nmethod relocation posts the correct JVMTI events\n+ *\n+ * @library \/vmTestbase \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/native TestDriver\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Asserts;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+public class TestDriver {\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-agentlib:agentnmethodrelocation001=-waittime=5\",\n+                \"--enable-native-access=ALL-UNNAMED\",\n+                \"-Xbootclasspath\/a:.\",\n+                \"-XX:+UseG1GC\",\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+WhiteBoxAPI\",\n+                \"-XX:+SegmentedCodeCache\",\n+                \"-XX:-TieredCompilation\",\n+                \"-Xbatch\",\n+                \"-XX:+UnlockExperimentalVMOptions\",\n+                \"-XX:+NMethodRelocation\",\n+                nsk.jvmti.NMethodRelocation.nmethodrelocation.class.getName());\n+\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        String output = oa.getOutput();\n+        if (oa.getExitValue() != 0) {\n+            System.err.println(oa.getOutput());\n+            throw new RuntimeException(\"Non-zero exit code returned from the test\");\n+        }\n+        Asserts.assertTrue(oa.getExitValue() == 0);\n+\n+        Pattern pattern = Pattern.compile(\"(?m)^Relocated nmethod from (0x[0-9a-f]{16}) to (0x[0-9a-f]{16})$\");\n+        Matcher matcher = pattern.matcher(output);\n+\n+        if (matcher.find()) {\n+            String fromAddr = matcher.group(1);\n+            String toAddr = matcher.group(2);\n+\n+            \/\/ Confirm events sent for both original and relocated nmethod\n+            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + fromAddr);\n+            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + toAddr);\n+            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + fromAddr);\n+            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + toAddr);\n+        } else {\n+            System.err.println(oa.getOutput());\n+            throw new RuntimeException(\"Unable to find relocation information\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NMethodRelocation\/nmethodrelocation\/TestDriver.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"agent_common.hpp\"\n+#include \"jvmti_tools.hpp\"\n+\n+extern \"C\" {\n+\n+\/* scaffold objects *\/\n+static jlong timeout = 0;\n+\n+#define EVENTS_COUNT    2\n+\n+\/* tested events *\/\n+static jvmtiEvent eventsList[EVENTS_COUNT] = {\n+    JVMTI_EVENT_COMPILED_METHOD_LOAD,\n+    JVMTI_EVENT_COMPILED_METHOD_UNLOAD\n+};\n+\n+\/** Agent library initialization. *\/\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_setevntcallb001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_setevntcallb001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_setevntcallb001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+\n+\/* ============================================================================= *\/\n+\n+\/** Agent algorithm. *\/\n+static void JNICALL\n+agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {\n+    NSK_DISPLAY0(\"Wait for tested method forced to compile\\n\");\n+    if (!nsk_jvmti_waitForSync(timeout))\n+        return;\n+\n+    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr)) {\n+        nsk_jvmti_setFailStatus();\n+    }\n+\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr)) {\n+        nsk_jvmti_setFailStatus();\n+    }\n+\n+    NSK_DISPLAY0(\"Let debugee to finish\\n\");\n+    if (!nsk_jvmti_resumeSync())\n+        return;\n+}\n+\n+\/* ============================================================================= *\/\n+\n+JNIEXPORT void JNICALL\n+callbackCompiledMethodLoad(jvmtiEnv* jvmti, jmethodID method,\n+                            jint code_size, const void* code_addr,\n+                            jint map_length, const jvmtiAddrLocationMap* map,\n+                            const void* compile_info) {\n+    char* name = nullptr;\n+    char* sig = nullptr;\n+\n+    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n+        printf(\"    [Could not retrieve method name]\\n\");\n+        fflush(stdout);\n+        return;\n+    }\n+\n+    printf(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n+        name, (uintptr_t)code_addr);\n+    fflush(stdout);\n+}\n+\n+\/**\n+ * Callback for COMPILED_METHOD_UNLOAD event.\n+ *\/\n+JNIEXPORT void JNICALL\n+callbackCompiledMethodUnload(jvmtiEnv* jvmti, jmethodID method,\n+                             const void* code_addr) {\n+    char* name = nullptr;\n+    char* sig = nullptr;\n+\n+    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n+        printf(\"    [Could not retrieve method name]\\n\");\n+        fflush(stdout);\n+        return;\n+    }\n+    printf(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n+        name, (uintptr_t)code_addr);\n+    fflush(stdout);\n+}\n+\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti = nullptr;\n+\n+    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n+        return JNI_ERR;\n+\n+    timeout = nsk_jvmti_getWaitTime() * 60 * 1000;\n+\n+    if (!NSK_VERIFY((jvmti =\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n+        return JNI_ERR;\n+\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n+        return JNI_ERR;\n+\n+    \/* add required capabilities *\/\n+    {\n+        jvmtiCapabilities caps;\n+        memset(&caps, 0, sizeof(caps));\n+        caps.can_generate_compiled_method_load_events = 1;\n+        if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n+            return JNI_ERR;\n+    }\n+\n+    \/* set event callbacks *\/\n+    {\n+        jvmtiEventCallbacks eventCallbacks;\n+        memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n+        eventCallbacks.CompiledMethodLoad = callbackCompiledMethodLoad;\n+        eventCallbacks.CompiledMethodUnload = callbackCompiledMethodUnload;\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks))))\n+            return JNI_ERR;\n+\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr)))\n+            return JNI_ERR;\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, nullptr)))\n+            return JNI_ERR;\n+    }\n+\n+    return JNI_OK;\n+}\n+\n+\/* ============================================================================= *\/\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NMethodRelocation\/nmethodrelocation\/agentnmethodrelocation001.cpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -33,1 +33,1 @@\n-#include \"addcaps001.cpp\"\n+#include \"agentnmethodrelocation001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NMethodRelocation\/nmethodrelocation\/libagentnmethodrelocation001.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AddCapabilities\/addcaps001\/libaddcaps001.cpp","status":"copied"},{"patch":"@@ -493,0 +493,6 @@\n+  private native void     relocateNMethodFromMethod0(Executable method, int type);\n+  public         void     relocateNMethodFromMethod(Executable method, int type) {\n+    Objects.requireNonNull(method);\n+    relocateNMethodFromMethod0(method, type);\n+  }\n+  public native void    relocateNMethodFromAddr(long address, int type);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    assert obj.length == 4;\n+    assert obj.length == 6;\n@@ -56,0 +56,2 @@\n+    code_begin = (Long) obj[4];\n+    isNMethod = (Boolean) obj[5];\n@@ -61,0 +63,2 @@\n+  public final long code_begin;\n+  public final boolean isNMethod;\n@@ -68,0 +72,1 @@\n+        + \", code_begin=\" + code_begin\n","filename":"test\/lib\/jdk\/test\/whitebox\/code\/CodeBlob.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}