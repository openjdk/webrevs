{"files":[{"patch":"@@ -79,1 +79,1 @@\n-void NativeCall::set_destination_mt_safe(address dest) {\n+void NativeCall::set_destination_mt_safe(address dest, bool update_trampoline) {\n@@ -90,1 +90,1 @@\n-  if (trampoline_stub_addr != nullptr) {\n+  if (trampoline_stub_addr != nullptr && update_trampoline) {\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-  void set_destination_mt_safe(address dest);\n+  void set_destination_mt_safe(address dest, bool update_trampoline=true);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,1 +84,9 @@\n-    call->set_destination(x);\n+    CodeBlob* cb = CodeCache::find_blob(addr());\n+    if (cb->is_nmethod()) {\n+      \/\/ Relocation for trampoline stub will fix its own destination\n+      call->set_destination_mt_safe(x, false);\n+      assert(pd_call_destination(addr()) == x || pd_call_destination(addr()) == call->get_trampoline(), \"fail in reloc\");\n+    } else {\n+      call->set_destination(x);\n+      assert(pd_call_destination(addr()) == x, \"fail in reloc\");\n+    }\n@@ -87,0 +95,1 @@\n+    assert(pd_call_destination(addr()) == x, \"fail in reloc\");\n@@ -88,1 +97,0 @@\n-  assert(pd_call_destination(addr()) == x, \"fail in reloc\");\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -413,13 +413,0 @@\n-\/\/ We must check that the new offset can still fit in the instruction\n-\/\/ for architectures that have small branch ranges\n-#if defined(AARCH64) || defined(RISV)\n-  if (!Assembler::reachable_from_branch_at(addr(), callee)) {\n-    if (NativeCall::is_call_at(addr())) {\n-      NativeCall* call = nativeCall_at(addr());\n-      address trampoline = call->get_trampoline();\n-      guarantee(trampoline != nullptr, \"Must have trampoline for far call\");\n-      callee = trampoline;\n-    }\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-\n-\n@@ -29,1 +27,2 @@\n- * @summary\n+ * @bug 8316694\n+ * @summary Verify that nmethod relocation posts the correct JVMTI events\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NMethodRelocation\/nmethodrelocation\/TestDriver.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -92,2 +92,2 @@\n-    printf(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016lx\\n\",\n-        name, (unsigned long)code_addr);\n+    printf(\"<COMPILED_METHOD_LOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n+        name, (uintptr_t)code_addr);\n@@ -111,2 +111,2 @@\n-    printf(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016lx\\n\",\n-        name, (unsigned long)code_addr);\n+    printf(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: 0x%016\" PRIxPTR \"\\n\",\n+        name, (uintptr_t)code_addr);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NMethodRelocation\/nmethodrelocation\/agentnmethodrelocation001.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}