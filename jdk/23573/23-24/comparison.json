{"files":[{"patch":"@@ -84,5 +84,0 @@\n-    if (!Assembler::reachable_from_branch_at(addr(), x)) {\n-      address trampoline = call->get_trampoline();\n-      guarantee(trampoline != nullptr, \"Must have trampoline for far call\");\n-      x = trampoline;\n-    }\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -262,1 +262,1 @@\n-  static CodeBlobType get_code_blob_type(nmethod* nm) {\n+  static CodeBlobType get_code_blob_type(const nmethod* nm) {\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1584,0 +1584,4 @@\n+      nm_copy->post_compiled_method_load_event();\n+\n+      nm_copy->log_relocated_nmethod(this);\n+\n@@ -1868,0 +1872,34 @@\n+\n+void nmethod::log_relocated_nmethod(nmethod* original) const {\n+  if (LogCompilation && xtty != nullptr) {\n+    ttyLocker ttyl;\n+    xtty->begin_elem(\"relocated nmethod\");\n+    log_identity(xtty);\n+    xtty->print(\" entry='\" INTPTR_FORMAT \"' size='%d'\", p2i(code_begin()), size());\n+\n+    const char* original_code_heap_name = CodeCache::get_code_heap_name(CodeCache::get_code_blob_type(original));\n+    xtty->print(\" original_address='\" INTPTR_FORMAT \"'\", p2i(original));\n+    xtty->print(\" original_code_heap='%s'\", original_code_heap_name);\n+\n+    const char* new_code_heap_name = CodeCache::get_code_heap_name(CodeCache::get_code_blob_type(this));\n+    xtty->print(\" new_address='\" INTPTR_FORMAT \"'\", p2i(this));\n+    xtty->print(\" new_code_heap='%s'\", new_code_heap_name);\n+\n+    LOG_OFFSET(xtty, relocation);\n+    LOG_OFFSET(xtty, consts);\n+    LOG_OFFSET(xtty, insts);\n+    LOG_OFFSET(xtty, stub);\n+    LOG_OFFSET(xtty, scopes_data);\n+    LOG_OFFSET(xtty, scopes_pcs);\n+    LOG_OFFSET(xtty, dependencies);\n+    LOG_OFFSET(xtty, handler_table);\n+    LOG_OFFSET(xtty, nul_chk_table);\n+    LOG_OFFSET(xtty, oops);\n+    LOG_OFFSET(xtty, metadata);\n+\n+    xtty->method(method());\n+    xtty->stamp();\n+    xtty->end_elem();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -967,0 +967,1 @@\n+  void log_relocated_nmethod(nmethod* original) const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -387,0 +387,9 @@\n+  if (!Assembler::reachable_from_branch_at(addr(), callee)) {\n+    if (NativeCall::is_call_at(addr())) {\n+      NativeCall* call = nativeCall_at(addr());\n+      address trampoline = call->get_trampoline();\n+      guarantee(trampoline != nullptr, \"Must have trampoline for far call\");\n+      callee = trampoline;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1561,0 +1561,1 @@\n+      code_begin((jlong) blob->code_begin()),\n@@ -1567,0 +1568,1 @@\n+  const jlong       code_begin;\n@@ -1574,1 +1576,1 @@\n-  jobjectArray result = env->NewObjectArray(5, clazz, nullptr);\n+  jobjectArray result = env->NewObjectArray(6, clazz, nullptr);\n@@ -1592,1 +1594,1 @@\n-  obj = booleanBox(thread, env, cb->is_nmethod);\n+  obj = longBox(thread, env, cb->code_begin);\n@@ -1596,0 +1598,4 @@\n+  obj = booleanBox(thread, env, cb->is_nmethod);\n+  CHECK_JNI_EXCEPTION_(env, nullptr);\n+  env->SetObjectArrayElement(result, 5, obj);\n+\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jvmti.NMethodRelocation;\n+\n+import java.io.PrintStream;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+\n+import nsk.share.*;\n+import nsk.share.jvmti.*;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.NMethod;\n+import jdk.test.whitebox.code.BlobType;\n+\n+public class nmethodrelocation extends DebugeeClass {\n+\n+    protected static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    \/** Value of {@code -XX:CompileThreshold} *\/\n+    protected static final int COMPILE_THRESHOLD\n+        = Integer.parseInt(getVMOption(\"CompileThreshold\", \"10000\"));\n+\n+    \/** Load native library if required. *\/\n+    static {\n+        loadLibrary(\"agentnmethodrelocation001\");\n+    }\n+\n+    \/**\n+     * Returns value of VM option.\n+     *\n+     * @param name option's name\n+     * @return value of option or {@code null}, if option doesn't exist\n+     * @throws NullPointerException if name is null\n+     *\/\n+    protected static String getVMOption(String name) {\n+        Objects.requireNonNull(name);\n+        return Objects.toString(WHITE_BOX.getVMFlag(name), null);\n+    }\n+\n+    \/**\n+     * Returns value of VM option or default value.\n+     *\n+     * @param name         option's name\n+     * @param defaultValue default value\n+     * @return value of option or {@code defaultValue}, if option doesn't exist\n+     * @throws NullPointerException if name is null\n+     * @see #getVMOption(String)\n+     *\/\n+    protected static String getVMOption(String name, String defaultValue) {\n+        String result = getVMOption(name);\n+        return result == null ? defaultValue : result;\n+    }\n+    public static void main(String argv[]) throws Exception {\n+        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n+\n+        run();\n+    }\n+\n+    static int status = Consts.TEST_PASSED;\n+\n+    public static int run() throws Exception {\n+        Executable method = nmethodrelocation.class.getDeclaredMethod(\"compiledMethod\");\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+\n+        compile();\n+\n+        NMethod originalNMethod = NMethod.get(method, false);\n+        if (originalNMethod == null) {\n+            throw new AssertionError(\"Could not find original nmethod\");\n+        }\n+\n+        WHITE_BOX.relocateNMethodFromAddr(originalNMethod.address, BlobType.MethodNonProfiled.id);\n+\n+        NMethod relocatedNMethod = NMethod.get(method, false);\n+        if (relocatedNMethod == null) {\n+            throw new AssertionError(\"Could not find relocated nmethod\");\n+        }\n+\n+        if (originalNMethod.address == relocatedNMethod.address) {\n+            throw new AssertionError(\"Relocated nmethod same as original\");\n+        }\n+\n+        WHITE_BOX.deoptimizeAll();\n+\n+        WHITE_BOX.fullGC();\n+        WHITE_BOX.fullGC();\n+\n+        status = checkStatus(status);\n+\n+        System.out.printf(\"Relocated nmethod from %d to %d%n\", originalNMethod.code_begin, relocatedNMethod.code_begin);\n+        System.out.flush();\n+\n+        return status;\n+    }\n+\n+    private static void compile() {\n+        for (int i = 0; i < COMPILE_THRESHOLD; i++) {\n+            compiledMethod();\n+        }\n+    }\n+\n+    public static long compiledMethod() {\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NMethodRelocation\/nmethodrelocation.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary\n+ *\n+ * @library \/vmTestbase \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/native TestDriver\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Asserts;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+public class TestDriver {\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-agentlib:agentnmethodrelocation001=-waittime=5\",\n+                \"--enable-native-access=ALL-UNNAMED\",\n+                \"-Xbootclasspath\/a:.\",\n+                \"-XX:+UseG1GC\",\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+WhiteBoxAPI\",\n+                \"-XX:+SegmentedCodeCache\",\n+                \"-XX:-TieredCompilation\",\n+                \"-Xbatch\",\n+                nsk.jvmti.NMethodRelocation.nmethodrelocation.class.getName());\n+\n+        OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+        String output = oa.getOutput();\n+        if (oa.getExitValue() != 0) {\n+            System.err.println(oa.getOutput());\n+            throw new RuntimeException(\"Non-zero exit code returned from the test\");\n+        }\n+        Asserts.assertTrue(oa.getExitValue() == 0);\n+\n+        Pattern pattern = Pattern.compile(\"(?m)^Relocated nmethod from (\\\\d+) to (\\\\d+)$\");\n+        Matcher matcher = pattern.matcher(output);\n+\n+        if (matcher.find()) {\n+            String fromAddr = matcher.group(1);\n+            String toAddr = matcher.group(2);\n+\n+            \/\/ Confirm events sent for both original and relocated nmethod\n+            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + fromAddr);\n+            oa.shouldContain(\"<COMPILED_METHOD_LOAD>:   name: compiledMethod, code: \" + toAddr);\n+            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + fromAddr);\n+            oa.shouldContain(\"<COMPILED_METHOD_UNLOAD>:   name: compiledMethod, code: \" + toAddr);\n+        } else {\n+            throw new RuntimeException(\"Unable to find relocation information\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NMethodRelocation\/nmethodrelocation\/TestDriver.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"agent_common.hpp\"\n+#include \"jvmti_tools.hpp\"\n+\n+extern \"C\" {\n+\n+\/* scaffold objects *\/\n+static jlong timeout = 0;\n+\n+#define EVENTS_COUNT    2\n+\n+\/* tested events *\/\n+static jvmtiEvent eventsList[EVENTS_COUNT] = {\n+    JVMTI_EVENT_COMPILED_METHOD_LOAD,\n+    JVMTI_EVENT_COMPILED_METHOD_UNLOAD\n+};\n+\n+\/** Agent library initialization. *\/\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_setevntcallb001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_setevntcallb001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_setevntcallb001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+\n+\/* ============================================================================= *\/\n+\n+\/** Agent algorithm. *\/\n+static void JNICALL\n+agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {\n+    NSK_DISPLAY0(\"Wait for tested method forced to compile\\n\");\n+    if (!nsk_jvmti_waitForSync(timeout))\n+        return;\n+\n+    if (!nsk_jvmti_enableEvents(JVMTI_ENABLE, EVENTS_COUNT, eventsList, nullptr)) {\n+        nsk_jvmti_setFailStatus();\n+    }\n+\n+    if (!nsk_jvmti_enableEvents(JVMTI_DISABLE, EVENTS_COUNT, eventsList, nullptr)) {\n+        nsk_jvmti_setFailStatus();\n+    }\n+\n+    NSK_DISPLAY0(\"Let debugee to finish\\n\");\n+    if (!nsk_jvmti_resumeSync())\n+        return;\n+}\n+\n+\/* ============================================================================= *\/\n+\n+JNIEXPORT void JNICALL\n+callbackCompiledMethodLoad(jvmtiEnv* jvmti, jmethodID method,\n+                            jint code_size, const void* code_addr,\n+                            jint map_length, const jvmtiAddrLocationMap* map,\n+                            const void* compile_info) {\n+    char* name = nullptr;\n+    char* sig = nullptr;\n+\n+    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n+        printf(\"    [Could not retrieve method name]\\n\");\n+        fflush(stdout);\n+        return;\n+    }\n+\n+    printf(\"<COMPILED_METHOD_LOAD>:   name: %s, code: %lu\\n\",\n+        name, code_addr);\n+    fflush(stdout);\n+}\n+\n+\/**\n+ * Callback for COMPILED_METHOD_UNLOAD event.\n+ *\/\n+JNIEXPORT void JNICALL\n+callbackCompiledMethodUnload(jvmtiEnv* jvmti, jmethodID method,\n+                             const void* code_addr) {\n+    char* name = nullptr;\n+    char* sig = nullptr;\n+\n+    if (jvmti->GetMethodName(method, &name, &sig, nullptr) != JVMTI_ERROR_NONE) {\n+        printf(\"    [Could not retrieve method name]\\n\");\n+        fflush(stdout);\n+        return;\n+    }\n+    printf(\"<COMPILED_METHOD_UNLOAD>:   name: %s, code: %lu\\n\",\n+        name, (void*)code_addr);\n+    fflush(stdout);\n+}\n+\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+    jvmtiEnv* jvmti = nullptr;\n+\n+    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n+        return JNI_ERR;\n+\n+    timeout = nsk_jvmti_getWaitTime() * 60 * 1000;\n+\n+    if (!NSK_VERIFY((jvmti =\n+            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != nullptr))\n+        return JNI_ERR;\n+\n+    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, nullptr)))\n+        return JNI_ERR;\n+\n+    \/* add required capabilities *\/\n+    {\n+        jvmtiCapabilities caps;\n+        memset(&caps, 0, sizeof(caps));\n+        caps.can_generate_compiled_method_load_events = 1;\n+        if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n+            return JNI_ERR;\n+    }\n+\n+    \/* set event callbacks *\/\n+    {\n+        jvmtiEventCallbacks eventCallbacks;\n+        memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n+        eventCallbacks.CompiledMethodLoad = callbackCompiledMethodLoad;\n+        eventCallbacks.CompiledMethodUnload = callbackCompiledMethodUnload;\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks))))\n+            return JNI_ERR;\n+\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_LOAD, nullptr)))\n+            return JNI_ERR;\n+        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_COMPILED_METHOD_UNLOAD, nullptr)))\n+            return JNI_ERR;\n+    }\n+\n+    return JNI_OK;\n+}\n+\n+\/* ============================================================================= *\/\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NMethodRelocation\/nmethodrelocation\/agentnmethodrelocation001.cpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -33,1 +33,1 @@\n-#include \"addcaps001.cpp\"\n+#include \"agentnmethodrelocation001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NMethodRelocation\/nmethodrelocation\/libagentnmethodrelocation001.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AddCapabilities\/addcaps001\/libaddcaps001.cpp","status":"copied"},{"patch":"@@ -49,1 +49,1 @@\n-    assert obj.length == 5;\n+    assert obj.length == 6;\n@@ -56,1 +56,2 @@\n-    isNMethod = (Boolean) obj[4];\n+    code_begin = (Long) obj[4];\n+    isNMethod = (Boolean) obj[5];\n@@ -62,0 +63,1 @@\n+  public final long code_begin;\n@@ -70,0 +72,1 @@\n+        + \", code_begin=\" + code_begin\n","filename":"test\/lib\/jdk\/test\/whitebox\/code\/CodeBlob.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}