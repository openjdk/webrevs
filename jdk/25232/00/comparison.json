{"files":[{"patch":"@@ -49,0 +49,2 @@\n+import java.lang.classfile.TypeAnnotation.TargetInfo;\n+import java.lang.classfile.TypeAnnotation.TypePathComponent;\n@@ -308,1 +310,1 @@\n-            \"Ljdk\/internal\/RequieresIdentity;\";\n+            \"Ljdk\/internal\/RequiresIdentity;\";\n@@ -994,0 +996,6 @@\n+        if (desc.classTypeAnnotations != null && !desc.classTypeAnnotations.isEmpty()) {\n+            builder.accept(RuntimeInvisibleTypeAnnotationsAttribute.of(createTypeAnnotations(desc.classTypeAnnotations)));\n+        }\n+        if (desc.runtimeTypeAnnotations != null && !desc.runtimeTypeAnnotations.isEmpty()) {\n+            builder.accept(RuntimeVisibleTypeAnnotationsAttribute.of(createTypeAnnotations(desc.runtimeTypeAnnotations)));\n+        }\n@@ -1069,0 +1077,38 @@\n+\n+    private List<TypeAnnotation> createTypeAnnotations(List<TypeAnnotationDescription> desc) {\n+        return desc.stream().map(this::createTypeAnnotation).collect(Collectors.toList());\n+    }\n+\n+    private TypeAnnotation createTypeAnnotation(TypeAnnotationDescription desc) {\n+        Annotation baseAnn = createAnnotation(desc.annotation);\n+        TargetInfo targetInfo = switch ((String) desc.targetInfo.get(\"targetType\")) {\n+            case \"CLASS_TYPE_PARAMETER\" -> \/\/TODO: test!\n+                TargetInfo.ofClassTypeParameter((int) desc.targetInfo.get(\"typeParameterIndex\"));\n+            case \"METHOD_TYPE_PARAMETER\" ->\n+                TargetInfo.ofMethodTypeParameter((int) desc.targetInfo.get(\"typeParameterIndex\"));\n+            case \"CLASS_EXTENDS\" ->\n+                TargetInfo.ofClassExtends((int) desc.targetInfo.get(\"supertypeIndex\"));\n+            case \"CLASS_TYPE_PARAMETER_BOUND\" ->\n+                TargetInfo.ofClassTypeParameterBound((int) desc.targetInfo.get(\"typeParameterIndex\"),\n+                                                     (int) desc.targetInfo.get(\"boundIndex\"));\n+            case \"METHOD_TYPE_PARAMETER_BOUND\" ->\n+                TargetInfo.ofMethodTypeParameterBound((int) desc.targetInfo.get(\"typeParameterIndex\"),\n+                                                      (int) desc.targetInfo.get(\"boundIndex\"));\n+            case \"METHOD_RETURN\" ->\n+                TargetInfo.ofMethodReturn();\n+            case \"METHOD_RECEIVER\" ->\n+                TargetInfo.ofMethodReceiver();\n+            case \"METHOD_FORMAL_PARAMETER\" ->\n+                TargetInfo.ofMethodFormalParameter((int) desc.targetInfo.get(\"formalParameterIndex\"));\n+            case \"THROWS\" ->\n+                TargetInfo.ofThrows((int) desc.targetInfo.get(\"throwsTargetIndex\"));\n+            case \"FIELD\" ->\n+                TargetInfo.ofField();\n+            case String targetType ->\n+                throw new IllegalStateException(\"Unsupported targetType: \" + targetType);\n+        };\n+\n+        List<TypePathComponent> typePath = desc.typePath.stream().map(d -> TypePathComponent.of(TypePathComponent.Kind.valueOf(d.tag()), d.index())).toList();\n+\n+        return TypeAnnotation.of(targetInfo, typePath, baseAnn);\n+    }\n@@ -2216,1 +2262,4 @@\n-            case RuntimeVisibleTypeAnnotationsAttribute a -> {\/* do nothing for now *\/}\n+            case RuntimeInvisibleTypeAnnotationsAttribute a ->\n+                feature.classTypeAnnotations = typeAnnotations2Descriptions(a.annotations());\n+            case RuntimeVisibleTypeAnnotationsAttribute a ->\n+                feature.runtimeTypeAnnotations = typeAnnotations2Descriptions(a.annotations());\n@@ -2273,0 +2322,25 @@\n+\n+    private List<TypeAnnotationDescription> typeAnnotations2Descriptions(List<TypeAnnotation> annos) {\n+        return annos.stream().map(ta -> {\n+            TypeAnnotationDescription desc = new TypeAnnotationDescription();\n+            desc.annotation = annotation2Description(ta.annotation());\n+            desc.targetInfo = new HashMap<>();\n+            desc.targetInfo.put(\"targetType\", ta.targetInfo().targetType().name());\n+            switch (ta.targetInfo()) {\n+                case TypeAnnotation.TypeParameterTarget tpt -> desc.targetInfo.put(\"typeParameterIndex\", tpt.typeParameterIndex());\n+                case TypeAnnotation.SupertypeTarget st -> desc.targetInfo.put(\"supertypeIndex\", st.supertypeIndex());\n+                case TypeAnnotation.TypeParameterBoundTarget tpbt -> {\n+                    desc.targetInfo.put(\"typeParameterIndex\", tpbt.typeParameterIndex());\n+                    desc.targetInfo.put(\"boundIndex\", tpbt.boundIndex());\n+                }\n+                case TypeAnnotation.EmptyTarget _ -> {\n+                    \/\/ nothing to write\n+                }\n+                case TypeAnnotation.FormalParameterTarget fpt -> desc.targetInfo.put(\"formalParameterIndex\", fpt.formalParameterIndex());\n+                case TypeAnnotation.ThrowsTarget tt -> desc.targetInfo.put(\"throwsTargetIndex\", tt.throwsTargetIndex());\n+                default -> throw new IllegalStateException(ta.targetInfo().targetType().name());\n+            }\n+            desc.typePath = ta.targetPath().stream().map(tpc -> new TypeAnnotationDescription.TypePathComponentDesc(tpc.typePathKind().name(), tpc.typeArgumentIndex())).toList();\n+            return desc;\n+        }).toList();\n+    }\n@@ -2394,0 +2468,2 @@\n+        List<TypeAnnotationDescription> classTypeAnnotations;\n+        List<TypeAnnotationDescription> runtimeTypeAnnotations;\n@@ -2416,0 +2492,12 @@\n+            if (classTypeAnnotations != null && !classTypeAnnotations.isEmpty()) {\n+                output.append(\" classTypeAnnotations \");\n+                for (TypeAnnotationDescription a : classTypeAnnotations) {\n+                    output.append(quote(a.toString(), false));\n+                }\n+            }\n+            if (runtimeTypeAnnotations != null && !runtimeTypeAnnotations.isEmpty()) {\n+                output.append(\" runtimeTypeAnnotations \");\n+                for (TypeAnnotationDescription a : runtimeTypeAnnotations) {\n+                    output.append(quote(a.toString(), false));\n+                }\n+            }\n@@ -2445,0 +2533,8 @@\n+            String inClassTypeAnnotations = reader.attributes.get(\"classTypeAnnotations\");\n+            if (inClassTypeAnnotations != null) {\n+                classTypeAnnotations = parseTypeAnnotations(inClassTypeAnnotations, new int[1]);\n+            }\n+            String inRuntimeTypeAnnotations = reader.attributes.get(\"runtimeTypeAnnotations\");\n+            if (inRuntimeTypeAnnotations != null) {\n+                runtimeTypeAnnotations = parseTypeAnnotations(inRuntimeTypeAnnotations, new int[1]);\n+            }\n@@ -2457,0 +2553,2 @@\n+            hash = 89 * hash + listHashCode(this.classTypeAnnotations);\n+            hash = 89 * hash + listHashCode(this.runtimeTypeAnnotations);\n@@ -2484,0 +2582,6 @@\n+            if (!listEquals(this.classTypeAnnotations, other.classTypeAnnotations)) {\n+                return false;\n+            }\n+            if (!listEquals(this.runtimeTypeAnnotations, other.runtimeTypeAnnotations)) {\n+                return false;\n+            }\n@@ -3288,0 +3392,2 @@\n+            hash = 59 * hash + Objects.hashCode(this.classParameterAnnotations);\n+            hash = 59 * hash + Objects.hashCode(this.runtimeParameterAnnotations);\n@@ -3312,0 +3418,6 @@\n+            if (!Objects.equals(this.classParameterAnnotations, other.classParameterAnnotations)) {\n+                return false;\n+            }\n+            if (!Objects.equals(this.runtimeParameterAnnotations, other.runtimeParameterAnnotations)) {\n+                return false;\n+            }\n@@ -3639,0 +3751,34 @@\n+    static final class TypeAnnotationDescription {\n+        AnnotationDescription annotation;\n+        Map<String, Object> targetInfo;\n+        List<TypePathComponentDesc> typePath;\n+\n+        public TypeAnnotationDescription() {\n+        }\n+\n+        public TypeAnnotationDescription(AnnotationDescription annotation, Map<String, Object> targetInfo, List<TypePathComponentDesc> typePath) {\n+            this.annotation = annotation;\n+            this.targetInfo = targetInfo;\n+            this.typePath = typePath;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return annotation.toString() + \"{\" + targetInfo.entrySet().stream().map(e -> e.getKey() + \"=\" + quote(printValue(e.getValue()), false)).collect(Collectors.joining(\",\")) + \"}\" +\n+                                           (!typePath.isEmpty() ? \"[\" + typePath.stream().map(desc -> desc.tag + \":\" + desc.index).collect(Collectors.joining(\",\")) + \"]\" : \"\");\n+        }\n+\n+        private String printValue(Object obj) {\n+            if (obj instanceof String s) {\n+                return \"\\\"\" + s + \"\\\"\";\n+            } else if (obj instanceof Integer i) {\n+                return \"I\" + String.valueOf(i);\n+            } else {\n+                throw new IllegalStateException(\"Unsupported value: \" + obj.getClass());\n+            }\n+        }\n+\n+        \/\/TODO: path\n+        record TypePathComponentDesc(String tag, int index) {}\n+    }\n+\n@@ -3978,1 +4124,1 @@\n-        Map<String, Object> attribute2Value = new HashMap<>();\n+        Map<String, Object> attribute2Value = Map.of();\n@@ -3981,1 +4127,47 @@\n-            while (value.charAt(valuePointer[0]) != ')') {\n+            attribute2Value = parseMap(value, valuePointer, ')');\n+        }\n+\n+        return new AnnotationDescription(className, attribute2Value);\n+    }\n+\n+    private static Map<String, Object> parseMap(String value, int[] valuePointer, char endBracket) {\n+        Map<String, Object> attribute2Value = new HashMap<>();\n+\n+        while (value.charAt(valuePointer[0]) != endBracket) {\n+            int nameStart = ++valuePointer[0];\n+\n+            while (value.charAt(valuePointer[0]++) != '=');\n+\n+            String name = value.substring(nameStart, valuePointer[0] - 1);\n+\n+            attribute2Value.put(name, parseAnnotationValue(value, valuePointer));\n+        }\n+\n+        valuePointer[0]++;\n+\n+        return attribute2Value;\n+    }\n+\n+    public static List<TypeAnnotationDescription> parseTypeAnnotations(String encoded, int[] pointer) {\n+        List<TypeAnnotationDescription> result = new ArrayList<>();\n+\n+        while (pointer[0] < encoded.length() && encoded.charAt(pointer[0]) == '@') {\n+            pointer[0]++;\n+            result.add(parseTypeAnnotation(encoded, pointer));\n+        }\n+\n+        return result;\n+    }\n+\n+    private static TypeAnnotationDescription parseTypeAnnotation(String value, int[] valuePointer) {\n+        AnnotationDescription ann = parseAnnotation(value, valuePointer);\n+        Map<String, Object> targetInfo = Map.of();\n+\n+        if (valuePointer[0] < value.length() && value.charAt(valuePointer[0]) == '{') {\n+            targetInfo = parseMap(value, valuePointer, '}');\n+        }\n+\n+        List<TypeAnnotationDescription.TypePathComponentDesc> typePath = new ArrayList<>();\n+\n+        if (valuePointer[0] < value.length() && value.charAt(valuePointer[0]) == '[') {\n+            while (value.charAt(valuePointer[0]) != ']') {\n@@ -3984,1 +4176,1 @@\n-                while (value.charAt(valuePointer[0]++) != '=');\n+                while (value.charAt(valuePointer[0]++) != ':');\n@@ -3988,1 +4180,1 @@\n-                attribute2Value.put(name, parseAnnotationValue(value, valuePointer));\n+                typePath.add(new TypeAnnotationDescription.TypePathComponentDesc(name, Integer.parseInt(readDigits(value, valuePointer))));\n@@ -3994,1 +4186,1 @@\n-        return new AnnotationDescription(className, attribute2Value);\n+        return new TypeAnnotationDescription(ann, targetInfo, typePath);\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":199,"deletions":7,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -402,0 +402,5 @@\n+    \/**\n+     * Flag to indicate parameters that require identity.\n+     *\/\n+    public static final long REQUIRES_IDENTITY = 1L<<62; \/\/ VarSymbols (parameters)\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -972,1 +972,2 @@\n-                        anno.position.parameter_index == index;\n+                        anno.position.parameter_index == index &&\n+                        anno.type.tsym.flatName() != name.table.names.requiresIdentityInternal;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -387,0 +387,6 @@\n+        return enterSyntheticAnnotation(names.fromString(name));\n+    }\n+\n+    \/\/ Enter a synthetic class that is used to mark classes in ct.sym.\n+    \/\/ This class does not have a class file.\n+    private Type enterSyntheticAnnotation(Name name) {\n@@ -389,1 +395,1 @@\n-        ClassType type = (ClassType)enterClass(java_base, names.fromString(name)).type;\n+        ClassType type = (ClassType)enterClass(java_base, name).type;\n@@ -616,1 +622,1 @@\n-        requiresIdentityInternalType = enterSyntheticAnnotation(\"jdk.internal.RequiresIdentity+Annotation\");\n+        requiresIdentityInternalType = enterSyntheticAnnotation(names.requiresIdentityInternal);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -387,0 +387,6 @@\n+\n+            if (!c.type.isErroneous()\n+                    && toAnnotate.kind == VAR\n+                    && types.isSameType(c.type, syms.requiresIdentityType)) {\n+                toAnnotate.flags_field |= Flags.REQUIRES_IDENTITY;\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5739,1 +5739,1 @@\n-                            if (param.attribute(syms.requiresIdentityType.tsym) != null && argExps.head.type.isValueBased()) {\n+                            if ((param.flags_field & REQUIRES_IDENTITY) != 0 && argExps.head.type.isValueBased()) {\n@@ -5746,1 +5746,1 @@\n-                            if (lastParam.attribute(syms.requiresIdentityType.tsym) != null && argExps.head.type.isValueBased()) {\n+                            if ((lastParam.flags_field & REQUIRES_IDENTITY) != 0 && argExps.head.type.isValueBased()) {\n@@ -5824,1 +5824,1 @@\n-                            .filter(ta -> ta.type.tsym == syms.requiresIdentityType.tsym).toList()) {\n+                            .filter(ta -> isRequiresIdentityAnnotation(ta.type.tsym)).toList()) {\n@@ -5850,1 +5850,1 @@\n-                        .filter(ta -> ta.type.tsym == syms.requiresIdentityType.tsym).toList()) {\n+                        .filter(ta -> isRequiresIdentityAnnotation(ta.type.tsym)).toList()) {\n@@ -5860,0 +5860,4 @@\n+    private boolean isRequiresIdentityAnnotation(TypeSymbol annoType) {\n+        return annoType == syms.requiresIdentityType.tsym ||\n+               annoType.flatName() == syms.requiresIdentityInternalType.tsym.flatName();\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1559,0 +1559,3 @@\n+            } else if (proxy.type.tsym.flatName() == syms.requiresIdentityInternalType.tsym.flatName()) {\n+                Assert.check(sym.kind == VAR);\n+                sym.flags_field |= REQUIRES_IDENTITY;\n@@ -1575,0 +1578,3 @@\n+                }  else if (proxy.type.tsym == syms.requiresIdentityType.tsym) {\n+                    Assert.check(sym.kind == VAR);\n+                    sym.flags_field |= REQUIRES_IDENTITY;\n@@ -2812,3 +2818,2 @@\n-                if (annotations != null && annotations.proxies != null\n-                        && !annotations.proxies.isEmpty()) {\n-                    annotate.normal(new AnnotationCompleter(param, annotations.proxies));\n+                if (annotations != null && annotations.proxies != null) {\n+                    attachAnnotations(param, annotations.proxies);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -231,0 +231,3 @@\n+    \/\/ special annotation names\n+    public final Name requiresIdentityInternal;\n+\n@@ -415,0 +418,3 @@\n+\n+        \/\/ special annotations:\n+        requiresIdentityInternal = fromString(\"jdk.internal.RequiresIdentity+Annotation\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8356894\n+ * @summary Verify source level checks are performed properly\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main RequiresIdentityTest\n+*\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class RequiresIdentityTest extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new RequiresIdentityTest().runTests();\n+    }\n+\n+    RequiresIdentityTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testReleaseWorksAsCurrentVersion(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          import java.util.WeakHashMap;\n+                          import java.util.Optional;\n+\n+                          public class Test {\n+                              void test() {\n+                                  WeakHashMap<Optional<Integer>, Object> m = null;\n+                                  m.put(Optional.empty(), 1);\n+                              }\n+                          }\n+                          \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        var expectedErrors = List.of(\n+            \"Test.java:6:20: compiler.warn.attempt.to.use.value.based.where.identity.expected\",\n+            \"Test.java:7:29: compiler.warn.attempt.to.use.value.based.where.identity.expected\",\n+            \"2 warnings\"\n+        );\n+\n+        {\n+            var actualErrors =\n+                    new JavacTask(tb)\n+                        .options(\"-XDrawDiagnostics\")\n+                        .outdir(classes)\n+                        .files(tb.findJavaFiles(src))\n+                        .run()\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!expectedErrors.equals(actualErrors)) {\n+                throw new AssertionError(\"Incorrect errors, expected: \" + List.of(expectedErrors) +\n+                                          \", actual: \" + actualErrors);\n+            }\n+        }\n+\n+        {\n+            var actualErrors =\n+                    new JavacTask(tb)\n+                        .options(\"--release\", System.getProperty(\"java.specification.version\"),\n+                                 \"-XDrawDiagnostics\")\n+                        .outdir(classes)\n+                        .files(tb.findJavaFiles(src))\n+                        .run()\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!expectedErrors.equals(actualErrors)) {\n+                throw new AssertionError(\"Incorrect errors, expected: \" + List.of(expectedErrors) +\n+                                          \", actual: \" + actualErrors);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testModel(Path base) throws Exception {\n+        {\n+            List<String> printed =\n+                new JavacTask(tb)\n+                    .options(\"-Xprint\")\n+                    .classes(\"java.util.WeakHashMap\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            printed.removeIf(l -> !l.contains(\"put(\") && !l.contains(\"class WeakHashMap<\"));\n+\n+            List<String> expected = List.of(\n+                \"public class WeakHashMap<@jdk.internal.RequiresIdentity K, V> extends java.util.AbstractMap<K,V> implements java.util.Map<K,V> {\",\n+                \"  public V put(@jdk.internal.RequiresIdentity sealed K key,\"\n+            );\n+            if (!expected.equals(printed)) {\n+                throw new AssertionError(\"Expected: \" + expected +\n+                                         \", but got: \" + printed);\n+            }\n+        }\n+\n+        {\n+            List<String> printed =\n+                new JavacTask(tb)\n+                    .options(\"--release\", System.getProperty(\"java.specification.version\"),\n+                             \"-Xprint\")\n+                    .classes(\"java.util.WeakHashMap\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            printed.removeIf(l -> !l.contains(\"put(\") && !l.contains(\"class WeakHashMap<\"));\n+\n+            List<String> expected = List.of(\n+                \"public class WeakHashMap<K, V> extends java.util.AbstractMap<K,V> implements java.util.Map<K,V> {\",\n+                \"  public V put(sealed K arg0,\"\n+            );\n+            if (!expected.equals(printed)) {\n+                throw new AssertionError(\"Expected: \" + expected +\n+                                         \", but got: \" + printed);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/platform\/RequiresIdentityTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+RequiresIdentityTest.java:16:18: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+- compiler.err.warnings.and.werror\n+1 error\n+1 warning\n","filename":"test\/langtools\/tools\/javac\/platform\/RequiresIdentityTest.out","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -24,13 +24,0 @@\n-\/**\n- * @test\n- * @bug 8072480 8277106 8331027\n- * @summary Unit test for CreateSymbols\n- * @modules java.compiler\n- *          jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.jvm\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.javac.util\n- * @clean *\n- * @run main\/othervm CreateSymbolsTest\n- *\/\n-\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTest.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,13 @@\n+\/**\n+ * @test\n+ * @bug 8072480 8277106 8331027\n+ * @summary Unit test for CreateSymbols\n+ * @modules java.compiler\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.jvm\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @clean *\n+ * @run main\/othervm CreateSymbolsTest\n+ *\/\n+\n@@ -911,0 +924,103 @@\n+    @Test\n+    void testTypeAnnotations() throws Exception {\n+        doPrintElementTest(\"\"\"\n+                           package t;\n+                           public class T {\n+                           }\n+                           \"\"\",\n+                           \"\"\"\n+                           package t;\n+                           import java.lang.annotation.*;\n+                           import java.util.*;\n+                           public class T<@AnnInvisible @AnnVisible E extends @AnnInvisible @AnnVisible ArrayList<@AnnInvisible @AnnVisible ArrayList>> extends @AnnInvisible @AnnVisible ArrayList {\n+                               public @AnnInvisible @AnnVisible List<@AnnInvisible @AnnVisible E> field;\n+                               public <@AnnInvisible @AnnVisible M extends @AnnInvisible @AnnVisible ArrayList<@AnnInvisible @AnnVisible ArrayList>> @AnnInvisible @AnnVisible List<@AnnInvisible @AnnVisible M> convert(@AnnInvisible @AnnVisible T<E> this, @AnnInvisible @AnnVisible M e1, @AnnInvisible @AnnVisible List<@AnnInvisible @AnnVisible E> e2) throws @AnnInvisible @AnnVisible IllegalStateException, @AnnInvisible @AnnVisible IllegalArgumentException {\n+                                   return null;\n+                               }\n+                           }\n+                           @Retention(RetentionPolicy.RUNTIME)\n+                           @Target(ElementType.TYPE_USE)\n+                           @interface AnnVisible {\n+                           }\n+                           @Retention(RetentionPolicy.CLASS)\n+                           @Target(ElementType.TYPE_USE)\n+                           @interface AnnInvisible {\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T {\n+\n+                             public T();\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T<@t.AnnInvisible @t.AnnVisible E extends java.util.@t.AnnInvisible @t.AnnVisible ArrayList<java.util.@t.AnnInvisible @t.AnnVisible ArrayList>> extends java.util.@t.AnnInvisible @t.AnnVisible ArrayList {\n+                             public java.util.@t.AnnInvisible @t.AnnVisible List<@t.AnnInvisible @t.AnnVisible E> field;\n+\n+                             public T();\n+\n+                             public <@t.AnnInvisible @t.AnnVisible M extends java.util.@t.AnnInvisible @t.AnnVisible ArrayList<java.util.@t.AnnInvisible @t.AnnVisible ArrayList>> java.util.@t.AnnInvisible @t.AnnVisible List<@t.AnnInvisible @t.AnnVisible M> convert(@t.AnnInvisible @t.AnnVisible M arg0,\n+                               java.util.@t.AnnInvisible @t.AnnVisible List<@t.AnnInvisible @t.AnnVisible E> arg1) throws java.lang.@t.AnnInvisible @t.AnnVisible IllegalStateException,\\s\n+                               java.lang.@t.AnnInvisible @t.AnnVisible IllegalArgumentException;\n+                           }\n+                           \"\"\");\n+    }\n+\n+    @Test\n+    void testParameterAnnotations() throws Exception {\n+        doPrintElementTest(\"\"\"\n+                           package t;\n+                           public class T {\n+                               public void test(int p1, int p2) {\n+                               }\n+                           }\n+                           \"\"\",\n+                           \"\"\"\n+                           package t;\n+                           import java.lang.annotation.*;\n+                           import java.util.*;\n+                           public class T {\n+                               public void test(@AnnVisible int p1, @AnnInvisible int p2) {\n+                               }\n+                           }\n+                           @Retention(RetentionPolicy.RUNTIME)\n+                           @Target(ElementType.PARAMETER)\n+                           @interface AnnVisible {\n+                           }\n+                           @Retention(RetentionPolicy.CLASS)\n+                           @Target(ElementType.PARAMETER)\n+                           @interface AnnInvisible {\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T {\n+\n+                             public T();\n+\n+                             public void test(int arg0,\n+                               int arg1);\n+                           }\n+                           \"\"\",\n+                           \"t.T\",\n+                           \"\"\"\n+                           package t;\n+\n+                           public class T {\n+\n+                             public T();\n+\n+                             public void test(@t.AnnVisible int arg0,\n+                               @t.AnnInvisible int arg1);\n+                           }\n+                           \"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/platform\/createsymbols\/CreateSymbolsTestImpl.java","additions":117,"deletions":1,"binary":false,"changes":118,"status":"modified"}]}