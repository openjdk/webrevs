{"files":[{"patch":"@@ -621,0 +621,1 @@\n+            Objects.requireNonNull(interfaces);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,6 +28,3 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import sun.invoke.util.Wrapper;\n+import java.lang.classfile.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n@@ -37,1 +34,3 @@\n-import java.lang.invoke.MethodType;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n@@ -46,0 +45,1 @@\n+import java.util.Objects;\n@@ -47,1 +47,4 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.util.StringJoiner;\n@@ -56,27 +59,28 @@\n-final class ProxyGenerator extends ClassWriter {\n-    private static final int CLASSFILE_VERSION = ClassFileFormatVersion.latest().major();\n-    private static final String JL_CLASS = \"java\/lang\/Class\";\n-    private static final String JL_OBJECT = \"java\/lang\/Object\";\n-    private static final String JL_THROWABLE = \"java\/lang\/Throwable\";\n-    private static final String JL_CLASS_NOT_FOUND_EX = \"java\/lang\/ClassNotFoundException\";\n-    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n-\n-    private static final String JL_NO_CLASS_DEF_FOUND_ERROR = \"java\/lang\/NoClassDefFoundError\";\n-    private static final String JL_NO_SUCH_METHOD_EX = \"java\/lang\/NoSuchMethodException\";\n-    private static final String JL_NO_SUCH_METHOD_ERROR = \"java\/lang\/NoSuchMethodError\";\n-    private static final String JLI_LOOKUP = \"java\/lang\/invoke\/MethodHandles$Lookup\";\n-    private static final String JLI_METHODHANDLES = \"java\/lang\/invoke\/MethodHandles\";\n-\n-    private static final String JLR_INVOCATION_HANDLER = \"java\/lang\/reflect\/InvocationHandler\";\n-    private static final String JLR_PROXY = \"java\/lang\/reflect\/Proxy\";\n-    private static final String JLR_UNDECLARED_THROWABLE_EX = \"java\/lang\/reflect\/UndeclaredThrowableException\";\n-\n-    private static final String LJL_CLASS = \"Ljava\/lang\/Class;\";\n-    private static final String LJL_CLASSLOADER = \"Ljava\/lang\/ClassLoader;\";\n-    private static final String LJLR_METHOD = \"Ljava\/lang\/reflect\/Method;\";\n-    private static final String LJLR_INVOCATION_HANDLER = \"Ljava\/lang\/reflect\/InvocationHandler;\";\n-\n-    private static final String MJLR_INVOCATIONHANDLER = \"(Ljava\/lang\/reflect\/InvocationHandler;)V\";\n-\n-    private static final String NAME_CTOR = \"<init>\";\n-    private static final String NAME_CLINIT = \"<clinit>\";\n+final class ProxyGenerator {\n+\n+    private static final ClassDesc\n+            CD_ClassLoader = ClassDesc.ofInternalName(\"java\/lang\/ClassLoader\"),\n+            CD_ClassNotFoundException = ClassDesc.ofInternalName(\"java\/lang\/ClassNotFoundException\"),\n+            CD_IllegalAccessException = ClassDesc.ofInternalName(\"java\/lang\/IllegalAccessException\"),\n+            CD_InvocationHandler = ClassDesc.ofInternalName(\"java\/lang\/reflect\/InvocationHandler\"),\n+            CD_Method = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Method\"),\n+            CD_NoClassDefFoundError = ClassDesc.ofInternalName(\"java\/lang\/NoClassDefFoundError\"),\n+            CD_NoSuchMethodError = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodError\"),\n+            CD_NoSuchMethodException = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodException\"),\n+            CD_Proxy = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Proxy\"),\n+            CD_UndeclaredThrowableException = ClassDesc.ofInternalName(\"java\/lang\/reflect\/UndeclaredThrowableException\");\n+\n+    private static final MethodTypeDesc\n+            MTD_boolean = MethodTypeDesc.of(CD_boolean),\n+            MTD_void_InvocationHandler = MethodTypeDesc.of(CD_void, CD_InvocationHandler),\n+            MTD_void_String = MethodTypeDesc.of(CD_void, CD_String),\n+            MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable),\n+            MTD_Class = MethodTypeDesc.of(CD_Class),\n+            MTD_Class_String_boolean_ClassLoader = MethodTypeDesc.of(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n+            MTD_ClassLoader = MethodTypeDesc.of(CD_ClassLoader),\n+            MTD_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup),\n+            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup),\n+            MTD_Method_String_ClassArray = MethodTypeDesc.of(CD_Method, CD_String, CD_Class.arrayType()),\n+            MTD_Object_Object_Method_ObjectArray = MethodTypeDesc.of(CD_Object, CD_Object, CD_Method, CD_Object.arrayType()),\n+            MTD_String = MethodTypeDesc.of(CD_String);\n+\n@@ -106,0 +110,22 @@\n+    private static final ClassModel TEMPLATE;\n+\n+    private static final Utf8Entry UE_Method;\n+    private static final MethodRefEntry MRE_Class_getClassLoader;\n+    private static final MethodRefEntry MRE_NoSuchMethodError_init;\n+    private static final ClassEntry CE_NoSuchMethodError;\n+    private static final FieldRefEntry FRE_Proxy_h;\n+    private static final ClassEntry CE_NoClassDefFoundError;\n+    private static final MethodRefEntry MRE_NoClassDefFoundError_init;\n+    private static final MethodRefEntry MRE_Throwable_getMessage;\n+    private static final MethodRefEntry MRE_Class_forName;\n+    private static final ClassEntry CE_Class;\n+    private static final MethodRefEntry MRE_Class_getMethod;\n+    private static final ClassEntry CE_Object;\n+    private static final InterfaceMethodRefEntry IMRE_InvocationHandler_invoke;\n+    private static final MethodRefEntry MRE_UndeclaredThrowableException_init;\n+    private static final ClassEntry CE_UndeclaredThrowableException;\n+    private static final ClassEntry CE_Throwable;\n+    private static final ClassEntry CE_NoSuchMethodException;\n+    private static final ClassEntry CE_ClassNotFoundException;\n+    private static final List<StackMapFrameInfo.VerificationTypeInfo> THROWABLE_STACK;\n+\n@@ -107,0 +133,40 @@\n+        var cc = ClassFile.of();\n+        var entries = new ArrayList<PoolEntry>(20);\n+        var q = new Object() {\n+            PoolEntry[] entries;\n+            int i;\n+            @SuppressWarnings(\"unchecked\")\n+            <T extends PoolEntry> T next() {\n+                return (T) TEMPLATE.constantPool().entryByIndex(entries[i++].index());\n+            }\n+        };\n+        TEMPLATE = cc.parse(cc.build(CD_Proxy, clb -> {\n+            clb.withSuperclass(CD_Proxy);\n+            generateConstructor(clb);\n+            generateLookupAccessor(clb);\n+            var cp = clb.constantPool();\n+            q.entries = new PoolEntry[] {\n+                cp.utf8Entry(\"m0\"),\n+                cp.utf8Entry(\"m1\"),\n+                cp.utf8Entry(\"m2\"),\n+                cp.utf8Entry(CD_Method),\n+                cp.methodRefEntry(CD_Class, \"getClassLoader\", MTD_ClassLoader),\n+                cp.classEntry(CD_NoSuchMethodError),\n+                cp.methodRefEntry(CD_NoSuchMethodError, INIT_NAME, MTD_void_String),\n+                cp.fieldRefEntry(CD_Proxy, handlerFieldName, CD_InvocationHandler),\n+                cp.classEntry(CD_NoClassDefFoundError),\n+                cp.methodRefEntry(CD_NoClassDefFoundError, INIT_NAME, MTD_void_String),\n+                cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String),\n+                cp.methodRefEntry(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader),\n+                cp.classEntry(CD_Class),\n+                cp.methodRefEntry(CD_Class, \"getMethod\", MTD_Method_String_ClassArray),\n+                cp.classEntry(CD_Object),\n+                cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray),\n+                cp.methodRefEntry(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable),\n+                cp.classEntry(CD_UndeclaredThrowableException),\n+                cp.classEntry(CD_NoSuchMethodException),\n+                cp.classEntry(CD_ClassNotFoundException),\n+                cp.classEntry(CD_Throwable)\n+            };\n+        }));\n+\n@@ -108,3 +174,3 @@\n-            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), \"m0\");\n-            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), \"m1\");\n-            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), \"m2\");\n+            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), q.next());\n+            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), q.next());\n+            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), q.next());\n@@ -114,0 +180,19 @@\n+        UE_Method = q.next();\n+        MRE_Class_getClassLoader = q.next();\n+        CE_NoSuchMethodError = q.next();\n+        MRE_NoSuchMethodError_init = q.next();\n+        FRE_Proxy_h = q.next();\n+        CE_NoClassDefFoundError = q.next();\n+        MRE_NoClassDefFoundError_init = q.next();\n+        MRE_Throwable_getMessage = q.next();\n+        MRE_Class_forName = q.next();\n+        CE_Class = q.next();\n+        MRE_Class_getMethod = q.next();\n+        CE_Object = q.next();\n+        IMRE_InvocationHandler_invoke = q.next();\n+        MRE_UndeclaredThrowableException_init = q.next();\n+        CE_UndeclaredThrowableException = q.next();\n+        CE_NoSuchMethodException = q.next();\n+        CE_ClassNotFoundException = q.next();\n+        CE_Throwable = q.next();\n+        THROWABLE_STACK = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(CE_Throwable));\n@@ -117,1 +202,1 @@\n-     * Class loader\n+     * Classfile context\n@@ -119,1 +204,2 @@\n-    private final ClassLoader loader;\n+    private final ClassFile classfileContext;\n+    private final ConstantPoolBuilder cp;\n@@ -124,1 +210,1 @@\n-    private final String className;\n+    private ClassEntry classEntry;\n@@ -158,3 +244,6 @@\n-        super(ClassWriter.COMPUTE_FRAMES);\n-        this.loader = loader;\n-        this.className = className;\n+        this.classfileContext = ClassFile.of(\n+                ClassFile.StackMapsOption.DROP_STACK_MAPS,\n+                ClassFile.ClassHierarchyResolverOption.of(\n+                        ClassHierarchyResolver.ofClassLoading(loader).cached()));\n+        this.cp = ConstantPoolBuilder.of(TEMPLATE);\n+        this.classEntry = cp.classEntry(ClassDesc.of(className));\n@@ -177,0 +266,1 @@\n+        Objects.requireNonNull(interfaces);\n@@ -188,1 +278,1 @@\n-                                    Path dir = Path.of(dotToSlash(name.substring(0, i)));\n+                                    Path dir = Path.of(name.substring(0, i).replace('.', '\/'));\n@@ -208,5 +298,13 @@\n-     * Return an array of the class and interface names from an array of Classes.\n-     *\n-     * @param classes an array of classes or interfaces\n-     * @return the array of class and interface names; or null if classes is\n-     * null or empty\n+     * {@return the entries of the given type}\n+     * @param type the {@code Class} objects, no primitives nor arrays\n+     *\/\n+    private static ClassEntry[] toClassEntries(ConstantPoolBuilder cp, List<Class<?>> types) {\n+        var ces = new ClassEntry[types.size()];\n+        for (int i = 0; i< ces.length; i++)\n+            ces[i] = cp.classEntry(cp.utf8Entry(types.get(i).getName().replace('.', '\/')));\n+        return ces;\n+    }\n+\n+    \/**\n+     * {@return the {@code ClassDesc} of the given type}\n+     * @param type the {@code Class} object\n@@ -214,8 +312,2 @@\n-    private static String[] typeNames(List<Class<?>> classes) {\n-        if (classes == null || classes.size() == 0)\n-            return null;\n-        int size = classes.size();\n-        String[] ifaces = new String[size];\n-        for (int i = 0; i < size; i++)\n-            ifaces[i] = dotToSlash(classes.get(i).getName());\n-        return ifaces;\n+    private static ClassDesc toClassDesc(Class<?> type) {\n+        return ClassDesc.ofDescriptor(type.descriptorString());\n@@ -390,28 +482,0 @@\n-    \/**\n-     * Convert a fully qualified class name that uses '.' as the package\n-     * separator, the external representation used by the Java language\n-     * and APIs, to a fully qualified class name that uses '\/' as the\n-     * package separator, the representation used in the class file\n-     * format (see JVMS section {@jvms 4.2}).\n-     *\/\n-    private static String dotToSlash(String name) {\n-        return name.replace('.', '\/');\n-    }\n-\n-    \/**\n-     * Return the number of abstract \"words\", or consecutive local variable\n-     * indexes, required to contain a value of the given type.  See JVMS\n-     * section {@jvms 3.6.1}.\n-     * <p>\n-     * Note that the original version of the JVMS contained a definition of\n-     * this abstract notion of a \"word\" in section 3.4, but that definition\n-     * was removed for the second edition.\n-     *\/\n-    private static int getWordsPerType(Class<?> type) {\n-        if (type == long.class || type == double.class) {\n-            return 2;\n-        } else {\n-            return 1;\n-        }\n-    }\n-\n@@ -442,11 +506,0 @@\n-    \/**\n-     * Returns the {@link ClassLoader} to be used by the default implementation of {@link\n-     * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}'s runtime type by\n-     * default.\n-     *\n-     * @return ClassLoader\n-     *\/\n-    protected ClassLoader getClassLoader() {\n-        return loader;\n-    }\n-\n@@ -458,3 +511,0 @@\n-        visit(CLASSFILE_VERSION, accessFlags, dotToSlash(className), null,\n-                JLR_PROXY, typeNames(interfaces));\n-\n@@ -478,1 +528,1 @@\n-                    addProxyMethod(m, intf);\n+                    addProxyMethod(m, intf, cp);\n@@ -491,1 +541,4 @@\n-        generateConstructor();\n+        return classfileContext.build(classEntry, cp, clb -> {\n+            TEMPLATE.forEach(clb);\n+            clb.withFlags(accessFlags);\n+            clb.withInterfaces(toClassEntries(cp, interfaces));\n@@ -493,5 +546,4 @@\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                \/\/ add static field for the Method object\n-                visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName,\n-                        LJLR_METHOD, null, null);\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    \/\/ add static field for the Method object\n+                    clb.withField(pm.methodFieldName, UE_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -499,2 +551,3 @@\n-                \/\/ Generate code for proxy method\n-                pm.generateMethod(this, className);\n+                    \/\/ Generate code for proxy method\n+                    pm.generateMethod(clb, classEntry);\n+                }\n@@ -502,1 +555,0 @@\n-        }\n@@ -504,3 +556,2 @@\n-        generateStaticInitializer();\n-        generateLookupAccessor();\n-        return toByteArray();\n+            generateStaticInitializer(clb);\n+        });\n@@ -522,1 +573,1 @@\n-    private void addProxyMethod(Method m, Class<?> fromClass) {\n+    private void addProxyMethod(Method m, Class<?> fromClass, ConstantPoolBuilder cp) {\n@@ -548,1 +599,1 @@\n-                \"m\" + proxyMethodCount++));\n+                cp.utf8Entry(\"m\" + proxyMethodCount++)));\n@@ -566,14 +617,6 @@\n-    private void generateConstructor() {\n-        MethodVisitor ctor = visitMethod(Modifier.PUBLIC, NAME_CTOR,\n-                MJLR_INVOCATIONHANDLER, null, null);\n-        ctor.visitParameter(null, 0);\n-        ctor.visitCode();\n-        ctor.visitVarInsn(ALOAD, 0);\n-        ctor.visitVarInsn(ALOAD, 1);\n-        ctor.visitMethodInsn(INVOKESPECIAL, JLR_PROXY, NAME_CTOR,\n-                MJLR_INVOCATIONHANDLER, false);\n-        ctor.visitInsn(RETURN);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        ctor.visitMaxs(-1, -1);\n-        ctor.visitEnd();\n+    private static void generateConstructor(ClassBuilder clb) {\n+        clb.withMethodBody(INIT_NAME, MTD_void_InvocationHandler, ACC_PUBLIC, cob -> cob\n+               .aload(cob.receiverSlot())\n+               .aload(cob.parameterSlot(0))\n+               .invokespecial(CD_Proxy, INIT_NAME, MTD_void_InvocationHandler)\n+               .return_());\n@@ -585,26 +628,12 @@\n-    private void generateStaticInitializer() {\n-\n-        MethodVisitor mv = visitMethod(Modifier.STATIC, NAME_CLINIT,\n-                \"()V\", null, null);\n-        mv.visitCode();\n-        Label L_startBlock = new Label();\n-        Label L_endBlock = new Label();\n-        Label L_NoMethodHandler = new Label();\n-        Label L_NoClassHandler = new Label();\n-\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoMethodHandler,\n-                JL_NO_SUCH_METHOD_EX);\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoClassHandler,\n-                JL_CLASS_NOT_FOUND_EX);\n-\n-        \/\/ Put ClassLoader at local variable index 0, used by\n-        \/\/ Class.forName(String, boolean, ClassLoader) calls\n-        mv.visitLdcInsn(Type.getObjectType(dotToSlash(className)));\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_CLASS,\n-                \"getClassLoader\", \"()\" + LJL_CLASSLOADER, false);\n-        mv.visitVarInsn(ASTORE, 0);\n-\n-        mv.visitLabel(L_startBlock);\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                pm.codeFieldInitialization(mv, className);\n+    private void generateStaticInitializer(ClassBuilder clb) {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+            \/\/ Put ClassLoader at local variable index 0, used by\n+            \/\/ Class.forName(String, boolean, ClassLoader) calls\n+            cob.ldc(classEntry)\n+               .invokevirtual(MRE_Class_getClassLoader)\n+               .astore(0);\n+            var ts = cob.newBoundLabel();\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    pm.codeFieldInitialization(cob, classEntry);\n+                }\n@@ -612,30 +641,21 @@\n-        }\n-        mv.visitInsn(RETURN);\n-        mv.visitLabel(L_endBlock);\n-        \/\/ Generate exception handler\n-\n-        mv.visitLabel(L_NoMethodHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_SUCH_METHOD_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_SUCH_METHOD_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        mv.visitLabel(L_NoClassHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_CLASS_DEF_FOUND_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_CLASS_DEF_FOUND_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+            cob.return_();\n+            var c1 = cob.newBoundLabel();\n+            cob.exceptionCatch(ts, c1, c1, CE_NoSuchMethodException)\n+               .new_(CE_NoSuchMethodError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(MRE_Throwable_getMessage)\n+               .invokespecial(MRE_NoSuchMethodError_init)\n+               .athrow();\n+            var c2 = cob.newBoundLabel();\n+            cob.exceptionCatch(ts, c1, c2, CE_ClassNotFoundException)\n+               .new_(CE_NoClassDefFoundError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(MRE_Throwable_getMessage)\n+               .invokespecial(MRE_NoClassDefFoundError_init)\n+               .athrow()\n+               .with(StackMapTableAttribute.of(List.of(\n+                     StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n+                     StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+        });\n@@ -649,33 +669,22 @@\n-    private void generateLookupAccessor() {\n-        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n-                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n-                new String[] { JL_ILLEGAL_ACCESS_EX });\n-        mv.visitCode();\n-        Label L_illegalAccess = new Label();\n-\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n-                \"()Ljava\/lang\/Class;\", false);\n-        mv.visitLdcInsn(Type.getType(Proxy.class));\n-        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n-                \"()Z\", false);\n-        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n-        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n-                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n-        mv.visitInsn(ARETURN);\n-\n-        mv.visitLabel(L_illegalAccess);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n-                \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private static void generateLookupAccessor(ClassBuilder clb) {\n+        clb.withMethod(NAME_LOOKUP_ACCESSOR,\n+                MTD_MethodHandles$Lookup_MethodHandles$Lookup,\n+                ACC_PRIVATE | ACC_STATIC,\n+                mb -> mb.with(ExceptionsAttribute.of(List.of(mb.constantPool().classEntry(CD_IllegalAccessException))))\n+                        .withCode(cob -> cob\n+                            .block(blockBuilder -> blockBuilder\n+                                    .aload(cob.parameterSlot(0))\n+                                    .invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class)\n+                                    .constantInstruction(Opcode.LDC, CD_Proxy)\n+                                    .if_acmpne(blockBuilder.breakLabel())\n+                                    .aload(cob.parameterSlot(0))\n+                                    .invokevirtual(CD_MethodHandles_Lookup, \"hasFullPrivilegeAccess\", MTD_boolean)\n+                                    .ifeq(blockBuilder.breakLabel())\n+                                    .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n+                                    .areturn())\n+                            .new_(CD_IllegalAccessException)\n+                            .dup()\n+                            .aload(cob.parameterSlot(0))\n+                            .invokevirtual(CD_MethodHandles_Lookup, \"toString\", MTD_String)\n+                            .invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String)\n+                            .athrow()));\n@@ -696,1 +705,1 @@\n-        private final String methodFieldName;\n+        private final Utf8Entry methodFieldName;\n@@ -701,1 +710,1 @@\n-                            Class<?> fromClass, String methodFieldName) {\n+                            Class<?> fromClass, Utf8Entry methodFieldName) {\n@@ -717,1 +726,1 @@\n-        private ProxyMethod(Method method, String methodFieldName) {\n+        private ProxyMethod(Method method, Utf8Entry methodFieldName) {\n@@ -719,2 +728,2 @@\n-                    method.getSharedParameterTypes(), method.getReturnType(),\n-                    method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n+                 method.getSharedParameterTypes(), method.getReturnType(),\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n@@ -726,15 +735,5 @@\n-        private void generateMethod(ClassWriter cw, String className) {\n-            MethodType mt = MethodType.methodType(returnType, parameterTypes);\n-            String desc = mt.toMethodDescriptorString();\n-            int accessFlags = ACC_PUBLIC | ACC_FINAL;\n-            if (method.isVarArgs()) accessFlags |= ACC_VARARGS;\n-\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                    method.getName(), desc, null,\n-                    typeNames(Arrays.asList(exceptionTypes)));\n-\n-            int[] parameterSlot = new int[parameterTypes.length];\n-            int nextSlot = 1;\n-            for (int i = 0; i < parameterSlot.length; i++) {\n-                parameterSlot[i] = nextSlot;\n-                nextSlot += getWordsPerType(parameterTypes[i]);\n+        private void generateMethod(ClassBuilder clb, ClassEntry className) {\n+            var cp = clb.constantPool();\n+            var desc = new StringJoiner(\"\", \"(\", \")\" + returnType.descriptorString());\n+            for (var pt : parameterTypes) {\n+                desc.add(pt.descriptorString());\n@@ -742,0 +741,24 @@\n+            int accessFlags = (method.isVarArgs()) ? ACC_VARARGS | ACC_PUBLIC | ACC_FINAL\n+                                                   : ACC_PUBLIC | ACC_FINAL;\n+            var catchList = computeUniqueCatchList(exceptionTypes);\n+            clb.withMethod(cp.utf8Entry(method.getName()), cp.utf8Entry(desc.toString()), accessFlags, mb ->\n+                  mb.with(ExceptionsAttribute.of(toClassEntries(cp, List.of(exceptionTypes))))\n+                    .withCode(cob -> {\n+                        cob.aload(cob.receiverSlot())\n+                           .getfield(FRE_Proxy_h)\n+                           .aload(cob.receiverSlot())\n+                           .getstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n+\n+                        if (parameterTypes.length > 0) {\n+                            \/\/ Create an array and fill with the parameters converting primitives to wrappers\n+                            cob.constantInstruction(parameterTypes.length)\n+                               .anewarray(CE_Object);\n+                            for (int i = 0; i < parameterTypes.length; i++) {\n+                                cob.dup()\n+                                   .constantInstruction(i);\n+                                codeWrapArgument(cob, parameterTypes[i], cob.parameterSlot(i));\n+                                cob.aastore();\n+                            }\n+                        } else {\n+                            cob.aconst_null();\n+                        }\n@@ -743,50 +766,1 @@\n-            mv.visitCode();\n-            Label L_startBlock = new Label();\n-            Label L_endBlock = new Label();\n-            Label L_RuntimeHandler = new Label();\n-            Label L_ThrowableHandler = new Label();\n-\n-            List<Class<?>> catchList = computeUniqueCatchList(exceptionTypes);\n-            if (catchList.size() > 0) {\n-                for (Class<?> ex : catchList) {\n-                    mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_RuntimeHandler,\n-                            dotToSlash(ex.getName()));\n-                }\n-\n-                mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_ThrowableHandler,\n-                        JL_THROWABLE);\n-            }\n-            mv.visitLabel(L_startBlock);\n-\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETFIELD, JLR_PROXY, handlerFieldName,\n-                    LJLR_INVOCATION_HANDLER);\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETSTATIC, dotToSlash(className), methodFieldName,\n-                    LJLR_METHOD);\n-\n-            if (parameterTypes.length > 0) {\n-                \/\/ Create an array and fill with the parameters converting primitives to wrappers\n-                emitIconstInsn(mv, parameterTypes.length);\n-                mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_OBJECT);\n-                for (int i = 0; i < parameterTypes.length; i++) {\n-                    mv.visitInsn(DUP);\n-                    emitIconstInsn(mv, i);\n-                    codeWrapArgument(mv, parameterTypes[i], parameterSlot[i]);\n-                    mv.visitInsn(Opcodes.AASTORE);\n-                }\n-            } else {\n-                mv.visitInsn(Opcodes.ACONST_NULL);\n-            }\n-\n-            mv.visitMethodInsn(INVOKEINTERFACE, JLR_INVOCATION_HANDLER,\n-                    \"invoke\",\n-                    \"(Ljava\/lang\/Object;Ljava\/lang\/reflect\/Method;\" +\n-                            \"[Ljava\/lang\/Object;)Ljava\/lang\/Object;\", true);\n-\n-            if (returnType == void.class) {\n-                mv.visitInsn(POP);\n-                mv.visitInsn(RETURN);\n-            } else {\n-                codeUnwrapReturnValue(mv, returnType);\n-            }\n+                        cob.invokeinterface(IMRE_InvocationHandler_invoke);\n@@ -794,17 +768,24 @@\n-            mv.visitLabel(L_endBlock);\n-\n-            \/\/ Generate exception handler\n-            mv.visitLabel(L_RuntimeHandler);\n-            mv.visitInsn(ATHROW);   \/\/ just rethrow the exception\n-\n-            mv.visitLabel(L_ThrowableHandler);\n-            mv.visitVarInsn(ASTORE, 1);\n-            mv.visitTypeInsn(Opcodes.NEW, JLR_UNDECLARED_THROWABLE_EX);\n-            mv.visitInsn(DUP);\n-            mv.visitVarInsn(ALOAD, 1);\n-            mv.visitMethodInsn(INVOKESPECIAL, JLR_UNDECLARED_THROWABLE_EX,\n-                    \"<init>\", \"(Ljava\/lang\/Throwable;)V\", false);\n-            mv.visitInsn(ATHROW);\n-            \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n+                        if (returnType == void.class) {\n+                            cob.pop()\n+                               .return_();\n+                        } else {\n+                            codeUnwrapReturnValue(cob, returnType);\n+                        }\n+                        if (!catchList.isEmpty()) {\n+                            var c1 = cob.newBoundLabel();\n+                            for (var exc : catchList) {\n+                                cob.exceptionCatch(cob.startLabel(), c1, c1, toClassDesc(exc));\n+                            }\n+                            cob.athrow();   \/\/ just rethrow the exception\n+                            var c2 = cob.newBoundLabel();\n+                            cob.exceptionCatchAll(cob.startLabel(), c1, c2)\n+                               .new_(CE_UndeclaredThrowableException)\n+                               .dup_x1()\n+                               .swap()\n+                               .invokespecial(MRE_UndeclaredThrowableException_init)\n+                               .athrow()\n+                               .with(StackMapTableAttribute.of(List.of(\n+                                    StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n+                                    StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+                        }\n+                    }));\n@@ -819,1 +800,1 @@\n-        private void codeWrapArgument(MethodVisitor mv, Class<?> type, int slot) {\n+        private void codeWrapArgument(CodeBuilder cob, Class<?> type, int slot) {\n@@ -821,0 +802,1 @@\n+                cob.loadInstruction(TypeKind.from(type).asLoadable(), slot);\n@@ -822,4 +804,1 @@\n-\n-                mv.visitVarInsn(prim.loadOpcode, slot);\n-                mv.visitMethodInsn(INVOKESTATIC, prim.wrapperClassName, \"valueOf\",\n-                        prim.wrapperValueOfDesc, false);\n+                cob.invokestatic(prim.wrapperMethodRef);\n@@ -827,1 +806,1 @@\n-                mv.visitVarInsn(ALOAD, slot);\n+                cob.aload(slot);\n@@ -836,1 +815,1 @@\n-        private void codeUnwrapReturnValue(MethodVisitor mv, Class<?> type) {\n+        private void codeUnwrapReturnValue(CodeBuilder cob, Class<?> type) {\n@@ -840,6 +819,3 @@\n-                mv.visitTypeInsn(CHECKCAST, prim.wrapperClassName);\n-                mv.visitMethodInsn(INVOKEVIRTUAL,\n-                        prim.wrapperClassName,\n-                        prim.unwrapMethodName, prim.unwrapMethodDesc, false);\n-\n-                mv.visitInsn(prim.returnOpcode);\n+                cob.checkcast(prim.wrapperClass)\n+                   .invokevirtual(prim.unwrapMethodRef)\n+                   .returnInstruction(TypeKind.from(type).asLoadable());\n@@ -847,2 +823,2 @@\n-                mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));\n-                mv.visitInsn(ARETURN);\n+                cob.checkcast(toClassDesc(type))\n+                   .areturn();\n@@ -857,4 +833,3 @@\n-        private void codeFieldInitialization(MethodVisitor mv, String className) {\n-            codeClassForName(mv, fromClass);\n-\n-            mv.visitLdcInsn(method.getName());\n+        private void codeFieldInitialization(CodeBuilder cob, ClassEntry className) {\n+            var cp = cob.constantPool();\n+            codeClassForName(cob, fromClass);\n@@ -862,3 +837,3 @@\n-            emitIconstInsn(mv, parameterTypes.length);\n-\n-            mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_CLASS);\n+            cob.ldc(method.getName())\n+               .constantInstruction(parameterTypes.length)\n+               .anewarray(CE_Class);\n@@ -868,3 +843,2 @@\n-                mv.visitInsn(DUP);\n-                emitIconstInsn(mv, i);\n-\n+                cob.dup()\n+                   .constantInstruction(i);\n@@ -872,4 +846,2 @@\n-                    PrimitiveTypeInfo prim =\n-                            PrimitiveTypeInfo.get(parameterTypes[i]);\n-                    mv.visitFieldInsn(GETSTATIC,\n-                            prim.wrapperClassName, \"TYPE\", LJL_CLASS);\n+                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n+                    cob.getstatic(prim.typeFieldRef);\n@@ -877,1 +849,1 @@\n-                    codeClassForName(mv, parameterTypes[i]);\n+                    codeClassForName(cob, parameterTypes[i]);\n@@ -879,1 +851,1 @@\n-                mv.visitInsn(Opcodes.AASTORE);\n+                cob.aastore();\n@@ -882,9 +854,2 @@\n-            mv.visitMethodInsn(INVOKEVIRTUAL,\n-                    JL_CLASS,\n-                    \"getMethod\",\n-                    \"(Ljava\/lang\/String;[Ljava\/lang\/Class;)Ljava\/lang\/reflect\/Method;\",\n-                    false);\n-\n-            mv.visitFieldInsn(PUTSTATIC,\n-                    dotToSlash(className),\n-                    methodFieldName, LJLR_METHOD);\n+            cob.invokevirtual(MRE_Class_getMethod)\n+               .putstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n@@ -904,27 +869,5 @@\n-        private void codeClassForName(MethodVisitor mv, Class<?> cl) {\n-            mv.visitLdcInsn(cl.getName());\n-            mv.visitInsn(ICONST_0); \/\/ false\n-            mv.visitVarInsn(ALOAD, 0); \/\/ classLoader\n-            mv.visitMethodInsn(INVOKESTATIC,\n-                    JL_CLASS,\n-                    \"forName\",\n-                    \"(Ljava\/lang\/String;Z\" + LJL_CLASSLOADER + \")Ljava\/lang\/Class;\",\n-                    false);\n-        }\n-\n-        \/**\n-         * Visit a bytecode for a constant.\n-         *\n-         * @param mv  The MethodVisitor\n-         * @param cst The constant value\n-         *\/\n-        private void emitIconstInsn(MethodVisitor mv, final int cst) {\n-            if (cst >= -1 && cst <= 5) {\n-                mv.visitInsn(Opcodes.ICONST_0 + cst);\n-            } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-            } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-            } else {\n-                mv.visitLdcInsn(cst);\n-            }\n+        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n+            cob.ldc(cl.getName())\n+               .iconst_0() \/\/ false\n+               .aload(0)\/\/ classLoader\n+               .invokestatic(MRE_Class_forName);\n@@ -939,0 +882,1 @@\n+    private static final ConstantPoolBuilder CP = ConstantPoolBuilder.of();\n@@ -945,8 +889,8 @@\n-        BYTE(byte.class, ILOAD, IRETURN),\n-        CHAR(char.class, ILOAD, IRETURN),\n-        DOUBLE(double.class, DLOAD, DRETURN),\n-        FLOAT(float.class, FLOAD, FRETURN),\n-        INT(int.class, ILOAD, IRETURN),\n-        LONG(long.class, LLOAD, LRETURN),\n-        SHORT(short.class, ILOAD, IRETURN),\n-        BOOLEAN(boolean.class, ILOAD, IRETURN);\n+        BYTE(byte.class, CD_byte, CD_Byte),\n+        CHAR(char.class, CD_char, CD_Character),\n+        DOUBLE(double.class, CD_double, CD_Double),\n+        FLOAT(float.class, CD_float, CD_Float),\n+        INT(int.class, CD_int, CD_Integer),\n+        LONG(long.class, CD_long, CD_Long),\n+        SHORT(short.class, CD_short, CD_Short),\n+        BOOLEAN(boolean.class, CD_boolean, CD_Boolean);\n@@ -955,9 +899,1 @@\n-         * internal name of corresponding wrapper class\n-         *\/\n-        private final String wrapperClassName;\n-        \/**\n-         * method descriptor for wrapper class \"valueOf\" factory method\n-         *\/\n-        private final String wrapperValueOfDesc;\n-        \/**\n-         * name of wrapper class method for retrieving primitive value\n+         * CP entry of corresponding wrapper class\n@@ -965,1 +901,1 @@\n-        private final String unwrapMethodName;\n+        private final ClassEntry wrapperClass;\n@@ -967,1 +903,1 @@\n-         * descriptor of same method\n+         * CP entry for wrapper class \"valueOf\" factory method\n@@ -969,1 +905,1 @@\n-        private final String unwrapMethodDesc;\n+        private final MethodRefEntry wrapperMethodRef;\n@@ -971,1 +907,1 @@\n-         * Load opcode used by this primitive\n+         * CP entry of wrapper class method for retrieving primitive value\n@@ -973,1 +909,1 @@\n-        private final int loadOpcode;\n+        private final MethodRefEntry unwrapMethodRef;\n@@ -975,1 +911,1 @@\n-         * Return opcode used by this primitive\n+         * CP entry of wrapper class TYPE field\n@@ -977,17 +913,8 @@\n-        private final int returnOpcode;\n-\n-        PrimitiveTypeInfo(Class<?> primitiveClass, int loadOpcode, int returnOpcode) {\n-            assert primitiveClass.isPrimitive();\n-            assert returnOpcode - IRETURN == loadOpcode - ILOAD;\n-\n-            Wrapper wrapper = Wrapper.forPrimitiveType(primitiveClass);\n-            \/\/ single-char BaseType descriptor (see JVMS section 4.3.2)\n-            String baseTypeString = wrapper.basicTypeString();\n-            var wrapperType = wrapper.wrapperType();\n-            wrapperClassName = dotToSlash(wrapperType.getName());\n-            wrapperValueOfDesc =\n-                    \"(\" + baseTypeString + \")\" + wrapperType.descriptorString();\n-            unwrapMethodName = primitiveClass.getName() + \"Value\";\n-            unwrapMethodDesc = \"()\" + baseTypeString;\n-            this.loadOpcode = loadOpcode;\n-            this.returnOpcode = returnOpcode;\n+        private final FieldRefEntry typeFieldRef;\n+\n+        PrimitiveTypeInfo(Class<?> primitiveClass, ClassDesc baseType, ClassDesc wrapperClass) {\n+            assert baseType.isPrimitive();\n+            this.wrapperClass = CP.classEntry(wrapperClass);\n+            this.wrapperMethodRef = CP.methodRefEntry(wrapperClass, \"valueOf\", MethodTypeDesc.of(wrapperClass, baseType));\n+            this.unwrapMethodRef = CP.methodRefEntry(wrapperClass, primitiveClass.getName() + \"Value\", MethodTypeDesc.of(baseType));\n+            this.typeFieldRef = CP.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":339,"deletions":412,"binary":false,"changes":751,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+        this.doneFullScan = true;\n@@ -192,1 +193,1 @@\n-            for (int i=1; i<parentSize; i++) {\n+            for (int i=1; i<parentSize;) {\n@@ -194,1 +195,4 @@\n-                if (cpi != null)\n+                if (cpi == null) {\n+                    doneFullScan = false;\n+                    i++;\n+                } else {\n@@ -196,0 +200,2 @@\n+                    i += cpi.width();\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n@@ -32,1 +30,0 @@\n-import java.util.LinkedHashMap;\n@@ -34,1 +31,0 @@\n-import java.util.stream.Collectors;\n@@ -40,0 +36,3 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.LinkedList;\n@@ -44,0 +43,2 @@\n+    private record Target(int bci, int stack) {}\n+\n@@ -47,3 +48,2 @@\n-                buf.thisClass().asSymbol(),\n-                dcb.methodInfo.methodName().stringValue(),\n-                dcb.methodInfo.methodTypeSymbol(),\n+                dcb.methodInfo.methodName(),\n+                dcb.methodInfo.methodType(),\n@@ -59,2 +59,2 @@\n-    private final String methodName;\n-    private final MethodTypeDesc methodDesc;\n+    private final Utf8Entry methodName;\n+    private final Utf8Entry methodDesc;\n@@ -62,1 +62,1 @@\n-    private final LinkedHashMap<Integer, Integer> map;\n+    private final LinkedList<Target> targets;\n@@ -67,1 +67,1 @@\n-            map.put(targetBci, stack);\n+            targets.add(new Target(targetBci, stack));\n@@ -81,1 +81,1 @@\n-        var it = map.entrySet().iterator();\n+        var it = targets.iterator();\n@@ -85,3 +85,3 @@\n-            if (!visited.get(en.getKey())) {\n-                bcs.nextBci = en.getKey();\n-                stack = en.getValue();\n+            if (!visited.get(en.bci)) {\n+                bcs.nextBci = en.bci;\n+                stack = en.stack;\n@@ -96,3 +96,2 @@\n-                     ClassDesc thisClass,\n-                     String methodName,\n-                     MethodTypeDesc methodDesc,\n+                     Utf8Entry methodName,\n+                     Utf8Entry methodDesc,\n@@ -106,1 +105,1 @@\n-        map = new LinkedHashMap<>();\n+        targets = new LinkedList<>();\n@@ -108,1 +107,1 @@\n-        for (var h : handlers) map.put(labelContext.labelToBci(h.handler), 1);\n+        for (var h : handlers) targets.add(new Target(labelContext.labelToBci(h.handler), 1));\n@@ -110,3 +109,1 @@\n-        for (var cd : methodDesc.parameterList()) {\n-            maxLocals += Util.slotSize(cd);\n-        }\n+        maxLocals += countMethodStack(methodDesc, false);\n@@ -115,1 +112,1 @@\n-        map.put(0, 0);\n+        targets.add(new Target(0, 0));\n@@ -310,4 +307,1 @@\n-                        var mDesc = MethodTypeDesc.ofDescriptor(nameAndType.type().stringValue());\n-                        for (var arg : mDesc.parameterList()) {\n-                            addStackSlot(-TypeKind.from(arg).slotSize());\n-                        }\n+                        addStackSlot(-countMethodStack(nameAndType.type(), true));\n@@ -317,1 +311,0 @@\n-                        addStackSlot(TypeKind.from(mDesc.returnType()).slotSize());\n@@ -346,0 +339,45 @@\n+    private static int countMethodStack(Utf8Entry descriptor, boolean subReturn) {\n+        int cur = 0, end = descriptor.length();\n+        if (cur >= end || descriptor.charAt(cur) != '(')\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        ++cur;  \/\/ skip '('\n+        int count = 0;\n+        boolean inArray = false;\n+        while (cur < end) {\n+            switch (descriptor.charAt(cur++)) {\n+                case 'Z', 'B', 'C', 'S', 'I', 'F' -> {\n+                    count++;\n+                    inArray = false;\n+                }\n+                case 'J', 'D' -> {\n+                    count += inArray ? 1 : 2;\n+                    inArray = false;\n+                }\n+                case 'L' -> {\n+                    while (cur < end && descriptor.charAt(cur++) != ';');\n+                    count++;\n+                    inArray = false;\n+                }\n+                case '[' -> {\n+                    inArray = true;\n+                }\n+                case ')' -> {\n+                    if (cur < end) {\n+                        if (subReturn) {\n+                            return switch (descriptor.charAt(cur++)) {\n+                                case 'Z', 'B', 'C', 'S', 'I', 'F', '[', 'L' -> count - 1;\n+                                case 'J', 'D' -> count - 2;\n+                                case 'V' -> count;\n+                                default -> throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+                            };\n+                        } else {\n+                            return count;\n+                        }\n+                    }\n+                }\n+                default -> throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+    }\n+\n@@ -380,1 +418,1 @@\n-                methodDesc.displayDescriptor()));\n+                MethodTypeDesc.ofDescriptor(methodDesc.stringValue()).displayDescriptor()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":68,"deletions":30,"binary":false,"changes":98,"status":"modified"}]}