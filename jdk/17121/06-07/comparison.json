{"files":[{"patch":"@@ -90,1 +90,0 @@\n-        this.doneFullScan = true;\n@@ -193,1 +192,1 @@\n-            for (int i=1; i<parentSize;) {\n+            for (int i=1; i<parentSize; i++) {\n@@ -195,4 +194,1 @@\n-                if (cpi == null) {\n-                    doneFullScan = false;\n-                    i++;\n-                } else {\n+                if (cpi != null)\n@@ -200,2 +196,0 @@\n-                    i += cpi.width();\n-                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -30,0 +32,1 @@\n+import java.util.LinkedHashMap;\n@@ -31,0 +34,1 @@\n+import java.util.stream.Collectors;\n@@ -36,4 +40,0 @@\n-import java.lang.classfile.constantpool.Utf8Entry;\n-import java.lang.constant.MethodTypeDesc;\n-import java.util.ArrayDeque;\n-import java.util.Queue;\n@@ -44,2 +44,0 @@\n-    private record Target(int bci, int stack) {}\n-\n@@ -49,2 +47,3 @@\n-                dcb.methodInfo.methodName(),\n-                dcb.methodInfo.methodType(),\n+                buf.thisClass().asSymbol(),\n+                dcb.methodInfo.methodName().stringValue(),\n+                dcb.methodInfo.methodTypeSymbol(),\n@@ -60,2 +59,2 @@\n-    private final Utf8Entry methodName;\n-    private final Utf8Entry methodDesc;\n+    private final String methodName;\n+    private final MethodTypeDesc methodDesc;\n@@ -63,1 +62,1 @@\n-    private final Queue<Target> targets;\n+    private final LinkedHashMap<Integer, Integer> map;\n@@ -68,1 +67,1 @@\n-            targets.add(new Target(targetBci, stack));\n+            map.put(targetBci, stack);\n@@ -82,5 +81,7 @@\n-        Target en;\n-        while ((en = targets.poll()) != null) {\n-            if (!visited.get(en.bci)) {\n-                bcs.nextBci = en.bci;\n-                stack = en.stack;\n+        var it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            var en = it.next();\n+            it.remove();\n+            if (!visited.get(en.getKey())) {\n+                bcs.nextBci = en.getKey();\n+                stack = en.getValue();\n@@ -95,2 +96,3 @@\n-                     Utf8Entry methodName,\n-                     Utf8Entry methodDesc,\n+                     ClassDesc thisClass,\n+                     String methodName,\n+                     MethodTypeDesc methodDesc,\n@@ -104,1 +106,1 @@\n-        targets = new ArrayDeque<>();\n+        map = new LinkedHashMap<>();\n@@ -106,1 +108,1 @@\n-        for (var h : handlers) targets.add(new Target(labelContext.labelToBci(h.handler), 1));\n+        for (var h : handlers) map.put(labelContext.labelToBci(h.handler), 1);\n@@ -108,1 +110,3 @@\n-        maxLocals += countMethodStack(methodDesc, false);\n+        for (var cd : methodDesc.parameterList()) {\n+            maxLocals += Util.slotSize(cd);\n+        }\n@@ -111,1 +115,1 @@\n-        targets.add(new Target(0, 0));\n+        map.put(0, 0);\n@@ -306,1 +310,4 @@\n-                        addStackSlot(-countMethodStack(nameAndType.type(), true));\n+                        var mDesc = MethodTypeDesc.ofDescriptor(nameAndType.type().stringValue());\n+                        for (var arg : mDesc.parameterList()) {\n+                            addStackSlot(-TypeKind.from(arg).slotSize());\n+                        }\n@@ -310,0 +317,1 @@\n+                        addStackSlot(TypeKind.from(mDesc.returnType()).slotSize());\n@@ -338,45 +346,0 @@\n-    private static int countMethodStack(Utf8Entry descriptor, boolean subReturn) {\n-        int cur = 0, end = descriptor.length();\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip '('\n-        int count = 0;\n-        boolean inArray = false;\n-        while (cur < end) {\n-            switch (descriptor.charAt(cur++)) {\n-                case 'Z', 'B', 'C', 'S', 'I', 'F' -> {\n-                    count++;\n-                    inArray = false;\n-                }\n-                case 'J', 'D' -> {\n-                    count += inArray ? 1 : 2;\n-                    inArray = false;\n-                }\n-                case 'L' -> {\n-                    while (cur < end && descriptor.charAt(cur++) != ';');\n-                    count++;\n-                    inArray = false;\n-                }\n-                case '[' -> {\n-                    inArray = true;\n-                }\n-                case ')' -> {\n-                    if (cur < end) {\n-                        if (subReturn) {\n-                            return switch (descriptor.charAt(cur++)) {\n-                                case 'Z', 'B', 'C', 'S', 'I', 'F', '[', 'L' -> count - 1;\n-                                case 'J', 'D' -> count - 2;\n-                                case 'V' -> count;\n-                                default -> throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-                            };\n-                        } else {\n-                            return count;\n-                        }\n-                    }\n-                }\n-                default -> throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            }\n-        }\n-        throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-    }\n-\n@@ -417,1 +380,1 @@\n-                MethodTypeDesc.ofDescriptor(methodDesc.stringValue()).displayDescriptor()));\n+                methodDesc.displayDescriptor()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":33,"deletions":70,"binary":false,"changes":103,"status":"modified"}]}