{"files":[{"patch":"@@ -621,0 +621,1 @@\n+            Objects.requireNonNull(interfaces);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,6 +28,3 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import sun.invoke.util.Wrapper;\n+import java.lang.classfile.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n@@ -37,1 +34,6 @@\n-import java.lang.invoke.MethodType;\n+import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.constant.MethodTypeDesc;\n@@ -46,2 +48,1 @@\n-\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import java.util.Objects;\n@@ -56,27 +57,28 @@\n-final class ProxyGenerator extends ClassWriter {\n-    private static final int CLASSFILE_VERSION = ClassFileFormatVersion.latest().major();\n-    private static final String JL_CLASS = \"java\/lang\/Class\";\n-    private static final String JL_OBJECT = \"java\/lang\/Object\";\n-    private static final String JL_THROWABLE = \"java\/lang\/Throwable\";\n-    private static final String JL_CLASS_NOT_FOUND_EX = \"java\/lang\/ClassNotFoundException\";\n-    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n-\n-    private static final String JL_NO_CLASS_DEF_FOUND_ERROR = \"java\/lang\/NoClassDefFoundError\";\n-    private static final String JL_NO_SUCH_METHOD_EX = \"java\/lang\/NoSuchMethodException\";\n-    private static final String JL_NO_SUCH_METHOD_ERROR = \"java\/lang\/NoSuchMethodError\";\n-    private static final String JLI_LOOKUP = \"java\/lang\/invoke\/MethodHandles$Lookup\";\n-    private static final String JLI_METHODHANDLES = \"java\/lang\/invoke\/MethodHandles\";\n-\n-    private static final String JLR_INVOCATION_HANDLER = \"java\/lang\/reflect\/InvocationHandler\";\n-    private static final String JLR_PROXY = \"java\/lang\/reflect\/Proxy\";\n-    private static final String JLR_UNDECLARED_THROWABLE_EX = \"java\/lang\/reflect\/UndeclaredThrowableException\";\n-\n-    private static final String LJL_CLASS = \"Ljava\/lang\/Class;\";\n-    private static final String LJL_CLASSLOADER = \"Ljava\/lang\/ClassLoader;\";\n-    private static final String LJLR_METHOD = \"Ljava\/lang\/reflect\/Method;\";\n-    private static final String LJLR_INVOCATION_HANDLER = \"Ljava\/lang\/reflect\/InvocationHandler;\";\n-\n-    private static final String MJLR_INVOCATIONHANDLER = \"(Ljava\/lang\/reflect\/InvocationHandler;)V\";\n-\n-    private static final String NAME_CTOR = \"<init>\";\n-    private static final String NAME_CLINIT = \"<clinit>\";\n+final class ProxyGenerator {\n+\n+    private static final ClassDesc\n+            CD_ClassLoader = ClassDesc.ofInternalName(\"java\/lang\/ClassLoader\"),\n+            CD_ClassNotFoundException = ClassDesc.ofInternalName(\"java\/lang\/ClassNotFoundException\"),\n+            CD_IllegalAccessException = ClassDesc.ofInternalName(\"java\/lang\/IllegalAccessException\"),\n+            CD_InvocationHandler = ClassDesc.ofInternalName(\"java\/lang\/reflect\/InvocationHandler\"),\n+            CD_Method = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Method\"),\n+            CD_NoClassDefFoundError = ClassDesc.ofInternalName(\"java\/lang\/NoClassDefFoundError\"),\n+            CD_NoSuchMethodError = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodError\"),\n+            CD_NoSuchMethodException = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodException\"),\n+            CD_Proxy = ClassDesc.ofInternalName(\"java\/lang\/reflect\/Proxy\"),\n+            CD_UndeclaredThrowableException = ClassDesc.ofInternalName(\"java\/lang\/reflect\/UndeclaredThrowableException\");\n+\n+    private static final MethodTypeDesc\n+            MTD_boolean = MethodTypeDesc.of(CD_boolean),\n+            MTD_void_InvocationHandler = MethodTypeDesc.of(CD_void, CD_InvocationHandler),\n+            MTD_void_String = MethodTypeDesc.of(CD_void, CD_String),\n+            MTD_void_Throwable = MethodTypeDesc.of(CD_void, CD_Throwable),\n+            MTD_Class = MethodTypeDesc.of(CD_Class),\n+            MTD_Class_String_boolean_ClassLoader = MethodTypeDesc.of(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n+            MTD_ClassLoader = MethodTypeDesc.of(CD_ClassLoader),\n+            MTD_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup),\n+            MTD_MethodHandles$Lookup_MethodHandles$Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup, CD_MethodHandles_Lookup),\n+            MTD_Method_String_ClassArray = MethodTypeDesc.of(CD_Method, CD_String, CD_Class.arrayType()),\n+            MTD_Object_Object_Method_ObjectArray = MethodTypeDesc.of(CD_Object, CD_Object, CD_Method, CD_Object.arrayType()),\n+            MTD_String = MethodTypeDesc.of(CD_String);\n+\n@@ -106,0 +108,27 @@\n+    private static final ClassModel TEMPLATE;\n+\n+    private static final ClassEntry CE_Class;\n+    private static final ClassEntry CE_Object;\n+    private static final ClassEntry CE_NoSuchMethodError;\n+    private static final ClassEntry CE_NoClassDefFoundError;\n+    private static final ClassEntry CE_UndeclaredThrowableException;\n+    private static final ClassEntry CE_Throwable;\n+    private static final ClassEntry CE_NoSuchMethodException;\n+    private static final ClassEntry CE_ClassNotFoundException;\n+\n+    private static final FieldRefEntry FRE_Proxy_h;\n+\n+    private static final InterfaceMethodRefEntry IMRE_InvocationHandler_invoke;\n+\n+    private static final MethodRefEntry MRE_Class_getClassLoader;\n+    private static final MethodRefEntry MRE_NoSuchMethodError_init;\n+    private static final MethodRefEntry MRE_NoClassDefFoundError_init;\n+    private static final MethodRefEntry MRE_Throwable_getMessage;\n+    private static final MethodRefEntry MRE_Class_forName;\n+    private static final MethodRefEntry MRE_Class_getMethod;\n+    private static final MethodRefEntry MRE_UndeclaredThrowableException_init;\n+\n+    private static final Utf8Entry UE_Method;\n+\n+    private static final List<StackMapFrameInfo.VerificationTypeInfo> THROWABLE_STACK;\n+\n@@ -107,0 +136,42 @@\n+        var cc = ClassFile.of();\n+        var q = new Object() {\n+            PoolEntry[] entries;\n+            int i;\n+            @SuppressWarnings(\"unchecked\")\n+            <T extends PoolEntry> T next() {\n+                return (T) TEMPLATE.constantPool().entryByIndex(entries[i++].index());\n+            }\n+        };\n+        \/\/static template ClassModel holds pre-defined constant pool entries\n+        \/\/proxy transformed from the template shares the template constant pool\n+        \/\/each direct use of the template pool entry is significantly faster\n+        TEMPLATE = cc.parse(cc.build(CD_Proxy, clb -> {\n+            clb.withSuperclass(CD_Proxy);\n+            generateConstructor(clb);\n+            generateLookupAccessor(clb);\n+            var cp = clb.constantPool();\n+            q.entries = new PoolEntry[] {\n+                cp.utf8Entry(\"m0\"),\n+                cp.utf8Entry(\"m1\"),\n+                cp.utf8Entry(\"m2\"),\n+                cp.utf8Entry(CD_Method),\n+                cp.methodRefEntry(CD_Class, \"getClassLoader\", MTD_ClassLoader),\n+                cp.classEntry(CD_NoSuchMethodError),\n+                cp.methodRefEntry(CD_NoSuchMethodError, INIT_NAME, MTD_void_String),\n+                cp.fieldRefEntry(CD_Proxy, handlerFieldName, CD_InvocationHandler),\n+                cp.classEntry(CD_NoClassDefFoundError),\n+                cp.methodRefEntry(CD_NoClassDefFoundError, INIT_NAME, MTD_void_String),\n+                cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String),\n+                cp.methodRefEntry(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader),\n+                cp.classEntry(CD_Class),\n+                cp.methodRefEntry(CD_Class, \"getMethod\", MTD_Method_String_ClassArray),\n+                cp.classEntry(CD_Object),\n+                cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray),\n+                cp.methodRefEntry(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable),\n+                cp.classEntry(CD_UndeclaredThrowableException),\n+                cp.classEntry(CD_NoSuchMethodException),\n+                cp.classEntry(CD_ClassNotFoundException),\n+                cp.classEntry(CD_Throwable)\n+            };\n+        }));\n+\n@@ -108,3 +179,3 @@\n-            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), \"m0\");\n-            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), \"m1\");\n-            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), \"m2\");\n+            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), q.next());\n+            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), q.next());\n+            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), q.next());\n@@ -114,0 +185,19 @@\n+        UE_Method = q.next();\n+        MRE_Class_getClassLoader = q.next();\n+        CE_NoSuchMethodError = q.next();\n+        MRE_NoSuchMethodError_init = q.next();\n+        FRE_Proxy_h = q.next();\n+        CE_NoClassDefFoundError = q.next();\n+        MRE_NoClassDefFoundError_init = q.next();\n+        MRE_Throwable_getMessage = q.next();\n+        MRE_Class_forName = q.next();\n+        CE_Class = q.next();\n+        MRE_Class_getMethod = q.next();\n+        CE_Object = q.next();\n+        IMRE_InvocationHandler_invoke = q.next();\n+        MRE_UndeclaredThrowableException_init = q.next();\n+        CE_UndeclaredThrowableException = q.next();\n+        CE_NoSuchMethodException = q.next();\n+        CE_ClassNotFoundException = q.next();\n+        CE_Throwable = q.next();\n+        THROWABLE_STACK = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(CE_Throwable));\n@@ -117,1 +207,1 @@\n-     * Class loader\n+     * Classfile context\n@@ -119,1 +209,2 @@\n-    private final ClassLoader loader;\n+    private final ClassFile classfileContext;\n+    private final ConstantPoolBuilder cp;\n@@ -124,1 +215,1 @@\n-    private final String className;\n+    private ClassEntry classEntry;\n@@ -158,3 +249,6 @@\n-        super(ClassWriter.COMPUTE_FRAMES);\n-        this.loader = loader;\n-        this.className = className;\n+        this.classfileContext = ClassFile.of(\n+                ClassFile.StackMapsOption.DROP_STACK_MAPS,\n+                ClassFile.ClassHierarchyResolverOption.of(\n+                        ClassHierarchyResolver.ofClassLoading(loader).cached()));\n+        this.cp = ConstantPoolBuilder.of(TEMPLATE);\n+        this.classEntry = cp.classEntry(ClassDesc.of(className));\n@@ -177,0 +271,1 @@\n+        Objects.requireNonNull(interfaces);\n@@ -188,1 +283,1 @@\n-                                    Path dir = Path.of(dotToSlash(name.substring(0, i)));\n+                                    Path dir = Path.of(name.substring(0, i).replace('.', '\/'));\n@@ -208,5 +303,2 @@\n-     * Return an array of the class and interface names from an array of Classes.\n-     *\n-     * @param classes an array of classes or interfaces\n-     * @return the array of class and interface names; or null if classes is\n-     * null or empty\n+     * {@return the entries of the given type}\n+     * @param types the {@code Class} objects, not primitive types nor array types\n@@ -214,8 +306,13 @@\n-    private static String[] typeNames(List<Class<?>> classes) {\n-        if (classes == null || classes.size() == 0)\n-            return null;\n-        int size = classes.size();\n-        String[] ifaces = new String[size];\n-        for (int i = 0; i < size; i++)\n-            ifaces[i] = dotToSlash(classes.get(i).getName());\n-        return ifaces;\n+    private static ClassEntry[] toClassEntries(ConstantPoolBuilder cp, List<Class<?>> types) {\n+        var ces = new ClassEntry[types.size()];\n+        for (int i = 0; i < ces.length; i++)\n+            ces[i] = cp.classEntry(cp.utf8Entry(types.get(i).getName().replace('.', '\/')));\n+        return ces;\n+    }\n+\n+    \/**\n+     * {@return the {@code ClassDesc} of the given type}\n+     * @param type the {@code Class} object\n+     *\/\n+    private static ClassDesc toClassDesc(Class<?> type) {\n+        return ClassDesc.ofDescriptor(type.descriptorString());\n@@ -390,28 +487,0 @@\n-    \/**\n-     * Convert a fully qualified class name that uses '.' as the package\n-     * separator, the external representation used by the Java language\n-     * and APIs, to a fully qualified class name that uses '\/' as the\n-     * package separator, the representation used in the class file\n-     * format (see JVMS section {@jvms 4.2}).\n-     *\/\n-    private static String dotToSlash(String name) {\n-        return name.replace('.', '\/');\n-    }\n-\n-    \/**\n-     * Return the number of abstract \"words\", or consecutive local variable\n-     * indexes, required to contain a value of the given type.  See JVMS\n-     * section {@jvms 3.6.1}.\n-     * <p>\n-     * Note that the original version of the JVMS contained a definition of\n-     * this abstract notion of a \"word\" in section 3.4, but that definition\n-     * was removed for the second edition.\n-     *\/\n-    private static int getWordsPerType(Class<?> type) {\n-        if (type == long.class || type == double.class) {\n-            return 2;\n-        } else {\n-            return 1;\n-        }\n-    }\n-\n@@ -442,11 +511,0 @@\n-    \/**\n-     * Returns the {@link ClassLoader} to be used by the default implementation of {@link\n-     * #getCommonSuperClass(String, String)}, that of this {@link ClassWriter}'s runtime type by\n-     * default.\n-     *\n-     * @return ClassLoader\n-     *\/\n-    protected ClassLoader getClassLoader() {\n-        return loader;\n-    }\n-\n@@ -458,3 +516,0 @@\n-        visit(CLASSFILE_VERSION, accessFlags, dotToSlash(className), null,\n-                JLR_PROXY, typeNames(interfaces));\n-\n@@ -478,1 +533,1 @@\n-                    addProxyMethod(m, intf);\n+                    addProxyMethod(m, intf, cp);\n@@ -491,1 +546,4 @@\n-        generateConstructor();\n+        return classfileContext.build(classEntry, cp, clb -> {\n+            TEMPLATE.forEach(clb);\n+            clb.withFlags(accessFlags);\n+            clb.withInterfaces(toClassEntries(cp, interfaces));\n@@ -493,5 +551,4 @@\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                \/\/ add static field for the Method object\n-                visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName,\n-                        LJLR_METHOD, null, null);\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    \/\/ add static field for the Method object\n+                    clb.withField(pm.methodFieldName, UE_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -499,2 +556,3 @@\n-                \/\/ Generate code for proxy method\n-                pm.generateMethod(this, className);\n+                    \/\/ Generate code for proxy method\n+                    pm.generateMethod(clb, classEntry);\n+                }\n@@ -502,1 +560,0 @@\n-        }\n@@ -504,3 +561,2 @@\n-        generateStaticInitializer();\n-        generateLookupAccessor();\n-        return toByteArray();\n+            generateStaticInitializer(clb);\n+        });\n@@ -522,1 +578,1 @@\n-    private void addProxyMethod(Method m, Class<?> fromClass) {\n+    private void addProxyMethod(Method m, Class<?> fromClass, ConstantPoolBuilder cp) {\n@@ -548,1 +604,1 @@\n-                \"m\" + proxyMethodCount++));\n+                cp.utf8Entry(\"m\" + proxyMethodCount++)));\n@@ -566,14 +622,6 @@\n-    private void generateConstructor() {\n-        MethodVisitor ctor = visitMethod(Modifier.PUBLIC, NAME_CTOR,\n-                MJLR_INVOCATIONHANDLER, null, null);\n-        ctor.visitParameter(null, 0);\n-        ctor.visitCode();\n-        ctor.visitVarInsn(ALOAD, 0);\n-        ctor.visitVarInsn(ALOAD, 1);\n-        ctor.visitMethodInsn(INVOKESPECIAL, JLR_PROXY, NAME_CTOR,\n-                MJLR_INVOCATIONHANDLER, false);\n-        ctor.visitInsn(RETURN);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        ctor.visitMaxs(-1, -1);\n-        ctor.visitEnd();\n+    private static void generateConstructor(ClassBuilder clb) {\n+        clb.withMethodBody(INIT_NAME, MTD_void_InvocationHandler, ACC_PUBLIC, cob -> cob\n+               .aload(cob.receiverSlot())\n+               .aload(cob.parameterSlot(0))\n+               .invokespecial(CD_Proxy, INIT_NAME, MTD_void_InvocationHandler)\n+               .return_());\n@@ -585,26 +633,12 @@\n-    private void generateStaticInitializer() {\n-\n-        MethodVisitor mv = visitMethod(Modifier.STATIC, NAME_CLINIT,\n-                \"()V\", null, null);\n-        mv.visitCode();\n-        Label L_startBlock = new Label();\n-        Label L_endBlock = new Label();\n-        Label L_NoMethodHandler = new Label();\n-        Label L_NoClassHandler = new Label();\n-\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoMethodHandler,\n-                JL_NO_SUCH_METHOD_EX);\n-        mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_NoClassHandler,\n-                JL_CLASS_NOT_FOUND_EX);\n-\n-        \/\/ Put ClassLoader at local variable index 0, used by\n-        \/\/ Class.forName(String, boolean, ClassLoader) calls\n-        mv.visitLdcInsn(Type.getObjectType(dotToSlash(className)));\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_CLASS,\n-                \"getClassLoader\", \"()\" + LJL_CLASSLOADER, false);\n-        mv.visitVarInsn(ASTORE, 0);\n-\n-        mv.visitLabel(L_startBlock);\n-        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-            for (ProxyMethod pm : sigmethods) {\n-                pm.codeFieldInitialization(mv, className);\n+    private void generateStaticInitializer(ClassBuilder clb) {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+            \/\/ Put ClassLoader at local variable index 0, used by\n+            \/\/ Class.forName(String, boolean, ClassLoader) calls\n+            cob.ldc(classEntry)\n+               .invokevirtual(MRE_Class_getClassLoader)\n+               .astore(0);\n+            var ts = cob.newBoundLabel();\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    pm.codeFieldInitialization(cob, classEntry);\n+                }\n@@ -612,30 +646,21 @@\n-        }\n-        mv.visitInsn(RETURN);\n-        mv.visitLabel(L_endBlock);\n-        \/\/ Generate exception handler\n-\n-        mv.visitLabel(L_NoMethodHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_SUCH_METHOD_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_SUCH_METHOD_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        mv.visitLabel(L_NoClassHandler);\n-        mv.visitVarInsn(ASTORE, 1);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_NO_CLASS_DEF_FOUND_ERROR);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 1);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JL_THROWABLE,\n-                \"getMessage\", \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_NO_CLASS_DEF_FOUND_ERROR,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+            cob.return_();\n+            var c1 = cob.newBoundLabel();\n+            cob.exceptionCatch(ts, c1, c1, CE_NoSuchMethodException)\n+               .new_(CE_NoSuchMethodError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(MRE_Throwable_getMessage)\n+               .invokespecial(MRE_NoSuchMethodError_init)\n+               .athrow();\n+            var c2 = cob.newBoundLabel();\n+            cob.exceptionCatch(ts, c1, c2, CE_ClassNotFoundException)\n+               .new_(CE_NoClassDefFoundError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(MRE_Throwable_getMessage)\n+               .invokespecial(MRE_NoClassDefFoundError_init)\n+               .athrow()\n+               .with(StackMapTableAttribute.of(List.of(\n+                     StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n+                     StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+        });\n@@ -649,33 +674,22 @@\n-    private void generateLookupAccessor() {\n-        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n-                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n-                new String[] { JL_ILLEGAL_ACCESS_EX });\n-        mv.visitCode();\n-        Label L_illegalAccess = new Label();\n-\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n-                \"()Ljava\/lang\/Class;\", false);\n-        mv.visitLdcInsn(Type.getType(Proxy.class));\n-        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n-                \"()Z\", false);\n-        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n-        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n-                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n-        mv.visitInsn(ARETURN);\n-\n-        mv.visitLabel(L_illegalAccess);\n-        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n-        mv.visitInsn(DUP);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n-                \"()Ljava\/lang\/String;\", false);\n-        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n-                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n-        mv.visitInsn(ATHROW);\n-\n-        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-        mv.visitMaxs(-1, -1);\n-        mv.visitEnd();\n+    private static void generateLookupAccessor(ClassBuilder clb) {\n+        clb.withMethod(NAME_LOOKUP_ACCESSOR,\n+                MTD_MethodHandles$Lookup_MethodHandles$Lookup,\n+                ACC_PRIVATE | ACC_STATIC,\n+                mb -> mb.with(ExceptionsAttribute.of(List.of(mb.constantPool().classEntry(CD_IllegalAccessException))))\n+                        .withCode(cob -> cob\n+                            .block(blockBuilder -> blockBuilder\n+                                    .aload(cob.parameterSlot(0))\n+                                    .invokevirtual(CD_MethodHandles_Lookup, \"lookupClass\", MTD_Class)\n+                                    .constantInstruction(Opcode.LDC, CD_Proxy)\n+                                    .if_acmpne(blockBuilder.breakLabel())\n+                                    .aload(cob.parameterSlot(0))\n+                                    .invokevirtual(CD_MethodHandles_Lookup, \"hasFullPrivilegeAccess\", MTD_boolean)\n+                                    .ifeq(blockBuilder.breakLabel())\n+                                    .invokestatic(CD_MethodHandles, \"lookup\", MTD_MethodHandles$Lookup)\n+                                    .areturn())\n+                            .new_(CD_IllegalAccessException)\n+                            .dup()\n+                            .aload(cob.parameterSlot(0))\n+                            .invokevirtual(CD_MethodHandles_Lookup, \"toString\", MTD_String)\n+                            .invokespecial(CD_IllegalAccessException, INIT_NAME, MTD_void_String)\n+                            .athrow()));\n@@ -696,1 +710,1 @@\n-        private final String methodFieldName;\n+        private final Utf8Entry methodFieldName;\n@@ -701,1 +715,1 @@\n-                            Class<?> fromClass, String methodFieldName) {\n+                            Class<?> fromClass, Utf8Entry methodFieldName) {\n@@ -717,1 +731,1 @@\n-        private ProxyMethod(Method method, String methodFieldName) {\n+        private ProxyMethod(Method method, Utf8Entry methodFieldName) {\n@@ -719,2 +733,2 @@\n-                    method.getSharedParameterTypes(), method.getReturnType(),\n-                    method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n+                 method.getSharedParameterTypes(), method.getReturnType(),\n+                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n@@ -726,55 +740,28 @@\n-        private void generateMethod(ClassWriter cw, String className) {\n-            MethodType mt = MethodType.methodType(returnType, parameterTypes);\n-            String desc = mt.toMethodDescriptorString();\n-            int accessFlags = ACC_PUBLIC | ACC_FINAL;\n-            if (method.isVarArgs()) accessFlags |= ACC_VARARGS;\n-\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                    method.getName(), desc, null,\n-                    typeNames(Arrays.asList(exceptionTypes)));\n-\n-            int[] parameterSlot = new int[parameterTypes.length];\n-            int nextSlot = 1;\n-            for (int i = 0; i < parameterSlot.length; i++) {\n-                parameterSlot[i] = nextSlot;\n-                nextSlot += getWordsPerType(parameterTypes[i]);\n-            }\n-\n-            mv.visitCode();\n-            Label L_startBlock = new Label();\n-            Label L_endBlock = new Label();\n-            Label L_RuntimeHandler = new Label();\n-            Label L_ThrowableHandler = new Label();\n-\n-            List<Class<?>> catchList = computeUniqueCatchList(exceptionTypes);\n-            if (catchList.size() > 0) {\n-                for (Class<?> ex : catchList) {\n-                    mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_RuntimeHandler,\n-                            dotToSlash(ex.getName()));\n-                }\n-\n-                mv.visitTryCatchBlock(L_startBlock, L_endBlock, L_ThrowableHandler,\n-                        JL_THROWABLE);\n-            }\n-            mv.visitLabel(L_startBlock);\n-\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETFIELD, JLR_PROXY, handlerFieldName,\n-                    LJLR_INVOCATION_HANDLER);\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitFieldInsn(GETSTATIC, dotToSlash(className), methodFieldName,\n-                    LJLR_METHOD);\n-\n-            if (parameterTypes.length > 0) {\n-                \/\/ Create an array and fill with the parameters converting primitives to wrappers\n-                emitIconstInsn(mv, parameterTypes.length);\n-                mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_OBJECT);\n-                for (int i = 0; i < parameterTypes.length; i++) {\n-                    mv.visitInsn(DUP);\n-                    emitIconstInsn(mv, i);\n-                    codeWrapArgument(mv, parameterTypes[i], parameterSlot[i]);\n-                    mv.visitInsn(Opcodes.AASTORE);\n-                }\n-            } else {\n-                mv.visitInsn(Opcodes.ACONST_NULL);\n-            }\n+        private void generateMethod(ClassBuilder clb, ClassEntry className) {\n+            var cp = clb.constantPool();\n+            MethodTypeDesc desc = MethodTypeDesc.of(toClassDesc(returnType),\n+                    Arrays.stream(parameterTypes).map(ProxyGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+            int accessFlags = (method.isVarArgs()) ? ACC_VARARGS | ACC_PUBLIC | ACC_FINAL\n+                                                   : ACC_PUBLIC | ACC_FINAL;\n+            var catchList = computeUniqueCatchList(exceptionTypes);\n+            clb.withMethod(method.getName(), desc, accessFlags, mb ->\n+                  mb.with(ExceptionsAttribute.of(toClassEntries(cp, List.of(exceptionTypes))))\n+                    .withCode(cob -> {\n+                        cob.aload(cob.receiverSlot())\n+                           .getfield(FRE_Proxy_h)\n+                           .aload(cob.receiverSlot())\n+                           .getstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n+\n+                        if (parameterTypes.length > 0) {\n+                            \/\/ Create an array and fill with the parameters converting primitives to wrappers\n+                            cob.constantInstruction(parameterTypes.length)\n+                               .anewarray(CE_Object);\n+                            for (int i = 0; i < parameterTypes.length; i++) {\n+                                cob.dup()\n+                                   .constantInstruction(i);\n+                                codeWrapArgument(cob, parameterTypes[i], cob.parameterSlot(i));\n+                                cob.aastore();\n+                            }\n+                        } else {\n+                            cob.aconst_null();\n+                        }\n@@ -782,4 +769,1 @@\n-            mv.visitMethodInsn(INVOKEINTERFACE, JLR_INVOCATION_HANDLER,\n-                    \"invoke\",\n-                    \"(Ljava\/lang\/Object;Ljava\/lang\/reflect\/Method;\" +\n-                            \"[Ljava\/lang\/Object;)Ljava\/lang\/Object;\", true);\n+                        cob.invokeinterface(IMRE_InvocationHandler_invoke);\n@@ -787,24 +771,24 @@\n-            if (returnType == void.class) {\n-                mv.visitInsn(POP);\n-                mv.visitInsn(RETURN);\n-            } else {\n-                codeUnwrapReturnValue(mv, returnType);\n-            }\n-\n-            mv.visitLabel(L_endBlock);\n-\n-            \/\/ Generate exception handler\n-            mv.visitLabel(L_RuntimeHandler);\n-            mv.visitInsn(ATHROW);   \/\/ just rethrow the exception\n-\n-            mv.visitLabel(L_ThrowableHandler);\n-            mv.visitVarInsn(ASTORE, 1);\n-            mv.visitTypeInsn(Opcodes.NEW, JLR_UNDECLARED_THROWABLE_EX);\n-            mv.visitInsn(DUP);\n-            mv.visitVarInsn(ALOAD, 1);\n-            mv.visitMethodInsn(INVOKESPECIAL, JLR_UNDECLARED_THROWABLE_EX,\n-                    \"<init>\", \"(Ljava\/lang\/Throwable;)V\", false);\n-            mv.visitInsn(ATHROW);\n-            \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n+                        if (returnType == void.class) {\n+                            cob.pop()\n+                               .return_();\n+                        } else {\n+                            codeUnwrapReturnValue(cob, returnType);\n+                        }\n+                        if (!catchList.isEmpty()) {\n+                            var c1 = cob.newBoundLabel();\n+                            for (var exc : catchList) {\n+                                cob.exceptionCatch(cob.startLabel(), c1, c1, toClassDesc(exc));\n+                            }\n+                            cob.athrow();   \/\/ just rethrow the exception\n+                            var c2 = cob.newBoundLabel();\n+                            cob.exceptionCatchAll(cob.startLabel(), c1, c2)\n+                               .new_(CE_UndeclaredThrowableException)\n+                               .dup_x1()\n+                               .swap()\n+                               .invokespecial(MRE_UndeclaredThrowableException_init)\n+                               .athrow()\n+                               .with(StackMapTableAttribute.of(List.of(\n+                                    StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n+                                    StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+                        }\n+                    }));\n@@ -819,1 +803,1 @@\n-        private void codeWrapArgument(MethodVisitor mv, Class<?> type, int slot) {\n+        private void codeWrapArgument(CodeBuilder cob, Class<?> type, int slot) {\n@@ -821,0 +805,1 @@\n+                cob.loadInstruction(TypeKind.from(type).asLoadable(), slot);\n@@ -822,4 +807,1 @@\n-\n-                mv.visitVarInsn(prim.loadOpcode, slot);\n-                mv.visitMethodInsn(INVOKESTATIC, prim.wrapperClassName, \"valueOf\",\n-                        prim.wrapperValueOfDesc, false);\n+                cob.invokestatic(prim.wrapperMethodRef);\n@@ -827,1 +809,1 @@\n-                mv.visitVarInsn(ALOAD, slot);\n+                cob.aload(slot);\n@@ -836,1 +818,1 @@\n-        private void codeUnwrapReturnValue(MethodVisitor mv, Class<?> type) {\n+        private void codeUnwrapReturnValue(CodeBuilder cob, Class<?> type) {\n@@ -840,6 +822,3 @@\n-                mv.visitTypeInsn(CHECKCAST, prim.wrapperClassName);\n-                mv.visitMethodInsn(INVOKEVIRTUAL,\n-                        prim.wrapperClassName,\n-                        prim.unwrapMethodName, prim.unwrapMethodDesc, false);\n-\n-                mv.visitInsn(prim.returnOpcode);\n+                cob.checkcast(prim.wrapperClass)\n+                   .invokevirtual(prim.unwrapMethodRef)\n+                   .returnInstruction(TypeKind.from(type).asLoadable());\n@@ -847,2 +826,2 @@\n-                mv.visitTypeInsn(CHECKCAST, dotToSlash(type.getName()));\n-                mv.visitInsn(ARETURN);\n+                cob.checkcast(toClassDesc(type))\n+                   .areturn();\n@@ -857,6 +836,3 @@\n-        private void codeFieldInitialization(MethodVisitor mv, String className) {\n-            codeClassForName(mv, fromClass);\n-\n-            mv.visitLdcInsn(method.getName());\n-\n-            emitIconstInsn(mv, parameterTypes.length);\n+        private void codeFieldInitialization(CodeBuilder cob, ClassEntry className) {\n+            var cp = cob.constantPool();\n+            codeClassForName(cob, fromClass);\n@@ -864,1 +840,3 @@\n-            mv.visitTypeInsn(Opcodes.ANEWARRAY, JL_CLASS);\n+            cob.ldc(method.getName())\n+               .constantInstruction(parameterTypes.length)\n+               .anewarray(CE_Class);\n@@ -868,3 +846,2 @@\n-                mv.visitInsn(DUP);\n-                emitIconstInsn(mv, i);\n-\n+                cob.dup()\n+                   .constantInstruction(i);\n@@ -872,4 +849,2 @@\n-                    PrimitiveTypeInfo prim =\n-                            PrimitiveTypeInfo.get(parameterTypes[i]);\n-                    mv.visitFieldInsn(GETSTATIC,\n-                            prim.wrapperClassName, \"TYPE\", LJL_CLASS);\n+                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n+                    cob.getstatic(prim.typeFieldRef);\n@@ -877,1 +852,1 @@\n-                    codeClassForName(mv, parameterTypes[i]);\n+                    codeClassForName(cob, parameterTypes[i]);\n@@ -879,1 +854,1 @@\n-                mv.visitInsn(Opcodes.AASTORE);\n+                cob.aastore();\n@@ -882,9 +857,2 @@\n-            mv.visitMethodInsn(INVOKEVIRTUAL,\n-                    JL_CLASS,\n-                    \"getMethod\",\n-                    \"(Ljava\/lang\/String;[Ljava\/lang\/Class;)Ljava\/lang\/reflect\/Method;\",\n-                    false);\n-\n-            mv.visitFieldInsn(PUTSTATIC,\n-                    dotToSlash(className),\n-                    methodFieldName, LJLR_METHOD);\n+            cob.invokevirtual(MRE_Class_getMethod)\n+               .putstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n@@ -904,27 +872,5 @@\n-        private void codeClassForName(MethodVisitor mv, Class<?> cl) {\n-            mv.visitLdcInsn(cl.getName());\n-            mv.visitInsn(ICONST_0); \/\/ false\n-            mv.visitVarInsn(ALOAD, 0); \/\/ classLoader\n-            mv.visitMethodInsn(INVOKESTATIC,\n-                    JL_CLASS,\n-                    \"forName\",\n-                    \"(Ljava\/lang\/String;Z\" + LJL_CLASSLOADER + \")Ljava\/lang\/Class;\",\n-                    false);\n-        }\n-\n-        \/**\n-         * Visit a bytecode for a constant.\n-         *\n-         * @param mv  The MethodVisitor\n-         * @param cst The constant value\n-         *\/\n-        private void emitIconstInsn(MethodVisitor mv, final int cst) {\n-            if (cst >= -1 && cst <= 5) {\n-                mv.visitInsn(Opcodes.ICONST_0 + cst);\n-            } else if (cst >= Byte.MIN_VALUE && cst <= Byte.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.BIPUSH, cst);\n-            } else if (cst >= Short.MIN_VALUE && cst <= Short.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.SIPUSH, cst);\n-            } else {\n-                mv.visitLdcInsn(cst);\n-            }\n+        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n+            cob.ldc(cl.getName())\n+               .iconst_0() \/\/ false\n+               .aload(0)\/\/ classLoader\n+               .invokestatic(MRE_Class_forName);\n@@ -939,0 +885,1 @@\n+    private static final ConstantPoolBuilder CP = ConstantPoolBuilder.of();\n@@ -945,8 +892,8 @@\n-        BYTE(byte.class, ILOAD, IRETURN),\n-        CHAR(char.class, ILOAD, IRETURN),\n-        DOUBLE(double.class, DLOAD, DRETURN),\n-        FLOAT(float.class, FLOAD, FRETURN),\n-        INT(int.class, ILOAD, IRETURN),\n-        LONG(long.class, LLOAD, LRETURN),\n-        SHORT(short.class, ILOAD, IRETURN),\n-        BOOLEAN(boolean.class, ILOAD, IRETURN);\n+        BYTE(byte.class, CD_byte, CD_Byte),\n+        CHAR(char.class, CD_char, CD_Character),\n+        DOUBLE(double.class, CD_double, CD_Double),\n+        FLOAT(float.class, CD_float, CD_Float),\n+        INT(int.class, CD_int, CD_Integer),\n+        LONG(long.class, CD_long, CD_Long),\n+        SHORT(short.class, CD_short, CD_Short),\n+        BOOLEAN(boolean.class, CD_boolean, CD_Boolean);\n@@ -955,9 +902,1 @@\n-         * internal name of corresponding wrapper class\n-         *\/\n-        private final String wrapperClassName;\n-        \/**\n-         * method descriptor for wrapper class \"valueOf\" factory method\n-         *\/\n-        private final String wrapperValueOfDesc;\n-        \/**\n-         * name of wrapper class method for retrieving primitive value\n+         * CP entry of corresponding wrapper class\n@@ -965,1 +904,1 @@\n-        private final String unwrapMethodName;\n+        private final ClassEntry wrapperClass;\n@@ -967,1 +906,1 @@\n-         * descriptor of same method\n+         * CP entry for wrapper class \"valueOf\" factory method\n@@ -969,1 +908,1 @@\n-        private final String unwrapMethodDesc;\n+        private final MethodRefEntry wrapperMethodRef;\n@@ -971,1 +910,1 @@\n-         * Load opcode used by this primitive\n+         * CP entry of wrapper class method for retrieving primitive value\n@@ -973,1 +912,1 @@\n-        private final int loadOpcode;\n+        private final MethodRefEntry unwrapMethodRef;\n@@ -975,1 +914,1 @@\n-         * Return opcode used by this primitive\n+         * CP entry of wrapper class TYPE field\n@@ -977,17 +916,8 @@\n-        private final int returnOpcode;\n-\n-        PrimitiveTypeInfo(Class<?> primitiveClass, int loadOpcode, int returnOpcode) {\n-            assert primitiveClass.isPrimitive();\n-            assert returnOpcode - IRETURN == loadOpcode - ILOAD;\n-\n-            Wrapper wrapper = Wrapper.forPrimitiveType(primitiveClass);\n-            \/\/ single-char BaseType descriptor (see JVMS section 4.3.2)\n-            String baseTypeString = wrapper.basicTypeString();\n-            var wrapperType = wrapper.wrapperType();\n-            wrapperClassName = dotToSlash(wrapperType.getName());\n-            wrapperValueOfDesc =\n-                    \"(\" + baseTypeString + \")\" + wrapperType.descriptorString();\n-            unwrapMethodName = primitiveClass.getName() + \"Value\";\n-            unwrapMethodDesc = \"()\" + baseTypeString;\n-            this.loadOpcode = loadOpcode;\n-            this.returnOpcode = returnOpcode;\n+        private final FieldRefEntry typeFieldRef;\n+\n+        PrimitiveTypeInfo(Class<?> primitiveClass, ClassDesc baseType, ClassDesc wrapperClass) {\n+            assert baseType.isPrimitive();\n+            this.wrapperClass = CP.classEntry(wrapperClass);\n+            this.wrapperMethodRef = CP.methodRefEntry(wrapperClass, \"valueOf\", MethodTypeDesc.of(wrapperClass, baseType));\n+            this.unwrapMethodRef = CP.methodRefEntry(wrapperClass, primitiveClass.getName() + \"Value\", MethodTypeDesc.of(baseType));\n+            this.typeFieldRef = CP.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":344,"deletions":414,"binary":false,"changes":758,"status":"modified"}]}