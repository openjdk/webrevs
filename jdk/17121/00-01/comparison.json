{"files":[{"patch":"@@ -48,0 +48,3 @@\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n+import java.util.StringJoiner;\n@@ -57,1 +60,0 @@\n-    private static final int CLASSFILE_VERSION = ClassFileFormatVersion.latest().major();\n@@ -108,0 +110,22 @@\n+    private static final ClassModel TEMPLATE;\n+\n+    private static final Utf8Entry UE_Method;\n+    private static final MethodRefEntry MRE_Class_getClassLoader;\n+    private static final MethodRefEntry MRE_NoSuchMethodError_init;\n+    private static final ClassEntry CE_NoSuchMethodError;\n+    private static final FieldRefEntry FRE_Proxy_h;\n+    private static final ClassEntry CE_NoClassDefFoundError;\n+    private static final MethodRefEntry MRE_NoClassDefFoundError_init;\n+    private static final MethodRefEntry MRE_Throwable_getMessage;\n+    private static final MethodRefEntry MRE_Class_forName;\n+    private static final ClassEntry CE_Class;\n+    private static final MethodRefEntry MRE_Class_getMethod;\n+    private static final ClassEntry CE_Object;\n+    private static final InterfaceMethodRefEntry IMRE_InvocationHandler_invoke;\n+    private static final MethodRefEntry MRE_UndeclaredThrowableException_init;\n+    private static final ClassEntry CE_UndeclaredThrowableException;\n+    private static final ClassEntry CE_Throwable;\n+    private static final ClassEntry CE_NoSuchMethodException;\n+    private static final ClassEntry CE_ClassNotFoundException;\n+    private static final List<StackMapFrameInfo.VerificationTypeInfo> THROWABLE_STACK;\n+\n@@ -109,0 +133,40 @@\n+        var cc = ClassFile.of();\n+        var entries = new ArrayList<PoolEntry>(20);\n+        var q = new Object() {\n+            PoolEntry[] entries;\n+            int i;\n+            @SuppressWarnings(\"unchecked\")\n+            <T extends PoolEntry> T next() {\n+                return (T) TEMPLATE.constantPool().entryByIndex(entries[i++].index());\n+            }\n+        };\n+        TEMPLATE = cc.parse(cc.build(CD_Proxy, clb -> {\n+            clb.withSuperclass(CD_Proxy);\n+            generateConstructor(clb);\n+            generateLookupAccessor(clb);\n+            var cp = clb.constantPool();\n+            q.entries = new PoolEntry[] {\n+                cp.utf8Entry(\"m0\"),\n+                cp.utf8Entry(\"m1\"),\n+                cp.utf8Entry(\"m2\"),\n+                cp.utf8Entry(CD_Method),\n+                cp.methodRefEntry(CD_Class, \"getClassLoader\", MTD_ClassLoader),\n+                cp.classEntry(CD_NoSuchMethodError),\n+                cp.methodRefEntry(CD_NoSuchMethodError, INIT_NAME, MTD_void_String),\n+                cp.fieldRefEntry(CD_Proxy, handlerFieldName, CD_InvocationHandler),\n+                cp.classEntry(CD_NoClassDefFoundError),\n+                cp.methodRefEntry(CD_NoClassDefFoundError, INIT_NAME, MTD_void_String),\n+                cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String),\n+                cp.methodRefEntry(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader),\n+                cp.classEntry(CD_Class),\n+                cp.methodRefEntry(CD_Class, \"getMethod\", MTD_Method_String_ClassArray),\n+                cp.classEntry(CD_Object),\n+                cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray),\n+                cp.methodRefEntry(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable),\n+                cp.classEntry(CD_UndeclaredThrowableException),\n+                cp.classEntry(CD_NoSuchMethodException),\n+                cp.classEntry(CD_ClassNotFoundException),\n+                cp.classEntry(CD_Throwable)\n+            };\n+        }));\n+\n@@ -110,3 +174,3 @@\n-            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), \"m0\");\n-            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), \"m1\");\n-            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), \"m2\");\n+            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), q.next());\n+            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), q.next());\n+            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), q.next());\n@@ -116,0 +180,19 @@\n+        UE_Method = q.next();\n+        MRE_Class_getClassLoader = q.next();\n+        CE_NoSuchMethodError = q.next();\n+        MRE_NoSuchMethodError_init = q.next();\n+        FRE_Proxy_h = q.next();\n+        CE_NoClassDefFoundError = q.next();\n+        MRE_NoClassDefFoundError_init = q.next();\n+        MRE_Throwable_getMessage = q.next();\n+        MRE_Class_forName = q.next();\n+        CE_Class = q.next();\n+        MRE_Class_getMethod = q.next();\n+        CE_Object = q.next();\n+        IMRE_InvocationHandler_invoke = q.next();\n+        MRE_UndeclaredThrowableException_init = q.next();\n+        CE_UndeclaredThrowableException = q.next();\n+        CE_NoSuchMethodException = q.next();\n+        CE_ClassNotFoundException = q.next();\n+        CE_Throwable = q.next();\n+        THROWABLE_STACK = List.of(StackMapFrameInfo.ObjectVerificationTypeInfo.of(CE_Throwable));\n@@ -122,0 +205,1 @@\n+    private final ConstantPoolBuilder cp;\n@@ -126,1 +210,1 @@\n-    private final ClassDesc classDesc;\n+    private ClassEntry classEntry;\n@@ -161,0 +245,1 @@\n+                ClassFile.StackMapsOption.DROP_STACK_MAPS,\n@@ -163,1 +248,2 @@\n-        this.classDesc = ClassDesc.of(className);\n+        this.cp = ConstantPoolBuilder.of(TEMPLATE);\n+        this.classEntry = cp.classEntry(ClassDesc.of(className));\n@@ -414,16 +500,10 @@\n-        return classfileContext.build(classDesc, clb -> {\n-            clb.withFlags(accessFlags);\n-            clb.withSuperclass(CD_Proxy);\n-            clb.withInterfaceSymbols(interfaces.stream().map(ProxyGenerator::toClassDesc).toList());\n-            clb.withVersion(CLASSFILE_VERSION, 0);\n-\n-            \/*\n-             * Add proxy methods for the hashCode, equals,\n-             * and toString methods of java.lang.Object.  This is done before\n-             * the methods from the proxy interfaces so that the methods from\n-             * java.lang.Object take precedence over duplicate methods in the\n-             * proxy interfaces.\n-             *\/\n-            addProxyMethod(hashCodeMethod);\n-            addProxyMethod(equalsMethod);\n-            addProxyMethod(toStringMethod);\n+        \/*\n+         * Add proxy methods for the hashCode, equals,\n+         * and toString methods of java.lang.Object.  This is done before\n+         * the methods from the proxy interfaces so that the methods from\n+         * java.lang.Object take precedence over duplicate methods in the\n+         * proxy interfaces.\n+         *\/\n+        addProxyMethod(hashCodeMethod);\n+        addProxyMethod(equalsMethod);\n+        addProxyMethod(toStringMethod);\n@@ -431,8 +511,7 @@\n-            \/*\n-             * Accumulate all of the methods from the proxy interfaces.\n-             *\/\n-            for (Class<?> intf : interfaces) {\n-                for (Method m : intf.getMethods()) {\n-                    if (!Modifier.isStatic(m.getModifiers())) {\n-                        addProxyMethod(m, intf);\n-                    }\n+        \/*\n+         * Accumulate all of the methods from the proxy interfaces.\n+         *\/\n+        for (Class<?> intf : interfaces) {\n+            for (Method m : intf.getMethods()) {\n+                if (!Modifier.isStatic(m.getModifiers())) {\n+                    addProxyMethod(m, intf, cp);\n@@ -441,0 +520,1 @@\n+        }\n@@ -442,7 +522,7 @@\n-            \/*\n-             * For each set of proxy methods with the same signature,\n-             * verify that the methods' return types are compatible.\n-             *\/\n-            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-                checkReturnTypes(sigmethods);\n-            }\n+        \/*\n+         * For each set of proxy methods with the same signature,\n+         * verify that the methods' return types are compatible.\n+         *\/\n+        for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+            checkReturnTypes(sigmethods);\n+        }\n@@ -450,1 +530,4 @@\n-            generateConstructor(clb);\n+        return classfileContext.build(classEntry, cp, clb -> {\n+            TEMPLATE.forEach(clb);\n+            clb.withFlags(accessFlags);\n+            clb.withInterfaceSymbols(interfaces.stream().map(ProxyGenerator::toClassDesc).toList());\n@@ -455,1 +538,1 @@\n-                    clb.withField(pm.methodFieldName, CD_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+                    clb.withField(pm.methodFieldName, UE_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -458,1 +541,1 @@\n-                    pm.generateMethod(clb, classDesc);\n+                    pm.generateMethod(clb, classEntry);\n@@ -463,1 +546,0 @@\n-            generateLookupAccessor(clb);\n@@ -480,1 +562,1 @@\n-    private void addProxyMethod(Method m, Class<?> fromClass) {\n+    private void addProxyMethod(Method m, Class<?> fromClass, ConstantPoolBuilder cp) {\n@@ -506,1 +588,1 @@\n-                \"m\" + proxyMethodCount++));\n+                cp.utf8Entry(\"m\" + proxyMethodCount++)));\n@@ -524,1 +606,1 @@\n-    private void generateConstructor(ClassBuilder clb) {\n+    private static void generateConstructor(ClassBuilder clb) {\n@@ -536,28 +618,33 @@\n-        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> cob\n-                \/\/ Put ClassLoader at local variable index 0, used by\n-                \/\/ Class.forName(String, boolean, ClassLoader) calls\n-                .constantInstruction(classDesc)\n-                .invokevirtual(CD_Class, \"getClassLoader\", MTD_ClassLoader)\n-                .astore(0)\n-                .trying(tryb -> {\n-                    for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-                        for (ProxyMethod pm : sigmethods) {\n-                            pm.codeFieldInitialization(tryb, classDesc);\n-                        }\n-                    }\n-                    tryb.return_();\n-                }, cb -> cb\n-                    .catching(CD_NoSuchMethodException, nsmb -> nsmb\n-                            .new_(CD_NoSuchMethodError)\n-                            .dup_x1()\n-                            .swap()\n-                            .invokevirtual(CD_Throwable, \"getMessage\", MTD_String)\n-                            .invokespecial(CD_NoSuchMethodError, INIT_NAME, MTD_void_String)\n-                            .athrow())\n-                    .catching(CD_ClassNotFoundException, cnfb -> cnfb\n-                            .new_(CD_NoClassDefFoundError)\n-                            .dup_x1()\n-                            .swap()\n-                            .invokevirtual(CD_Throwable, \"getMessage\", MTD_String)\n-                            .invokespecial(CD_NoClassDefFoundError, INIT_NAME, MTD_void_String)\n-                            .athrow())));\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n+            \/\/ Put ClassLoader at local variable index 0, used by\n+            \/\/ Class.forName(String, boolean, ClassLoader) calls\n+            cob.ldc(classEntry)\n+               .invokevirtual(MRE_Class_getClassLoader)\n+               .astore(0);\n+            var ts = cob.newBoundLabel();\n+            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n+                for (ProxyMethod pm : sigmethods) {\n+                    pm.codeFieldInitialization(cob, classEntry);\n+                }\n+            }\n+            cob.return_();\n+            var c1 = cob.newBoundLabel();\n+            cob.exceptionCatch(ts, c1, c1, CE_NoSuchMethodException)\n+               .new_(CE_NoSuchMethodError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(MRE_Throwable_getMessage)\n+               .invokespecial(MRE_NoSuchMethodError_init)\n+               .athrow();\n+            var c2 = cob.newBoundLabel();\n+            cob.exceptionCatch(ts, c1, c2, CE_ClassNotFoundException)\n+               .new_(CE_NoClassDefFoundError)\n+               .dup_x1()\n+               .swap()\n+               .invokevirtual(MRE_Throwable_getMessage)\n+               .invokespecial(MRE_NoClassDefFoundError_init)\n+               .athrow()\n+               .with(StackMapTableAttribute.of(List.of(\n+                     StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n+                     StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+        });\n@@ -571,1 +658,1 @@\n-    private void generateLookupAccessor(ClassBuilder clb) {\n+    private static void generateLookupAccessor(ClassBuilder clb) {\n@@ -607,1 +694,1 @@\n-        private final String methodFieldName;\n+        private final Utf8Entry methodFieldName;\n@@ -612,1 +699,1 @@\n-                            Class<?> fromClass, String methodFieldName) {\n+                            Class<?> fromClass, Utf8Entry methodFieldName) {\n@@ -628,1 +715,1 @@\n-        private ProxyMethod(Method method, String methodFieldName) {\n+        private ProxyMethod(Method method, Utf8Entry methodFieldName) {\n@@ -637,3 +724,6 @@\n-        private void generateMethod(ClassBuilder clb, ClassDesc className) {\n-            MethodTypeDesc desc = MethodTypeDesc.of(toClassDesc(returnType),\n-                    Arrays.stream(parameterTypes).map(ProxyGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+        private void generateMethod(ClassBuilder clb, ClassEntry className) {\n+            var cp = clb.constantPool();\n+            var desc = new StringJoiner(\"\", \"(\", \")\" + returnType.descriptorString());\n+            for (var pt : parameterTypes) {\n+                desc.add(pt.descriptorString());\n+            }\n@@ -643,2 +733,1 @@\n-            clb.withMethod(method.getName(), desc, accessFlags, mb -> {\n-                ConstantPoolBuilder cpb = mb.constantPool();\n+            clb.withMethod(cp.utf8Entry(method.getName()), cp.utf8Entry(desc.toString()), accessFlags, mb -> {\n@@ -648,1 +737,1 @@\n-                        .map(cpb::classEntry)\n+                        .map(cp::classEntry)\n@@ -651,19 +740,15 @@\n-                mb.withCode(cob ->\n-                    cob.trying(tryb -> {\n-                        tryb.aload(tryb.receiverSlot())\n-                            .getfield(CD_Proxy, handlerFieldName, CD_InvocationHandler)\n-                            .aload(tryb.receiverSlot())\n-                            .getstatic(className, methodFieldName, CD_Method);\n-\n-                        if (parameterTypes.length > 0) {\n-                            \/\/ Create an array and fill with the parameters converting primitives to wrappers\n-                            tryb.constantInstruction(parameterTypes.length)\n-                                .anewarray(CD_Object);\n-                            for (int i = 0; i < parameterTypes.length; i++) {\n-                                tryb.dup()\n-                                    .constantInstruction(i);\n-                                codeWrapArgument(tryb, parameterTypes[i], tryb.parameterSlot(i));\n-                                tryb.aastore();\n-                            }\n-                        } else {\n-                            tryb.aconst_null();\n+                mb.withCode(cob -> {\n+                    cob.aload(cob.receiverSlot())\n+                       .getfield(FRE_Proxy_h)\n+                       .aload(cob.receiverSlot())\n+                       .getstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n+\n+                    if (parameterTypes.length > 0) {\n+                        \/\/ Create an array and fill with the parameters converting primitives to wrappers\n+                        cob.constantInstruction(parameterTypes.length)\n+                           .anewarray(CE_Object);\n+                        for (int i = 0; i < parameterTypes.length; i++) {\n+                            cob.dup()\n+                               .constantInstruction(i);\n+                            codeWrapArgument(cob, parameterTypes[i], cob.parameterSlot(i));\n+                            cob.aastore();\n@@ -671,0 +756,3 @@\n+                    } else {\n+                        cob.aconst_null();\n+                    }\n@@ -672,1 +760,1 @@\n-                        tryb.invokeinterface(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray);\n+                    cob.invokeinterface(IMRE_InvocationHandler_invoke);\n@@ -674,17 +762,10 @@\n-                        if (returnType == void.class) {\n-                            tryb.pop()\n-                                .return_();\n-                        } else {\n-                            codeUnwrapReturnValue(tryb, returnType);\n-                        }\n-                    }, catchBuilder -> {\n-                        if (!catchList.isEmpty()) {\n-                            catchBuilder.catchingMulti(catchList, ehb -> ehb\n-                                    .athrow());   \/\/ just rethrow the exception\n-\n-                            catchBuilder.catching(CD_Throwable, ehb -> ehb\n-                                    .new_(CD_UndeclaredThrowableException)\n-                                    .dup_x1()\n-                                    .swap()\n-                                    .invokespecial(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable)\n-                                    .athrow());\n+                    if (returnType == void.class) {\n+                        cob.pop()\n+                           .return_();\n+                    } else {\n+                        codeUnwrapReturnValue(cob, returnType);\n+                    }\n+                    if (!catchList.isEmpty()) {\n+                        var c1 = cob.newBoundLabel();\n+                        for (var exc : catchList) {\n+                            cob.exceptionCatch(cob.startLabel(), c1, c1, exc);\n@@ -692,1 +773,13 @@\n-                    }));\n+                        cob.athrow();   \/\/ just rethrow the exception\n+                        var c2 = cob.newBoundLabel();\n+                        cob.exceptionCatchAll(cob.startLabel(), c1, c2)\n+                           .new_(CE_UndeclaredThrowableException)\n+                           .dup_x1()\n+                           .swap()\n+                           .invokespecial(MRE_UndeclaredThrowableException_init)\n+                           .athrow()\n+                           .with(StackMapTableAttribute.of(List.of(\n+                                StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n+                                StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n+                    }\n+                });\n@@ -706,1 +799,1 @@\n-                cob.invokestatic(prim.wrapperClass, \"valueOf\", prim.wrapperValueOf);\n+                cob.invokestatic(prim.wrapperMethodRef);\n@@ -721,2 +814,2 @@\n-                cob.typeCheckInstruction(Opcode.CHECKCAST, prim.wrapperClass)\n-                   .invokevirtual(prim.wrapperClass, prim.unwrapMethodName, prim.unwrapMethodType)\n+                cob.checkcast(prim.wrapperClass)\n+                   .invokevirtual(prim.unwrapMethodRef)\n@@ -735,1 +828,2 @@\n-        private void codeFieldInitialization(CodeBuilder cob, ClassDesc className) {\n+        private void codeFieldInitialization(CodeBuilder cob, ClassEntry className) {\n+            var cp = cob.constantPool();\n@@ -740,1 +834,1 @@\n-               .anewarray(CD_Class);\n+               .anewarray(CE_Class);\n@@ -748,1 +842,1 @@\n-                    cob.getstatic(prim.wrapperClass, \"TYPE\", CD_Class);\n+                    cob.getstatic(prim.typeFieldRef);\n@@ -755,2 +849,2 @@\n-            cob.invokevirtual(CD_Class, \"getMethod\", MTD_Method_String_ClassArray)\n-               .putstatic(className, methodFieldName, CD_Method);\n+            cob.invokevirtual(MRE_Class_getMethod)\n+               .putstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n@@ -771,1 +865,1 @@\n-            cob.constantInstruction(Opcode.LDC, cl.getName())\n+            cob.ldc(cl.getName())\n@@ -774,1 +868,1 @@\n-               .invokestatic(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader);\n+               .invokestatic(MRE_Class_forName);\n@@ -783,0 +877,1 @@\n+    private static final ConstantPoolBuilder CP = ConstantPoolBuilder.of();\n@@ -799,1 +894,1 @@\n-         * internal name of corresponding wrapper class\n+         * CP entry of corresponding wrapper class\n@@ -801,1 +896,1 @@\n-        private final ClassDesc wrapperClass;\n+        private final ClassEntry wrapperClass;\n@@ -803,1 +898,1 @@\n-         * method descriptor for wrapper class \"valueOf\" factory method\n+         * CP entry for wrapper class \"valueOf\" factory method\n@@ -805,1 +900,1 @@\n-        private final MethodTypeDesc wrapperValueOf;\n+        private final MethodRefEntry wrapperMethodRef;\n@@ -807,1 +902,1 @@\n-         * name of wrapper class method for retrieving primitive value\n+         * CP entry of wrapper class method for retrieving primitive value\n@@ -809,1 +904,1 @@\n-        private final String unwrapMethodName;\n+        private final MethodRefEntry unwrapMethodRef;\n@@ -811,1 +906,1 @@\n-         * descriptor of same method\n+         * CP entry of wrapper class TYPE field\n@@ -813,1 +908,1 @@\n-        private final MethodTypeDesc unwrapMethodType;\n+        private final FieldRefEntry typeFieldRef;\n@@ -817,4 +912,4 @@\n-            this.wrapperClass = wrapperClass;\n-            this.wrapperValueOf = MethodTypeDesc.of(wrapperClass, baseType);\n-            this.unwrapMethodName = primitiveClass.getName() + \"Value\";\n-            this.unwrapMethodType = MethodTypeDesc.of(baseType);\n+            this.wrapperClass = CP.classEntry(wrapperClass);\n+            this.wrapperMethodRef = CP.methodRefEntry(wrapperClass, \"valueOf\", MethodTypeDesc.of(wrapperClass, baseType));\n+            this.unwrapMethodRef = CP.methodRefEntry(wrapperClass, primitiveClass.getName() + \"Value\", MethodTypeDesc.of(baseType));\n+            this.typeFieldRef = CP.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":237,"deletions":142,"binary":false,"changes":379,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n@@ -32,1 +30,0 @@\n-import java.util.LinkedHashMap;\n@@ -34,1 +31,0 @@\n-import java.util.stream.Collectors;\n@@ -40,0 +36,3 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.LinkedList;\n@@ -44,0 +43,2 @@\n+    private record Target(int bci, int stack) {}\n+\n@@ -47,3 +48,2 @@\n-                buf.thisClass().asSymbol(),\n-                dcb.methodInfo.methodName().stringValue(),\n-                dcb.methodInfo.methodTypeSymbol(),\n+                dcb.methodInfo.methodName(),\n+                dcb.methodInfo.methodType(),\n@@ -59,2 +59,2 @@\n-    private final String methodName;\n-    private final MethodTypeDesc methodDesc;\n+    private final Utf8Entry methodName;\n+    private final Utf8Entry methodDesc;\n@@ -62,1 +62,1 @@\n-    private final LinkedHashMap<Integer, Integer> map;\n+    private final LinkedList<Target> targets;\n@@ -67,1 +67,1 @@\n-            map.put(targetBci, stack);\n+            targets.add(new Target(targetBci, stack));\n@@ -81,1 +81,1 @@\n-        var it = map.entrySet().iterator();\n+        var it = targets.iterator();\n@@ -85,3 +85,3 @@\n-            if (!visited.get(en.getKey())) {\n-                bcs.nextBci = en.getKey();\n-                stack = en.getValue();\n+            if (!visited.get(en.bci)) {\n+                bcs.nextBci = en.bci;\n+                stack = en.stack;\n@@ -96,3 +96,2 @@\n-                     ClassDesc thisClass,\n-                     String methodName,\n-                     MethodTypeDesc methodDesc,\n+                     Utf8Entry methodName,\n+                     Utf8Entry methodDesc,\n@@ -106,1 +105,1 @@\n-        map = new LinkedHashMap<>();\n+        targets = new LinkedList<>();\n@@ -108,1 +107,1 @@\n-        for (var h : handlers) map.put(labelContext.labelToBci(h.handler), 1);\n+        for (var h : handlers) targets.add(new Target(labelContext.labelToBci(h.handler), 1));\n@@ -110,3 +109,1 @@\n-        for (var cd : methodDesc.parameterList()) {\n-            maxLocals += Util.slotSize(cd);\n-        }\n+        maxLocals += countMethodStack(methodDesc, false);\n@@ -115,1 +112,1 @@\n-        map.put(0, 0);\n+        targets.add(new Target(0, 0));\n@@ -310,4 +307,1 @@\n-                        var mDesc = MethodTypeDesc.ofDescriptor(nameAndType.type().stringValue());\n-                        for (var arg : mDesc.parameterList()) {\n-                            addStackSlot(-TypeKind.from(arg).slotSize());\n-                        }\n+                        addStackSlot(-countMethodStack(nameAndType.type(), true));\n@@ -317,1 +311,0 @@\n-                        addStackSlot(TypeKind.from(mDesc.returnType()).slotSize());\n@@ -346,0 +339,45 @@\n+    private static int countMethodStack(Utf8Entry descriptor, boolean subReturn) {\n+        int cur = 0, end = descriptor.length();\n+        if (cur >= end || descriptor.charAt(cur) != '(')\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        ++cur;  \/\/ skip '('\n+        int count = 0;\n+        boolean inArray = false;\n+        while (cur < end) {\n+            switch (descriptor.charAt(cur++)) {\n+                case 'Z', 'B', 'C', 'S', 'I', 'F' -> {\n+                    count++;\n+                    inArray = false;\n+                }\n+                case 'J', 'D' -> {\n+                    count += inArray ? 1 : 2;\n+                    inArray = false;\n+                }\n+                case 'L' -> {\n+                    while (cur < end && descriptor.charAt(cur++) != ';');\n+                    count++;\n+                    inArray = false;\n+                }\n+                case '[' -> {\n+                    inArray = true;\n+                }\n+                case ')' -> {\n+                    if (cur < end) {\n+                        if (subReturn) {\n+                            return switch (descriptor.charAt(cur++)) {\n+                                case 'Z', 'B', 'C', 'S', 'I', 'F', '[', 'L' -> count - 1;\n+                                case 'J', 'D' -> count - 2;\n+                                case 'V' -> count;\n+                                default -> throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+                            };\n+                        } else {\n+                            return count;\n+                        }\n+                    }\n+                }\n+                default -> throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+    }\n+\n@@ -380,1 +418,1 @@\n-                methodDesc.displayDescriptor()));\n+                MethodTypeDesc.ofDescriptor(methodDesc.stringValue()).displayDescriptor()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":68,"deletions":30,"binary":false,"changes":98,"status":"modified"}]}