{"files":[{"patch":"@@ -162,0 +162,1 @@\n+  _prelinker(),\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/classPrelinker.hpp\"\n@@ -231,0 +232,1 @@\n+  ClassPrelinker _prelinker;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/classPrelinker.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/constantPool.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+\n+ClassPrelinker* ClassPrelinker::_singleton = NULL;\n+\n+bool ClassPrelinker::is_vm_class(InstanceKlass* ik) {\n+  return (_vm_classes.get(ik) != NULL);\n+}\n+\n+void ClassPrelinker::add_one_vm_class(InstanceKlass* ik) {\n+  bool created;\n+  _vm_classes.put_if_absent(ik, &created);\n+  if (created) {\n+    InstanceKlass* super = ik->java_super();\n+    if (super != NULL) {\n+      add_one_vm_class(super);\n+    }\n+    Array<InstanceKlass*>* ifs = ik->local_interfaces();\n+    for (int i = 0; i < ifs->length(); i++) {\n+      add_one_vm_class(ifs->at(i));\n+    }\n+  }\n+}\n+\n+ClassPrelinker::ClassPrelinker() {\n+  assert(_singleton == NULL, \"must be\");\n+  _singleton = this;\n+  for (auto id : EnumRange<vmClassID>{}) {\n+    add_one_vm_class(vmClasses::klass_at(id));\n+  }\n+}\n+\n+ClassPrelinker::~ClassPrelinker() {\n+  assert(_singleton == this, \"must be\");\n+  _singleton = NULL;\n+}\n+\n+bool ClassPrelinker::can_archive_resolved_vm_class(InstanceKlass* cp_holder, InstanceKlass* resolved_klass) {\n+  if (!is_vm_class(resolved_klass)) {\n+    return false;\n+  }\n+  if (!cp_holder->is_shared_boot_class() &&\n+      !cp_holder->is_shared_platform_class() &&\n+      !cp_holder->is_shared_app_class()) {\n+    \/\/ Custom loaders are not guaranteed to resolve the vmClasses to the\n+    \/\/ ones resolved by the boot loader.\n+    return false;\n+  }\n+  if (cp_holder->class_loader_data() != resolved_klass->class_loader_data()) {\n+    \/\/ If they are defined by different loaders, it's possible for resolved_klass\n+    \/\/ to be already defined, but is not yet resolved in cp_holder->class_loader().\n+\n+    \/\/ TODO: this check can be removed if we preload the vmClasses into\n+    \/\/ platform and app loaders during VM bootstrap.\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool ClassPrelinker::can_archive_resolved_klass(InstanceKlass* cp_holder, Klass* resolved_klass) {\n+  assert(!is_in_archivebuilder_buffer(cp_holder), \"sanity\");\n+  assert(!is_in_archivebuilder_buffer(resolved_klass), \"sanity\");\n+\n+  if (resolved_klass->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(resolved_klass);\n+    if (can_archive_resolved_vm_class(cp_holder, ik)) {\n+      return true;\n+    }\n+    if (cp_holder->is_subtype_of(ik)) {\n+      \/\/ All super types of ik will be resolved in ik->class_loader() before\n+      \/\/ ik is defined in this loader, so it's safe to archive the resolved klass reference.\n+      return true;\n+    }\n+\n+    \/\/ TODO -- allow objArray classes, too\n+  }\n+\n+  return false;\n+}\n+\n+Klass* ClassPrelinker::get_resolved_klass_or_null(ConstantPool* cp, int cp_index) {\n+  if (cp->tag_at(cp_index).is_klass()) {\n+    CPKlassSlot kslot = cp->klass_slot_at(cp_index);\n+    int resolved_klass_index = kslot.resolved_klass_index();\n+    return cp->resolved_klasses()->at(resolved_klass_index);\n+  } else {\n+    \/\/ klass is not resolved yet\n+    assert(cp->tag_at(cp_index).is_unresolved_klass() ||\n+           cp->tag_at(cp_index).is_unresolved_klass_in_error(), \"must be\");\n+    return NULL;\n+  }\n+}\n+\n+bool ClassPrelinker::can_archive_resolved_klass(ConstantPool* cp, int cp_index) {\n+  assert(!is_in_archivebuilder_buffer(cp), \"sanity\");\n+  assert(cp->tag_at(cp_index).is_klass(), \"must be resolved\");\n+\n+  Klass* resolved_klass = get_resolved_klass_or_null(cp, cp_index);\n+  assert(resolved_klass != NULL, \"must be\");\n+\n+  return can_archive_resolved_klass(cp->pool_holder(), resolved_klass);\n+}\n+\n+void ClassPrelinker::dumptime_resolve_constants(InstanceKlass* ik, TRAPS) {\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  if (cp->cache() == NULL || cp->reference_map() == NULL) {\n+    \/\/ The cache may be NULL if the pool_holder klass fails verification\n+    \/\/ at dump time due to missing dependencies.\n+    return;\n+  }\n+\n+  bool first_time;\n+  _processed_classes.put_if_absent(ik, &first_time);\n+  if (!first_time) {\n+    return;\n+  }\n+\n+  for (int cp_index = 1; cp_index < cp->length(); cp_index++) { \/\/ Index 0 is unused\n+    switch (cp->tag_at(cp_index).value()) {\n+    case JVM_CONSTANT_UnresolvedClass:\n+      maybe_resolve_class(cp, cp_index, CHECK);\n+      break;\n+\n+    case JVM_CONSTANT_String:\n+      resolve_string(cp, cp_index, CHECK); \/\/ may throw OOM when interning strings.\n+      break;\n+    }\n+  }\n+}\n+\n+Klass* ClassPrelinker::find_loaded_class(JavaThread* THREAD, oop class_loader, Symbol* name) {\n+  Handle h_loader(THREAD, class_loader);\n+  Klass* k = SystemDictionary::find_instance_or_array_klass(THREAD, name,\n+                                                            h_loader,\n+                                                            Handle());\n+  if (k != NULL) {\n+    return k;\n+  }\n+  if (class_loader == SystemDictionary::java_system_loader()) {\n+    return find_loaded_class(THREAD, SystemDictionary::java_platform_loader(), name);\n+  } else if (class_loader == SystemDictionary::java_platform_loader()) {\n+    return find_loaded_class(THREAD, NULL, name);\n+  }\n+\n+  return NULL;\n+}\n+\n+Klass* ClassPrelinker::maybe_resolve_class(constantPoolHandle cp, int cp_index, TRAPS) {\n+  assert(!is_in_archivebuilder_buffer(cp()), \"sanity\");\n+  InstanceKlass* cp_holder = cp->pool_holder();\n+  if (!cp_holder->is_shared_boot_class() &&\n+      !cp_holder->is_shared_platform_class() &&\n+      !cp_holder->is_shared_app_class()) {\n+    \/\/ Don't trust custom loaders, as they may not be well-behaved\n+    \/\/ when resolving classes.\n+    return NULL;\n+  }\n+\n+  CPKlassSlot kslot = cp->klass_slot_at(cp_index);\n+  int name_index = kslot.name_index();\n+  Symbol* name = cp->symbol_at(name_index);\n+  Klass* resolved_klass = find_loaded_class(THREAD, cp_holder->class_loader(), name);\n+  if (resolved_klass != NULL && can_archive_resolved_klass(cp_holder, resolved_klass)) {\n+    Klass* k = ConstantPool::klass_at_impl(cp, cp_index, CHECK_NULL); \/\/ Should fail only with OOM\n+    assert(k == resolved_klass, \"must be\");\n+  }\n+\n+  return resolved_klass;\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+void ClassPrelinker::resolve_string(constantPoolHandle cp, int cp_index, TRAPS) {\n+  if (!DumpSharedSpaces) {\n+    \/\/ The archive heap is not supported for the dynamic archive.\n+    return;\n+  }\n+\n+  int cache_index = cp->cp_to_object_index(cp_index);\n+  ConstantPool::string_at_impl(cp, cp_index, cache_index, CHECK);\n+}\n+#endif\n+\n+#ifdef ASSERT\n+bool ClassPrelinker::is_in_archivebuilder_buffer(address p) {\n+  if (!Thread::current()->is_VM_thread() || ArchiveBuilder::current() == NULL) {\n+    return false;\n+  } else {\n+    return ArchiveBuilder::current()->is_in_buffer_space(p);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_CLASSPRELINKER_HPP\n+#define SHARE_CDS_CLASSPRELINKER_HPP\n+\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class ConstantPool;\n+class constantPoolHandle;\n+class InstanceKlass;\n+class Klass;\n+\n+\/\/ ClassPrelinker is used to perform ahead-of-time linking of ConstantPool entries\n+\/\/ for archived InstanceKlasses.\n+\/\/\n+\/\/ At run time, Java classes are loaded dynamically and may be replaced with JVMTI.\n+\/\/ Therefore, we take care to prelink only the ConstantPool entries that are\n+\/\/ guatanteed to resolve to the same results at both dump time and run time.\n+\/\/\n+\/\/ For example, a JVM_CONSTANT_Class reference to a supertype can be safely resolved\n+\/\/ at dump time, because at run time we will load a class from the CDS archive only\n+\/\/ if all of its supertypes are loaded from the CDS archive.\n+class ClassPrelinker :  public StackObj {\n+  typedef ResourceHashtable<InstanceKlass*, bool, 15889, ResourceObj::C_HEAP, mtClassShared> ClassesTable;\n+  ClassesTable _processed_classes;\n+  ClassesTable _vm_classes;\n+\n+  void add_one_vm_class(InstanceKlass* ik);\n+  bool can_archive_resolved_vm_class(InstanceKlass* cp_holder, InstanceKlass* resolved_klass);\n+\n+#ifdef ASSERT\n+  static bool is_in_archivebuilder_buffer(address p);\n+#endif\n+\n+  template <typename T>\n+  static bool is_in_archivebuilder_buffer(T p) {\n+    return is_in_archivebuilder_buffer((address)(p));\n+  }\n+  void resolve_string(constantPoolHandle cp, int cp_index, TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n+  Klass* maybe_resolve_class(constantPoolHandle cp, int cp_index, TRAPS);\n+  bool can_archive_resolved_klass(InstanceKlass* cp_holder, Klass* resolved_klass);\n+  Klass* find_loaded_class(JavaThread* THREAD, oop class_loader, Symbol* name);\n+  Klass* get_resolved_klass_or_null(ConstantPool* cp, int cp_index);\n+\n+  static ClassPrelinker* _singleton;\n+public:\n+  ClassPrelinker();\n+  ~ClassPrelinker();\n+  static ClassPrelinker* current() {\n+    assert(_singleton != NULL, \"must have one\");\n+    return _singleton;\n+  }\n+\n+  \/\/ Is this class resolved as part of vmClasses::resolve_all()? If so, these\n+  \/\/ classes are guatanteed to be loaded at runtime (and cannot be replaced by JVMTI)\n+  \/\/ when CDS is enabled. Therefore, we can safely keep a direct reference to these\n+  \/\/ classes.\n+  bool is_vm_class(InstanceKlass* ik);\n+\n+  \/\/ Resolve all constant pool entries that are safe to be stored in the\n+  \/\/ CDS archive.\n+  void dumptime_resolve_constants(InstanceKlass* ik, TRAPS);\n+\n+  \/\/ Can we resolve the klass entry at cp_index in this constant pool, and store\n+  \/\/ the result in the CDS archive? Returns true if cp_index is guaranteed to\n+  \/\/ resolve to the same InstanceKlass* at both dump time and run time.\n+  bool can_archive_resolved_klass(ConstantPool* cp, int cp_index);\n+};\n+\n+#endif \/\/ SHARE_CDS_CLASSPRELINKER_HPP\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,5 @@\n+\n+  msg.debug(\"Class CP entries = %d, archived = %d (%3.1f%%)\",\n+            _num_klass_cp_entries, _num_klass_cp_entries_archived,\n+            percent_of(_num_klass_cp_entries_archived, _num_klass_cp_entries));\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,3 @@\n+  int _num_klass_cp_entries;\n+  int _num_klass_cp_entries_archived;\n+\n@@ -74,0 +77,2 @@\n+    _num_klass_cp_entries = 0;\n+    _num_klass_cp_entries_archived = 0;\n@@ -100,0 +105,5 @@\n+  void record_klass_cp_entry(bool archived) {\n+    _num_klass_cp_entries ++;\n+    _num_klass_cp_entries_archived += archived ? 1 : 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"cds\/classPrelinker.hpp\"\n@@ -635,7 +636,1 @@\n-\n-  if (DumpSharedSpaces) {\n-    \/\/ The following function is used to resolve all Strings in the statically\n-    \/\/ dumped classes to archive all the Strings. The archive heap is not supported\n-    \/\/ for the dynamic archive.\n-    ik->constants()->resolve_class_constants(CHECK_(false)); \/\/ may throw OOM when interning strings.\n-  }\n+  ClassPrelinker::current()->dumptime_resolve_constants(ik, CHECK_(false));\n@@ -646,0 +641,2 @@\n+  ClassPrelinker prelinker;\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/classPrelinker.hpp\"\n@@ -302,17 +304,0 @@\n-void ConstantPool::resolve_class_constants(TRAPS) {\n-  assert(DumpSharedSpaces, \"used during dump time only\");\n-  \/\/ The _cache may be NULL if the _pool_holder klass fails verification\n-  \/\/ at dump time due to missing dependencies.\n-  if (cache() == NULL || reference_map() == NULL) {\n-    return; \/\/ nothing to do\n-  }\n-\n-  constantPoolHandle cp(THREAD, this);\n-  for (int index = 1; index < length(); index++) { \/\/ Index 0 is unused\n-    if (tag_at(index).is_string()) {\n-      int cache_index = cp->cp_to_object_index(index);\n-      string_at_impl(cp, index, cache_index, CHECK);\n-    }\n-  }\n-}\n-\n@@ -391,1 +376,1 @@\n-  int num_klasses = 0;\n+  bool archived = false;\n@@ -393,1 +378,2 @@\n-    if (tag_at(index).is_unresolved_klass_in_error()) {\n+    switch (tag_at(index).value()) {\n+    case JVM_CONSTANT_UnresolvedClassInError:\n@@ -395,1 +381,2 @@\n-    } else if (tag_at(index).is_method_handle_in_error()) {\n+      break;\n+    case JVM_CONSTANT_MethodHandleInError:\n@@ -397,1 +384,2 @@\n-    } else if (tag_at(index).is_method_type_in_error()) {\n+      break;\n+    case JVM_CONSTANT_MethodTypeInError:\n@@ -399,1 +387,2 @@\n-    } else if (tag_at(index).is_dynamic_constant_in_error()) {\n+      break;\n+    case JVM_CONSTANT_DynamicInError:\n@@ -401,21 +390,5 @@\n-    }\n-    if (tag_at(index).is_klass()) {\n-      \/\/ This class was resolved as a side effect of executing Java code\n-      \/\/ during dump time. We need to restore it back to an UnresolvedClass,\n-      \/\/ so that the proper class loading and initialization can happen\n-      \/\/ at runtime.\n-      bool clear_it = true;\n-      if (pool_holder()->is_hidden() && index == pool_holder()->this_class_index()) {\n-        \/\/ All references to a hidden class's own field\/methods are through this\n-        \/\/ index. We cannot clear it. See comments in ClassFileParser::fill_instance_klass.\n-        clear_it = false;\n-      }\n-      if (clear_it) {\n-        CPKlassSlot kslot = klass_slot_at(index);\n-        int resolved_klass_index = kslot.resolved_klass_index();\n-        int name_index = kslot.name_index();\n-        assert(tag_at(name_index).is_symbol(), \"sanity\");\n-        resolved_klasses()->at_put(resolved_klass_index, NULL);\n-        tag_at_put(index, JVM_CONSTANT_UnresolvedClass);\n-        assert(klass_name_at(index) == symbol_at(name_index), \"sanity\");\n-      }\n+      break;\n+    case JVM_CONSTANT_Class:\n+      archived = maybe_archive_resolved_klass_at(index);\n+      ArchiveBuilder::alloc_stats()->record_klass_cp_entry(archived);\n+      break;\n@@ -424,0 +397,1 @@\n+\n@@ -429,0 +403,36 @@\n+\n+bool ConstantPool::maybe_archive_resolved_klass_at(int cp_index) {\n+  assert(ArchiveBuilder::current()->is_in_buffer_space(this), \"must be\");\n+  assert(tag_at(cp_index).is_klass(), \"must be resolved\");\n+\n+  if (pool_holder()->is_hidden() && cp_index == pool_holder()->this_class_index()) {\n+    \/\/ All references to a hidden class's own field\/methods are through this\n+    \/\/ index, which was resolved in ClassFileParser::fill_instance_klass. We\n+    \/\/ must preserve it.\n+    return true;\n+  }\n+\n+  CPKlassSlot kslot = klass_slot_at(cp_index);\n+  int resolved_klass_index = kslot.resolved_klass_index();\n+  Klass* k = resolved_klasses()->at(resolved_klass_index);\n+  \/\/ k could be NULL if the referenced class has been excluded via\n+  \/\/ SystemDictionaryShared::is_excluded_class().\n+\n+  if (k != NULL) {\n+    ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(this);\n+    if (ClassPrelinker::current()->can_archive_resolved_klass(src_cp, cp_index)) {\n+      if (log_is_enabled(Debug, cds, resolve)) {\n+        ResourceMark rm;\n+        log_debug(cds, resolve)(\"Resolved klass CP entry [%d]: %s => %s\", cp_index,\n+                                pool_holder()->external_name(), k->external_name());\n+      }\n+      return true;\n+    }\n+  }\n+\n+  \/\/ This referenced class cannot be archived. Revert the tag to UnresolvedClass,\n+  \/\/ so that the proper class loading and initialization can happen at runtime.\n+  resolved_klasses()->at_put(resolved_klass_index, NULL);\n+  tag_at_put(cp_index, JVM_CONSTANT_UnresolvedClass);\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":53,"deletions":43,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+  friend class ClassPrelinker;       \/\/ CDS\n@@ -698,1 +699,1 @@\n-  void resolve_class_constants(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n+  bool maybe_archive_resolved_klass_at(int cp_index);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}