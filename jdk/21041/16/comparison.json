{"files":[{"patch":"@@ -244,2 +244,2 @@\n- * All native linker implementations support a well-defined subset of layouts. More formally,\n- * a layout {@code L} is supported by a native linker {@code NL} if:\n+ * A native linker only supports function descriptors whose argument\/return layouts are\n+ * <em>well-formed<\/em> layouts. More formally, a layout `L` is well-formed if:\n@@ -247,1 +247,2 @@\n- * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is a canonical layout<\/li>\n+ * <li>{@code L} is a value layout and {@code L} is derived from a canonical layout\n+ *     {@code C} such that {@code L.byteAlignment() <= C.byteAlignment()}<\/li>\n@@ -250,3 +251,3 @@\n- * <li>the alignment constraint of {@code S} is set to its\n- *     <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>, and<\/li>\n- * <li>{@code S.elementLayout()} is a layout supported by {@code NL}.<\/li>\n+ * <li>{@code L.byteAlignment()} is equal to the sequence layout's <em>natural alignment<\/em>\n+ *     , and<\/li>\n+ * <li>{@code S.elementLayout()} is a well-formed layout.<\/li>\n@@ -257,7 +258,9 @@\n- * <li>the alignment constraint of {@code G} is set to its\n- *     <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>;<\/li>\n- * <li>the size of {@code G} is a multiple of its alignment constraint;<\/li>\n- * <li>each member layout in {@code G.memberLayouts()} is either a padding layout or\n- *     a layout supported by {@code NL}, and<\/li>\n- * <li>{@code G} does not contain padding other than what is strictly required to align\n- *      its non-padding layout elements, or to satisfy (2).<\/li>\n+ * <li>{@code G.byteAlignment()} is equal to the group layout's <em>natural alignment<\/em><\/li>\n+ * <li>{@code G.byteSize()} is a multiple of {@code G.byteAlignment()}<\/li>\n+ * <li>Each member layout in {@code G.memberLayouts()} is either a padding layout or a\n+ *     well-formed layout<\/li>\n+ * <li>Each non-padding member layout {@code E} in {@code G.memberLayouts()} follows an\n+ *     optional padding member layout, whose size is the minimum size required to\n+ *     align {@code E}<\/li>\n+ * <li>{@code G} contains an optional trailing padding member layout, whose size is the\n+ *     minimum size that satisfies (2)<\/li>\n@@ -267,18 +270,0 @@\n- *\n- * Linker implementations may optionally support additional layouts, such as\n- * <em>packed<\/em> struct layouts. A packed struct is a struct in which there is\n- * at least one member layout {@code L} that has an alignment constraint less strict\n- * than its natural alignment. This allows to avoid padding between member layouts,\n- * as well as avoiding padding at the end of the struct layout. For example:\n-\n- * {@snippet lang = java:\n- * \/\/ No padding between the 2 element layouts:\n- * MemoryLayout noFieldPadding = MemoryLayout.structLayout(\n- *         ValueLayout.JAVA_INT,\n- *         ValueLayout.JAVA_DOUBLE.withByteAlignment(4));\n- *\n- * \/\/ No padding at the end of the struct:\n- * MemoryLayout noTrailingPadding = MemoryLayout.structLayout(\n- *         ValueLayout.JAVA_DOUBLE.withByteAlignment(4),\n- *         ValueLayout.JAVA_INT);\n- * }\n@@ -286,2 +271,7 @@\n- * A native linker only supports function descriptors whose argument\/return layouts are\n- * layouts supported by that linker and are not sequence layouts.\n+ * A function descriptor is well-formed if its argument and return layouts are\n+ * well-formed and are not sequence layouts. A native linker is guaranteed to reject\n+ * function descriptors that are not well-formed. However, a native linker can still\n+ * reject well-formed function descriptors, according to platform-specific rules.\n+ * For example, some native linkers may reject <em>packed<\/em> struct layouts -- struct\n+ * layouts whose member layouts feature relaxed alignment constraints, to avoid\n+ * the insertion of additional padding.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":23,"deletions":33,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-import java.nio.ByteOrder;\n@@ -192,0 +191,1 @@\n+            PaddingLayout preceedingPadding = null;\n@@ -199,1 +199,1 @@\n-                if (!(member instanceof PaddingLayout)) {\n+                if (!(member instanceof PaddingLayout pl)) {\n@@ -201,0 +201,10 @@\n+                    if (preceedingPadding != null) {\n+                        preceedingPadding = null;\n+                    }\n+                } else {\n+                    if (preceedingPadding != null) {\n+                        throw new IllegalArgumentException(\"The padding layout \" + pl +\n+                                \" was preceded by another padding layout \" + preceedingPadding +\n+                                inMessage(sl));\n+                    }\n+                    preceedingPadding = pl;\n@@ -203,1 +213,2 @@\n-            checkGroupSize(sl, lastUnpaddedOffset);\n+            checkNotAllPadding(sl);\n+            checkGroup(sl, lastUnpaddedOffset);\n@@ -209,1 +220,1 @@\n-                if (!(member instanceof PaddingLayout)) {\n+                if (!(member instanceof PaddingLayout pl)) {\n@@ -211,0 +222,4 @@\n+                } else {\n+                    if (pl.byteSize() != ul.byteSize()) {\n+                        throw new IllegalArgumentException(\"Superfluous padding \" + pl + inMessage(ul));\n+                    }\n@@ -213,1 +228,1 @@\n-            checkGroupSize(ul, maxUnpaddedLayout);\n+            checkGroup(ul, maxUnpaddedLayout);\n@@ -216,0 +231,4 @@\n+            if (sl.elementLayout() instanceof PaddingLayout pl) {\n+                throw memberException(sl, pl,\n+                        \"not supported because a sequence of a padding layout is not allowed\");\n+            }\n@@ -220,2 +239,9 @@\n-    \/\/ check for trailing padding\n-    private void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n+    \/\/ check elements are not all padding layouts\n+    private static void checkNotAllPadding(StructLayout sl) {\n+        if (!sl.memberLayouts().isEmpty() && sl.memberLayouts().stream().allMatch(e -> e instanceof PaddingLayout)) {\n+            throw new IllegalArgumentException(\"Layout '\" + sl + \"' is non-empty and only has padding layouts\");\n+        }\n+    }\n+\n+    \/\/ check trailing padding\n+    private static void checkGroup(GroupLayout gl, long maxUnpaddedOffset) {\n@@ -229,0 +255,4 @@\n+    private static String inMessage(GroupLayout gl) {\n+        return \" in \" + gl;\n+    }\n+\n@@ -231,1 +261,1 @@\n-    private void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n+    private static void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n@@ -235,2 +265,2 @@\n-            throw new IllegalArgumentException(\"Member layout '\" + memberLayout + \"', of '\" + parent + \"'\" +\n-                    \" found at unexpected offset: \" + offset + \" != \" + expectedOffset);\n+            throw memberException(parent, memberLayout,\n+                    \"found at unexpected offset: \" + offset + \" != \" + expectedOffset);\n@@ -240,0 +270,7 @@\n+    private static IllegalArgumentException memberException(MemoryLayout parent,\n+                                                            MemoryLayout member,\n+                                                            String info) {\n+        return new IllegalArgumentException(\n+                \"Member layout '\" + member + \"', of '\" + parent + \"' \" + info);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.SequenceLayout;\n+import java.lang.foreign.StructLayout;\n@@ -45,6 +48,2 @@\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-import static org.testng.Assert.assertNotNull;\n-import static org.testng.Assert.assertSame;\n-import static org.testng.Assert.assertNotSame;\n-import static org.testng.Assert.assertTrue;\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n@@ -153,0 +152,73 @@\n+    @Test\n+    public void embeddedPaddingLayout() {\n+        PaddingLayout padding = MemoryLayout.paddingLayout(64).withByteAlignment(64);\n+        SequenceLayout sequence = MemoryLayout.sequenceLayout(2, padding);\n+        StructLayout struct = MemoryLayout.structLayout(sequence);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct, struct);\n+        Linker linker = Linker.nativeLinker();\n+        var x = expectThrows(IllegalArgumentException.class, () -> linker.downcallHandle(fd));\n+        assertTrue(x.getMessage().contains(\"not supported because a sequence of a padding layout is not allowed\"));\n+    }\n+\n+    @Test\n+    public void groupLayoutWithOnlyPadding() {\n+        PaddingLayout padding = MemoryLayout.paddingLayout(1);\n+        StructLayout struct = MemoryLayout.structLayout(padding);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct, struct);\n+        Linker linker = Linker.nativeLinker();\n+        var x = expectThrows(IllegalArgumentException.class, () -> linker.downcallHandle(fd));\n+        assertTrue(x.getMessage().contains(\"is non-empty and only has padding layouts\"));\n+    }\n+\n+    @Test\n+    public void interwovenPadding() {\n+        Linker linker = Linker.nativeLinker();\n+        var padding1 = MemoryLayout.paddingLayout(1);\n+        var padding2 = MemoryLayout.paddingLayout(2).withByteAlignment(2);\n+\n+        var struct = MemoryLayout.structLayout(JAVA_BYTE, padding1, padding2, JAVA_INT);\n+\n+        var fd = FunctionDescriptor.of(struct, struct, struct);\n+        var e = expectThrows(IllegalArgumentException.class, () -> linker.downcallHandle(fd));\n+        assertEquals(e.getMessage(),\n+                \"The padding layout x2 was preceded by another padding layout x1 in [b1x1x2i4]\");\n+    }\n+\n+    @Test\n+    public void stackedPadding() {\n+        Linker linker = Linker.nativeLinker();\n+        var struct32 = MemoryLayout.structLayout(MemoryLayout.sequenceLayout(4, JAVA_LONG));\n+        var padding1 = MemoryLayout.paddingLayout(1);\n+        var padding2 = MemoryLayout.paddingLayout(2).withByteAlignment(2);\n+        var padding4 = MemoryLayout.paddingLayout(4).withByteAlignment(4);\n+        var padding8 = MemoryLayout.paddingLayout(8).withByteAlignment(8);\n+        var padding16 = MemoryLayout.paddingLayout(16).withByteAlignment(16);\n+        var padding32 = MemoryLayout.paddingLayout(32).withByteAlignment(32);\n+        var union = MemoryLayout.unionLayout(struct32, padding32);\n+        var struct = MemoryLayout.structLayout(JAVA_BYTE, padding1, padding2, padding4, padding8, padding16, union);\n+        var fd = FunctionDescriptor.of(struct, struct, struct);\n+        var e = expectThrows(IllegalArgumentException.class, () -> linker.downcallHandle(fd));\n+        assertEquals(e.getMessage(),\n+                \"The padding layout x2 was preceded by another padding layout x1 in [b1x1x2x4x8x16[[[4:j8]]|x32]]\");\n+    }\n+\n+    @Test\n+    public void paddingUnion() {\n+        Linker linker = Linker.nativeLinker();\n+        var union = MemoryLayout.unionLayout(MemoryLayout.paddingLayout(3), ValueLayout.JAVA_INT);\n+        var fd = FunctionDescriptor.of(union, union, union);\n+        var e = expectThrows(IllegalArgumentException.class, () -> linker.downcallHandle(fd));\n+        assertEquals(e.getMessage(), \"Superfluous padding x3 in [x3|i4]\");\n+    }\n+\n+    @Test\n+    public void sequenceOfZeroElements() {\n+        Linker linker = Linker.nativeLinker();\n+        var sequence0a8 = MemoryLayout.sequenceLayout(0, JAVA_LONG);\n+        var sequence3a1 = MemoryLayout.sequenceLayout(3, JAVA_BYTE);\n+        var padding5a1 = MemoryLayout.paddingLayout(5);\n+        var struct8a8 = MemoryLayout.structLayout(sequence0a8, sequence3a1, padding5a1);\n+        var fd = FunctionDescriptor.of(struct8a8, struct8a8, struct8a8);\n+        linker.downcallHandle(fd);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":78,"deletions":6,"binary":false,"changes":84,"status":"modified"}]}