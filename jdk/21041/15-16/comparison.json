{"files":[{"patch":"@@ -253,1 +253,1 @@\n- * <li>{@code S.elementLayout()} is a well-defined layout.<\/li>\n+ * <li>{@code S.elementLayout()} is a well-formed layout.<\/li>\n@@ -261,1 +261,1 @@\n- *     well-defined layout<\/li>\n+ *     well-formed layout<\/li>\n@@ -271,21 +271,7 @@\n- * Well-formed layouts in function descriptions consumed by a native linker constitute\n- * a necessary, but not sufficient, requirement for acceptance. For example, some\n- * native linkers may reject <em>packed<\/em> struct layouts. A packed struct is a struct\n- * in which there is at least one member layout {@code L} that has an alignment constraint\n- * less strict than its natural alignment. This allows padding between member layouts and\n- * padding at the end to be avoided in struct layouts.\n- * For example:\n-  * {@snippet lang = java:\n- * \/\/ No padding between the 2 element layouts:\n- * MemoryLayout noFieldPadding = MemoryLayout.structLayout(\n- *         ValueLayout.JAVA_INT,\n- *         ValueLayout.JAVA_DOUBLE.withByteAlignment(4));\n- *\n- * \/\/ No padding at the end of the struct:\n- * MemoryLayout noTrailingPadding = MemoryLayout.structLayout(\n- *         ValueLayout.JAVA_DOUBLE.withByteAlignment(4),\n- *         ValueLayout.JAVA_INT);\n- * }\n- * <p>\n- * A native linker only supports function descriptors whose argument\/return layouts are\n- * layouts supported by that linker and are not sequence layouts.\n+ * A function descriptor is well-formed if its argument and return layouts are\n+ * well-formed and are not sequence layouts. A native linker is guaranteed to reject\n+ * function descriptors that are not well-formed. However, a native linker can still\n+ * reject well-formed function descriptors, according to platform-specific rules.\n+ * For example, some native linkers may reject <em>packed<\/em> struct layouts -- struct\n+ * layouts whose member layouts feature relaxed alignment constraints, to avoid\n+ * the insertion of additional padding.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -202,1 +202,0 @@\n-                        assertIsAlignedBy(sl, preceedingPadding, member);\n@@ -256,8 +255,0 @@\n-    private static void assertIsAlignedBy(StructLayout gl, PaddingLayout padding, MemoryLayout element) {\n-        if (padding.byteSize() > element.byteAlignment()) {\n-            throw new IllegalArgumentException(\"The padding layout \" + padding +\n-                    \" is not of minimum size to align \" + element +\n-                    \"(with byte alignment \" + element.byteAlignment() + \")\" + inMessage(gl));\n-        }\n-    }\n-\n@@ -265,3 +256,1 @@\n-        return gl != null\n-                ? \" in \" + gl\n-                : \"\";\n+        return \" in \" + gl;\n@@ -270,1 +259,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"}]}