{"files":[{"patch":"@@ -224,1 +224,25 @@\n-    private void checkGroup(GroupLayout gl, long maxUnpaddedOffset) {\n+    static private void checkGroup(GroupLayout gl, long maxUnpaddedOffset) {\n+        PaddingLayout preceedingPadding = null;\n+        List<MemoryLayout> memberLayouts = gl.memberLayouts();\n+        for (int i = 0; i < memberLayouts.size(); i++) {\n+            MemoryLayout current = memberLayouts.get(i);\n+            if (current instanceof PaddingLayout pl) {\n+                if (preceedingPadding != null) {\n+                    throw new IllegalArgumentException(\"The padding layout \" + pl +\n+                            \" was preceded by another padding layout \" + preceedingPadding +\n+                            inMessage(gl));\n+                }\n+                preceedingPadding = pl;\n+            } else {\n+                if (preceedingPadding != null) {\n+                    assertIsAlignedBy(gl, i, preceedingPadding, current);\n+                    preceedingPadding = null;\n+                }\n+            }\n+        }\n+        \/\/ Check an optional trailing padding in a struct layout used to align any previous members\n+        if (gl instanceof StructLayout && (gl.memberLayouts().size() > 1) &&\n+                gl.memberLayouts().getLast() instanceof PaddingLayout pl) {\n+            assertIsAlignedBy(null, 0, pl, gl);\n+        }\n+\n@@ -235,0 +259,21 @@\n+    static void assertIsAlignedBy(GroupLayout gl, long index, PaddingLayout padding, MemoryLayout element) {\n+        if (padding.byteSize() > element.byteAlignment()) {\n+            throw new IllegalArgumentException(\"The padding layout \" + padding +\n+                    \" is not of minimum size to align \" + element +\n+                    \"(with byte alignment \" + element.byteAlignment() + \")\" + inMessage(gl));\n+        }\n+        long pos = (gl != null) ? gl.byteOffset(MemoryLayout.PathElement.groupElement(index)) : 0;\n+        if (!Utils.isAligned(pos, element.byteAlignment())) {\n+            throw new IllegalArgumentException(\"The padding layout \" + padding +\n+                    \" does not align the element \" + element +\n+                    \" (at byte offset \" + pos + \")\" + inMessage(gl));\n+        }\n+    }\n+\n+    static String inMessage(GroupLayout gl) {\n+        return gl != null\n+                ? \" in \" + gl\n+                : \"\";\n+    }\n+\n+\n@@ -237,1 +282,1 @@\n-    private void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n+    static private void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":47,"deletions":2,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -49,7 +49,2 @@\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-import static org.testng.Assert.assertNotNull;\n-import static org.testng.Assert.assertSame;\n-import static org.testng.Assert.assertNotSame;\n-import static org.testng.Assert.assertTrue;\n-import static org.testng.Assert.expectThrows;\n+import static java.lang.foreign.ValueLayout.*;\n+import static org.testng.Assert.*;\n@@ -179,0 +174,39 @@\n+    @Test\n+    public void interwovenPadding() {\n+        Linker linker = Linker.nativeLinker();\n+        var padding1 = MemoryLayout.paddingLayout(1);\n+        var padding2 = MemoryLayout.paddingLayout(2).withByteAlignment(2);\n+\n+        var struct = MemoryLayout.structLayout(JAVA_BYTE, padding1, padding2, JAVA_INT);\n+\n+        var fd = FunctionDescriptor.of(struct, struct, struct);\n+        assertThrows(IllegalArgumentException.class, () ->linker.downcallHandle(fd));\n+    }\n+\n+    @Test\n+    public void stackedPadding() {\n+        Linker linker = Linker.nativeLinker();\n+        var struct32 = MemoryLayout.structLayout(MemoryLayout.sequenceLayout(4, JAVA_LONG));\n+        var padding1 = MemoryLayout.paddingLayout(1);\n+        var padding2 = MemoryLayout.paddingLayout(2).withByteAlignment(2);\n+        var padding4 = MemoryLayout.paddingLayout(4).withByteAlignment(4);\n+        var padding8 = MemoryLayout.paddingLayout(8).withByteAlignment(8);\n+        var padding16 = MemoryLayout.paddingLayout(16).withByteAlignment(16);\n+        var padding32 = MemoryLayout.paddingLayout(32).withByteAlignment(32);\n+        var union = MemoryLayout.unionLayout(struct32, padding32);\n+        var struct = MemoryLayout.structLayout(JAVA_BYTE, padding1, padding2, padding4, padding8, padding16, union);\n+        var fd = FunctionDescriptor.of(struct, struct, struct);\n+        assertThrows(IllegalArgumentException.class, () -> linker.downcallHandle(fd));\n+    }\n+\n+    @Test\n+    public void sequenceOfZeroElements() {\n+        Linker linker = Linker.nativeLinker();\n+        var sequence0a8 = MemoryLayout.sequenceLayout(0, JAVA_LONG);\n+        var sequence3a1 = MemoryLayout.sequenceLayout(3, JAVA_BYTE);\n+        var padding5a1 = MemoryLayout.paddingLayout(5);\n+        var struct8a8 = MemoryLayout.structLayout(sequence0a8, sequence3a1, padding5a1);\n+        var fd = FunctionDescriptor.of(struct8a8, struct8a8, struct8a8);\n+        linker.downcallHandle(fd);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":41,"deletions":7,"binary":false,"changes":48,"status":"modified"}]}