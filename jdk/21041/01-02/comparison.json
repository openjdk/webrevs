{"files":[{"patch":"@@ -202,1 +202,1 @@\n-            checkGroupSize(sl, lastUnpaddedOffset);\n+            checkGroup(sl, lastUnpaddedOffset);\n@@ -212,1 +212,1 @@\n-            checkGroupSize(ul, maxUnpaddedLayout);\n+            checkGroup(ul, maxUnpaddedLayout);\n@@ -223,2 +223,5 @@\n-    \/\/ check for trailing padding\n-    private void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n+    \/\/ check elements are not all padding layouts and for trailing padding\n+    private void checkGroup(GroupLayout gl, long maxUnpaddedOffset) {\n+        if (gl.memberLayouts().stream().allMatch(e -> e instanceof PaddingLayout)) {\n+            throw new IllegalArgumentException(\"Layout '\" + gl + \"' only has padding layouts\");\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -169,0 +169,10 @@\n+    @Test\n+    public void groupLayoutWithOnlyPadding() {\n+        PaddingLayout padding = MemoryLayout.paddingLayout(1);\n+        StructLayout struct = MemoryLayout.structLayout(padding);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct, struct);\n+        Linker linker = Linker.nativeLinker();\n+        var x = expectThrows(IllegalArgumentException.class, () -> linker.downcallHandle(fd));\n+        assertTrue(x.getMessage().contains(\"only has padding layouts\"));\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}