{"files":[{"patch":"@@ -863,4 +863,1 @@\n-    int lgrp_id = os::numa_get_group_id();\n-    if (lgrp_id != -1) {\n-      thread->set_lgrp_id(lgrp_id);\n-    }\n+    thread->update_lgrp_id();\n@@ -868,0 +865,1 @@\n+\n@@ -1194,4 +1192,1 @@\n-    int lgrp_id = os::numa_get_group_id();\n-    if (lgrp_id != -1) {\n-      thread->set_lgrp_id(lgrp_id);\n-    }\n+    thread->update_lgrp_id();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,0 @@\n-\/\/ Aix does not have NUMA support but need these for compilation.\n-inline bool os::numa_has_group_homing()     { AIX_ONLY(ShouldNotReachHere();) return false;  }\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -537,7 +537,0 @@\n-  if (UseNUMA) {\n-    int lgrp_id = os::numa_get_group_id();\n-    if (lgrp_id != -1) {\n-      thread->set_lgrp_id(lgrp_id);\n-    }\n-  }\n-\n@@ -601,7 +594,0 @@\n-  if (UseNUMA) {\n-    int lgrp_id = os::numa_get_group_id();\n-    if (lgrp_id != -1) {\n-      thread->set_lgrp_id(lgrp_id);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,2 +65,0 @@\n-inline bool os::numa_has_group_homing()     { return false;  }\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -121,3 +121,8 @@\n-int MutableNUMASpace::lgrp_space_index(int lgrp_id) const {\n-  return lgrp_spaces()->find_if([&](LGRPSpace* space) {\n-    return space->lgrp_id() == checked_cast<uint>(lgrp_id);\n+MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_thread(Thread* thr) const {\n+  guarantee(thr != nullptr, \"No thread\");\n+\n+  int lgrp_id = thr->lgrp_id();\n+  assert(lgrp_id != -1, \"lgrp_id must be set during thread creation\");\n+\n+  int lgrp_spaces_index = lgrp_spaces()->find_if([&](LGRPSpace* space) {\n+    return space->lgrp_id() == (uint)lgrp_id;\n@@ -125,0 +130,3 @@\n+\n+  assert(lgrp_spaces_index != -1, \"must have created spaces for all lgrp_ids\");\n+  return lgrp_spaces()->at(lgrp_spaces_index);\n@@ -128,21 +136,1 @@\n-  guarantee(thr != nullptr, \"No thread\");\n-  int lgrp_id = thr->lgrp_id();\n-  if (lgrp_id == -1) {\n-    \/\/ This case can occur after the topology of the system has\n-    \/\/ changed. Thread can change their location, the new home\n-    \/\/ group will be determined during the first allocation\n-    \/\/ attempt. For now we can safely assume that all spaces\n-    \/\/ have equal size because the whole space will be reinitialized.\n-    if (lgrp_spaces()->length() > 0) {\n-      return capacity_in_bytes() \/ lgrp_spaces()->length();\n-    } else {\n-      assert(false, \"There should be at least one locality group\");\n-      return 0;\n-    }\n-  }\n-  \/\/ That's the normal case, where we know the locality group of the thread.\n-  int i = lgrp_space_index(lgrp_id);\n-  if (i == -1) {\n-    return 0;\n-  }\n-  return lgrp_spaces()->at(i)->space()->capacity_in_bytes();\n+  return lgrp_space_for_thread(thr)->space()->capacity_in_bytes();\n@@ -152,16 +140,1 @@\n-  \/\/ Please see the comments for tlab_capacity().\n-  guarantee(thr != nullptr, \"No thread\");\n-  int lgrp_id = thr->lgrp_id();\n-  if (lgrp_id == -1) {\n-    if (lgrp_spaces()->length() > 0) {\n-      return (used_in_bytes()) \/ lgrp_spaces()->length();\n-    } else {\n-      assert(false, \"There should be at least one locality group\");\n-      return 0;\n-    }\n-  }\n-  int i = lgrp_space_index(lgrp_id);\n-  if (i == -1) {\n-    return 0;\n-  }\n-  return lgrp_spaces()->at(i)->space()->used_in_bytes();\n+  return lgrp_space_for_thread(thr)->space()->used_in_bytes();\n@@ -170,1 +143,0 @@\n-\n@@ -172,16 +144,1 @@\n-  \/\/ Please see the comments for tlab_capacity().\n-  guarantee(thr != nullptr, \"No thread\");\n-  int lgrp_id = thr->lgrp_id();\n-  if (lgrp_id == -1) {\n-    if (lgrp_spaces()->length() > 0) {\n-      return free_in_bytes() \/ lgrp_spaces()->length();\n-    } else {\n-      assert(false, \"There should be at least one locality group\");\n-      return 0;\n-    }\n-  }\n-  int i = lgrp_space_index(lgrp_id);\n-  if (i == -1) {\n-    return 0;\n-  }\n-  return lgrp_spaces()->at(i)->space()->free_in_bytes();\n+  return lgrp_space_for_thread(thr)->space()->free_in_bytes();\n@@ -531,11 +488,0 @@\n-\/*\n-   Linux supports static memory binding, therefore the most part of the\n-   logic dealing with the possible invalid page allocation is effectively\n-   disabled. Besides there is no notion of the home node in Linux. A\n-   thread is allowed to migrate freely. Although the scheduler is rather\n-   reluctant to move threads between the nodes. We check for the current\n-   node every allocation. And with a high probability a thread stays on\n-   the same node for some time allowing local access to recently allocated\n-   objects.\n- *\/\n-\n@@ -543,6 +489,1 @@\n-  Thread* thr = Thread::current();\n-  int lgrp_id = thr->lgrp_id();\n-  if (lgrp_id == -1 || !os::numa_has_group_homing()) {\n-    lgrp_id = os::numa_get_group_id();\n-    thr->set_lgrp_id(lgrp_id);\n-  }\n+  Thread *thr = Thread::current();\n@@ -550,7 +491,4 @@\n-  int i = lgrp_space_index(lgrp_id);\n-  \/\/ It is possible that a new CPU has been hotplugged and\n-  \/\/ we haven't reshaped the space accordingly.\n-  if (i == -1) {\n-    i = os::random() % lgrp_spaces()->length();\n-  }\n-  LGRPSpace *ls = lgrp_spaces()->at(i);\n+  \/\/ Update the locality group to match where the thread actually is.\n+  thr->update_lgrp_id();\n+\n+  LGRPSpace *ls = lgrp_space_for_thread(thr);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":19,"deletions":81,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-  int lgrp_space_index(int lgrp_id) const;\n+  LGRPSpace *lgrp_space_for_thread(Thread *thr) const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-  assert(result, \"inv\");\n+  assert(result || UseNUMA, \"inv\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -538,1 +538,0 @@\n-  static bool   numa_has_group_homing();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  set_lgrp_id(-1);\n+  _lgrp_id = -1;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -540,2 +540,2 @@\n-  int     lgrp_id() const        { return _lgrp_id; }\n-  void    set_lgrp_id(int value) { _lgrp_id = value; }\n+  int     lgrp_id() const  { return _lgrp_id; }\n+  void    update_lgrp_id() { _lgrp_id = os::numa_get_group_id(); }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}