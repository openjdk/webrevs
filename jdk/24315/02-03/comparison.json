{"files":[{"patch":"@@ -35,0 +35,1 @@\n+ * @modules java.base\/jdk.internal.access\n@@ -41,1 +42,1 @@\n- *    TestNativeReferenceGet\n+ *    gc.TestNativeReferenceGet\n@@ -44,1 +45,0 @@\n-import jdk.test.whitebox.WhiteBox;\n@@ -47,1 +47,0 @@\n-import java.util.List;\n@@ -49,0 +48,4 @@\n+import java.util.List;\n+import jdk.internal.access.JavaLangRefAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.test.whitebox.WhiteBox;\n@@ -119,1 +122,5 @@\n-    private static final long TIMEOUT = 10 * 1000; \/\/ 10 seconds, in millis.\n+    private static void checkQueue() {\n+        if (queue.poll() != null) {\n+            throw new RuntimeException(\"Reference enqueued\");\n+        }\n+    }\n@@ -125,2 +132,3 @@\n-            if (queue.remove(TIMEOUT) != null) {\n-                throw new RuntimeException(\"Reference enqueued\");\n+            JavaLangRefAccess jlra = SharedSecrets.getJavaLangRefAccess();\n+            while (jlra.waitForReferenceProcessing()) {\n+                checkQueue();\n@@ -128,0 +136,1 @@\n+            checkQueue();       \/\/ One last check after refproc complete.\n@@ -163,0 +172,3 @@\n+        \/\/ A GC between clearing and strengthening will result in test failure.\n+        \/\/ We try to make that unlikely via this immediately preceeding GC.\n+        WB.fullGC();\n","filename":"test\/hotspot\/jtreg\/gc\/TestNativeReferenceGet.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"}]}