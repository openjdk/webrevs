{"files":[{"patch":"@@ -2568,3 +2568,1 @@\n-        Class<?> k = ClassLoader.class;\n-        long offset;\n-        offset = unsafe.objectFieldOffset(k, name);\n+        long offset = unsafe.objectFieldOffset(ClassLoader.class, name);\n@@ -2574,0 +2572,13 @@\n+    private void reinitObjectField(String name, Object obj) {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        long offset = unsafe.objectFieldOffset(ClassLoader.class, name);\n+\n+        \/\/ Extra safety: check the types\n+        Object current = unsafe.getReference(this, offset);\n+        if (current.getClass() != obj.getClass()) {\n+            throw new IllegalStateException(\"Wrong field type\");\n+        }\n+\n+        unsafe.putReference(this, offset, obj);\n+    }\n+\n@@ -2575,1 +2586,5 @@\n-     * Called by the VM, during -Xshare:dump\n+     * Called only by the VM, during -Xshare:dump.\n+     *\n+     * @implNote This is done while the JVM is running in single-threaded mode,\n+     * and at the very end of Java bytecode execution. We know that no more classes\n+     * will be loaded and none of the fields modified by this method will be used again.\n@@ -2579,1 +2594,1 @@\n-            parallelLockMap.clear();\n+            reinitObjectField(\"parallelLockMap\", new ConcurrentHashMap<>());\n@@ -2581,2 +2596,2 @@\n-        packages.clear();\n-        package2certs.clear();\n+        reinitObjectField(\"packages\", new ConcurrentHashMap<>());\n+        reinitObjectField(\"package2certs\", new ConcurrentHashMap<>());\n@@ -2584,0 +2599,1 @@\n+        classes.trimToSize();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -452,1 +452,2 @@\n- -runtime\/cds\/appcds\/LotsOfClasses.java \\\n+ -runtime\/cds\/appcds\/LotsOfJRTClasses.java \\\n+ -runtime\/cds\/appcds\/LotsOfSyntheticClasses.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @run driver\/timeout=500 LotsOfClasses\n+ * @run driver\/timeout=500 LotsOfJRTClasses\n@@ -39,1 +39,1 @@\n-public class LotsOfClasses {\n+public class LotsOfJRTClasses {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfJRTClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfClasses.java","status":"renamed"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.Files;\n+\n+import jdk.test.lib.cds.CDSJarUtils;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/*\n+ * @test\n+ * @summary Try to archive lots and lots of classes.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @run driver\/timeout=500 LotsOfSyntheticClasses\n+ *\/\n+\n+public class LotsOfSyntheticClasses {\n+\n+    \/\/ Generate 100 top-level classes, each containing 1000 nested classes.\n+    \/\/ 100K total classes are more than enough to push the CDS limits.\n+    private static final int NUM_CLASSES = 100;\n+    private static final int NUM_NESTED_CLASSES = 1000;\n+\n+    private static final Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n+    private static final Path APP_JAR = USER_DIR.resolve(\"test.jar\");\n+    private static final Path SRC_DIR = USER_DIR.resolve(\"src\");\n+\n+    private static final String TOP_CLASS_NAME = \"Class\";\n+    private static final String NESTED_CLASS_NAME = \"Nested\";\n+    private static final String MAIN_CLASS_NAME = \"Main\";\n+\n+    public static List<String> generateClass(int idx) {\n+        List<String> out = new ArrayList<>();\n+        out.add(\"public class \" + TOP_CLASS_NAME + idx + \" {\");\n+        out.add(\"public \" + TOP_CLASS_NAME + idx + \"() {\");\n+        for (int c = 0; c < NUM_NESTED_CLASSES; c++) {\n+            out.add(\"new \" + NESTED_CLASS_NAME + c + \"();\");\n+        }\n+        out.add(\"}\");\n+        for (int c = 0; c < NUM_NESTED_CLASSES; c++) {\n+            out.add(\"public static class \" + NESTED_CLASS_NAME + c + \" {}\");\n+        }\n+        out.add(\"}\");\n+        return out;\n+    }\n+\n+    public static List<String> generateMainClass() {\n+        List<String> out = new ArrayList<>();\n+        out.add(\"public class \" + MAIN_CLASS_NAME + \" {\");\n+        out.add(\"public static void main(String... args) {\");\n+        for (int c = 0; c < NUM_CLASSES; c++) {\n+            out.add(\"new \" + TOP_CLASS_NAME + c + \"();\");\n+        }\n+        out.add(\"System.out.println(\\\"Success\\\");\");\n+        out.add(\"}\");\n+        out.add(\"}\");\n+        return out;\n+    }\n+\n+    public static String[] listAppClasses() {\n+        String[] res = new String[NUM_CLASSES * NUM_NESTED_CLASSES];\n+        for (int c = 0; c < NUM_CLASSES; c++) {\n+            for (int sc = 0; sc < NUM_NESTED_CLASSES; sc++) {\n+                res[c * NUM_NESTED_CLASSES + sc] = TOP_CLASS_NAME + c + \"$\" + NESTED_CLASS_NAME + sc;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Step 1. Generate classes and build the JAR with them.\n+        {\n+            SRC_DIR.toFile().mkdirs();\n+\n+            for (int i = 0; i < NUM_CLASSES; i++) {\n+                Path file = SRC_DIR.resolve(TOP_CLASS_NAME + i + \".java\");\n+                Files.write(file, generateClass(i));\n+            }\n+\n+            Path mainFile = SRC_DIR.resolve(MAIN_CLASS_NAME + \".java\");\n+            Files.write(mainFile, generateMainClass());\n+\n+            CDSJarUtils.buildFromSourceDirectory(\n+                APP_JAR.toString(),\n+                SRC_DIR.toString()\n+            );\n+        }\n+\n+        \/\/ Step 2. Try to dump the archive.\n+        {\n+            OutputAnalyzer output = TestCommon.createArchive(\n+                APP_JAR.toString(),\n+                listAppClasses(),\n+                MAIN_CLASS_NAME\n+            );\n+            TestCommon.checkDump(output);\n+        }\n+\n+        \/\/ Step 3. Try to run, touching every class.\n+        {\n+            TestCommon.run(\n+                \/\/ Verifying dependencies for lots of classes slows down the test.\n+                \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-VerifyDependencies\",\n+                \"-Xlog:cds\",\n+                \"-cp\", APP_JAR.toString(),\n+                MAIN_CLASS_NAME).\n+                    assertNormalExit(\"Success\");\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LotsOfSyntheticClasses.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}