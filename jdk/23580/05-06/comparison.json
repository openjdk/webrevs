{"files":[{"patch":"@@ -2959,1 +2959,1 @@\n-                                              BasicType bt, uint len, VectorMask vm) {\n+                                              BasicType bt, uint vector_length, VectorMask vm) {\n@@ -2961,1 +2961,1 @@\n-  vsetvli_helper(bt, len);\n+  vsetvli_helper(bt, vector_length);\n@@ -2963,1 +2963,1 @@\n-  len \/= 2;\n+  vector_length \/= 2;\n@@ -2970,1 +2970,1 @@\n-    vslidedown_vi(vtmp1, vtmp2, len);\n+    vslidedown_vi(vtmp1, vtmp2, vector_length);\n@@ -2972,1 +2972,1 @@\n-    vsetvli_helper(bt, len);\n+    vsetvli_helper(bt, vector_length);\n@@ -2975,1 +2975,1 @@\n-    vslidedown_vi(vtmp1, src2, len);\n+    vslidedown_vi(vtmp1, src2, vector_length);\n@@ -2977,1 +2977,1 @@\n-    vsetvli_helper(bt, len);\n+    vsetvli_helper(bt, vector_length);\n@@ -2981,4 +2981,4 @@\n-  while (len > 1) {\n-    len \/= 2;\n-    vslidedown_vi(vtmp2, vtmp1, len);\n-    vsetvli_helper(bt, len);\n+  while (vector_length > 1) {\n+    vector_length \/= 2;\n+    vslidedown_vi(vtmp2, vtmp1, vector_length);\n+    vsetvli_helper(bt, vector_length);\n@@ -2996,45 +2996,0 @@\n-void C2_MacroAssembler::reduce_mul_fp_v(FloatRegister dst, FloatRegister src1, VectorRegister src2,\n-                                        VectorRegister vtmp1, VectorRegister vtmp2,\n-                                        BasicType bt, uint len, VectorMask vm) {\n-  assert(bt == T_FLOAT || bt == T_DOUBLE, \"unsupported element type\");\n-  vsetvli_helper(bt, len);\n-\n-  len \/= 2;\n-  if (vm != Assembler::unmasked) {\n-    \/\/ This behaviour is consistent with spec requirements of vector API, for `reduceLanes`:\n-    \/\/  If no elements are selected, an operation-specific identity value is returned.\n-    \/\/    If the operation is MUL, then the identity value is one.\n-    if (bt == T_FLOAT) {\n-      mv(t0, 0x3f800000); \/\/ 1.0f\n-    } else {\n-      mv(t0, 0x3ff00000); \/\/ 1.0d\n-      slli(t0, t0, 32);\n-    }\n-    vmv_v_x(vtmp1, t0);\n-    vmerge_vvm(vtmp2, vtmp1, src2); \/\/ vm == v0\n-    vslidedown_vi(vtmp1, vtmp2, len);\n-\n-    vsetvli_helper(bt, len);\n-    vfmul_vv(vtmp1, vtmp1, vtmp2);\n-  } else {\n-    vslidedown_vi(vtmp1, src2, len);\n-\n-    vsetvli_helper(bt, len);\n-    vfmul_vv(vtmp1, vtmp1, src2);\n-  }\n-\n-  while (len > 1) {\n-    len \/= 2;\n-    vslidedown_vi(vtmp2, vtmp1, len);\n-    vsetvli_helper(bt, len);\n-    vfmul_vv(vtmp1, vtmp1, vtmp2);\n-  }\n-\n-  vfmv_f_s(dst, vtmp1);\n-  if (bt == T_FLOAT) {\n-    fmul_s(dst, dst, src1);\n-  } else {\n-    fmul_d(dst, dst, src1);\n-  }\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":11,"deletions":56,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -244,5 +244,1 @@\n-                             uint len, VectorMask vm = Assembler::unmasked);\n-\n-  void reduce_mul_fp_v(FloatRegister dst, FloatRegister src1, VectorRegister src2,\n-                       VectorRegister vtmp1, VectorRegister vtmp2, BasicType bt,\n-                       uint len, VectorMask vm = Assembler::unmasked);\n+                             uint vector_length, VectorMask vm = Assembler::unmasked);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,2 +105,0 @@\n-      case Op_MulReductionVF:\n-      case Op_MulReductionVD:\n@@ -2493,67 +2491,0 @@\n-\/\/ Floating-point addition and multiplication are non-associative, so\n-\/\/ AddReductionVF\/D and MulReductionVF\/D require strict ordering\n-\/\/ in auto-vectorization. Vector API can generate AddReductionVF\/D\n-\/\/ and MulReductionVF\/VD without strict ordering, which can benefit\n-\/\/ some platforms.\n-instruct reduce_mulF_unordered(fRegF dst, fRegF fsrc, vReg vsrc,\n-                     vReg tmp1, vReg tmp2) %{\n-  predicate(!n->as_Reduction()->requires_strict_order());\n-  match(Set dst (MulReductionVF fsrc vsrc));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n-  format %{ \"reduce_mulF_unordered $dst, $fsrc, $vsrc\\t\" %}\n-\n-  ins_encode %{\n-    __ reduce_mul_fp_v($dst$$FloatRegister, $fsrc$$FloatRegister, as_VectorRegister($vsrc$$reg),\n-                       as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n-                       Matcher::vector_element_basic_type(this, $vsrc), Matcher::vector_length(this, $vsrc));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mulF_masked_unordered(fRegF dst, fRegF fsrc, vReg vsrc,\n-                            vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n-  predicate(!n->as_Reduction()->requires_strict_order());\n-  match(Set dst (MulReductionVF (Binary fsrc vsrc) v0));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n-  format %{ \"reduce_mulF_masked_unordered $dst, $fsrc, $vsrc, $v0\\t\" %}\n-\n-  ins_encode %{\n-    __ reduce_mul_fp_v($dst$$FloatRegister, $fsrc$$FloatRegister, as_VectorRegister($vsrc$$reg),\n-                       as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n-                       Matcher::vector_element_basic_type(this, $vsrc), Matcher::vector_length(this, $vsrc),\n-                       Assembler::v0_t);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mulD_unordered(fRegD dst, fRegD fsrc, vReg vsrc,\n-                     vReg tmp1, vReg tmp2) %{\n-  predicate(!n->as_Reduction()->requires_strict_order());\n-  match(Set dst (MulReductionVD fsrc vsrc));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n-  format %{ \"reduce_mulD_unordered $dst, $fsrc, $vsrc\\t\" %}\n-\n-  ins_encode %{\n-    __ reduce_mul_fp_v($dst$$FloatRegister, $fsrc$$FloatRegister, as_VectorRegister($vsrc$$reg),\n-                       as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n-                       Matcher::vector_element_basic_type(this, $vsrc), Matcher::vector_length(this, $vsrc));\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct reduce_mulD_masked_unordered(fRegD dst, fRegD fsrc, vReg vsrc,\n-                            vRegMask_V0 v0, vReg tmp1, vReg tmp2) %{\n-  predicate(!n->as_Reduction()->requires_strict_order());\n-  match(Set dst (MulReductionVD (Binary fsrc vsrc) v0));\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP tmp2);\n-  format %{ \"reduce_mulD_masked_unordered $dst, $fsrc, $vsrc, $v0\\t\" %}\n-\n-  ins_encode %{\n-    __ reduce_mul_fp_v($dst$$FloatRegister, $fsrc$$FloatRegister, as_VectorRegister($vsrc$$reg),\n-                       as_VectorRegister($tmp1$$reg), as_VectorRegister($tmp2$$reg),\n-                       Matcher::vector_element_basic_type(this, $vsrc), Matcher::vector_length(this, $vsrc),\n-                       Assembler::v0_t);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":0,"deletions":69,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,4 +91,0 @@\n-    @IR(applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n-        applyIfPlatform = {\"riscv64\", \"true\"},\n-        applyIfCPUFeature = {\"rvv\", \"true\"},\n-        counts = {IRNode.MUL_REDUCTION_VD, \">= 1\"})\n@@ -108,4 +104,0 @@\n-    @IR(applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n-        applyIfPlatform = {\"riscv64\", \"true\"},\n-        applyIfCPUFeature = {\"rvv\", \"true\"},\n-        counts = {IRNode.MUL_REDUCTION_VD, \">= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Double.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,4 +89,0 @@\n-    @IR(applyIfAnd = {\"SuperWordReductions\", \"true\", \"LoopMaxUnroll\", \">= 8\"},\n-        applyIfPlatform = {\"riscv64\", \"true\"},\n-        applyIfCPUFeature = {\"rvv\", \"true\"},\n-        counts = {IRNode.MUL_REDUCTION_VF, \">= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/ProdRed_Float.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}