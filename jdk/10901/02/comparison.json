{"files":[{"patch":"@@ -29,1 +29,2 @@\n-#include \"ci\/ciUtilities.hpp\"\n+#include \"ci\/ciUtilities.inline.hpp\"\n+#include \"memory\/universe.hpp\"\n@@ -106,0 +107,14 @@\n+\n+GrowableArray<ciInstanceKlass*>* ciArrayKlass::interfaces() {\n+  GrowableArray<ciInstanceKlass*>* result = NULL;\n+  GUARDED_VM_ENTRY(\n+    Array<Klass*>* interfaces = Universe::the_array_interfaces_array();\n+    result = new GrowableArray<ciInstanceKlass*>(interfaces->length());\n+    for (int i = 0; i < interfaces->length(); i++) {\n+      ciInstanceKlass* interface = CURRENT_ENV->get_instance_klass(interfaces->at(i));\n+      assert(!CURRENT_ENV->arena()->contains(interfaces), \"should be shareable\");\n+      result->append(interface);\n+    }\n+  );\n+  return result;\n+}\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+\n+  static GrowableArray<ciInstanceKlass*>* interfaces();\n","filename":"src\/hotspot\/share\/ci\/ciArrayKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  _transitive_interfaces = NULL;\n@@ -732,0 +733,20 @@\n+GrowableArray<ciInstanceKlass*>* ciInstanceKlass::transitive_interfaces() {\n+  if (_transitive_interfaces == NULL) {\n+    GUARDED_VM_ENTRY(\n+            InstanceKlass* ik = get_instanceKlass();\n+            Array<InstanceKlass*>* interfaces = ik->transitive_interfaces();\n+            Arena* arena = CURRENT_ENV->arena();\n+            int len = interfaces->length() + (is_interface() ? 1 : 0);\n+            GrowableArray<ciInstanceKlass*>* transitive_interfaces = new (arena)GrowableArray<ciInstanceKlass*>(arena, len, 0, NULL);\n+            for (int i = 0; i < interfaces->length(); i++) {\n+              transitive_interfaces->append(CURRENT_ENV->get_instance_klass(interfaces->at(i)));\n+            }\n+            if (is_interface()) {\n+              transitive_interfaces->append(this);\n+            }\n+            _transitive_interfaces = transitive_interfaces;\n+    );\n+  }\n+  return _transitive_interfaces;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  GrowableArray<ciInstanceKlass*>* _transitive_interfaces;\n@@ -295,0 +296,1 @@\n+  GrowableArray<ciInstanceKlass*>* transitive_interfaces();\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -156,3 +156,11 @@\n-#define VM_CLASS_DEFN(name, ignore_s)                              \\\n-  if (vmClasses::name##_is_loaded()) \\\n-    ciEnv::_##name = get_metadata(vmClasses::name())->as_instance_klass();\n+  \/\/ ciInstanceKlass objects for interfaces that the vm class implements must also be allocated from the long lived arena\n+#define VM_CLASS_DEFN(name, ignore_s)                                \\\n+  if (vmClasses::name##_is_loaded()) {                               \\\n+    InstanceKlass* ik = vmClasses::name();                           \\\n+    ciEnv::_##name = get_metadata(ik)->as_instance_klass();          \\\n+    Array<InstanceKlass*>* interfaces = ik->transitive_interfaces(); \\\n+    for (int i = 0; i < interfaces->length(); i++) {                 \\\n+      InstanceKlass* interface = interfaces->at(i);                  \\\n+      get_metadata(interface);                                       \\\n+    }                                                                \\\n+  }\n@@ -170,0 +178,1 @@\n+        obj->as_instance_klass()->transitive_interfaces();\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -406,2 +406,6 @@\n-  const TypePtr *in_type   = inn->isa_ptr();\n-  const TypePtr *my_type   = _type->isa_ptr();\n+  if (inn->isa_oopptr() && _type->isa_oopptr()) {\n+    return ConstraintCastNode::Value(phase);\n+  }\n+\n+  const TypePtr *in_type = inn->isa_ptr();\n+  const TypePtr *my_type = _type->isa_ptr();\n@@ -409,2 +413,2 @@\n-  if( in_type != NULL && my_type != NULL ) {\n-    TypePtr::PTR   in_ptr    = in_type->ptr();\n+  if (in_type != NULL && my_type != NULL) {\n+    TypePtr::PTR in_ptr = in_type->ptr();\n@@ -413,10 +417,0 @@\n-    } else if (in_ptr == TypePtr::Constant) {\n-      if (my_type->isa_rawptr()) {\n-        result = my_type;\n-      } else {\n-        const TypeOopPtr *jptr = my_type->isa_oopptr();\n-        assert(jptr, \"\");\n-        result = !in_type->higher_equal(_type)\n-          ? my_type->cast_to_ptr_type(TypePtr::NotNull)\n-          : in_type;\n-      }\n@@ -424,1 +418,1 @@\n-      result =  my_type->cast_to_ptr_type( my_type->join_ptr(in_ptr) );\n+      result =  my_type->cast_to_ptr_type(my_type->join_ptr(in_ptr));\n@@ -428,55 +422,1 @@\n-  \/\/ This is the code from TypePtr::xmeet() that prevents us from\n-  \/\/ having 2 ways to represent the same type. We have to replicate it\n-  \/\/ here because we don't go through meet\/join.\n-  if (result->remove_speculative() == result->speculative()) {\n-    result = result->remove_speculative();\n-  }\n-\n-  \/\/ Same as above: because we don't go through meet\/join, remove the\n-  \/\/ speculative type if we know we won't use it.\n-  return result->cleanup_speculative();\n-\n-  \/\/ JOIN NOT DONE HERE BECAUSE OF INTERFACE ISSUES.\n-  \/\/ FIX THIS (DO THE JOIN) WHEN UNION TYPES APPEAR!\n-\n-  \/\/\n-  \/\/ Remove this code after overnight run indicates no performance\n-  \/\/ loss from not performing JOIN at CheckCastPPNode\n-  \/\/\n-  \/\/ const TypeInstPtr *in_oop = in->isa_instptr();\n-  \/\/ const TypeInstPtr *my_oop = _type->isa_instptr();\n-  \/\/ \/\/ If either input is an 'interface', return destination type\n-  \/\/ assert (in_oop == NULL || in_oop->klass() != NULL, \"\");\n-  \/\/ assert (my_oop == NULL || my_oop->klass() != NULL, \"\");\n-  \/\/ if( (in_oop && in_oop->klass()->is_interface())\n-  \/\/   ||(my_oop && my_oop->klass()->is_interface()) ) {\n-  \/\/   TypePtr::PTR  in_ptr = in->isa_ptr() ? in->is_ptr()->_ptr : TypePtr::BotPTR;\n-  \/\/   \/\/ Preserve cast away nullness for interfaces\n-  \/\/   if( in_ptr == TypePtr::NotNull && my_oop && my_oop->_ptr == TypePtr::BotPTR ) {\n-  \/\/     return my_oop->cast_to_ptr_type(TypePtr::NotNull);\n-  \/\/   }\n-  \/\/   return _type;\n-  \/\/ }\n-  \/\/\n-  \/\/ \/\/ Neither the input nor the destination type is an interface,\n-  \/\/\n-  \/\/ \/\/ history: JOIN used to cause weird corner case bugs\n-  \/\/ \/\/          return (in == TypeOopPtr::NULL_PTR) ? in : _type;\n-  \/\/ \/\/ JOIN picks up NotNull in common instance-of\/check-cast idioms, both oops.\n-  \/\/ \/\/ JOIN does not preserve NotNull in other cases, e.g. RawPtr vs InstPtr\n-  \/\/ const Type *join = in->join(_type);\n-  \/\/ \/\/ Check if join preserved NotNull'ness for pointers\n-  \/\/ if( join->isa_ptr() && _type->isa_ptr() ) {\n-  \/\/   TypePtr::PTR join_ptr = join->is_ptr()->_ptr;\n-  \/\/   TypePtr::PTR type_ptr = _type->is_ptr()->_ptr;\n-  \/\/   \/\/ If there isn't any NotNull'ness to preserve\n-  \/\/   \/\/ OR if join preserved NotNull'ness then return it\n-  \/\/   if( type_ptr == TypePtr::BotPTR  || type_ptr == TypePtr::Null ||\n-  \/\/       join_ptr == TypePtr::NotNull || join_ptr == TypePtr::Constant ) {\n-  \/\/     return join;\n-  \/\/   }\n-  \/\/   \/\/ ELSE return same old type as before\n-  \/\/   return _type;\n-  \/\/ }\n-  \/\/ \/\/ Not joining two pointers\n-  \/\/ return join;\n+  return result;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":10,"deletions":70,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1183,16 +1183,0 @@\n-  \/\/ Until we have harmony between classes and interfaces in the type\n-  \/\/ lattice, we must tread carefully around phis which implicitly\n-  \/\/ convert the one to the other.\n-  const TypePtr* ttp = _type->make_ptr();\n-  const TypeInstPtr* ttip = (ttp != NULL) ? ttp->isa_instptr() : NULL;\n-  const TypeInstKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_instklassptr() : NULL;\n-  bool is_intf = false;\n-  if (ttip != NULL) {\n-    if (ttip->is_interface())\n-      is_intf = true;\n-  }\n-  if (ttkp != NULL) {\n-    if (ttkp->is_interface())\n-      is_intf = true;\n-  }\n-\n@@ -1205,14 +1189,0 @@\n-      \/\/ We assume that each input of an interface-valued Phi is a true\n-      \/\/ subtype of that interface.  This might not be true of the meet\n-      \/\/ of all the input types.  The lattice is not distributive in\n-      \/\/ such cases.  Ward off asserts in type.cpp by refusing to do\n-      \/\/ meets between interfaces and proper classes.\n-      const TypePtr* tip = ti->make_ptr();\n-      const TypeInstPtr* tiip = (tip != NULL) ? tip->isa_instptr() : NULL;\n-      if (tiip) {\n-        bool ti_is_intf = false;\n-        if (tiip->is_interface())\n-          ti_is_intf = true;\n-        if (is_intf != ti_is_intf)\n-          { t = _type; break; }\n-      }\n@@ -1242,25 +1212,3 @@\n-\n-    \/\/ Check for evil case of 't' being a class and '_type' expecting an\n-    \/\/ interface.  This can happen because the bytecodes do not contain\n-    \/\/ enough type info to distinguish a Java-level interface variable\n-    \/\/ from a Java-level object variable.  If we meet 2 classes which\n-    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n-    \/\/ doesn't implement I, we have no way to tell if the result should\n-    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n-    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n-    \/\/ uplift the type.\n-    if (!t->empty() && ttip && ttip->is_interface()) {\n-      assert(ft == _type, \"\"); \/\/ Uplift to interface\n-    } else if (!t->empty() && ttkp && ttkp->is_interface()) {\n-      assert(ft == _type, \"\"); \/\/ Uplift to interface\n-    } else {\n-      \/\/ We also have to handle 'evil cases' of interface- vs. class-arrays\n-      Type::get_arrays_base_elements(jt, _type, NULL, &ttip);\n-      if (!t->empty() && ttip != NULL && ttip->is_interface()) {\n-          assert(ft == _type, \"\");   \/\/ Uplift to array of interface\n-      } else {\n-        \/\/ Otherwise it's something stupid like non-overlapping int ranges\n-        \/\/ found on dying counted loops.\n-        assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n-      }\n-    }\n+    \/\/ Otherwise it's something stupid like non-overlapping int ranges\n+    \/\/ found on dying counted loops.\n+    assert(ft == Type::TOP, \"\"); \/\/ Canonical empty value\n@@ -1271,25 +1219,0 @@\n-    \/\/ If we have an interface-typed Phi and we narrow to a class type, the join\n-    \/\/ should report back the class.  However, if we have a J\/L\/Object\n-    \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n-    \/\/ join report an interface back out.  This isn't possible but happens\n-    \/\/ because the type system doesn't interact well with interfaces.\n-    const TypePtr *jtp = jt->make_ptr();\n-    const TypeInstPtr *jtip = (jtp != NULL) ? jtp->isa_instptr() : NULL;\n-    const TypeInstKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_instklassptr() : NULL;\n-    if (jtip && ttip) {\n-      if (jtip->is_interface() &&\n-          !ttip->is_interface()) {\n-        assert(ft == ttip->cast_to_ptr_type(jtip->ptr()) ||\n-               ft->isa_narrowoop() && ft->make_ptr() == ttip->cast_to_ptr_type(jtip->ptr()), \"\");\n-        jt = ft;\n-      }\n-    }\n-    if (jtkp && ttkp) {\n-      if (jtkp->is_interface() &&\n-          !jtkp->klass_is_exact() && \/\/ Keep exact interface klass (6894807)\n-          ttkp->is_loaded() && !ttkp->is_interface()) {\n-        assert(ft == ttkp->cast_to_ptr_type(jtkp->ptr()) ||\n-               ft->isa_narrowklass() && ft->make_ptr() == ttkp->cast_to_ptr_type(jtkp->ptr()), \"\");\n-        jt = ft;\n-      }\n-    }\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":3,"deletions":80,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint));\n+    Node* cls_node = makecon(TypeKlassPtr::make(receiver_constraint, Type::trust_interfaces));\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2185,1 +2185,1 @@\n-    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls);\n+    const TypeKlassPtr* tklass = TypeKlassPtr::make(exact_kls, Type::trust_interfaces);\n@@ -2639,1 +2639,1 @@\n-  gvn.transform(cmp);\n+  cmp = gvn.transform(cmp);\n@@ -2847,1 +2847,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces);\n@@ -2876,1 +2876,1 @@\n-  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass);\n+  const TypeKlassPtr* tklass = TypeKlassPtr::make(klass, Type::trust_interfaces)->try_improve();\n@@ -2999,1 +2999,1 @@\n-        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls)) == Compile::SSC_always_true) {\n+        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls, Type::trust_interfaces)) == Compile::SSC_always_true) {\n@@ -3185,2 +3185,2 @@\n-  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr();\n-  const Type *toop = tk->cast_to_exactness(false)->as_instance_type();\n+  const TypeKlassPtr *tk = _gvn.type(superklass)->is_klassptr()->try_improve();\n+  const TypeOopPtr *toop = tk->cast_to_exactness(false)->as_instance_type();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -503,3 +503,1 @@\n-      if ((toop != NULL && toop->is_interface()) || (tkls != NULL && tkls->is_interface())) {\n-        s2.print(\"  Interface:\");\n-      } else if (toop) {\n+      if (toop) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3667,1 +3667,1 @@\n-      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass()), tp->as_klass_type());\n+      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass(), Type::trust_interfaces), tp->as_klass_type());\n@@ -7169,1 +7169,1 @@\n-  const TypeOopPtr* xtype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n+  const TypeOopPtr* xtype = aklass->cast_to_exactness(false)->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2035,1 +2035,1 @@\n-        return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n+        return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n@@ -2066,1 +2066,1 @@\n-          return ss ? TypeKlassPtr::make(ss) : TypePtr::NULL_PTR;\n+          return ss ? TypeKlassPtr::make(ss, Type::trust_interfaces) : TypePtr::NULL_PTR;\n@@ -2326,1 +2326,1 @@\n-          return TypeKlassPtr::make(ciArrayKlass::make(t));\n+          return TypeKlassPtr::make(ciArrayKlass::make(t), Type::trust_interfaces);\n@@ -2333,1 +2333,1 @@\n-        return TypeKlassPtr::make(t->as_klass());\n+        return TypeKlassPtr::make(t->as_klass(), Type::trust_interfaces);\n@@ -2371,1 +2371,1 @@\n-      return sup ? TypeKlassPtr::make(sup) : TypePtr::NULL_PTR;\n+      return sup ? TypeKlassPtr::make(sup, Type::trust_interfaces) : TypePtr::NULL_PTR;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2557,4 +2557,1 @@\n-    ciKlass*           klass = toop ? toop->instance_klass() : (tkls ? tkls->instance_klass() : NULL );\n-    if (klass && klass->is_loaded() && ((toop && toop->is_interface()) || (tkls && tkls->is_interface()))) {\n-      st->print(\"  Interface:\");\n-    } else if (toop) {\n+    if (toop) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1202,1 +1202,1 @@\n-    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder);\n+    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder, Type::trust_interfaces);\n@@ -1215,1 +1215,1 @@\n-      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder));\n+      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder, Type::trust_interfaces));\n@@ -2135,1 +2135,1 @@\n-  Node* holder = makecon(TypeKlassPtr::make(method()->holder()));\n+  Node* holder = makecon(TypeKlassPtr::make(method()->holder(), Type::trust_interfaces));\n@@ -2214,21 +2214,0 @@\n-    const TypeInstPtr *tr = phi->bottom_type()->isa_instptr();\n-    if (tr && tr->is_loaded() &&\n-        tr->is_interface()) {\n-      const TypeInstPtr *tp = value->bottom_type()->isa_instptr();\n-      if (tp && tp->is_loaded() &&\n-          !tp->is_interface()) {\n-        \/\/ sharpen the type eagerly; this eases certain assert checking\n-        if (tp->higher_equal(TypeInstPtr::NOTNULL))\n-          tr = tr->join_speculative(TypeInstPtr::NOTNULL)->is_instptr();\n-        value = _gvn.transform(new CheckCastPPNode(0, value, tr));\n-      }\n-    } else {\n-      \/\/ Also handle returns of oop-arrays to an arrays-of-interface return\n-      const TypeInstPtr* phi_tip;\n-      const TypeInstPtr* val_tip;\n-      Type::get_arrays_base_elements(phi->bottom_type(), value->bottom_type(), &phi_tip, &val_tip);\n-      if (phi_tip != NULL && phi_tip->is_loaded() && phi_tip->is_interface() &&\n-          val_tip != NULL && val_tip->is_loaded() && !val_tip->is_interface()) {\n-        value = _gvn.transform(new CheckCastPPNode(0, value, phi->bottom_type()));\n-      }\n-    }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass);\n+  const TypeKlassPtr* array_klass_type = TypeKlassPtr::make(array_klass, Type::trust_interfaces);\n@@ -302,1 +302,1 @@\n-  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass)), length, nargs);\n+  Node* array = new_array(makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)), length, nargs);\n@@ -388,1 +388,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass)),\n+                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n@@ -410,1 +410,1 @@\n-                          makecon(TypeKlassPtr::make(array_klass)),\n+                          makecon(TypeKlassPtr::make(array_klass, Type::trust_interfaces)),\n@@ -417,1 +417,1 @@\n-  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass);\n+  const Type* type = TypeOopPtr::make_from_klass_raw(array_klass, Type::trust_interfaces);\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass)));\n+  Node* res = gen_checkcast(obj, makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)));\n@@ -132,1 +132,1 @@\n-  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass)), true);\n+  Node* res = gen_instanceof(peek(), makecon(TypeKlassPtr::make(klass, Type::trust_interfaces)), true);\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1050,1 +1050,1 @@\n-  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass()));\n+  return phase->makecon(TypeKlassPtr::make(mirror_type->as_klass(),  Type::trust_interfaces));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,0 +123,2 @@\n+TypePtr::InterfaceSet* TypeAryPtr::_array_interfaces = NULL;\n+TypePtr::InterfaceSet* TypeAryKlassPtr::_array_interfaces = NULL;\n@@ -137,1 +139,1 @@\n-const Type* Type::get_const_type(ciType* type) {\n+const Type* Type::get_const_type(ciType* type, InterfaceHandling interface_handling) {\n@@ -143,1 +145,1 @@\n-    return TypeOopPtr::make_from_klass(type->as_klass());\n+    return TypeOopPtr::make_from_klass(type->as_klass(), interface_handling);\n@@ -569,0 +571,3 @@\n+  TypeAryPtr::_array_interfaces = new TypePtr::InterfaceSet(ciArrayKlass::interfaces());\n+  TypeAryKlassPtr::_array_interfaces = TypeAryPtr::_array_interfaces;\n+\n@@ -781,45 +786,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool Type::interface_vs_oop_helper(const Type *t) const {\n-  bool result = false;\n-\n-  const TypePtr* this_ptr = this->make_ptr(); \/\/ In case it is narrow_oop\n-  const TypePtr*    t_ptr =    t->make_ptr();\n-  if( this_ptr == NULL || t_ptr == NULL )\n-    return result;\n-\n-  const TypeInstPtr* this_inst = this_ptr->isa_instptr();\n-  const TypeInstPtr*    t_inst =    t_ptr->isa_instptr();\n-  if( this_inst && this_inst->is_loaded() && t_inst && t_inst->is_loaded() ) {\n-    bool this_interface = this_inst->is_interface();\n-    bool    t_interface =    t_inst->is_interface();\n-    result = this_interface ^ t_interface;\n-  }\n-\n-  return result;\n-}\n-\n-bool Type::interface_vs_oop(const Type *t) const {\n-  if (interface_vs_oop_helper(t)) {\n-    return true;\n-  }\n-  \/\/ Now check the speculative parts as well\n-  const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()->speculative() : NULL;\n-  const TypePtr* t_spec = t->isa_ptr() != NULL ? t->is_ptr()->speculative() : NULL;\n-  if (this_spec != NULL && t_spec != NULL) {\n-    if (this_spec->interface_vs_oop_helper(t_spec)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-  if (this_spec != NULL && this_spec->interface_vs_oop_helper(t)) {\n-    return true;\n-  }\n-  if (t_spec != NULL && interface_vs_oop_helper(t_spec)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-#endif\n-\n@@ -845,1 +805,1 @@\n-  if (!interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual)) {\n+  if (t2t != t->_dual || t2this != this->_dual) {\n@@ -2023,1 +1983,1 @@\n-const TypeTuple *TypeTuple::make_range(ciSignature* sig) {\n+const TypeTuple *TypeTuple::make_range(ciSignature* sig, InterfaceHandling interface_handling) {\n@@ -2044,1 +2004,1 @@\n-    field_array[TypeFunc::Parms] = get_const_type(return_type);\n+    field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling);\n@@ -2055,1 +2015,1 @@\n-const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {\n+const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig, InterfaceHandling interface_handling) {\n@@ -2064,1 +2024,1 @@\n-    field_array[pos++] = get_const_type(recv)->join_speculative(TypePtr::NOTNULL);\n+    field_array[pos++] = get_const_type(recv, interface_handling)->join_speculative(TypePtr::NOTNULL);\n@@ -2086,1 +2046,1 @@\n-      field_array[pos++] = get_const_type(type);\n+      field_array[pos++] = get_const_type(type, interface_handling);\n@@ -2317,15 +2277,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool TypeAry::interface_vs_oop(const Type *t) const {\n-  const TypeAry* t_ary = t->is_ary();\n-  if (t_ary) {\n-    const TypePtr* this_ptr = _elem->make_ptr(); \/\/ In case we have narrow_oops\n-    const TypePtr*    t_ptr = t_ary->_elem->make_ptr();\n-    if(this_ptr != NULL && t_ptr != NULL) {\n-      return this_ptr->interface_vs_oop(t_ptr);\n-    }\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -3170,0 +3115,220 @@\n+TypePtr::InterfaceSet::InterfaceSet()\n+        : _list(Compile::current()->type_arena(), 0, 0, NULL),\n+          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n+}\n+\n+TypePtr::InterfaceSet::InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces)\n+        : _list(Compile::current()->type_arena(), interfaces->length(), 0, NULL),\n+          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    add(interfaces->at(i));\n+  }\n+}\n+\n+\n+int TypePtr::InterfaceSet::compare(ciKlass* const& k1, ciKlass* const& k2) {\n+  if ((intptr_t)k1 < (intptr_t)k2) {\n+    return -1;\n+  } else if ((intptr_t)k1 > (intptr_t)k2) {\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+void TypePtr::InterfaceSet::add(ciKlass* interface) {\n+  assert(interface->is_interface(), \"for interfaces only\");\n+  _list.insert_sorted<compare>(interface);\n+  verify();\n+}\n+\n+void TypePtr::InterfaceSet::raw_add(ciKlass* interface) {\n+  assert(interface->is_interface(), \"for interfaces only\");\n+  _list.push(interface);\n+}\n+\n+bool TypePtr::InterfaceSet::eq(const InterfaceSet& other) const {\n+  if (_list.length() != other._list.length()) {\n+    return false;\n+  }\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* k1 = _list.at(i);\n+    ciKlass* k2 = other._list.at(i);\n+    if (!k1->equals(k2)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+int TypePtr::InterfaceSet::hash() const {\n+  if (_hash_computed) {\n+    return _hash;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_hash();\n+  assert(_hash_computed, \"should be computed now\");\n+  return _hash;\n+}\n+\n+void TypePtr::InterfaceSet::compute_hash() {\n+  int hash = 0;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* k = _list.at(i);\n+    hash += (jint)k->hash();\n+  }\n+  _hash_computed = 1;\n+  _hash = hash;\n+}\n+\n+void TypePtr::InterfaceSet::dump(outputStream *st) const {\n+  if (_list.length() == 0) {\n+    return;\n+  }\n+  st->print(\" (\");\n+  for (int i = 0; i < _list.length(); i++) {\n+    if (i > 0) {\n+      st->print(\",\");\n+    }\n+    ciKlass* k = _list.at(i);\n+    k->print_name_on(st);\n+  }\n+  st->print(\")\");\n+}\n+\n+void TypePtr::InterfaceSet::verify() const {\n+#ifdef DEBUG\n+  for (int i = 1; i < _list.length(); i++) {\n+    ciKlass* k1 = _list.at(i-1);\n+    ciKlass* k2 = _list.at(i);\n+    assert(compare(k2, k1) > 0, \"should be ordered\");\n+    assert(k1 != k2, \"no duplicate\");\n+  }\n+#endif\n+}\n+\n+TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::union_with(const InterfaceSet& other) const {\n+  InterfaceSet result;\n+  int i = 0;\n+  int j = 0;\n+  while (i < _list.length() || j < other._list.length()) {\n+    while (i < _list.length() &&\n+           (j >= other._list.length() ||\n+            compare(_list.at(i), other._list.at(j)) < 0)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+    }\n+    while (j < other._list.length() &&\n+           (i >= _list.length() ||\n+            compare(other._list.at(j), _list.at(i)) < 0)) {\n+      result.raw_add(other._list.at(j));\n+      j++;\n+    }\n+    if (i < _list.length() &&\n+        j < other._list.length() &&\n+        _list.at(i) == other._list.at(j)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+      j++;\n+    }\n+  }\n+  result.verify();\n+#ifdef DEBUG\n+  for (int i = 0; i < _list.length(); i++) {\n+    assert(result.contains(_list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < other._list.length(); i++) {\n+    assert(result.contains(other._list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < result._list.length(); i++) {\n+    assert(_list.contains(result._list.at(i)) || other._list.contains(result._list.at(i)), \"missing\");\n+  }\n+#endif\n+  return result;\n+}\n+\n+TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::intersection_with(const InterfaceSet& other) const {\n+  InterfaceSet result;\n+  int i = 0;\n+  int j = 0;\n+  while (i < _list.length() || j < other._list.length()) {\n+    while (i < _list.length() &&\n+           (j >= other._list.length() ||\n+            compare(_list.at(i), other._list.at(j)) < 0)) {\n+      i++;\n+    }\n+    while (j < other._list.length() &&\n+           (i >= _list.length() ||\n+            compare(other._list.at(j), _list.at(i)) < 0)) {\n+      j++;\n+    }\n+    if (i < _list.length() &&\n+        j < other._list.length() &&\n+        _list.at(i) == other._list.at(j)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+      j++;\n+    }\n+  }\n+  result.verify();\n+#ifdef DEBUG\n+  for (int i = 0; i < _list.length(); i++) {\n+    assert(!other._list.contains(_list.at(i)) || result.contains(_list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < other._list.length(); i++) {\n+    assert(!_list.contains(other._list.at(i)) || result.contains(other._list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < result._list.length(); i++) {\n+    assert(_list.contains(result._list.at(i)) && other._list.contains(result._list.at(i)), \"missing\");\n+  }\n+#endif\n+  return result;\n+}\n+\n+\/\/ Is there a single ciKlass* that can represent the interface set?\n+ciKlass* TypePtr::InterfaceSet::exact_klass() const {\n+  if (_exact_klass_computed) {\n+    return _exact_klass;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_exact_klass();\n+  assert(_exact_klass_computed, \"should be computed now\");\n+  return _exact_klass;\n+}\n+\n+void TypePtr::InterfaceSet::compute_exact_klass() {\n+  if (_list.length() == 0) {\n+    _exact_klass_computed = 1;\n+    _exact_klass = NULL;\n+    return;\n+  }\n+  ciKlass* res = NULL;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* interface = _list.at(i);\n+    if (eq(interfaces(interface, false, true, false, trust_interfaces))) {\n+      assert(res == NULL, \"\");\n+      res = _list.at(i);\n+    }\n+  }\n+  _exact_klass_computed = 1;\n+  _exact_klass = res;\n+}\n+\n+bool TypePtr::InterfaceSet::is_loaded() const {\n+  if (_is_loaded_computed) {\n+    return _is_loaded;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_is_loaded();\n+  assert(_is_loaded_computed, \"should be computed now\");\n+  return _is_loaded;\n+}\n+\n+void TypePtr::InterfaceSet::compute_is_loaded() {\n+  _is_loaded_computed = 1;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* interface = _list.at(i);\n+    if (!interface->is_loaded()) {\n+      _is_loaded = false;\n+      return;\n+    }\n+  }\n+  _is_loaded = true;\n+}\n+\n@@ -3171,1 +3336,1 @@\n-TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n+TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n@@ -3175,0 +3340,1 @@\n+    _interfaces(interfaces),\n@@ -3222,1 +3388,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n@@ -3232,1 +3398,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n@@ -3255,1 +3421,1 @@\n-  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n+  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, InterfaceSet(), xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3368,1 +3534,1 @@\n-  return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeOopPtr(_base, dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -3373,1 +3539,1 @@\n-const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {\n+const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling) {\n@@ -3400,1 +3566,2 @@\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, NULL, 0);\n@@ -3403,1 +3570,2 @@\n-    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass->as_obj_array_klass()->element_klass(), false, try_for_exact);\n+    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n+    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(eklass, try_for_exact, false, interface_handling);\n@@ -3409,1 +3577,1 @@\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, NULL, xk, 0);\n@@ -3443,1 +3611,1 @@\n-      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass());\n+      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass(), trust_interfaces);\n@@ -3501,21 +3669,0 @@\n-    \/\/ Check for evil case of 'this' being a class and 'kills' expecting an\n-    \/\/ interface.  This can happen because the bytecodes do not contain\n-    \/\/ enough type info to distinguish a Java-level interface variable\n-    \/\/ from a Java-level object variable.  If we meet 2 classes which\n-    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n-    \/\/ doesn't implement I, we have no way to tell if the result should\n-    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n-    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n-    \/\/ uplift the type.\n-    if (!empty()) {\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n-        return kills;           \/\/ Uplift to interface\n-      }\n-      \/\/ Also check for evil cases of 'this' being a class array\n-      \/\/ and 'kills' expecting an array of interfaces.\n-      Type::get_arrays_base_elements(ft, kills, NULL, &ktip);\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n-        return kills;           \/\/ Uplift to array of interface\n-      }\n-    }\n-\n@@ -3525,12 +3672,0 @@\n-  \/\/ If we have an interface-typed Phi or cast and we narrow to a class type,\n-  \/\/ the join should report back the class.  However, if we have a J\/L\/Object\n-  \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n-  \/\/ join report an interface back out.  This isn't possible but happens\n-  \/\/ because the type system doesn't interact well with interfaces.\n-  if (ftip != NULL && ktip != NULL &&\n-      ftip->is_loaded() &&  ftip->klass()->is_interface() &&\n-      ktip->is_loaded() && !ktip->klass()->is_interface()) {\n-    assert(!ftip->klass_is_exact(), \"interface could not be exact\");\n-    return ktip->cast_to_ptr_type(ftip->ptr());\n-  }\n-\n@@ -3595,1 +3730,1 @@\n-const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeOopPtr::add_offset(intptr_t offset) const {\n@@ -3662,0 +3797,12 @@\n+\n+TypePtr::InterfaceSet TypeOopPtr::meet_interfaces(const TypeOopPtr* other) const {\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces.union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n+  }\n+  return _interfaces.intersection_with(other->_interfaces);\n+}\n+\n@@ -3686,0 +3833,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -3687,1 +3835,12 @@\n-  return _klass;\n+  if (_interfaces.empty()) {\n+    return _klass;\n+  }\n+  if (_klass != ciEnv::current()->Object_klass()) {\n+    ciKlass* k = _klass;\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    if (_interfaces.eq(interfaces)) {\n+      return _klass;\n+    }\n+    return NULL;\n+  }\n+  return _interfaces.exact_klass();\n@@ -3691,1 +3850,1 @@\n-TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,\n+TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int off,\n@@ -3693,4 +3852,5 @@\n-  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth) {\n-   assert(k != NULL &&\n-          (k->is_loaded() || o == NULL),\n-          \"cannot have constants with non-loaded klass\");\n+  : TypeOopPtr(InstPtr, ptr, k, interfaces, xk, o, off, instance_id, speculative, inline_depth) {\n+  assert(k == NULL || !k->is_loaded() || !k->is_interface(), \"no interface here\");\n+  assert(k != NULL &&\n+         (k->is_loaded() || o == NULL),\n+         \"cannot have constants with non-loaded klass\");\n@@ -3702,0 +3862,1 @@\n+                                     const InterfaceSet& interfaces,\n@@ -3722,0 +3883,1 @@\n+    assert(!ik->is_interface(), \"no interface here\");\n@@ -3727,1 +3889,1 @@\n-    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n+    (TypeInstPtr*)(new TypeInstPtr(ptr, k, interfaces, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3732,0 +3894,33 @@\n+TypePtr::InterfaceSet TypePtr::interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling) {\n+  if (k->is_instance_klass()) {\n+    if (k->is_loaded()) {\n+      if (k->is_interface() && interface_handling == ignore_interfaces) {\n+        assert(interface, \"no interface expected\");\n+        k = ciEnv::current()->Object_klass();\n+        InterfaceSet interfaces;\n+        return interfaces;\n+      }\n+      GrowableArray<ciInstanceKlass *> *k_interfaces = k->as_instance_klass()->transitive_interfaces();\n+      InterfaceSet interfaces(k_interfaces);\n+      if (k->is_interface()) {\n+        assert(interface, \"no interface expected\");\n+        k = ciEnv::current()->Object_klass();\n+      } else {\n+        assert(klass, \"no instance klass expected\");\n+      }\n+      return interfaces;\n+    }\n+    InterfaceSet interfaces;\n+    return interfaces;\n+  }\n+  assert(array, \"no array expected\");\n+  assert(k->is_array_klass(), \"Not an array?\");\n+  ciType* e = k->as_array_klass()->base_element_type();\n+  if (e->is_loaded() && e->is_instance_klass() && e->as_instance_klass()->is_interface()) {\n+    if (interface_handling == ignore_interfaces) {\n+      k = ciObjArrayKlass::make(ciEnv::current()->Object_klass(), k->as_array_klass()->dimension());\n+    }\n+  }\n+  return *TypeAryPtr::_array_interfaces;\n+}\n+\n@@ -3760,1 +3955,1 @@\n-  return make(ptr, klass(), klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n@@ -3770,2 +3965,2 @@\n-  if( ik->is_interface() )              return this;  \/\/ cannot set xk\n-  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n+  assert(!ik->is_interface(), \"no interface here\");\n+  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n@@ -3777,1 +3972,1 @@\n-  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(),  _interfaces, _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -3783,35 +3978,31 @@\n-const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {\n-    int off = meet_offset(tinst->offset());\n-    PTR ptr = meet_ptr(tinst->ptr());\n-    int instance_id = meet_instance_id(tinst->instance_id());\n-    const TypePtr* speculative = xmeet_speculative(tinst);\n-    int depth = meet_inline_depth(tinst->inline_depth());\n-\n-    const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n-    const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n-    if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n-      \/\/\n-      \/\/ Meet unloaded class with java\/lang\/Object\n-      \/\/\n-      \/\/ Meet\n-      \/\/          |                     Unloaded Class\n-      \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n-      \/\/  ===================================================================\n-      \/\/   TOP    | ..........................Unloaded......................|\n-      \/\/  AnyNull |  U-AN    |................Unloaded......................|\n-      \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n-      \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n-      \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n-      \/\/\n-      assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n-      \/\/\n-      if(      loaded->ptr() == TypePtr::TopPTR ) { return unloaded; }\n-      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, instance_id, speculative, depth); }\n-      else if (loaded->ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }\n-      else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n-        if (unloaded->ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }\n-        else                                      { return TypeInstPtr::NOTNULL; }\n-      }\n-      else if( unloaded->ptr() == TypePtr::TopPTR )  { return unloaded; }\n-\n-      return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst, const InterfaceSet& interfaces) const {\n+  int off = meet_offset(tinst->offset());\n+  PTR ptr = meet_ptr(tinst->ptr());\n+  int instance_id = meet_instance_id(tinst->instance_id());\n+  const TypePtr* speculative = xmeet_speculative(tinst);\n+  int depth = meet_inline_depth(tinst->inline_depth());\n+\n+  const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n+  const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n+  if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n+    \/\/\n+    \/\/ Meet unloaded class with java\/lang\/Object\n+    \/\/\n+    \/\/ Meet\n+    \/\/          |                     Unloaded Class\n+    \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n+    \/\/  ===================================================================\n+    \/\/   TOP    | ..........................Unloaded......................|\n+    \/\/  AnyNull |  U-AN    |................Unloaded......................|\n+    \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n+    \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n+    \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n+    \/\/\n+    assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n+    \/\/\n+    if(      loaded->ptr() == TypePtr::TopPTR ) { return unloaded; }\n+    else if (loaded->ptr() == TypePtr::AnyNull) { return make(ptr, unloaded->klass(), interfaces, false, NULL, off, instance_id, speculative, depth); }\n+    else if (loaded->ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }\n+    else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n+      if (unloaded->ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }\n+      else                                      { return TypeInstPtr::NOTNULL; }\n@@ -3819,0 +4010,1 @@\n+    else if( unloaded->ptr() == TypePtr::TopPTR )  { return unloaded; }\n@@ -3820,6 +4012,9 @@\n-    \/\/ Both are unloaded, not the same class, not Object\n-    \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n-    if( ptr != TypePtr::BotPTR ) {\n-      return TypeInstPtr::NOTNULL;\n-    }\n-    return TypeInstPtr::BOTTOM;\n+    return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+  }\n+\n+  \/\/ Both are unloaded, not the same class, not Object\n+  \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n+  if( ptr != TypePtr::BotPTR ) {\n+    return TypeInstPtr::NOTNULL;\n+  }\n+  return TypeInstPtr::BOTTOM;\n@@ -3878,1 +4073,1 @@\n-      return make(ptr, klass(), klass_is_exact(),\n+      return make(ptr, klass(), _interfaces, klass_is_exact(),\n@@ -3906,1 +4101,1 @@\n-      return make(ptr, klass(), klass_is_exact(),\n+      return make(ptr, klass(), _interfaces, klass_is_exact(),\n@@ -3940,0 +4135,2 @@\n+    InterfaceSet interfaces = meet_interfaces(tinst);\n+\n@@ -3942,2 +4139,0 @@\n-    bool tinst_xk = tinst->klass_is_exact();\n-    bool this_xk  = klass_is_exact();\n@@ -3948,1 +4143,2 @@\n-    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr, res_klass, res_xk);\n+    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk);\n+\n@@ -3951,1 +4147,1 @@\n-      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst);\n+      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst, interfaces);\n@@ -3988,1 +4184,1 @@\n-      res = make(ptr, res_klass, res_xk, o, off, instance_id, speculative, depth);\n+      res = make(ptr, res_klass, interfaces, res_xk, o, off, instance_id, speculative, depth);\n@@ -3999,4 +4195,10 @@\n-TypePtr::MeetResult TypePtr::meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk,\n-                                          PTR this_ptr,\n-                                          PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk) {\n-\n+template<class T> TypePtr::MeetResult TypePtr::meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type, const T* other_type,\n+                      ciKlass*& res_klass, bool& res_xk) {\n+  ciKlass* this_klass = this_type->klass();\n+  ciKlass* other_klass = other_type->klass();\n+  bool this_xk = this_type->klass_is_exact();\n+  bool other_xk = other_type->klass_is_exact();\n+  PTR this_ptr = this_type->ptr();\n+  PTR other_ptr = other_type->ptr();\n+  InterfaceSet this_interfaces = this_type->interfaces();\n+  InterfaceSet other_interfaces = other_type->interfaces();\n@@ -4007,1 +4209,1 @@\n-  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk) {\n+  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk) {\n@@ -4014,1 +4216,1 @@\n-  if (!tinst_klass->is_loaded() || !this_klass->is_loaded()) {\n+  if (!other_klass->is_loaded() || !this_klass->is_loaded()) {\n@@ -4018,41 +4220,0 @@\n-  \/\/ Handle mixing oops and interfaces first.\n-  if (this_klass->is_interface() && !(tinst_klass->is_interface() ||\n-                                      tinst_klass == ciEnv::current()->Object_klass())) {\n-    ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n-    tinst_klass = this_klass;\n-    this_klass = tmp;\n-    bool tmp2 = tinst_xk;\n-    tinst_xk = this_xk;\n-    this_xk = tmp2;\n-  }\n-  if (tinst_klass->is_interface() &&\n-      !(this_klass->is_interface() ||\n-        \/\/ Treat java\/lang\/Object as an honorary interface,\n-        \/\/ because we need a bottom for the interface hierarchy.\n-        this_klass == ciEnv::current()->Object_klass())) {\n-    \/\/ Oop meets interface!\n-\n-    \/\/ See if the oop subtypes (implements) interface.\n-    if (this_klass->is_subtype_of(tinst_klass)) {\n-      \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n-      \/\/ on whether we are both above the centerline or either is\n-      \/\/ below the centerline.  If we are on the centerline\n-      \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n-      res_klass  = below_centerline(ptr) ? tinst_klass : this_klass;\n-      \/\/ If we are keeping this_klass, keep its exactness too.\n-      res_xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n-      return SUBTYPE;\n-    } else {                  \/\/ Does not implement, fall to Object\n-      \/\/ Oop does not implement interface, so mixing falls to Object\n-      \/\/ just like the verifier does (if both are above the\n-      \/\/ centerline fall to interface)\n-      res_klass = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n-      res_xk = above_centerline(ptr) ? tinst_xk : false;\n-      \/\/ Watch out for Constant vs. AnyNull interface.\n-      if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n-      return NOT_SUBTYPE;\n-    }\n-  }\n-\n-  \/\/ Either oop vs oop or interface vs interface or interface vs Object\n-\n@@ -4084,1 +4245,1 @@\n-  ciKlass *subtype = NULL;\n+  const T* subtype = NULL;\n@@ -4086,5 +4247,7 @@\n-  if (tinst_klass->equals(this_klass)) {\n-    subtype = this_klass;\n-    subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n-  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass)) {\n-    subtype = this_klass;     \/\/ Pick subtyping class\n+  InterfaceSet subtype_interfaces;\n+\n+  if (this_type->is_same_java_type_as(other_type)) {\n+    subtype = this_type;\n+    subtype_exact = below_centerline(ptr) ? (this_xk && other_xk) : (this_xk || other_xk);\n+  } else if (!other_xk && this_type->is_meet_subtype_of(other_type)) {\n+    subtype = this_type;     \/\/ Pick subtyping class\n@@ -4092,3 +4255,3 @@\n-  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass)) {\n-    subtype = tinst_klass;    \/\/ Pick subtyping class\n-    subtype_exact = tinst_xk;\n+  } else if(!this_xk && other_type->is_meet_subtype_of(this_type)) {\n+    subtype = other_type;    \/\/ Pick subtyping class\n+    subtype_exact = other_xk;\n@@ -4099,8 +4262,8 @@\n-      this_klass = tinst_klass = subtype;\n-      this_xk = tinst_xk = subtype_exact;\n-    } else if (above_centerline(this_ptr) && !above_centerline(tinst_ptr)) {\n-      this_klass = tinst_klass; \/\/ tinst is down; keep down man\n-      this_xk = tinst_xk;\n-    } else if (above_centerline(tinst_ptr) && !above_centerline(this_ptr)) {\n-      tinst_klass = this_klass; \/\/ this is down; keep down man\n-      tinst_xk = this_xk;\n+      this_type = other_type = subtype;\n+      this_xk = other_xk = subtype_exact;\n+    } else if (above_centerline(this_ptr) && !above_centerline(other_ptr)) {\n+      this_type = other_type; \/\/ tinst is down; keep down man\n+      this_xk = other_xk;\n+    } else if (above_centerline(other_ptr) && !above_centerline(this_ptr)) {\n+      other_type = this_type; \/\/ this is down; keep down man\n+      other_xk = this_xk;\n@@ -4113,1 +4276,1 @@\n-  if (tinst_klass->equals(this_klass)) {\n+  if (this_type->is_same_java_type_as(other_type)) {\n@@ -4117,1 +4280,1 @@\n-    res_klass = this_klass;\n+    res_klass = this_type->klass();\n@@ -4128,0 +4291,2 @@\n+  interfaces = this_interfaces.intersection_with(other_interfaces);\n+\n@@ -4129,1 +4294,1 @@\n-  ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n+  ciKlass* k = this_klass->least_common_ancestor(other_klass);\n@@ -4137,1 +4302,0 @@\n-\n@@ -4154,1 +4318,1 @@\n-  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -4163,0 +4327,1 @@\n+    _interfaces.eq(p->_interfaces) &&\n@@ -4169,1 +4334,1 @@\n-  int hash = java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash());\n+  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), _interfaces.hash());\n@@ -4174,20 +4339,1 @@\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return false;\n-  }\n-  if (!other->isa_instptr()) {\n-    return false;\n-  }\n-\n-  if (!other_exact) {\n-    return false;\n-  }\n-\n-  if (other->klass()->equals(ciEnv::current()->Object_klass())) {\n-    return true;\n-  }\n-\n-  if (!this_exact && klass()->is_interface()) {\n-    return false;\n-  }\n-\n-  return _klass->is_subtype_of(other->klass());\n+  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -4196,8 +4342,3 @@\n-bool TypeInstPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return false;\n-  }\n-  if (!other->isa_instptr()) {\n-    return false;\n-  }\n-  return _klass->equals(other->_klass);\n+\n+bool TypeInstPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n@@ -4207,27 +4348,1 @@\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return true;\n-  }\n-\n-  if (other->isa_aryptr()) {\n-    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n-  }\n-\n-  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n-    return true;\n-  }\n-\n-  assert(other->isa_instptr(), \"unsupported\");\n-\n-  if (this_exact && other_exact) {\n-    return is_java_subtype_of(other);\n-  }\n-\n-  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n-    return false;\n-  }\n-\n-  if (this_exact) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-\n-  return true;\n+  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -4243,0 +4358,1 @@\n+  _interfaces.dump(st);\n@@ -4292,1 +4408,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset),\n@@ -4297,1 +4413,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), offset,\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), offset,\n@@ -4306,1 +4422,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset,\n@@ -4310,1 +4426,1 @@\n-const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {\n+const TypePtr* TypeInstPtr::with_inline_depth(int depth) const {\n@@ -4314,1 +4430,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n@@ -4317,1 +4433,1 @@\n-const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {\n+const TypePtr* TypeInstPtr::with_instance_id(int instance_id) const {\n@@ -4319,1 +4435,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -4325,5 +4441,55 @@\n-  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final() && !ik->is_interface()) {\n-    Compile* C = Compile::current();\n-    Dependencies* deps = C->dependencies();\n-    deps->assert_leaf_type(ik);\n-    xk = true;\n+  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final()) {\n+    ciKlass* k = ik;\n+    TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    assert(k == ik, \"\");\n+    if (interfaces.eq(_interfaces)) {\n+      Compile *C = Compile::current();\n+      Dependencies* deps = C->dependencies();\n+      deps->assert_leaf_type(ik);\n+      xk = true;\n+    }\n+  }\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, 0);\n+}\n+\n+template <class T1, class T2> bool TypePtr::is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  if (!this_one->is_instance_type(other)) {\n+    return false;\n+  }\n+\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+    return true;\n+  }\n+\n+  return this_one->klass()->is_subtype_of(other->klass()) &&\n+         (!this_xk || this_one->_interfaces.contains(other->_interfaces));\n+}\n+\n+\n+bool TypeInstPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n+}\n+\n+template <class T1, class T2>  bool TypePtr::is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+    return true;\n+  }\n+\n+  if (this_one->is_instance_type(other)) {\n+    return other->klass() == ciEnv::current()->Object_klass() && this_one->_interfaces.contains(other->_interfaces);\n+  }\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (this_top_or_bottom) {\n+    return false;\n+  }\n+\n+  const T1* other_ary = this_one->is_array_type(other);\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_meet_subtype_of_helper(this_one->is_reference_type(other_elem), this_xk, other_xk);\n@@ -4331,1 +4497,18 @@\n-  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), 0);\n+\n+  if (other_elem == NULL && this_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n+  }\n+\n+  return false;\n+}\n+\n+bool TypeAryPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n+}\n+\n+bool TypeInstKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n+}\n+\n+bool TypeAryKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n@@ -4354,0 +4537,4 @@\n+  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n+    k = NULL;\n+  }\n@@ -4366,0 +4553,4 @@\n+  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n+    k = NULL;\n+  }\n@@ -4393,1 +4584,1 @@\n-  if (!is_java_primitive(etype) && !is_reference_type(etype)) {\n+  if (!is_java_primitive(etype) && !::is_reference_type(etype)) {\n@@ -4501,22 +4692,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n-    return true;\n-  }\n-\n-  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n-    return false;\n-  }\n-  if (other->isa_instptr()) {\n-    return _klass->is_subtype_of(other->_klass) && other_exact;\n-  }\n-  if (klass() == NULL) {\n-    return false;\n-  }\n-  assert(other->isa_aryptr(), \"\");\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->is_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact, other_exact);\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-  return false;\n+  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n@@ -4525,13 +4695,2 @@\n-bool TypeAryPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n-  if (!other->isa_aryptr() ||\n-      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n-    return false;\n-  }\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->is_same_java_type_as(other_ary->elem()->make_oopptr());\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->equals(other->_klass);\n-  }\n-  return false;\n+bool TypeAryPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n@@ -4541,25 +4700,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass()) {\n-    return true;\n-  }\n-\n-  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n-    return true;\n-  }\n-  if (other->isa_instptr()) {\n-    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n-  }\n-  assert(other->isa_aryptr(), \"\");\n-\n-  if (this_exact && other_exact) {\n-    return is_java_subtype_of(other);\n-  }\n-\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->maybe_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact,\n-                                                               other_exact);\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-  return false;\n+  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n@@ -4660,1 +4795,1 @@\n-    if (meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk) == NOT_SUBTYPE) {\n+    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk) == NOT_SUBTYPE) {\n@@ -4690,0 +4825,4 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n+\n@@ -4696,2 +4835,2 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n-        return make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n+        return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n@@ -4702,1 +4841,2 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL,offset, instance_id, speculative, depth);\n+        interfaces = this_interfaces.intersection_with(tp_interfaces);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL,offset, instance_id, speculative, depth);\n@@ -4714,1 +4854,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -4728,1 +4868,2 @@\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL, offset, instance_id, speculative, depth);\n@@ -4737,1 +4878,8 @@\n-TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk) {\n+template<class T> TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary,\n+                                                           const T* other_ary, ciKlass*& res_klass, bool& res_xk) {\n+  ciKlass* this_klass = this_ary->klass();\n+  ciKlass* other_klass = other_ary->klass();\n+  bool this_xk = this_ary->klass_is_exact();\n+  bool other_xk = other_ary->klass_is_exact();\n+  PTR this_ptr = this_ary->ptr();\n+  PTR other_ptr = other_ary->ptr();\n@@ -4744,2 +4892,2 @@\n-      res_klass = tap_klass;\n-    else if (tap_klass == NULL || tap_klass == this_klass) {\n+      res_klass = other_klass;\n+    else if (other_klass == NULL || other_klass == this_klass) {\n@@ -4754,1 +4902,1 @@\n-  } else \/\/ Non integral arrays.\n+  } else {\/\/ Non integral arrays.\n@@ -4757,1 +4905,4 @@\n-    if ((above_centerline(ptr) || ptr == Constant) && this_klass != tap_klass &&\n+    int dummy;\n+    bool this_top_or_bottom = (this_ary->base_element_type(dummy) == Type::TOP || this_ary->base_element_type(dummy) == Type::BOTTOM);\n+    bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+    if ((above_centerline(ptr) || ptr == Constant) && !this_ary->is_same_java_type_as(other_ary) &&\n@@ -4759,1 +4910,1 @@\n-        tap_klass != NULL  && this_klass != NULL   &&\n+        !this_top_or_bottom && !other_top_or_bottom &&\n@@ -4761,1 +4912,1 @@\n-        ((tap_xk && this_xk) ||\n+        ((other_xk && this_xk) ||\n@@ -4763,1 +4914,1 @@\n-         (tap_xk && !tap_klass->is_subtype_of(this_klass)) ||\n+         (other_xk && !other_ary->is_meet_subtype_of(this_ary)) ||\n@@ -4765,1 +4916,1 @@\n-         (this_xk && !this_klass->is_subtype_of(tap_klass)))) {\n+         (this_xk && !this_ary->is_meet_subtype_of(other_ary)))) {\n@@ -4773,0 +4924,1 @@\n+  }\n@@ -4775,1 +4927,1 @@\n-  switch (tap_ptr) {\n+  switch (other_ptr) {\n@@ -4782,1 +4934,1 @@\n-        res_xk = (tap_xk || this_xk);\n+        res_xk = (other_xk || this_xk);\n@@ -4792,1 +4944,1 @@\n-        res_xk = this_xk && (this_klass == tap_klass);\n+        res_xk = this_xk && this_ary->is_same_java_type_as(other_ary);\n@@ -4800,1 +4952,1 @@\n-        res_xk = tap_xk;\n+        res_xk = other_xk;\n@@ -4802,2 +4954,2 @@\n-        res_xk = (tap_xk && this_xk) &&\n-          (this_klass == tap_klass); \/\/ Only precise for identical arrays\n+        res_xk = (other_xk && this_xk) &&\n+                 (this_ary->is_same_java_type_as(other_ary)); \/\/ Only precise for identical arrays\n@@ -4821,11 +4973,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool TypeAryPtr::interface_vs_oop(const Type *t) const {\n-  const TypeAryPtr* t_aryptr = t->isa_aryptr();\n-  if (t_aryptr) {\n-    return _ary->interface_vs_oop(t_aryptr->_ary);\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -4836,0 +4977,2 @@\n+  _interfaces.dump(st);\n+\n@@ -4888,1 +5031,1 @@\n-const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeAryPtr::add_offset(intptr_t offset) const {\n@@ -4908,1 +5051,1 @@\n-const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {\n+const TypePtr* TypeAryPtr::with_inline_depth(int depth) const {\n@@ -4915,1 +5058,1 @@\n-const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {\n+const TypePtr* TypeAryPtr::with_instance_id(int instance_id) const {\n@@ -5100,1 +5243,1 @@\n-const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {\n+const TypePtr* TypeMetadataPtr::add_offset( intptr_t offset ) const {\n@@ -5275,1 +5418,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass) {\n+const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass, InterfaceHandling interface_handling) {\n@@ -5277,1 +5420,1 @@\n-    return TypeInstKlassPtr::make(klass);\n+    return TypeInstKlassPtr::make(klass, interface_handling);\n@@ -5279,1 +5422,1 @@\n-  return TypeAryKlassPtr::make(klass);\n+  return TypeAryKlassPtr::make(klass, interface_handling);\n@@ -5282,1 +5425,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling) {\n@@ -5284,1 +5427,2 @@\n-    return TypeInstKlassPtr::make(ptr, klass, offset);\n+    const InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return TypeInstKlassPtr::make(ptr, klass, interfaces, offset);\n@@ -5286,1 +5430,1 @@\n-  return TypeAryKlassPtr::make(ptr, klass, offset);\n+  return TypeAryKlassPtr::make(ptr, klass, offset, interface_handling);\n@@ -5291,2 +5435,4 @@\n-TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset)\n-  : TypePtr(t, ptr, offset), _klass(klass) {\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n+  : TypePtr(t, ptr, offset), _klass(klass), _interfaces(interfaces) {\n+  assert(klass == NULL || !klass->is_loaded() || (klass->is_instance_klass() && !klass->is_interface()) ||\n+         klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"no interface here\");\n@@ -5295,0 +5441,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5296,1 +5443,12 @@\n-  return _klass;\n+  assert(_klass->is_instance_klass() && !_klass->is_interface(), \"No interface\");\n+  if (_interfaces.empty()) {\n+    return _klass;\n+  }\n+  if (_klass != ciEnv::current()->Object_klass()) {\n+    ciKlass* k = _klass;\n+    if (_interfaces.eq(TypePtr::interfaces(k, true, false, true, ignore_interfaces))) {\n+      return _klass;\n+    }\n+    return NULL;\n+  }\n+  return _interfaces.exact_klass();\n@@ -5304,0 +5462,1 @@\n+    _interfaces.eq(p->_interfaces) &&\n@@ -5310,1 +5469,1 @@\n-  return TypePtr::hash();\n+  return java_add((jint)TypePtr::hash(), _interfaces.hash());\n@@ -5331,3 +5490,0 @@\n-    if (!empty() && ktkp != NULL && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n-      return kills;             \/\/ Uplift to interface\n-\n@@ -5337,9 +5493,0 @@\n-  \/\/ Interface klass type could be exact in opposite to interface type,\n-  \/\/ return it here instead of incorrect Constant ptr J\/L\/Object (6894807).\n-  if (ftkp != NULL && ktkp != NULL &&\n-      ftkp->is_loaded() &&  ftkp->klass()->is_interface() &&\n-      !ftkp->klass_is_exact() && \/\/ Keep exact interface klass\n-      ktkp->is_loaded() && !ktkp->klass()->is_interface()) {\n-    return ktkp->cast_to_ptr_type(ftkp->ptr());\n-  }\n-\n@@ -5349,0 +5496,11 @@\n+TypePtr::InterfaceSet TypeKlassPtr::meet_interfaces(const TypeKlassPtr* other) const {\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces.union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n+  }\n+  return _interfaces.intersection_with(other->_interfaces);\n+}\n+\n@@ -5386,0 +5544,1 @@\n+      _interfaces.dump(st);\n@@ -5426,1 +5585,1 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, int offset) {\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset) {\n@@ -5428,1 +5587,1 @@\n-    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset))->hashcons();\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, interfaces, offset))->hashcons();\n@@ -5435,2 +5594,2 @@\n-const TypePtr *TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n-  return make( _ptr, klass(), xadd_offset(offset) );\n+const TypePtr* TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n+  return make( _ptr, klass(), _interfaces, xadd_offset(offset) );\n@@ -5440,1 +5599,1 @@\n-  return make(_ptr, klass(), offset);\n+  return make(_ptr, klass(), _interfaces, offset);\n@@ -5447,1 +5606,1 @@\n-  return make(ptr, _klass, _offset);\n+  return make(ptr, _klass, _interfaces, _offset);\n@@ -5463,1 +5622,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, k, _offset);\n+  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset);\n@@ -5478,0 +5637,1 @@\n+  TypePtr::InterfaceSet interfaces = _interfaces;\n@@ -5486,3 +5646,8 @@\n-        deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n-        k = ik = sub;\n-        xk = sub->is_final();\n+        ciKlass* sub_k = sub;\n+        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n+        assert(sub_k == sub, \"\");\n+        if (sub_interfaces.eq(_interfaces)) {\n+          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+          k = ik = sub;\n+          xk = sub->is_final();\n+        }\n@@ -5492,1 +5657,1 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, 0);\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, NULL, 0);\n@@ -5533,1 +5698,1 @@\n-      return make( ptr, klass(), offset );\n+      return make( ptr, klass(), _interfaces, offset );\n@@ -5568,4 +5733,1 @@\n-    ciKlass* tkls_klass = tkls->klass();\n-    ciKlass* this_klass  = klass();\n-    bool tkls_xk = tkls->klass_is_exact();\n-    bool this_xk  = klass_is_exact();\n+    InterfaceSet interfaces = meet_interfaces(tkls);\n@@ -5575,1 +5737,1 @@\n-    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr, res_klass, res_xk)) {\n+    switch(meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk)) {\n@@ -5583,2 +5745,2 @@\n-        const Type* res1 = make(ptr, res_klass, off);\n-        return res1;\n+        const Type* res = make(ptr, res_klass, interfaces, off);\n+        return res;\n@@ -5594,0 +5756,3 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n@@ -5601,1 +5766,1 @@\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n@@ -5606,1 +5771,2 @@\n-        return make(ptr, ciEnv::current()->Object_klass(), offset);\n+        interfaces = _interfaces.intersection_with(tp->_interfaces);\n+        return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -5618,1 +5784,1 @@\n-        if (klass()->equals(ciEnv::current()->Object_klass())) {\n+        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n@@ -5628,1 +5794,2 @@\n-      return make(ptr, ciEnv::current()->Object_klass(), offset);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -5640,1 +5807,1 @@\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset());\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset());\n@@ -5643,2 +5810,3 @@\n-bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n+template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -5647,1 +5815,1 @@\n-  if (!other->isa_instklassptr()) {\n+  if (!this_one->is_instance_type(other)) {\n@@ -5655,1 +5823,1 @@\n-  if (other->_klass->equals(ciEnv::current()->Object_klass())) {\n+  if (other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces.empty()) {\n@@ -5659,3 +5827,2 @@\n-  if (!this_exact && klass()->is_interface()) {\n-    return false;\n-  }\n+  return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n+}\n@@ -5663,1 +5830,2 @@\n-  return _klass->is_subtype_of(other->_klass);\n+bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -5666,2 +5834,3 @@\n-bool TypeInstKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n+template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -5670,1 +5839,1 @@\n-  if (!other->isa_instklassptr()) {\n+  if (!this_one->is_instance_type(other)) {\n@@ -5673,1 +5842,1 @@\n-  return _klass->equals(other->_klass);\n+  return this_one->_klass->equals(other->_klass) && this_one->_interfaces.eq(other->_interfaces);\n@@ -5676,4 +5845,3 @@\n-bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return true;\n-  }\n+bool TypeInstKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n+}\n@@ -5681,2 +5849,4 @@\n-  if (other->isa_aryklassptr()) {\n-    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n+    return true;\n@@ -5685,2 +5855,2 @@\n-  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n-    return true;\n+  if (this_one->is_array_type(other)) {\n+    return !this_exact && this_one->_klass->equals(ciEnv::current()->Object_klass())  && other->_interfaces.contains(this_one->_interfaces);\n@@ -5689,1 +5859,1 @@\n-  assert(other->isa_instklassptr(), \"unsupported\");\n+  assert(this_one->is_instance_type(other), \"unsupported\");\n@@ -5692,1 +5862,1 @@\n-    return is_java_subtype_of(other);\n+    return this_one->is_java_subtype_of(other);\n@@ -5695,1 +5865,1 @@\n-  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n+  if (!this_one->_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(this_one->_klass)) {\n@@ -5700,1 +5870,1 @@\n-    return _klass->is_subtype_of(other->_klass);\n+    return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n@@ -5706,0 +5876,36 @@\n+bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n+}\n+\n+const TypeKlassPtr* TypeInstKlassPtr::try_improve() const {\n+  if (!UseUniqueSubclasses) {\n+    return this;\n+  }\n+  ciKlass* k = klass();\n+  Compile* C = Compile::current();\n+  Dependencies* deps = C->dependencies();\n+  assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+  TypePtr::InterfaceSet interfaces = _interfaces;\n+  if (k->is_loaded()) {\n+    ciInstanceKlass* ik = k->as_instance_klass();\n+    bool klass_is_exact = ik->is_final();\n+    if (!klass_is_exact &&\n+        deps != NULL) {\n+      ciInstanceKlass* sub = ik->unique_concrete_subklass();\n+      if (sub != NULL) {\n+        ciKlass *sub_k = sub;\n+        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n+        assert(sub_k == sub, \"\");\n+        if (sub_interfaces.eq(_interfaces)) {\n+          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+          k = ik = sub;\n+          klass_is_exact = sub->is_final();\n+          return TypeKlassPtr::make(klass_is_exact ? Constant : _ptr, k, _offset);\n+        }\n+      }\n+    }\n+  }\n+  return this;\n+}\n+\n+\n@@ -5710,2 +5916,2 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n-  if (klass->is_obj_array_klass()) {\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling) {\n+  if (k->is_obj_array_klass()) {\n@@ -5713,2 +5919,2 @@\n-    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n-    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n+    ciKlass* eklass = k->as_obj_array_klass()->element_klass();\n+    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n@@ -5716,1 +5922,1 @@\n-  } else if (klass->is_type_array_klass()) {\n+  } else if (k->is_type_array_klass()) {\n@@ -5718,2 +5924,2 @@\n-    const Type* etype = get_const_basic_type(klass->as_type_array_klass()->element_type());\n-    return TypeAryKlassPtr::make(ptr, etype, klass, offset);\n+    const Type* etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset);\n@@ -5726,2 +5932,2 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass) {\n-  return TypeAryKlassPtr::make(Constant, klass, 0);\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n+  return TypeAryKlassPtr::make(Constant, klass, 0, interface_handling);\n@@ -5759,2 +5965,1 @@\n-    \/\/ Compute array klass from element klass\n-    k_ary = ciObjArrayKlass::make(tinst->klass());\n+    \/\/ Leave k_ary at NULL.\n@@ -5762,5 +5967,1 @@\n-    \/\/ Compute array klass from element klass\n-    ciKlass* k_elem = tary->klass();\n-    \/\/ If element type is something like bottom[], k_elem will be null.\n-    if (k_elem != NULL)\n-      k_ary = ciObjArrayKlass::make(k_elem);\n+    \/\/ Leave k_ary at NULL.\n@@ -5824,5 +6025,0 @@\n-    if (UseCompressedOops && k_ary != NULL && k_ary->is_obj_array_klass() &&\n-        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n-        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n-      ((TypeAryPtr*)this)->_is_ptr_to_narrowoop = true;\n-    }\n@@ -5833,0 +6029,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5858,1 +6055,1 @@\n-const TypePtr *TypeAryKlassPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeAryKlassPtr::add_offset(intptr_t offset) const {\n@@ -5988,1 +6185,1 @@\n-    meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk);\n+    meet_aryptr(ptr, elem, this, tap, res_klass, res_xk);\n@@ -5996,0 +6193,3 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n@@ -6003,1 +6203,1 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6008,1 +6208,2 @@\n-        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+        interfaces = this_interfaces.intersection_with(tp->_interfaces);\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -6020,1 +6221,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6029,1 +6230,2 @@\n-      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -6038,2 +6240,4 @@\n-bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n+template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n@@ -6043,1 +6247,4 @@\n-  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6046,2 +6253,3 @@\n-  if (other->isa_instklassptr()) {\n-    return _klass->is_subtype_of(other->_klass) && other_exact;\n+\n+  if (this_one->is_instance_type(other)) {\n+    return other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces) && other_exact;\n@@ -6049,1 +6257,5 @@\n-  if (klass() == NULL) {\n+\n+  assert(this_one->is_array_type(other), \"\");\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  if (other_top_or_bottom) {\n@@ -6052,4 +6264,5 @@\n-  assert(other->isa_aryklassptr(), \"\");\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->is_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (this_elem != NULL && other_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n@@ -6057,2 +6270,2 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n+  if (this_elem == NULL && other_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -6063,3 +6276,18 @@\n-bool TypeAryKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n-  if (!other->isa_aryklassptr() ||\n-      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+}\n+\n+template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (!this_one->is_array_type(other) ||\n+      !this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+    return false;\n+  }\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (other_top_or_bottom) {\n@@ -6068,3 +6296,5 @@\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->is_same_java_type_as(other_ary->_elem->is_klassptr());\n+\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_same_java_type_as(this_one->is_reference_type(other_elem));\n@@ -6072,2 +6302,3 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->equals(other->_klass);\n+  if (other_elem == NULL && this_elem == NULL) {\n+    assert(this_one->_klass != NULL && other->_klass != NULL, \"\");\n+    return this_one->_klass->equals(other->_klass);\n@@ -6078,2 +6309,7 @@\n-bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (other->klass() == ciEnv::current()->Object_klass()) {\n+bool TypeAryKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n+}\n+\n+template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n@@ -6082,1 +6318,3 @@\n-  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6085,2 +6323,2 @@\n-  if (other->isa_instklassptr()) {\n-    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n+  if (this_one->is_instance_type(other)) {\n+    return other->_klass->equals(ciEnv::current()->Object_klass()) && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces);\n@@ -6088,1 +6326,1 @@\n-  assert(other->isa_aryklassptr(), \"\");\n+  assert(this_one->is_array_type(other), \"\");\n@@ -6090,0 +6328,5 @@\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  if (other_top_or_bottom) {\n+    return true;\n+  }\n@@ -6091,1 +6334,1 @@\n-    return is_java_subtype_of(other);\n+    return this_one->is_java_subtype_of(other);\n@@ -6094,3 +6337,4 @@\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->maybe_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->maybe_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n@@ -6098,2 +6342,2 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n+  if (other_elem == NULL && this_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -6104,0 +6348,4 @@\n+bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+}\n+\n@@ -6110,1 +6358,1 @@\n-\/\/------------------------------get_con----------------------------------------\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -6130,5 +6378,1 @@\n-    k = elem()->is_klassptr()->klass();\n-    if (k != NULL) {\n-      k = ciObjArrayKlass::make(k);\n-      ((TypeAryKlassPtr*)this)->_klass = k;\n-    }\n+    \/\/ leave NULL\n@@ -6139,0 +6383,1 @@\n+    ((TypeAryKlassPtr*)this)->_klass = k;\n@@ -6154,0 +6399,1 @@\n+      _interfaces.dump(st);\n@@ -6202,1 +6448,1 @@\n-    domain = TypeTuple::make_domain(NULL, method->signature());\n+    domain = TypeTuple::make_domain(NULL, method->signature(), ignore_interfaces);\n@@ -6204,1 +6450,1 @@\n-    domain = TypeTuple::make_domain(method->holder(), method->signature());\n+    domain = TypeTuple::make_domain(method->holder(), method->signature(), ignore_interfaces);\n@@ -6206,1 +6452,1 @@\n-  const TypeTuple *range  = TypeTuple::make_range(method->signature());\n+  const TypeTuple *range  = TypeTuple::make_range(method->signature(), ignore_interfaces);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":790,"deletions":544,"binary":false,"changes":1334,"status":"modified"},{"patch":"@@ -171,4 +171,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop_helper(const Type *t) const;\n-#endif\n@@ -263,1 +259,0 @@\n-  \/\/ Currently, it also works around limitations involving interface types.\n@@ -273,5 +268,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n-\n@@ -407,0 +397,4 @@\n+  enum InterfaceHandling {\n+      trust_interfaces,\n+      ignore_interfaces\n+  };\n@@ -408,1 +402,1 @@\n-  static const Type* get_const_type(ciType* type);\n+  static const Type* get_const_type(ciType* type, InterfaceHandling interface_handling = ignore_interfaces);\n@@ -727,2 +721,2 @@\n-  static const TypeTuple *make_range(ciSignature *sig);\n-  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig);\n+  static const TypeTuple *make_range(ciSignature *sig, InterfaceHandling interface_handling = ignore_interfaces);\n+  static const TypeTuple *make_domain(ciInstanceKlass* recv, ciSignature *sig, InterfaceHandling interface_handling);\n@@ -779,4 +773,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n@@ -888,0 +878,46 @@\n+  friend class Type;\n+protected:\n+  class InterfaceSet {\n+  private:\n+    GrowableArray<ciKlass*> _list;\n+    void raw_add(ciKlass* interface);\n+    void add(ciKlass* interface);\n+    void verify() const;\n+    int _hash_computed:1;\n+    int _exact_klass_computed:1;\n+    int _is_loaded_computed:1;\n+    int _hash;\n+    ciKlass* _exact_klass;\n+    bool _is_loaded;\n+    void compute_hash();\n+    void compute_exact_klass();\n+  public:\n+    InterfaceSet();\n+    InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces);\n+    bool eq(const InterfaceSet& other) const;\n+    int hash() const;\n+    void dump(outputStream *st) const;\n+    InterfaceSet union_with(const InterfaceSet& other) const;\n+    InterfaceSet intersection_with(const InterfaceSet& other) const;\n+    bool contains(const InterfaceSet& other) const {\n+      return intersection_with(other).eq(other);\n+    }\n+    bool empty() const { return _list.length() == 0; }\n+\n+    inline void* operator new(size_t x) throw() {\n+      Compile* compile = Compile::current();\n+      return compile->type_arena()->AmallocWords(x);\n+    }\n+    inline void operator delete( void* ptr ) {\n+      ShouldNotReachHere();\n+    }\n+    ciKlass* exact_klass() const;\n+    bool is_loaded() const;\n+\n+    static int compare(ciKlass* const &, ciKlass* const & k2);\n+\n+    void compute_is_loaded();\n+  };\n+\n+  static InterfaceSet interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling);\n+\n@@ -946,6 +982,14 @@\n-  static MeetResult\n-  meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk, PTR this_ptr,\n-               PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk);\n-  static MeetResult\n-  meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk);\n-\n+  template<class T> static TypePtr::MeetResult meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type,\n+                                                            const T* other_type, ciKlass*& res_klass, bool& res_xk);\n+\n+  template<class T> static MeetResult meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary, const T* other_ary,\n+                                                  ciKlass*& res_klass, bool& res_xk);\n+\n+  template <class T1, class T2> static bool is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other);\n+  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other);\n+  template <class T1, class T2> static bool maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact);\n+  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n+  template <class T1, class T2> static bool is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk);\n@@ -1060,1 +1104,1 @@\n-  TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n+ TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset, int instance_id,\n@@ -1076,0 +1120,3 @@\n+\n+  const InterfaceSet _interfaces;\n+\n@@ -1087,1 +1134,1 @@\n-  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact);\n+  static const TypeOopPtr* make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling);\n@@ -1092,0 +1139,2 @@\n+  InterfaceSet meet_interfaces(const TypeOopPtr* other) const;\n+\n@@ -1103,1 +1152,9 @@\n-  virtual bool is_same_java_type_as(const TypeOopPtr* other) const { ShouldNotReachHere(); return false; }\n+\n+  bool is_same_java_type_as(const TypePtr* other) const {\n+    return is_same_java_type_as_helper(other->is_oopptr());\n+  }\n+\n+  virtual bool is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n@@ -1114,2 +1171,2 @@\n-  static const TypeOopPtr* make_from_klass(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, false);\n+  static const TypeOopPtr* make_from_klass(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    return make_from_klass_common(klass, true, false, interface_handling);\n@@ -1119,2 +1176,2 @@\n-  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass) {\n-    return make_from_klass_common(klass, true, true);\n+  static const TypeOopPtr* make_from_klass_unique(ciKlass* klass, InterfaceHandling interface_handling= ignore_interfaces) {\n+    return make_from_klass_common(klass, true, true, interface_handling);\n@@ -1124,2 +1181,2 @@\n-  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass) {\n-    return make_from_klass_common(klass, false, false);\n+  static const TypeOopPtr* make_from_klass_raw(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    return make_from_klass_common(klass, false, false, interface_handling);\n@@ -1144,2 +1201,2 @@\n-  virtual bool  is_loaded() const { return klass()->is_loaded(); }\n-  bool klass_is_exact()    const { return _klass_is_exact; }\n+  virtual bool  is_loaded() const { return klass()->is_loaded() && _interfaces.is_loaded(); }\n+  virtual bool klass_is_exact()    const { return _klass_is_exact; }\n@@ -1187,0 +1244,24 @@\n+private:\n+  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n+    return is_meet_subtype_of_helper(other->is_oopptr(), klass_is_exact(), other->is_oopptr()->klass_is_exact());\n+  }\n+\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n+  virtual const InterfaceSet interfaces() const {\n+    return _interfaces;\n+  };\n+\n+  const TypeOopPtr* is_reference_type(const Type* other) const {\n+    return other->isa_oopptr();\n+  }\n+\n+  const TypeAryPtr* is_array_type(const TypeOopPtr* other) const {\n+    return other->isa_aryptr();\n+  }\n+\n+  const TypeInstPtr* is_instance_type(const TypeOopPtr* other) const {\n+    return other->isa_instptr();\n+  }\n@@ -1193,1 +1274,1 @@\n-  TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id,\n+  TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset, int instance_id,\n@@ -1204,3 +1285,1 @@\n-    if (klass()->is_loaded() && klass()->is_interface()) {\n-      return Compile::current()->env()->Object_klass();\n-    }\n+    assert(!(klass()->is_loaded() && klass()->is_interface()), \"\");\n@@ -1210,1 +1289,1 @@\n-  bool is_same_java_type_as(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n@@ -1216,1 +1295,3 @@\n-    return make(TypePtr::Constant, o->klass(), true, o, 0, InstanceBot);\n+    ciKlass* k = o->klass();\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(TypePtr::Constant, k, interfaces, true, o, 0, InstanceBot);\n@@ -1220,1 +1301,3 @@\n-    return make(TypePtr::Constant, o->klass(), true, o, offset, InstanceBot);\n+    ciKlass* k = o->klass();\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(TypePtr::Constant, k, interfaces, true, o, offset, InstanceBot);\n@@ -1224,2 +1307,3 @@\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* klass) {\n-    return make(ptr, klass, false, NULL, 0, InstanceBot);\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return make(ptr, klass, interfaces, false, NULL, 0, InstanceBot);\n@@ -1230,1 +1314,2 @@\n-    return make(ptr, klass, true, NULL, 0, InstanceBot);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n+    return make(ptr, klass, interfaces, true, NULL, 0, InstanceBot);\n@@ -1235,1 +1320,2 @@\n-    return make(ptr, klass, false, NULL, offset, InstanceBot);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, false, false, ignore_interfaces);\n+    return make(ptr, klass, interfaces, false, NULL, offset, InstanceBot);\n@@ -1238,2 +1324,1 @@\n-  \/\/ Make a pointer to an oop.\n-  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n@@ -1244,0 +1329,5 @@\n+  static const TypeInstPtr *make(PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset, int instance_id = InstanceBot) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(ptr, k, interfaces, xk, o, offset, instance_id);\n+  }\n+\n@@ -1268,1 +1358,1 @@\n-  virtual const TypeInstPtr *xmeet_unloaded( const TypeInstPtr *t ) const;\n+  virtual const TypeInstPtr *xmeet_unloaded(const TypeInstPtr *t, const InterfaceSet& interfaces) const;\n@@ -1273,2 +1363,0 @@\n-  bool is_interface() const { return is_loaded() && klass()->is_interface(); }\n-\n@@ -1284,0 +1372,8 @@\n+\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n+\n+  virtual bool is_meet_same_type_as(const TypePtr* other) const {\n+    return _klass->equals(other->is_instptr()->_klass) && _interfaces.eq(other->is_instptr()->_interfaces);\n+  }\n+\n@@ -1289,0 +1385,3 @@\n+  friend class Type;\n+  friend class TypePtr;\n+\n@@ -1292,1 +1391,1 @@\n-    : TypeOopPtr(AryPtr,ptr,k,xk,o,offset, instance_id, speculative, inline_depth),\n+    : TypeOopPtr(AryPtr,ptr,k,*_array_interfaces,xk,o,offset, instance_id, speculative, inline_depth),\n@@ -1296,14 +1395,7 @@\n-#ifdef ASSERT\n-    if (k != NULL) {\n-      \/\/ Verify that specified klass and TypeAryPtr::klass() follow the same rules.\n-      ciKlass* ck = compute_klass(true);\n-      if (k != ck) {\n-        this->dump(); tty->cr();\n-        tty->print(\" k: \");\n-        k->print(); tty->cr();\n-        tty->print(\"ck: \");\n-        if (ck != NULL) ck->print();\n-        else tty->print(\"<NULL>\");\n-        tty->cr();\n-        assert(false, \"unexpected TypeAryPtr::_klass\");\n-      }\n+    int dummy;\n+    bool top_or_bottom = (base_element_type(dummy) == Type::TOP || base_element_type(dummy) == Type::BOTTOM);\n+\n+    if (UseCompressedOops && (elem()->make_oopptr() != NULL && !top_or_bottom) &&\n+        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n+        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n+      _is_ptr_to_narrowoop = true;\n@@ -1311,1 +1403,1 @@\n-#endif\n+\n@@ -1320,0 +1412,3 @@\n+  \/\/ A pointer to delay allocation to Type::Initialize_shared()\n+\n+  static InterfaceSet* _array_interfaces;\n@@ -1321,0 +1416,1 @@\n+  \/\/ Only guaranteed non null for array of basic types\n@@ -1325,1 +1421,1 @@\n-  bool is_same_java_type_as(const TypeOopPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeOopPtr* other) const;\n@@ -1402,4 +1498,0 @@\n-#ifdef ASSERT\n-  \/\/ One type is interface, the other is oop\n-  virtual bool interface_vs_oop(const Type *t) const;\n-#endif\n@@ -1409,0 +1501,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeOopPtr* other, bool this_xk, bool other_xk) const;\n@@ -1456,0 +1550,1 @@\n+  friend class TypePtr;\n@@ -1457,1 +1552,1 @@\n-  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset);\n+  TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset);\n@@ -1469,1 +1564,2 @@\n-\n+  const InterfaceSet _interfaces;\n+  InterfaceSet meet_interfaces(const TypeKlassPtr* other) const;\n@@ -1479,0 +1575,4 @@\n+  bool is_same_java_type_as(const TypePtr* other) const {\n+    return is_same_java_type_as_helper(other->is_klassptr());\n+  }\n+\n@@ -1482,1 +1582,1 @@\n-  virtual bool is_same_java_type_as(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n+  virtual bool is_same_java_type_as_helper(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n@@ -1488,0 +1588,1 @@\n+  virtual bool klass_is_exact()    const { return _ptr == Constant; }\n@@ -1489,4 +1590,2 @@\n-  bool klass_is_exact()    const { return _ptr == Constant; }\n-\n-  static const TypeKlassPtr* make(ciKlass* klass);\n-  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset);\n+  static const TypeKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling = ignore_interfaces);\n+  static const TypeKlassPtr *make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling = ignore_interfaces);\n@@ -1511,0 +1610,2 @@\n+  virtual const TypeKlassPtr* try_improve() const { return this; }\n+\n@@ -1514,0 +1615,24 @@\n+private:\n+  virtual bool is_meet_subtype_of(const TypePtr* other) const {\n+    return is_meet_subtype_of_helper(other->is_klassptr(), klass_is_exact(), other->is_klassptr()->klass_is_exact());\n+  }\n+\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const {\n+    ShouldNotReachHere(); return false;\n+  }\n+\n+  virtual const InterfaceSet interfaces() const {\n+    return _interfaces;\n+  };\n+\n+  const TypeKlassPtr* is_reference_type(const Type* other) const {\n+    return other->isa_klassptr();\n+  }\n+\n+  const TypeAryKlassPtr* is_array_type(const TypeKlassPtr* other) const {\n+    return other->isa_aryklassptr();\n+  }\n+\n+  const TypeInstKlassPtr* is_instance_type(const TypeKlassPtr* other) const {\n+    return other->isa_instklassptr();\n+  }\n@@ -1519,2 +1644,3 @@\n-  TypeInstKlassPtr(PTR ptr, ciKlass* klass, int offset)\n-    : TypeKlassPtr(InstKlassPtr, ptr, klass, offset) {\n+  TypeInstKlassPtr(PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n+    : TypeKlassPtr(InstKlassPtr, ptr, klass, interfaces, offset) {\n+    assert(klass->is_instance_klass() && (!klass->is_loaded() || !klass->is_interface()), \"\");\n@@ -1528,3 +1654,1 @@\n-    if (klass()->is_interface()) {\n-      return Compile::current()->env()->Object_klass();\n-    }\n+    assert(!klass()->is_interface(), \"\");\n@@ -1534,1 +1658,1 @@\n-  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n@@ -1538,2 +1662,9 @@\n-  static const TypeInstKlassPtr *make(ciKlass* k) {\n-    return make(TypePtr::Constant, k, 0);\n+  static const TypeInstKlassPtr *make(ciKlass* k, InterfaceHandling interface_handling) {\n+    InterfaceSet interfaces = TypePtr::interfaces(k, true, true, false, interface_handling);\n+    return make(TypePtr::Constant, k, interfaces, 0);\n+  }\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset);\n+\n+  static const TypeInstKlassPtr* make(PTR ptr, ciKlass* k, int offset) {\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    return make(ptr, k, interfaces, offset);\n@@ -1541,1 +1672,0 @@\n-  static const TypeInstKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n@@ -1557,1 +1687,1 @@\n-  bool is_interface() const { return klass()->is_interface(); }\n+  virtual const TypeKlassPtr* try_improve() const;\n@@ -1562,0 +1692,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n@@ -1567,0 +1699,3 @@\n+  friend class Type;\n+  friend class TypePtr;\n+\n@@ -1569,0 +1704,1 @@\n+  static InterfaceSet* _array_interfaces;\n@@ -1570,1 +1706,2 @@\n-    : TypeKlassPtr(AryKlassPtr, ptr, klass, offset), _elem(elem) {\n+    : TypeKlassPtr(AryKlassPtr, ptr, klass, *_array_interfaces, offset), _elem(elem) {\n+    assert(klass == NULL || klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"\");\n@@ -1574,0 +1711,1 @@\n+  \/\/ Only guaranteed non null for array of basic types\n@@ -1583,1 +1721,1 @@\n-  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset);\n+  static const TypeAryKlassPtr *make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling);\n@@ -1585,1 +1723,1 @@\n-  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n+  bool is_same_java_type_as_helper(const TypeKlassPtr* other) const;\n@@ -1592,1 +1730,1 @@\n-  static const TypeAryKlassPtr* make(ciKlass* klass);\n+  static const TypeAryKlassPtr* make(ciKlass* klass, InterfaceHandling interface_handling);\n@@ -1619,0 +1757,2 @@\n+private:\n+  virtual bool is_meet_subtype_of_helper(const TypeKlassPtr* other, bool this_xk, bool other_xk) const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":232,"deletions":92,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-        t.runTest(methodObjClassCast,  true,  svalue);\n+        t.runTest(methodObjClassCast,  false,  svalue);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/CastNullCheckDroppingsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}