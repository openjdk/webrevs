{"files":[{"patch":"@@ -1529,1 +1529,1 @@\n-  macro(_raw_access_flags_offset,    k, \"rawAccessFlags\",      char_signature,    false); \\\n+  macro(_raw_access_flags_offset,    k, \"classFileAccessFlags\",      char_signature,    false); \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-        rawAccessFlags = flags;\n+        classFileAccessFlags = flags;\n@@ -1012,1 +1012,1 @@\n-    private final transient char rawAccessFlags;  \/\/ Set by the VM\n+    private final transient char classFileAccessFlags;  \/\/ Set by the VM\n@@ -1384,1 +1384,1 @@\n-        \/\/ Use getRawClassAccessFlags to expose SUPER status.\n+        \/\/ Use getClassFileAccessFlags to expose SUPER status.\n@@ -1390,1 +1390,1 @@\n-                        getRawClassAccessFlags() : getModifiers(), location, this);\n+                        getClassFileAccessFlags() : getModifiers(), location, this);\n@@ -4135,7 +4135,13 @@\n-    \/**\n-     * Return the access flags as they were in the class's bytecode, including\n-     * the original setting of ACC_SUPER.\n-     *\/\n-    int getRawClassAccessFlags() {\n-        return rawAccessFlags;\n-    }\n+     \/**\n+      * Return the access flags as they were in the class's bytecode, including\n+      * the original setting of ACC_SUPER.\n+      *\n+      * If this {@code Class} object represents a primitive type or\n+      * void, the flags are {@code PUBLIC}, {@code ABSTRACT}, and\n+      * {@code FINAL}.\n+      * If this {@code Class} object represents an array type return 0. This\n+      * is not called in Class but can be called with an array type in Reflection.\n+      *\/\n+     int getClassFileAccessFlags() {\n+         return classFileAccessFlags;\n+     }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2025,2 +2025,2 @@\n-            public int getRawClassAccessFlags(Class<?> klass) {\n-                return klass.getRawClassAccessFlags();\n+            public int getClassFileAccessFlags(Class<?> klass) {\n+                return klass.getClassFileAccessFlags();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-    int getRawClassAccessFlags(Class<?> klass);\n+    int getClassFileAccessFlags(Class<?> klass);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-        return Holder.JLA.getRawClassAccessFlags(c);\n+        return Holder.JLA.getClassFileAccessFlags(c);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Set;\n@@ -51,1 +52,1 @@\n-        m = cl.getDeclaredMethod(\"getRawClassAccessFlags\", new Class[0]);\n+        m = cl.getDeclaredMethod(\"getClassFileAccessFlags\", new Class[0]);\n@@ -57,2 +58,6 @@\n-        \/\/ test primitive array.  should return ACC_ABSTRACT | ACC_FINAL | ACC_PUBLIC.\n-        int flags = (int)m.invoke((new int[3]).getClass());\n+        \/\/ Test that primitive should return ACC_ABSTRACT | ACC_FINAL | ACC_PUBLIC.\n+        int[] arr = new int[3];\n+        if (!arr.getClass().getComponentType().isPrimitive()) {\n+            throw new RuntimeException(\"not primitive\");\n+        }\n+        int flags = (int)m.invoke(arr.getClass().getComponentType());\n@@ -61,1 +66,8 @@\n-                \"expected 0x411, got 0x\" + Integer.toHexString(flags) + \" for primitive array\");\n+                \"expected 0x411, got 0x\" + Integer.toHexString(flags) + \" for primitive type\");\n+        }\n+\n+        \/\/ Test that primitive array raw access flags return 0.\n+        flags = (int)m.invoke(arr.getClass());\n+        if (flags != 0) {\n+            throw new RuntimeException(\n+                \"expected 0x0 got 0x\" + Integer.toHexString(flags) + \" for primitive array\");\n@@ -64,1 +76,15 @@\n-        \/\/ test object array.  should return flags of component.\n+        \/\/ Test that the modifier flags return element type flags.\n+        flags = (int)arr.getClass().getModifiers();\n+        if (flags != (Modifier.ABSTRACT | Modifier.FINAL | Modifier.PUBLIC)) {\n+            throw new RuntimeException(\n+                \"expected 0x411, got 0x\" + Integer.toHexString(flags) + \" for primitive type\");\n+        }\n+\n+        \/\/ Test that AccessFlags set will return element type access flags.\n+        Set<AccessFlag> aacc = arr.getClass().accessFlags();\n+        if (!aacc.containsAll(Set.of(AccessFlag.FINAL, AccessFlag.ABSTRACT, AccessFlag.PUBLIC))) {\n+            throw new RuntimeException(\n+                \"AccessFlags should contain FINAL, ABSTRACT and PUBLIC for primitive type\");\n+        }\n+\n+        \/\/ Test object array.  Raw access flags are 0 for arrays.\n@@ -66,1 +92,1 @@\n-        if (flags != Modifier.PUBLIC) {\n+        if (flags != 0) {\n@@ -68,1 +94,1 @@\n-                \"expected 0x1, got 0x\" + Integer.toHexString(flags) + \" for object array\");\n+                \"expected 0x0, got 0x\" + Integer.toHexString(flags) + \" for object array\");\n@@ -71,2 +97,2 @@\n-        \/\/ test multi-dimensional object array.  should return flags of component.\n-        flags = (int)m.invoke((new SUPERnotset[4][2]).getClass());\n+        \/\/ Test object array component type.\n+        flags = (int)m.invoke((new SUPERnotset[2]).getClass().getComponentType());\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassAccessFlagsRawTest.java","additions":35,"deletions":9,"binary":false,"changes":44,"status":"modified"}]}