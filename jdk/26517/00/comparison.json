{"files":[{"patch":"@@ -873,0 +873,1 @@\n+int java_lang_Class::_raw_access_flags_offset;\n@@ -1076,0 +1077,4 @@\n+  \/\/ Set the raw access_flags, this is used by reflection instead of modifier flags.\n+  \/\/ The Java code for array classes gets the access flags from the element type.\n+  assert(!k->is_array_klass() || k->access_flags().as_unsigned_short() == 0, \"access flags are not set for arrays\");\n+  set_raw_access_flags(mirror(), k->access_flags().as_unsigned_short());\n@@ -1381,0 +1386,2 @@\n+  set_raw_access_flags(java_class, JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n+\n@@ -1522,0 +1529,1 @@\n+  macro(_raw_access_flags_offset,    k, \"rawAccessFlags\",      char_signature,    false); \\\n@@ -1567,0 +1575,10 @@\n+int java_lang_Class::raw_access_flags(oop the_class_mirror) {\n+  assert(_raw_access_flags_offset != 0, \"offsets should have been initialized\");\n+  return the_class_mirror->char_field(_raw_access_flags_offset);\n+}\n+\n+void java_lang_Class::set_raw_access_flags(oop the_class_mirror, u2 value) {\n+  assert(_raw_access_flags_offset != 0, \"offsets should have been initialized\");\n+  the_class_mirror->char_field_put(_raw_access_flags_offset, value);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  static int _raw_access_flags_offset;\n@@ -345,0 +346,3 @@\n+  static int raw_access_flags(oop java_class);\n+  static void set_raw_access_flags(oop java_class, u2 value);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -317,2 +317,0 @@\n-  do_intrinsic(_getClassAccessFlags,      reflect_Reflection,     getClassAccessFlags_name, class_int_signature, F_SN)  \\\n-   do_name(     getClassAccessFlags_name,                        \"getClassAccessFlags\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -763,1 +763,0 @@\n-  case vmIntrinsics::_getClassAccessFlags:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -522,2 +522,1 @@\n-  case vmIntrinsics::_getSuperclass:\n-  case vmIntrinsics::_getClassAccessFlags:      return inline_native_Class_query(intrinsic_id());\n+  case vmIntrinsics::_getSuperclass:            return inline_native_Class_query(intrinsic_id());\n@@ -4010,4 +4009,0 @@\n-  case vmIntrinsics::_getClassAccessFlags:\n-    prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n-    return_type = TypeInt::CHAR;\n-    break;\n@@ -4109,5 +4104,0 @@\n-  case vmIntrinsics::_getClassAccessFlags:\n-    p = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));\n-    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n-    break;\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1982,6 +1982,0 @@\n-  if (tkls->offset() == in_bytes(Klass::access_flags_offset())) {\n-    \/\/ The field is Klass::_access_flags.  Return its (constant) value.\n-    \/\/ (Folds up the 2nd indirection in Reflection.getClassAccessFlags(aClassConstant).)\n-    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _access_flags\");\n-    return TypeInt::make(klass->access_flags());\n-  }\n@@ -1990,1 +1984,0 @@\n-    \/\/ (Folds up the 2nd indirection in Reflection.getClassAccessFlags(aClassConstant).)\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1744,13 +1744,0 @@\n-JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))\n-{\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    \/\/ Primitive type\n-    return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n-  }\n-\n-  Klass* k = java_lang_Class::as_Klass(mirror);\n-  return k->access_flags().as_class_flags();\n-}\n-JVM_END\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    private Class(ClassLoader loader, Class<?> arrayComponentType, char mods, ProtectionDomain pd, boolean isPrim) {\n+    private Class(ClassLoader loader, Class<?> arrayComponentType, char mods, ProtectionDomain pd, boolean isPrim, char flags) {\n@@ -248,0 +248,1 @@\n+        rawAccessFlags = flags;\n@@ -1011,0 +1012,1 @@\n+    private final transient char rawAccessFlags;  \/\/ Set by the VM\n@@ -1382,1 +1384,1 @@\n-        \/\/ Use getClassAccessFlagsRaw to expose SUPER status.\n+        \/\/ Use getRawClassAccessFlags to expose SUPER status.\n@@ -1388,1 +1390,1 @@\n-                        getClassAccessFlagsRaw() : getModifiers(), location, this);\n+                        getRawClassAccessFlags() : getModifiers(), location, this);\n@@ -4133,1 +4135,1 @@\n-    \/*\n+    \/**\n@@ -4136,3 +4138,0 @@\n-     *\n-     * If the class is an array type then the access flags of the element type is\n-     * returned.  If the class is a primitive then ACC_ABSTRACT | ACC_FINAL | ACC_PUBLIC.\n@@ -4140,3 +4139,2 @@\n-    private int getClassAccessFlagsRaw() {\n-        Class<?> c = isArray() ? elementType() : this;\n-        return c.getClassAccessFlagsRaw0();\n+    int getRawClassAccessFlags() {\n+        return rawAccessFlags;\n@@ -4144,2 +4142,0 @@\n-\n-    private native int getClassAccessFlagsRaw0();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2025,0 +2025,3 @@\n+            public int getRawClassAccessFlags(Class<?> klass) {\n+                return klass.getRawClassAccessFlags();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,0 +115,5 @@\n+    \/**\n+     * Get the int value of the Class's class-file access flags.\n+     *\/\n+    int getRawClassAccessFlags(Class<?> klass);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,2 +84,6 @@\n-    @IntrinsicCandidate\n-    public static native int getClassAccessFlags(Class<?> c);\n+    public static int getClassAccessFlags(Class<?> c) {\n+        class Holder {\n+            static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+        }\n+        return Holder.JLA.getRawClassAccessFlags(c);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-    {\"getClassAccessFlagsRaw0\", \"()I\",      (void *)&JVM_GetClassAccessFlags},\n","filename":"src\/java.base\/share\/native\/libjava\/Class.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,6 +36,0 @@\n-JNIEXPORT jint JNICALL\n-Java_jdk_internal_reflect_Reflection_getClassAccessFlags(JNIEnv *env, jclass unused, jclass cls)\n-{\n-    return JVM_GetClassAccessFlags(env, cls);\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjava\/Reflection.c","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-        m = cl.getDeclaredMethod(\"getClassAccessFlagsRaw\", new Class[0]);\n+        m = cl.getDeclaredMethod(\"getRawClassAccessFlags\", new Class[0]);\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassAccessFlagsRawTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,1 +151,2 @@\n-            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, char.class, ProtectionDomain.class, boolean.class);\n+            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, char.class,\n+                                                 ProtectionDomain.class, boolean.class, char.class);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessibleObject\/ModuleSetAccessibleTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,1 +197,2 @@\n-            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, char.class, ProtectionDomain.class, boolean.class);\n+            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, char.class,\n+                                                 ProtectionDomain.class, boolean.class, char.class);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessibleObject\/TrySetAccessibleTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}