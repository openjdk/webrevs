{"files":[{"patch":"@@ -873,0 +873,1 @@\n+int java_lang_Class::_raw_access_flags_offset;\n@@ -1076,0 +1077,4 @@\n+  \/\/ Set the raw access_flags, this is used by reflection instead of modifier flags.\n+  \/\/ The Java code for array classes gets the access flags from the element type.\n+  assert(!k->is_array_klass() || k->access_flags().as_unsigned_short() == 0, \"access flags are not set for arrays\");\n+  set_raw_access_flags(mirror(), k->access_flags().as_unsigned_short());\n@@ -1381,0 +1386,2 @@\n+  set_raw_access_flags(java_class, JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n+\n@@ -1522,0 +1529,1 @@\n+  macro(_raw_access_flags_offset,    k, \"classFileAccessFlags\",      char_signature,    false); \\\n@@ -1567,0 +1575,10 @@\n+int java_lang_Class::raw_access_flags(oop the_class_mirror) {\n+  assert(_raw_access_flags_offset != 0, \"offsets should have been initialized\");\n+  return the_class_mirror->char_field(_raw_access_flags_offset);\n+}\n+\n+void java_lang_Class::set_raw_access_flags(oop the_class_mirror, u2 value) {\n+  assert(_raw_access_flags_offset != 0, \"offsets should have been initialized\");\n+  the_class_mirror->char_field_put(_raw_access_flags_offset, value);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -261,0 +261,1 @@\n+  static int _raw_access_flags_offset;\n@@ -345,0 +346,3 @@\n+  static int raw_access_flags(oop java_class);\n+  static void set_raw_access_flags(oop java_class, u2 value);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -317,2 +317,0 @@\n-  do_intrinsic(_getClassAccessFlags,      reflect_Reflection,     getClassAccessFlags_name, class_int_signature, F_SN)  \\\n-   do_name(     getClassAccessFlags_name,                        \"getClassAccessFlags\")                                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -763,1 +763,0 @@\n-  case vmIntrinsics::_getClassAccessFlags:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -522,2 +522,1 @@\n-  case vmIntrinsics::_getSuperclass:\n-  case vmIntrinsics::_getClassAccessFlags:      return inline_native_Class_query(intrinsic_id());\n+  case vmIntrinsics::_getSuperclass:            return inline_native_Class_query(intrinsic_id());\n@@ -4010,4 +4009,0 @@\n-  case vmIntrinsics::_getClassAccessFlags:\n-    prim_return_value = intcon(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n-    return_type = TypeInt::CHAR;\n-    break;\n@@ -4109,5 +4104,0 @@\n-  case vmIntrinsics::_getClassAccessFlags:\n-    p = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));\n-    query_value = make_load(nullptr, p, TypeInt::CHAR, T_CHAR, MemNode::unordered);\n-    break;\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1982,6 +1982,0 @@\n-  if (tkls->offset() == in_bytes(Klass::access_flags_offset())) {\n-    \/\/ The field is Klass::_access_flags.  Return its (constant) value.\n-    \/\/ (Folds up the 2nd indirection in Reflection.getClassAccessFlags(aClassConstant).)\n-    assert(Opcode() == Op_LoadUS, \"must load an unsigned short from _access_flags\");\n-    return TypeInt::make(klass->access_flags());\n-  }\n@@ -1990,1 +1984,0 @@\n-    \/\/ (Folds up the 2nd indirection in Reflection.getClassAccessFlags(aClassConstant).)\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1744,13 +1744,0 @@\n-JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))\n-{\n-  oop mirror = JNIHandles::resolve_non_null(cls);\n-  if (java_lang_Class::is_primitive(mirror)) {\n-    \/\/ Primitive type\n-    return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n-  }\n-\n-  Klass* k = java_lang_Class::as_Klass(mirror);\n-  return k->access_flags().as_class_flags();\n-}\n-JVM_END\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    private Class(ClassLoader loader, Class<?> arrayComponentType, char mods, ProtectionDomain pd, boolean isPrim) {\n+    private Class(ClassLoader loader, Class<?> arrayComponentType, char mods, ProtectionDomain pd, boolean isPrim, char flags) {\n@@ -248,0 +248,1 @@\n+        classFileAccessFlags = flags;\n@@ -1011,0 +1012,1 @@\n+    private final transient char classFileAccessFlags;  \/\/ Set by the VM\n@@ -1382,1 +1384,1 @@\n-        \/\/ Use getClassAccessFlagsRaw to expose SUPER status.\n+        \/\/ Use getClassFileAccessFlags to expose SUPER status.\n@@ -1388,1 +1390,1 @@\n-                        getClassAccessFlagsRaw() : getModifiers(), location, this);\n+                        getClassFileAccessFlags() : getModifiers(), location, this);\n@@ -4133,13 +4135,12 @@\n-    \/*\n-     * Return the access flags as they were in the class's bytecode, including\n-     * the original setting of ACC_SUPER.\n-     *\n-     * If the class is an array type then the access flags of the element type is\n-     * returned.  If the class is a primitive then ACC_ABSTRACT | ACC_FINAL | ACC_PUBLIC.\n-     *\/\n-    private int getClassAccessFlagsRaw() {\n-        Class<?> c = isArray() ? elementType() : this;\n-        return c.getClassAccessFlagsRaw0();\n-    }\n-\n-    private native int getClassAccessFlagsRaw0();\n+     \/**\n+      * Return the access flags as they were in the class's bytecode, including\n+      * the original setting of ACC_SUPER.\n+      *\n+      * If this {@code Class} object represents a primitive type or\n+      * void, the flags are {@code PUBLIC}, {@code ABSTRACT}, and\n+      * {@code FINAL}.\n+      * If this {@code Class} object represents an array type, return 0.\n+      *\/\n+     int getClassFileAccessFlags() {\n+         return classFileAccessFlags;\n+     }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2025,0 +2025,3 @@\n+            public int getClassFileAccessFlags(Class<?> klass) {\n+                return klass.getClassFileAccessFlags();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,0 +115,5 @@\n+    \/**\n+     * Get the int value of the Class's class-file access flags.\n+     *\/\n+    int getClassFileAccessFlags(Class<?> klass);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -84,2 +84,3 @@\n-    @IntrinsicCandidate\n-    public static native int getClassAccessFlags(Class<?> c);\n+    public static int getClassAccessFlags(Class<?> c) {\n+        return SharedSecrets.getJavaLangAccess().getClassFileAccessFlags(c);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-    {\"getClassAccessFlagsRaw0\", \"()I\",      (void *)&JVM_GetClassAccessFlags},\n","filename":"src\/java.base\/share\/native\/libjava\/Class.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,6 +36,0 @@\n-JNIEXPORT jint JNICALL\n-Java_jdk_internal_reflect_Reflection_getClassAccessFlags(JNIEnv *env, jclass unused, jclass cls)\n-{\n-    return JVM_GetClassAccessFlags(env, cls);\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjava\/Reflection.c","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.Set;\n@@ -51,1 +52,1 @@\n-        m = cl.getDeclaredMethod(\"getClassAccessFlagsRaw\", new Class[0]);\n+        m = cl.getDeclaredMethod(\"getClassFileAccessFlags\", new Class[0]);\n@@ -57,2 +58,6 @@\n-        \/\/ test primitive array.  should return ACC_ABSTRACT | ACC_FINAL | ACC_PUBLIC.\n-        int flags = (int)m.invoke((new int[3]).getClass());\n+        \/\/ Test that primitive should return ACC_ABSTRACT | ACC_FINAL | ACC_PUBLIC.\n+        int[] arr = new int[3];\n+        if (!arr.getClass().getComponentType().isPrimitive()) {\n+            throw new RuntimeException(\"not primitive\");\n+        }\n+        int flags = (int)m.invoke(arr.getClass().getComponentType());\n@@ -61,1 +66,8 @@\n-                \"expected 0x411, got 0x\" + Integer.toHexString(flags) + \" for primitive array\");\n+                \"expected 0x411, got 0x\" + Integer.toHexString(flags) + \" for primitive type\");\n+        }\n+\n+        \/\/ Test that primitive array raw access flags return 0.\n+        flags = (int)m.invoke(arr.getClass());\n+        if (flags != 0) {\n+            throw new RuntimeException(\n+                \"expected 0x0 got 0x\" + Integer.toHexString(flags) + \" for primitive array\");\n@@ -64,1 +76,15 @@\n-        \/\/ test object array.  should return flags of component.\n+        \/\/ Test that the modifier flags return element type flags.\n+        flags = (int)arr.getClass().getModifiers();\n+        if (flags != (Modifier.ABSTRACT | Modifier.FINAL | Modifier.PUBLIC)) {\n+            throw new RuntimeException(\n+                \"expected 0x411, got 0x\" + Integer.toHexString(flags) + \" for primitive type\");\n+        }\n+\n+        \/\/ Test that AccessFlags set will return element type access flags.\n+        Set<AccessFlag> aacc = arr.getClass().accessFlags();\n+        if (!aacc.containsAll(Set.of(AccessFlag.FINAL, AccessFlag.ABSTRACT, AccessFlag.PUBLIC))) {\n+            throw new RuntimeException(\n+                \"AccessFlags should contain FINAL, ABSTRACT and PUBLIC for primitive type\");\n+        }\n+\n+        \/\/ Test object array.  Raw access flags are 0 for arrays.\n@@ -66,1 +92,1 @@\n-        if (flags != Modifier.PUBLIC) {\n+        if (flags != 0) {\n@@ -68,1 +94,1 @@\n-                \"expected 0x1, got 0x\" + Integer.toHexString(flags) + \" for object array\");\n+                \"expected 0x0, got 0x\" + Integer.toHexString(flags) + \" for object array\");\n@@ -71,2 +97,2 @@\n-        \/\/ test multi-dimensional object array.  should return flags of component.\n-        flags = (int)m.invoke((new SUPERnotset[4][2]).getClass());\n+        \/\/ Test object array component type.\n+        flags = (int)m.invoke((new SUPERnotset[2]).getClass().getComponentType());\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassAccessFlagsRawTest.java","additions":36,"deletions":10,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -151,1 +151,2 @@\n-            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, char.class, ProtectionDomain.class, boolean.class);\n+            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, char.class,\n+                                                 ProtectionDomain.class, boolean.class, char.class);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessibleObject\/ModuleSetAccessibleTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,1 +197,2 @@\n-            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, char.class, ProtectionDomain.class, boolean.class);\n+            = Class.class.getDeclaredConstructor(ClassLoader.class, Class.class, char.class,\n+                                                 ProtectionDomain.class, boolean.class, char.class);\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessibleObject\/TrySetAccessibleTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}