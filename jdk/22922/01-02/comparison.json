{"files":[{"patch":"@@ -1,258 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Red Hat and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2;\n-\n-import compiler.lib.ir_framework.Test;\n-import compiler.lib.ir_framework.*;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-\n-import java.util.Random;\n-\n-\/*\n- * @test\n- * @bug 8325495\n- * @summary C2 should optimize for series of Add of unique value. e.g., a + a + ... + a => a*n\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.TestSerialAdditions\n- *\/\n-public class TestSerialAdditions {\n-    private static final Random RNG = Utils.getRandomInstance();\n-\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Run(test = {\n-            \"addTo2\",\n-            \"addTo3\",\n-            \"addTo4\",\n-            \"shiftAndAddTo4\",\n-            \"mulAndAddTo4\",\n-            \"addTo5\",\n-            \"addTo6\",\n-            \"addTo7\",\n-            \"addTo8\",\n-            \"addTo16\",\n-            \"addAndShiftTo16\",\n-            \"addTo42\",\n-            \"mulAndAddTo42\",\n-            \"mulAndAddToMax\",\n-            \"mulAndAddToOverflow\",\n-            \"mulAndAddToZero\",\n-            \"mulAndAddToMinus1\",\n-            \"mulAndAddToMinus42\"\n-    })\n-    private void runIntTests() {\n-        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, RNG.nextInt() }) {\n-            Asserts.assertEQ(a * 2, addTo2(a));\n-            Asserts.assertEQ(a * 3, addTo3(a));\n-            Asserts.assertEQ(a * 4, addTo4(a));\n-            Asserts.assertEQ(a * 4, shiftAndAddTo4(a));\n-            Asserts.assertEQ(a * 4, mulAndAddTo4(a));\n-            Asserts.assertEQ(a * 5, addTo5(a));\n-            Asserts.assertEQ(a * 6, addTo6(a));\n-            Asserts.assertEQ(a * 7, addTo7(a));\n-            Asserts.assertEQ(a * 8, addTo8(a));\n-            Asserts.assertEQ(a * 16, addTo16(a));\n-            Asserts.assertEQ(a * 16, addAndShiftTo16(a));\n-            Asserts.assertEQ(a * 42, addTo42(a));\n-            Asserts.assertEQ(a * 42, mulAndAddTo42(a));\n-            Asserts.assertEQ(a * Integer.MAX_VALUE, mulAndAddToMax(a));\n-            Asserts.assertEQ(a * Integer.MIN_VALUE, mulAndAddToOverflow(a));\n-            Asserts.assertEQ(0, mulAndAddToZero(a));\n-            Asserts.assertEQ(a * -1, mulAndAddToMinus1(a));\n-            Asserts.assertEQ(a * -42, mulAndAddToMinus42(a));\n-        }\n-    }\n-\n-    @Run(test = {\n-            \"mulAndAddToIntOverflowL\",\n-            \"mulAndAddToMaxL\",\n-            \"mulAndAddToOverflowL\"\n-    })\n-    private void runLongTests() {\n-        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, RNG.nextLong() }) {\n-            Asserts.assertEQ(a * (Integer.MAX_VALUE + 1L), mulAndAddToIntOverflowL(a));\n-            Asserts.assertEQ(a * Long.MAX_VALUE, mulAndAddToMaxL(a));\n-            Asserts.assertEQ(a * Long.MIN_VALUE, mulAndAddToOverflowL(a));\n-        }\n-    }\n-\n-    \/\/ ----- integer tests -----\n-    @Test\n-    @IR(counts = { IRNode.ADD_I, \"1\" })\n-    @IR(failOn = IRNode.LSHIFT_I)\n-    private static int addTo2(int a) {\n-        return a + a; \/\/ Simple additions like a + a should be kept as-is\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n-    private static int addTo3(int a) {\n-        return a + a + a; \/\/ a*3 => (a<<1) + a\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n-    private static int addTo4(int a) {\n-        return a + a + a + a; \/\/ a*4 => a<<2\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n-    private static int shiftAndAddTo4(int a) {\n-        return (a << 1) + a + a; \/\/ a*2 + a + a => a*3 + a => a*4 => a<<2\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n-    private static int mulAndAddTo4(int a) {\n-        return a * 3 + a; \/\/ a*4 => a<<2\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n-    private static int addTo5(int a) {\n-        return a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.MUL_I, \"1\" })\n-    private static int addTo6(int a) {\n-        return a + a + a + a + a + a;\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n-    private static int addTo7(int a) {\n-        return a + a + a + a + a + a + a; \/\/ a*7 => (a<<3) - a\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n-    private static int addTo8(int a) {\n-        return a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n-    private static int addTo16(int a) {\n-        return a + a + a + a + a + a + a + a + a + a\n-                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n-    private static int addAndShiftTo16(int a) {\n-        return (a + a) << 3; \/\/ a<<(3 + 1) => a<<4\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.MUL_I, \"1\" })\n-    private static int addTo42(int a) {\n-        return a + a + a + a + a + a + a + a + a + a\n-                + a + a + a + a + a + a + a + a + a + a\n-                + a + a + a + a + a + a + a + a + a + a\n-                + a + a + a + a + a + a + a + a + a + a\n-                + a + a; \/\/ a*42\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.MUL_I, \"1\" })\n-    private static int mulAndAddTo42(int a) {\n-        return a * 40 + a + a; \/\/ a*41 + a => a*42\n-    }\n-\n-    private static final int INT_MAX_MINUS_ONE = Integer.MAX_VALUE - 1;\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n-    private static int mulAndAddToMax(int a) {\n-        return a * INT_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - a => (a<<31) - a\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n-    private static int mulAndAddToOverflow(int a) {\n-        return a * Integer.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<31\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.CON_I, \"1\" })\n-    private static int mulAndAddToZero(int a) {\n-        return a * -1 + a; \/\/ 0\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n-    private static int mulAndAddToMinus1(int a) {\n-        return a * -2 + a; \/\/ a*-1 => a - (a<<1)\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_I)\n-    @IR(counts = { IRNode.MUL_I, \"1\" })\n-    private static int mulAndAddToMinus42(int a) {\n-        return a * -43 + a; \/\/ a*-42\n-    }\n-\n-    \/\/ --- long tests ---\n-    @Test\n-    @IR(failOn = IRNode.ADD_L)\n-    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n-    private static long mulAndAddToIntOverflowL(long a) {\n-        return a * Integer.MAX_VALUE + a; \/\/ a*(INT_MAX+1)\n-    }\n-\n-    private static final long LONG_MAX_MINUS_ONE = Long.MAX_VALUE - 1;\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_L)\n-    @IR(counts = { IRNode.LSHIFT_L, \"1\", IRNode.SUB_L, \"1\" })\n-    private static long mulAndAddToMaxL(long a) {\n-        return a * LONG_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<63) - 1\n-    }\n-\n-    @Test\n-    @IR(failOn = IRNode.ADD_L)\n-    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n-    private static long mulAndAddToOverflowL(long a) {\n-        return a * Long.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<63\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSerialAdditions.java","additions":0,"deletions":258,"binary":false,"changes":258,"status":"deleted"}]}