{"files":[{"patch":"@@ -252,1 +252,11 @@\n-  \/\/ Get low bit; check for being the only bit\n+  \/\/ TODO: abs_con = (1<<m)+(1<<n) and con = -((1<<n)+1) was supported\n+  \/\/ originally, but they are disabled since it's not performing in some cases,\n+  \/\/ such as \"mul then add\" in a loop. On some architectures this can be\n+  \/\/ vectorized as a vector mul-add instruction, which is more performing than\n+  \/\/ two vector shifts and one vector add instruction.\n+  \/\/\n+  \/\/ Tests show that conversion is beneficial if constant multiplication is\n+  \/\/ converted to fewer than three normal or vector shift and add instructions.\n+  \/\/\n+  \/\/ But if it's not vectorizable, maybe it's profitable to do the conversion on\n+  \/\/ some architectures, support it in backends if it's worthwhile.\n@@ -254,3 +264,13 @@\n-  unsigned int bit1 = submultiple_power_of_2(abs_con);\n-  if (bit1 == abs_con) {           \/\/ Found a power of 2?\n-    res = new LShiftINode(in(1), phase->intcon(log2i_exact(bit1)));\n+  if (is_power_of_2(abs_con)) {\n+    \/\/ abs_con = 1<<n, (n > 0)\n+    res = new LShiftINode(in(1), phase->intcon(log2i_exact(abs_con)));\n+  } else if (is_power_of_2(abs_con - 1) && !sign_flip) {\n+    \/\/ con = (1<<n) + 1, (n > 0)\n+    Node* n1 = phase->transform(\n+        new LShiftINode(in(1), phase->intcon(log2i_exact(abs_con - 1))));\n+    res = new AddINode(in(1), n1);\n+  } else if (is_power_of_2(abs_con + 1)) {\n+    \/\/ abs_con = (1<<n) - 1, (n > 0)\n+    Node* n1 = phase->transform(\n+        new LShiftINode(in(1), phase->intcon(log2i_exact(abs_con + 1))));\n+    res = new SubINode(n1, in(1));\n@@ -258,15 +278,1 @@\n-    \/\/ Check for constant with 2 bits set\n-    unsigned int bit2 = abs_con - bit1;\n-    bit2 = bit2 & (0 - bit2);          \/\/ Extract 2nd bit\n-    if (bit2 + bit1 == abs_con) {    \/\/ Found all bits in con?\n-      Node *n1 = phase->transform(new LShiftINode(in(1), phase->intcon(log2i_exact(bit1))));\n-      Node *n2 = phase->transform(new LShiftINode(in(1), phase->intcon(log2i_exact(bit2))));\n-      res = new AddINode(n2, n1);\n-    } else if (is_power_of_2(abs_con + 1)) {\n-      \/\/ Sleezy: power-of-2 - 1.  Next time be generic.\n-      unsigned int temp = abs_con + 1;\n-      Node *n1 = phase->transform(new LShiftINode(in(1), phase->intcon(log2i_exact(temp))));\n-      res = new SubINode(n1, in(1));\n-    } else {\n-      return MulNode::Ideal(phase, can_reshape);\n-    }\n+    return MulNode::Ideal(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":25,"deletions":19,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,258 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Red Hat and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8325495\n+ * @summary C2 should optimize for series of Add of unique value. e.g., a + a + ... + a => a*n\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.TestSerialAdditions\n+ *\/\n+public class TestSerialAdditions {\n+    private static final Random RNG = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\n+            \"addTo2\",\n+            \"addTo3\",\n+            \"addTo4\",\n+            \"shiftAndAddTo4\",\n+            \"mulAndAddTo4\",\n+            \"addTo5\",\n+            \"addTo6\",\n+            \"addTo7\",\n+            \"addTo8\",\n+            \"addTo16\",\n+            \"addAndShiftTo16\",\n+            \"addTo42\",\n+            \"mulAndAddTo42\",\n+            \"mulAndAddToMax\",\n+            \"mulAndAddToOverflow\",\n+            \"mulAndAddToZero\",\n+            \"mulAndAddToMinus1\",\n+            \"mulAndAddToMinus42\"\n+    })\n+    private void runIntTests() {\n+        for (int a : new int[] { 0, 1, Integer.MIN_VALUE, Integer.MAX_VALUE, RNG.nextInt() }) {\n+            Asserts.assertEQ(a * 2, addTo2(a));\n+            Asserts.assertEQ(a * 3, addTo3(a));\n+            Asserts.assertEQ(a * 4, addTo4(a));\n+            Asserts.assertEQ(a * 4, shiftAndAddTo4(a));\n+            Asserts.assertEQ(a * 4, mulAndAddTo4(a));\n+            Asserts.assertEQ(a * 5, addTo5(a));\n+            Asserts.assertEQ(a * 6, addTo6(a));\n+            Asserts.assertEQ(a * 7, addTo7(a));\n+            Asserts.assertEQ(a * 8, addTo8(a));\n+            Asserts.assertEQ(a * 16, addTo16(a));\n+            Asserts.assertEQ(a * 16, addAndShiftTo16(a));\n+            Asserts.assertEQ(a * 42, addTo42(a));\n+            Asserts.assertEQ(a * 42, mulAndAddTo42(a));\n+            Asserts.assertEQ(a * Integer.MAX_VALUE, mulAndAddToMax(a));\n+            Asserts.assertEQ(a * Integer.MIN_VALUE, mulAndAddToOverflow(a));\n+            Asserts.assertEQ(0, mulAndAddToZero(a));\n+            Asserts.assertEQ(a * -1, mulAndAddToMinus1(a));\n+            Asserts.assertEQ(a * -42, mulAndAddToMinus42(a));\n+        }\n+    }\n+\n+    @Run(test = {\n+            \"mulAndAddToIntOverflowL\",\n+            \"mulAndAddToMaxL\",\n+            \"mulAndAddToOverflowL\"\n+    })\n+    private void runLongTests() {\n+        for (long a : new long[] { 0, 1, Long.MIN_VALUE, Long.MAX_VALUE, RNG.nextLong() }) {\n+            Asserts.assertEQ(a * (Integer.MAX_VALUE + 1L), mulAndAddToIntOverflowL(a));\n+            Asserts.assertEQ(a * Long.MAX_VALUE, mulAndAddToMaxL(a));\n+            Asserts.assertEQ(a * Long.MIN_VALUE, mulAndAddToOverflowL(a));\n+        }\n+    }\n+\n+    \/\/ ----- integer tests -----\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\" })\n+    @IR(failOn = IRNode.LSHIFT_I)\n+    private static int addTo2(int a) {\n+        return a + a; \/\/ Simple additions like a + a should be kept as-is\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo3(int a) {\n+        return a + a + a; \/\/ a*3 => (a<<1) + a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo4(int a) {\n+        return a + a + a + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int shiftAndAddTo4(int a) {\n+        return (a << 1) + a + a; \/\/ a*2 + a + a => a*3 + a => a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int mulAndAddTo4(int a) {\n+        return a * 3 + a; \/\/ a*4 => a<<2\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo5(int a) {\n+        return a + a + a + a + a; \/\/ a*5 => (a<<2) + a\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int addTo6(int a) {\n+        return a + a + a + a + a + a;\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int addTo7(int a) {\n+        return a + a + a + a + a + a + a; \/\/ a*7 => (a<<3) - a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo8(int a) {\n+        return a + a + a + a + a + a + a + a; \/\/ a*8 => a<<3\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addTo16(int a) {\n+        return a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a; \/\/ a*16 => a<<4\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int addAndShiftTo16(int a) {\n+        return (a + a) << 3; \/\/ a<<(3 + 1) => a<<4\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int addTo42(int a) {\n+        return a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a + a + a + a + a + a + a + a + a\n+                + a + a; \/\/ a*42\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int mulAndAddTo42(int a) {\n+        return a * 40 + a + a; \/\/ a*41 + a => a*42\n+    }\n+\n+    private static final int INT_MAX_MINUS_ONE = Integer.MAX_VALUE - 1;\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int mulAndAddToMax(int a) {\n+        return a * INT_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - a => (a<<31) - a\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\" })\n+    private static int mulAndAddToOverflow(int a) {\n+        return a * Integer.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<31\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.CON_I, \"1\" })\n+    private static int mulAndAddToZero(int a) {\n+        return a * -1 + a; \/\/ 0\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.LSHIFT_I, \"1\", IRNode.SUB_I, \"1\" })\n+    private static int mulAndAddToMinus1(int a) {\n+        return a * -2 + a; \/\/ a*-1 => a - (a<<1)\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_I)\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n+    private static int mulAndAddToMinus42(int a) {\n+        return a * -43 + a; \/\/ a*-42\n+    }\n+\n+    \/\/ --- long tests ---\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long mulAndAddToIntOverflowL(long a) {\n+        return a * Integer.MAX_VALUE + a; \/\/ a*(INT_MAX+1)\n+    }\n+\n+    private static final long LONG_MAX_MINUS_ONE = Long.MAX_VALUE - 1;\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\", IRNode.SUB_L, \"1\" })\n+    private static long mulAndAddToMaxL(long a) {\n+        return a * LONG_MAX_MINUS_ONE + a; \/\/ a*MAX => a*(MIN-1) => a*MIN - 1 => (a<<63) - 1\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.ADD_L)\n+    @IR(counts = { IRNode.LSHIFT_L, \"1\" })\n+    private static long mulAndAddToOverflowL(long a) {\n+        return a * Long.MAX_VALUE + a; \/\/ a*(MAX+1) => a*(MIN) => a<<63\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSerialAdditions.java","additions":258,"deletions":0,"binary":false,"changes":258,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,5 +40,6 @@\n-    @Run(test = {\"combineConstants\", \"moveConstants\", \"moveConstantsAgain\",\n-                 \"multiplyZero\", \"multiplyZeroAgain\", \"distribute\",\n-                 \"identity\",  \"identityAgain\", \"powerTwo\",\n-                 \"powerTwoAgain\", \"powerTwoPlusOne\", \"powerTwoMinusOne\",\n-                 \"negativeCancelledOut\", \"maxMin\"})\n+    @Run(test = { \"combineConstants\", \"moveConstants\", \"moveConstantsAgain\",\n+            \"multiplyZero\", \"multiplyZeroAgain\", \"distribute\",\n+            \"identity\", \"identityAgain\", \"powerTwo\", \"powerTwoAgain\",\n+            \"powerTwoPlusOne\", \"powerTwoMinusOne\", \"powerTwoPlusPowerTwo\",\n+            \"negativePowerTwoPlusPowerTwo\", \"negativePowerTwoPlusOne\",\n+            \"negativeCancelledOut\", \"maxMin\" })\n@@ -72,0 +73,3 @@\n+        Asserts.assertEQ(a * ((1 << 2) + (1 << 3))      , powerTwoPlusPowerTwo(a));\n+        Asserts.assertEQ(a * -((1 << 3) + (1 << 4))     , negativePowerTwoPlusPowerTwo(a));\n+        Asserts.assertEQ(a * -((1 << 3) + 1)            , negativePowerTwoPlusOne(a));\n@@ -170,0 +174,21 @@\n+    @Test\n+    @IR(counts = { IRNode.MUL, \"1\" })\n+    \/\/ Checks x * (2^m + 2^n) is not converted to (x << m) + (x << n)\n+    public int powerTwoPlusPowerTwo(int x) {\n+        return x * ((1 << 2) + (1 << 3));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MUL, \"1\" })\n+    \/\/ Checks x * -(2^m + 2^n) is not converted to -((x << m) + (x << n))\n+    public int negativePowerTwoPlusPowerTwo(int x) {\n+        return x * -((1 << 3) + (1 << 4));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MUL, \"1\" })\n+    \/\/ Checks x * (-(2^n+1)) is not converted to -((x << n) + x)\n+    public int negativePowerTwoPlusOne(int x) {\n+        return x * (-(1 + (1 << 3)));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulINodeIdealizationTests.java","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1056,1 +1056,1 @@\n-        return new Object[]{ a, b };\n+        return new Object[] { a, b };\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 2)\n+public class MultWithConst {\n+    @Param({ \"512\" })\n+    private static int SIZE;\n+    private int[] ints;\n+\n+    @Setup\n+    public void init() {\n+        ints = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = i;\n+        }\n+    }\n+\n+    \/\/ const = 2^n, (n > 0)\n+    \/\/ Test x * 8 => x << 3.\n+    @Benchmark\n+    public void testInt8(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 8);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt8AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * 8);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt8Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 8;\n+        }\n+    }\n+\n+    \/\/ const = 2^n + 1, (n > 0)\n+    \/\/ Test x * 9 => (x << 3) + x.\n+    @Benchmark\n+    public void testInt9(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 9);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt9AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += ints[i] * 9;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt9Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 9;\n+        }\n+    }\n+\n+    \/\/ const = 2^n - 1, (n > 0)\n+    \/\/ Test x * 7 => (x << 3) - x.\n+    @Benchmark\n+    public void testInt7(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 7);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt7AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * 7);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt7Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 7;\n+        }\n+    }\n+\n+    \/\/ const = 2^m + 2^n, (0 < m <= 4, 0 < n <= 4)\n+    \/\/ Test x * 18 vs (x << 4) + (x << 1).\n+    @Benchmark\n+    public void testInt18(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 18);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt18AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * 18);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt18Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 18;\n+        }\n+    }\n+\n+    \/\/ const = 2^m + 2^n, (m > 4, 0 < n <= 4)\n+    \/\/ Test x * 36 vs (x << 5) + (x << 2)\n+    @Benchmark\n+    public void testInt36(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 36);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt36AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * 36);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt36Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 36;\n+        }\n+    }\n+\n+    \/\/ const = 2^m + 2^n, (m > 4, n > 4)\n+    \/\/ Test x * 96 vs (x << 6) + (x << 5)\n+    @Benchmark\n+    public void testInt96(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 96);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt96AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * 96);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt96Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 96;\n+        }\n+    }\n+\n+    \/\/ Negatives\n+\n+    \/\/ const = -2^n, (n > 0)\n+    \/\/ Test x * -8 => -(x << 3).\n+    @Benchmark\n+    public void testIntN8(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -8);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN8AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += ints[i] * -8;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN8Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -8;\n+        }\n+    }\n+\n+    \/\/ const = -(2^n + 1), (0 < n <= 4)\n+    \/\/ Test x * -9 vs -((x << 3) + x).\n+    @Benchmark\n+    public void testIntN9(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -9);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN9AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += ints[i] * -9;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN9Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -9;\n+        }\n+    }\n+\n+    \/\/ const = -(2^n + 1), (n > 4)\n+    \/\/ Test x * -33 vs -((x << 5) + x).\n+    @Benchmark\n+    public void testIntN33(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -33);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN33AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += ints[i] * -33;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN33Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -33;\n+        }\n+    }\n+\n+    \/\/ const = -(2^n - 1), (n > 0)\n+    \/\/ Test x * -7 => x - (x << 3).\n+    @Benchmark\n+    public void testIntN7(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -7);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN7AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += ints[i] * -7;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN7Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -7;\n+        }\n+    }\n+\n+    \/\/ const = -(2^m + 2^n), (0 < m <= 4, 0 < n <= 4)\n+    \/\/ Test x * -18 vs -((x << 4) + (x << 1)).\n+    @Benchmark\n+    public void testIntN18(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -18);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN18AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * -18);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN18Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -18;\n+        }\n+    }\n+\n+    \/\/ const = -(2^m + 2^n), (m > 4, 0 < n <= 4)\n+    \/\/ Test x * -36 vs -((x << 5) + (x << 2))\n+    @Benchmark\n+    public void testIntN36(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -36);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN36AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * -36);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN36Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -36;\n+        }\n+    }\n+\n+    \/\/ const = -(2^m + 2^n), (m > 4, n > 4)\n+    \/\/ Test x * -96 vs -((x << 6) + (x << 5))\n+    @Benchmark\n+    public void testIntN96(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -96);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN96AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * -96);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN96Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -96;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MultWithConst.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"}]}