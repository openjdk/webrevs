{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -253,1 +253,11 @@\n-  \/\/ Get low bit; check for being the only bit\n+  \/\/ TODO: abs_con = (1<<m)+(1<<n) and con = -((1<<n)+1) was supported\n+  \/\/ originally, but they are disabled since it's not performing in some cases,\n+  \/\/ such as \"mul then add\" in a loop. On some architectures this can be\n+  \/\/ vectorized as a vector mul-add instruction, which is more performing than\n+  \/\/ two vector shifts and one vector add instruction.\n+  \/\/\n+  \/\/ Tests show that conversion is beneficial if constant multiplication is\n+  \/\/ converted to fewer than three normal or vector shift and add instructions.\n+  \/\/\n+  \/\/ But if it's not vectorizable, maybe it's profitable to do the conversion on\n+  \/\/ some architectures, support it in backends if it's worthwhile.\n@@ -255,3 +265,13 @@\n-  unsigned int bit1 = submultiple_power_of_2(abs_con);\n-  if (bit1 == abs_con) {           \/\/ Found a power of 2?\n-    res = new LShiftINode(in(1), phase->intcon(log2i_exact(bit1)));\n+  if (is_power_of_2(abs_con)) {\n+    \/\/ abs_con = 1<<n, (n > 0)\n+    res = new LShiftINode(in(1), phase->intcon(log2i_exact(abs_con)));\n+  } else if (is_power_of_2(abs_con - 1) && !sign_flip) {\n+    \/\/ con = (1<<n) + 1, (n > 0)\n+    Node* n1 = phase->transform(\n+        new LShiftINode(in(1), phase->intcon(log2i_exact(abs_con - 1))));\n+    res = new AddINode(in(1), n1);\n+  } else if (is_power_of_2(abs_con + 1)) {\n+    \/\/ abs_con = (1<<n) - 1, (n > 0)\n+    Node* n1 = phase->transform(\n+        new LShiftINode(in(1), phase->intcon(log2i_exact(abs_con + 1))));\n+    res = new SubINode(n1, in(1));\n@@ -259,15 +279,1 @@\n-    \/\/ Check for constant with 2 bits set\n-    unsigned int bit2 = abs_con - bit1;\n-    bit2 = bit2 & (0 - bit2);          \/\/ Extract 2nd bit\n-    if (bit2 + bit1 == abs_con) {    \/\/ Found all bits in con?\n-      Node *n1 = phase->transform(new LShiftINode(in(1), phase->intcon(log2i_exact(bit1))));\n-      Node *n2 = phase->transform(new LShiftINode(in(1), phase->intcon(log2i_exact(bit2))));\n-      res = new AddINode(n2, n1);\n-    } else if (is_power_of_2(abs_con + 1)) {\n-      \/\/ Sleezy: power-of-2 - 1.  Next time be generic.\n-      unsigned int temp = abs_con + 1;\n-      Node *n1 = phase->transform(new LShiftINode(in(1), phase->intcon(log2i_exact(temp))));\n-      res = new SubINode(n1, in(1));\n-    } else {\n-      return MulNode::Ideal(phase, can_reshape);\n-    }\n+    return MulNode::Ideal(phase, can_reshape);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Red Hat and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n@@ -145,1 +146,1 @@\n-    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"2\" })\n+    @IR(counts = { IRNode.MUL_I, \"1\" })\n@@ -147,1 +148,1 @@\n-        return a + a + a + a + a + a; \/\/ a*6 => (a<<1) + (a<<2)\n+        return a + a + a + a + a + a;\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestSerialAdditions.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,5 +40,6 @@\n-    @Run(test = {\"combineConstants\", \"moveConstants\", \"moveConstantsAgain\",\n-                 \"multiplyZero\", \"multiplyZeroAgain\", \"distribute\",\n-                 \"identity\",  \"identityAgain\", \"powerTwo\",\n-                 \"powerTwoAgain\", \"powerTwoPlusOne\", \"powerTwoMinusOne\",\n-                 \"negativeCancelledOut\", \"maxMin\"})\n+    @Run(test = { \"combineConstants\", \"moveConstants\", \"moveConstantsAgain\",\n+            \"multiplyZero\", \"multiplyZeroAgain\", \"distribute\",\n+            \"identity\", \"identityAgain\", \"powerTwo\", \"powerTwoAgain\",\n+            \"powerTwoPlusOne\", \"powerTwoMinusOne\", \"powerTwoPlusPowerTwo\",\n+            \"negativePowerTwoPlusPowerTwo\", \"negativePowerTwoPlusOne\",\n+            \"negativeCancelledOut\", \"maxMin\" })\n@@ -72,0 +73,3 @@\n+        Asserts.assertEQ(a * ((1 << 2) + (1 << 3))      , powerTwoPlusPowerTwo(a));\n+        Asserts.assertEQ(a * -((1 << 3) + (1 << 4))     , negativePowerTwoPlusPowerTwo(a));\n+        Asserts.assertEQ(a * -((1 << 3) + 1)            , negativePowerTwoPlusOne(a));\n@@ -170,0 +174,21 @@\n+    @Test\n+    @IR(counts = { IRNode.MUL, \"1\" })\n+    \/\/ Checks x * (2^m + 2^n) is not converted to (x << m) + (x << n)\n+    public int powerTwoPlusPowerTwo(int x) {\n+        return x * ((1 << 2) + (1 << 3));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MUL, \"1\" })\n+    \/\/ Checks x * -(2^m + 2^n) is not converted to -((x << m) + (x << n))\n+    public int negativePowerTwoPlusPowerTwo(int x) {\n+        return x * -((1 << 3) + (1 << 4));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MUL, \"1\" })\n+    \/\/ Checks x * (-(2^n+1)) is not converted to -((x << n) + x)\n+    public int negativePowerTwoPlusOne(int x) {\n+        return x * (-(1 + (1 << 3)));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulINodeIdealizationTests.java","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1042,5 +1042,12 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n-                  IRNode.AND_VB, \"= 0\",\n-                  IRNode.STORE_VECTOR, \"= 0\"},\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = { IRNode.LOAD_VECTOR_B, \"= 0\",\n+                   IRNode.AND_VB, \"= 0\",\n+                   IRNode.STORE_VECTOR, \"= 0\" },\n+        applyIfPlatform = { \"64-bit\", \"true\" },\n+        applyIf = { \"AlignVector\", \"true\" },\n+        applyIfCPUFeatureOr = { \"sse4.1\", \"true\", \"asimd\", \"true\" })\n+    @IR(counts = { IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                   IRNode.AND_VB, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                   IRNode.STORE_VECTOR, \"> 0\" },\n+        applyIfPlatform = { \"64-bit\", \"true\" },\n+        applyIf = { \"AlignVector\", \"false\" },\n+        applyIfCPUFeatureOr = { \"sse4.1\", \"true\", \"asimd\", \"true\" })\n@@ -1048,6 +1055,5 @@\n-        for (int i = 0; i < RANGE\/16; i++) {\n-            \/\/ Currently does not vectorize at all\n-            b[i*6 + 0 ] = (byte)(a[i*6 + 0 ] & mask);\n-            b[i*6 + 1 ] = (byte)(a[i*6 + 1 ] & mask);\n-            b[i*6 + 2 ] = (byte)(a[i*6 + 2 ] & mask);\n-            b[i*6 + 3 ] = (byte)(a[i*6 + 3 ] & mask);\n+        for (int i = 0; i < RANGE \/ 16; i++) {\n+            b[i * 6 + 0] = (byte) (a[i * 6 + 0] & mask);\n+            b[i * 6 + 1] = (byte) (a[i * 6 + 1] & mask);\n+            b[i * 6 + 2] = (byte) (a[i * 6 + 2] & mask);\n+            b[i * 6 + 3] = (byte) (a[i * 6 + 3] & mask);\n@@ -1055,1 +1061,1 @@\n-        return new Object[]{ a, b };\n+        return new Object[] { a, b };\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestAlignVector.java","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 2)\n+public class MultWithConst {\n+    @Param({ \"512\" })\n+    private static int SIZE;\n+    private int[] ints;\n+\n+    @Setup\n+    public void init() {\n+        ints = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = i;\n+        }\n+    }\n+\n+    \/\/ const = 2^n, (n > 0)\n+    \/\/ Test x * 8 => x << 3.\n+    @Benchmark\n+    public void testInt8(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 8);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt8AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * 8);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt8Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 8;\n+        }\n+    }\n+\n+    \/\/ const = 2^n + 1, (n > 0)\n+    \/\/ Test x * 9 => (x << 3) + x.\n+    @Benchmark\n+    public void testInt9(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 9);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt9AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += ints[i] * 9;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt9Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 9;\n+        }\n+    }\n+\n+    \/\/ const = 2^n - 1, (n > 0)\n+    \/\/ Test x * 7 => (x << 3) - x.\n+    @Benchmark\n+    public void testInt7(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 7);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt7AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * 7);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt7Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 7;\n+        }\n+    }\n+\n+    \/\/ const = 2^m + 2^n, (0 < m <= 4, 0 < n <= 4)\n+    \/\/ Test x * 18 vs (x << 4) + (x << 1).\n+    @Benchmark\n+    public void testInt18(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 18);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt18AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * 18);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt18Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 18;\n+        }\n+    }\n+\n+    \/\/ const = 2^m + 2^n, (m > 4, 0 < n <= 4)\n+    \/\/ Test x * 36 vs (x << 5) + (x << 2)\n+    @Benchmark\n+    public void testInt36(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 36);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt36AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * 36);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt36Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 36;\n+        }\n+    }\n+\n+    \/\/ const = 2^m + 2^n, (m > 4, n > 4)\n+    \/\/ Test x * 96 vs (x << 6) + (x << 5)\n+    @Benchmark\n+    public void testInt96(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * 96);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testInt96AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * 96);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testInt96Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * 96;\n+        }\n+    }\n+\n+    \/\/ Negatives\n+\n+    \/\/ const = -2^n, (n > 0)\n+    \/\/ Test x * -8 => -(x << 3).\n+    @Benchmark\n+    public void testIntN8(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -8);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN8AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += ints[i] * -8;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN8Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -8;\n+        }\n+    }\n+\n+    \/\/ const = -(2^n + 1), (0 < n <= 4)\n+    \/\/ Test x * -9 vs -((x << 3) + x).\n+    @Benchmark\n+    public void testIntN9(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -9);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN9AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += ints[i] * -9;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN9Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -9;\n+        }\n+    }\n+\n+    \/\/ const = -(2^n + 1), (n > 4)\n+    \/\/ Test x * -33 vs -((x << 5) + x).\n+    @Benchmark\n+    public void testIntN33(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -33);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN33AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += ints[i] * -33;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN33Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -33;\n+        }\n+    }\n+\n+    \/\/ const = -(2^n - 1), (n > 0)\n+    \/\/ Test x * -7 => x - (x << 3).\n+    @Benchmark\n+    public void testIntN7(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -7);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN7AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += ints[i] * -7;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN7Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -7;\n+        }\n+    }\n+\n+    \/\/ const = -(2^m + 2^n), (0 < m <= 4, 0 < n <= 4)\n+    \/\/ Test x * -18 vs -((x << 4) + (x << 1)).\n+    @Benchmark\n+    public void testIntN18(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -18);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN18AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * -18);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN18Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -18;\n+        }\n+    }\n+\n+    \/\/ const = -(2^m + 2^n), (m > 4, 0 < n <= 4)\n+    \/\/ Test x * -36 vs -((x << 5) + (x << 2))\n+    @Benchmark\n+    public void testIntN36(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -36);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN36AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * -36);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN36Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -36;\n+        }\n+    }\n+\n+    \/\/ const = -(2^m + 2^n), (m > 4, n > 4)\n+    \/\/ Test x * -96 vs -((x << 6) + (x << 5))\n+    @Benchmark\n+    public void testIntN96(Blackhole blackhole) {\n+        for (int i = 0; i < SIZE; i++) {\n+            blackhole.consume(ints[i] * -96);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int testIntN96AddSum() {\n+        int sum = 0;\n+        for (int i = 0; i < SIZE; i++) {\n+            sum += (ints[i] * -96);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public void testIntN96Store() {\n+        for (int i = 0; i < SIZE; i++) {\n+            ints[i] = ints[i] * -96;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/MultWithConst.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"}]}