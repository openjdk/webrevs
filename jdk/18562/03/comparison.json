{"files":[{"patch":"@@ -118,0 +118,4 @@\n+                                                                            \\\n+  product(bool, UseAPX, false, EXPERIMENTAL,                                \\\n+          \"Use Intel Advanced Performance Extensions\")                      \\\n+                                                                            \\\n@@ -237,2 +241,0 @@\n-  product(bool, UseAPX, false, EXPERIMENTAL,                                \\\n-          \"Use Advanced Performance Extensions on x86\")                     \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,0 +59,4 @@\n+\/\/ Address of instruction which causes APX specific SEGV\n+address VM_Version::_cpuinfo_segv_addr_apx = 0;\n+\/\/ Address of instruction after the one which causes APX specific SEGV\n+address VM_Version::_cpuinfo_cont_addr_apx = 0;\n@@ -66,0 +70,1 @@\n+  typedef void (*clear_apx_test_state_t)(void);\n@@ -69,0 +74,1 @@\n+static clear_apx_test_state_t clear_apx_test_state_stub = nullptr;\n@@ -105,0 +111,21 @@\n+  address clear_apx_test_state() {\n+#   define __ _masm->\n+    address start = __ pc();\n+    \/\/ EGPRs are call clobbered registers, Explicit clearing of r16 and r31 during signal\n+    \/\/ handling guarantees that preserved register values post signal handling were\n+    \/\/ re-instantiated by operating system and not because they were not modified externally.\n+\n+    \/* FIXME Uncomment following code after OS enablement of\n+    bool save_apx = UseAPX;\n+    VM_Version::set_apx_cpuFeatures();\n+    UseAPX = true;\n+    \/\/ EGPR state save\/restoration.\n+    __ mov64(r16, 0L);\n+    __ mov64(r31, 0L);\n+    UseAPX = save_apx;\n+    VM_Version::clean_cpuFeatures();\n+    *\/\n+    __ ret(0);\n+    return start;\n+  }\n+\n@@ -116,1 +143,2 @@\n-    Label sef_cpuid, ext_cpuid, ext_cpuid1, ext_cpuid5, ext_cpuid7, ext_cpuid8, done, wrapup;\n+    Label sef_cpuid, sefsl1_cpuid, ext_cpuid, ext_cpuid1, ext_cpuid5, ext_cpuid7;\n+    Label ext_cpuid8, done, wrapup, vector_save_restore, apx_save_restore_warning;\n@@ -291,1 +319,1 @@\n-    \/\/ cpuid(0x7) Structured Extended Features\n+    \/\/ cpuid(0x7) Structured Extended Features Enumeration Leaf.\n@@ -306,1 +334,4 @@\n-    \/\/ ECX = 1\n+    \/\/\n+    \/\/ cpuid(0x7) Structured Extended Features Enumeration Sub-Leaf 1.\n+    \/\/\n+    __ bind(sefsl1_cpuid);\n@@ -310,1 +341,1 @@\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_ecx1_offset())));\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::sefsl1_cpuid7_offset())));\n@@ -312,0 +343,1 @@\n+    __ movl(Address(rsi, 4), rdx);\n@@ -390,0 +422,40 @@\n+#ifndef PRODUCT\n+    \/\/\n+    \/\/ Check if OS has enabled XGETBV instruction to access XCR0\n+    \/\/ (OSXSAVE feature flag) and CPU supports APX\n+    \/\/\n+    \/\/ To enable APX, check CPUID.EAX=7.ECX=1.EDX[21] bit for HW support\n+    \/\/ and XCRO[19] bit for OS support to save\/restore extended GPR state.\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::sefsl1_cpuid7_offset())));\n+    __ movl(rax, 0x200000);\n+    __ andl(rax, Address(rsi, 4));\n+    __ cmpl(rax, 0x200000);\n+    __ jcc(Assembler::notEqual, vector_save_restore);\n+    \/\/ check _cpuid_info.xem_xcr0_eax.bits.apx_f\n+    __ movl(rax, 0x80000);\n+    __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); \/\/ xcr0 bits apx_f\n+    __ cmpl(rax, 0x80000);\n+    __ jcc(Assembler::notEqual, vector_save_restore);\n+\n+    \/* FIXME: Uncomment while integrating JDK-8329032\n+    bool save_apx = UseAPX;\n+    VM_Version::set_apx_cpuFeatures();\n+    UseAPX = true;\n+    __ mov64(r16, VM_Version::egpr_test_value());\n+    __ mov64(r31, VM_Version::egpr_test_value());\n+    *\/\n+    __ xorl(rsi, rsi);\n+    VM_Version::set_cpuinfo_segv_addr_apx(__ pc());\n+    \/\/ Generate SEGV\n+    __ movl(rax, Address(rsi, 0));\n+\n+    VM_Version::set_cpuinfo_cont_addr_apx(__ pc());\n+    \/* FIXME: Uncomment after integration of JDK-8329032\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::apx_save_offset())));\n+    __ movq(Address(rsi, 0), r16);\n+    __ movq(Address(rsi, 8), r31);\n+\n+    UseAPX = save_apx;\n+    *\/\n+#endif\n+    __ bind(vector_save_restore);\n@@ -583,0 +655,1 @@\n+\n@@ -943,0 +1016,1 @@\n+\n@@ -966,0 +1040,10 @@\n+    _features &= ~CPU_APX_F;\n+  }\n+\n+  \/\/ Currently APX support is only enabled for targets supporting AVX512VL feature.\n+  bool apx_supported = os_supports_apx_egprs() && supports_apx_f() && supports_avx512vl();\n+  if (UseAPX && !apx_supported) {\n+    warning(\"UseAPX is not supported on this CPU, setting it to false\");\n+    FLAG_SET_DEFAULT(UseAPX, false);\n+  } else if (FLAG_IS_DEFAULT(UseAPX)) {\n+    FLAG_SET_DEFAULT(UseAPX, apx_supported ? true : false);\n@@ -1005,8 +1089,0 @@\n-  \/\/ APX support not enabled yet\n-  if (UseAPX) {\n-    if (!FLAG_IS_DEFAULT(UseAPX)) {\n-        warning(\"APX is not supported on this CPU.\");\n-    }\n-    FLAG_SET_DEFAULT(UseAPX, false);\n-  }\n-\n@@ -2146,0 +2222,4 @@\n+void VM_Version::clear_apx_test_state() {\n+  clear_apx_test_state_stub();\n+}\n+\n@@ -2163,0 +2243,2 @@\n+  clear_apx_test_state_stub = CAST_TO_FN_PTR(clear_apx_test_state_t,\n+                                     g.clear_apx_test_state());\n@@ -2961,0 +3043,4 @@\n+  if (sefsl1_cpuid7_edx.bits.apx_f != 0 &&\n+      xem_xcr0_eax.bits.apx_f != 0) {\n+    result |= CPU_APX_F;\n+  }\n@@ -2971,1 +3057,1 @@\n-      if (sef_cpuid7_ecx1_eax.bits.avx_ifma != 0)\n+      if (sefsl1_cpuid7_eax.bits.avx_ifma != 0)\n@@ -3145,0 +3231,11 @@\n+bool VM_Version::os_supports_apx_egprs() {\n+  if (!supports_apx_f()) {\n+    return false;\n+  }\n+  if (_cpuid_info.apx_save[0] != egpr_test_value() ||\n+      _cpuid_info.apx_save[1] != egpr_test_value()) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":110,"deletions":13,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -282,1 +283,1 @@\n-  union SefCpuid7Ecx1Eax {\n+  union SefCpuid7SubLeaf1Eax {\n@@ -291,0 +292,9 @@\n+  union SefCpuid7SubLeaf1Edx {\n+    uint32_t value;\n+    struct {\n+      uint32_t       : 21,\n+              apx_f  : 1,\n+                     : 10;\n+    } bits;\n+  };\n+\n@@ -311,1 +321,3 @@\n-                       : 24;\n+                       : 11,\n+               apx_f   : 1,\n+                       : 12;\n@@ -322,2 +334,4 @@\n-  static address   _cpuinfo_segv_addr; \/\/ address of instruction which causes SEGV\n-  static address   _cpuinfo_cont_addr; \/\/ address of instruction after the one which causes SEGV\n+  static address   _cpuinfo_segv_addr;     \/\/ address of instruction which causes SEGV\n+  static address   _cpuinfo_cont_addr;     \/\/ address of instruction after the one which causes SEGV\n+  static address   _cpuinfo_segv_addr_apx; \/\/ address of instruction which causes APX specific SEGV\n+  static address   _cpuinfo_cont_addr_apx; \/\/ address of instruction after the one which causes APX specific SEGV\n@@ -403,1 +417,2 @@\n-    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/\n+    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/ \\\n+    decl(APX_F,             \"apx_f\",             60) \/* Intel Advanced Performance Extensions*\/\n@@ -461,2 +476,2 @@\n-    \/\/ cpuid function 7 (structured extended features)\n-    \/\/ ECX = 0 before calling cpuid()\n+    \/\/ cpuid function 7 (structured extended features enumeration leaf)\n+    \/\/ eax = 7, ecx = 0\n@@ -467,2 +482,5 @@\n-    \/\/ ECX = 1 before calling cpuid()\n-    SefCpuid7Ecx1Eax sef_cpuid7_ecx1_eax;\n+\n+    \/\/ cpuid function 7 (structured extended features enumeration sub-leaf 1)\n+    \/\/ eax = 7, ecx = 1\n+    SefCpuid7SubLeaf1Eax sefsl1_cpuid7_eax;\n+    SefCpuid7SubLeaf1Edx sefsl1_cpuid7_edx;\n@@ -540,0 +558,3 @@\n+    \/\/ Space to save apx registers after signal handle\n+    jlong        apx_save[2]; \/\/ Save r16 and r31\n+\n@@ -579,0 +600,1 @@\n+  static bool os_supports_apx_egprs();\n@@ -587,1 +609,1 @@\n-  static ByteSize sef_cpuid7_ecx1_offset() { return byte_offset_of(CpuidInfo, sef_cpuid7_ecx1_eax); }\n+  static ByteSize sefsl1_cpuid7_offset() { return byte_offset_of(CpuidInfo, sefsl1_cpuid7_eax); }\n@@ -599,0 +621,1 @@\n+  static ByteSize apx_save_offset() { return byte_offset_of(CpuidInfo, apx_save); }\n@@ -602,0 +625,1 @@\n+  static jlong egpr_test_value()   { return 0xCAFEBABECAFEBABELL; }\n@@ -609,0 +633,7 @@\n+  static void set_cpuinfo_segv_addr_apx(address pc) { _cpuinfo_segv_addr_apx = pc; }\n+  static bool  is_cpuinfo_segv_addr_apx(address pc) { return _cpuinfo_segv_addr_apx == pc; }\n+  static void set_cpuinfo_cont_addr_apx(address pc) { _cpuinfo_cont_addr_apx = pc; }\n+  static address  cpuinfo_cont_addr_apx()           { return _cpuinfo_cont_addr_apx; }\n+\n+  static void clear_apx_test_state();\n+\n@@ -612,0 +643,1 @@\n+  static void set_apx_cpuFeatures() { _features |= CPU_APX_F; }\n@@ -708,0 +740,1 @@\n+  static bool supports_apx_f()        { return (_features & CPU_APX_F) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":43,"deletions":10,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2692,0 +2692,9 @@\n+\n+#ifndef PRODUCT\n+  if ((exception_code == EXCEPTION_ACCESS_VIOLATION) &&\n+      VM_Version::is_cpuinfo_segv_addr_apx(pc)) {\n+    \/\/ Verify that OS save\/restore APX registers.\n+    VM_Version::clear_apx_test_state();\n+    return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr_apx());\n+  }\n+#endif\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -419,0 +419,8 @@\n+#ifndef PRODUCT\n+    if ((sig == SIGSEGV || sig == SIGBUS) && VM_Version::is_cpuinfo_segv_addr_apx(pc)) {\n+      \/\/ Verify that OS save\/restore APX registers.\n+      stub = VM_Version::cpuinfo_cont_addr_apx();\n+      VM_Version::clear_apx_test_state();\n+    }\n+#endif\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -251,0 +251,8 @@\n+#ifndef PRODUCT\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr_apx(pc)) {\n+      \/\/ Verify that OS save\/restore APX registers.\n+      stub = VM_Version::cpuinfo_cont_addr_apx();\n+      VM_Version::clear_apx_test_state();\n+    }\n+#endif\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -236,0 +236,1 @@\n+        APX_F,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,1 +68,2 @@\n-                    \"cet_ss\",       \"avx512_ifma\",      \"serialize\",         \"avx_ifma\"\n+                    \"cet_ss\",       \"avx512_ifma\",      \"serialize\",         \"avx_ifma\",\n+                    \"apx_f\"\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}