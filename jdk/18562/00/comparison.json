{"files":[{"patch":"@@ -118,0 +118,4 @@\n+                                                                            \\\n+  product(bool, UseAPX, false, EXPERIMENTAL,                                \\\n+          \"Use Intel Advanced Performance Extensions\")                      \\\n+                                                                            \\\n@@ -237,2 +241,0 @@\n-  product(bool, UseAPX, false, EXPERIMENTAL,                                \\\n-          \"Use Advanced Performance Extensions on x86\")                     \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,0 +59,6 @@\n+\/\/ Address of instruction which causes APX specific SEGV\n+address VM_Version::_cpuinfo_segv_addr_apx = 0;\n+\/\/ Address of instruction after the one which causes APX specific SEGV\n+address VM_Version::_cpuinfo_cont_addr_apx = 0;\n+\/\/ Address of apx state restore error handler.\n+address VM_Version::_apx_state_restore_error_handler = (address)VM_Version::report_apx_state_restore_error;\n@@ -66,0 +72,1 @@\n+  typedef void (*clear_apx_test_state_t)(void);\n@@ -69,0 +76,1 @@\n+static clear_apx_test_state_t clear_apx_test_state_stub = nullptr;\n@@ -105,0 +113,12 @@\n+  address clear_apx_test_state() {\n+#   define __ _masm->\n+    address start = __ pc();\n+    \/\/__ mov64(r15, 0L);\n+    \/\/ FIXME Uncomment following code after OS enablement of\n+    \/\/ EGPR state save\/restoration.\n+    \/\/__ mov64(r16, 0L);\n+    \/\/__ mov64(r31, 0L);\n+    __ ret(0);\n+    return start;\n+  }\n+\n@@ -116,1 +136,2 @@\n-    Label sef_cpuid, ext_cpuid, ext_cpuid1, ext_cpuid5, ext_cpuid7, ext_cpuid8, done, wrapup;\n+    Label sef_cpuid, sefsl1_cpuid, ext_cpuid, ext_cpuid1, ext_cpuid5, ext_cpuid7;\n+    Label ext_cpuid8, done, wrapup, vector_save_restore, apx_save_restore_error;\n@@ -291,1 +312,1 @@\n-    \/\/ cpuid(0x7) Structured Extended Features\n+    \/\/ cpuid(0x7) Structured Extended Features Enumeration Leaf.\n@@ -306,1 +327,4 @@\n-    \/\/ ECX = 1\n+    \/\/\n+    \/\/ cpuid(0x7) Structured Extended Features Enumeration Sub-Leaf 1.\n+    \/\/\n+    __ bind(sefsl1_cpuid);\n@@ -310,1 +334,1 @@\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version::sef_cpuid7_ecx1_offset())));\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::sefsl1_cpuid7_offset())));\n@@ -312,0 +336,1 @@\n+    __ movl(Address(rsi, 4), rdx);\n@@ -390,0 +415,46 @@\n+#ifndef PRODUCT\n+    \/\/\n+    \/\/ Check if OS has enabled XGETBV instruction to access XCR0\n+    \/\/ (OSXSAVE feature flag) and CPU supports APX\n+    \/\/\n+    \/\/ To enable APX, check CPUID.EAX=7.ECX=1.EDX[21] bit for HW support\n+    \/\/ and XCRO[19] bit for OS support to save\/restore extended GPR state.\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::sefsl1_cpuid7_offset())));\n+    __ movl(rax, 0x200000);\n+    __ andl(rax, Address(rsi, 4));\n+    __ cmpl(rax, 0x200000);\n+    __ jcc(Assembler::notEqual, vector_save_restore);\n+    \/\/ check _cpuid_info.xem_xcr0_eax.bits.apx_f\n+    __ movl(rax, 0x80000);\n+    __ andl(rax, Address(rbp, in_bytes(VM_Version::xem_xcr0_offset()))); \/\/ xcr0 bits apx_f\n+    __ cmpl(rax, 0x80000);\n+    __ jcc(Assembler::notEqual, vector_save_restore);\n+\n+    \/* FIXME: Uncomment after integration of JDK-8328998\n+    __ mov64(r15, VM_Version::egpr_test_value());\n+    __ mov64(r16, VM_Version::egpr_test_value());\n+    __ mov64(r31, VM_Version::egpr_test_value());\n+    *\/\n+    __ xorl(rsi, rsi);\n+    VM_Version::set_cpuinfo_segv_addr_apx(__ pc());\n+    \/\/ Generate SEGV\n+    __ movl(rax, Address(rsi, 0));\n+\n+    VM_Version::set_cpuinfo_cont_addr_apx(__ pc());\n+    \/\/ Validate the contents of r15, r16 and r31\n+    \/* FIXME: Uncomment after integration of JDK-8328998\n+    __ mov64(rax, VM_Version::egpr_test_value());\n+    __ cmpq(rax, r15);\n+    __ jccb(Assembler::notEqual, apx_save_restore_error);\n+    __ cmpq(rax, r16);\n+    __ jccb(Assembler::notEqual, apx_save_restore_error);\n+    __ cmpq(rax, r31);\n+    __ jccb(Assembler::equal, vector_save_restore);\n+\n+    \/\/ Generate SEGV to signal unsuccessful save\/restore.\n+    __ bind(apx_save_restore_error);\n+    __ lea(rax, ExternalAddress(VM_Version::_apx_state_restore_error_handler));\n+    __ call(rax);\n+    *\/\n+#endif\n+    __ bind(vector_save_restore);\n@@ -583,0 +654,1 @@\n+\n@@ -968,0 +1040,9 @@\n+  \/\/ Currently APX support is only enabled for targets supporting AVX512VL feature.\n+  if (UseAPX && (!supports_apx_f() || !supports_avx512vl())) {\n+    warning(\"UseAPX is not supported on this CPU, setting it to false\");\n+    FLAG_SET_DEFAULT(UseAPX, false);\n+  } else if (FLAG_IS_DEFAULT(UseAPX)) {\n+    FLAG_SET_DEFAULT(UseAPX, (supports_apx_f() && supports_avx512vl()) ? true : false);\n+  }\n+\n+\n@@ -1005,8 +1086,0 @@\n-  \/\/ APX support not enabled yet\n-  if (UseAPX) {\n-    if (!FLAG_IS_DEFAULT(UseAPX)) {\n-        warning(\"APX is not supported on this CPU.\");\n-    }\n-    FLAG_SET_DEFAULT(UseAPX, false);\n-  }\n-\n@@ -2146,0 +2219,4 @@\n+void VM_Version::clear_apx_test_state() {\n+  clear_apx_test_state_stub();\n+}\n+\n@@ -2163,0 +2240,2 @@\n+  clear_apx_test_state_stub = CAST_TO_FN_PTR(clear_apx_test_state_t,\n+                                     g.clear_apx_test_state());\n@@ -2961,0 +3040,4 @@\n+  if (sefsl1_cpuid7_edx.bits.apx_f != 0 &&\n+      xem_xcr0_eax.bits.apx_f != 0) {\n+    result |= CPU_APX_F;\n+  }\n@@ -2971,1 +3054,1 @@\n-      if (sef_cpuid7_ecx1_eax.bits.avx_ifma != 0)\n+      if (sefsl1_cpuid7_eax.bits.avx_ifma != 0)\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":96,"deletions":13,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -282,1 +283,1 @@\n-  union SefCpuid7Ecx1Eax {\n+  union SefCpuid7SubLeaf1Eax {\n@@ -291,0 +292,9 @@\n+  union SefCpuid7SubLeaf1Edx {\n+    uint32_t value;\n+    struct {\n+      uint32_t       : 21,\n+              apx_f  : 1,\n+                     : 10;\n+    } bits;\n+  };\n+\n@@ -311,1 +321,3 @@\n-                       : 24;\n+                       : 11,\n+               apx_f   : 1,\n+                       : 12;\n@@ -322,2 +334,4 @@\n-  static address   _cpuinfo_segv_addr; \/\/ address of instruction which causes SEGV\n-  static address   _cpuinfo_cont_addr; \/\/ address of instruction after the one which causes SEGV\n+  static address   _cpuinfo_segv_addr;     \/\/ address of instruction which causes SEGV\n+  static address   _cpuinfo_cont_addr;     \/\/ address of instruction after the one which causes SEGV\n+  static address   _cpuinfo_segv_addr_apx; \/\/ address of instruction which causes APX specific SEGV\n+  static address   _cpuinfo_cont_addr_apx; \/\/ address of instruction which causes APX specific SEGV\n@@ -403,1 +417,2 @@\n-    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/\n+    decl(AVX_IFMA,          \"avx_ifma\",          59) \/* 256-bit VEX-coded variant of AVX512-IFMA*\/ \\\n+    decl(APX_F,             \"apx_f\",             60) \/* Intel Advanced Performance Extensions*\/\n@@ -461,2 +476,1 @@\n-    \/\/ cpuid function 7 (structured extended features)\n-    \/\/ ECX = 0 before calling cpuid()\n+    \/\/ cpuid function 7 (structured extended features enumeration leaf)\n@@ -467,2 +481,5 @@\n-    \/\/ ECX = 1 before calling cpuid()\n-    SefCpuid7Ecx1Eax sef_cpuid7_ecx1_eax;\n+\n+    \/\/ cpuid function 7 (structured extended features enumeration sub-leaf 1)\n+    \/\/ eax = 7, ecx = 1\n+    SefCpuid7SubLeaf1Eax sefsl1_cpuid7_eax;\n+    SefCpuid7SubLeaf1Edx sefsl1_cpuid7_edx;\n@@ -587,1 +604,1 @@\n-  static ByteSize sef_cpuid7_ecx1_offset() { return byte_offset_of(CpuidInfo, sef_cpuid7_ecx1_eax); }\n+  static ByteSize sefsl1_cpuid7_offset() { return byte_offset_of(CpuidInfo, sefsl1_cpuid7_eax); }\n@@ -602,0 +619,2 @@\n+  static long long egpr_test_value()   { return 0xCAFEBABECAFEBABEULL; }\n+  static void report_apx_state_restore_error() { report_vm_error(__FILE__, __LINE__,\"Unsuccessful APX state restoration.\\n\"); }\n@@ -609,0 +628,9 @@\n+  static void set_cpuinfo_segv_addr_apx(address pc) { _cpuinfo_segv_addr_apx = pc; }\n+  static bool  is_cpuinfo_segv_addr_apx(address pc) { return _cpuinfo_segv_addr_apx == pc; }\n+  static void set_cpuinfo_cont_addr_apx(address pc) { _cpuinfo_cont_addr_apx = pc; }\n+  static address  cpuinfo_cont_addr_apx()           { return _cpuinfo_cont_addr_apx; }\n+  \/\/ address of apx state restore error handler.\n+  static address _apx_state_restore_error_handler;\n+\n+  static void clear_apx_test_state();\n+\n@@ -612,0 +640,1 @@\n+  static void set_apx_cpuFeatures() { _features |= CPU_APX_F; }\n@@ -708,0 +737,1 @@\n+  static bool supports_apx_f()        { return (_features & CPU_APX_F) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2692,0 +2692,9 @@\n+\n+#ifndef PRODUCT\n+  if ((exception_code == EXCEPTION_ACCESS_VIOLATION) &&\n+      VM_Version::is_cpuinfo_segv_addr_apx(pc)) {\n+    \/\/ Verify that OS save\/restore APX registers.\n+    VM_Version::clear_apx_test_state();\n+    return Handle_Exception(exceptionInfo, VM_Version::cpuinfo_cont_addr_apx());\n+  }\n+#endif\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -419,0 +419,8 @@\n+#ifndef PRODUCT\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr_apx(pc)) {\n+      \/\/ Verify that OS save\/restore APX registers.\n+      stub = VM_Version::cpuinfo_cont_addr_apx();\n+      VM_Version::clear_apx_test_state();\n+    }\n+#endif\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -251,0 +251,8 @@\n+#ifndef PRODUCT\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr_apx(pc)) {\n+      \/\/ Verify that OS save\/restore APX registers.\n+      stub = VM_Version::cpuinfo_cont_addr_apx();\n+      VM_Version::clear_apx_test_state();\n+    }\n+#endif\n+\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -236,0 +236,1 @@\n+        APX_F,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,1 +68,2 @@\n-                    \"cet_ss\",       \"avx512_ifma\",      \"serialize\",         \"avx_ifma\"\n+                    \"cet_ss\",       \"avx512_ifma\",      \"serialize\",         \"avx_ifma\",\n+                    \"apx_f\"\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}