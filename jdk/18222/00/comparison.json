{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-  release_set_pd_set(nullptr);\n+  release_set_package_access_cache(nullptr);\n@@ -90,1 +90,1 @@\n-  \/\/ pd_set is accessed during a safepoint.\n+  \/\/ package_access_cache is accessed during a safepoint.\n@@ -93,3 +93,3 @@\n-  while (pd_set_acquire() != nullptr) {\n-    ProtectionDomainEntry* to_delete = pd_set_acquire();\n-    release_set_pd_set(to_delete->next_acquire());\n+  while (package_access_cache_acquire() != nullptr) {\n+    ProtectionDomainEntry* to_delete = package_access_cache_acquire();\n+    release_set_package_access_cache(to_delete->next_acquire());\n@@ -111,2 +111,1 @@\n-bool DictionaryEntry::is_valid_protection_domain(Handle protection_domain) {\n-\n+bool DictionaryEntry::has_package_access_been_granted(Handle protection_domain) {\n@@ -115,1 +114,1 @@\n-        : contains_protection_domain(protection_domain());\n+        : is_in_package_access_cache(protection_domain());\n@@ -118,1 +117,1 @@\n-\/\/ Reading the pd_set on each DictionaryEntry is lock free and cannot safepoint.\n+\/\/ Reading the package_access_cache on each DictionaryEntry is lock free and cannot safepoint.\n@@ -126,1 +125,1 @@\n-bool DictionaryEntry::contains_protection_domain(oop protection_domain) const {\n+bool DictionaryEntry::is_in_package_access_cache(oop protection_domain) const {\n@@ -133,3 +132,3 @@\n-    \/\/ Ensure this doesn't show up in the pd_set (invariant)\n-    bool in_pd_set = false;\n-    for (ProtectionDomainEntry* current = pd_set_acquire();\n+    \/\/ Ensure this doesn't show up in the package_access_cache (invariant)\n+    bool in_package_access_cache = false;\n+    for (ProtectionDomainEntry* current = package_access_cache_acquire();\n@@ -139,1 +138,1 @@\n-        in_pd_set = true;\n+        in_package_access_cache = true;\n@@ -143,1 +142,1 @@\n-    if (in_pd_set) {\n+    if (in_package_access_cache) {\n@@ -155,1 +154,1 @@\n-  for (ProtectionDomainEntry* current = pd_set_acquire();\n+  for (ProtectionDomainEntry* current = package_access_cache_acquire();\n@@ -165,1 +164,1 @@\n-void DictionaryEntry::add_protection_domain(ClassLoaderData* loader_data, Handle protection_domain) {\n+void DictionaryEntry::add_to_package_access_cache(ClassLoaderData* loader_data, Handle protection_domain) {\n@@ -167,1 +166,1 @@\n-  if (!contains_protection_domain(protection_domain())) {\n+  if (!is_in_package_access_cache(protection_domain())) {\n@@ -170,2 +169,2 @@\n-    ProtectionDomainEntry* new_head = new ProtectionDomainEntry(obj, _pd_set);\n-    release_set_pd_set(new_head);\n+    ProtectionDomainEntry* new_head = new ProtectionDomainEntry(obj, _package_access_cache);\n+    release_set_package_access_cache(new_head);\n@@ -177,1 +176,1 @@\n-    ls.print(\"adding protection domain for class %s\", instance_klass()->name()->as_C_string());\n+    ls.print(\"adding protection domain that can access class %s\", instance_klass()->name()->as_C_string());\n@@ -295,1 +294,2 @@\n-\n+\/\/ If SecurityManager is allowed, return the class ONLY IF the protection_domain has been\n+\/\/ granted access to this class by a previous call to Dictionary::check_package_access()\n@@ -301,1 +301,1 @@\n-  if (entry != nullptr && entry->is_valid_protection_domain(protection_domain)) {\n+  if (entry != nullptr && entry->has_package_access_been_granted(protection_domain)) {\n@@ -315,3 +315,3 @@\n-void Dictionary::add_protection_domain(JavaThread* current,\n-                                       InstanceKlass* klass,\n-                                       Handle protection_domain) {\n+void Dictionary::add_to_package_access_cache(JavaThread* current,\n+                                             InstanceKlass* klass,\n+                                             Handle protection_domain) {\n@@ -326,1 +326,1 @@\n-  entry->add_protection_domain(loader_data(), protection_domain);\n+  entry->add_to_package_access_cache(loader_data(), protection_domain);\n@@ -332,1 +332,1 @@\n-  assert(entry->contains_protection_domain(protection_domain()),\n+  assert(entry->is_in_package_access_cache(protection_domain()),\n@@ -336,2 +336,1 @@\n-\n-inline bool Dictionary::is_valid_protection_domain(JavaThread* current,\n+inline bool Dictionary::is_in_package_access_cache(JavaThread* current,\n@@ -341,1 +340,1 @@\n-  return entry->is_valid_protection_domain(protection_domain);\n+  return entry->has_package_access_been_granted(protection_domain);\n@@ -344,4 +343,4 @@\n-void Dictionary::validate_protection_domain(InstanceKlass* klass,\n-                                            Handle class_loader,\n-                                            Handle protection_domain,\n-                                            TRAPS) {\n+void Dictionary::check_package_access(InstanceKlass* klass,\n+                                      Handle class_loader,\n+                                      Handle protection_domain,\n+                                      TRAPS) {\n@@ -352,2 +351,7 @@\n-  if (!java_lang_System::allow_security_manager() ||\n-      is_valid_protection_domain(THREAD, klass->name(), protection_domain)) {\n+  if (!java_lang_System::allow_security_manager()) {\n+    \/\/ No need for any further checking. Package access always allowed.\n+    return;\n+  }\n+\n+  if (is_in_package_access_cache(THREAD, klass->name(), protection_domain)) {\n+    \/\/ No need to check again.\n@@ -398,5 +402,6 @@\n-  \/\/ If no exception has been thrown, we have validated the protection domain\n-  \/\/ Insert the protection domain of the initiating class into the set.\n-  \/\/ We still have to add the protection_domain to the dictionary in case a new\n-  \/\/ security manager is installed later. Calls to load the same class with class loader\n-  \/\/ and protection domain are expected to succeed.\n+  \/\/ If no exception has been thrown, we have checked that the protection_domain can access\n+  \/\/ this klass. Always add it to the cache (even if no SecurityManager is installed yet).\n+  \/\/\n+  \/\/ This ensures that subsequent calls to Dictionary::find(THREAD, klass->name(), protection_domain)\n+  \/\/ will always succeed. I.e., a new SecurityManager installed in the future cannot retroactively\n+  \/\/ revoke the granted access.\n@@ -405,2 +410,1 @@\n-    add_protection_domain(THREAD, klass,\n-                          protection_domain);\n+    add_to_package_access_cache(THREAD, klass, protection_domain);\n@@ -412,1 +416,1 @@\n-void Dictionary::clean_cached_protection_domains(GrowableArray<ProtectionDomainEntry*>* delete_list) {\n+void Dictionary::remove_from_package_access_cache(GrowableArray<ProtectionDomainEntry*>* delete_list) {\n@@ -426,1 +430,1 @@\n-      ProtectionDomainEntry* current = probe->pd_set_acquire();\n+      ProtectionDomainEntry* current = probe->package_access_cache_acquire();\n@@ -440,2 +444,2 @@\n-          if (probe->pd_set_acquire() == current) {\n-            probe->release_set_pd_set(current->next_acquire());\n+          if (probe->package_access_cache_acquire() == current) {\n+            probe->release_set_package_access_cache(current->next_acquire());\n@@ -461,1 +465,1 @@\n-void DictionaryEntry::verify_protection_domain_set() {\n+void DictionaryEntry::verify_package_access_cache() {\n@@ -463,1 +467,1 @@\n-  for (ProtectionDomainEntry* current = pd_set_acquire(); \/\/ accessed at a safepoint\n+  for (ProtectionDomainEntry* current = package_access_cache_acquire(); \/\/ accessed at a safepoint\n@@ -473,1 +477,1 @@\n-  for (ProtectionDomainEntry* current = pd_set_acquire();\n+  for (ProtectionDomainEntry* current = package_access_cache_acquire();\n@@ -528,1 +532,1 @@\n-  verify_protection_domain_set();\n+  verify_package_access_cache();\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":57,"deletions":53,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-  void clean_cached_protection_domains(GrowableArray<ProtectionDomainEntry*>* delete_list);\n+  void remove_from_package_access_cache(GrowableArray<ProtectionDomainEntry*>* delete_list);\n@@ -78,1 +78,0 @@\n-  \/\/ Protection domains\n@@ -80,4 +79,4 @@\n-  void validate_protection_domain(InstanceKlass* klass,\n-                                  Handle class_loader,\n-                                  Handle protection_domain,\n-                                  TRAPS);\n+  void check_package_access(InstanceKlass* klass,\n+                            Handle class_loader,\n+                            Handle protection_domain,\n+                            TRAPS);\n@@ -92,1 +91,1 @@\n-  bool is_valid_protection_domain(JavaThread* current, Symbol* name,\n+  bool is_in_package_access_cache(JavaThread* current, Symbol* name,\n@@ -94,2 +93,2 @@\n-  void add_protection_domain(JavaThread* current, InstanceKlass* klass,\n-                             Handle protection_domain);\n+  void add_to_package_access_cache(JavaThread* current, InstanceKlass* klass,\n+                                   Handle protection_domain);\n@@ -98,3 +97,0 @@\n-\/\/ An entry in the class loader data dictionaries, this describes a class as\n-\/\/ { InstanceKlass*, protection_domain_set }.\n-\n@@ -103,15 +99,5 @@\n-  \/\/ Contains the set of approved protection domains that can access\n-  \/\/ this dictionary entry.\n-  \/\/\n-  \/\/ [Note that C.protection_domain(), which is stored in the java.lang.Class\n-  \/\/ mirror of C, is NOT the same as PD]\n-  \/\/\n-  \/\/ If an entry for PD exists in the list, it means that\n-  \/\/ it is okay for a caller class to reference the class in this dictionary entry.\n-  \/\/\n-  \/\/ The usage of the PD set can be seen in SystemDictionary::validate_protection_domain()\n-  \/\/ It is essentially a cache to avoid repeated Java up-calls to\n-  \/\/ ClassLoader.checkPackageAccess().\n-  \/\/\n-  InstanceKlass*                  _instance_klass;\n-  ProtectionDomainEntry* volatile _pd_set;\n+  InstanceKlass* _instance_klass;\n+\n+  \/\/ A cache of the ProtectionDomains that have been granted\n+  \/\/ access to the package of _instance_klass\n+  ProtectionDomainEntry* volatile _package_access_cache;\n@@ -123,4 +109,4 @@\n-  \/\/ Tells whether a protection is in the approved set.\n-  bool contains_protection_domain(oop protection_domain) const;\n-  \/\/ Adds a protection domain to the approved set.\n-  void add_protection_domain(ClassLoaderData* loader_data, Handle protection_domain);\n+  bool is_in_package_access_cache(oop protection_domain) const;\n+  void add_to_package_access_cache(ClassLoaderData* loader_data, Handle protection_domain);\n+  inline bool has_package_access_been_granted(Handle protection_domain);\n+  void verify_package_access_cache();\n@@ -131,6 +117,2 @@\n-  ProtectionDomainEntry* pd_set_acquire() const            { return Atomic::load_acquire(&_pd_set); }\n-  void release_set_pd_set(ProtectionDomainEntry* entry)    { Atomic::release_store(&_pd_set, entry); }\n-\n-  \/\/ Tells whether the initiating class' protection domain can access the klass in this entry\n-  inline bool is_valid_protection_domain(Handle protection_domain);\n-  void verify_protection_domain_set();\n+  ProtectionDomainEntry* package_access_cache_acquire() const            { return Atomic::load_acquire(&_package_access_cache); }\n+  void release_set_package_access_cache(ProtectionDomainEntry* entry)    { Atomic::release_store(&_package_access_cache, entry); }\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":20,"deletions":38,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-      dictionary->clean_cached_protection_domains(_delete_list);\n+      dictionary->remove_from_package_access_cache(_delete_list);\n@@ -99,2 +99,2 @@\n-  \/\/ safe to remove since traversing the pd_set list does not stop for\n-  \/\/ safepoints and only JavaThreads will read the pd_set.\n+  \/\/ safe to remove since traversing the package_access_cache list does not stop for\n+  \/\/ safepoints and only JavaThreads will read the package_access_cache.\n@@ -118,1 +118,1 @@\n-  \/\/ The dictionary entries _pd_set field should be null also, so nothing to do.\n+  \/\/ DictionaryEntry::_package_access_cache should be null also, so nothing to do.\n@@ -131,1 +131,1 @@\n-    \/\/ The dictionary pd_set points at entries in the ProtectionDomainCacheTable.\n+    \/\/ DictionaryEntry::_package_access_cache points at entries in the ProtectionDomainCacheTable.\n@@ -190,1 +190,1 @@\n-\/\/ keeping it alive.  This is used for traversing DictionaryEntry pd_set.\n+\/\/ keeping it alive.  This is used for traversing DictionaryEntry::_package_access_cache.\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-\/\/ registered by DictionaryEntry::add_protection_domain() to a unique WeakHandle.\n+\/\/ registered by DictionaryEntry::add_to_package_access_cache() to a unique WeakHandle.\n@@ -61,1 +61,1 @@\n-\/\/ This describes the linked list protection domain for each DictionaryEntry in pd_set.\n+\/\/ This describes the linked list protection domain for each DictionaryEntry in its package_access_cache.\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -726,1 +726,0 @@\n-  \/\/ Check if the protection domain is present it has the right access\n@@ -728,2 +727,3 @@\n-    \/\/ Verify protection domain. If it fails an exception is thrown\n-    dictionary->validate_protection_domain(loaded_class, class_loader, protection_domain, CHECK_NULL);\n+    \/\/ A SecurityManager (if installed) may prevent this protection_domain from accessing loaded_class\n+    \/\/ by throwing a SecurityException.\n+    dictionary->check_package_access(loaded_class, class_loader, protection_domain, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-        .shouldContain(\"[protectiondomain] adding protection domain for class\");\n+        .shouldContain(\"[protectiondomain] adding protection domain that can access class\");\n@@ -59,1 +59,1 @@\n-        .shouldNotContain(\"[protectiondomain] adding protection domain for class\");\n+        .shouldNotContain(\"[protectiondomain] adding protection domain that can access class\");\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/ProtectionDomainVerificationTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}