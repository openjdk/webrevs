{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,1 @@\n+        len = Math.min(len, Streams.MAX_BUFFER_SIZE);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,4 @@\n-        while (bb.remaining() > 0) {\n+        int pos = bb.position();\n+        int rem = bb.limit() - pos;\n+        while (rem > 0) {\n+            bb.limit(pos + Math.min(Streams.MAX_BUFFER_SIZE, rem));\n@@ -70,1 +73,4 @@\n-                throw new RuntimeException(\"no bytes written\");\n+                throw new IOException(\"Write failed\");\n+            pos += n;\n+            rem -= n;\n+            bb.position(pos);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelOutputStream.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n-    \/\/ The maximum number of bytes to read\/write per syscall to avoid needing\n-    \/\/ a huge buffer from the temporary buffer cache\n-    private static final int MAX_BUFFER_SIZE = 128 * 1024;\n-\n@@ -358,2 +354,2 @@\n-                \/\/ read up to MAX_BUFFER_SIZE bytes\n-                int size = Math.min(len, MAX_BUFFER_SIZE);\n+                \/\/ read up to Streams.MAX_BUFFER_SIZE bytes\n+                int size = Math.min(len, Streams.MAX_BUFFER_SIZE);\n@@ -456,2 +452,2 @@\n-                    \/\/ write up to MAX_BUFFER_SIZE bytes\n-                    int size = Math.min((end - pos), MAX_BUFFER_SIZE);\n+                    \/\/ write up to Streams.MAX_BUFFER_SIZE bytes\n+                    int size = Math.min((end - pos), Streams.MAX_BUFFER_SIZE);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1376,0 +1376,1 @@\n+        len = Math.min(len, Streams.MAX_BUFFER_SIZE);\n@@ -1472,1 +1473,1 @@\n-                    int size = end - pos;\n+                    int size = Math.min(end - pos, Streams.MAX_BUFFER_SIZE);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,4 @@\n+    \/\/ The maximum number of bytes to read\/write per syscall to avoid needing\n+    \/\/ a huge buffer from the temporary buffer cache\n+    static final int MAX_BUFFER_SIZE = 128 * 1024;\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Streams.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * @run testng SocketChannelStreams\n@@ -29,0 +28,1 @@\n+ * @run testng SocketChannelStreams\n@@ -38,0 +38,2 @@\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ByteChannel;\n@@ -54,0 +56,3 @@\n+    \/\/ Maximum size of internal temporary buffer\n+    private static final int MAX_BUFFER_SIZE = 128*1024;\n+\n@@ -382,0 +387,19 @@\n+    \/**\n+     * Test that internal buffers have at most MAX_BUFFER_SIZE bytes remaining.\n+     *\/\n+    public void testReadLimit() throws IOException {\n+        InputStream in = Channels.newInputStream(new TestChannel());\n+        byte[] b = new byte[3*MAX_BUFFER_SIZE];\n+        int n = in.read(b, 0, b.length);\n+        assertEquals(n, MAX_BUFFER_SIZE);\n+    }\n+\n+    \/**\n+     * Test that internal buffers have at most MAX_BUFFER_SIZE bytes remaining.\n+     *\/\n+    public void testWriteLimit() throws IOException {\n+        OutputStream out = Channels.newOutputStream(new TestChannel());\n+        byte[] b = new byte[3*MAX_BUFFER_SIZE];\n+        out.write(b, 0, b.length);\n+    }\n+\n@@ -480,0 +504,36 @@\n+\n+    \/**\n+     * ByteChannel that throws if more than 128k bytes remain\n+     * in the buffer supplied for reading or writing.\n+     *\/\n+    private static class TestChannel implements ByteChannel {\n+        @Override\n+        public int read(ByteBuffer bb) throws IOException {\n+            int rem = bb.remaining();\n+            if (rem > MAX_BUFFER_SIZE) {\n+                throw new IOException(\"too big\");\n+            }\n+            bb.position(bb.limit());\n+            return rem;\n+        }\n+\n+        @Override\n+        public int write(ByteBuffer bb) throws IOException {\n+            int rem = bb.remaining();\n+            if (rem > MAX_BUFFER_SIZE) {\n+                throw new IOException(\"too big\");\n+            }\n+            bb.position(bb.limit());\n+            return rem;\n+        }\n+\n+        @Override\n+        public boolean isOpen() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void close() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n","filename":"test\/jdk\/java\/nio\/channels\/Channels\/SocketChannelStreams.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"}]}