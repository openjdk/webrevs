{"files":[{"patch":"@@ -26,1 +26,3 @@\n- * @bug 8366401\n+ * @bug 4068067 4101150 8366401\n+ * @library \/java\/text\/testlib\n+ * @build HexDumpReader\n@@ -38,0 +40,1 @@\n+import java.io.InputStream;\n@@ -41,0 +44,1 @@\n+import java.io.Serializable;\n@@ -54,0 +58,1 @@\n+    \/\/ Test that rely on hex dump files that were written from older JDK versions\n@@ -55,1 +60,23 @@\n-    class VersionTests {\n+    class HexDumpTests {\n+\n+        @Test \/\/ See 4068067 and CDFS which is the class in the serialized hex dump\n+        void JDK1_1_4Test() {\n+            \/\/ Reconstruct a class serialized during 1.1.4 which has a DFS holder\n+            var cdfs = (CheckDecimalFormatSymbols) assertDoesNotThrow(\n+                    () -> deSer(\"DecimalFormatSymbols.114.txt\"));\n+            assertDoesNotThrow(cdfs::Update); \/\/ Checks getDigit call succeeds\n+        }\n+\n+        @Test \/\/ See 4068067\n+        void JDK1_4_2Test() {\n+            \/\/ Reconstruct a 1.4.2 DFS\n+            var dfs = (DecimalFormatSymbols) assertDoesNotThrow(\n+                    () -> deSer(\"DecimalFormatSymbols.142.txt\"));\n+            \/\/ Checks curr symbol is saved, and exponent separator default set\n+            assertEquals(\"E\", dfs.getExponentSeparator());\n+            assertEquals(\"*SpecialCurrencySymbol*\", dfs.getCurrencySymbol());\n+        }\n+    }\n+\n+    @Nested\n+    class StreamVersionTests {\n@@ -60,1 +87,1 @@\n-        public void version0Test() {\n+        void version0Test() {\n@@ -79,1 +106,1 @@\n-        public void version1Test() {\n+        void version1Test() {\n@@ -92,1 +119,1 @@\n-        public void version2Test() {\n+        void version2Test() {\n@@ -106,1 +133,1 @@\n-        public void version3Test() {\n+        void version3Test() {\n@@ -128,1 +155,1 @@\n-        public void version4Test() {\n+        void version4Test() {\n@@ -145,1 +172,1 @@\n-    public void nullableLocaleTest() {\n+    void nullableLocaleTest() {\n@@ -160,1 +187,1 @@\n-    public void disagreeingTextTest() {\n+    void disagreeingTextTest() {\n@@ -182,1 +209,1 @@\n-    public void updatedVersionTest() {\n+    void updatedVersionTest() {\n@@ -190,1 +217,1 @@\n-    public void validIntlCurrencyTest() {\n+    void validIntlCurrencyTest() {\n@@ -198,1 +225,1 @@\n-    public void invalidIntlCurrencyTest() {\n+    void invalidIntlCurrencyTest() {\n@@ -208,0 +235,20 @@\n+    \/\/ Ensure the currency symbol is read properly\n+    @Test\n+    void currencySymbolTest() {\n+        var crafted = new DecimalFormatSymbols();\n+        crafted.setCurrencySymbol(\"*SpecialCurrencySymbol*\");\n+        var bytes = ser(crafted);\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(\"*SpecialCurrencySymbol*\", dfs.getCurrencySymbol());\n+    }\n+\n+    \/\/ Ensure the exponent separator is read properly\n+    @Test\n+    void exponentSeparatorTest() {\n+        var crafted = new DecimalFormatSymbols();\n+        crafted.setExponentSeparator(\"*SpecialExponentSeparator*\");\n+        var bytes = ser(crafted);\n+        var dfs = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(\"*SpecialExponentSeparator*\", dfs.getExponentSeparator());\n+    }\n+\n@@ -221,1 +268,1 @@\n-    \/\/ Utility to deserialize\n+    \/\/ Utility to deserialize from byte array\n@@ -229,0 +276,8 @@\n+    \/\/ Utility to deserialize from file in hex format\n+    private static Object deSer(String file) throws IOException, ClassNotFoundException {\n+        try (InputStream stream = HexDumpReader.getStreamFromHexDump(file);\n+             ObjectInputStream ois = new ObjectInputStream(stream)) {\n+            return ois.readObject();\n+        }\n+    }\n+\n@@ -265,0 +320,9 @@\n+\n+\/\/ Not nested, so that it can be cast correctly for the 1.1.4 test\n+class CheckDecimalFormatSymbols implements Serializable {\n+    DecimalFormatSymbols _decFormatSymbols = new DecimalFormatSymbols();\n+    public char Update()\n+    {\n+        return  _decFormatSymbols.getDigit();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DFSSerializationTest.java","additions":77,"deletions":13,"binary":false,"changes":90,"status":"modified"},{"patch":"","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DecimalFormat.114.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/DecimalFormat.114.txt","status":"renamed"},{"patch":"","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DecimalFormatSymbols.114.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/DecimalFormatSymbols.114.txt","status":"renamed"},{"patch":"","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/DecimalFormatSymbols.142.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/DecimalFormatSymbols.142.txt","status":"renamed"},{"patch":"","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/NumberFormat4185761a.ser.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/NumberFormat4185761a.ser.txt","status":"renamed"},{"patch":"","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/NumberFormat4185761b.ser.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/NumberFormat4185761b.ser.txt","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,3 +25,6 @@\n- * @bug 8327640\n- * @summary Check parseStrict correctness for DecimalFormat serialization\n- * @run junit\/othervm SerializationTest\n+ * @bug 4069754 4067878 4101150 4185761 8327640\n+ * @library \/java\/text\/testlib\n+ * @build HexDumpReader\n+ * @summary Check de-serialization correctness for DecimalFormat. That is, ensure the\n+ *          behavior for each stream version is correct during de-serialization.\n+ * @run junit\/othervm --add-opens java.base\/java.text=ALL-UNNAMED SerializationTest\n@@ -30,1 +33,1 @@\n-import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Nested;\n@@ -33,2 +36,2 @@\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n@@ -36,0 +39,2 @@\n+import java.io.InputStream;\n+import java.io.InvalidObjectException;\n@@ -38,0 +43,5 @@\n+import java.io.Serializable;\n+import java.lang.reflect.Field;\n+import java.math.RoundingMode;\n+import java.text.DateFormat;\n+import java.text.DecimalFormat;\n@@ -39,1 +49,3 @@\n-import java.text.ParseException;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.Random;\n@@ -41,0 +53,1 @@\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n@@ -42,0 +55,3 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n@@ -43,0 +59,1 @@\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -46,1 +63,2 @@\n-    private static final NumberFormat FORMAT = NumberFormat.getInstance();\n+    @Nested \/\/ Test that rely on hex dump files that were written from older JDK versions\n+    class HexDumpTests {\n@@ -48,3 +66,29 @@\n-    @BeforeAll\n-    public static void mutateFormat() {\n-        FORMAT.setStrict(true);\n+        @Test \/\/ See 4101150 and CDF which is the serialized hex dump\n+        void JDK1_1_4Test() {\n+            \/\/ Reconstruct a 1.1.4 serializable class which has a DF holder\n+            var cdf = (CheckDecimalFormat) assertDoesNotThrow(\n+                    () -> deSer(\"DecimalFormat.114.txt\"));\n+            assertDoesNotThrow(cdf::Update); \/\/ Checks format call succeeds\n+        }\n+\n+        @Test \/\/ See 4185761\n+        void minMaxDigitsTest() {\n+            \/\/ Reconstructing a DFS stream from an older JDK version\n+            \/\/ The min digits are smaller than the max digits and should fail\n+            \/\/ minint maxint minfrac maxfrac\n+            \/\/ 0x122  0x121   0x124   0x123\n+            assertEquals(\"Digit count range invalid\",\n+                    assertThrows(InvalidObjectException.class,\n+                            () -> deSer(\"NumberFormat4185761a.ser.txt\")).getMessage());\n+        }\n+\n+        @Test \/\/ See 4185761\n+        void digitLimitTest() {\n+            \/\/ Reconstructing a DFS stream from an older JDK version\n+            \/\/ The digit values exceed the class invariant limits\n+            \/\/ minint maxint minfrac maxfrac\n+            \/\/ 0x311  0x312   0x313   0x314\n+            assertEquals(\"Digit count out of range\",\n+                    assertThrows(InvalidObjectException.class,\n+                            () -> deSer(\"NumberFormat4185761b.ser.txt\")).getMessage());\n+        }\n@@ -53,0 +97,122 @@\n+    @Nested\n+    class VersionTests {\n+\n+        \/\/ Version 0 did not have exponential fields and defaulted the value to false\n+        @Test\n+        void version0Test() {\n+            var crafted = new DFBuilder()\n+                    .setVer(0)\n+                    .set(\"useExponentialNotation\", true)\n+                    .build();\n+            var bytes = ser(crafted);\n+            var df = assertDoesNotThrow(() -> deSer(bytes));\n+            \/\/ Ensure we do not observe exponential notation form\n+            assertFalse(df.format(0).contains(\"E\"));\n+        }\n+\n+        \/\/ Version 1 did not support the affix pattern Strings. Ensure when they\n+        \/\/ are read in from the stream they are not defaulted and remain null.\n+        @Test\n+        void version1Test() {\n+            var crafted = new DFBuilder()\n+                    .setVer(1)\n+                    .set(\"posPrefixPattern\", null)\n+                    .set(\"posSuffixPattern\", null)\n+                    .set(\"negPrefixPattern\", null)\n+                    .set(\"negSuffixPattern\", null)\n+                    .build();\n+            var bytes = ser(crafted);\n+            var df = assertDoesNotThrow(() -> deSer(bytes));\n+            assertNull(readField(df, \"posPrefixPattern\"));\n+            assertNull(readField(df, \"posSuffixPattern\"));\n+            assertNull(readField(df, \"negPrefixPattern\"));\n+            assertNull(readField(df, \"negSuffixPattern\"));\n+        }\n+\n+        \/\/ Version 2 did not support the min\/max int and frac digits.\n+        \/\/ Ensure the proper defaults are set.\n+        @Test\n+        void version2Test() {\n+            var crafted = new DFBuilder()\n+                    .setVer(2)\n+                    .set(\"maximumIntegerDigits\", -1)\n+                    .set(\"maximumFractionDigits\", -1)\n+                    .set(\"minimumIntegerDigits\", -1)\n+                    .set(\"minimumFractionDigits\", -1)\n+                    .build();\n+            var bytes = ser(crafted);\n+            var df = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(1, df.getMinimumIntegerDigits());\n+            assertEquals(3, df.getMaximumFractionDigits());\n+            assertEquals(309, df.getMaximumIntegerDigits());\n+            assertEquals(0, df.getMinimumFractionDigits());\n+        }\n+\n+        \/\/ Version 3 did not support rounding mode. Should default to HALF_EVEN\n+        @Test\n+        void version3Test() {\n+            var crafted = new DFBuilder()\n+                    .setVer(3)\n+                    .set(\"roundingMode\", RoundingMode.UNNECESSARY)\n+                    .build();\n+            var bytes = ser(crafted);\n+            var df = assertDoesNotThrow(() -> deSer(bytes));\n+            assertEquals(RoundingMode.HALF_EVEN, df.getRoundingMode());\n+        }\n+    }\n+\n+    \/\/ Some invariant checking in DF relies on checking NF fields.\n+    \/\/ Either via NF.readObject() or through super calls in DF.readObject\n+    @Nested \/\/ For all these nested tests, see 4185761\n+    class NumberFormatTests {\n+\n+        \/\/ Ensure the max integer value invariant is not exceeded\n+        @Test\n+        void integerTest() {\n+            var crafted = new DFBuilder()\n+                    .setSuper(\"maximumIntegerDigits\", 786)\n+                    .setSuper(\"minimumIntegerDigits\", 785)\n+                    .build();\n+            var bytes = ser(crafted);\n+            assertEquals(\"Digit count out of range\",\n+                    assertThrows(InvalidObjectException.class, () -> deSer(bytes)).getMessage());\n+        }\n+\n+        \/\/ Ensure the max fraction value invariant is not exceeded\n+        @Test\n+        void fractionTest() {\n+            var crafted = new DFBuilder()\n+                    .setSuper(\"maximumFractionDigits\", 788)\n+                    .setSuper(\"minimumFractionDigits\", 787)\n+                    .build();\n+            var bytes = ser(crafted);\n+            assertEquals(\"Digit count out of range\",\n+                    assertThrows(InvalidObjectException.class, () -> deSer(bytes)).getMessage());\n+        }\n+\n+        \/\/ Ensure the minimum integer digits cannot be greater than the max\n+        @Test\n+        void maxMinIntegerTest() {\n+            var crafted = new DFBuilder()\n+                    .setSuper(\"maximumIntegerDigits\", 5)\n+                    .setSuper(\"minimumIntegerDigits\", 6)\n+                    .build();\n+            var bytes = ser(crafted);\n+            assertEquals(\"Digit count range invalid\",\n+                    assertThrows(InvalidObjectException.class, () -> deSer(bytes)).getMessage());\n+        }\n+\n+        \/\/ Ensure the minimum fraction digits cannot be greater than the max\n+        @Test\n+        void maxMinFractionTest() {\n+            var crafted = new DFBuilder()\n+                    .setSuper(\"maximumFractionDigits\", 5)\n+                    .setSuper(\"minimumFractionDigits\", 6)\n+                    .build();\n+            var bytes = ser(crafted);\n+            assertEquals(\"Digit count range invalid\",\n+                    assertThrows(InvalidObjectException.class, () -> deSer(bytes)).getMessage());\n+        }\n+    }\n+\n+    \/\/ Ensure the serial version is updated to the current after de-serialization.\n@@ -54,14 +220,56 @@\n-    public void testSerialization() throws IOException, ClassNotFoundException {\n-        \/\/ Serialize\n-        serialize(\"fmt.ser\", FORMAT);\n-        \/\/ Deserialize\n-        deserialize(\"fmt.ser\", FORMAT);\n-    }\n-\n-    private void serialize(String fileName, NumberFormat... formats)\n-            throws IOException {\n-        try (ObjectOutputStream os = new ObjectOutputStream(\n-                new FileOutputStream(fileName))) {\n-            for (NumberFormat fmt : formats) {\n-                os.writeObject(fmt);\n-            }\n+    void versionTest() {\n+        var bytes = ser(new DFBuilder().setVer(-25).build());\n+        var df = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(4, readField(df, \"serialVersionOnStream\"));\n+    }\n+\n+    \/\/ Ensure strictness value is read properly when it is set.\n+    @Test\n+    void strictnessTest() {\n+        var crafted = new DecimalFormat();\n+        crafted.setStrict(true);\n+        var bytes = ser(crafted);\n+        var df = assertDoesNotThrow(() -> deSer(bytes));\n+        assertTrue(df.isStrict());\n+    }\n+\n+    \/\/ Ensure invalid grouping sizes are corrected to the default invariant.\n+    @Test\n+    void groupingSizeTest() {\n+        var crafted = new DFBuilder()\n+                .set(\"groupingSize\", (byte) -5)\n+                .build();\n+        var bytes = ser(crafted);\n+        var df = assertDoesNotThrow(() -> deSer(bytes));\n+        assertEquals(3, df.getGroupingSize());\n+    }\n+\n+    \/\/ Ensure a de-serialized dFmt does not throw NPE from missing digitList\n+    \/\/ later when formatting. i.e. re-construct the transient digitList field\n+    @Test \/\/ See 4069754, 4067878\n+    void digitListTest() {\n+        var crafted = new DecimalFormat();\n+        var bytes = ser(crafted);\n+        var df = assertDoesNotThrow(() -> deSer(bytes));\n+        assertDoesNotThrow(() -> df.format(1));\n+        assertNotNull(readField(df, \"digitList\"));\n+    }\n+\n+    \/\/ Similar to the previous test, but the original regression test\n+    \/\/ which was a failure in DateFormat due to DecimalFormat NPE\n+    @Test \/\/ See 4069754 and 4067878\n+    void digitListDateFormatTest() {\n+        var fmt = new FooFormat();\n+        fmt.now();\n+        var bytes = ser(fmt);\n+        var ff = (FooFormat) assertDoesNotThrow(() -> deSer0(bytes));\n+        assertDoesNotThrow(ff::now);\n+    }\n+\n+    static class FooFormat implements Serializable {\n+        DateFormat dateFormat = DateFormat.getDateInstance();\n+\n+        public String now() {\n+            GregorianCalendar calendar = new GregorianCalendar();\n+            Date t = calendar.getTime();\n+            return dateFormat.format(t);\n@@ -71,8 +279,1 @@\n-    private static void deserialize(String fileName, NumberFormat... formats)\n-            throws IOException, ClassNotFoundException {\n-        try (ObjectInputStream os = new ObjectInputStream(\n-                new FileInputStream(fileName))) {\n-            for (NumberFormat fmt : formats) {\n-                NumberFormat obj = (NumberFormat) os.readObject();\n-                assertEquals(fmt, obj, \"Serialized and deserialized\"\n-                        + \" objects do not match\");\n+\/\/ Utilities ----\n@@ -80,3 +281,7 @@\n-                String badNumber = \"fooofooo23foo\";\n-                assertThrows(ParseException.class, () -> fmt.parse(badNumber));\n-                assertThrows(ParseException.class, () -> obj.parse(badNumber));\n+    \/\/ Utility to serialize\n+    private static byte[] ser(Object obj) {\n+        return assertDoesNotThrow(() -> {\n+            try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+                 ObjectOutputStream oos = new ObjectOutputStream(byteArrayOutputStream)) {\n+                oos.writeObject(obj);\n+                return byteArrayOutputStream.toByteArray();\n@@ -84,0 +289,8 @@\n+        }, \"Unexpected error during serialization\");\n+    }\n+\n+    \/\/ Utility to deserialize\n+    private static Object deSer0(byte[] bytes) throws IOException, ClassNotFoundException {\n+        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n+             ObjectInputStream ois = new ObjectInputStream(byteArrayInputStream)) {\n+            return ois.readObject();\n@@ -86,0 +299,66 @@\n+\n+    \/\/ Convenience cast to DF\n+    private static DecimalFormat deSer(byte[] bytes) throws IOException, ClassNotFoundException {\n+        return (DecimalFormat) deSer0(bytes);\n+    }\n+\n+    \/\/ Utility to deserialize from file in hex format\n+    private static Object deSer(String file) throws IOException, ClassNotFoundException {\n+        try (InputStream stream = HexDumpReader.getStreamFromHexDump(file);\n+             ObjectInputStream ois = new ObjectInputStream(stream)) {\n+            return ois.readObject();\n+        }\n+    }\n+\n+    \/\/ Utility to read a private field\n+    private static Object readField(DecimalFormat df, String name) {\n+        return assertDoesNotThrow(() -> {\n+            var field = DecimalFormat.class.getDeclaredField(name);\n+            field.setAccessible(true);\n+            return field.get(df);\n+        }, \"Unexpected error during field reading\");\n+    }\n+\n+    \/\/ Utility class to build instances of DF via reflection\n+    private static class DFBuilder {\n+\n+        private final DecimalFormat df;\n+\n+        private DFBuilder() {\n+            df = new DecimalFormat();\n+        }\n+\n+        private DFBuilder setVer(Object value) {\n+            return set(\"serialVersionOnStream\", value);\n+        }\n+\n+        private DFBuilder setSuper(String field, Object value) {\n+            return set(df.getClass().getSuperclass(), field, value);\n+        }\n+\n+        private DFBuilder set(String field, Object value) {\n+            return set(df.getClass(), field, value);\n+        }\n+\n+        private DFBuilder set(Class<?> clzz, String field, Object value) {\n+            return assertDoesNotThrow(() -> {\n+                Field f = clzz.getDeclaredField(field);\n+                f.setAccessible(true);\n+                f.set(df, value);\n+                return this;\n+            }, \"Unexpected error during reflection setting\");\n+        }\n+\n+        private DecimalFormat build() {\n+            return df;\n+        }\n+    }\n+}\n+\n+\/\/ Not nested, so that it can be recognized and cast correctly for the 1.1.4 test\n+class CheckDecimalFormat implements Serializable {\n+    DecimalFormat _decFormat = (DecimalFormat) NumberFormat.getInstance();\n+    public String Update() {\n+        Random r = new Random();\n+        return _decFormat.format(r.nextDouble());\n+    }\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/SerializationTest.java","additions":316,"deletions":37,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * No at-test for this test, because it needs to be run on older version JDK than 1.6 to test.\n- * It was tested using 1.4.2. The file object was created using JDK1.6.\n- *\/\n-\n-\n-\n-import java.awt.*;\n-import java.text.*;\n-import java.util.*;\n-import java.io.*;\n-\n-public class DFSDeserialization142{\n-\n-    public static void main(String[] args)\n-    {\n-        try {\n-\n-           File file = new File(\"DecimalFormatSymbols.current\");\n-           FileInputStream istream = new FileInputStream(file);\n-           ObjectInputStream p = new ObjectInputStream(istream);\n-           DecimalFormatSymbols dfs = (DecimalFormatSymbols)p.readObject();\n-           if (dfs.getCurrencySymbol().equals(\"*SpecialCurrencySymbol*\")){\n-                System.out.println(\"Serialization\/Deserialization Test Passed.\");\n-           }else{\n-                throw new Exception(\"Serialization\/Deserialization Test Failed:\"+dfs.getCurrencySymbol());\n-           }\n-           istream.close();\n-       } catch (Exception e) {\n-            e.printStackTrace();\n-          }\n-     }\n-}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/DFSDeserialization142.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4068067\n- * @library \/java\/text\/testlib\n- * @build DFSSerialization HexDumpReader\n- * @run junit DFSSerialization\n- * @summary Three different tests are done.\n- *    1. read from the object created using jdk1.4.2\n- *    2. create a valid DecimalFormatSymbols object with current JDK, then read the object\n- *    3. Try to create an valid DecimalFormatSymbols object by passing null to set null\n- *       for the exponent separator symbol. Expect the NullPointerException.\n- *\/\n-\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.InputStream;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.text.DecimalFormatSymbols;\n-import java.util.Locale;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.fail;\n-\n-public class DFSSerialization{\n-\n-    @Test\n-    public void TestDFSSerialization(){\n-        \/*\n-         * 1. read from the object created using jdk1.4.2\n-         *\/\n-        File oldFile = new File(System.getProperty(\"test.src\", \".\"), \"DecimalFormatSymbols.142.txt\");\n-        DecimalFormatSymbols dfs142 = readTestObject(oldFile);\n-        if (dfs142 != null){\n-            if (dfs142.getExponentSeparator().equals(\"E\") && dfs142.getCurrencySymbol().equals(\"*SpecialCurrencySymbol*\")){\n-                System.out.println(\"\\n  Deserialization of JDK1.4.2 Object from the current JDK: Passed.\");\n-                System.out.println(\" Deserialization of JDK1.4.2 Object from the current JDK: Passed.\");\n-            } else {\n-                fail(\" Deserialization of JDK1.4.2 Object from the current JDK was Failed:\"\n-                      +dfs142.getCurrencySymbol()+\" \"+dfs142.getExponentSeparator());\n-                \/*\n-                 * logically should not throw this exception as errln throws exception\n-                 * if not thrown yet - but in case errln got changed\n-                 *\/\n-                throw new RuntimeException(\" Deserialization of JDK1.4.2 Object from the current JDK was Failed:\"\n-                                           +dfs142.getCurrencySymbol()+\" \"+dfs142.getExponentSeparator());\n-            }\n-        }\n-        \/*\n-         * 2. create a valid DecimalFormatSymbols object with current JDK, then read the object\n-         *\/\n-        String validObject = \"DecimalFormatSymbols.current\";\n-        File currentFile = createTestObject(validObject, \"*SpecialExponentSeparator*\");\n-\n-        DecimalFormatSymbols dfsValid = readTestObject(currentFile);\n-        if (dfsValid != null){\n-            if (dfsValid.getExponentSeparator().equals(\"*SpecialExponentSeparator*\") &&\n-                dfsValid.getCurrencySymbol().equals(\"*SpecialCurrencySymbol*\")){\n-                System.out.println(\"  Deserialization of current JDK Object from the current JDK: Passed.\");\n-                System.out.println(\" Deserialization of current JDK Object from the current JDK: Passed.\");\n-            } else {\n-                fail(\" Deserialization of current JDK Object from the current JDK was Failed:\"\n-                      +dfsValid.getCurrencySymbol()+\" \"+dfsValid.getExponentSeparator());\n-                \/*\n-                 * logically should not throw this exception as errln throws exception\n-                 * if not thrown yet - but in case errln got changed\n-                 *\/\n-                throw new RuntimeException(\" Deserialization of current Object from the current JDK was Failed:\"\n-                                           +dfsValid.getCurrencySymbol()+\" \"+dfsValid.getExponentSeparator());\n-            }\n-        }\n-        \/*\n-         * 3. Try to create an valid DecimalFormatSymbols object by passing null\n-         *    to set null for the exponent separator symbol. Expect the NullPointerException.\n-         *\/\n-        DecimalFormatSymbols symNPE = new DecimalFormatSymbols(Locale.US);\n-        boolean npePassed = false;\n-        try {\n-            symNPE.setExponentSeparator(null);\n-        } catch (NullPointerException npe){\n-            npePassed = true;\n-            System.out.println(\"  Trying to set exponent separator with null: Passed.\");\n-            System.out.println(\" Trying to set exponent separator with null: Passed.\");\n-        }\n-        if (!npePassed){\n-            System.out.println(\" Trying to set exponent separator with null:Failed.\");\n-            fail(\"  Trying to set exponent separator with null:Failed.\");\n-            \/*\n-             * logically should not throw this exception as errln throws exception\n-             * if not thrown yet - but in case errln got changed\n-             *\/\n-            throw new RuntimeException(\" Trying to set exponent separator with null:Failed.\");\n-        }\n-\n-    }\n-\n-    private DecimalFormatSymbols readTestObject(File inputFile){\n-        try (InputStream istream = inputFile.getName().endsWith(\".txt\") ?\n-                                       HexDumpReader.getStreamFromHexDump(inputFile) :\n-                                       new FileInputStream(inputFile)) {\n-            ObjectInputStream p = new ObjectInputStream(istream);\n-            DecimalFormatSymbols dfs = (DecimalFormatSymbols)p.readObject();\n-            return dfs;\n-        } catch (Exception e) {\n-            fail(\"Test Malfunction in DFSSerialization: Exception while reading the object\");\n-            \/*\n-             * logically should not throw this exception as errln throws exception\n-             * if not thrown yet - but in case errln got changed\n-             *\/\n-            throw new RuntimeException(\"Test Malfunction: re-throwing the exception\", e);\n-        }\n-    }\n-\n-    private File createTestObject(String objectName, String expString){\n-        DecimalFormatSymbols dfs= new DecimalFormatSymbols();\n-        dfs.setExponentSeparator(expString);\n-        dfs.setCurrencySymbol(\"*SpecialCurrencySymbol*\");\n-        System.out.println(\" The special exponent separator is set : \"  + dfs.getExponentSeparator());\n-        System.out.println(\" The special currency symbol is set : \"  + dfs.getCurrencySymbol());\n-\n-        \/\/ 6345659: create a test object in the test.class dir where test user has a write permission.\n-        File file = new File(System.getProperty(\"test.class\", \".\"), objectName);\n-        try (FileOutputStream ostream = new FileOutputStream(file)) {\n-            ObjectOutputStream p = new ObjectOutputStream(ostream);\n-            p.writeObject(dfs);\n-            \/\/System.out.println(\" The special currency symbol is set : \"  + dfs.getCurrencySymbol());\n-            return file;\n-        } catch (Exception e){\n-            fail(\"Test Malfunction in DFSSerialization: Exception while creating an object\");\n-            \/*\n-             * logically should not throw this exception as errln throws exception\n-             * if not thrown yet - but in case errln got changed\n-             *\/\n-            throw new RuntimeException(\"Test Malfunction: re-throwing the exception\", e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/DFSSerialization.java","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * No at-test for this test, because it needs to be run on JDK 1.4.2\n- * Instead, the resulting serialized file\n- * DecimalFormatSymbols.142 is archived.\n- *\/\n-\n-import java.awt.*;\n-import java.text.*;\n-import java.util.*;\n-import java.io.*;\n-\n-public class DFSSerialization142 {\n-\n-    public static void main(String[] args)\n-    {\n-        try {\n-\n-            DecimalFormatSymbols dfs= new DecimalFormatSymbols();\n-            System.out.println(\"Default currency symbol in the default locale : \"  + dfs.getCurrencySymbol());\n-            dfs.setCurrencySymbol(\"*SpecialCurrencySymbol*\");\n-            System.out.println(\"The special currency symbol is set : \"  + dfs.getCurrencySymbol());\n-            FileOutputStream ostream = new FileOutputStream(\"DecimalFormatSymbols.142\");\n-            ObjectOutputStream p = new ObjectOutputStream(ostream);\n-            p.writeObject(dfs);\n-            ostream.close();\n-            System.out.println(\"DecimalFormatSymbols saved ok.\");\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/DFSSerialization142.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,2 @@\n- * 4162852 4167494 4170798 4176114 4179818 4185761 4212072 4212073 4216742\n- * 4217661 4243011 4243108 4330377 4233840 4241880 4833877 8008577 8227313\n- * 8174269\n+ * 4162852 4167494 4170798 4176114 4179818 4212072 4212073 4216742 4217661\n+ * 4243011 4243108 4330377 4233840 4241880 4833877 8008577 8227313 8174269\n@@ -310,27 +309,0 @@\n-    \/* bugs 4069754, 4067878\n-     * null pointer thrown when accessing a deserialized DecimalFormat\n-     * object.\n-     *\/\n-    @Test\n-    public void Test4069754()\n-    {\n-        try {\n-            myformat it = new myformat();\n-            System.out.println(it.Now());\n-            FileOutputStream ostream = new FileOutputStream(\"t.tmp\");\n-            ObjectOutputStream p = new ObjectOutputStream(ostream);\n-            p.writeObject(it);\n-            ostream.close();\n-            System.out.println(\"Saved ok.\");\n-\n-            FileInputStream istream = new FileInputStream(\"t.tmp\");\n-            ObjectInputStream p2 = new ObjectInputStream(istream);\n-            myformat it2 = (myformat)p2.readObject();\n-            System.out.println(it2.Now());\n-            istream.close();\n-            System.out.println(\"Loaded ok.\");\n-        } catch (Exception foo) {\n-            fail(\"Test for bug 4069754 or 4057878 failed => Exception: \" + foo.getMessage());\n-        }\n-    }\n-\n@@ -1488,53 +1460,0 @@\n-    @Test\n-    public void Test4185761() throws IOException, ClassNotFoundException {\n-        \/* Code used to write out the initial files, which are\n-         * then edited manually:\n-        NumberFormat nf = NumberFormat.getInstance(Locale.US);\n-        nf.setMinimumIntegerDigits(0x111); \/\/ Keep under 309\n-        nf.setMaximumIntegerDigits(0x112); \/\/ Keep under 309\n-        nf.setMinimumFractionDigits(0x113); \/\/ Keep under 340\n-        nf.setMaximumFractionDigits(0x114); \/\/ Keep under 340\n-        FileOutputStream ostream =\n-            new FileOutputStream(\"NumberFormat4185761\");\n-        ObjectOutputStream p = new ObjectOutputStream(ostream);\n-        p.writeObject(nf);\n-        ostream.close();\n-        *\/\n-\n-        \/\/ File                 minint maxint minfrac maxfrac\n-        \/\/ NumberFormat4185761a  0x122  0x121   0x124   0x123\n-        \/\/ NumberFormat4185761b  0x311  0x312   0x313   0x314\n-        \/\/ File a is bad because the mins are smaller than the maxes.\n-        \/\/ File b is bad because the values are too big for a DecimalFormat.\n-        \/\/ These files have a sufix \".ser.txt\".\n-\n-        InputStream istream = HexDumpReader.getStreamFromHexDump(\"NumberFormat4185761a.ser.txt\");\n-        ObjectInputStream p = new ObjectInputStream(istream);\n-        try {\n-            NumberFormat nf = (NumberFormat) p.readObject();\n-            fail(\"FAIL: Deserialized bogus NumberFormat int:\" +\n-                  nf.getMinimumIntegerDigits() + \"..\" +\n-                  nf.getMaximumIntegerDigits() + \" frac:\" +\n-                  nf.getMinimumFractionDigits() + \"..\" +\n-                  nf.getMaximumFractionDigits());\n-        } catch (InvalidObjectException e) {\n-            System.out.println(\"Ok: \" + e.getMessage());\n-        }\n-        istream.close();\n-\n-        istream = HexDumpReader.getStreamFromHexDump(\"NumberFormat4185761b.ser.txt\");\n-        p = new ObjectInputStream(istream);\n-        try {\n-            NumberFormat nf = (NumberFormat) p.readObject();\n-            fail(\"FAIL: Deserialized bogus DecimalFormat int:\" +\n-                  nf.getMinimumIntegerDigits() + \"..\" +\n-                  nf.getMaximumIntegerDigits() + \" frac:\" +\n-                  nf.getMinimumFractionDigits() + \"..\" +\n-                  nf.getMaximumFractionDigits());\n-        } catch (InvalidObjectException e) {\n-            System.out.println(\"Ok: \" + e.getMessage());\n-        }\n-        istream.close();\n-    }\n-\n-\n@@ -1933,14 +1852,0 @@\n-@SuppressWarnings(\"serial\")\n-class myformat implements Serializable\n-{\n-    DateFormat _dateFormat = DateFormat.getDateInstance();\n-\n-    public String Now()\n-    {\n-        GregorianCalendar calendar = new GregorianCalendar();\n-        Date t = calendar.getTime();\n-        String nowStr = _dateFormat.format(t);\n-        return nowStr;\n-    }\n-}\n-\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/NumberRegression.java","additions":3,"deletions":98,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4101150\n- * @library \/java\/text\/testlib\n- * @build SerializationLoadTest HexDumpReader\n- * @run main SerializationLoadTest\n- * @summary test serialization compatibility of DecimalFormat and DecimalFormatSymbols\n- * @key randomness\n- *\/\n-\n-import java.io.InputStream;\n-import java.io.ObjectInputStream;\n-import java.io.Serializable;\n-import java.text.DecimalFormat;\n-import java.text.DecimalFormatSymbols;\n-import java.text.NumberFormat;\n-import java.util.Random;\n-\n-public class SerializationLoadTest {\n-\n-    public static void main(String[] args)\n-    {\n-        try {\n-            InputStream istream1 = HexDumpReader.getStreamFromHexDump(\"DecimalFormat.114.txt\");\n-            ObjectInputStream p = new ObjectInputStream(istream1);\n-            CheckDecimalFormat it = (CheckDecimalFormat)p.readObject();\n-            System.out.println(\"1.1.4 DecimalFormat Loaded ok.\");\n-            System.out.println(it.Update());\n-            System.out.println(\"Called Update successfully.\");\n-            istream1.close();\n-\n-            InputStream istream2 = HexDumpReader.getStreamFromHexDump(\"DecimalFormatSymbols.114.txt\");\n-            ObjectInputStream p2 = new ObjectInputStream(istream2);\n-            CheckDecimalFormatSymbols it2 = (CheckDecimalFormatSymbols)p2.readObject();\n-            System.out.println(\"1.1.4 DecimalFormatSymbols Loaded ok.\");\n-            System.out.println(\"getDigit : \"  + it2.Update());\n-            System.out.println(\"Called Update successfully.\");\n-            istream2.close();\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-}\n-\n-@SuppressWarnings(\"serial\")\n-class CheckDecimalFormat implements Serializable\n-{\n-    DecimalFormat _decFormat = (DecimalFormat)NumberFormat.getInstance();\n-\n-    public String Update()\n-    {\n-        Random r = new Random();\n-        return _decFormat.format(r.nextDouble());\n-    }\n-}\n-\n-@SuppressWarnings(\"serial\")\n-class CheckDecimalFormatSymbols implements Serializable\n-{\n-    DecimalFormatSymbols _decFormatSymbols = new DecimalFormatSymbols();\n-\n-    public char Update()\n-    {\n-        return  _decFormatSymbols.getDigit();\n-    }\n-}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/SerializationLoadTest.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * No at-test for this test, because it needs to be run on JDK 1.1.4.\n- * Instead, the resulting serialized files DecimalFormat.114 and\n- * DecimalFormatSymbols.114 are archived.\n- *\/\n-\n-import java.awt.*;\n-import java.text.*;\n-import java.util.*;\n-import java.io.*;\n-\n-public class SerializationSaveTest {\n-\n-    public static void main(String[] args)\n-    {\n-        try {\n-            CheckDecimalFormat it = new CheckDecimalFormat();\n-            System.out.println(it.Update());\n-            FileOutputStream ostream = new FileOutputStream(\"DecimalFormat.114\");\n-            ObjectOutputStream p = new ObjectOutputStream(ostream);\n-            p.writeObject(it);\n-            ostream.close();\n-            System.out.println(\"DecimalFormat saved ok.\");\n-            CheckDecimalFormatSymbols it2 = new CheckDecimalFormatSymbols();\n-            System.out.println(\"getDigit : \"  + it2.Update());\n-            FileOutputStream ostream2 = new FileOutputStream(\"DecimalFormatSymbols.114\");\n-            ObjectOutputStream p2 = new ObjectOutputStream(ostream2);\n-            p2.writeObject(it2);\n-            ostream2.close();\n-            System.out.println(\"DecimalFormatSymbols saved ok.\");\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-}\n-\n-@SuppressWarnings(\"serial\")\n-class CheckDecimalFormat implements Serializable\n-{\n-    DecimalFormat _decFormat = (DecimalFormat)NumberFormat.getInstance();\n-\n-    public String Update()\n-    {\n-        Random r = new Random();\n-        return _decFormat.format(r.nextDouble());\n-    }\n-}\n-\n-@SuppressWarnings(\"serial\")\n-class CheckDecimalFormatSymbols implements Serializable\n-{\n-    DecimalFormatSymbols _decFormatSymbols = new DecimalFormatSymbols();\n-\n-    public char Update()\n-    {\n-        return  _decFormatSymbols.getDigit();\n-    }\n-}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/SerializationSaveTest.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"}]}