{"files":[{"patch":"@@ -1491,80 +1491,0 @@\n-\/\/ Create a new Bool node from the provided Template Assertion Predicate.\n-\/\/ Unswitched loop: new_init and new_stride are both null. Clone OpaqueLoopInit and OpaqueLoopStride.\n-\/\/ Otherwise: Replace found OpaqueLoop* nodes with new_init and new_stride, respectively.\n-Node* PhaseIdealLoop::create_bool_from_template_assertion_predicate(Node* template_assertion_predicate, Node* new_init,\n-                                                                    Node* new_stride, Node* control) {\n-  Node_Stack to_clone(2);\n-  Node* opaque4 = template_assertion_predicate->in(1);\n-  assert(opaque4->Opcode() == Op_Opaque4, \"must be Opaque4\");\n-  to_clone.push(opaque4, 1);\n-  uint current = C->unique();\n-  Node* result = nullptr;\n-  bool is_unswitched_loop = new_init == nullptr && new_stride == nullptr;\n-  assert(new_init != nullptr || is_unswitched_loop, \"new_init must be set when new_stride is non-null\");\n-  \/\/ Look for the opaque node to replace with the new value\n-  \/\/ and clone everything in between. We keep the Opaque4 node\n-  \/\/ so the duplicated predicates are eliminated once loop\n-  \/\/ opts are over: they are here only to keep the IR graph\n-  \/\/ consistent.\n-  do {\n-    Node* n = to_clone.node();\n-    uint i = to_clone.index();\n-    Node* m = n->in(i);\n-    if (is_part_of_template_assertion_predicate_bool(m)) {\n-      to_clone.push(m, 1);\n-      continue;\n-    }\n-    if (m->is_Opaque1()) {\n-      if (n->_idx < current) {\n-        n = n->clone();\n-        register_new_node(n, control);\n-      }\n-      int op = m->Opcode();\n-      if (op == Op_OpaqueLoopInit) {\n-        if (is_unswitched_loop && m->_idx < current && new_init == nullptr) {\n-          new_init = m->clone();\n-          register_new_node(new_init, control);\n-        }\n-        n->set_req(i, new_init);\n-      } else {\n-        assert(op == Op_OpaqueLoopStride, \"unexpected opaque node\");\n-        if (is_unswitched_loop && m->_idx < current && new_stride == nullptr) {\n-          new_stride = m->clone();\n-          register_new_node(new_stride, control);\n-        }\n-        if (new_stride != nullptr) {\n-          n->set_req(i, new_stride);\n-        }\n-      }\n-      to_clone.set_node(n);\n-    }\n-    while (true) {\n-      Node* cur = to_clone.node();\n-      uint j = to_clone.index();\n-      if (j+1 < cur->req()) {\n-        to_clone.set_index(j+1);\n-        break;\n-      }\n-      to_clone.pop();\n-      if (to_clone.size() == 0) {\n-        result = cur;\n-        break;\n-      }\n-      Node* next = to_clone.node();\n-      j = to_clone.index();\n-      if (next->in(j) != cur) {\n-        assert(cur->_idx >= current || next->in(j)->Opcode() == Op_Opaque1, \"new node or Opaque1 being replaced\");\n-        if (next->_idx < current) {\n-          next = next->clone();\n-          register_new_node(next, control);\n-          to_clone.set_node(next);\n-        }\n-        next->set_req(j, cur);\n-      }\n-    }\n-  } while (result == nullptr);\n-  assert(result->_idx >= current, \"new node expected\");\n-  assert(!is_unswitched_loop || new_init != nullptr, \"new_init must always be found and cloned\");\n-  return result;\n-}\n-\n@@ -1576,1 +1496,8 @@\n-  Node* result = create_bool_from_template_assertion_predicate(iff, new_init, new_stride, control);\n+  TemplateAssertionPredicateExpression template_assertion_predicate_expression(iff->in(1)->as_Opaque4());\n+  Opaque4Node* new_opaque4_node;\n+  if (new_stride == nullptr) {\n+    new_opaque4_node = template_assertion_predicate_expression.clone_and_replace_init(new_init, control, this);\n+  } else {\n+    new_opaque4_node = template_assertion_predicate_expression.clone_and_replace_init_and_stride(new_init, new_stride,\n+                                                                                                 control, this);\n+  }\n@@ -1580,1 +1507,1 @@\n-  new_iff->set_req(1, result);\n+  new_iff->set_req(1, new_opaque4_node);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":9,"deletions":82,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -953,2 +953,0 @@\n-  Node* create_bool_from_template_assertion_predicate(Node* template_assertion_predicate, Node* new_init, Node* new_stride,\n-                                                      Node* control);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,0 +173,43 @@\n+\/\/ This strategy replaces the OpaqueLoopInitNode with the provided init node and clones the OpaqueLoopStrideNode.\n+class ReplaceInitAndCloneStrideStrategy : public TransformStrategyForOpaqueLoopNodes {\n+  Node* const _new_init;\n+  Node* const _new_ctrl;\n+  PhaseIdealLoop* const _phase;\n+\n+ public:\n+  ReplaceInitAndCloneStrideStrategy(Node* new_init, Node* new_ctrl, PhaseIdealLoop* phase)\n+      : _new_init(new_init),\n+        _new_ctrl(new_ctrl),\n+        _phase(phase) {}\n+  NONCOPYABLE(ReplaceInitAndCloneStrideStrategy);\n+\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const override {\n+    return _new_init;\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const override {\n+    return _phase->clone_and_register(opaque_stride, _new_ctrl)->as_OpaqueLoopStride();\n+  }\n+};\n+\n+\/\/ This strategy replaces the OpaqueLoopInit and OpaqueLoopStride nodes with the provided init and stride nodes,\n+\/\/ respectively.\n+class ReplaceInitAndStrideStrategy : public TransformStrategyForOpaqueLoopNodes {\n+  Node* const _new_init;\n+  Node* const _new_stride;\n+\n+ public:\n+  ReplaceInitAndStrideStrategy(Node* new_init, Node* new_stride)\n+      : _new_init(new_init),\n+        _new_stride(new_stride) {}\n+  NONCOPYABLE(ReplaceInitAndStrideStrategy);\n+\n+  Node* transform_opaque_init(OpaqueLoopInitNode* opaque_init) const override {\n+    return _new_init;\n+  }\n+\n+  Node* transform_opaque_stride(OpaqueLoopStrideNode* opaque_stride) const override {\n+    return _new_stride;\n+  }\n+};\n+\n@@ -182,0 +225,16 @@\n+\/\/ Same as clone() but instead of cloning the OpaqueLoopInitNode, we replace it with the provided 'new_init' node.\n+Opaque4Node* TemplateAssertionPredicateExpression::clone_and_replace_init(Node* new_init, Node* new_ctrl,\n+                                                                          PhaseIdealLoop* phase) {\n+  ReplaceInitAndCloneStrideStrategy replace_init_and_clone_stride_strategy(new_init, new_ctrl, phase);\n+  return clone(replace_init_and_clone_stride_strategy, new_ctrl, phase);\n+}\n+\n+\/\/ Same as clone() but instead of cloning the OpaqueLoopInit and OpaqueLoopStride node, we replace them with the provided\n+\/\/ 'new_init' and 'new_stride' nodes, respectively.\n+Opaque4Node* TemplateAssertionPredicateExpression::clone_and_replace_init_and_stride(Node* new_init, Node* new_stride,\n+                                                                                     Node* new_ctrl,\n+                                                                                     PhaseIdealLoop* phase) {\n+  ReplaceInitAndStrideStrategy replace_init_and_stride_strategy(new_init, new_stride);\n+  return clone(replace_init_and_stride_strategy, new_ctrl, phase);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -310,0 +310,2 @@\n+  Opaque4Node* clone_and_replace_init(Node* new_init, Node* new_ctrl,PhaseIdealLoop* phase);\n+  Opaque4Node* clone_and_replace_init_and_stride(Node* new_init, Node* new_stride, Node* new_ctrl, PhaseIdealLoop* phase);\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8327110\n+ * @bug 8327110 8327111\n@@ -38,1 +38,1 @@\n- * @run main compiler.predicates.TestCloningWithManyDiamondsInExpression\n+ * @run main\/othervm\/timeout=30 compiler.predicates.TestCloningWithManyDiamondsInExpression\n@@ -41,0 +41,14 @@\n+ \/*\n+  * @test\n+  * @bug 8327111\n+  * @summary Test that DFS algorithm for cloning Template Assertion Predicate Expression does not endlessly process paths.\n+  * @run main\/othervm\/timeout=30 -Xcomp\n+  *                              -XX:CompileCommand=compileonly,*TestCloningWithManyDiamondsInExpression::test*\n+  *                              -XX:CompileCommand=inline,*TestCloningWithManyDiamondsInExpression::create*\n+  *                              compiler.predicates.TestCloningWithManyDiamondsInExpression\n+  * @run main\/othervm\/timeout=30 -Xbatch\n+  *                              -XX:CompileCommand=compileonly,*TestCloningWithManyDiamondsInExpression::test*\n+  *                              -XX:CompileCommand=inline,*TestCloningWithManyDiamondsInExpression::create*\n+  *                              compiler.predicates.TestCloningWithManyDiamondsInExpression\n+  *\/\n+\n@@ -54,0 +68,2 @@\n+            testLoopUnrolling(i % 2);\n+            testLoopPeeling(i % 2);\n@@ -101,0 +117,16 @@\n+    static void testLoopUnrolling(int x) {\n+        int[] a = new int[createExpressionWithManyDiamonds(x) + 1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = i; \/\/ Loop Predication hoists this check and creates a Template Assertion Predicate.\n+        }\n+    }\n+\n+    static void testLoopPeeling(int x) {\n+        int[] a = new int[createExpressionWithManyDiamonds(x) + 1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = i; \/\/ Loop Predication hoists this check and creates a Template Assertion Predicate.\n+            if (x == 0) { \/\/ Reason to peel with LoopMaxUnroll=0\n+                return;\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/predicates\/TestCloningWithManyDiamondsInExpression.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"}]}