{"files":[{"patch":"@@ -627,54 +627,23 @@\n-  if (if_proj->in(0) && if_proj->in(0)->is_If()) {\n-    IfNode* iff = if_proj->in(0)->as_If();\n-    if (iff->in(1) && iff->in(1)->is_Bool()) {\n-      BoolNode* bol = iff->in(1)->as_Bool();\n-      if (bol->in(1) && bol->in(1)->is_Cmp()) {\n-        const CmpNode* cmp  = bol->in(1)->as_Cmp();\n-        if (cmp->in(1) == val) {\n-          const TypeInt* cmp2_t = gvn->type(cmp->in(2))->isa_int();\n-          if (cmp2_t != nullptr) {\n-            jint lo = cmp2_t->_lo;\n-            jint hi = cmp2_t->_hi;\n-            BoolTest::mask msk = if_proj->Opcode() == Op_IfTrue ? bol->_test._test : bol->_test.negate();\n-            switch (msk) {\n-            case BoolTest::ne: {\n-              \/\/ If val is compared to its lower or upper bound, we can narrow the type\n-              const TypeInt* val_t = gvn->type(val)->isa_int();\n-              if (val_t != nullptr && !val_t->singleton() && cmp2_t->is_con()) {\n-                if (val_t->_lo == lo) {\n-                  return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen);\n-                } else if (val_t->_hi == hi) {\n-                  return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen);\n-                }\n-              }\n-              \/\/ Can't refine type\n-              return nullptr;\n-            }\n-            case BoolTest::eq:\n-              return cmp2_t;\n-            case BoolTest::lt:\n-              lo = TypeInt::INT->_lo;\n-              if (hi != min_jint) {\n-                hi = hi - 1;\n-              }\n-              break;\n-            case BoolTest::le:\n-              lo = TypeInt::INT->_lo;\n-              break;\n-            case BoolTest::gt:\n-              if (lo != max_jint) {\n-                lo = lo + 1;\n-              }\n-              hi = TypeInt::INT->_hi;\n-              break;\n-            case BoolTest::ge:\n-              \/\/ lo unchanged\n-              hi = TypeInt::INT->_hi;\n-              break;\n-            default:\n-              break;\n-            }\n-            const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen);\n-            return rtn_t;\n-          }\n-        }\n+  IfNode* iff = if_proj->in(0)->as_If();\n+  BoolNode* bol = iff->in(1)->isa_Bool();\n+  if (bol == nullptr) {\n+    return nullptr;\n+  }\n+  const CmpNode* cmp  = bol->in(1)->as_Cmp();\n+  const TypeInt* cmp2_t = gvn->type(cmp->in(2))->isa_int();\n+  if (cmp->in(1) != val || cmp2_t == nullptr) {\n+    return nullptr;\n+  }\n+\n+  jint lo = cmp2_t->_lo;\n+  jint hi = cmp2_t->_hi;\n+  BoolTest::mask msk = if_proj->Opcode() == Op_IfTrue ? bol->_test._test : bol->_test.negate();\n+  switch (msk) {\n+  case BoolTest::ne: {\n+    \/\/ If val is compared to its lower or upper bound, we can narrow the type\n+    const TypeInt* val_t = gvn->type(val)->isa_int();\n+    if (val_t != nullptr && !val_t->singleton() && cmp2_t->is_con()) {\n+      if (val_t->_lo == lo) {\n+        return TypeInt::make(val_t->_lo + 1, val_t->_hi, val_t->_widen);\n+      } else if (val_t->_hi == hi) {\n+        return TypeInt::make(val_t->_lo, val_t->_hi - 1, val_t->_widen);\n@@ -683,0 +652,2 @@\n+    \/\/ Can't refine type\n+    return nullptr;\n@@ -684,1 +655,26 @@\n-  return nullptr;\n+  case BoolTest::eq:\n+    return cmp2_t;\n+  case BoolTest::lt:\n+    lo = TypeInt::INT->_lo;\n+    if (hi != min_jint) {\n+      hi = hi - 1;\n+    }\n+    break;\n+  case BoolTest::le:\n+    lo = TypeInt::INT->_lo;\n+    break;\n+  case BoolTest::gt:\n+    if (lo != max_jint) {\n+      lo = lo + 1;\n+    }\n+    hi = TypeInt::INT->_hi;\n+    break;\n+  case BoolTest::ge:\n+    \/\/ lo unchanged\n+    hi = TypeInt::INT->_hi;\n+    break;\n+  default:\n+    break;\n+  }\n+  const TypeInt* rtn_t = TypeInt::make(lo, hi, cmp2_t->_widen);\n+  return rtn_t;\n@@ -1018,1 +1014,1 @@\n-        if (failtype->_lo > failtype->_hi) {\n+        if (failtype->empty()) {\n@@ -1026,2 +1022,1 @@\n-    lo = nullptr;\n-    hi = nullptr;\n+    return false;\n@@ -1030,7 +1025,24 @@\n-  if (lo && hi) {\n-    Node* hook = new Node(1);\n-    hook->init_req(0, lo); \/\/ Add a use to lo to prevent him from dying\n-    \/\/ Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))\n-    Node* adjusted_val = igvn->transform(new SubINode(n,  lo));\n-    if (adjusted_lim == nullptr) {\n-      adjusted_lim = igvn->transform(new SubINode(hi, lo));\n+  Node* hook = new Node(lo); \/\/ Add a use to lo to prevent him from dying\n+  \/\/ Merge the two compares into a single unsigned compare by building (CmpU (n - lo) (hi - lo))\n+  Node* adjusted_val = igvn->transform(new SubINode(n,  lo));\n+  if (adjusted_lim == nullptr) {\n+    adjusted_lim = igvn->transform(new SubINode(hi, lo));\n+  }\n+  hook->destruct(igvn);\n+\n+  if (igvn->type(adjusted_lim)->is_int()->_lo < 0 &&\n+      !igvn->C->post_loop_opts_phase()) {\n+    \/\/ If range check elimination applies to this comparison, it includes code to protect from overflows that may\n+    \/\/ cause the main loop to be skipped entirely. Delay this transformation.\n+    \/\/ Example:\n+    \/\/ for (int i = 0; i < limit; i++) {\n+    \/\/   if (i < max_jint && i > min_jint) {...\n+    \/\/ }\n+    \/\/ Comparisons folded as:\n+    \/\/ i - min_jint - 1 <u -2\n+    \/\/ when RC applies, main loop limit becomes:\n+    \/\/ min(limit, max(-2 + min_jint + 1, min_jint))\n+    \/\/ = min(limit, min_jint)\n+    \/\/ = min_jint\n+    if (adjusted_val->outcnt() == 0) {\n+      igvn->remove_dead_node(adjusted_val);\n@@ -1038,26 +1050,2 @@\n-    hook->destruct(igvn);\n-\n-    int lo = igvn->type(adjusted_lim)->is_int()->_lo;\n-    if (lo < 0) {\n-      \/\/ If range check elimination applies to this comparison, it includes code to protect from overflows that may\n-      \/\/ cause the main loop to be skipped entirely. Delay this transformation.\n-      \/\/ Example:\n-      \/\/ for (int i = 0; i < limit; i++) {\n-      \/\/   if (i < max_jint && i > min_jint) {...\n-      \/\/ }\n-      \/\/ Comparisons folded as:\n-      \/\/ i - min_jint - 1 <u -2\n-      \/\/ when RC applies, main loop limit becomes:\n-      \/\/ min(limit, max(-2 + min_jint + 1, min_jint))\n-      \/\/ = min(limit, min_jint)\n-      \/\/ = min_jint\n-      if (!igvn->C->post_loop_opts_phase()) {\n-        if (adjusted_val->outcnt() == 0) {\n-          igvn->remove_dead_node(adjusted_val);\n-        }\n-        if (adjusted_lim->outcnt() == 0) {\n-          igvn->remove_dead_node(adjusted_lim);\n-        }\n-        igvn->C->record_for_post_loop_opts_igvn(this);\n-        return false;\n-      }\n+    if (adjusted_lim->outcnt() == 0) {\n+      igvn->remove_dead_node(adjusted_lim);\n@@ -1065,0 +1053,3 @@\n+    igvn->C->record_for_post_loop_opts_igvn(this);\n+    return false;\n+  }\n@@ -1066,2 +1057,2 @@\n-    Node* newcmp = igvn->transform(new CmpUNode(adjusted_val, adjusted_lim));\n-    Node* newbool = igvn->transform(new BoolNode(newcmp, cond));\n+  Node* newcmp = igvn->transform(new CmpUNode(adjusted_val, adjusted_lim));\n+  Node* newbool = igvn->transform(new BoolNode(newcmp, cond));\n@@ -1069,2 +1060,2 @@\n-    igvn->replace_input_of(dom_iff, 1, igvn->intcon(proj->_con));\n-    igvn->replace_input_of(this, 1, newbool);\n+  igvn->replace_input_of(dom_iff, 1, igvn->intcon(proj->_con));\n+  igvn->replace_input_of(this, 1, newbool);\n@@ -1072,3 +1063,1 @@\n-    return true;\n-  }\n-  return false;\n+  return true;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":87,"deletions":98,"binary":false,"changes":185,"status":"modified"}]}