{"files":[{"patch":"@@ -0,0 +1,276 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8345403\n+ * @summary FloatingDecimal parsing methods (use -Dseed=X to set seed)\n+ * @modules java.base\/jdk.internal.math\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @run junit TestRandomFloatingDecimal\n+ * @key randomness\n+ *\/\n+\n+import jdk.internal.math.FloatingDecimal;\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Random;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class TestRandomFloatingDecimal {\n+\n+    \/*\n+     * This class relies on the correctness of\n+     *      BigInteger string parsing, both decimal and hexadecimal\n+     *      BigDecimal floatValue() and doubleValue() conversions\n+     * and on the fact that the implementation of the BigDecimal conversions is\n+     * independent of the implementation in FloatingDecimal.\n+     * Hence, the expected values are those computed by BigDecimal,\n+     * while the actual values are those returned by FloatingDecimal.\n+     *\/\n+    private static final int COUNT = 10_000;  \/\/ random samples per test\n+\n+    private static final Random RANDOM = RandomFactory.getRandom();\n+\n+    static Stream<Args> testRandomDecForFloat() {\n+        return Stream.generate(() -> randomDec(false)).limit(COUNT);\n+    }\n+\n+    static Stream<Args> testRandomDecForDouble() {\n+        return Stream.generate(() -> randomDec(true)).limit(COUNT);\n+    }\n+\n+    static Stream<Args> testRandomHexForFloat() {\n+        return Stream.generate(() -> randomHex(false)).limit(COUNT);\n+    }\n+\n+    static Stream<Args> testRandomHexForDouble() {\n+        return Stream.generate(() -> randomHex(true)).limit(COUNT);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testRandomDecForFloat(Args args) {\n+        float expected = args.decimal().floatValue();\n+        float actual = FloatingDecimal.parseFloat(args.s());\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testRandomDecForDouble(Args args) {\n+        double expected = args.decimal().doubleValue();\n+        double actual = FloatingDecimal.parseDouble(args.s());\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testRandomHexForFloat(Args args) {\n+        float expected = args.decimal().floatValue();\n+        float actual = FloatingDecimal.parseFloat(args.s());\n+        assertEquals(expected, actual);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void testRandomHexForDouble(Args args) {\n+       double expected = args.decimal().doubleValue();\n+       double actual = FloatingDecimal.parseDouble(args.s());\n+       assertEquals(expected, actual);\n+    }\n+\n+    private record Args(String s, BigDecimal decimal) {}\n+\n+    private static Args randomDec(boolean forDouble) {\n+        StringBuilder sb = new StringBuilder();\n+        int leadingWhites = RANDOM.nextInt(4);\n+        appendRandomWhitespace(sb, leadingWhites);\n+        int signLen = appendRandomSign(sb);\n+        int leadingZeros = RANDOM.nextInt(4);\n+        appendZeros(sb, leadingZeros);\n+        int digits = RANDOM.nextInt(forDouble ? 24 : 12) + 1;\n+        appendRandomDecDigits(sb, digits);\n+        int trailingZeros = RANDOM.nextInt(4);\n+        appendZeros(sb, trailingZeros);\n+        BigDecimal bd = new BigDecimal(new BigInteger(\n+                sb.substring(\n+                        leadingWhites,\n+                        leadingWhites + signLen + leadingZeros + digits + trailingZeros),\n+                10));\n+\n+        int p = 0;\n+        if (RANDOM.nextInt(8) != 0) {  \/\/ 87.5% chance of point presence\n+            int pointPos = RANDOM.nextInt(leadingZeros + digits + trailingZeros + 1);\n+            sb.insert(leadingWhites + signLen + pointPos, '.');\n+            p = -(leadingZeros + digits + trailingZeros - pointPos);\n+        }\n+        int e = 0;\n+        if (RANDOM.nextInt(4) != 0) {  \/\/ 75% chance of explicit exponent\n+            int emax = forDouble ? 325 : 46;\n+            e = RANDOM.nextInt(-emax, emax);\n+            appendExponent(sb, e, true);\n+        }\n+        appendRandomSuffix(sb);\n+        int trailingWhites = RANDOM.nextInt(4);\n+        appendRandomWhitespace(sb, trailingWhites);\n+        if (e + p >= 0) {\n+            bd = bd .multiply(BigDecimal.TEN.pow(e + p));\n+        } else {\n+            bd = bd .divide(BigDecimal.TEN.pow(-(e + p)));\n+        }\n+        return new Args(sb.toString(), bd);\n+    }\n+\n+    private static Args randomHex(boolean forDouble) {\n+        StringBuilder sb = new StringBuilder();\n+        int leadingWhites = RANDOM.nextInt(4);\n+        appendRandomWhitespace(sb, leadingWhites);\n+        int signLen = appendRandomSign(sb);\n+        appendHexPrefix(sb);\n+        int leadingZeros = RANDOM.nextInt(4);\n+        appendZeros(sb, leadingZeros);\n+        int digits = RANDOM.nextInt(forDouble ? 24 : 12) + 1;\n+        appendRandomHexDigits(sb, digits);\n+        int trailingZeros = RANDOM.nextInt(4);\n+        appendZeros(sb, trailingZeros);\n+        BigDecimal bd = new BigDecimal(new BigInteger(  \/\/ don't include 0x or 0X\n+                sb.substring(leadingWhites, leadingWhites + signLen) +\n+                sb.substring(\n+                        leadingWhites + signLen + 2,\n+                        leadingWhites + signLen + 2 + leadingZeros + digits + trailingZeros),\n+                0x10));\n+\n+        int p = 0;\n+        if (RANDOM.nextInt(8) != 0) {  \/\/ 87.5% chance for a point\n+            int pointPos = RANDOM.nextInt(leadingZeros + digits + trailingZeros + 1);\n+            sb.insert(leadingWhites + signLen + 2 + pointPos, '.');\n+            p = -4 * (leadingZeros + digits + trailingZeros - pointPos);\n+        }\n+        int emax = forDouble ? 1075 : 150;\n+        int e = RANDOM.nextInt(-emax, emax);\n+        appendExponent(sb, e, false);\n+        appendRandomSuffix(sb);\n+        int trailingWhites = RANDOM.nextInt(4);\n+        appendRandomWhitespace(sb, trailingWhites);\n+        if (e + p >= 0) {\n+            bd = bd .multiply(BigDecimal.TWO.pow(e + p));\n+        } else {\n+            bd = bd .divide(BigDecimal.TWO.pow(-(e + p)));\n+        }\n+        return new Args(sb.toString(), bd);\n+    }\n+\n+    private static int appendRandomSign(StringBuilder sb) {\n+        return switch (RANDOM.nextInt(4)) {  \/\/ 50% chance of tacit sign\n+            case 0 -> {\n+                sb.append('-');\n+                yield 1;\n+            }\n+            case 1 -> {\n+                sb.append('+');\n+                yield 1;\n+            }\n+            default -> 0;\n+        };\n+    }\n+\n+    private static void appendExponent(StringBuilder sb, int e, boolean forDec) {\n+        if (forDec) {\n+            sb.append(RANDOM.nextBoolean() ? 'e' : 'E');\n+        } else {\n+            sb.append(RANDOM.nextBoolean() ? 'p' : 'P');\n+        }\n+        if (e < 0) {\n+            sb.append('-');\n+        } else if (e == 0) {\n+            appendRandomSign(sb);\n+        } else if (RANDOM.nextBoolean()) {\n+            sb.append('+');\n+        }\n+        appendZeros(sb, RANDOM.nextInt(2));\n+        sb.append(Math.abs(e));\n+    }\n+\n+    private static void appendRandomSuffix(StringBuilder sb) {\n+        switch (RANDOM.nextInt(8)) {  \/\/ 50% chance of no suffix\n+            case 0 -> sb.append('D');\n+            case 1 -> sb.append('F');\n+            case 2 -> sb.append('d');\n+            case 3 -> sb.append('f');\n+        }\n+    }\n+\n+    private static void appendHexPrefix(StringBuilder sb) {\n+        \/* Randomize case of x. *\/\n+        sb.append('0').append(RANDOM.nextBoolean() ? 'x' : 'X');\n+    }\n+\n+    private static void appendZeros(StringBuilder sb, int count) {\n+        sb.repeat('0', count);\n+    }\n+\n+    private static void appendRandomDecDigits(StringBuilder sb, int count) {\n+        sb.append(randomDecDigit(1));\n+        for (; count > 1; --count) {\n+            sb.append(randomDecDigit(0));\n+        }\n+    }\n+\n+    private static void appendRandomHexDigits(StringBuilder sb, int count) {\n+        sb.append(randomHexDigit(1));\n+        for (; count > 1; --count) {\n+            sb.append(randomHexDigit(0));\n+        }\n+    }\n+\n+    private static char randomHexDigit(int min) {\n+        char c = Character.forDigit(RANDOM.nextInt(min, 0x10), 0x10);\n+        \/* Randomize letter case as well. *\/\n+        return RANDOM.nextBoolean() ? Character.toLowerCase(c) : Character.toUpperCase(c);\n+    }\n+\n+    private static char randomDecDigit(int min) {\n+        int c = Character.forDigit(RANDOM.nextInt(min, 10), 10);\n+        return (char) c;\n+    }\n+\n+    private static void appendRandomWhitespace(StringBuilder sb, int count) {\n+        \/* Randomize all whitespace chars. *\/\n+        for (; count > 0; --count) {\n+            sb.append(randomWhitespace());\n+        }\n+    }\n+\n+    private static char randomWhitespace() {\n+        return (char) (RANDOM.nextInt(0x20 + 1));\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/math\/FloatingDecimal\/TestRandomFloatingDecimal.java","additions":276,"deletions":0,"binary":false,"changes":276,"status":"added"}]}