{"files":[{"patch":"@@ -562,3 +562,4 @@\n-          \"When HeapDumpOnOutOfMemoryError is on, the path (filename or \"   \\\n-          \"directory) of the dump file (defaults to java_pid<pid>.hprof \"   \\\n-          \"in the working directory)\")                                      \\\n+          \"When HeapDumpOnOutOfMemoryError is on, or a heap dump is \"       \\\n+          \"triggered by jcmd GC.heap_dump without specifying a path, \"      \\\n+          \"the path (filename or directory) of the dump file \"              \\\n+          \"(defaults to java_pid<pid>.hprof in the working directory)\")     \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -475,1 +475,1 @@\n-  _filename(\"filename\",\"Name of the dump file\", \"STRING\",true),\n+  _filename(\"filename\",\"Name of the dump file\", \"STRING\", false, \"-XX:HeapDumpPath\"),\n@@ -496,0 +496,4 @@\n+  \/\/ in case no specific filename was passed to heap_dump command,\n+  \/\/ attempt to use the HeapDumpPath if it was set\n+  const char* filename = HeapDumpPath;\n+  bool use_heapdump_path = false;\n@@ -518,0 +522,10 @@\n+  if (filename == nullptr && !_filename.is_set()) {\n+    output()->print_cr(\"Filename or -XX:HeapDumpPath must be set!\");\n+    return;\n+  } else if (_filename.is_set()) {\n+    filename = _filename.value();\n+  } else {\n+    \/\/ use HeapDumpPath (file or directory is possible)\n+    use_heapdump_path = true;\n+  }\n+\n@@ -522,1 +536,6 @@\n-  dumper.dump(_filename.value(), output(), (int) level, _overwrite.value(), (uint)parallel);\n+\n+  if (use_heapdump_path) {\n+    dumper.dump_to_heapdump_path(output(), (int)level, _overwrite.value(), (uint)parallel);\n+  } else {\n+    dumper.dump(filename, output(), (int)level, _overwrite.value(), (uint)parallel);\n+  }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2612,0 +2612,92 @@\n+static uint dump_file_seq = 0;\n+\n+\/\/ helper function to create the heap dump path name\n+\/\/ the caller must free the returned pointer\n+static char* alloc_and_create_heapdump_pathname() {\n+  static char base_path[JVM_MAXPATHLEN] = {'\\0'};\n+  char* my_path;\n+  const int max_digit_chars = 20;\n+\n+  const char* dump_file_name = \"java_pid\";\n+  const char* dump_file_ext  = HeapDumpGzipLevel > 0 ? \".hprof.gz\" : \".hprof\";\n+\n+  \/\/ The dump file defaults to java_pid<pid>.hprof in the current working\n+  \/\/ directory. HeapDumpPath=<file> can be used to specify an alternative\n+  \/\/ dump file name or a directory where dump file is created.\n+  if (dump_file_seq == 0) { \/\/ first time in, we initialize base_path\n+    \/\/ Calculate potentially longest base path and check if we have enough\n+    \/\/ allocated statically.\n+    const size_t total_length =\n+                      (HeapDumpPath == nullptr ? 0 : strlen(HeapDumpPath)) +\n+                      strlen(os::file_separator()) + max_digit_chars +\n+                      strlen(dump_file_name) + strlen(dump_file_ext) + 1;\n+    if (total_length > sizeof(base_path)) {\n+      warning(\"Cannot create heap dump file.  HeapDumpPath is too long.\");\n+      return nullptr;\n+    }\n+\n+    bool use_default_filename = true;\n+    if (HeapDumpPath == nullptr || HeapDumpPath[0] == '\\0') {\n+      \/\/ HeapDumpPath=<file> not specified\n+    } else {\n+      strcpy(base_path, HeapDumpPath);\n+      \/\/ check if the path is a directory (must exist)\n+      DIR* dir = os::opendir(base_path);\n+      if (dir == nullptr) {\n+        use_default_filename = false;\n+      } else {\n+        \/\/ HeapDumpPath specified a directory. We append a file separator\n+        \/\/ (if needed).\n+        os::closedir(dir);\n+        size_t fs_len = strlen(os::file_separator());\n+        if (strlen(base_path) >= fs_len) {\n+          char* end = base_path;\n+          end += (strlen(base_path) - fs_len);\n+          if (strcmp(end, os::file_separator()) != 0) {\n+            strcat(base_path, os::file_separator());\n+          }\n+        }\n+      }\n+    }\n+    \/\/ If HeapDumpPath wasn't a file name then we append the default name\n+    if (use_default_filename) {\n+      const size_t dlen = strlen(base_path);  \/\/ if heap dump dir specified\n+      jio_snprintf(&base_path[dlen], sizeof(base_path)-dlen, \"%s%d%s\",\n+                   dump_file_name, os::current_process_id(), dump_file_ext);\n+    }\n+    const size_t len = strlen(base_path) + 1;\n+    my_path = (char*)os::malloc(len, mtInternal);\n+    if (my_path == nullptr) {\n+      warning(\"Cannot create heap dump file.  Out of system memory.\");\n+      return nullptr;\n+    }\n+    strncpy(my_path, base_path, len);\n+  } else {\n+    \/\/ Append a sequence number id for dumps following the first\n+    const size_t len = strlen(base_path) + max_digit_chars + 2; \/\/ for '.' and \\0\n+    my_path = (char*)os::malloc(len, mtInternal);\n+    if (my_path == nullptr) {\n+      warning(\"Cannot create heap dump file.  Out of system memory.\");\n+      return nullptr;\n+    }\n+    jio_snprintf(my_path, len, \"%s.%d\", base_path, dump_file_seq);\n+  }\n+  dump_file_seq++;   \/\/ increment seq number for next time we dump\n+  return my_path;\n+}\n+\n+\n+int HeapDumper::dump_to_heapdump_path(outputStream* out, int compression, bool overwrite, uint num_dump_threads) {\n+  if (HeapDumpPath == nullptr || HeapDumpPath[0] == '\\0') {\n+    return -1;\n+  }\n+\n+  char* h_path = alloc_and_create_heapdump_pathname();\n+  if (h_path != nullptr) {\n+    int res = dump(h_path, out, compression, overwrite, num_dump_threads);\n+    os::free(h_path);\n+    return res;\n+  }\n+  return -1;\n+}\n+\n@@ -2756,68 +2848,6 @@\n-  static char base_path[JVM_MAXPATHLEN] = {'\\0'};\n-  static uint dump_file_seq = 0;\n-  char* my_path;\n-  const int max_digit_chars = 20;\n-\n-  const char* dump_file_name = \"java_pid\";\n-  const char* dump_file_ext  = HeapDumpGzipLevel > 0 ? \".hprof.gz\" : \".hprof\";\n-\n-  \/\/ The dump file defaults to java_pid<pid>.hprof in the current working\n-  \/\/ directory. HeapDumpPath=<file> can be used to specify an alternative\n-  \/\/ dump file name or a directory where dump file is created.\n-  if (dump_file_seq == 0) { \/\/ first time in, we initialize base_path\n-    \/\/ Calculate potentially longest base path and check if we have enough\n-    \/\/ allocated statically.\n-    const size_t total_length =\n-                      (HeapDumpPath == nullptr ? 0 : strlen(HeapDumpPath)) +\n-                      strlen(os::file_separator()) + max_digit_chars +\n-                      strlen(dump_file_name) + strlen(dump_file_ext) + 1;\n-    if (total_length > sizeof(base_path)) {\n-      warning(\"Cannot create heap dump file.  HeapDumpPath is too long.\");\n-      return;\n-    }\n-\n-    bool use_default_filename = true;\n-    if (HeapDumpPath == nullptr || HeapDumpPath[0] == '\\0') {\n-      \/\/ HeapDumpPath=<file> not specified\n-    } else {\n-      strcpy(base_path, HeapDumpPath);\n-      \/\/ check if the path is a directory (must exist)\n-      DIR* dir = os::opendir(base_path);\n-      if (dir == nullptr) {\n-        use_default_filename = false;\n-      } else {\n-        \/\/ HeapDumpPath specified a directory. We append a file separator\n-        \/\/ (if needed).\n-        os::closedir(dir);\n-        size_t fs_len = strlen(os::file_separator());\n-        if (strlen(base_path) >= fs_len) {\n-          char* end = base_path;\n-          end += (strlen(base_path) - fs_len);\n-          if (strcmp(end, os::file_separator()) != 0) {\n-            strcat(base_path, os::file_separator());\n-          }\n-        }\n-      }\n-    }\n-    \/\/ If HeapDumpPath wasn't a file name then we append the default name\n-    if (use_default_filename) {\n-      const size_t dlen = strlen(base_path);  \/\/ if heap dump dir specified\n-      jio_snprintf(&base_path[dlen], sizeof(base_path)-dlen, \"%s%d%s\",\n-                   dump_file_name, os::current_process_id(), dump_file_ext);\n-    }\n-    const size_t len = strlen(base_path) + 1;\n-    my_path = (char*)os::malloc(len, mtInternal);\n-    if (my_path == nullptr) {\n-      warning(\"Cannot create heap dump file.  Out of system memory.\");\n-      return;\n-    }\n-    strncpy(my_path, base_path, len);\n-  } else {\n-    \/\/ Append a sequence number id for dumps following the first\n-    const size_t len = strlen(base_path) + max_digit_chars + 2; \/\/ for '.' and \\0\n-    my_path = (char*)os::malloc(len, mtInternal);\n-    if (my_path == nullptr) {\n-      warning(\"Cannot create heap dump file.  Out of system memory.\");\n-      return;\n-    }\n-    jio_snprintf(my_path, len, \"%s.%d\", base_path, dump_file_seq);\n+  char* h_path = alloc_and_create_heapdump_pathname();\n+  if (h_path != nullptr) {\n+    HeapDumper dumper(false \/* no GC before heap dump *\/,\n+                      oome  \/* pass along out-of-memory-error flag *\/);\n+    dumper.dump(h_path, tty, HeapDumpGzipLevel);\n+    os::free(h_path);\n@@ -2825,6 +2855,0 @@\n-  dump_file_seq++;   \/\/ increment seq number for next time we dump\n-\n-  HeapDumper dumper(false \/* no GC before heap dump *\/,\n-                    oome  \/* pass along out-of-memory-error flag *\/);\n-  dumper.dump(my_path, tty, HeapDumpGzipLevel);\n-  os::free(my_path);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":98,"deletions":74,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+  \/\/ same as dump with path parameter, but uses the preset HeapDumpPath file or directory\n+  int dump_to_heapdump_path(outputStream* out, int compression, bool overwrite, uint parallel_thread_num);\n+\n","filename":"src\/hotspot\/share\/services\/heapDumper.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}