{"files":[{"patch":"@@ -562,3 +562,5 @@\n-          \"When HeapDumpOnOutOfMemoryError is on, the path (filename or \"   \\\n-          \"directory) of the dump file (defaults to java_pid<pid>.hprof \"   \\\n-          \"in the working directory)\")                                      \\\n+          \"When HeapDumpOnOutOfMemoryError is enabled, or a heap dump is \"  \\\n+          \"triggered by jcmd GC.heap_dump without specifying a path, \"      \\\n+          \"the path (filename or directory) of the dump file. \"             \\\n+          \"(in case of HeapDumpOnOutOfMemoryError only: \"                   \\\n+          \"defaults to java_pid<pid>.hprof in the working directory)\")      \\\n@@ -567,1 +569,1 @@\n-          \"When HeapDumpOnOutOfMemoryError is on, the gzip compression \"    \\\n+          \"When HeapDumpOnOutOfMemoryError is enabled, the gzip compression \" \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -475,1 +475,1 @@\n-  _filename(\"filename\",\"Name of the dump file\", \"STRING\",true),\n+  _filename(\"filename\",\"Name of the dump file\", \"STRING\", false, \"if no filename was specified, but -XX:HeapDumpPath=hdp is set, path hdp is taken\"),\n@@ -496,0 +496,1 @@\n+  bool use_heapdump_path = false;\n@@ -518,0 +519,10 @@\n+  if (!_filename.is_set()) {\n+    if (HeapDumpPath != nullptr) {\n+      \/\/ use HeapDumpPath (file or directory is possible)\n+      use_heapdump_path = true;\n+    } else {\n+      output()->print_cr(\"Filename or -XX:HeapDumpPath must be set!\");\n+      return;\n+    }\n+  }\n+\n@@ -522,1 +533,6 @@\n-  dumper.dump(_filename.value(), output(), (int) level, _overwrite.value(), (uint)parallel);\n+\n+  if (use_heapdump_path) {\n+    dumper.dump_to(output(), (int)level, _overwrite.value(), (uint)parallel);\n+  } else {\n+    dumper.dump(_filename.value(), output(), (int)level, _overwrite.value(), (uint)parallel);\n+  }\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2612,0 +2612,92 @@\n+static uint dump_file_seq = 0;\n+\n+\/\/ helper function to create the heap dump path name\n+\/\/ the caller must free the returned pointer\n+static char* alloc_and_create_heapdump_pathname() {\n+  static char base_path[JVM_MAXPATHLEN] = {'\\0'};\n+  char* my_path;\n+  const int max_digit_chars = 20;\n+\n+  const char* dump_file_name = \"java_pid\";\n+  const char* dump_file_ext  = HeapDumpGzipLevel > 0 ? \".hprof.gz\" : \".hprof\";\n+\n+  \/\/ The dump file defaults to java_pid<pid>.hprof in the current working\n+  \/\/ directory. HeapDumpPath=<file> can be used to specify an alternative\n+  \/\/ dump file name or a directory where dump file is created.\n+  if (dump_file_seq == 0) { \/\/ first time in, we initialize base_path\n+    \/\/ Calculate potentially longest base path and check if we have enough\n+    \/\/ allocated statically.\n+    const size_t total_length =\n+                      (HeapDumpPath == nullptr ? 0 : strlen(HeapDumpPath)) +\n+                      strlen(os::file_separator()) + max_digit_chars +\n+                      strlen(dump_file_name) + strlen(dump_file_ext) + 1;\n+    if (total_length > sizeof(base_path)) {\n+      warning(\"Cannot create heap dump file.  HeapDumpPath is too long.\");\n+      return nullptr;\n+    }\n+\n+    bool use_default_filename = true;\n+    if (HeapDumpPath == nullptr || HeapDumpPath[0] == '\\0') {\n+      \/\/ HeapDumpPath=<file> not specified\n+    } else {\n+      strcpy(base_path, HeapDumpPath);\n+      \/\/ check if the path is a directory (must exist)\n+      DIR* dir = os::opendir(base_path);\n+      if (dir == nullptr) {\n+        use_default_filename = false;\n+      } else {\n+        \/\/ HeapDumpPath specified a directory. We append a file separator\n+        \/\/ (if needed).\n+        os::closedir(dir);\n+        size_t fs_len = strlen(os::file_separator());\n+        if (strlen(base_path) >= fs_len) {\n+          char* end = base_path;\n+          end += (strlen(base_path) - fs_len);\n+          if (strcmp(end, os::file_separator()) != 0) {\n+            strcat(base_path, os::file_separator());\n+          }\n+        }\n+      }\n+    }\n+    \/\/ If HeapDumpPath wasn't a file name then we append the default name\n+    if (use_default_filename) {\n+      const size_t dlen = strlen(base_path);  \/\/ if heap dump dir specified\n+      jio_snprintf(&base_path[dlen], sizeof(base_path)-dlen, \"%s%d%s\",\n+                   dump_file_name, os::current_process_id(), dump_file_ext);\n+    }\n+    const size_t len = strlen(base_path) + 1;\n+    my_path = (char*)os::malloc(len, mtInternal);\n+    if (my_path == nullptr) {\n+      warning(\"Cannot create heap dump file.  Out of system memory.\");\n+      return nullptr;\n+    }\n+    strncpy(my_path, base_path, len);\n+  } else {\n+    \/\/ Append a sequence number id for dumps following the first\n+    const size_t len = strlen(base_path) + max_digit_chars + 2; \/\/ for '.' and \\0\n+    my_path = (char*)os::malloc(len, mtInternal);\n+    if (my_path == nullptr) {\n+      warning(\"Cannot create heap dump file.  Out of system memory.\");\n+      return nullptr;\n+    }\n+    jio_snprintf(my_path, len, \"%s.%d\", base_path, dump_file_seq);\n+  }\n+  dump_file_seq++;   \/\/ increment seq number for next time we dump\n+  return my_path;\n+}\n+\n+\n+int HeapDumper::dump_to(outputStream* out, int compression, bool overwrite, uint num_dump_threads) {\n+  if (HeapDumpPath == nullptr || HeapDumpPath[0] == '\\0') {\n+    return -1;\n+  }\n+\n+  char* h_path = alloc_and_create_heapdump_pathname();\n+  if (h_path != nullptr) {\n+    int res = dump(h_path, out, compression, overwrite, num_dump_threads);\n+    os::free(h_path);\n+    return res;\n+  }\n+  return -1;\n+}\n+\n@@ -2756,68 +2848,6 @@\n-  static char base_path[JVM_MAXPATHLEN] = {'\\0'};\n-  static uint dump_file_seq = 0;\n-  char* my_path;\n-  const int max_digit_chars = 20;\n-\n-  const char* dump_file_name = \"java_pid\";\n-  const char* dump_file_ext  = HeapDumpGzipLevel > 0 ? \".hprof.gz\" : \".hprof\";\n-\n-  \/\/ The dump file defaults to java_pid<pid>.hprof in the current working\n-  \/\/ directory. HeapDumpPath=<file> can be used to specify an alternative\n-  \/\/ dump file name or a directory where dump file is created.\n-  if (dump_file_seq == 0) { \/\/ first time in, we initialize base_path\n-    \/\/ Calculate potentially longest base path and check if we have enough\n-    \/\/ allocated statically.\n-    const size_t total_length =\n-                      (HeapDumpPath == nullptr ? 0 : strlen(HeapDumpPath)) +\n-                      strlen(os::file_separator()) + max_digit_chars +\n-                      strlen(dump_file_name) + strlen(dump_file_ext) + 1;\n-    if (total_length > sizeof(base_path)) {\n-      warning(\"Cannot create heap dump file.  HeapDumpPath is too long.\");\n-      return;\n-    }\n-\n-    bool use_default_filename = true;\n-    if (HeapDumpPath == nullptr || HeapDumpPath[0] == '\\0') {\n-      \/\/ HeapDumpPath=<file> not specified\n-    } else {\n-      strcpy(base_path, HeapDumpPath);\n-      \/\/ check if the path is a directory (must exist)\n-      DIR* dir = os::opendir(base_path);\n-      if (dir == nullptr) {\n-        use_default_filename = false;\n-      } else {\n-        \/\/ HeapDumpPath specified a directory. We append a file separator\n-        \/\/ (if needed).\n-        os::closedir(dir);\n-        size_t fs_len = strlen(os::file_separator());\n-        if (strlen(base_path) >= fs_len) {\n-          char* end = base_path;\n-          end += (strlen(base_path) - fs_len);\n-          if (strcmp(end, os::file_separator()) != 0) {\n-            strcat(base_path, os::file_separator());\n-          }\n-        }\n-      }\n-    }\n-    \/\/ If HeapDumpPath wasn't a file name then we append the default name\n-    if (use_default_filename) {\n-      const size_t dlen = strlen(base_path);  \/\/ if heap dump dir specified\n-      jio_snprintf(&base_path[dlen], sizeof(base_path)-dlen, \"%s%d%s\",\n-                   dump_file_name, os::current_process_id(), dump_file_ext);\n-    }\n-    const size_t len = strlen(base_path) + 1;\n-    my_path = (char*)os::malloc(len, mtInternal);\n-    if (my_path == nullptr) {\n-      warning(\"Cannot create heap dump file.  Out of system memory.\");\n-      return;\n-    }\n-    strncpy(my_path, base_path, len);\n-  } else {\n-    \/\/ Append a sequence number id for dumps following the first\n-    const size_t len = strlen(base_path) + max_digit_chars + 2; \/\/ for '.' and \\0\n-    my_path = (char*)os::malloc(len, mtInternal);\n-    if (my_path == nullptr) {\n-      warning(\"Cannot create heap dump file.  Out of system memory.\");\n-      return;\n-    }\n-    jio_snprintf(my_path, len, \"%s.%d\", base_path, dump_file_seq);\n+  char* h_path = alloc_and_create_heapdump_pathname();\n+  if (h_path != nullptr) {\n+    HeapDumper dumper(false \/* no GC before heap dump *\/,\n+                      oome  \/* pass along out-of-memory-error flag *\/);\n+    dumper.dump(h_path, tty, HeapDumpGzipLevel);\n+    os::free(h_path);\n@@ -2825,6 +2855,0 @@\n-  dump_file_seq++;   \/\/ increment seq number for next time we dump\n-\n-  HeapDumper dumper(false \/* no GC before heap dump *\/,\n-                    oome  \/* pass along out-of-memory-error flag *\/);\n-  dumper.dump(my_path, tty, HeapDumpGzipLevel);\n-  os::free(my_path);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":98,"deletions":74,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+  \/\/ same as dump with path parameter, but uses the preset HeapDumpPath file or directory\n+  int dump_to(outputStream* out, int compression, bool overwrite, uint parallel_thread_num);\n+\n","filename":"src\/hotspot\/share\/services\/heapDumper.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2836,3 +2836,3 @@\n-option is set.\n-By default, the file is created in the current working directory, and\n-it\\[aq]s named \\f[V]java_pid<pid>.hprof\\f[R] where \\f[V]<pid>\\f[R] is\n+option is set or a heap dump is triggered by \\f[V]jcmd GC.heap_dump\\f[R] without specifying a path.\n+In case of HeapDumpOnOutOfMemoryError, by default, the file is created in the current\n+working directory, and it\\[aq]s named \\f[V]java_pid<pid>.hprof\\f[R] where \\f[V]<pid>\\f[R] is\n","filename":"src\/java.base\/share\/man\/java.1","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -338,1 +338,3 @@\n-\\f[I]filename\\f[R]: The name of the dump file (STRING, no default value)\n+\\f[I]filename\\f[R]: The name of the dump file; in case no file is specified\n+but -XX:HeapDumpPath=path is set, the path provided by HeapDumpPath is used\n+(STRING, no default value)\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2024 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test jcmd GC.heap_dump without path option; path is set via HeapDumpPath\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:HeapDumpPath=testjcmd.hprof HeapDumpJcmdPresetPathTest\n+ *\/\n+\n+import java.io.File;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class HeapDumpJcmdPresetPathTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        PidJcmdExecutor executor = new PidJcmdExecutor();\n+        OutputAnalyzer output = executor.execute(\"GC.heap_dump\");\n+        output.shouldContain(\"Dumping heap to testjcmd.hprof\");\n+        output.shouldContain(\"Heap dump file created\");\n+\n+        Asserts.assertTrue(new File(\"testjcmd.hprof\").exists());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/HeapDump\/HeapDumpJcmdPresetPathTest.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"}]}