{"files":[{"patch":"@@ -373,0 +373,49 @@\n+bool ParallelScavengeHeap::should_attempt_young_gc() const {\n+  const bool ShouldRunYoungGC = true;\n+  const bool ShouldRunFullGC = false;\n+\n+  if (!_young_gen->to_space()->is_empty()) {\n+    log_debug(gc, ergo)(\"To-space is not empty; run full-gc instead.\");\n+    return ShouldRunFullGC;\n+  }\n+\n+  \/\/ Check if the predicted promoted bytes will overflow free space in old-gen.\n+  PSAdaptiveSizePolicy* policy = _size_policy;\n+\n+  size_t avg_promoted = (size_t) policy->padded_average_promoted_in_bytes();\n+  size_t promotion_estimate = MIN2(avg_promoted, _young_gen->used_in_bytes());\n+  \/\/ Total free size after possible old gen expansion\n+  size_t free_in_old_gen_with_expansion = _old_gen->max_gen_size() - _old_gen->used_in_bytes();\n+\n+  log_trace(gc, ergo)(\"average_promoted %zu; padded_average_promoted %zu\",\n+              (size_t) policy->average_promoted_in_bytes(),\n+              (size_t) policy->padded_average_promoted_in_bytes());\n+\n+  if (promotion_estimate >= free_in_old_gen_with_expansion) {\n+    log_debug(gc, ergo)(\"Run full-gc; predicted promotion size >= max free space in old-gen: %zu >= %zu\",\n+      promotion_estimate, free_in_old_gen_with_expansion);\n+    return ShouldRunFullGC;\n+  }\n+\n+  if (UseAdaptiveSizePolicy) {\n+    \/\/ Also checking OS has enough free memory to commit and expand old-gen.\n+    \/\/ Otherwise, the recorded gc-pause-time might be inflated to include time\n+    \/\/ of OS preparing free memory, resulting in inaccurate young-gen resizing.\n+    assert(_old_gen->committed().byte_size() >= _old_gen->used_in_bytes(), \"inv\");\n+    \/\/ Use uint64_t instead of size_t for 32bit compatibility.\n+    uint64_t free_mem_in_os;\n+    if (os::free_memory(free_mem_in_os)) {\n+      size_t actual_free = (size_t)MIN2(_old_gen->committed().byte_size() - _old_gen->used_in_bytes() + free_mem_in_os,\n+                                        (uint64_t)SIZE_MAX);\n+      if (promotion_estimate > actual_free) {\n+        log_debug(gc, ergo)(\"Run full-gc; predicted promotion size > free space in old-gen and OS: %zu > %zu\",\n+          promotion_estimate, actual_free);\n+        return ShouldRunFullGC;\n+      }\n+    }\n+  }\n+\n+  \/\/ No particular reasons to run full-gc, so young-gc.\n+  return ShouldRunYoungGC;\n+}\n+\n@@ -519,1 +568,1 @@\n-void ParallelScavengeHeap::collect_at_safepoint(bool full) {\n+void ParallelScavengeHeap::collect_at_safepoint(bool is_full) {\n@@ -523,3 +572,3 @@\n-  if (!full) {\n-    bool success = PSScavenge::invoke(clear_soft_refs);\n-    if (success) {\n+  if (!is_full && should_attempt_young_gc()) {\n+    bool young_gc_success = PSScavenge::invoke(clear_soft_refs);\n+    if (young_gc_success) {\n@@ -528,1 +577,1 @@\n-    \/\/ Upgrade to Full-GC if young-gc fails\n+    log_debug(gc, heap)(\"Upgrade to Full-GC since Young-gc failed.\");\n@@ -530,0 +579,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":55,"deletions":5,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -122,0 +122,3 @@\n+  \/\/ Returns true if a young GC should be attempted, false if a full GC is preferred.\n+  bool should_attempt_young_gc() const;\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -316,6 +316,0 @@\n-  \/\/ Check for potential problems.\n-  if (!should_attempt_scavenge()) {\n-    log_info(gc, ergo)(\"Young-gc might fail so skipping\");\n-    return false;\n-  }\n-\n@@ -339,2 +333,1 @@\n-  assert(young_gen->to_space()->is_empty(),\n-         \"Attempt to scavenge with live objects in to_space\");\n+  assert(young_gen->to_space()->is_empty(), \"precondition\");\n@@ -523,53 +516,0 @@\n-bool PSScavenge::should_attempt_scavenge() {\n-  const bool ShouldRunYoungGC = true;\n-  const bool ShouldRunFullGC = false;\n-\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-  PSYoungGen* young_gen = heap->young_gen();\n-  PSOldGen* old_gen = heap->old_gen();\n-\n-  if (!young_gen->to_space()->is_empty()) {\n-    log_debug(gc, ergo)(\"To-space is not empty; run full-gc instead.\");\n-    return ShouldRunFullGC;\n-  }\n-\n-  \/\/ Check if the predicted promoted bytes will overflow free space in old-gen.\n-  PSAdaptiveSizePolicy* policy = heap->size_policy();\n-\n-  size_t avg_promoted = (size_t) policy->padded_average_promoted_in_bytes();\n-  size_t promotion_estimate = MIN2(avg_promoted, young_gen->used_in_bytes());\n-  \/\/ Total free size after possible old gen expansion\n-  size_t free_in_old_gen_with_expansion = old_gen->max_gen_size() - old_gen->used_in_bytes();\n-\n-  log_trace(gc, ergo)(\"average_promoted %zu; padded_average_promoted %zu\",\n-              (size_t) policy->average_promoted_in_bytes(),\n-              (size_t) policy->padded_average_promoted_in_bytes());\n-\n-  if (promotion_estimate >= free_in_old_gen_with_expansion) {\n-    log_debug(gc, ergo)(\"Run full-gc; predicted promotion size >= max free space in old-gen: %zu >= %zu\",\n-      promotion_estimate, free_in_old_gen_with_expansion);\n-    return ShouldRunFullGC;\n-  }\n-\n-  if (UseAdaptiveSizePolicy) {\n-    \/\/ Also checking OS has enough free memory to commit and expand old-gen.\n-    \/\/ Otherwise, the recorded gc-pause-time might be inflated to include time\n-    \/\/ of OS preparing free memory, resulting in inaccurate young-gen resizing.\n-    assert(old_gen->committed().byte_size() >= old_gen->used_in_bytes(), \"inv\");\n-    \/\/ Use uint64_t instead of size_t for 32bit compatibility.\n-    uint64_t free_mem_in_os;\n-    if (os::free_memory(free_mem_in_os)) {\n-      size_t actual_free = (size_t)MIN2(old_gen->committed().byte_size() - old_gen->used_in_bytes() + free_mem_in_os,\n-                                        (uint64_t)SIZE_MAX);\n-      if (promotion_estimate > actual_free) {\n-        log_debug(gc, ergo)(\"Run full-gc; predicted promotion size > free space in old-gen and OS: %zu > %zu\",\n-          promotion_estimate, actual_free);\n-        return ShouldRunFullGC;\n-      }\n-    }\n-  }\n-\n-  \/\/ No particular reasons to run full-gc, so young-gc.\n-  return ShouldRunYoungGC;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":1,"deletions":61,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -67,2 +67,0 @@\n-  static bool should_attempt_scavenge();\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}