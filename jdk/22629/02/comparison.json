{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1317,2 +1318,11 @@\n-\/\/ If Node n lives in the back_ctrl block and cannot float, we clone a private\n-\/\/ version of n in preheader_ctrl block and return that, otherwise return n.\n+\/\/ Return the appropriate node to use on the new loop's data-flow path derived from 'n'.\n+\/\/ If no suitable existing node can be reused, create a private clone controlled by\n+\/\/ the 'preheader_ctrl'.\n+\/\/\n+\/\/ If 'back_ctrl' is not null:\n+\/\/   - Clone a private version of node 'n' in 'preheader_ctrl' if it resides in the 'back_ctrl' block.\n+\/\/   - Otherwise, return 'n' unchanged.\n+\/\/\n+\/\/ If 'back_ctrl' is null: (Specially for pre-loop exit in resolve_input_for_drain_or_post())\n+\/\/   - Clone 'n' into 'preheader_ctrl' if its block does not strictly dominate 'preheader_ctrl'.\n+\/\/   - Otherwise, return 'n'.\n@@ -1320,1 +1330,8 @@\n-  if (get_ctrl(n) != back_ctrl) return n;\n+  bool is_from_preloop_exit = (back_ctrl == nullptr);\n+  bool requires_clone_from_preloop_exit = !is_dominator(get_ctrl(n), preheader_ctrl);\n+  if (is_from_preloop_exit) {\n+    \/\/ Specially for pre-loop exit in resolve_input_for_drain_or_post()\n+    if (!requires_clone_from_preloop_exit) { return n; }\n+  } else {\n+    if (get_ctrl(n) != back_ctrl) { return n; }\n+  }\n@@ -1330,1 +1347,2 @@\n-  if (n->in(0) && n->in(0) == back_ctrl) {\n+  if (n->in(0) && (n->in(0) == back_ctrl ||\n+                   (is_from_preloop_exit && requires_clone_from_preloop_exit))) {\n@@ -1354,1 +1372,1 @@\n-  } else {                      \/\/ raise n to cover LCA of uses\n+  } else if (!is_from_preloop_exit) {  \/\/ raise n to cover LCA of uses\n@@ -1376,0 +1394,103 @@\n+\/\/------------------------------resolve_input_for_drain_or_post--------------------------\n+\/\/ Determine and obtain the correct fall-in values for either the drain loop or the post loop.\n+Node* PhaseIdealLoop::resolve_input_for_drain_or_post(Node* post_head_ctrl, VectorSet& visited,\n+                                                      Node_Stack& clones, Node* main_merge_region,\n+                                                      Node* main_phi, CloneLoopMode mode) {\n+  CountedLoopNode* main_head = main_phi->in(0)->as_CountedLoop();\n+  Node* main_backedge_ctrl = main_head->back_control();\n+  \/\/ For the post loop, we call clone_up_backedge_goo() to obtain the fall-out values\n+  \/\/ from the main loop, which serve as the fall-in values for the post loop.\n+  if (mode == ControlAroundStripMined) {\n+    return clone_up_backedge_goo(main_backedge_ctrl,\n+                                 post_head_ctrl,\n+                                 main_phi->in(LoopNode::LoopBackControl),\n+                                 visited, clones);\n+  }\n+\n+  \/\/ For drain loop, after inserting zero trip guard for the vectorized drain loop,\n+  \/\/ we now need to make the fall-in values to the vectorized drain\n+  \/\/ loop come from phis merging exit values from the pre loop and\n+  \/\/ the main loop.\n+  \/\/ (new edges are marked with \"*\/*\" or \"*\\*\".)\n+  \/\/\n+  \/\/      pre loop exit  'pre_incr'\n+  \/\/            |         \/\n+  \/\/      main zero-trip guard\n+  \/\/          \/          \\\n+  \/\/     IfFalse        IfTrue\n+  \/\/        \/               \\\n+  \/\/       |     ------->   main loop head   'pre_incr'\n+  \/\/       |     |              |         \\   \/\n+  \/\/       |    IfTrue          |    ----> PhiNode('main_phi')\n+  \/\/       |     |              v    |       |\n+  \/\/       |     -------loop end     ---- addI('main_incr')\n+  \/\/        \\              |                 |\n+  \/\/         \\          IfFalse              |\n+  \/\/          \\          \/        'pre_incr' |\n+  \/\/  RegionNode('main_merge_region')   |    |\n+  \/\/                \\              \\    |    |\n+  \/\/                  \\            PhiNode('drain_input')\n+  \/\/                    \\          \/                  *\\*\n+  \/\/                 drain zero-trip guard             *\\*\n+  \/\/                    \/  \\                            *\\*\n+  \/\/               IfFalse IfTrue                        *\\*\n+  \/\/  ('drain_bypass')\/       \\('drain_entry')            *|*\n+  \/\/                 \/         \\                          *|*\n+  \/\/                 |  -----> vectorized drain loop head *|*\n+  \/\/                 |  |          |                   \\  *|*\n+  \/\/                 | IfTrue      |          ----> PhiNode('drain_phi')\n+  \/\/                 |  |          v          |        |\n+  \/\/                 |  ----- loop end        ----- addI('drain_incr')\n+  \/\/                  \\        |                      |\n+  \/\/                   \\    IfFalse 'drain_input'    \/\n+  \/\/                    \\    \/                |     \/\n+  \/\/      RegionNode('drain_merge_region')    |    \/\n+  \/\/                        \\             \\   |   \/\n+  \/\/                         \\             PhiNode\n+  \/\/                          \\           \/\n+  \/\/                    post zero-trip guard\n+  \/\/                           ...\n+  \/\/\n+  \/\/ We look for an existing Phi node 'drain_input' among the uses of 'main_incr'.\n+  \/\/\n+  \/\/ If no valid Phi is found, we create a new Phi that merges output data edges\n+  \/\/ from both the pre-loop and main loop. The example here is test5() added in\n+  \/\/ TestVectorizedDrainLoop.java.\n+  Node* drain_input = nullptr;\n+  Node* main_incr = main_phi->in(LoopNode::LoopBackControl);\n+  if (get_ctrl(main_incr) != main_backedge_ctrl) {\n+    \/\/ We try to look up target phi from all uses of node 'main_incr'.\n+    drain_input = find_merge_phi_for_vectorized_drain(main_incr, main_merge_region);\n+  }\n+  if (drain_input == nullptr) {\n+    \/\/ Make the fall-in values to the vectorized drain-loop come from a phi node\n+    \/\/ merging the data from the vector main-loop and the pre-loop.\n+\n+    \/\/ If Node 'main_incr' lives in the 'main_backedge_ctrl' block, we clone a private version of\n+    \/\/ 'main_incr' in 'main_exit' block and return that, otherwise return 'main_incr'.\n+    main_incr = clone_up_backedge_goo(main_backedge_ctrl, main_merge_region->in(2), main_incr,\n+                                      visited, clones);\n+    drain_input = PhiNode::make(main_merge_region, main_incr);\n+    Node* pre_incr = main_phi->in(LoopNode::EntryControl);\n+    if (has_ctrl(pre_incr) && !is_dominator(get_ctrl(pre_incr), main_merge_region->in(1))) {\n+      \/\/ If the entry input of the main_phi is not directly from pre-loop but has been preprocessed\n+      \/\/ by some nodes floating below the zero-trip guard of main-loop, we need to clone a private\n+      \/\/ version of these nodes for vectorized drain loop.\n+      pre_incr = clone_up_backedge_goo(nullptr, main_merge_region->in(1), pre_incr, visited, clones);\n+    }\n+    drain_input->set_req(1, pre_incr);\n+    \/\/ If inserting a new Phi, check for prior hits\n+    Node* hit = _igvn.hash_find_insert(drain_input);\n+    if (hit == nullptr) {\n+      \/\/ Register new phi\n+      _igvn.register_new_node_with_optimizer(drain_input);\n+    } else {\n+      \/\/ Remove the new phi from the graph and use the hit\n+      _igvn.remove_dead_node(drain_input);\n+      drain_input = hit;\n+    }\n+    set_ctrl(drain_input, main_merge_region);\n+  }\n+  return drain_input;\n+}\n+\n@@ -1439,1 +1560,2 @@\n-  Node* main_exit = insert_post_loop(loop, old_new, main_head, main_end, post_incr, limit, post_head);\n+  Node* main_exit = insert_post_or_drain_loop(loop, old_new, main_head, main_end, post_incr,\n+                                              limit, post_head, ControlAroundStripMined);\n@@ -1606,6 +1728,6 @@\n-\/\/------------------------------insert_vector_post_loop------------------------\n-\/\/ Insert a copy of the atomic unrolled vectorized main loop as a post loop,\n-\/\/ unroll_policy has  already informed  us that more  unrolling is  about to\n-\/\/ happen  to the  main  loop.  The  resultant  post loop  will  serve as  a\n-\/\/ vectorized drain loop.\n-void PhaseIdealLoop::insert_vector_post_loop(IdealLoopTree *loop, Node_List &old_new) {\n+\/\/------------------------------insert_vectorized_drain_loop------------------------\n+\/\/ Insert a copy of the vectorized but not super-unrolled main loop as another post loop,\n+\/\/ policy_unroll() has already informed us that more unrolling is about to happen to\n+\/\/ the main loop.\n+\/\/ The resultant post loop will serve as a vectorized drain loop.\n+void PhaseIdealLoop::insert_vectorized_drain_loop(IdealLoopTree* loop, Node_List& old_new) {\n@@ -1628,1 +1750,1 @@\n-  if (cl->has_atomic_post_loop()) return;\n+  if (cl->has_vectorized_drain_loop()) return;\n@@ -1648,0 +1770,2 @@\n+  C->print_method(PHASE_BEFORE_VECTORIZED_DRAIN, 4, main_head);\n+\n@@ -1649,1 +1773,1 @@\n-  main_head->mark_has_atomic_post_loop();\n+  main_head->mark_has_vectorized_drain_loop();\n@@ -1655,1 +1779,0 @@\n-  C->print_method(PHASE_BEFORE_POST_LOOP, 4, main_head);\n@@ -1657,2 +1780,2 @@\n-  insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);\n-  C->print_method(PHASE_AFTER_POST_LOOP, 4, post_head);\n+  insert_post_or_drain_loop(loop, old_new, main_head, main_end, incr, limit,\n+                            post_head, InsertVectorizedDrain);\n@@ -1669,0 +1792,1 @@\n+  C->print_method(PHASE_AFTER_VECTORIZED_DRAIN, 4, post_head);\n@@ -1695,5 +1819,98 @@\n-\/\/------------------------------insert_post_loop-------------------------------\n-\/\/ Insert post loops.  Add a post loop to the given loop passed.\n-Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n-                                       CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n-                                       Node* incr, Node* limit, CountedLoopNode*& post_head) {\n+\/\/ Rewire the control inputs of nodes created for the drain loop\n+\/\/ so that they point to the correct control nodes at the new loop entry.\n+void PhaseIdealLoop::rewire_ctrl_for_drain_loop_nodes(CountedLoopNode* main_head, CountedLoopNode* post_head,\n+                                                      uint new_counter) {\n+  Node* start = main_head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  Node* new_start = post_head->in(LoopNode::EntryControl);\n+  while (AssertionPredicate::is_predicate(start) ||\n+         start == main_head->skip_assertion_predicates_with_halt()) {\n+    assert(AssertionPredicate::is_predicate(new_start) ||\n+           new_start == post_head->skip_assertion_predicates_with_halt(), \"Must be\");\n+    for (uint i = 0; i < start->outcnt(); i++) {\n+      Node* loop_node = start->raw_out(i);\n+      if (loop_node->in(0) == start && loop_node->_idx >= new_counter) {\n+        _igvn.replace_input_of(loop_node, 0, new_start);\n+        --i;\n+      }\n+    }\n+    start = start->in(0)->in(0);\n+    if (start == main_head->skip_assertion_predicates_with_halt()) {\n+      new_start = post_head->skip_assertion_predicates_with_halt();\n+    }\n+  }\n+}\n+\n+\/\/------------------------------insert_post_or_drain_loop-------------------------------\n+\/\/ Insert a post loop with the specified mode for the given loop.\n+\/\/\n+\/\/ Here is how the loop structure is changed as we insert post loops with\n+\/\/ different mode.\n+\/\/\n+\/\/ insert_pre_post_loop() calls this function with the ControlAroundStripMined\n+\/\/ mode first. The new inserted loop serves as the 'post' loop and\n+\/\/ the loop structure becomes a 'main-post' structure:\n+\/\/\n+\/\/                 main loop\n+\/\/                     |\n+\/\/                     |\n+\/\/              post zero-trip guard\n+\/\/                   \/     \\\n+\/\/                  \/       \\\n+\/\/                 \/       post loop\n+\/\/                \/        \/\n+\/\/               \/        \/\n+\/\/              after loop\n+\/\/\n+\/\/ The caller insert_pre_post_loops() will continue to insert a 'pre' loop and\n+\/\/ zero trip guard for 'main' loop. It becomes a complete 'pre-main-post'\n+\/\/ model as showed below:\n+\/\/\n+\/\/               pre loop\n+\/\/                   |\n+\/\/                   |\n+\/\/            main zero-trip guard\n+\/\/                   \/    \\\n+\/\/                  \/      \\\n+\/\/                 \/      main loop\n+\/\/                \/          \/\n+\/\/               \/          \/\n+\/\/            post zero-trip guard\n+\/\/                   \/     \\\n+\/\/                  \/       \\\n+\/\/                 \/       post loop\n+\/\/                \/        \/\n+\/\/               \/        \/\n+\/\/              after loop\n+\/\/\n+\/\/ After auto-vectorization, if more unrolling is about to happen to the\n+\/\/ vectorized 'main' loop, insert_vectorized_drain_loop() will call this function\n+\/\/ with the InsertVectorizedDrain mode, the new inserted loop serves as another\n+\/\/ post loop, i.e. the vectorized drain loop, as showed below:\n+\/\/\n+\/\/               pre loop\n+\/\/                   |\n+\/\/                   |\n+\/\/            main zero-trip guard\n+\/\/                   \/    \\\n+\/\/                  \/      \\\n+\/\/                 \/      (vectorized) main loop\n+\/\/                \/          \/\n+\/\/               \/          \/\n+\/\/            drain zero-trip guard\n+\/\/                   \/    \\\n+\/\/                  \/      \\\n+\/\/                 \/        vectorized drain loop\n+\/\/                \/          \/\n+\/\/               \/          \/\n+\/\/            post zero-trip guard\n+\/\/                   \/     \\\n+\/\/                  \/       \\\n+\/\/                 \/       post loop\n+\/\/                \/        \/\n+\/\/               \/        \/\n+\/\/              after loop\n+Node* PhaseIdealLoop::insert_post_or_drain_loop(IdealLoopTree* loop, Node_List& old_new,\n+                                                CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n+                                                Node* main_incr, Node* limit, CountedLoopNode*& post_head,\n+                                                CloneLoopMode mode) {\n+  assert(mode == ControlAroundStripMined || mode == InsertVectorizedDrain, \"Unsupported mode\");\n@@ -1709,2 +1926,0 @@\n-  \/\/------------------------------\n-  \/\/ Step A: Create a new post-Loop.\n@@ -1715,2 +1930,1 @@\n-  \/\/ Step A1: Clone the loop body of main. The clone becomes the post-loop.\n-  \/\/ The main loop pre-header illegally has 2 control users (old & new loops).\n+  \/\/ Step 1: Clone the loop body of main loop. The clone becomes the new loop (post or drain).\n@@ -1718,1 +1932,1 @@\n-  clone_loop(loop, old_new, dd_main_exit, ControlAroundStripMined);\n+  clone_loop(loop, old_new, dd_main_exit, mode);\n@@ -1731,5 +1945,77 @@\n-  \/\/ Build the main-loop normal exit.\n-  IfFalseNode *new_main_exit = new IfFalseNode(outer_main_end);\n-  _igvn.register_new_node_with_optimizer(new_main_exit);\n-  set_idom(new_main_exit, outer_main_end, dd_main_exit);\n-  set_loop(new_main_exit, outer_loop->_parent);\n+  \/\/ Step 2: Find some key nodes which control the execution paths of the zero trip guard.\n+  \/\/ Step 2.1: Find 'zero_ctrl' which will be the control input of the zero trip guard.\n+  Node* zero_ctrl = nullptr;\n+  if (mode == InsertVectorizedDrain) {\n+    \/\/ For vectorized drain loop, 'zero_ctrl' should be the node merges exits\n+    \/\/ from the main loop and the pre loop.\n+    zero_ctrl = main_exit->unique_ctrl_out_or_null();\n+    assert(zero_ctrl != nullptr && zero_ctrl->is_Region(),\n+           \"In the pre-main-post model, zero_ctrl must exist.\");\n+\n+    DEBUG_ONLY (\n+      \/\/ We can look up the target 'zero_ctrl' either by exit of the pre loop or\n+      \/\/ by exit of the main loop.\n+      Node* min_taken = main_head->skip_assertion_predicates_with_halt();\n+      IfNode* min_iff = min_taken->in(0)->as_If();\n+      assert(min_iff != nullptr, \"Zero trip guard of main loop does exist.\");\n+      assert(zero_ctrl->in(1) == min_iff->proj_out(false) ||\n+             zero_ctrl->in(1) == min_iff->proj_out(true), \"\");\n+    )\n+  } else {\n+    assert(mode == ControlAroundStripMined, \"\");\n+    \/\/ For post loop, build the main-loop normal exit as the 'zero_ctrl'.\n+    zero_ctrl = new IfFalseNode(outer_main_end);\n+    _igvn.register_new_node_with_optimizer(zero_ctrl);\n+    set_idom(zero_ctrl, outer_main_end, dd_main_exit);\n+    set_loop(zero_ctrl, outer_loop->_parent);\n+  }\n+\n+  \/\/ Step 2.2: Find 'exit_ctrl', which is taken when zero trip guard fails.\n+  Node* exit_ctrl = nullptr;\n+  uint exit_ctrl_idx = 0;\n+  if (mode == InsertVectorizedDrain) {\n+    \/\/ For vectorized drain loop, 'exit_ctrl' should merge exit from the vectorized drain\n+    \/\/ loop and 'zero_ctrl' merging exits from the pre loop and the main loop.\n+    for (uint i = 0; i < zero_ctrl->outcnt(); i++) {\n+      Node* outn = zero_ctrl->raw_out(i);\n+      if (outn != zero_ctrl && outn->is_CFG()) {\n+        assert(exit_ctrl == nullptr,\n+               \"We definitely find only one valid exit_ctrl\");\n+        exit_ctrl = outn;\n+      }\n+    }\n+\n+    exit_ctrl_idx = 2;\n+    assert(exit_ctrl->is_Region() && exit_ctrl->in(exit_ctrl_idx) == zero_ctrl,\n+           \"exit_ctrl should be a Region node and zero_ctrl should be its second input\");\n+  } else {\n+    \/\/ For post loop, when zero trip guard fails, we should use the exit path from the main loop.\n+    exit_ctrl = main_exit;\n+  }\n+\n+  \/\/ Step 3: Find a 'new_trip_cnt' which is the input trip count of the zero trip guard.\n+  Node* new_trip_cnt = nullptr;\n+  if (mode == InsertVectorizedDrain) {\n+    \/\/ For vectorized drain loop, 'new_phi' should merge 'main_incr' from the main loop\n+    \/\/ and 'pre_incr' from the pre loop.\n+    for (uint i = 0; i < main_incr->outcnt(); i++) {\n+      Node* outn = main_incr->raw_out(i);\n+      if (outn->in(0) == zero_ctrl) {\n+        new_trip_cnt = outn;\n+        break;\n+      }\n+    }\n+    DEBUG_ONLY (\n+      \/\/ We can look up the target merging phi node either from outputs of the pre-loop\n+      \/\/ incr or from outputs of the main-loop incr.\n+      Node* main_guard_opaq = main_head->is_canonical_loop_entry();\n+      Node* cmp  = main_guard_opaq->unique_out();\n+      Node* pre_incr = cmp->in(1);\n+      assert(new_trip_cnt != nullptr && new_trip_cnt->is_Phi() &&\n+             new_trip_cnt->in(1) == pre_incr && new_trip_cnt->in(2) == main_incr, \"\");\n+    )\n+  } else {\n+    assert(mode == ControlAroundStripMined, \"\");\n+    \/\/ For post loop, use the loop incr from the main loop directly.\n+    new_trip_cnt = main_incr;\n+  }\n@@ -1737,3 +2023,3 @@\n-  \/\/ Step A2: Build a zero-trip guard for the post-loop.  After leaving the\n-  \/\/ main-loop, the post-loop may not execute at all.  We 'opaque' the incr\n-  \/\/ (the previous loop trip-counter exit value) because we will be changing\n+  \/\/ Step 4: Build a zero-trip guard for the new inserted loop. Whether leaving the\n+  \/\/ main-loop or the pre loop, the new loop may not execute at all. We 'opaque'\n+  \/\/ the incr (the previous loop trip-counter exit value) because we will be changing\n@@ -1742,6 +2028,66 @@\n-  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr, main_end->test_trip());\n-  Node *zer_cmp = new CmpINode(zer_opaq, limit);\n-  Node *zer_bol = new BoolNode(zer_cmp, main_end->test_trip());\n-  register_new_node(zer_opaq, new_main_exit);\n-  register_new_node(zer_cmp, new_main_exit);\n-  register_new_node(zer_bol, new_main_exit);\n+  \/\/ For example, when we're inserting vectorized drain loop, after step 1 - 3 above,\n+  \/\/ the loop structure is showed in the comments for fix_data_uses_for_vectorized_drain().\n+  \/\/ After inserting the zero trip guard, it becomes:\n+  \/\/ (new edges are marked with \"*\/*\" or \"*\\*\".)\n+\n+  \/\/          -----> pre loop head ...\n+  \/\/          |      |          \\  \/\n+  \/\/         IfTrue  |   ----->  PhiNode\n+  \/\/          |      v   |         |\n+  \/\/         loop end    ------ addI('pre_incr')\n+  \/\/               |           \/\n+  \/\/           IfFalse       \/\n+  \/\/               |       \/\n+  \/\/               |     \/\n+  \/\/         main zero-trip guard\n+  \/\/             \/  \\\n+  \/\/        IfFalse  IfTrue\n+  \/\/           \/       \\\n+  \/\/          \/         \\               'pre_incr'\n+  \/\/          |  -----> main loop head    \/\n+  \/\/          |  |     |              \\  \/\n+  \/\/          | IfTrue |      ---->  PhiNode\n+  \/\/          |  |     v      |          |\n+  \/\/          |   loop end    -------- addI('main_incr')\n+  \/\/           \\       v                   |\n+  \/\/            \\     IfFalse   'pre_incr' |\n+  \/\/             \\     \/              |    |\n+  \/\/       RegionNode('zero_ctrl')    |    |\n+  \/\/                  *\\*         \\   |    |\n+  \/\/                    *\\*       PhiNode('new_trip_cnt')\n+  \/\/                      *\\*       *\/*\n+  \/\/                  drain zero-trip guard ('zer_opaq')\n+  \/\/                      *\/* *\\*\n+  \/\/  ('drain_bypass')IfFalse  IfTrue ('zer_taken')\n+  \/\/                    *\/*      *\\*\n+  \/\/                   *\/*        *\\*                          'pre_incr'\n+  \/\/                  *\/*   -----> vectorized drain loop head   \/\n+  \/\/                 *|*    |         |                    \\   \/\n+  \/\/                 *|*   IfTrue     |         ------> PhiNode('drain_phi')\n+  \/\/                 *|*    |         v         |         |\n+  \/\/                  *\\*   ------loop end      ------- addI('drain_incr')\n+  \/\/                    *\\*         |                    \/\n+  \/\/                     *\\*    IfFalse 'new_trip_cnt' \/\n+  \/\/                       *\\*   \/         |         \/\n+  \/\/             RegionNode('exit_ctrl')   |      \/\n+  \/\/                        |          \\   |   \/\n+  \/\/                        |           PhiNode\n+  \/\/                        |            \/   \\\n+  \/\/                   post zero-trip guard   \\\n+  \/\/                   \/      \\                \\\n+  \/\/               IfFalse   IfTrue            |\n+  \/\/                  |        |               |\n+  \/\/                  |  ----> post loop head  |\n+  \/\/                ...  |     |           \\   |\n+  \/\/                   IfTrue  |      ----> PhiNode\n+  \/\/                     |     v      |       |\n+  \/\/                     loop end     ----- addI\n+  \/\/                           |\n+  \/\/                          ...\n+\n+  Node* zer_opaq = new OpaqueZeroTripGuardNode(C, new_trip_cnt, main_end->test_trip());\n+  Node* zer_cmp = new CmpINode(zer_opaq, limit);\n+  Node* zer_bol = new BoolNode(zer_cmp, main_end->test_trip());\n+  register_new_node(zer_opaq, zero_ctrl);\n+  register_new_node(zer_cmp, zero_ctrl);\n+  register_new_node(zer_bol, zero_ctrl);\n@@ -1750,1 +2096,1 @@\n-  IfNode *zer_iff = new IfNode(new_main_exit, zer_bol, PROB_FAIR, COUNT_UNKNOWN);\n+  IfNode* zer_iff = new IfNode(zero_ctrl, zer_bol, PROB_FAIR, COUNT_UNKNOWN);\n@@ -1752,1 +2098,2 @@\n-  set_idom(zer_iff, new_main_exit, dd_main_exit);\n+  int dd_zero_ctrl = dom_depth(zero_ctrl);\n+  set_idom(zer_iff, zero_ctrl, dd_zero_ctrl);\n@@ -1755,6 +2102,16 @@\n-  \/\/ Plug in the false-path, taken if we need to skip this post-loop\n-  _igvn.replace_input_of(main_exit, 0, zer_iff);\n-  set_idom(main_exit, zer_iff, dd_main_exit);\n-  set_idom(main_exit->unique_out(), zer_iff, dd_main_exit);\n-  \/\/ Make the true-path, must enter this post loop\n-  Node *zer_taken = new IfTrueNode(zer_iff);\n+  \/\/ Plug in the false-path, taken if we need to skip this new loop.\n+  if (mode == InsertVectorizedDrain) {\n+    IfFalseNode* drain_bypass = new IfFalseNode(zer_iff);\n+    _igvn.register_new_node_with_optimizer(drain_bypass);\n+    set_idom(drain_bypass, zer_iff, dd_zero_ctrl);\n+    set_loop(drain_bypass, outer_loop->_parent);\n+    _igvn.replace_input_of(exit_ctrl, exit_ctrl_idx, drain_bypass);\n+    set_idom(exit_ctrl, drain_bypass, dd_zero_ctrl);\n+  } else {\n+    _igvn.replace_input_of(exit_ctrl, exit_ctrl_idx, zer_iff);\n+    set_idom(exit_ctrl, zer_iff, dd_zero_ctrl);\n+    set_idom(exit_ctrl->unique_out(), zer_iff, dd_zero_ctrl);\n+  }\n+\n+  \/\/ Plug in the true path, taken if we enter this new loop.\n+  Node* zer_taken = new IfTrueNode(zer_iff);\n@@ -1764,1 +2121,0 @@\n-  \/\/ Plug in the true path\n@@ -1769,0 +2125,1 @@\n+  \/\/ Step 5: Correct the fall-in values to the new loop.\n@@ -1771,2 +2128,0 @@\n-  \/\/ Step A3: Make the fall-in values to the post-loop come from the\n-  \/\/ fall-out values of the main-loop.\n@@ -1776,26 +2131,28 @@\n-      Node* cur_phi = old_new[main_phi->_idx];\n-      Node* fallnew = clone_up_backedge_goo(main_head->back_control(),\n-                                            post_head->init_control(),\n-                                            main_phi->in(LoopNode::LoopBackControl),\n-                                            visited, clones);\n-      _igvn.hash_delete(cur_phi);\n-      cur_phi->set_req(LoopNode::EntryControl, fallnew);\n-    }\n-  }\n-  \/\/ Store nodes that were moved to the outer loop by PhaseIdealLoop::try_move_store_after_loop\n-  \/\/ do not have an associated Phi node. Such nodes are attached to the false projection of the CountedLoopEnd node,\n-  \/\/ right after the execution of the inner CountedLoop.\n-  \/\/ We have to make sure that such stores in the post loop have the right memory inputs from the main loop\n-  \/\/ The moved store node is always attached right after the inner loop exit, and just before the safepoint\n-  const Node* if_false = main_end->proj_out(false);\n-  for (DUIterator j = if_false->outs(); if_false->has_out(j); j++) {\n-    Node* store = if_false->out(j);\n-    if (store->is_Store()) {\n-      \/\/ We only make changes if the memory input of the store is outside the outer loop body,\n-      \/\/ as this is when we would normally expect a Phi as input. If the memory input\n-      \/\/ is in the loop body as well, then we can safely assume it is still correct as the entire\n-      \/\/ body was cloned as a unit\n-      if (!is_member(outer_loop, get_ctrl(store->in(MemNode::Memory)))) {\n-        Node* mem_out = find_last_store_in_outer_loop(store, outer_loop);\n-        Node* store_new = old_new[store->_idx];\n-        store_new->set_req(MemNode::Memory, mem_out);\n+      Node* new_phi = old_new[main_phi->_idx];\n+      Node* new_input = resolve_input_for_drain_or_post(post_head->init_control(),\n+                                                        visited, clones, zero_ctrl,\n+                                                        main_phi, mode);\n+      _igvn.hash_delete(new_phi);\n+      new_phi->set_req(LoopNode::EntryControl, new_input);\n+    }\n+  }\n+\n+  if (mode == ControlAroundStripMined) {\n+    \/\/ Store nodes that were moved to the outer loop by PhaseIdealLoop::try_move_store_after_loop\n+    \/\/ do not have an associated Phi node. Such nodes are attached to the false projection of the CountedLoopEnd node,\n+    \/\/ right after the execution of the inner CountedLoop.\n+    \/\/ We have to make sure that such stores in the post loop have the right memory inputs from the main loop\n+    \/\/ The moved store node is always attached right after the inner loop exit, and just before the safepoint\n+    const Node* if_false = main_end->proj_out(false);\n+    for (DUIterator j = if_false->outs(); if_false->has_out(j); j++) {\n+      Node* store = if_false->out(j);\n+      if (store->is_Store()) {\n+        \/\/ We only make changes if the memory input of the store is outside the outer loop body,\n+        \/\/ as this is when we would normally expect a Phi as input. If the memory input\n+        \/\/ is in the loop body as well, then we can safely assume it is still correct as the entire\n+        \/\/ body was cloned as a unit\n+        if (!is_member(outer_loop, get_ctrl(store->in(MemNode::Memory)))) {\n+          Node* mem_out = find_last_store_in_outer_loop(store, outer_loop);\n+          Node* store_new = old_new[store->_idx];\n+          store_new->set_req(MemNode::Memory, mem_out);\n+        }\n@@ -1808,0 +2165,5 @@\n+\n+  if (mode == InsertVectorizedDrain) {\n+    \/\/ Rewire the control of node created for vectorized drain loop.\n+    rewire_ctrl_for_drain_loop_nodes(main_head, post_head, first_node_index_in_cloned_loop_body);\n+  }\n@@ -1809,1 +2171,1 @@\n-  return new_main_exit;\n+  return zero_ctrl;\n@@ -3591,1 +3953,1 @@\n-        phase->insert_vector_post_loop(this, old_new);\n+        phase->insert_vectorized_drain_loop(this, old_new);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":442,"deletions":80,"binary":false,"changes":522,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -78,1 +79,1 @@\n-         HasAtomicPostLoop     = 1<<11,\n+         HasVectorizedDrain    = 1<<11,\n@@ -117,1 +118,1 @@\n-  void mark_has_atomic_post_loop() { _loop_flags |= HasAtomicPostLoop; }\n+  void mark_has_vectorized_drain_loop() { _loop_flags |= HasVectorizedDrain; }\n@@ -296,0 +297,4 @@\n+  \/\/ If the 'main' loop is auto-vectorized and super-unrolled, it also\n+  \/\/ has a 'vectorized drain' loop, which is copied from vectorized but\n+  \/\/ not super-unrolled 'main' loop and inserted post the 'main' loop.\n+\n@@ -306,1 +311,1 @@\n-  bool has_atomic_post_loop  () const { return (_loop_flags & HasAtomicPostLoop) == HasAtomicPostLoop; }\n+  bool has_vectorized_drain_loop () const { return (_loop_flags & HasVectorizedDrain) == HasVectorizedDrain; }\n@@ -1396,4 +1401,20 @@\n-  \/\/ edges are the same.  All exits from the old-loop now have a RegionNode\n-  \/\/ that merges the equivalent new-loop path.  This is true even for the\n-  \/\/ normal \"loop-exit\" condition.  All uses of loop-invariant old-loop values\n-  \/\/ now come from (one or more) Phis that merge their new-loop equivalents.\n+  \/\/ edges are the same.\n+  \/\/\n+  \/\/ For most modes (except InsertVectorizedDrain):\n+  \/\/ All exits from the old-loop now have a RegionNode that merges the\n+  \/\/ equivalent new-loop path.  This is true even for the normal \"loop-exit\"\n+  \/\/ condition.  All uses of loop-variant old-loop values now come from\n+  \/\/ (one or more) Phis that merge their new-loop equivalents.\n+  \/\/\n+  \/\/ For InsertVectorizedDrain mode:\n+  \/\/ Before:\n+  \/\/ region_old = Region(pre_loop_exit, main_loop_exit)\n+  \/\/ phi_old = Phi(pre_loop_outputs, main_loop_outputs)\n+  \/\/ After:\n+  \/\/ region_old = Region(pre_loop_exit, main_loop_exit)\n+  \/\/ phi_old = Phi(pre_loop_outputs, main_loop_outputs)\n+  \/\/ region_new = Region(region_old, drain_loop_exit)\n+  \/\/ phi_new = Phi(phi_old, drain_loop_outputs)\n+  \/\/ All control uses of exits from old-loop now should use 'region_new'.\n+  \/\/ All data uses of outputs from old-loop now should use 'phi_new'.\n+  \/\/\n@@ -1410,1 +1431,1 @@\n-    ControlAroundStripMined = 2  \/\/ Only clone inner strip mined loop,\n+    ControlAroundStripMined = 2, \/\/ Only clone inner strip mined loop,\n@@ -1414,0 +1435,3 @@\n+    InsertVectorizedDrain = 3    \/\/ Only clone inner strip mined vector loop,\n+                                 \/\/ result control flow branches to inner clone or\n+                                 \/\/ scalar post loop\n@@ -1422,0 +1446,11 @@\n+  void replace_input_with_new_clone(Node* use, Node* old_in, Node* new_in,\n+                                    uint& count, uint new_counter);\n+  void fix_data_uses_for_vectorized_drain(Node* main_old, Node_List& old_new,\n+                                          IdealLoopTree* loop, IdealLoopTree* outer_loop,\n+                                          Node_List& worklist, uint new_counter);\n+  void clone_outer_nodes_helper(Node* root, uint new_counter, Node_List& old_new,\n+                                LoopNode* head, Node_List& extra_data_nodes, CloneLoopMode mode);\n+  \/\/ Determines whether 'n' lies on the control path leading into loop 'cl'.\n+  \/\/ Such a node would either be a projection of an assertion predicate\n+  \/\/ or the taken branch of the zero-trip guard.\n+  bool is_loop_entry_ctrl(Node* n, CountedLoopNode* cl);\n@@ -1425,0 +1460,1 @@\n+  Node* find_merge_phi_for_vectorized_drain(Node* n, Node* merge_region);\n@@ -1442,0 +1478,3 @@\n+  void rewire_ctrl_for_drain_loop_nodes(CountedLoopNode* main_head, CountedLoopNode* post_head,\n+                                        uint new_counter);\n+\n@@ -1443,8 +1482,19 @@\n-  Node *insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n-                         CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n-                         Node* incr, Node* limit, CountedLoopNode*& post_head);\n-\n-  \/\/ Add a vector post loop between a vector main loop and the current post loop\n-  void insert_vector_post_loop(IdealLoopTree *loop, Node_List &old_new);\n-  \/\/ If Node n lives in the back_ctrl block, we clone a private version of n\n-  \/\/ in preheader_ctrl block and return that, otherwise return n.\n+  Node* insert_post_or_drain_loop(IdealLoopTree* loop, Node_List& old_new,\n+                                  CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n+                                  Node* main_incr, Node* limit, CountedLoopNode*& post_head,\n+                                  CloneLoopMode mode);\n+\n+  \/\/ Add a vectorized drain loop between the main loop and the current post loop.\n+  void insert_vectorized_drain_loop(IdealLoopTree* loop, Node_List& old_new);\n+\n+  \/\/ Return the appropriate node to use on the new loop's data-flow path derived from 'n'.\n+  \/\/ If no suitable existing node can be reused, create a private clone controlled by the\n+  \/\/ 'preheader_ctrl'.\n+  \/\/\n+  \/\/ If 'back_ctrl' is not null:\n+  \/\/   - Clone a private version of node 'n' in 'preheader_ctrl' if it resides in the 'back_ctrl' block.\n+  \/\/   - Otherwise, return 'n' unchanged.\n+  \/\/\n+  \/\/ If 'back_ctrl' is null: (Specially for pre-loop exit in resolve_input_for_drain_or_post())\n+  \/\/   - Clone 'n' into 'preheader_ctrl' if its block does not strictly dominate 'preheader_ctrl'.\n+  \/\/   - Otherwise, return 'n'.\n@@ -1453,0 +1503,5 @@\n+  \/\/ Determine and obtain the correct fall-in values for either the drain loop or the post loop.\n+  Node* resolve_input_for_drain_or_post(Node* post_head_ctrl, VectorSet& visited,\n+                                        Node_Stack& clones, Node* main_merge_region,\n+                                        Node* main_phi, CloneLoopMode mode);\n+\n@@ -1939,1 +1994,4 @@\n-\n+  void fix_ctrl_uses_for_common_loop(Node* use, Node* newuse, Node_List& old_new,\n+                                     IdealLoopTree* use_loop, Node* side_by_side_idom);\n+  void fix_ctrl_uses_for_vectorized_drain(Node* main_use, Node* drain_use, Node_List& old_new,\n+                                          IdealLoopTree* use_loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":75,"deletions":17,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -2347,0 +2348,255 @@\n+\/\/ For the 'use' node, replace all input occurrences of 'old_in' with 'new_in'.\n+\/\/ After all replacements, attempt to replace 'use' with an existing 'hit' to\n+\/\/ avoid redundant value computation.\n+void PhaseIdealLoop::replace_input_with_new_clone(Node* use, Node* old_in,\n+                                                  Node* new_in, uint& count,\n+                                                  uint new_counter) {\n+  bool make_change = false;\n+  for (uint k = 1; k < use->req(); k++) {\n+    if (use->in(k) == old_in) {\n+      _igvn.replace_input_of(use, k, new_in);\n+      count--;\n+      make_change = true;\n+    }\n+  }\n+  if (make_change && use->_idx >= new_counter) {\n+    Node* hit = _igvn.hash_find_insert(use);\n+    if (hit)\n+      _igvn.replace_node(use, hit);\n+  }\n+}\n+\n+\/\/ This function is going to fix all data uses of the new loop body.\n+\/\/\n+\/\/ Let us look at the data path of the trip counter, as an example\n+\/\/ to understand the data uses:\n+\/\/\n+\/\/   -----> pre loop head ...\n+\/\/   |      |          \\  \/\n+\/\/  IfTrue  |  ----->  PhiNode\n+\/\/   |      v  |         |\n+\/\/  loop end   ------ addI('pre_incr')\n+\/\/        |           \/\n+\/\/    IfFalse       \/\n+\/\/        |       \/\n+\/\/        |     \/\n+\/\/   main zero-trip guard\n+\/\/     \/     \\\n+\/\/ IfFalse  IfTrue\n+\/\/   \/       |  \\_____________________________\n+\/\/  \/        |                                \\\n+\/\/  |   ---> main loop head             ----> vectorized drain loop head\n+\/\/  |   |    |           \\  'pre_incr'  |     |          \\   'pre_incr'\n+\/\/  |   |    |            \\   \/         |     |           \\   \/\n+\/\/  | IfTrue |       -----> PhiNode   IfTrue  |    -----> PhiNode\n+\/\/  |   |    v       |       |          |     v    |        |\n+\/\/  |   loop end     ------ addI        loop end   ----- addI('drain_incr')\n+\/\/  |        |                |              |\n+\/\/   \\      IfFalse           |            IfFalse\n+\/\/    \\      |                |             \/\n+\/\/     \\    \/     'pre_incr'  |            \/\n+\/\/ 'main_merge_region'  |     |           \/\n+\/\/             \\    \\   |     |          \/\n+\/\/              \\  'main_merge_phi'     \/\n+\/\/               \\                     \/\n+\/\/              RegionNode('drain_merge_region')\n+\/\/                  |\n+\/\/                  |    'main_merge_phi'\n+\/\/                  |      \/\n+\/\/            post zero-trip guard\n+\/\/              \/        \\\n+\/\/          IfFalse      IfTrue\n+\/\/             |           |\n+\/\/             |   ----> post loop head  'main_merge_phi'\n+\/\/           ...   |      |            \\  \/\n+\/\/                IfTrue  |      ----> PhiNode\n+\/\/                 |      v      |       |\n+\/\/                  loop end     ----- addI\n+\/\/                     |\n+\/\/                    ...\n+\/\/\n+\/\/ The increment feeding the trip-counter phi in the new loop body\n+\/\/ is 'drain_incr', which is dangling. We create a new 'drain_merge_phi'\n+\/\/ node which will merge 'drain_incr' and 'main_merge_phi' and take\n+\/\/ the RegionNode, 'new_prev', as the control input which was created in\n+\/\/ fix_ctrl_uses_for_vectorized_drain(). This new node 'drain_merge_phi'\n+\/\/ will replace all other uses of 'main_merge_phi'.\n+\/\/ The data uses will become:\n+\/\/ (new edges are marked with \"*\/*\" or \"*\\*\".)\n+\n+\/\/  pre loop exit  'pre_incr'\n+\/\/        |         \/\n+\/\/   main zero-trip guard\n+\/\/     \/      \\\n+\/\/  IfFalse IfTrue\n+\/\/   \/       |   \\______________________________\n+\/\/  \/        |                                  \\\n+\/\/  |   ---> main loop head                ----> vectorized drain loop head\n+\/\/  |   |    |         \\  'pre_incr'       |     |              \\   'pre_incr'\n+\/\/  |   |    |          \\   \/              |     |               \\   \/\n+\/\/  | IfTrue |     ----> PhiNode         IfTrue  |      ------>  PhiNode\n+\/\/  |   |    v     |        |              |     v      |           |\n+\/\/  |   loop end   ------ addI('main_old') loop end     -------- addI('drain_incr')\n+\/\/  |        |               |                   |                *\/*\n+\/\/   \\     IfFalse           |          IfFalse('drain_exit')   *\/*\n+\/\/    \\      |               |                                *\/*\n+\/\/     \\     |    'pre_incr' |                              *\/*\n+\/\/ 'main_merge_region' |     |                            *\/*\n+\/\/           \\     \\   |     |                          *\/*\n+\/\/            \\   PhiNode('main_merge_phi')           *\/*\n+\/\/             \\                     *|*            *\/*\n+\/\/              \\   'drain_exit'     *|*          *\/*\n+\/\/               \\      \/            *|*        *\/*\n+\/\/ RegionNode('drain_merge_region')  *|*      *\/*\n+\/\/               |              *\\*  *|*    *\/*\n+\/\/               |           PhiNode('drain_merge_phi')\n+\/\/               |               *\/*     *|*\n+\/\/            post zero-trip guard       *|*\n+\/\/              \/        \\               *|*\n+\/\/          IfFalse      IfTrue          *|*\n+\/\/             |           |             *|*\n+\/\/            ...  ----> post loop head  *|*\n+\/\/                 |      |            \\ *|*\n+\/\/                IfTrue  |     ----> PhiNode\n+\/\/                 |      v     |        |\n+\/\/                  loop end    ------ addI\n+\/\/                        |\n+\/\/                       ...\n+void PhaseIdealLoop::fix_data_uses_for_vectorized_drain(Node* main_old, Node_List &old_new,\n+                                                        IdealLoopTree* loop, IdealLoopTree* outer_loop,\n+                                                        Node_List& worklist, uint new_counter) {\n+\n+  for (DUIterator_Fast jmax, j = main_old->fast_outs(jmax); j < jmax; j++) {\n+    worklist.push(main_old->fast_out(j));\n+  }\n+\n+  Node_List visit_list;\n+  Node_List phi_list;\n+\n+  while (worklist.size() != 0) {\n+    Node* use = worklist.pop();\n+    if (!has_node(use)) continue; \/\/ Ignore dead nodes\n+    if (use->in(0) == C->top()) continue;\n+    IdealLoopTree* ctrl_or_self = get_loop(has_ctrl(use) ? get_ctrl(use) : use);\n+    if (!loop->is_member(ctrl_or_self) && !outer_loop->is_member(ctrl_or_self) &&\n+        (!main_old->is_CFG() || !use->is_CFG())) {\n+\n+      \/\/ Find the phi node merging the data from pre-loop and vector main-loop.\n+      visit_list.clear();\n+      phi_list.clear();\n+      if (use->is_Phi()) {\n+        phi_list.push(use);\n+      } else {\n+        visit_list.push(use);\n+      }\n+\n+      \/\/ Use BFS to clone all necessary nodes starting from the 'use' node, which exits the main loop,\n+      \/\/ until reaching a merge point with a path from the pre-loop.\n+      while (visit_list.size() != 0) {\n+        Node* curr = visit_list.at(0);\n+        visit_list.remove(0);\n+        Node* newcurr = old_new[curr->_idx];\n+        if (newcurr != nullptr) { continue; }\n+        newcurr = curr->clone();\n+        if (curr->in(0) != nullptr) {\n+          Node* merged_ctrl = old_new[curr->in(0)->_idx];\n+          assert(merged_ctrl->is_Region() && merged_ctrl->in(2)->is_Region(),\n+                 \"Must be a merge point of pre, main, and vectorized drain loops\");\n+          \/\/ The cloned node \"newcurr\" should be in the exit path of vectorized drain loop.\n+          newcurr->set_req(0, merged_ctrl->in(1));\n+        }\n+        for (uint j = 1; j < newcurr->req(); j++) {\n+          Node* n = newcurr->in(j);\n+          if (n != nullptr && old_new[n->_idx]) {\n+            newcurr->set_req(j, old_new[n->_idx]);\n+          }\n+        }\n+        old_new.map(curr->_idx, newcurr);\n+        _igvn.register_new_node_with_optimizer(newcurr);\n+        for (uint j = 0; j < curr->outcnt(); j++) {\n+          Node* outn = curr->raw_out(j);\n+          if (outn->is_CFG()) continue;\n+          Node* newoutn = outn->_idx > new_counter? outn : old_new[outn->_idx];\n+          if (newoutn) {\n+            replace_input_with_new_clone(newoutn, curr, newcurr, j, new_counter);\n+            \/\/ The node \"outn\" has been already visited.\n+            continue;\n+          }\n+          if (outn->is_Phi()) {\n+            phi_list.push(outn);\n+            \/\/ Reached the target node\n+            continue;\n+          }\n+          assert(!has_ctrl(outn) || !has_ctrl(curr) || is_dominator(get_ctrl(curr), get_ctrl(outn)),\n+                 \"Only these nodes controlled by loop exit edge need to be cloned\");\n+          visit_list.push(outn);\n+        }\n+      }\n+\n+      \/\/ The increment feeding the trip-counter phi in the new loop body\n+      \/\/ is 'drain_incr', which is dangling. We create a new 'drain_merge_phi'\n+      \/\/ node which will merge 'drain_incr' and 'main_merge_phi' and take\n+      \/\/ the RegionNode, 'new_prev', as the control input which was created in\n+      \/\/ fix_ctrl_uses_for_vectorized_drain(). This new node 'drain_merge_phi'\n+      \/\/ will replace all other uses of 'main_merge_phi'.\n+      \/\/\n+      \/\/ 'use' may have more than one valid \"Phi\" uses.\n+      \/\/ The example here is test6() added in TestVectorizedDrainLoop.java.\n+      while (phi_list.size() != 0) {\n+        Node* main_merge_phi = phi_list.pop();\n+        const uint idx = 2;\n+        Node* last_in = main_merge_phi->in(idx);\n+        assert(main_merge_phi->in(idx) == last_in,\n+              \"The data from main loop should be the second data input of the phi node\");\n+        Node* main_merge_region = get_ctrl(main_merge_phi);\n+        assert(!loop->is_member(get_loop(main_merge_region)) &&\n+               !outer_loop->is_member(get_loop(main_merge_region)), \"\" );\n+        Node* cfg = main_merge_region->in(idx); \/\/ NOT in block of Phi itself\n+        if (cfg->is_top()) {\n+          \/\/ \"use\" is dead?\n+          _igvn.replace_input_of(main_merge_phi, idx, C->top());\n+          continue;\n+        }\n+\n+        while (!outer_loop->is_member(get_loop(cfg))) {\n+          main_merge_region = cfg;\n+          cfg = (cfg->_idx >= new_counter && cfg->is_Region()) ? cfg->in(2) : idom(cfg);\n+        }\n+\n+        \/\/ \"main_merge_phi\" merges exits from the pre-loop and the main loop.\n+        \/\/ Now we do need a new Phi here which merges \"main_merge_phi\" and data from\n+        \/\/ vectorized drain loop.\n+        Node* drain_merge_region = old_new[main_merge_region->_idx];\n+        assert(drain_merge_region != nullptr, \"just made this in step 3\");\n+        \/\/ Make a new Phi merging data values properly\n+        Node* drain_incr = old_new[last_in->_idx];\n+        Node* drain_merge_phi = PhiNode::make(drain_merge_region, drain_incr);\n+        drain_merge_phi->set_req(2, main_merge_phi);\n+        \/\/ If inserting a new Phi, check for prior hits\n+        Node* hit = _igvn.hash_find_insert(drain_merge_phi);\n+        if (hit == nullptr) {\n+          \/\/ Register new phi\n+          _igvn.register_new_node_with_optimizer(drain_merge_phi);\n+        } else {\n+          \/\/ Remove the new phi from the graph and use the hit\n+          _igvn.remove_dead_node(drain_merge_phi);\n+          drain_merge_phi = hit;\n+        }\n+        set_ctrl(drain_merge_phi, drain_merge_region);\n+        _igvn.add_users_to_worklist(main_merge_phi);\n+\n+        \/\/ We make all uses of \"main_merge_phi\", excluding the new \"drain_merge_phi\",\n+        \/\/ use new \"drain_merge_phi\" instead.\n+        for (uint i = 0; i < main_merge_phi->outcnt(); i++) {\n+          if (main_merge_phi->raw_out(i) != drain_merge_phi) {\n+            replace_input_with_new_clone(main_merge_phi->raw_out(i), main_merge_phi,\n+                                         drain_merge_phi, i, new_counter);\n+          }\n+        }\n+\n+        old_new.map(main_merge_phi->_idx, drain_merge_phi);\n+      }\n+    }\n+  }\n+}\n+\n@@ -2376,0 +2632,104 @@\n+\/\/ Look for the target phi node, which has 'merge_region' as control input, among all uses of node 'n'.\n+Node* PhaseIdealLoop::find_merge_phi_for_vectorized_drain(Node* n, Node* merge_region) {\n+  for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+    Node* merge_phi = n->fast_out(j);\n+    if (merge_phi->is_Phi() && has_ctrl(merge_phi) && get_ctrl(merge_phi) == merge_region)\n+      return merge_phi;\n+  }\n+  return nullptr;\n+}\n+\n+\/\/ Use DFS to clone all necessary dependencies starting from the root node to support both the\n+\/\/ loop out-edge and in-edge.\n+void PhaseIdealLoop::clone_outer_nodes_helper(Node* root, uint new_counter, Node_List& old_new,\n+                                              LoopNode* head, Node_List& extra_data_nodes,\n+                                              CloneLoopMode mode) {\n+  CountedLoopNode* cl = head->as_CountedLoop();\n+  Node* sfpt = cl->outer_safepoint();\n+  Node* new_sfpt = mode == CloneIncludesStripMined ? old_new[sfpt->_idx] : nullptr;\n+  Node_Stack stack(2);\n+  stack.push(root, 1);\n+  Node* l = cl->outer_loop();\n+  IdealLoopTree* outer_loop = get_loop(l);\n+  Node* cle_out = cl->loopexit()->proj_out(false);\n+\n+  Node* main_pre_exit_region = nullptr;\n+  if (mode == InsertVectorizedDrain) {\n+    IfNode* outer_main_end = head->outer_loop_end();\n+    Node* main_exit = outer_main_end->proj_out(false);\n+    main_pre_exit_region = main_exit->unique_ctrl_out_or_null();\n+  }\n+\n+  while (stack.size() > 0) {\n+    Node* n = stack.node();\n+    uint i = stack.index();\n+    for (; i < n->req(); i++) {\n+      if (!(n->in(i) == nullptr ||\n+            !has_ctrl(n->in(i)) ||\n+            get_loop(get_ctrl(n->in(i))) != outer_loop ||\n+            (old_new[n->in(i)->_idx] != nullptr && old_new[n->in(i)->_idx]->_idx >= new_counter))) {\n+        break;\n+      }\n+      if (mode == InsertVectorizedDrain && n->in(i) != nullptr &&\n+          is_loop_entry_ctrl(n->in(i), cl) &&\n+          old_new[n->in(i)->_idx] == nullptr) {\n+        \/\/ In InsertVectorizedDrain, nodes located between the outer loop entry and the zero-trip\n+        \/\/ guard entry of the main loop must be cloned separately for the vectorized drain loop\n+        \/\/ to preserve dominance correctness.\n+        \/\/ These nodes are typically loop-invariant and do not affect memory.\n+        break;\n+      }\n+    }\n+\n+    if (i < n->req()) {\n+      stack.set_index(i+1);\n+      stack.push(n->in(i), 0);\n+    } else {\n+      assert(old_new[n->_idx] == nullptr || n == sfpt || old_new[n->_idx]->_idx < new_counter, \"no clone yet\");\n+      Node* m = n == sfpt ? new_sfpt : n->clone();\n+      if (m != nullptr) {\n+        for (uint i = 0; i < n->req(); i++) {\n+          if (m->in(i) != nullptr && old_new[m->in(i)->_idx] != nullptr) {\n+            m->set_req(i, old_new[m->in(i)->_idx]);\n+          } else if (m->in(i) != nullptr && mode == InsertVectorizedDrain) {\n+            Node* old_in = m->in(i);\n+            if (is_loop_entry_ctrl(old_in, cl)) {\n+              \/\/ In InsertVectorizedDrain, these inputs may affect memory and vary across loop\n+              \/\/ iterations, and therefore need to be updated.\n+              Node* new_in = find_merge_phi_for_vectorized_drain(old_in, main_pre_exit_region);\n+              if (new_in) {\n+                m->set_req(i, new_in);\n+              }\n+            }\n+          }\n+        }\n+      } else {\n+        assert(n == sfpt && mode != CloneIncludesStripMined, \"where's the safepoint clone?\");\n+      }\n+      if (n != sfpt) {\n+        _igvn.register_new_node_with_optimizer(m);\n+        Node* n_ctrl = get_ctrl(n);\n+        if (n_ctrl == cle_out) extra_data_nodes.push(n);\n+        Node* m_ctrl = old_new[n_ctrl->_idx] == nullptr?\n+                       n_ctrl: old_new[n_ctrl->_idx];\n+        set_ctrl(m, m_ctrl);\n+        old_new.map(n->_idx, m);\n+      }\n+      stack.pop();\n+    }\n+  }\n+}\n+\n+\/\/ Determines whether 'n' lies on the control path leading into loop 'cl'.\n+\/\/ Such a node would either be a projection of an assertion predicate\n+\/\/ or the taken branch of the zero-trip guard.\n+bool PhaseIdealLoop::is_loop_entry_ctrl(Node* n, CountedLoopNode* cl) {\n+  if (!has_ctrl(n)) {\n+    return false;\n+  }\n+  Node* ctrl = get_ctrl(n);\n+  Node* dom_ctrl = cl->skip_assertion_predicates_with_halt();\n+  if (ctrl == dom_ctrl) { return true; }\n+  return (is_dominator(dom_ctrl, ctrl) && AssertionPredicate::is_predicate(ctrl));\n+}\n+\n@@ -2437,3 +2797,0 @@\n-    IdealLoopTree* outer_loop = get_loop(l);\n-    Node_Stack stack(2);\n-    stack.push(sfpt, 1);\n@@ -2441,20 +2798,21 @@\n-    while (stack.size() > 0) {\n-      Node* n = stack.node();\n-      uint i = stack.index();\n-      while (i < n->req() &&\n-             (n->in(i) == nullptr ||\n-              !has_ctrl(n->in(i)) ||\n-              get_loop(get_ctrl(n->in(i))) != outer_loop ||\n-              (old_new[n->in(i)->_idx] != nullptr && old_new[n->in(i)->_idx]->_idx >= new_counter))) {\n-        i++;\n-      }\n-      if (i < n->req()) {\n-        stack.set_index(i+1);\n-        stack.push(n->in(i), 0);\n-      } else {\n-        assert(old_new[n->_idx] == nullptr || n == sfpt || old_new[n->_idx]->_idx < new_counter, \"no clone yet\");\n-        Node* m = n == sfpt ? new_sfpt : n->clone();\n-        if (m != nullptr) {\n-          for (uint i = 0; i < n->req(); i++) {\n-            if (m->in(i) != nullptr && old_new[m->in(i)->_idx] != nullptr) {\n-              m->set_req(i, old_new[m->in(i)->_idx]);\n+    \/\/ To support the loop out-edge.\n+    clone_outer_nodes_helper(sfpt, new_counter, old_new, head, extra_data_nodes, mode);\n+\n+    if (mode == CloneIncludesStripMined) {\n+      _igvn.register_new_node_with_optimizer(new_sfpt);\n+      _igvn.register_new_node_with_optimizer(new_cle_out);\n+    }\n+\n+    if (mode == InsertVectorizedDrain) {\n+      \/\/ To support the loop in-edge.\n+      for (uint i = 0; i < loop->_body.size(); i++) {\n+        Node* old = loop->_body.at(i);\n+        Node* drain_n = old_new[old->_idx];\n+        for (uint j = 1; j < old->req(); j++) {\n+          if (old->in(j) != nullptr && drain_n->in(j) == old->in(j) &&\n+              is_loop_entry_ctrl(old->in(j), cl)) {\n+            if (old_new[old->in(j)->_idx] == nullptr) {\n+              clone_outer_nodes_helper(old->in(j), new_counter, old_new, head, extra_data_nodes, InsertVectorizedDrain);\n+              assert(old_new[old->in(j)->_idx], \"We must clone a new node for vectorized drain loop\");\n+            } else {\n+              assert(old_new[old->in(j)->_idx]->_idx >= new_counter, \"Must be a new cloned node\");\n@@ -2462,0 +2820,1 @@\n+            _igvn.replace_input_of(old_new[old->_idx], j, old_new[old->in(j)->_idx]);\n@@ -2463,2 +2822,0 @@\n-        } else {\n-          assert(n == sfpt && mode != CloneIncludesStripMined, \"where's the safepoint clone?\");\n@@ -2466,8 +2823,0 @@\n-        if (n != sfpt) {\n-          extra_data_nodes.push(n);\n-          _igvn.register_new_node_with_optimizer(m);\n-          assert(get_ctrl(n) == cle_out, \"what other control?\");\n-          set_ctrl(m, new_cle_out);\n-          old_new.map(n->_idx, m);\n-        }\n-        stack.pop();\n@@ -2476,4 +2825,1 @@\n-    if (mode == CloneIncludesStripMined) {\n-      _igvn.register_new_node_with_optimizer(new_sfpt);\n-      _igvn.register_new_node_with_optimizer(new_cle_out);\n-    }\n+\n@@ -2524,1 +2870,4 @@\n-\/\/ same.  All exits from the old-loop now have a RegionNode that merges the\n+\/\/ same.\n+\/\/\n+\/\/ For most modes (except InsertVectorizedDrain):\n+\/\/ All exits from the old-loop now have a RegionNode that merges the\n@@ -2526,2 +2875,14 @@\n-\/\/ condition.  All uses of loop-invariant old-loop values now come from (one\n-\/\/ or more) Phis that merge their new-loop equivalents.\n+\/\/ condition.  All uses of loop-variant old-loop values now come from\n+\/\/ (one or more) Phis that merge their new-loop equivalents.\n+\/\/\n+\/\/ For InsertVectorizedDrain mode:\n+\/\/ Before:\n+\/\/ region_old = Region(pre_loop_exit, main_loop_exit)\n+\/\/ phi_old = Phi(pre_loop_outputs, main_loop_outputs)\n+\/\/ After:\n+\/\/ region_old = Region(pre_loop_exit, main_loop_exit)\n+\/\/ phi_old = Phi(pre_loop_outputs, main_loop_outputs)\n+\/\/ region_new = Region(region_old, drain_loop_exit)\n+\/\/ phi_new = Phi(phi_old, drain_loop_outputs)\n+\/\/ All control uses of exits from old-loop now should use region_new.\n+\/\/ All data uses of outputs from old-loop now should use phi_new.\n@@ -2597,5 +2958,23 @@\n-  for (uint i = 0; i < extra_data_nodes.size(); i++) {\n-    Node* old = extra_data_nodes.at(i);\n-    clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,\n-                                split_bool_set, split_cex_set, worklist, new_counter,\n-                                mode);\n+  switch (mode) {\n+    case InsertVectorizedDrain:\n+      for (uint i = 0; i < extra_data_nodes.size(); i++) {\n+        Node* old = extra_data_nodes.at(i);\n+        fix_data_uses_for_vectorized_drain(old, old_new, loop, outer_loop,\n+                                           worklist, new_counter);\n+      }\n+      break;\n+\n+    case IgnoreStripMined:\n+    case CloneIncludesStripMined:\n+    case ControlAroundStripMined:\n+      for (uint i = 0; i < extra_data_nodes.size(); i++) {\n+        Node* old = extra_data_nodes.at(i);\n+        clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,\n+                                    split_bool_set, split_cex_set, worklist, new_counter,\n+                                    mode);\n+      }\n+      break;\n+\n+    default:\n+      assert(false, \"should not reach here\");\n+      break;\n@@ -2647,5 +3026,21 @@\n-  for(uint i = 0; i < body.size(); i++ ) {\n-    Node* old = body.at(i);\n-    clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,\n-                                split_bool_set, split_cex_set, worklist, new_counter,\n-                                mode);\n+  switch (mode) {\n+    case InsertVectorizedDrain:\n+      for (uint i = 0; i < body.size(); i++) {\n+        Node* old = body.at(i);\n+        fix_data_uses_for_vectorized_drain(old, old_new, loop, outer_loop, worklist, new_counter);\n+      }\n+      break;\n+\n+    case IgnoreStripMined:\n+    case CloneIncludesStripMined:\n+    case ControlAroundStripMined:\n+      for (uint i = 0; i < body.size(); i++) {\n+        Node* old = body.at(i);\n+        clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set, split_bool_set,\n+                                    split_cex_set, worklist, new_counter, mode);\n+      }\n+      break;\n+\n+    default:\n+      assert(false, \"Should not reach here.\");\n+      break;\n@@ -2706,37 +3101,12 @@\n-        \/\/ We need a Region to merge the exit from the peeled body and the\n-        \/\/ exit from the old loop body.\n-        RegionNode *r = new RegionNode(3);\n-        uint dd_r = MIN2(dom_depth(newuse), dom_depth(use));\n-        assert(dd_r >= dom_depth(dom_lca(newuse, use)), \"\" );\n-\n-        \/\/ The original user of 'use' uses 'r' instead.\n-        for (DUIterator_Last lmin, l = use->last_outs(lmin); l >= lmin;) {\n-          Node* useuse = use->last_out(l);\n-          _igvn.rehash_node_delayed(useuse);\n-          uint uses_found = 0;\n-          if (useuse->in(0) == use) {\n-            useuse->set_req(0, r);\n-            uses_found++;\n-            if (useuse->is_CFG()) {\n-              \/\/ This is not a dom_depth > dd_r because when new\n-              \/\/ control flow is constructed by a loop opt, a node and\n-              \/\/ its dominator can end up at the same dom_depth\n-              assert(dom_depth(useuse) >= dd_r, \"\");\n-              set_idom(useuse, r, dom_depth(useuse));\n-            }\n-          }\n-          for (uint k = 1; k < useuse->req(); k++) {\n-            if( useuse->in(k) == use ) {\n-              useuse->set_req(k, r);\n-              uses_found++;\n-              if (useuse->is_Loop() && k == LoopNode::EntryControl) {\n-                \/\/ This is not a dom_depth > dd_r because when new\n-                \/\/ control flow is constructed by a loop opt, a node\n-                \/\/ and its dominator can end up at the same dom_depth\n-                assert(dom_depth(useuse) >= dd_r , \"\");\n-                set_idom(useuse, r, dom_depth(useuse));\n-              }\n-            }\n-          }\n-          l -= uses_found;    \/\/ we deleted 1 or more copies of this edge\n-        }\n+        \/\/ We need to fix control uses for cloning vectorized drain loop and other loops\n+        \/\/ in different ways.\n+        switch (mode) {\n+          case InsertVectorizedDrain:\n+            fix_ctrl_uses_for_vectorized_drain(use, newuse, old_new, use_loop);\n+            break;\n+\n+          case IgnoreStripMined:\n+          case CloneIncludesStripMined:\n+          case ControlAroundStripMined:\n+            fix_ctrl_uses_for_common_loop(use, newuse, old_new, use_loop, side_by_side_idom);\n+            break;\n@@ -2744,19 +3114,4 @@\n-        assert(use->is_Proj(), \"loop exit should be projection\");\n-        \/\/ replace_node_and_forward_ctrl() below moves all nodes that are:\n-        \/\/ - control dependent on the loop exit or\n-        \/\/ - have control set to the loop exit\n-        \/\/ below the post-loop merge point.\n-        \/\/ replace_node_and_forward_ctrl() takes a dead control as first input.\n-        \/\/ To make it possible to use it, the loop exit projection is cloned and becomes the\n-        \/\/ new exit projection. The initial one becomes dead and is \"replaced\" by the region.\n-        Node* use_clone = use->clone();\n-        register_control(use_clone, use_loop, idom(use), dom_depth(use));\n-        \/\/ Now finish up 'r'\n-        r->set_req(1, newuse);\n-        r->set_req(2, use_clone);\n-        _igvn.register_new_node_with_optimizer(r);\n-        set_loop(r, use_loop);\n-        set_idom(r, (side_by_side_idom == nullptr) ? newuse->in(0) : side_by_side_idom, dd_r);\n-        replace_node_and_forward_ctrl(use, r);\n-        \/\/ Map the (cloned) old use to the new merge point\n-        old_new.map(use_clone->_idx, r);\n+          default:\n+            assert(false, \"should not reach here\");\n+            break;\n+        }\n@@ -2768,0 +3123,183 @@\n+void PhaseIdealLoop::fix_ctrl_uses_for_common_loop(Node* use, Node* newuse, Node_List& old_new,\n+                                                   IdealLoopTree* use_loop, Node* side_by_side_idom) {\n+  \/\/ We need a Region to merge the exit from the peeled body and the\n+  \/\/ exit from the old loop body.\n+  RegionNode* r = new RegionNode(3);\n+  uint dd_r = MIN2(dom_depth(newuse), dom_depth(use));\n+  assert(dd_r >= dom_depth(dom_lca(newuse, use)), \"\" );\n+\n+  \/\/ The original user of 'use' uses 'r' instead.\n+  for (DUIterator_Last lmin, l = use->last_outs(lmin); l >= lmin;) {\n+    Node* useuse = use->last_out(l);\n+    _igvn.rehash_node_delayed(useuse);\n+    uint uses_found = 0;\n+    if (useuse->in(0) == use) {\n+      useuse->set_req(0, r);\n+      uses_found++;\n+      if (useuse->is_CFG()) {\n+        \/\/ This is not a dom_depth > dd_r because when new\n+        \/\/ control flow is constructed by a loop opt, a node and\n+        \/\/ its dominator can end up at the same dom_depth\n+        assert(dom_depth(useuse) >= dd_r, \"\");\n+        set_idom(useuse, r, dom_depth(useuse));\n+      }\n+    }\n+    for (uint k = 1; k < useuse->req(); k++) {\n+      if (useuse->in(k) == use) {\n+        useuse->set_req(k, r);\n+        uses_found++;\n+        if (useuse->is_Loop() && k == LoopNode::EntryControl) {\n+          \/\/ This is not a dom_depth > dd_r because when new\n+          \/\/ control flow is constructed by a loop opt, a node\n+          \/\/ and its dominator can end up at the same dom_depth\n+          assert(dom_depth(useuse) >= dd_r , \"\");\n+          set_idom(useuse, r, dom_depth(useuse));\n+        }\n+      }\n+    }\n+    l -= uses_found; \/\/ we deleted 1 or more copies of this edge\n+  }\n+\n+  assert(use->is_Proj(), \"loop exit should be projection\");\n+  \/\/ replace_node_and_forward_ctrl() below moves all nodes that are:\n+  \/\/ - control dependent on the loop exit or\n+  \/\/ - have control set to the loop exit\n+  \/\/ below the post-loop merge point.\n+  \/\/ replace_node_and_forward_ctrl() takes a dead control as first input.\n+  \/\/ To make it possible to use it, the loop exit projection is cloned and becomes the\n+  \/\/ new exit projection. The initial one becomes dead and is \"replaced\" by the region.\n+  Node* use_clone = use->clone();\n+  register_control(use_clone, use_loop, idom(use), dom_depth(use));\n+  \/\/ Now finish up 'r'\n+  r->set_req(1, newuse);\n+  r->set_req(2, use_clone);\n+  _igvn.register_new_node_with_optimizer(r);\n+  set_loop(r, use_loop);\n+  set_idom(r, (side_by_side_idom == nullptr) ? newuse->in(0) : side_by_side_idom, dd_r);\n+  replace_node_and_forward_ctrl(use, r);\n+  \/\/ Map the (cloned) old use to the new merge point\n+  old_new.map(use_clone->_idx, r);\n+}\n+\n+\/\/ After clone_loop_body() and fix_body_edges(), now the control uses of the new loop body\n+\/\/ is like:\n+\/\/ (To simplify it, we ignore the outer strip-mined loop here.)\n+\n+\/\/          pre loop exit\n+\/\/              |\n+\/\/      main zero-trip guard\n+\/\/       \/     \\\n+\/\/  IfFalse    IfTrue\n+\/\/    \/        |   \\____________________\n+\/\/   |         |                        \\\n+\/\/   |   ----> main loop head   -----> vectorized drain loop head\n+\/\/   |   |           |          |              |\n+\/\/   |  IfTrue       |        IfTrue           |\n+\/\/   |   |           v          |              v\n+\/\/   |   ---- main loop end     ------ vectorized drain loop end\n+\/\/   |         |\n+\/\/    \\      IfFalse('main_use')\n+\/\/     \\       |\n+\/\/   RegionNode ('main_merge_region')\n+\/\/              |\n+\/\/      post zero-trip guard\n+\/\/           |     \\\n+\/\/        IfFalse  IfTrue\n+\/\/           |        \\\n+\/\/           |      post loop\n+\/\/           |      \/\n+\/\/         after loop\n+\n+\/\/ 'drain_use' is cloned from 'main_use', i.e. IfFalse (main loop exit) and used as\n+\/\/ the exit of vectorized drain loop. 'main_merge_region' is the RegionNode merging\n+\/\/ the exit of main loop and the false path of zero trip guard for main loop.\n+\/\/ We create a new RegionNode, 'drain_merge_region', to merge all exit path from previous loop.\n+\/\/ Then part of the graph above becomes:\n+\n+\/\/          pre loop exit\n+\/\/              |\n+\/\/      main zero-trip guard\n+\/\/       \/     \\\n+\/\/  IfFalse    IfTrue\n+\/\/    \/        |   \\____________________\n+\/\/   |         |                        \\\n+\/\/   |   ----> main loop head   -----> vectorized drain loop head\n+\/\/   |   |           |          |              |\n+\/\/   |  IfTrue       |        IfTrue           |\n+\/\/   |   |           v          |              v\n+\/\/   |   ---- main loop end     ------ vectorized drain loop end\n+\/\/   |         |                              *|*\n+\/\/    \\      IfFalse('main_use')           IfFalse('drain_use')\n+\/\/     \\       |                             *\/*\n+\/\/   RegionNode ('main_merge_region')       *\/*\n+\/\/                               *\\*       *\/*\n+\/\/                new RegionNode ('drain_merge_region')\n+\/\/                                 |\n+\/\/                         post zero-trip guard\n+\/\/                               ...\n+\n+\/\/ After this step, the loop structure here is still not correct but all\n+\/\/ control uses of the vectorized drain loop have been fixed.\n+void PhaseIdealLoop::fix_ctrl_uses_for_vectorized_drain(Node* main_use, Node* drain_use, Node_List& old_new,\n+                                                        IdealLoopTree* use_loop) {\n+  \/\/ We need a Region to merge the exit from the cloned body(vectorized drain loop)\n+  \/\/ and the merge point of exits from the vector main-loop and pre-loop.\n+\n+  \/\/ We need to find the Region node merging exits from the vector main-loop\n+  \/\/ and pre-loop first.\n+  Node* main_merge_region = nullptr;\n+  for (DUIterator_Fast jmax, j = main_use->fast_outs(jmax); j < jmax; j++) {\n+    Node* outn = main_use->fast_out(j);\n+    if (outn->is_Region()) {\n+      assert(main_merge_region == nullptr, \"We definitely find only one valid main_merge_region\");\n+      main_merge_region = outn;\n+    }\n+  }\n+\n+  \/\/ Now we need a new Region node.\n+  RegionNode* drain_merge_region = new RegionNode(3);\n+  uint dd_r = MIN2(dom_depth(drain_use), dom_depth(main_merge_region));\n+  assert(dd_r >= dom_depth(dom_lca(drain_use, main_merge_region)), \"\");\n+  set_loop(drain_merge_region, use_loop);\n+  set_idom(drain_merge_region, drain_use->in(0), dd_r);\n+\n+  \/\/ We make all uses of \"main_merge_region\", excluding itself,\n+  \/\/ use the new Region node \"r\" instead.\n+  for (uint i = 0; i < main_merge_region->outcnt(); i++) {\n+    Node* useuse = main_merge_region->raw_out(i);\n+    if (useuse == main_merge_region || useuse->is_Phi()) {\n+      continue;\n+    }\n+    assert(useuse->is_CFG(), \"\");\n+    _igvn.rehash_node_delayed(useuse);\n+    if (useuse->in(0) == main_merge_region) {\n+      useuse->set_req(0, drain_merge_region);\n+      if (useuse->is_CFG()) {\n+        \/\/ This is not a dom_depth > dd_r because when new\n+        \/\/ control flow is constructed by a loop opt, a node and\n+        \/\/ its dominator can end up at the same dom_depth\n+        assert(dom_depth(useuse) >= dd_r, \"\");\n+        set_idom(useuse, drain_merge_region, dd_r+1);\n+      }\n+    }\n+    for (uint k = 1; k < useuse->req(); k++) {\n+      if (useuse->in(k) == main_merge_region) {\n+        useuse->set_req(k, drain_merge_region);\n+        if (useuse->is_Loop() && k == LoopNode::EntryControl) {\n+          \/\/ This is not a dom_depth > dd_r because when new\n+          \/\/ control flow is constructed by a loop opt, a node\n+          \/\/ and its dominator can end up at the same dom_depth\n+          assert(dom_depth(useuse) >= dd_r , \"\");\n+          set_idom(useuse, drain_merge_region, dom_depth(useuse));\n+        }\n+      }\n+    }\n+  }\n+\n+  drain_merge_region->set_req(1, drain_use);\n+  drain_merge_region->set_req(2, main_merge_region);\n+  _igvn.register_new_node_with_optimizer(drain_merge_region);\n+  \/\/ Map the (cloned) old use to the new merge point\n+  old_new.map(main_use->_idx, drain_merge_region);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":644,"deletions":106,"binary":false,"changes":750,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -86,0 +87,2 @@\n+  flags(BEFORE_VECTORIZED_DRAIN,        \"Before Vectorized Drain Loop\") \\\n+  flags(AFTER_VECTORIZED_DRAIN,         \"After Vectorized Drain Loop\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -97,0 +98,2 @@\n+    BEFORE_VECTORIZED_DRAIN(        \"Before Vectorized Drain Loop\"),\n+    AFTER_VECTORIZED_DRAIN(         \"After Vectorized Drain Loop\"),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -67,1 +68,4 @@\n-                  \"post .* multiversion_fast\", \"= 3\", \/\/ the second loop is vectorized, and has a vectorized post loop\n+                  \/\/ Both of loops are vectorized, and have vectorized drain post loops on platforms (<= 32 bytes).\n+                  \/\/ On platforms (> 32 bytes), the second loop is vectorized, and has a vectorized post loop\n+                  \"post .* multiversion_fast\", \"<= 4\",\n+                  \"post .* multiversion_fast\", \">= 3\",\n@@ -69,1 +73,2 @@\n-                  \"multiversion\",              \"= 7\", \/\/ nothing unexpected\n+                  \"multiversion\",              \">= 7\", \/\/ nothing unexpected\n+                  \"multiversion\",              \"<= 8\", \/\/ nothing unexpected\n@@ -77,1 +82,4 @@\n-                  \"post .* multiversion_fast\", \"= 3\",\n+                  \/\/ After loop-opts, we also constant fold the vectorized drain post loop of the first loop, as it is unreachable on platforms (!= 32bytes).\n+                  \/\/ But on platforms (== 32bytes), after loop-opts, the vectorized drain post loop of the first loop is reachable.\n+                  \"post .* multiversion_fast\", \"<= 4\",\n+                  \"post .* multiversion_fast\", \">= 3\",\n@@ -80,1 +88,1 @@\n-                  \"multiversion\",              \"<= 6\", \/\/ nothing unexpected\n+                  \"multiversion\",              \"<= 7\", \/\/ nothing unexpected\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMultiversionRemoveUselessSlowLoop.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test\n+ * @bug 8307084\n+ * @summary Test the optimization about vectorized drain loop with some testcases\n+ *          generated by fuzzer.\n+ *          Interpreter run is for verification with exact constant results.\n+ *\n+ * @run main\/othervm compiler.loopopts.superword.TestVectorizedDrainLoop\n+ * @run main\/othervm -Xint compiler.loopopts.superword.TestVectorizedDrainLoop\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   compiler.loopopts.superword.TestVectorizedDrainLoop\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   compiler.loopopts.superword.TestVectorizedDrainLoop\n+ * @run main\/othervm -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=compiler.loopopts.superword.TestVectorizedDrainLoop::*\n+ *                   compiler.loopopts.superword.TestVectorizedDrainLoop\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=compiler.loopopts.superword.TestVectorizedDrainLoop::*\n+ *                   compiler.loopopts.superword.TestVectorizedDrainLoop\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestVectorizedDrainLoop {\n+\n+    public static int N = 400;\n+    public static long long_check_sum = 0;\n+    public static long long_seed = 1L;\n+    public static float float_seed = -1.303F;\n+    public static short s_array[] = new short[N];\n+    public static long l_array[] = new long[N];\n+    public static int i_array[] = new int[N];\n+    public static long shift_count = -30723L;\n+    public static float float_factor = 27.992F;\n+    public static double double_adder = 0.55984;\n+\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static void init(long[] a, long seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static void init(float[] a, float seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static long checkSum(int[] a) {\n+        long sum = 0;\n+        for (int j = 0; j < a.length; j++) {\n+            sum += a[j];\n+        }\n+        return sum;\n+    }\n+\n+    public static double checkSum(float[] a) {\n+        double sum = 0;\n+        for (int j = 0; j < a.length; j++) {\n+            sum += a[j];\n+        }\n+        return sum;\n+    }\n+\n+    public static long checkSum(long[] a) {\n+        long sum = 0;\n+        for (int j = 0; j < a.length; j++) {\n+            sum += a[j];\n+        }\n+        return sum;\n+    }\n+\n+    public static void test1_helper(long l) {\n+        int i3 = 1, i5 = 5, i7 = 65,\n+            i9 = 47833, iArr[] = new int[N];\n+        init(iArr, 1);\n+        for (i5 = 1; 155 > i5; ++i5) {\n+            iArr[i5 + 1] = i3;\n+        }\n+        while (--i7 > 0) {\n+            i9 -= i5;\n+        }\n+        long_check_sum = l + i3 + i5 + i9;\n+    }\n+\n+    public static void test1() {\n+        int i1 = 118;\n+        while (++i1 < 398) {\n+            test1_helper(long_seed);\n+        }\n+        if (long_check_sum != 38070) {\n+            throw new RuntimeException(\"wrong result at test1: \" + long_check_sum);\n+        }\n+    }\n+\n+    public static void test2() {\n+        int i = -18, i21 = -3, i23 = 18, i25 = -12, iArr1[] = new int[N];\n+        for (i = 14; i < 397; i++) {\n+            for (i21 = 1; i21 < 66; ++i21) {\n+                for (i23 = 2; i23 > 1; --i23) {\n+                    iArr1[i23 + 1] += i21;\n+                }\n+                for (i25 = 1; i25 < 2; ++i25) {\n+                    switch ((i % 2) + 16) {\n+                        case 16:\n+                            s_array[i21] = (short)float_seed;\n+                            l_array[i21] -= i;\n+                    }\n+                }\n+            }\n+        }\n+        long check_sum = checkSum(iArr1);\n+        if (check_sum != 821535) {\n+            throw new RuntimeException(\"wrong result at test2: \" + check_sum);\n+        }\n+    }\n+\n+    public static void test3_helper() {\n+        float f1 = 7F;\n+        int i18 = -15;\n+        for (i18 = 6; i18 < 285; ++i18) {\n+            f1 *= 8;\n+            i_array[i18 - 1] += -203;\n+        }\n+        long_check_sum = Float.floatToIntBits(f1) + i18;\n+    }\n+\n+    public static void test3() {\n+        for (int i = 0; i < 10000; i++ ) {\n+            test3_helper();\n+        }\n+        if (long_check_sum != 2139095325) {\n+            throw new RuntimeException(\"wrong result at test3: \" + long_check_sum);\n+        }\n+    }\n+\n+    public static void test4_helper(int i6, long l1) {\n+        int i7 = -33872, i8 = 65468, i9 = 7, i10 = 40154, i11 = -148, iArr[] = new int[N];\n+        boolean b = true;\n+        i7 = 187;\n+        while (--i7 > 0) {\n+            iArr[i7 + 1] = 8;\n+            for (i8 = 1; i8 < 9; i8++) {\n+                i6 += (((i8 * shift_count) + float_factor) - i7);\n+                if (b) break;\n+                for (i10 = 1; i10 < 2; ++i10) {\n+                    l1 >>= shift_count;\n+                    i11 += (((i10 * float_factor) + shift_count) - i9);\n+                    double_adder += i7;\n+                    i9 += i10;\n+                    i6 += (i10 | i8);\n+                }\n+            }\n+        }\n+        long_check_sum = i6 + l1 + i7 + i8 + i9 + (b ? 1 : 0) + i10 + i11;\n+   }\n+\n+    public static void test4() {\n+        int i2 = -15478;\n+        for (int i = 0; i < 10000; i++ ) {\n+            test4_helper(i2, shift_count);\n+        }\n+        if (long_check_sum != -5732847) {\n+            throw new RuntimeException(\"wrong result at test4: \" + long_check_sum);\n+        }\n+    }\n+\n+    \/\/ test5_helper is an example where PhaseIdealLoop::resolve_input_for_drain_or_post()\n+    \/\/ cannot find an existing Phi node 'drain_input' among the uses of 'main_incr'.\n+    public static int test5_helper() {\n+        int i6 = 0, i7 = 1, i8 = 0, iArr[] = new int[N];\n+        float f=1F;\n+        for (i6 = 4; i6 < 166; i6++) {\n+          iArr[i6] *= -38756;\n+          i7 += (i6 + f);\n+        }\n+        for (i8 = 6; i8 < 282; ++i8) {\n+          long_check_sum = i7;\n+        }\n+        long meth_res = i6 + i7 + Float.floatToIntBits(f) + i8;\n+        return (int)meth_res;\n+    }\n+\n+    public static void test5() {\n+        for (int i = 0; i < 10000; i++ ) {\n+            test5_helper();\n+        }\n+        if (long_check_sum != 13852) {\n+            throw new RuntimeException(\"wrong result at test5: \" + long_check_sum);\n+        }\n+    }\n+\n+    \/\/ Example test case where phi_list.size() > 1 in\n+    \/\/ PhaseIdealLoop::fix_data_uses_for_vectorized_drain().\n+    public static int test6_helper(long l) {\n+\n+        int i4 = 7, i5 = -8, iArr[] = new int[N];\n+        short s3 = -11204;\n+        float fArr[] = new float[N];\n+        long lArr[] = new long[N];\n+\n+        init(fArr, -1.587F);\n+        init(iArr, -12);\n+        init(lArr, -8L);\n+        short s2 = 6902;\n+        for (i4 = 19; i4 < 337; ++i4) {\n+            fArr[i4] *= i5;\n+            i5 = s2;\n+        }\n+        iArr[(26391) % N] >>= i4;\n+        lArr[(i4 >>> 1) % N] -= -5740;\n+        i5 = s3;\n+        i5 -= i4;\n+        iArr[(459) % N] = i4;\n+        l = -48557;\n+        iArr[(i5 >>> 1) % N] = i4;\n+        l += i4;\n+        long meth_res = l + i4 + i5 + Double.doubleToLongBits(checkSum(fArr)) +\n+                        checkSum(iArr) + checkSum(lArr);\n+        return (int)meth_res;\n+    }\n+\n+    public static void test6() {\n+        int int_check_sum = 0;\n+        for (int i = 0; i < 10000; i++) {\n+            int_check_sum = test6_helper(long_seed);\n+        }\n+        if (int_check_sum != -316996328) {\n+            throw new RuntimeException(\"wrong result at test6: \" + int_check_sum);\n+        }\n+\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10; i++)\n+            test1();\n+            test2();\n+            test3();\n+            test4();\n+            test5();\n+            test6();\n+        }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestVectorizedDrainLoop.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -80,0 +80,2 @@\n+    public static int WARMUP_LEN = 2048;\n+    public static int START_IDX = 0;\n@@ -192,0 +194,32 @@\n+\n+        for (int i = 0; i < 10_000; i++) {\n+            byteadd(aB, bB, rB, START_IDX, WARMUP_LEN);\n+            shortadd(aS, bS, rS, START_IDX, WARMUP_LEN);\n+            intadd(aI, bI, rI, START_IDX, WARMUP_LEN);\n+            longadd(aL, bL, rL, START_IDX, WARMUP_LEN);\n+        }\n+\n+    }\n+\n+    public void byteadd(byte[] ba, byte[] bb, byte[] bc, int startIndex, int length) {\n+        for (int i = startIndex; i < startIndex + length; i++) {\n+            bc[i] = (byte) (ba[i] + bb[i]);\n+        }\n+    }\n+\n+    public void shortadd(short[] sa, short[] sb, short[] sc, int startIndex, int length) {\n+        for (int i = startIndex; i < startIndex + length; i++) {\n+            sc[i] = (short) (sa[i] + sb[i]);\n+        }\n+    }\n+\n+    public void intadd(int[] a, int[] b, int[] c, int startIndex, int length) {\n+        for (int i = startIndex; i < startIndex + length; i++) {\n+            c[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    public void longadd(long[] a, long[] b, long[] c, int startIndex, int length) {\n+        for (int i = startIndex; i < startIndex + length; i++) {\n+            c[i] = a[i] + b[i];\n+        }\n@@ -228,0 +262,12 @@\n+    @Benchmark\n+    public void bench031B_drain_memoryBound() {\n+        byteadd(aB, bB, rB, START_IDX, ITERATION_COUNT);\n+    }\n+\n+    @Benchmark\n+    public void bench031B_drain_dynamic() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            byteadd(aB, bB, rB, START_IDX, offsets[r]+ITERATION_COUNT);\n+        }\n+    }\n+\n@@ -261,0 +307,13 @@\n+\n+    @Benchmark\n+    public void bench032S_drain_memoryBound() {\n+        shortadd(aS, bS, rS, START_IDX, ITERATION_COUNT);\n+    }\n+\n+    @Benchmark\n+    public void bench032S_drain_dynamic() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            shortadd(aS, bS, rS, START_IDX, offsets[r]+ITERATION_COUNT);\n+        }\n+    }\n+\n@@ -330,0 +389,12 @@\n+    @Benchmark\n+    public void bench034I_drain_memoryBound() {\n+        intadd(aI, bI, rI, START_IDX, ITERATION_COUNT);\n+    }\n+\n+    @Benchmark\n+    public void bench034I_drain_dynamic() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            intadd(aI, bI, rI, START_IDX, offsets[r]+ITERATION_COUNT);\n+        }\n+    }\n+\n@@ -364,0 +435,12 @@\n+    @Benchmark\n+    public void bench035L_drain_memoryBound() {\n+        longadd(aL, bL, rL, START_IDX, ITERATION_COUNT);\n+    }\n+\n+    @Benchmark\n+    public void bench035L_drain_dynamic() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            longadd(aL, bL, rL, START_IDX, offsets[r]+ITERATION_COUNT);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorThroughputForIterationCount.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"modified"}]}