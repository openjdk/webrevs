{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -1317,2 +1318,7 @@\n-\/\/ If Node n lives in the back_ctrl block and cannot float, we clone a private\n-\/\/ version of n in preheader_ctrl block and return that, otherwise return n.\n+\/\/ If 'back_ctrl' is not null:\n+\/\/   - Clone a private version of node 'n' in 'preheader_ctrl' if it resides in the 'back_ctrl' block.\n+\/\/   - Otherwise, return 'n' unchanged.\n+\/\/\n+\/\/ If 'back_ctrl' is null: (Specially for pre-loop exit in get_vectorized_drain_input())\n+\/\/   - Clone 'n' into 'preheader_ctrl' if its block does not strictly dominate 'preheader_ctrl'.\n+\/\/   - Otherwise, return 'n'.\n@@ -1320,1 +1326,8 @@\n-  if (get_ctrl(n) != back_ctrl) return n;\n+  bool is_from_preloop_exit = (back_ctrl == nullptr);\n+  bool requires_clone_from_preloop_exit = !is_dominator(get_ctrl(n), preheader_ctrl);\n+  if (is_from_preloop_exit) {\n+    \/\/ Specially for pre-loop exit in get_vectorized_drain_input()\n+    if (!requires_clone_from_preloop_exit) return n;\n+  } else {\n+    if (get_ctrl(n) != back_ctrl) return n;\n+  }\n@@ -1330,1 +1343,2 @@\n-  if (n->in(0) && n->in(0) == back_ctrl) {\n+  if (n->in(0) && (n->in(0) == back_ctrl ||\n+                   (is_from_preloop_exit && requires_clone_from_preloop_exit))) {\n@@ -1354,1 +1368,1 @@\n-  } else {                      \/\/ raise n to cover LCA of uses\n+  } else if (!is_from_preloop_exit) {  \/\/ raise n to cover LCA of uses\n@@ -1376,0 +1390,89 @@\n+\/\/------------------------------get_vectorized_drain_input--------------------------\n+\/\/ After inserting zero trip guard for the vectorized drain loop,\n+\/\/ now we need to make the fall-in values to the vectorized drain\n+\/\/ loop come from phis merging exit values from the pre loop and\n+\/\/ the main loop.\n+\/\/ (new edges are marked with \"*\/*\" or \"*\\*\".)\n+\/\/\n+\/\/      pre loop exit  'pre_incr'\n+\/\/            |         \/\n+\/\/      main zero-trip guard\n+\/\/          \/          \\\n+\/\/     IfFalse        IfTrue\n+\/\/        \/               \\\n+\/\/       |     |------>   main loop head   'pre_incr'\n+\/\/       |     |              |         \\   \/\n+\/\/       |    IfTrue          |    |---> PhiNode('main_phi')\n+\/\/       |     |              |    |       |\n+\/\/       |     -------loop end     ---- addI('main_incr')\n+\/\/        \\              |                 |\n+\/\/         \\          IfFalse              |\n+\/\/          \\          \/        'pre_incr' |\n+\/\/  RegionNode('main_merge_region')   |    |\n+\/\/                \\              \\    |    |\n+\/\/                  \\            PhiNode('drain_input')\n+\/\/                    \\          \/                  *\\*\n+\/\/                 drain zero-trip guard             *\\*\n+\/\/                    \/  \\                            *\\*\n+\/\/               IfFalse IfTrue                        *\\*\n+\/\/  ('drain_bypass')\/       \\('drain_entry')            *|*\n+\/\/                 \/         \\                          *|*\n+\/\/                 |  |----> vectorized drain loop head *|*\n+\/\/                 |  |          |                   \\  *|*\n+\/\/                 | IfTrue      |          |---> PhiNode('drain_phi')\n+\/\/                 |  |          |          |        |\n+\/\/                 |  ----- loop end        ----- addI('drain_incr')\n+\/\/                  \\        |                      |\n+\/\/                   \\    IfFalse 'drain_input'    \/\n+\/\/                    \\    \/                |     \/\n+\/\/      RegionNode('drain_merge_region')    |    \/\n+\/\/                        \\             \\   |   \/\n+\/\/                         \\             PhiNode\n+\/\/                          \\           \/\n+\/\/                    post zero-trip guard\n+\/\/                           ...\n+\/\/\n+\/\/ We look for an existing Phi node 'drain_input' among the uses of 'main_incr'.\n+\/\/ If no valid Phi is found, we create a new Phi that merges output data edges\n+\/\/ from both the pre-loop and main loop.\n+Node* PhaseIdealLoop::get_vectorized_drain_input(Node* main_backedge_ctrl, VectorSet& visited,\n+                                                 Node_Stack& clones,Node* main_merge_region,\n+                                                 Node* main_phi) {\n+  Node* drain_input = nullptr;\n+  Node* main_incr = main_phi->in(LoopNode::LoopBackControl);\n+  if (get_ctrl(main_incr) != main_backedge_ctrl) {\n+    \/\/ We try to look up target phi from all uses of node 'main_incr'.\n+    drain_input = find_merge_phi_for_vectorized_drain(main_incr, main_merge_region);\n+  }\n+  if (drain_input == nullptr) {\n+    \/\/ Make the fall-in values to the vectorized drain-loop come from a phi node\n+    \/\/ merging the data from the vector main-loop and the pre-loop.\n+\n+    \/\/ If Node 'main_incr' lives in the 'main_backedge_ctrl' block, we clone a private version of\n+    \/\/ 'main_incr' in 'main_exit' block and return that, otherwise return 'main_incr'.\n+    main_incr = clone_up_backedge_goo(main_backedge_ctrl, main_merge_region->in(2), main_incr,\n+                                      visited, clones);\n+    drain_input = PhiNode::make(main_merge_region, main_incr);\n+    Node* pre_incr = main_phi->in(LoopNode::EntryControl);\n+    if (has_ctrl(pre_incr) && !is_dominator(get_ctrl(pre_incr), main_merge_region->in(1))) {\n+      \/\/ If the entry input of the main_phi is not directly from pre-loop but has been preprocessed\n+      \/\/ by some nodes floating below the zero-trip guard of main-loop, we need to clone a private\n+      \/\/ version of these nodes for vectorized drain loop.\n+      pre_incr = clone_up_backedge_goo(nullptr, main_merge_region->in(1), pre_incr, visited, clones);\n+    }\n+    drain_input->set_req(1, pre_incr);\n+    \/\/ If inserting a new Phi, check for prior hits\n+    Node* hit = _igvn.hash_find_insert(drain_input);\n+    if (hit == nullptr) {\n+      \/\/ Register new phi\n+      _igvn.register_new_node_with_optimizer(drain_input);\n+    } else {\n+      \/\/ Remove the new phi from the graph and use the hit\n+      _igvn.remove_dead_node(drain_input);\n+      drain_input = hit;\n+    }\n+    set_ctrl(drain_input, main_merge_region);\n+  }\n+  return drain_input;\n+}\n+\n@@ -1439,1 +1542,2 @@\n-  Node* main_exit = insert_post_loop(loop, old_new, main_head, main_end, post_incr, limit, post_head);\n+  Node* main_exit = insert_post_loop(loop, old_new, main_head, main_end, post_incr,\n+                                     limit, post_head, ControlAroundStripMined);\n@@ -1606,6 +1710,6 @@\n-\/\/------------------------------insert_vector_post_loop------------------------\n-\/\/ Insert a copy of the atomic unrolled vectorized main loop as a post loop,\n-\/\/ unroll_policy has  already informed  us that more  unrolling is  about to\n-\/\/ happen  to the  main  loop.  The  resultant  post loop  will  serve as  a\n-\/\/ vectorized drain loop.\n-void PhaseIdealLoop::insert_vector_post_loop(IdealLoopTree *loop, Node_List &old_new) {\n+\/\/------------------------------insert_vectorized_drain_loop------------------------\n+\/\/ Insert a copy of the vectorized but not super-unrolled main loop as another post loop,\n+\/\/ policy_unroll() has already informed us that more unrolling is about to happen to\n+\/\/ the main loop.\n+\/\/ The resultant post loop will serve as a vectorized drain loop.\n+void PhaseIdealLoop::insert_vectorized_drain_loop(IdealLoopTree* loop, Node_List& old_new) {\n@@ -1628,1 +1732,1 @@\n-  if (cl->has_atomic_post_loop()) return;\n+  if (cl->has_vectorized_drain_loop()) return;\n@@ -1648,0 +1752,2 @@\n+  C->print_method(PHASE_BEFORE_VECTORIZED_DRAIN, 4, main_head);\n+\n@@ -1649,1 +1755,1 @@\n-  main_head->mark_has_atomic_post_loop();\n+  main_head->mark_has_vectorized_drain_loop();\n@@ -1657,1 +1763,2 @@\n-  insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);\n+  insert_post_loop(loop, old_new, main_head, main_end, incr, limit,\n+                   post_head, InsertVectorizedDrain);\n@@ -1669,0 +1776,1 @@\n+  C->print_method(PHASE_AFTER_VECTORIZED_DRAIN, 4, post_head);\n@@ -1672,2 +1780,69 @@\n-\/\/ Insert post loops.  Add a post loop to the given loop passed.\n-Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n+\/\/ Insert a post loop with the specified mode for the given loop.\n+\/\/\n+\/\/ Here is how the loop structure is changed as we insert post loops with\n+\/\/ different mode.\n+\/\/\n+\/\/ insert_pre_post_loop() calls this function with the ControlAroundStripMined\n+\/\/ mode first. The new inserted loop serves as the 'post' loop and\n+\/\/ the loop structure becomes a 'main-post' structure:\n+\/\/\n+\/\/                 main loop\n+\/\/                     |\n+\/\/                     |\n+\/\/              post zero-trip guard\n+\/\/                   \/     \\\n+\/\/                  \/       \\\n+\/\/                 \/       post loop\n+\/\/                \/        \/\n+\/\/               \/        \/\n+\/\/              after loop\n+\/\/\n+\/\/ The caller insert_pre_post_loops() will continue to insert a 'pre' loop and\n+\/\/ zero trip guard for 'main' loop. It becomes a complete 'pre-main-post'\n+\/\/ model as showed below:\n+\/\/\n+\/\/               pre loop\n+\/\/                   |\n+\/\/                   |\n+\/\/            main zero-trip guard\n+\/\/                   \/    \\\n+\/\/                  \/      \\\n+\/\/                 \/      main loop\n+\/\/                \/          \/\n+\/\/               \/          \/\n+\/\/            post zero-trip guard\n+\/\/                   \/     \\\n+\/\/                  \/       \\\n+\/\/                 \/       post loop\n+\/\/                \/        \/\n+\/\/               \/        \/\n+\/\/              after loop\n+\/\/\n+\/\/ After auto-vectorization, if more unrolling is about to happen to the\n+\/\/ vectorized 'main' loop, insert_vectorized_drain_loop() will call this function\n+\/\/ with the InsertVectorizedDrain mode, the new inserted loop serves as another\n+\/\/ post loop, i.e. the vectorized drain loop, as showed below:\n+\/\/\n+\/\/               pre loop\n+\/\/                   |\n+\/\/                   |\n+\/\/            main zero-trip guard\n+\/\/                   \/    \\\n+\/\/                  \/      \\\n+\/\/                 \/      (vectorized) main loop\n+\/\/                \/          \/\n+\/\/               \/          \/\n+\/\/            drain zero-trip guard\n+\/\/                   \/    \\\n+\/\/                  \/      \\\n+\/\/                 \/        vectorized drain loop\n+\/\/                \/          \/\n+\/\/               \/          \/\n+\/\/            post zero-trip guard\n+\/\/                   \/     \\\n+\/\/                  \/       \\\n+\/\/                 \/       post loop\n+\/\/                \/        \/\n+\/\/               \/        \/\n+\/\/              after loop\n+Node* PhaseIdealLoop::insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n@@ -1675,1 +1850,2 @@\n-                                       Node* incr, Node* limit, CountedLoopNode*& post_head) {\n+                                       Node* main_incr, Node* limit, CountedLoopNode*& post_head,\n+                                       CloneLoopMode mode) {\n@@ -1685,2 +1861,0 @@\n-  \/\/------------------------------\n-  \/\/ Step A: Create a new post-Loop.\n@@ -1691,2 +1865,1 @@\n-  \/\/ Step A1: Clone the loop body of main. The clone becomes the post-loop.\n-  \/\/ The main loop pre-header illegally has 2 control users (old & new loops).\n+  \/\/ Step 1: Clone the loop body of main loop. The clone becomes the new loop.\n@@ -1694,1 +1867,1 @@\n-  clone_loop(loop, old_new, dd_main_exit, ControlAroundStripMined);\n+  clone_loop(loop, old_new, dd_main_exit, mode);\n@@ -1707,5 +1880,78 @@\n-  \/\/ Build the main-loop normal exit.\n-  IfFalseNode *new_main_exit = new IfFalseNode(outer_main_end);\n-  _igvn.register_new_node_with_optimizer(new_main_exit);\n-  set_idom(new_main_exit, outer_main_end, dd_main_exit);\n-  set_loop(new_main_exit, outer_loop->_parent);\n+  \/\/ Step 2: Find some key nodes which control the execution paths of the zero trip guard.\n+  \/\/ Step 2.1: Find 'zero_ctrl' which will be the control input of the zero trip guard.\n+  Node* zero_ctrl = nullptr;\n+  if (mode == InsertVectorizedDrain) {\n+    \/\/ For vectorized drain loop, 'zero_ctrl' should be the node merges exits\n+    \/\/ from the main loop and the pre loop.\n+    zero_ctrl = main_exit->unique_ctrl_out_or_null();\n+    assert(zero_ctrl, \"if zero_ctrl doesn't exist, pre-main-post model fails.\");\n+\n+    DEBUG_ONLY (\n+      \/\/ We can look up the target 'zero_ctrl' either by exit of the pre loop or\n+      \/\/ by exit of the main loop.\n+      Node* min_taken = main_head->skip_assertion_predicates_with_halt();\n+      IfNode* min_iff = min_taken->in(0)->as_If();\n+      assert(min_iff, \"Zero trip guard of main loop does exist.\");\n+      assert(zero_ctrl->is_Region() &&\n+             (zero_ctrl->in(1) == min_iff->proj_out(false) ||\n+              zero_ctrl->in(1) == min_iff->proj_out(true)), \"\");\n+    )\n+  } else {\n+    assert(mode == ControlAroundStripMined, \"\");\n+    \/\/ For post loop, build the main-loop normal exit as the 'zero_ctrl'.\n+    zero_ctrl = new IfFalseNode(outer_main_end);\n+    _igvn.register_new_node_with_optimizer(zero_ctrl);\n+    set_idom(zero_ctrl, outer_main_end, dd_main_exit);\n+    set_loop(zero_ctrl, outer_loop->_parent);\n+  }\n+\n+  \/\/ Step 2.2: Find 'exit_point', which is taken when zero trip guard fails.\n+  Node* exit_point = nullptr;\n+  uint replace_idx = 0;\n+  if (mode == InsertVectorizedDrain) {\n+    \/\/ For vectorized drain loop, 'exit_point' should merge exit from the vectorized drain\n+    \/\/ loop and 'zero_ctrl' merging exits from the pre loop and the main loop.\n+    for (uint i = 0; i < zero_ctrl->outcnt(); i++) {\n+      Node* outn = zero_ctrl->raw_out(i);\n+      if (outn != zero_ctrl && outn->is_CFG()) {\n+        assert(exit_point == nullptr,\n+               \"We definitely find only one valid exit_point\");\n+        exit_point = outn;\n+      }\n+    }\n+\n+    replace_idx = 2;\n+    DEBUG_ONLY (\n+      assert(exit_point->in(replace_idx) == zero_ctrl,\n+             \"The zero_ctrl should be the second input\");\n+    )\n+  } else {\n+    \/\/ For post loop, when zero trip guard fails, we should use the exit path from the main loop.\n+    exit_point = main_exit;\n+  }\n+\n+  \/\/ Step 3: Find a 'new_phi' which is the input trip count of the zero trip guard.\n+  Node* new_incr = nullptr;\n+  if (mode == InsertVectorizedDrain) {\n+    \/\/ For vectorized drain loop, 'new_phi' should merge 'main_incr' from the main loop and 'pre_incr'\n+    \/\/ from the pre loop.\n+    for (uint i = 0; i < main_incr->outcnt(); i++) {\n+      Node* outn = main_incr->raw_out(i);\n+      if (outn->in(0) == zero_ctrl) {\n+        new_incr = outn;\n+        break;\n+      }\n+    }\n+    DEBUG_ONLY (\n+      \/\/ We can look up the target merging phi node either from outputs of the pre-loop\n+      \/\/ incr or from outputs of the main-loop incr.\n+      Node* main_guard_opaq = main_head->is_canonical_loop_entry();\n+      Node* cmp  = main_guard_opaq->unique_out();\n+      Node* pre_incr = cmp->in(1);\n+      assert(new_incr && new_incr->in(1) == pre_incr && new_incr->in(2) == main_incr, \"\");\n+    )\n+  } else {\n+    assert(mode == ControlAroundStripMined, \"\");\n+    \/\/ For post loop, use the loop incr from the main loop directly.\n+    new_incr = main_incr;\n+  }\n@@ -1713,3 +1959,3 @@\n-  \/\/ Step A2: Build a zero-trip guard for the post-loop.  After leaving the\n-  \/\/ main-loop, the post-loop may not execute at all.  We 'opaque' the incr\n-  \/\/ (the previous loop trip-counter exit value) because we will be changing\n+  \/\/ Step 4: Build a zero-trip guard for the new inserted loop. Whether leaving the\n+  \/\/ main-loop or the pre loop, the new loop may not execute at all. We 'opaque'\n+  \/\/ the incr (the previous loop trip-counter exit value) because we will be changing\n@@ -1718,6 +1964,66 @@\n-  Node *zer_opaq = new OpaqueZeroTripGuardNode(C, incr, main_end->test_trip());\n-  Node *zer_cmp = new CmpINode(zer_opaq, limit);\n-  Node *zer_bol = new BoolNode(zer_cmp, main_end->test_trip());\n-  register_new_node(zer_opaq, new_main_exit);\n-  register_new_node(zer_cmp, new_main_exit);\n-  register_new_node(zer_bol, new_main_exit);\n+  \/\/ For example, when we're inserting vectorized drain loop, after several steps above,\n+  \/\/ the loop structure is showed in the comments for handle_data_uses_for_vectorized_drain().\n+  \/\/ After inserting the zero trip guard, it becomes:\n+  \/\/ (new edges are marked with \"*\/*\" or \"*\\*\".)\n+\n+  \/\/          |----> pre loop head ...\n+  \/\/          |      |          \\  \/\n+  \/\/         IfTrue  |   |---->  PhiNode\n+  \/\/          |      |   |         |\n+  \/\/         loop end    ------ addI('pre_incr')\n+  \/\/               |           \/\n+  \/\/           IfFalse       \/\n+  \/\/               |       \/\n+  \/\/               |     \/\n+  \/\/         main zero-trip guard\n+  \/\/             \/  \\\n+  \/\/        IfFalse  IfTrue\n+  \/\/           \/       \\\n+  \/\/          \/         \\               'pre_incr'\n+  \/\/          |  |----> main loop head    \/\n+  \/\/          |  |     |              \\  \/\n+  \/\/          | IfTrue |      |--->  PhiNode\n+  \/\/          |  |     |      |          |\n+  \/\/          |   loop end    -------- addI('main_incr')\n+  \/\/           \\       |                   |\n+  \/\/            \\     IfFalse   'pre_incr' |\n+  \/\/             \\     \/              |    |\n+  \/\/       RegionNode('zero_ctrl')    |    |\n+  \/\/                  *\\*         \\   |    |\n+  \/\/                    *\\*       PhiNode('new_incr')\n+  \/\/                      *\\*       *\/*\n+  \/\/                  drain zero-trip guard ('zer_opaq')\n+  \/\/                      *\/* *\\*\n+  \/\/  ('drain_bypass')IfFalse  IfTrue ('zer_taken')\n+  \/\/                    *\/*      *\\*\n+  \/\/                   *\/*        *\\*                          'pre_incr'\n+  \/\/                  *\/*   |----> vectorized drain loop head   \/\n+  \/\/                 *|*    |         |                    \\   \/\n+  \/\/                 *|*   IfTrue     |         |-----> PhiNode('drain_phi')\n+  \/\/                 *|*    |         |         |         |\n+  \/\/                  *\\*   ------loop end      ------- addI('drain_incr')\n+  \/\/                    *\\*         |                  \/\n+  \/\/                     *\\*    IfFalse  'new_incr'  \/\n+  \/\/                       *\\*   \/         |       \/\n+  \/\/             RegionNode('exit_point')  |     \/\n+  \/\/                        |          \\   |   \/\n+  \/\/                        |           PhiNode\n+  \/\/                        |            \/   \\\n+  \/\/                   post zero-trip guard   \\\n+  \/\/                   \/      \\                \\\n+  \/\/               IfFalse   IfTrue            |\n+  \/\/                  |        |               |\n+  \/\/                  |  |---> post loop head  |\n+  \/\/                ...  |     |           \\   |\n+  \/\/                   IfTrue  |      |---> PhiNode\n+  \/\/                     |     |      |       |\n+  \/\/                     loop end     ----- addI\n+  \/\/                           |\n+  \/\/                          ...\n+\n+  Node* zer_opaq = new OpaqueZeroTripGuardNode(C, new_incr, main_end->test_trip());\n+  Node* zer_cmp = new CmpINode(zer_opaq, limit);\n+  Node* zer_bol = new BoolNode(zer_cmp, main_end->test_trip());\n+  register_new_node(zer_opaq, zero_ctrl);\n+  register_new_node(zer_cmp, zero_ctrl);\n+  register_new_node(zer_bol, zero_ctrl);\n@@ -1726,1 +2032,1 @@\n-  IfNode *zer_iff = new IfNode(new_main_exit, zer_bol, PROB_FAIR, COUNT_UNKNOWN);\n+  IfNode* zer_iff = new IfNode(zero_ctrl, zer_bol, PROB_FAIR, COUNT_UNKNOWN);\n@@ -1728,1 +2034,2 @@\n-  set_idom(zer_iff, new_main_exit, dd_main_exit);\n+  int dd_zero_ctrl = dom_depth(zero_ctrl);\n+  set_idom(zer_iff, zero_ctrl, dd_zero_ctrl);\n@@ -1731,6 +2038,16 @@\n-  \/\/ Plug in the false-path, taken if we need to skip this post-loop\n-  _igvn.replace_input_of(main_exit, 0, zer_iff);\n-  set_idom(main_exit, zer_iff, dd_main_exit);\n-  set_idom(main_exit->unique_out(), zer_iff, dd_main_exit);\n-  \/\/ Make the true-path, must enter this post loop\n-  Node *zer_taken = new IfTrueNode(zer_iff);\n+  \/\/ Plug in the false-path, taken if we need to skip this new loop.\n+  if (mode == InsertVectorizedDrain) {\n+    IfFalseNode* drain_bypass = new IfFalseNode(zer_iff);\n+    _igvn.register_new_node_with_optimizer(drain_bypass);\n+    set_idom(drain_bypass, zer_iff, dd_zero_ctrl);\n+    set_loop(drain_bypass, outer_loop->_parent);\n+    _igvn.replace_input_of(exit_point, replace_idx, drain_bypass);\n+    set_idom(exit_point, drain_bypass, dd_zero_ctrl);\n+  } else {\n+    _igvn.replace_input_of(exit_point, replace_idx, zer_iff);\n+    set_idom(exit_point, zer_iff, dd_zero_ctrl);\n+    set_idom(exit_point->unique_out(), zer_iff, dd_zero_ctrl);\n+  }\n+\n+  \/\/ Plug in the true path, taken if we enter this new loop.\n+  Node* zer_taken = new IfTrueNode(zer_iff);\n@@ -1740,1 +2057,0 @@\n-  \/\/ Plug in the true path\n@@ -1745,0 +2061,1 @@\n+  \/\/ Step 5: Correct the fall-in values to the new loop.\n@@ -1747,12 +2064,27 @@\n-  \/\/ Step A3: Make the fall-in values to the post-loop come from the\n-  \/\/ fall-out values of the main-loop.\n-  for (DUIterator i = main_head->outs(); main_head->has_out(i); i++) {\n-    Node* main_phi = main_head->out(i);\n-    if (main_phi->is_Phi() && main_phi->in(0) == main_head && main_phi->outcnt() > 0) {\n-      Node* cur_phi = old_new[main_phi->_idx];\n-      Node* fallnew = clone_up_backedge_goo(main_head->back_control(),\n-                                            post_head->init_control(),\n-                                            main_phi->in(LoopNode::LoopBackControl),\n-                                            visited, clones);\n-      _igvn.hash_delete(cur_phi);\n-      cur_phi->set_req(LoopNode::EntryControl, fallnew);\n+  if (mode == InsertVectorizedDrain) {\n+    \/\/ Make the fall-in values to the vectorized drain loop come\n+    \/\/ from phis merging exit values from the pre loop and the main loop.\n+    for (DUIterator i = main_head->outs(); main_head->has_out(i); i++) {\n+      Node* main_phi = main_head->out(i);\n+      if (main_phi->is_Phi() && main_phi->in(0) == main_head && main_phi->outcnt() > 0) {\n+        Node* drain_phi = old_new[main_phi->_idx];\n+        Node* drain_input = get_vectorized_drain_input(main_head->back_control(),\n+                                                       visited, clones, zero_ctrl, main_phi);\n+        _igvn.hash_delete(drain_phi);\n+        drain_phi->set_req(LoopNode::EntryControl, drain_input);\n+      }\n+    }\n+  } else {\n+    \/\/ Make the fall-in values to the post loop come from the\n+    \/\/ fall-out values of the main loop.\n+    for (DUIterator i = main_head->outs(); main_head->has_out(i); i++) {\n+      Node* main_phi = main_head->out(i);\n+      if (main_phi->is_Phi() && main_phi->in(0) == main_head && main_phi->outcnt() > 0) {\n+        Node* post_phi = old_new[main_phi->_idx];\n+        Node* fallnew = clone_up_backedge_goo(main_head->back_control(),\n+                                              post_head->init_control(),\n+                                              main_phi->in(LoopNode::LoopBackControl),\n+                                              visited, clones);\n+        _igvn.hash_delete(post_phi);\n+        post_phi->set_req(LoopNode::EntryControl, fallnew);\n+      }\n@@ -1764,0 +2096,14 @@\n+\n+  if (mode == InsertVectorizedDrain) {\n+    \/\/ 'loop_node' is a data node and part of the vectorized drain loop.\n+    \/\/ Rewire the control to the projection of the zero-trip guard.\n+    Node* main_entry_ctrl = main_head->skip_assertion_predicates_with_halt();\n+    Node* post_entry_ctrl = zer_taken;\n+    for (uint i = 0; i < main_entry_ctrl->outcnt(); i++) {\n+      Node* loop_node = main_entry_ctrl->raw_out(i);\n+      if (loop_node->_idx >= first_node_index_in_cloned_loop_body) {\n+        _igvn.replace_input_of(loop_node, 0, post_entry_ctrl);\n+        --i;\n+      }\n+    }\n+  }\n@@ -1765,1 +2111,1 @@\n-  return new_main_exit;\n+  return zero_ctrl;\n@@ -3547,1 +3893,1 @@\n-        phase->insert_vector_post_loop(this, old_new);\n+        phase->insert_vectorized_drain_loop(this, old_new);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":406,"deletions":60,"binary":false,"changes":466,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -78,1 +79,1 @@\n-         HasAtomicPostLoop     = 1<<11,\n+         HasVectorizedDrain    = 1<<11,\n@@ -117,1 +118,1 @@\n-  void mark_has_atomic_post_loop() { _loop_flags |= HasAtomicPostLoop; }\n+  void mark_has_vectorized_drain_loop() { _loop_flags |= HasVectorizedDrain; }\n@@ -296,0 +297,4 @@\n+  \/\/ If the 'main' loop is auto-vectorized and super-unrolled, it also\n+  \/\/ has a 'vectorized drain' loop, which is copied from vectorized but\n+  \/\/ not super-unrolled 'main' loop and inserted post the 'main' loop.\n+\n@@ -306,1 +311,1 @@\n-  bool has_atomic_post_loop  () const { return (_loop_flags & HasAtomicPostLoop) == HasAtomicPostLoop; }\n+  bool has_vectorized_drain_loop () const { return (_loop_flags & HasVectorizedDrain) == HasVectorizedDrain; }\n@@ -1340,4 +1345,16 @@\n-  \/\/ edges are the same.  All exits from the old-loop now have a RegionNode\n-  \/\/ that merges the equivalent new-loop path.  This is true even for the\n-  \/\/ normal \"loop-exit\" condition.  All uses of loop-invariant old-loop values\n-  \/\/ now come from (one or more) Phis that merge their new-loop equivalents.\n+  \/\/ edges are the same.\n+  \/\/\n+  \/\/ For most modes (except InsertVectorizedDrain):\n+  \/\/ All exits from the old-loop now have a RegionNode that merges the\n+  \/\/ equivalent new-loop path.  This is true even for the normal \"loop-exit\"\n+  \/\/ condition.  All uses of loop-variant old-loop values now come from\n+  \/\/ (one or more) Phis that merge their new-loop equivalents.\n+  \/\/\n+  \/\/ For InsertVectorizedDrain mode:\n+  \/\/ all control uses of exits from old-loop now should use new RegionNodes\n+  \/\/ that merges RegionNode which merges exits from pre-loop and main-loop\n+  \/\/ and exits from the new-loop (vectorized drain loop).All data uses of values\n+  \/\/ from old-loop now should use new Phis that merges Phis which merges\n+  \/\/ values from pre-loop and main-loop and values from the new-loop\n+  \/\/ (vectorized drain loop) equivalents.\n+  \/\/\n@@ -1354,1 +1371,1 @@\n-    ControlAroundStripMined = 2  \/\/ Only clone inner strip mined loop,\n+    ControlAroundStripMined = 2, \/\/ Only clone inner strip mined loop,\n@@ -1358,0 +1375,3 @@\n+    InsertVectorizedDrain = 3    \/\/ Only clone inner strip mined vector loop,\n+                                 \/\/ result control flow branches to inner clone or\n+                                 \/\/ scalar post loop\n@@ -1366,0 +1386,5 @@\n+  void handle_data_uses_for_vectorized_drain(Node* main_old, Node_List& old_new,\n+                                             IdealLoopTree* loop, IdealLoopTree* outer_loop,\n+                                             Node_List& worklist, uint new_counter);\n+  void clone_outer_nodes_helper(Node* root, uint new_counter, Node_List& old_new,\n+                                LoopNode* head, Node_List& extra_data_nodes, CloneLoopMode mode);\n@@ -1369,0 +1394,1 @@\n+  Node* find_merge_phi_for_vectorized_drain(Node* n, Node* merge_region);\n@@ -1384,1 +1410,1 @@\n-  Node *insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n+  Node* insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n@@ -1386,1 +1412,5 @@\n-                         Node* incr, Node* limit, CountedLoopNode*& post_head);\n+                         Node* main_incr, Node* limit, CountedLoopNode*& post_head,\n+                         CloneLoopMode mode);\n+\n+  \/\/ Add a vectorized drain loop between the main loop and the current post loop.\n+  void insert_vectorized_drain_loop(IdealLoopTree* loop, Node_List& old_new);\n@@ -1388,4 +1418,7 @@\n-  \/\/ Add a vector post loop between a vector main loop and the current post loop\n-  void insert_vector_post_loop(IdealLoopTree *loop, Node_List &old_new);\n-  \/\/ If Node n lives in the back_ctrl block, we clone a private version of n\n-  \/\/ in preheader_ctrl block and return that, otherwise return n.\n+\/\/ If 'back_ctrl' is not null:\n+\/\/   - Clone a private version of node 'n' in 'preheader_ctrl' if it resides in the 'back_ctrl' block.\n+\/\/   - Otherwise, return 'n' unchanged.\n+\/\/\n+\/\/ If 'back_ctrl' is null: (Specially for pre-loop exit in get_vectorized_drain_input())\n+\/\/   - Clone 'n' into 'preheader_ctrl' if its block does not strictly dominate 'preheader_ctrl'.\n+\/\/   - Otherwise, return 'n'.\n@@ -1394,0 +1427,9 @@\n+  \/\/ If Node 'main_incr' lives in the 'main_backedge_ctrl' block, we clone\n+  \/\/ a private version of 'main_incr' in 'drain_entry' block and return that,\n+  \/\/ otherwise return a phi node 'main_merge_phi' merging exit values from\n+  \/\/ the main loop and the pre loop.\n+  \/\/ When 'main_incr' is dead, return nullptr.\n+  Node* get_vectorized_drain_input(Node* main_backedge_ctrl, VectorSet& visited,\n+                                   Node_Stack& clones, Node* main_merge_region,\n+                                   Node* main_phi);\n+\n@@ -1881,1 +1923,4 @@\n-\n+  void fix_ctrl_uses_for_common_loop(Node* use, Node* newuse, Node_List& old_new,\n+                                     IdealLoopTree* use_loop, Node* side_by_side_idom);\n+  void fix_ctrl_uses_for_vectorized_drain(Node* main_use, Node* drain_use, Node_List& old_new,\n+                                          IdealLoopTree* use_loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":60,"deletions":15,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -2336,0 +2337,239 @@\n+\/\/ This function is going to fix all data uses of the new loop body.\n+\n+\/\/ Take the loop increment \"i\" as an example.\n+\/\/ Now the data uses about \"i\" are like:\n+\n+\/\/   |----> pre loop head ...\n+\/\/   |      |          \\  \/\n+\/\/  IfTrue  |  |---->  PhiNode\n+\/\/   |      |  |         |\n+\/\/  loop end   ------ addI('pre_incr')\n+\/\/        |           \/\n+\/\/    IfFalse       \/\n+\/\/        |       \/\n+\/\/        |     \/\n+\/\/   main zero-trip guard\n+\/\/     \/     \\\n+\/\/ IfFalse  IfTrue\n+\/\/   \/       |  \\_____________________________\n+\/\/  \/        |                                \\\n+\/\/  |   |--> main loop head             |---> vectorized drain loop head\n+\/\/  |   |    |           \\  'pre_incr'  |     |          \\   'pre_incr'\n+\/\/  |   |    |            \\   \/         |     |           \\   \/\n+\/\/  | IfTrue |       |----> PhiNode   IfTrue  |    |----> PhiNode\n+\/\/  |   |    |       |       |          |     |    |        |\n+\/\/  |   loop end     ------ addI        loop end   ----- addI('drain_new')\n+\/\/  |        |                |              |\n+\/\/   \\      IfFalse           |            IfFalse\n+\/\/    \\      |                |             \/\n+\/\/     \\    \/     'pre_incr'  |            \/\n+\/\/ 'main_merge_region'  |     |           \/\n+\/\/             \\    \\   |     |          \/\n+\/\/              \\  'main_merge_phi'     \/\n+\/\/               \\                     \/\n+\/\/              RegionNode('drain_merge_region')\n+\/\/                  |\n+\/\/                  |    'main_merge_phi'\n+\/\/                  |      \/\n+\/\/            post zero-trip guard\n+\/\/              \/        \\\n+\/\/          IfFalse      IfTrue\n+\/\/             |           |\n+\/\/             |   |---> post loop head  'main_merge_phi'\n+\/\/           ...   |      |            \\  \/\n+\/\/                IfTrue  |      |---> PhiNode\n+\/\/                 |      |      |       |\n+\/\/                  loop end     ----- addI\n+\/\/                     |\n+\/\/                    ...\n+\n+\/\/ The equivalent loop increment 'i' in the new loop body is 'drain_new',\n+\/\/ which is dangling. We create a new 'drain_merge_phi' node which will\n+\/\/ merge 'drain_new' and 'main_merge_phi' and take the RegionNode,\n+\/\/ 'new_prev', as the control input which was created in\n+\/\/ fix_ctrl_uses_for_vectorized_drain(). This new node 'drain_merge_phi'\n+\/\/ will replace all other uses of 'main_merge_phi'.\n+\/\/ The data uses will become:\n+\/\/ (new edges are marked with \"*\/*\" or \"*\\*\".)\n+\n+\/\/  pre loop exit  'pre_incr'\n+\/\/        |         \/\n+\/\/   main zero-trip guard\n+\/\/     \/      \\\n+\/\/  IfFalse IfTrue\n+\/\/   \/       |   \\______________________________\n+\/\/  \/        |                                  \\\n+\/\/  |   |--> main loop head                |---> vectorized drain loop head\n+\/\/  |   |    |         \\  'pre_incr'       |     |              \\   'pre_incr'\n+\/\/  |   |    |          \\   \/              |     |               \\   \/\n+\/\/  | IfTrue |     |---> PhiNode         IfTrue  |      |----->  PhiNode\n+\/\/  |   |    |     |        |              |     |      |           |\n+\/\/  |   loop end   ------ addI('main_old') loop end     -------- addI('drain_new')\n+\/\/  |        |               |                   |                *\/*\n+\/\/   \\     IfFalse           |          IfFalse('drain_exit')   *\/*\n+\/\/    \\      |               |                                *\/*\n+\/\/     \\     |    'pre_incr' |                              *\/*\n+\/\/ 'main_merge_region' |     |                            *\/*\n+\/\/           \\     \\   |     |                          *\/*\n+\/\/            \\   PhiNode('main_merge_phi')           *\/*\n+\/\/             \\                     *|*            *\/*\n+\/\/              \\   'drain_exit'     *|*          *\/*\n+\/\/               \\      \/            *|*        *\/*\n+\/\/ RegionNode('drain_merge_region')  *|*      *\/*\n+\/\/               |              *\\*  *|*    *\/*\n+\/\/               |           PhiNode('drain_merge_phi')\n+\/\/               |               *\/*     *|*\n+\/\/            post zero-trip guard       *|*\n+\/\/              \/        \\               *|*\n+\/\/          IfFalse      IfTrue          *|*\n+\/\/             |           |             *|*\n+\/\/            ...  |---> post loop head  *|*\n+\/\/                 |      |            \\ *|*\n+\/\/                IfTrue  |     |---> PhiNode\n+\/\/                 |      |     |        |\n+\/\/                  loop end    ------ addI\n+\/\/                        |\n+\/\/                       ...\n+void PhaseIdealLoop::handle_data_uses_for_vectorized_drain(Node* main_old, Node_List &old_new,\n+                                                           IdealLoopTree* loop, IdealLoopTree* outer_loop,\n+                                                           Node_List& worklist, uint new_counter) {\n+\n+  \/\/ For the node 'use', if it uses 'old_in' as an input, replace it with the new cloned input 'new_in'.\n+  auto replace_input_with_new_clone = [&](Node* use, Node* old_in, Node* new_in, uint& count) {\n+    bool make_change = false;\n+    for (uint k = 1; k < use->req(); k++) {\n+      if (use->in(k) == old_in) {\n+        _igvn.replace_input_of(use, k, new_in);\n+        count--;\n+        make_change = true;\n+      }\n+    }\n+    if (make_change && use->_idx >= new_counter) {\n+      Node* hit = _igvn.hash_find_insert(use);\n+      if (hit)\n+        _igvn.replace_node(use, hit);\n+    }\n+  };\n+\n+  for (DUIterator_Fast jmax, j = main_old->fast_outs(jmax); j < jmax; j++)\n+    worklist.push(main_old->fast_out(j));\n+\n+  while (worklist.size()) {\n+    Node* use = worklist.pop();\n+    if (!has_node(use)) continue; \/\/ Ignore dead nodes\n+    if (use->in(0) == C->top()) continue;\n+    IdealLoopTree* use_loop = get_loop(has_ctrl(use) ? get_ctrl(use) : use);\n+    if (!loop->is_member(use_loop) && !outer_loop->is_member(use_loop) && (!main_old->is_CFG() || !use->is_CFG())) {\n+\n+      \/\/ Find the phi node merging the data from pre-loop and vector main-loop.\n+      Node_List visit_list;\n+      Node_List phi_list;\n+      if (use->is_Phi()) {\n+        phi_list.push(use);\n+      } else {\n+        visit_list.push(use);\n+      }\n+\n+      \/\/ Use BFS to clone all necessary nodes starting from the 'use' node, which exits the main loop,\n+      \/\/ until reaching a merge point with a path from the pre-loop.\n+      while (visit_list.size()) {\n+        Node* curr = visit_list.at(0);\n+        visit_list.remove(0);\n+        Node* newcurr = old_new[curr->_idx];\n+        if (newcurr) {\n+          continue;\n+        }\n+        newcurr = curr->clone();\n+        if (curr->in(0)) {\n+          Node* merged_ctrl = old_new[curr->in(0)->_idx];\n+          assert(merged_ctrl->is_Region() && merged_ctrl->in(2)->is_Region(),\n+                 \"Must be a merge point of pre, main, and vectorized drain loops\");\n+          \/\/ The cloned node \"newcurr\" should be in the exit path of vectorized drain loop.\n+          newcurr->set_req(0, merged_ctrl->in(1));\n+        }\n+        for (uint j = 1; j < newcurr->req(); j++) {\n+          Node* n = newcurr->in(j);\n+          if (n != nullptr && old_new[n->_idx]) {\n+            newcurr->set_req(j, old_new[n->_idx]);\n+          }\n+        }\n+        old_new.map(curr->_idx, newcurr);\n+        _igvn.register_new_node_with_optimizer(newcurr);\n+        for (uint j = 0; j < curr->outcnt(); j++) {\n+          Node* outn = curr->raw_out(j);\n+          if (outn->is_CFG()) continue;\n+          Node* newoutn = outn->_idx > new_counter? outn : old_new[outn->_idx];\n+          if (newoutn) {\n+            replace_input_with_new_clone(newoutn, curr, newcurr, j);\n+            \/\/ The node \"outn\" has been already visited.\n+            continue;\n+          }\n+          if (outn->is_Phi()) {\n+            phi_list.push(outn);\n+            \/\/ Reached the target node\n+            continue;\n+          }\n+          assert(!has_ctrl(outn) || !has_ctrl(curr) || is_dominator(get_ctrl(curr), get_ctrl(outn)),\n+                 \"Only these nodes controlled by loop exit edge need to be cloned\");\n+          visit_list.push(outn);\n+        }\n+      }\n+\n+      \/\/ 'use' may have more than one valid \"Phi\" uses.\n+      while (phi_list.size()) {\n+        Node* main_merge_phi = phi_list.pop();\n+        const uint idx = 2;\n+        Node* last_in = main_merge_phi->in(idx);\n+        assert(main_merge_phi->in(idx) == last_in,\n+              \"The data from main loop should be the second data input of the phi node\");\n+        Node* main_merge_region = get_ctrl(main_merge_phi);\n+        assert(!loop->is_member(get_loop(main_merge_region)) &&\n+              !outer_loop->is_member(get_loop(main_merge_region)), \"\" );\n+        Node* cfg = main_merge_region->in(idx); \/\/ NOT in block of Phi itself\n+        if (cfg->is_top()) {\n+          \/\/ \"use\" is dead?\n+          _igvn.replace_input_of(main_merge_phi, idx, C->top());\n+          continue;\n+        }\n+\n+        while (!outer_loop->is_member(get_loop(cfg))) {\n+          main_merge_region = cfg;\n+          cfg = (cfg->_idx >= new_counter && cfg->is_Region()) ? cfg->in(2) : idom(cfg);\n+        }\n+\n+        \/\/ \"main_merge_phi\" merges exits from the pre-loop and the main loop.\n+        \/\/ Now we do need a new Phi here which merges \"main_merge_phi\" and data from\n+        \/\/ vectorized drain loop.\n+        Node* drain_merge_region = old_new[main_merge_region->_idx];\n+        assert(drain_merge_region, \"just made this in step 3\");\n+        \/\/ Make a new Phi merging data values properly\n+        Node* drain_new = old_new[last_in->_idx];\n+        Node* drain_merge_phi = PhiNode::make(drain_merge_region, drain_new);\n+        drain_merge_phi->set_req(2, main_merge_phi);\n+        \/\/ If inserting a new Phi, check for prior hits\n+        Node* hit = _igvn.hash_find_insert(drain_merge_phi);\n+        if (hit == nullptr) {\n+          \/\/ Register new phi\n+          _igvn.register_new_node_with_optimizer(drain_merge_phi);\n+        } else {\n+          \/\/ Remove the new phi from the graph and use the hit\n+          _igvn.remove_dead_node(drain_merge_phi);\n+          drain_merge_phi = hit;\n+        }\n+        set_ctrl(drain_merge_phi, drain_merge_region);\n+        _igvn.add_users_to_worklist(main_merge_phi);\n+\n+        \/\/ We make all uses of \"main_merge_phi\", excluding the new \"drain_merge_phi\",\n+        \/\/ use new \"drain_merge_phi\" instead.\n+        for (uint i = 0; i < main_merge_phi->outcnt(); i++) {\n+          if (main_merge_phi->raw_out(i) != drain_merge_phi) {\n+            replace_input_with_new_clone(main_merge_phi->raw_out(i), main_merge_phi, drain_merge_phi, i);\n+          }\n+        }\n+\n+        old_new.map(main_merge_phi->_idx, drain_merge_phi);\n+      }\n+    }\n+  }\n+}\n+\n@@ -2365,0 +2605,91 @@\n+\/\/ Look for the target phi node, which has 'merge_region' as control input, among all uses of node 'n'.\n+Node* PhaseIdealLoop::find_merge_phi_for_vectorized_drain(Node* n, Node* merge_region) {\n+  for (DUIterator_Fast jmax, j = n->fast_outs(jmax); j < jmax; j++) {\n+    Node* merge_phi = n->fast_out(j);\n+    if (merge_phi->is_Phi() && has_ctrl(merge_phi) && get_ctrl(merge_phi) == merge_region)\n+      return merge_phi;\n+  }\n+  return nullptr;\n+}\n+\n+\/\/ Use DFS to clone all necessary dependencies starting from the root node to support both the\n+\/\/ loop out-edge and in-edge.\n+void PhaseIdealLoop::clone_outer_nodes_helper(Node* root, uint new_counter, Node_List& old_new,\n+                                              LoopNode* head, Node_List& extra_data_nodes,\n+                                              CloneLoopMode mode) {\n+  CountedLoopNode* cl = head->as_CountedLoop();\n+  Node* sfpt = cl->outer_safepoint();\n+  Node* new_sfpt = mode == CloneIncludesStripMined ? old_new[sfpt->_idx] : nullptr;\n+  Node_Stack stack(2);\n+  stack.push(root, 1);\n+  Node* l = cl->outer_loop();\n+  IdealLoopTree* outer_loop = get_loop(l);\n+  Node* cle_out = cl->loopexit()->proj_out(false);\n+\n+  Node* main_pre_exit_region = nullptr;\n+  if (mode == InsertVectorizedDrain) {\n+    IfNode* outer_main_end = head->outer_loop_end();\n+    Node* main_exit = outer_main_end->proj_out(false);\n+    main_pre_exit_region = main_exit->unique_ctrl_out_or_null();\n+  }\n+\n+  while (stack.size() > 0) {\n+    Node* n = stack.node();\n+    uint i = stack.index();\n+    for (; i < n->req(); i++) {\n+      if (!(n->in(i) == nullptr ||\n+            !has_ctrl(n->in(i)) ||\n+            get_loop(get_ctrl(n->in(i))) != outer_loop ||\n+            (old_new[n->in(i)->_idx] != nullptr && old_new[n->in(i)->_idx]->_idx >= new_counter))) {\n+        break;\n+      }\n+      if (mode == InsertVectorizedDrain && n->in(i) != nullptr && has_ctrl(n->in(i)) &&\n+          get_ctrl(n->in(i)) == cl->skip_assertion_predicates_with_halt() &&\n+          old_new[n->in(i)->_idx] == nullptr) {\n+        \/\/ In InsertVectorizedDrain, nodes located between the outer loop entry and the zero-trip\n+        \/\/ guard entry of the main loop must be cloned separately for the vectorized drain loop\n+        \/\/ to preserve dominance correctness.\n+        \/\/ These nodes are typically loop-invariant and do not affect memory.\n+        break;\n+      }\n+    }\n+\n+    if (i < n->req()) {\n+      stack.set_index(i+1);\n+      stack.push(n->in(i), 0);\n+    } else {\n+      assert(old_new[n->_idx] == nullptr || n == sfpt || old_new[n->_idx]->_idx < new_counter, \"no clone yet\");\n+      Node* m = n == sfpt ? new_sfpt : n->clone();\n+      if (m != nullptr) {\n+        for (uint i = 0; i < n->req(); i++) {\n+          if (m->in(i) != nullptr && old_new[m->in(i)->_idx] != nullptr) {\n+            m->set_req(i, old_new[m->in(i)->_idx]);\n+          } else if (m->in(i) != nullptr && mode == InsertVectorizedDrain) {\n+            Node* old_in = m->in(i);\n+            if (has_ctrl(old_in) && get_ctrl(old_in) == l->in(LoopNode::EntryControl)) {\n+              \/\/ In InsertVectorizedDrain, these inputs may affect memory and vary across loop\n+              \/\/ iterations, and therefore need to be updated.\n+              Node* new_in = find_merge_phi_for_vectorized_drain(old_in, main_pre_exit_region);\n+              if (new_in) {\n+                m->set_req(i, new_in);\n+              }\n+            }\n+          }\n+        }\n+      } else {\n+        assert(n == sfpt && mode != CloneIncludesStripMined, \"where's the safepoint clone?\");\n+      }\n+      if (n != sfpt) {\n+        _igvn.register_new_node_with_optimizer(m);\n+        Node* n_ctrl = get_ctrl(n);\n+        if (n_ctrl == cle_out) extra_data_nodes.push(n);\n+        Node* m_ctrl = old_new[n_ctrl->_idx] == nullptr?\n+                       n_ctrl: old_new[n_ctrl->_idx];\n+        set_ctrl(m, m_ctrl);\n+        old_new.map(n->_idx, m);\n+      }\n+      stack.pop();\n+    }\n+  }\n+}\n+\n@@ -2426,3 +2757,0 @@\n-    IdealLoopTree* outer_loop = get_loop(l);\n-    Node_Stack stack(2);\n-    stack.push(sfpt, 1);\n@@ -2430,20 +2758,21 @@\n-    while (stack.size() > 0) {\n-      Node* n = stack.node();\n-      uint i = stack.index();\n-      while (i < n->req() &&\n-             (n->in(i) == nullptr ||\n-              !has_ctrl(n->in(i)) ||\n-              get_loop(get_ctrl(n->in(i))) != outer_loop ||\n-              (old_new[n->in(i)->_idx] != nullptr && old_new[n->in(i)->_idx]->_idx >= new_counter))) {\n-        i++;\n-      }\n-      if (i < n->req()) {\n-        stack.set_index(i+1);\n-        stack.push(n->in(i), 0);\n-      } else {\n-        assert(old_new[n->_idx] == nullptr || n == sfpt || old_new[n->_idx]->_idx < new_counter, \"no clone yet\");\n-        Node* m = n == sfpt ? new_sfpt : n->clone();\n-        if (m != nullptr) {\n-          for (uint i = 0; i < n->req(); i++) {\n-            if (m->in(i) != nullptr && old_new[m->in(i)->_idx] != nullptr) {\n-              m->set_req(i, old_new[m->in(i)->_idx]);\n+    \/\/ To support the loop out-edge.\n+    clone_outer_nodes_helper(sfpt, new_counter, old_new, head, extra_data_nodes, mode);\n+\n+    if (mode == CloneIncludesStripMined) {\n+      _igvn.register_new_node_with_optimizer(new_sfpt);\n+      _igvn.register_new_node_with_optimizer(new_cle_out);\n+    }\n+\n+    if (mode == InsertVectorizedDrain) {\n+      \/\/ To support the loop in-edge.\n+      for (uint i = 0; i < loop->_body.size(); i++) {\n+        Node* old = loop->_body.at(i);\n+        Node* drain_n = old_new[old->_idx];\n+        for (uint j = 1; j < old->req(); j++) {\n+          if (old->in(j) != nullptr && drain_n->in(j) == old->in(j) &&\n+              has_ctrl(old->in(j)) && get_ctrl(old->in(j)) == cl->skip_assertion_predicates_with_halt()) {\n+            if (old_new[old->in(j)->_idx] == nullptr) {\n+              clone_outer_nodes_helper(old->in(j), new_counter, old_new, head, extra_data_nodes, InsertVectorizedDrain);\n+              assert(old_new[old->in(j)->_idx], \"We must clone a new node for vectorized drain loop\");\n+            } else {\n+              assert(old_new[old->in(j)->_idx]->_idx >= new_counter, \"Must be a new cloned node\");\n@@ -2451,0 +2780,1 @@\n+            _igvn.replace_input_of(old_new[old->_idx], j, old_new[old->in(j)->_idx]);\n@@ -2452,9 +2782,0 @@\n-        } else {\n-          assert(n == sfpt && mode != CloneIncludesStripMined, \"where's the safepoint clone?\");\n-        }\n-        if (n != sfpt) {\n-          extra_data_nodes.push(n);\n-          _igvn.register_new_node_with_optimizer(m);\n-          assert(get_ctrl(n) == cle_out, \"what other control?\");\n-          set_ctrl(m, new_cle_out);\n-          old_new.map(n->_idx, m);\n@@ -2462,1 +2783,0 @@\n-        stack.pop();\n@@ -2465,4 +2785,1 @@\n-    if (mode == CloneIncludesStripMined) {\n-      _igvn.register_new_node_with_optimizer(new_sfpt);\n-      _igvn.register_new_node_with_optimizer(new_cle_out);\n-    }\n+\n@@ -2513,1 +2830,4 @@\n-\/\/ same.  All exits from the old-loop now have a RegionNode that merges the\n+\/\/ same.\n+\/\/\n+\/\/ For most modes (except InsertVectorizedDrain):\n+\/\/ All exits from the old-loop now have a RegionNode that merges the\n@@ -2515,2 +2835,10 @@\n-\/\/ condition.  All uses of loop-invariant old-loop values now come from (one\n-\/\/ or more) Phis that merge their new-loop equivalents.\n+\/\/ condition.  All uses of loop-variant old-loop values now come from\n+\/\/ (one or more) Phis that merge their new-loop equivalents.\n+\/\/\n+\/\/ For InsertVectorizedDrain mode:\n+\/\/ all control uses of exits from old-loop now should use new RegionNodes\n+\/\/ that merges RegionNode which merges exits from pre-loop and main-loop\n+\/\/ and exits from the new-loop (vectorized drain loop).All data uses of values\n+\/\/ from old-loop now should use new Phis that merges Phis which merges\n+\/\/ values from pre-loop and main-loop and values from the new-loop\n+\/\/ (vectorized drain loop) equivalents.\n@@ -2586,5 +2914,23 @@\n-  for (uint i = 0; i < extra_data_nodes.size(); i++) {\n-    Node* old = extra_data_nodes.at(i);\n-    clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,\n-                                split_bool_set, split_cex_set, worklist, new_counter,\n-                                mode);\n+  switch (mode) {\n+    case InsertVectorizedDrain:\n+      for (uint i = 0; i < extra_data_nodes.size(); i++) {\n+        Node* old = extra_data_nodes.at(i);\n+        handle_data_uses_for_vectorized_drain(old, old_new, loop, outer_loop,\n+                                              worklist, new_counter);\n+      }\n+      break;\n+\n+    case IgnoreStripMined:\n+    case CloneIncludesStripMined:\n+    case ControlAroundStripMined:\n+      for (uint i = 0; i < extra_data_nodes.size(); i++) {\n+        Node* old = extra_data_nodes.at(i);\n+        clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,\n+                                    split_bool_set, split_cex_set, worklist, new_counter,\n+                                    mode);\n+      }\n+      break;\n+\n+    default:\n+      assert(false, \"should not reach here\");\n+      break;\n@@ -2636,5 +2982,21 @@\n-  for(uint i = 0; i < body.size(); i++ ) {\n-    Node* old = body.at(i);\n-    clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set,\n-                                split_bool_set, split_cex_set, worklist, new_counter,\n-                                mode);\n+  switch (mode) {\n+    case InsertVectorizedDrain:\n+      for (uint i = 0; i < body.size(); i++) {\n+        Node* old = body.at(i);\n+        handle_data_uses_for_vectorized_drain(old, old_new, loop, outer_loop, worklist, new_counter);\n+      }\n+      break;\n+\n+    case IgnoreStripMined:\n+    case CloneIncludesStripMined:\n+    case ControlAroundStripMined:\n+      for (uint i = 0; i < body.size(); i++) {\n+        Node* old = body.at(i);\n+        clone_loop_handle_data_uses(old, old_new, loop, outer_loop, split_if_set, split_bool_set,\n+                                    split_cex_set, worklist, new_counter, mode);\n+      }\n+      break;\n+\n+    default:\n+      assert(false, \"Should not reach here.\");\n+      break;\n@@ -2695,37 +3057,12 @@\n-        \/\/ We need a Region to merge the exit from the peeled body and the\n-        \/\/ exit from the old loop body.\n-        RegionNode *r = new RegionNode(3);\n-        uint dd_r = MIN2(dom_depth(newuse), dom_depth(use));\n-        assert(dd_r >= dom_depth(dom_lca(newuse, use)), \"\" );\n-\n-        \/\/ The original user of 'use' uses 'r' instead.\n-        for (DUIterator_Last lmin, l = use->last_outs(lmin); l >= lmin;) {\n-          Node* useuse = use->last_out(l);\n-          _igvn.rehash_node_delayed(useuse);\n-          uint uses_found = 0;\n-          if (useuse->in(0) == use) {\n-            useuse->set_req(0, r);\n-            uses_found++;\n-            if (useuse->is_CFG()) {\n-              \/\/ This is not a dom_depth > dd_r because when new\n-              \/\/ control flow is constructed by a loop opt, a node and\n-              \/\/ its dominator can end up at the same dom_depth\n-              assert(dom_depth(useuse) >= dd_r, \"\");\n-              set_idom(useuse, r, dom_depth(useuse));\n-            }\n-          }\n-          for (uint k = 1; k < useuse->req(); k++) {\n-            if( useuse->in(k) == use ) {\n-              useuse->set_req(k, r);\n-              uses_found++;\n-              if (useuse->is_Loop() && k == LoopNode::EntryControl) {\n-                \/\/ This is not a dom_depth > dd_r because when new\n-                \/\/ control flow is constructed by a loop opt, a node\n-                \/\/ and its dominator can end up at the same dom_depth\n-                assert(dom_depth(useuse) >= dd_r , \"\");\n-                set_idom(useuse, r, dom_depth(useuse));\n-              }\n-            }\n-          }\n-          l -= uses_found;    \/\/ we deleted 1 or more copies of this edge\n-        }\n+        \/\/ We need to fix control uses for cloning vectorized drain loop and other loops\n+        \/\/ in different ways.\n+        switch (mode) {\n+          case InsertVectorizedDrain:\n+            fix_ctrl_uses_for_vectorized_drain(use, newuse, old_new, use_loop);\n+            break;\n+\n+          case IgnoreStripMined:\n+          case CloneIncludesStripMined:\n+          case ControlAroundStripMined:\n+            fix_ctrl_uses_for_common_loop(use, newuse, old_new, use_loop, side_by_side_idom);\n+            break;\n@@ -2733,18 +3070,4 @@\n-        assert(use->is_Proj(), \"loop exit should be projection\");\n-        \/\/ lazy_replace() below moves all nodes that are:\n-        \/\/ - control dependent on the loop exit or\n-        \/\/ - have control set to the loop exit\n-        \/\/ below the post-loop merge point. lazy_replace() takes a dead control as first input. To make it\n-        \/\/ possible to use it, the loop exit projection is cloned and becomes the new exit projection. The initial one\n-        \/\/ becomes dead and is \"replaced\" by the region.\n-        Node* use_clone = use->clone();\n-        register_control(use_clone, use_loop, idom(use), dom_depth(use));\n-        \/\/ Now finish up 'r'\n-        r->set_req(1, newuse);\n-        r->set_req(2, use_clone);\n-        _igvn.register_new_node_with_optimizer(r);\n-        set_loop(r, use_loop);\n-        set_idom(r, (side_by_side_idom == nullptr) ? newuse->in(0) : side_by_side_idom, dd_r);\n-        lazy_replace(use, r);\n-        \/\/ Map the (cloned) old use to the new merge point\n-        old_new.map(use_clone->_idx, r);\n+          default:\n+            assert(false, \"should not reach here\");\n+            break;\n+        }\n@@ -2756,0 +3079,183 @@\n+void PhaseIdealLoop::fix_ctrl_uses_for_common_loop(Node* use, Node* newuse, Node_List& old_new,\n+                                                   IdealLoopTree* use_loop, Node* side_by_side_idom) {\n+  \/\/ We need a Region to merge the exit from the peeled body and the\n+  \/\/ exit from the old loop body.\n+  RegionNode* r = new RegionNode(3);\n+  uint dd_r = MIN2(dom_depth(newuse), dom_depth(use));\n+  assert(dd_r >= dom_depth(dom_lca(newuse, use)), \"\" );\n+\n+  \/\/ The original user of 'use' uses 'r' instead.\n+  for (DUIterator_Last lmin, l = use->last_outs(lmin); l >= lmin;) {\n+    Node* useuse = use->last_out(l);\n+    _igvn.rehash_node_delayed(useuse);\n+    uint uses_found = 0;\n+    if (useuse->in(0) == use) {\n+      useuse->set_req(0, r);\n+      uses_found++;\n+      if (useuse->is_CFG()) {\n+        \/\/ This is not a dom_depth > dd_r because when new\n+        \/\/ control flow is constructed by a loop opt, a node and\n+        \/\/ its dominator can end up at the same dom_depth\n+        assert(dom_depth(useuse) >= dd_r, \"\");\n+        set_idom(useuse, r, dom_depth(useuse));\n+      }\n+    }\n+    for (uint k = 1; k < useuse->req(); k++) {\n+      if (useuse->in(k) == use) {\n+        useuse->set_req(k, r);\n+        uses_found++;\n+        if (useuse->is_Loop() && k == LoopNode::EntryControl) {\n+          \/\/ This is not a dom_depth > dd_r because when new\n+          \/\/ control flow is constructed by a loop opt, a node\n+          \/\/ and its dominator can end up at the same dom_depth\n+          assert(dom_depth(useuse) >= dd_r , \"\");\n+          set_idom(useuse, r, dom_depth(useuse));\n+        }\n+      }\n+    }\n+    l -= uses_found; \/\/ we deleted 1 or more copies of this edge\n+  }\n+\n+  assert(use->is_Proj(), \"loop exit should be projection\");\n+  \/\/ lazy_replace() below moves all nodes that are:\n+  \/\/  - control dependent on the loop exit or\n+  \/\/  - have control set to the loop exit\n+  \/\/ below the post-loop merge point. lazy_replace() takes a dead control\n+  \/\/ as first input. To make it possible to use it, the loop exit projection\n+  \/\/ is cloned and becomes the new exit projection. The initial one becomes\n+  \/\/ dead and is \"replaced\" by the region.\n+  Node* use_clone = use->clone();\n+  register_control(use_clone, use_loop, idom(use), dom_depth(use));\n+  \/\/ Now finish up 'r'\n+  r->set_req(1, newuse);\n+  r->set_req(2, use_clone);\n+  _igvn.register_new_node_with_optimizer(r);\n+  set_loop(r, use_loop);\n+  set_idom(r, (side_by_side_idom == nullptr) ? newuse->in(0) : side_by_side_idom, dd_r);\n+  lazy_replace(use, r);\n+  \/\/ Map the (cloned) old use to the new merge point\n+  old_new.map(use_clone->_idx, r);\n+}\n+\n+\/\/ After clone_loop_body() and fix_body_edges(), now the control uses of the new loop body\n+\/\/ is like:\n+\/\/ (To simplify it, we ignore the outer strip-mined loop here.)\n+\n+\/\/          pre loop exit\n+\/\/              |\n+\/\/      main zero-trip guard\n+\/\/       \/     \\\n+\/\/  IfFalse    IfTrue\n+\/\/    \/        |   \\____________________\n+\/\/   |         |                        \\\n+\/\/   |   |---> main loop head   |----> vectorized drain loop head\n+\/\/   |   |           |          |              |\n+\/\/   |  IfTrue       |        IfTrue           |\n+\/\/   |   |           |          |              |\n+\/\/   |   ---- main loop end     ------ vectorized drain loop end\n+\/\/   |         |\n+\/\/    \\      IfFalse('main_use')\n+\/\/     \\       |\n+\/\/   RegionNode ('main_merge_region')\n+\/\/              |\n+\/\/      post zero-trip guard\n+\/\/           |     \\\n+\/\/        IfFalse  IfTrue\n+\/\/           |        \\\n+\/\/           |      post loop\n+\/\/           |      \/\n+\/\/         after loop\n+\n+\/\/ 'drain_use' is cloned from 'main_use', i.e. IfFalse (main loop exit) and used as\n+\/\/ the exit of vectorized drain loop. 'main_merge_region' is the RegionNode merging\n+\/\/ the exit of main loop and the false path of zero trip guard for main loop.\n+\/\/ We create a new RegionNode, 'drain_merge_region', to merge all exit path from previous loop.\n+\/\/ Then part of the graph above becomes:\n+\n+\/\/          pre loop exit\n+\/\/              |\n+\/\/      main zero-trip guard\n+\/\/       \/     \\\n+\/\/  IfFalse    IfTrue\n+\/\/    \/        |   \\____________________\n+\/\/   |         |                        \\\n+\/\/   |   |---> main loop head   |----> vectorized drain loop head\n+\/\/   |   |           |          |              |\n+\/\/   |  IfTrue       |        IfTrue           |\n+\/\/   |   |           |          |              |\n+\/\/   |   ---- main loop end     ------ vectorized drain loop end\n+\/\/   |         |                              *|*\n+\/\/    \\      IfFalse('main_use')           IfFalse('drain_use')\n+\/\/     \\       |                             *\/*\n+\/\/   RegionNode ('main_merge_region')       *\/*\n+\/\/                               *\\*       *\/*\n+\/\/                new RegionNode ('drain_merge_region')\n+\/\/                                 |\n+\/\/                         post zero-trip guard\n+\/\/                               ...\n+\n+\/\/ After this step, the loop structure here is still not correct but all\n+\/\/ control uses of the vectorized drain loop have been fixed.\n+void PhaseIdealLoop::fix_ctrl_uses_for_vectorized_drain(Node* main_use, Node* drain_use, Node_List& old_new,\n+                                                        IdealLoopTree* use_loop) {\n+  \/\/ We need a Region to merge the exit from the cloned body(vectorized drain loop)\n+  \/\/ and the merge point of exits from the vector main-loop and pre-loop.\n+\n+  \/\/ We need to find the Region node merging exits from the vector main-loop\n+  \/\/ and pre-loop first.\n+  Node* main_merge_region = nullptr;\n+  for (DUIterator_Fast jmax, j = main_use->fast_outs(jmax); j < jmax; j++) {\n+    Node* outn = main_use->fast_out(j);\n+    if (outn->is_Region()) {\n+      assert(main_merge_region == nullptr, \"We definitely find only one valid main_merge_region\");\n+      main_merge_region = outn;\n+    }\n+  }\n+\n+  \/\/ Now we need a new Region node.\n+  RegionNode* drain_merge_region = new RegionNode(3);\n+  uint dd_r = MIN2(dom_depth(drain_use), dom_depth(main_merge_region));\n+  assert(dd_r >= dom_depth(dom_lca(drain_use, main_merge_region)), \"\");\n+  set_loop(drain_merge_region, use_loop);\n+  set_idom(drain_merge_region, drain_use->in(0), dd_r);\n+\n+  \/\/ We make all uses of \"main_merge_region\", excluding itself,\n+  \/\/ use the new Region node \"r\" instead.\n+  for (uint i = 0; i < main_merge_region->outcnt(); i++) {\n+    Node* useuse = main_merge_region->raw_out(i);\n+    if (useuse == main_merge_region || useuse->is_Phi()) {\n+      continue;\n+    }\n+    assert(useuse->is_CFG(), \"\");\n+    _igvn.rehash_node_delayed(useuse);\n+    if (useuse->in(0) == main_merge_region) {\n+      useuse->set_req(0, drain_merge_region);\n+      if (useuse->is_CFG()) {\n+        \/\/ This is not a dom_depth > dd_r because when new\n+        \/\/ control flow is constructed by a loop opt, a node and\n+        \/\/ its dominator can end up at the same dom_depth\n+        assert(dom_depth(useuse) >= dd_r, \"\");\n+        set_idom(useuse, drain_merge_region, dd_r+1);\n+      }\n+    }\n+    for (uint k = 1; k < useuse->req(); k++) {\n+      if (useuse->in(k) == main_merge_region) {\n+        useuse->set_req(k, drain_merge_region);\n+        if (useuse->is_Loop() && k == LoopNode::EntryControl) {\n+          \/\/ This is not a dom_depth > dd_r because when new\n+          \/\/ control flow is constructed by a loop opt, a node\n+          \/\/ and its dominator can end up at the same dom_depth\n+          assert(dom_depth(useuse) >= dd_r , \"\");\n+          set_idom(useuse, drain_merge_region, dom_depth(useuse));\n+        }\n+      }\n+    }\n+  }\n+\n+  drain_merge_region->set_req(1, drain_use);\n+  drain_merge_region->set_req(2, main_merge_region);\n+  _igvn.register_new_node_with_optimizer(drain_merge_region);\n+  \/\/ Map the (cloned) old use to the new merge point\n+  old_new.map(main_use->_idx, drain_merge_region);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":611,"deletions":105,"binary":false,"changes":716,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -86,0 +87,2 @@\n+  flags(BEFORE_VECTORIZED_DRAIN,        \"Before Vectorized Drain Loop\") \\\n+  flags(AFTER_VECTORIZED_DRAIN,         \"After Vectorized Drain Loop\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -97,0 +98,2 @@\n+    BEFORE_VECTORIZED_DRAIN(        \"Before Vectorized Drain Loop\"),\n+    AFTER_VECTORIZED_DRAIN(         \"After Vectorized Drain Loop\"),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -67,1 +68,3 @@\n-                  \"post .* multiversion_fast\", \"= 3\", \/\/ the second loop is vectorized, and has a vectorized post loop\n+                  \/\/ Both of loops are vectorized, and have vectorized drain post loops on platforms (<= 32 bytes).\n+                  \/\/ On platforms (> 32 bytes), the second loop is vectorized, and has a vectorized post loop\n+                  \"post .* multiversion_fast\", \"<= 4\",\n@@ -69,1 +72,2 @@\n-                  \"multiversion\",              \"= 7\", \/\/ nothing unexpected\n+                  \"multiversion\",              \">= 7\", \/\/ nothing unexpected\n+                  \"multiversion\",              \"<= 8\", \/\/ nothing unexpected\n@@ -77,1 +81,3 @@\n-                  \"post .* multiversion_fast\", \"= 3\",\n+                  \/\/ After loop-opts, we also constant fold the vectorized drain post loop of the first loop, as it is unreachable on platforms (!= 32bytes).\n+                  \/\/ But on platforms (== 32bytes), after loop-opts, the vectorized drain post loop of the first loop is reachable.\n+                  \"post .* multiversion_fast\", \"<= 4\",\n@@ -80,1 +86,1 @@\n-                  \"multiversion\",              \"<= 6\", \/\/ nothing unexpected\n+                  \"multiversion\",              \"<= 7\", \/\/ nothing unexpected\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMultiversionRemoveUselessSlowLoop.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test\n+ * @bug 8307084\n+ * @summary Test the optimization about vectorized drain loop with some testcases\n+ *          generated by fuzzer.\n+ *\n+ * @run main\/othervm -Xint compiler.loopopts.superword.TestVectorizedDrainLoop\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   compiler.loopopts.superword.TestVectorizedDrainLoop\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   compiler.loopopts.superword.TestVectorizedDrainLoop\n+ * @run main\/othervm -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=compiler.loopopts.superword.TestVectorizedDrainLoop::*\n+ *                   compiler.loopopts.superword.TestVectorizedDrainLoop\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=compiler.loopopts.superword.TestVectorizedDrainLoop::*\n+ *                   compiler.loopopts.superword.TestVectorizedDrainLoop\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+public class TestVectorizedDrainLoop {\n+\n+    public static int N = 400;\n+    public static long res_check_sum = 0;\n+    public static long long_seed = 1L;\n+    public static float float_seed = -1.303F;\n+    public static short s_array[] = new short[N];\n+    public static long l_array[] = new long[N];\n+    public static int i_array[] = new int[N];\n+    public static long shift_count = -30723L;\n+    public static float float_factor = 27.992F;\n+    public static double double_adder = 0.55984;\n+\n+    public static long checkSum(int[] a) {\n+        long sum = 0;\n+        for (int j = 0; j < a.length; j++) {\n+            sum += a[j];\n+        }\n+        return sum;\n+    }\n+\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static void test1_helper(long l) {\n+        int i3 = 1, i5 = 5, i7 = 65,\n+            i9 = 47833, iArr[] = new int[N];\n+        init(iArr, 1);\n+        for (i5 = 1; 155 > i5; ++i5) {\n+            iArr[i5 + 1] = i3;\n+        }\n+        while (--i7 > 0) {\n+            i9 -= i5;\n+        }\n+        res_check_sum = l + i3  + i5 + i9;\n+    }\n+\n+    public static void test1(String[] strArr1) {\n+        int i1 = 118;\n+        while (++i1 < 398) {\n+            test1_helper(long_seed);\n+        }\n+        if (res_check_sum != 38070) {\n+            throw new RuntimeException(\"wrong result at test1: \" + res_check_sum);\n+        }\n+    }\n+\n+    public static void test2(String[] strArr1) {\n+        int i = -18, i21 = -3, i23 = 18, i25 = -12, iArr1[] = new int[N];\n+        for (i = 14; i < 397; i++) {\n+            for (i21 = 1; i21 < 66; ++i21) {\n+                for (i23 = 2; i23 > 1; --i23) {\n+                    iArr1[i23 + 1] += i21;\n+                }\n+                for (i25 = 1; i25 < 2; ++i25) {\n+                    switch ((i % 2) + 16) {\n+                        case 16:\n+                            s_array[i21] = (short)float_seed;\n+                            l_array[i21] -= i;\n+                    }\n+                }\n+            }\n+        }\n+        long check_sum = checkSum(iArr1);\n+        if (check_sum != 821535) {\n+            throw new RuntimeException(\"wrong result at test2: \" + check_sum);\n+        }\n+    }\n+\n+    public static void test3_helper() {\n+        float f1 = 7F;\n+        int i18 = -15;\n+        for (i18 = 6; i18 < 285; ++i18) {\n+            f1 *= 8;\n+            i_array[i18 - 1] += -203;\n+        }\n+        res_check_sum = Float.floatToIntBits(f1) + i18;\n+    }\n+\n+    public static void test3(String[] strArr) {\n+        for (int i = 0; i < 10000; i++ ) {\n+            test3_helper();\n+        }\n+        if (res_check_sum != 2139095325) {\n+            throw new RuntimeException(\"wrong result at test3: \" + res_check_sum);\n+        }\n+    }\n+\n+    public static void test4_helper(int i6, long l1) {\n+        int i7 = -33872, i8 = 65468, i9 = 7, i10 = 40154, i11 = -148, iArr[] = new int[N];\n+        boolean b = true;\n+        i7 = 187;\n+        while (--i7 > 0) {\n+            iArr[i7 + 1] = 8;\n+            for (i8 = 1; i8 < 9; i8++) {\n+                i6 += (((i8 * shift_count) + float_factor) - i7);\n+                if (b) break;\n+                for (i10 = 1; i10 < 2; ++i10) {\n+                    l1 >>= shift_count;\n+                    i11 += (((i10 * float_factor) + shift_count) - i9);\n+                    double_adder += i7;\n+                    i9 += i10;\n+                    i6 += (i10 | i8);\n+                }\n+            }\n+        }\n+        res_check_sum = i6 + l1 + i7 + i8 + i9 + (b ? 1 : 0) + i10 + i11;\n+   }\n+\n+    public static void test4(String[] strArr) {\n+        int i2 = -15478;\n+        for (int i = 0; i < 10000; i++ ) {\n+            test4_helper(i2, shift_count);\n+        }\n+        if (res_check_sum != -5732847) {\n+            throw new RuntimeException(\"wrong result at test4: \" + res_check_sum);\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10; i++)\n+            test1(strArr);\n+            test2(strArr);\n+            test3(strArr);\n+            test4(strArr);\n+        }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestVectorizedDrainLoop.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 3)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+\n+public class VectorizedDrainLoopPerf {\n+    @Param({ \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",\n+             \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n+             \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n+             \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n+             \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n+             \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n+             \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n+             \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n+             \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n+             \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\",\n+             \"100\",\"101\",\"102\",\"103\",\"104\",\"105\",\"106\",\"107\",\"108\",\"109\",\n+             \"110\",\"111\",\"112\",\"113\",\"114\",\"115\",\"116\",\"117\",\"118\",\"119\",\n+             \"120\",\"121\",\"122\",\"123\",\"124\",\"125\",\"126\",\"127\",\"128\",\"129\",\n+             \"130\",\"131\",\"132\",\"133\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\n+             \"140\",\"141\",\"142\",\"143\",\"144\",\"145\",\"146\",\"147\",\"148\",\"149\",\n+             \"150\",\"151\",\"152\",\"153\",\"154\",\"155\",\"156\",\"157\",\"158\",\"159\",\n+             \"160\",\"161\",\"162\",\"163\",\"164\",\"165\",\"166\",\"167\",\"168\",\"169\",\n+             \"170\",\"171\",\"172\",\"173\",\"174\",\"175\",\"176\",\"177\",\"178\",\"179\",\n+             \"180\",\"181\",\"182\",\"183\",\"184\",\"185\",\"186\",\"187\",\"188\",\"189\",\n+             \"190\",\"191\",\"192\",\"193\",\"194\",\"195\",\"196\",\"197\",\"198\",\"199\",\n+             \"200\",\"201\",\"202\",\"203\",\"204\",\"205\",\"206\",\"207\",\"208\",\"209\",\n+             \"210\",\"211\",\"212\",\"213\",\"214\",\"215\",\"216\",\"217\",\"218\",\"219\",\n+             \"220\",\"221\",\"222\",\"223\",\"224\",\"225\",\"226\",\"227\",\"228\",\"229\",\n+             \"230\",\"231\",\"232\",\"233\",\"234\",\"235\",\"236\",\"237\",\"238\",\"239\",\n+             \"240\",\"241\",\"242\",\"243\",\"244\",\"245\",\"246\",\"247\",\"248\",\"249\",\n+             \"250\"})\n+    public int length;\n+\n+    private byte[] ba;\n+    private byte[] bb;\n+    private byte[] bc;\n+    private short[] sa;\n+    private short[] sb;\n+    private short[] sc;\n+    private int[] ia;\n+    private int[] ib;\n+    private int[] ic;\n+    private long[] la;\n+    private long[] lb;\n+    private long[] lc;\n+    private byte[] lba;\n+    private byte[] lbb;\n+    private byte[] lbc;\n+    private short[] lsa;\n+    private short[] lsb;\n+    private short[] lsc;\n+    private int[] lia;\n+    private int[] lib;\n+    private int[] lic;\n+    private long[] lla;\n+    private long[] llb;\n+    private long[] llc;\n+\n+    private Random random = new Random(0);\n+    private int SIZE = 2048;\n+    private int warm_up = 100_000;\n+\n+    \/**\n+     * Initialize. New array objects and set initial values.\n+     *\/\n+    @Setup(Level.Trial)\n+    public void init() {\n+        ba = new byte[length];\n+        bb = new byte[length];\n+        bc = new byte[length];\n+        sa = new short[length];\n+        sb = new short[length];\n+        sc = new short[length];\n+        ia = new int[length];\n+        ib = new int[length];\n+        ic = new int[length];\n+        la = new long[length];\n+        lb = new long[length];\n+        lc = new long[length];\n+\n+        for (int i = 0; i < length; i++) {\n+            ba[i] = (byte) random.nextInt();\n+            bb[i] = (byte) random.nextInt();\n+            sa[i] = (short) random.nextInt();\n+            sb[i] = (short) random.nextInt();\n+            ia[i] = random.nextInt();\n+            ib[i] = random.nextInt(length) + 1; \/\/ non zero\n+            la[i] = random.nextLong();\n+            lb[i] = random.nextLong();\n+        }\n+\n+        lba = new byte[SIZE];\n+        lbb = new byte[SIZE];\n+        lbc = new byte[SIZE];\n+        lsa = new short[SIZE];\n+        lsb = new short[SIZE];\n+        lsc = new short[SIZE];\n+        lia = new int[SIZE];\n+        lib = new int[SIZE];\n+        lic = new int[SIZE];\n+        lla = new long[SIZE];\n+        llb = new long[SIZE];\n+        llc = new long[SIZE];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            lba[i] = (byte) random.nextInt();\n+            lbb[i] = (byte) random.nextInt();\n+            lsa[i] = (short) random.nextInt();\n+            lsb[i] = (short) random.nextInt();\n+            lia[i] = random.nextInt();\n+            lib[i] = random.nextInt(SIZE) + 1; \/\/ non zero\n+            lla[i] = random.nextLong();\n+            llb[i] = random.nextLong();\n+        }\n+\n+        for (int i = 0; i < warm_up; i++) {\n+            byteadd(lba, lbb, lbc);\n+            shortadd(lsa, lsb, lsc);\n+            intadd(lia, lib, lic);\n+            longadd(lla, llb, llc);\n+        }\n+\n+    }\n+\n+    public void byteadd(byte[] ba, byte[] bb, byte[] bc) {\n+        for (int i = 0; i < ba.length; i++) {\n+            bc[i] = (byte) (ba[i] + bb[i]);\n+        }\n+    }\n+\n+    public void shortadd(short[] sa, short[] sb, short[] sc) {\n+        for (int i = 0; i < sa.length; i++) {\n+            sc[i] = (short) (sa[i] + sb[i]);\n+        }\n+    }\n+\n+    public void intadd(int[] a, int[] b, int[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    public void longadd(long[] a, long[] b, long[] c) {\n+        for (int i = 0; i < a.length; i++) {\n+            c[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void addB() {\n+        byteadd(ba, bb, bc);\n+    }\n+\n+    @Benchmark\n+    public void addS() {\n+        shortadd(sa, sb, sc);\n+    }\n+\n+    @Benchmark\n+    public void addI() {\n+        intadd(ia, ib, ic);\n+    }\n+\n+    @Benchmark\n+    public void addL() {\n+        longadd(la, lb, lc);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorizedDrainLoopPerf.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"}]}