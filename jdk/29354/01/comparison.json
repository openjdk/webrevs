{"files":[{"patch":"@@ -1,173 +0,0 @@\n-\/*\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *@test\n- *@bug 8007520\n- *@summary Test those bridge methods to\/from java.time date\/time classes\n- * @key randomness\n- *\/\n-\n-import java.util.Random;\n-import java.sql.Date;\n-import java.sql.Time;\n-import java.sql.Timestamp;\n-import java.time.Instant;\n-import java.time.LocalDateTime;\n-import java.time.LocalDate;\n-import java.time.LocalTime;\n-import java.time.ZoneId;\n-import java.time.ZoneOffset;\n-import java.time.ZonedDateTime;\n-\n-public class JavatimeTest {\n-\n-    static final int NANOS_PER_SECOND = 1000000000;\n-\n-    public static void main(String[] args) throws Throwable {\n-        int N = 10000;\n-        long t1970 = new java.util.Date(70, 0, 01).getTime();\n-        Random r = new Random();\n-        for (int i = 0; i < N; i++) {\n-            int days  = r.nextInt(50) * 365 + r.nextInt(365);\n-            long secs = t1970 + days * 86400 + r.nextInt(86400);\n-            int nanos = r.nextInt(NANOS_PER_SECOND);\n-            int nanos_ms = nanos \/ 1000000 * 1000000; \/\/ millis precision\n-            long millis = secs * 1000 + r.nextInt(1000);\n-\n-            LocalDateTime ldt = LocalDateTime.ofEpochSecond(secs, nanos, ZoneOffset.UTC);\n-            LocalDateTime ldt_ms = LocalDateTime.ofEpochSecond(secs, nanos_ms, ZoneOffset.UTC);\n-            Instant inst = Instant.ofEpochSecond(secs, nanos);\n-            Instant inst_ms = Instant.ofEpochSecond(secs, nanos_ms);\n-            \/\/System.out.printf(\"ms: %16d  ns: %10d  ldt:[%s]%n\", millis, nanos, ldt);\n-\n-            \/\/\/\/\/\/\/\/\/\/\/ Timestamp \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-            Timestamp ta = new Timestamp(millis);\n-            ta.setNanos(nanos);\n-            if (!isEqual(ta.toLocalDateTime(), ta)) {\n-                System.out.printf(\"ms: %16d  ns: %10d  ldt:[%s]%n\", millis, nanos, ldt);\n-                print(ta.toLocalDateTime(), ta);\n-                throw new RuntimeException(\"FAILED: j.s.ts -> ldt\");\n-            }\n-            if (!isEqual(ldt, Timestamp.valueOf(ldt))) {\n-                System.out.printf(\"ms: %16d  ns: %10d  ldt:[%s]%n\", millis, nanos, ldt);\n-                print(ldt, Timestamp.valueOf(ldt));\n-                throw new RuntimeException(\"FAILED: ldt -> j.s.ts\");\n-            }\n-            Instant inst0 = ta.toInstant();\n-            if (ta.getTime() != inst0.toEpochMilli() ||\n-                ta.getNanos() != inst0.getNano() ||\n-                !ta.equals(Timestamp.from(inst0))) {\n-                System.out.printf(\"ms: %16d  ns: %10d  ldt:[%s]%n\", millis, nanos, ldt);\n-                throw new RuntimeException(\"FAILED: j.s.ts -> instant -> j.s.ts\");\n-            }\n-            inst = Instant.ofEpochSecond(secs, nanos);\n-            Timestamp ta0 = Timestamp.from(inst);\n-            if (ta0.getTime() != inst.toEpochMilli() ||\n-                ta0.getNanos() != inst.getNano() ||\n-                !inst.equals(ta0.toInstant())) {\n-                System.out.printf(\"ms: %16d  ns: %10d  ldt:[%s]%n\", millis, nanos, ldt);\n-                throw new RuntimeException(\"FAILED: instant -> timestamp -> instant\");\n-            }\n-\n-            \/\/\/\/\/\/\/\/\/\/ java.sql.Date \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-            \/\/ j.s.d\/t uses j.u.d.equals() !!!!!!!!\n-            java.sql.Date jsd = new java.sql.Date(millis);\n-            if (!isEqual(jsd.toLocalDate(), jsd)) {\n-                System.out.printf(\"ms: %16d  ns: %10d  ldt:[%s]%n\", millis, nanos, ldt);\n-                print(jsd.toLocalDate(), jsd);\n-                throw new RuntimeException(\"FAILED: j.s.d -> ld\");\n-            }\n-            LocalDate ld = ldt.toLocalDate();\n-            if (!isEqual(ld, java.sql.Date.valueOf(ld))) {\n-                System.out.printf(\"ms: %16d  ns: %10d  ldt:[%s]%n\", millis, nanos, ldt);\n-                print(ld, java.sql.Date.valueOf(ld));\n-                throw new RuntimeException(\"FAILED: ld -> j.s.d\");\n-            }\n-            \/\/\/\/\/\/\/\/\/\/ java.sql.Time \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-            java.sql.Time jst = new java.sql.Time(millis);\n-            if (!isEqual(jst.toLocalTime(), jst)) {\n-                System.out.printf(\"ms: %16d  ns: %10d  ldt:[%s]%n\", millis, nanos, ldt);\n-                print(jst.toLocalTime(), jst);\n-                throw new RuntimeException(\"FAILED: j.s.t -> lt\");\n-            }\n-            \/\/ millis precision\n-            LocalTime lt = ldt_ms.toLocalTime();\n-            if (!isEqual(lt, java.sql.Time.valueOf(lt))) {\n-                System.out.printf(\"ms: %16d  ns: %10d  ldt:[%s]%n\", millis, nanos, ldt);\n-                print(lt, java.sql.Time.valueOf(lt));\n-                throw new RuntimeException(\"FAILED: lt -> j.s.t\");\n-            }\n-        }\n-        System.out.println(\"Passed!\");\n-    }\n-\n-    private static boolean isEqual(LocalDateTime ldt, Timestamp ts) {\n-        ZonedDateTime zdt = ZonedDateTime.of(ldt, ZoneId.systemDefault());\n-        return zdt.getYear() == ts.getYear() + 1900 &&\n-               zdt.getMonthValue() == ts.getMonth() + 1 &&\n-               zdt.getDayOfMonth() == ts.getDate() &&\n-               zdt.getHour() == ts.getHours() &&\n-               zdt.getMinute() == ts.getMinutes() &&\n-               zdt.getSecond() == ts.getSeconds() &&\n-               zdt.getNano() == ts.getNanos();\n-    }\n-\n-    private static void print(LocalDateTime ldt, Timestamp ts) {\n-        ZonedDateTime zdt = ZonedDateTime.of(ldt, ZoneId.systemDefault());\n-        System.out.printf(\"ldt:ts  %d\/%d, %d\/%d, %d\/%d, %d\/%d, %d\/%d, %d\/%d, nano:[%d\/%d]%n\",\n-               zdt.getYear(), ts.getYear() + 1900,\n-               zdt.getMonthValue(), ts.getMonth() + 1,\n-               zdt.getDayOfMonth(), ts.getDate(),\n-               zdt.getHour(), ts.getHours(),\n-               zdt.getMinute(), ts.getMinutes(),\n-               zdt.getSecond(), ts.getSeconds(),\n-               zdt.getNano(), ts.getNanos());\n-    }\n-\n-    private static boolean isEqual(LocalDate ld, java.sql.Date d) {\n-        return ld.getYear() == d.getYear() + 1900 &&\n-               ld.getMonthValue() == d.getMonth() + 1 &&\n-               ld.getDayOfMonth() == d.getDate();\n-    }\n-\n-    private static void print(LocalDate ld, java.sql.Date d) {\n-        System.out.printf(\"%d\/%d, %d\/%d, %d\/%d%n\",\n-               ld.getYear(), d.getYear() + 1900,\n-               ld.getMonthValue(), d.getMonth() + 1,\n-               ld.getDayOfMonth(), d.getDate());\n-    }\n-\n-    private static boolean isEqual(LocalTime lt, java.sql.Time t) {\n-        return lt.getHour() == t.getHours() &&\n-               lt.getMinute() == t.getMinutes() &&\n-               lt.getSecond() == t.getSeconds();\n-    }\n-\n-    private static void print(LocalTime lt, java.sql.Time t) {\n-        System.out.printf(\"%d\/%d, %d\/%d, %d\/%d%n\",\n-                          lt.getHour(), t.getHours(),\n-                          lt.getMinute(), t.getMinutes(),\n-                          lt.getSecond(), t.getSeconds());\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/JavatimeTest.java","additions":0,"deletions":173,"binary":false,"changes":173,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,3 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n@@ -39,1 +36,1 @@\n- * @run testng\/othervm DriverManagerModuleTests\n+ * @run junit\/othervm DriverManagerModuleTests\n@@ -49,16 +46,0 @@\n-    @BeforeClass\n-    public static void setUpClass() throws Exception {\n-    }\n-\n-    @AfterClass\n-    public static void tearDownClass() throws Exception {\n-    }\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-    }\n-\n","filename":"test\/jdk\/java\/sql\/driverModuleTests\/DriverManagerModuleTests.java","additions":5,"deletions":24,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+# JDBC unit tests uses JUnit\n+JUnit.dirs = .\n+othervm.dirs = test\/sql\/othervm\n+\n","filename":"test\/jdk\/java\/sql\/junit\/TEST.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/BatchUpdateExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/BatchUpdateExceptionTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import org.junit.jupiter.params.provider.ValueSource;\n+import util.BaseTest;\n+import util.StubConnection;\n+\n+import java.sql.CallableStatement;\n+import java.sql.SQLException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class CallableStatementTests extends BaseTest {\n+    private CallableStatement cstmt;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        cstmt = new StubConnection().prepareCall(\"{call SuperHero_Proc(?)}\");\n+    }\n+\n+    @AfterEach\n+    public void tearDownMethod() throws Exception {\n+        cstmt.close();\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedLiteralValues\")\n+    public void test00(String s, String expected) throws SQLException {\n+        assertEquals(expected, cstmt.enquoteLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteLiteral is null\n+     *\/\n+    @Test\n+    public void test01() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> cstmt.enquoteLiteral(null));\n+    }\n+\n+    \/*\n+     * Validate that enquoteIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedIdentifierValues\")\n+    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n+        assertEquals(expected, cstmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that a SQLException is thrown for values that are not valid\n+     * for a SQL identifier\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidEnquotedIdentifierValues\")\n+    public void test03(String s, boolean alwaysQuote) throws SQLException {\n+        assertThrows(SQLException.class, () -> cstmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown is the string passed to\n+     * enquoteIdentiifer is null\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @ValueSource(booleans = {true, false})\n+    public void test04(boolean alwaysQuote) throws SQLException {\n+        assertThrows(NullPointerException.class, () -> cstmt.enquoteIdentifier(null, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that isSimpleIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"simpleIdentifierValues\")\n+    public void test05(String s, boolean expected) throws SQLException {\n+        assertEquals(expected, cstmt.isSimpleIdentifier(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * isSimpleIdentifier is null\n+     *\/\n+    @Test\n+    public void test06() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> cstmt.isSimpleIdentifier(null));\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedNCharLiteralValues\")\n+    public void test07(String s, String expected) throws SQLException {\n+        assertEquals(expected, cstmt.enquoteNCharLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteNCharLiteral is null\n+     *\/\n+    @Test\n+    public void test08() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> cstmt.enquoteNCharLiteral(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/CallableStatementTests.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import org.junit.jupiter.params.provider.ValueSource;\n+import util.BaseTest;\n+import util.StubConnection;\n+\n+import java.sql.SQLException;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class ConnectionTests extends BaseTest {\n+\n+    protected StubConnection conn;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        conn = new StubConnection();\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedLiteralValues\")\n+    public void test00(String s, String expected) throws SQLException {\n+        assertEquals(expected, conn.enquoteLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteLiteral is null\n+     *\/\n+    @Test\n+    public void test01() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> conn.enquoteLiteral(null));\n+    }\n+\n+    \/*\n+     * Validate that enquoteIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedIdentifierValues\")\n+    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n+        assertEquals(expected, conn.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that a SQLException is thrown for values that are not valid\n+     * for a SQL identifier\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidEnquotedIdentifierValues\")\n+    public void test03(String s, boolean alwaysQuote) throws SQLException {\n+        assertThrows(SQLException.class, () -> conn.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown is the string passed to\n+     * enquoteIdentiifer is null\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @ValueSource(booleans = {true, false})\n+    public void test04(boolean alwaysQuote) throws SQLException {\n+        assertThrows(NullPointerException.class, () -> conn.enquoteIdentifier(null, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that isSimpleIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"simpleIdentifierValues\")\n+    public void test05(String s, boolean expected) throws SQLException {\n+        assertEquals(expected, conn.isSimpleIdentifier(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * isSimpleIdentifier is null\n+     *\/\n+    @Test\n+    public void test06() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> conn.isSimpleIdentifier(null));\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedNCharLiteralValues\")\n+    public void test07(String s, String expected) throws SQLException {\n+        assertEquals(expected, conn.enquoteNCharLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteNCharLiteral is null\n+     *\/\n+    @Test\n+    public void test08() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> conn.enquoteNCharLiteral(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/ConnectionTests.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/DataTruncationTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/DataTruncationTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import java.sql.Date;\n+import java.time.LocalDate;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import util.BaseTest;\n+\n+public class DateTests extends BaseTest {\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for an invalid Date string\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidDateValues\")\n+    public void test(String d) throws Exception {\n+        assertThrows(IllegalArgumentException.class, () -> Date.valueOf(d));\n+    }\n+\n+    \/*\n+     * Test that a date created from a date string is equal to the value\n+     * returned from toString()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validDateValues\")\n+    public void test00(String d, String expectedD) {\n+        Date d1 = Date.valueOf(d);\n+        Date d2 = Date.valueOf(expectedD);\n+        assertTrue(d1.equals(d2) && d2.equals(d1)\n+                && d1.toString().equals(expectedD), \"Error d1 != d2\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.after() returns false when same date is compared\n+     *\/\n+    @Test\n+    public void test01() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertFalse(d.after(d), \"Error d.after(d) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.after() returns true when later date is compared to\n+     * earlier date\n+     *\/\n+    @Test\n+    public void test2() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(System.currentTimeMillis());\n+        assertTrue(d2.after(d), \"Error d2.after(d) = false\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.after() returns false when earlier date is compared\n+     * to later date\n+     *\/\n+    @Test\n+    public void test3() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertFalse(d.after(d2), \"Error d.after(d2) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.after() returns false when date compared to another\n+     * date created from the original date\n+     *\/\n+    @Test\n+    public void test4() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertFalse(d.after(d2), \"Error d.after(d2) = true\");\n+        assertFalse(d2.after(d), \"Error d2.after(d) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.before() returns false when same date is compared\n+     *\/\n+    @Test\n+    public void test5() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertFalse(d.before(d), \"Error d.before(d) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.before() returns true when earlier date is compared\n+     * to later date\n+     *\/\n+    @Test\n+    public void test6() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(System.currentTimeMillis());\n+        assertTrue(d.before(d2), \"Error d.before(d2) = false\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.before() returns false when later date is compared\n+     * to earlier date\n+     *\/\n+    @Test\n+    public void test7() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertFalse(d2.before(d), \"Error d2.before(d) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.before() returns false when date compared to another\n+     * date created from the original date\n+     *\/\n+    @Test\n+    public void test8() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertFalse(d.before(d2), \"Error d.before(d2) = true\");\n+        assertFalse(d2.before(d), \"Error d2.before(d) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.compareTo returns 0 when both Date objects are the\n+     * same\n+     *\/\n+    @Test\n+    public void test9() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertTrue(d.compareTo(d) == 0, \"Error d.compareTo(d) !=0\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.compareTo returns 0 when both Date objects represent\n+     * the same date\n+     *\/\n+    @Test\n+    public void test10() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertTrue(d.compareTo(d2) == 0, \"Error d.compareTo(d2) !=0\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.compareTo returns -1 when comparing a date to a\n+     * later date\n+     *\/\n+    @Test\n+    public void test11() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(System.currentTimeMillis());\n+        assertTrue(d.compareTo(d2) == -1, \"Error d.compareTo(d2) != -1\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.compareTo returns 1 when comparing a date to an\n+     * earlier date\n+     *\/\n+    @Test\n+    public void test12() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(System.currentTimeMillis());\n+        assertTrue(d2.compareTo(d) == 1, \"Error d.compareTo(d2) != 1\");\n+    }\n+\n+    \/*\n+     * Validate that a Date made from a LocalDate are equal\n+     *\/\n+    @Test\n+    public void test13() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        LocalDate ldt = d.toLocalDate();\n+        Date d2 = Date.valueOf(ldt);\n+        assertTrue(d.equals(d2), \"Error d != d2\");\n+    }\n+\n+    \/*\n+     * Validate that a Date LocalDate value, made from a LocalDate are equal\n+     *\/\n+    @Test\n+    public void test14() {\n+        LocalDate ldt = LocalDate.now();\n+        Date d = Date.valueOf(ldt);\n+        assertTrue(ldt.equals(d.toLocalDate()),\n+                \"Error LocalDate values are not equal\");\n+    }\n+\n+    \/*\n+     * Validate an NPE occurs when a null LocalDate is passed to valueOf\n+     *\/\n+    @Test\n+    public void test15() throws Exception {\n+        LocalDate ld = null;\n+        assertThrows(NullPointerException.class, () -> Date.valueOf(ld));\n+    }\n+\n+    \/*\n+     * Validate an UnsupportedOperationException occurs when toInstant() is\n+     * called\n+     *\/\n+    @Test\n+    public void test16() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertThrows(UnsupportedOperationException.class, d::toInstant);\n+    }\n+\n+    \/*\n+     * Validate that two Date objects are equal when one is created from the\n+     * toString() of the other\n+     *\/\n+    @Test\n+    public void test17() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = Date.valueOf(d.toString());\n+        assertTrue(d.equals(d2) && d2.equals(d), \"Error d != d2\");\n+    }\n+\n+    \/*\n+     * Validate that two Date values one created using valueOf and another via a\n+     * constructor are equal\n+     *\/\n+    @Test\n+    public void test18() {\n+\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(61, 7, 30);\n+        assertTrue(d.equals(d2), \"Error d != d2\");\n+    }\n+\n+    \/*\n+     * Validate that two Date values one created using getTime() of the other\n+     * are equal\n+     *\/\n+    @Test\n+    public void test19() {\n+\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertTrue(d.equals(d2), \"Error d != d2\");\n+    }\n+\n+    \/*\n+     * Validate that a Date value is equal to itself\n+     *\/\n+    @Test\n+    public void test20() {\n+\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertTrue(d.equals(d), \"Error d != d\");\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getHours\n+     *\/\n+    @Test\n+    public void test21() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertThrows(IllegalArgumentException.class, d::getHours);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getMinutes\n+     *\/\n+    @Test\n+    public void test22() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertThrows(IllegalArgumentException.class, d::getMinutes);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getSeconds\n+     *\/\n+    @Test\n+    public void test23() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertThrows(IllegalArgumentException.class, d::getSeconds);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setHours\n+     *\/\n+    @Test\n+    public void test24() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertThrows(IllegalArgumentException.class, () -> d.setHours(8));\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setMinutes\n+     *\/\n+    @Test\n+    public void test25() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertThrows(IllegalArgumentException.class, () -> d.setMinutes(0));\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setSeconds\n+     *\/\n+    @Test\n+    public void test26() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertThrows(IllegalArgumentException.class, () -> d.setSeconds(0));\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Date which are not valid and are used\n+     * to validate that an IllegalArgumentException will be thrown from the\n+     * valueOf method\n+     *\/\n+    private Stream<String> invalidDateValues() {\n+        return Stream.of(\n+            \"20009-11-01\",\n+            \"09-11-01\",\n+            \"-11-01\",\n+            \"2009-111-01\",\n+            \"2009--01\",\n+            \"2009-13-01\",\n+            \"2009-11-011\",\n+            \"2009-11-\",\n+            \"2009-11-00\",\n+            \"2009-11-33\",\n+            \"--\",\n+            \"\",\n+            null,\n+            \"-\",\n+            \"2009\",\n+            \"2009-01\",\n+            \"---\",\n+            \"2009-13--1\",\n+            \"1900-1-0\",\n+            \"2009-01-01 10:50:01\",\n+            \"1996-12-10 12:26:19.1\",\n+            \"10:50:01\"\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Dates which are  valid and are used\n+     * to validate that an IllegalArgumentException will not be thrown from the\n+     * valueOf method and the corect value from toString() is returned\n+     *\/\n+    private Stream<Arguments> validDateValues() {\n+        return Stream.of(\n+            Arguments.of(\"2009-08-30\", \"2009-08-30\"),\n+            Arguments.of(\"2009-01-8\", \"2009-01-08\"),\n+            Arguments.of(\"2009-1-01\", \"2009-01-01\"),\n+            Arguments.of(\"2009-1-1\", \"2009-01-01\")\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/DateTests.java","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.CharArrayReader;\n+import java.io.CharArrayWriter;\n+import java.io.File;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.sql.Driver;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import util.StubDriver;\n+\n+public class DriverManagerTests {\n+\n+    private final String StubDriverURL = \"jdbc:tennis:boy\";\n+    private final String StubDriverDAURL = \"jdbc:luckydog:tennis\";\n+    private final String InvalidURL = \"jdbc:cardio:tennis\";\n+    private String[] results = {\"output\", \"more output\", \"and more\", \"the end\"};\n+    private String noOutput = \"should not find this\";\n+\n+    public DriverManagerTests() {\n+    }\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        removeAllDrivers();\n+    }\n+\n+    \/**\n+     * Utility method to remove all registered drivers\n+     *\/\n+    private static void removeAllDrivers() {\n+        java.util.Enumeration e = DriverManager.getDrivers();\n+        while (e.hasMoreElements()) {\n+            try {\n+                DriverManager.deregisterDriver((Driver) (e.nextElement()));\n+            } catch (SQLException ex) {\n+                System.out.print(ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Utility method to see if a driver is registered\n+     *\/\n+    private boolean isDriverRegistered(Driver d) {\n+        boolean foundDriver = false;\n+        java.util.Enumeration e = DriverManager.getDrivers();\n+        while (e.hasMoreElements()) {\n+            if (d == (Driver) e.nextElement()) {\n+                foundDriver = true;\n+                break;\n+            }\n+        }\n+        return foundDriver;\n+    }\n+\n+    \/**\n+     * Validate that values set using setLoginTimeout will be returned by\n+     * getLoginTimeout\n+     *\/\n+    @Test\n+    public void test() {\n+        int[] vals = {-1, 0, 5};\n+        for (int val : vals) {\n+            DriverManager.setLoginTimeout(val);\n+            assertEquals(DriverManager.getLoginTimeout(), val);\n+        }\n+    }\n+\n+    \/**\n+     * Validate that NullPointerException is thrown when null is passed to\n+     * registerDriver\n+     *\/\n+    @Test\n+    public void test1() throws Exception {\n+        Driver d = null;\n+        assertThrows(NullPointerException.class,\n+                () -> DriverManager.registerDriver(d));\n+    }\n+\n+    \/**\n+     * Validate that NullPointerException is thrown when null is passed to\n+     * registerDriver\n+     *\/\n+    @Test\n+    public void test2() throws Exception {\n+        Driver d = null;\n+        assertThrows(NullPointerException.class, () ->\n+                DriverManager.registerDriver(d, null));\n+    }\n+\n+    \/**\n+     * Validate that a null value allows for deRegisterDriver to return\n+     *\/\n+    @Test\n+    public void test3() throws Exception {\n+        DriverManager.deregisterDriver(null);\n+\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when there is no Driver to service\n+     * the URL\n+     *\/\n+    @Test\n+    public void test4() throws Exception {\n+        assertThrows(SQLException.class, () -> DriverManager.getConnection(InvalidURL));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when there is no Driver to service\n+     * the URL\n+     *\/\n+    @Test\n+    public void test5() throws Exception {\n+        assertThrows(SQLException.class, () -> DriverManager.getConnection(InvalidURL, new Properties()));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when there is no Driver to service\n+     * the URL\n+     *\/\n+    @Test\n+    public void test6() throws Exception {\n+        assertThrows(SQLException.class, () -> DriverManager.getConnection(InvalidURL, \"LuckyDog\", \"tennisanyone\"));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when null is passed for the URL\n+     *\/\n+    @Test\n+    public void test7() throws Exception {\n+        assertThrows(SQLException.class, () -> DriverManager.getConnection(null));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when null is passed for the URL\n+     *\/\n+    @Test\n+    public void test8() throws Exception {\n+        assertThrows(SQLException.class, () -> DriverManager.getConnection(null, new Properties()));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when null is passed for the URL\n+     *\/\n+    @Test\n+    public void test9() throws Exception {\n+        assertThrows(SQLException.class, () -> DriverManager.getConnection(null, \"LuckyDog\", \"tennisanyone\"));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when there is no Driver to service\n+     * the URL\n+     *\/\n+    @Test\n+    public void test10() throws Exception {\n+        assertThrows(SQLException.class, () -> DriverManager.getDriver(InvalidURL));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when null is passed for the URL\n+     *\/\n+    @Test\n+    public void test11() throws Exception {\n+        assertThrows(SQLException.class, () -> DriverManager.getDriver(null));\n+    }\n+\n+    \/**\n+     * Validate that a non-null Driver is returned by getDriver when a valid URL\n+     * is specified\n+     *\/\n+    @Test\n+    public void test12() throws Exception {\n+\n+        DriverManager.registerDriver(new StubDriver());\n+        assertTrue(DriverManager.getDriver(StubDriverURL) != null);\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when the URL is not valid for any of\n+     * the registered drivers\n+     *\/\n+    @Test\n+    public void test13() throws Exception {\n+        DriverManager.registerDriver(new StubDriver());\n+        assertThrows(SQLException.class, () -> DriverManager.getDriver(InvalidURL));\n+    }\n+\n+    \/**\n+     * Validate that a Connection object is returned when a valid URL is\n+     * specified to getConnection\n+     *\n+     *\/\n+    @Test\n+    public void test14() throws Exception {\n+\n+        DriverManager.registerDriver(new StubDriver());\n+        assertTrue(\n+                DriverManager.getConnection(StubDriverURL) != null);\n+        assertTrue(DriverManager.getConnection(StubDriverURL,\n+                \"LuckyDog\", \"tennisanyone\") != null);\n+        Properties props = new Properties();\n+        props.put(\"user\", \"LuckyDog\");\n+        props.put(\"password\", \"tennisanyone\");\n+        assertTrue(\n+                DriverManager.getConnection(StubDriverURL,\n+                        props) != null);\n+    }\n+\n+    \/**\n+     * Register a driver and make sure you find it via its URL. Deregister the\n+     * driver and validate it is not longer registered\n+     *\n+     * @throws Exception\n+     *\/\n+    @Test()\n+    public void test15() throws Exception {\n+        DriverManager.registerDriver(new StubDriver());\n+        Driver d = DriverManager.getDriver(StubDriverURL);\n+        assertTrue(d != null);\n+        assertTrue(isDriverRegistered(d));\n+        DriverManager.deregisterDriver(d);\n+        assertFalse(isDriverRegistered(d));\n+    }\n+\n+    \/**\n+     * Validate that DriverAction.release is called when a driver is registered\n+     * via registerDriver(Driver, DriverAction)\n+     *\n+     * @throws Exception\n+     *\/\n+    @Test\n+    public void test16() throws Exception {\n+        File file = new File(util.StubDriverDA.DriverActionCalled);\n+        file.delete();\n+        assertFalse(file.exists());\n+        Driver d = null;\n+        Class.forName(\"util.StubDriverDA\");\n+        d = DriverManager.getDriver(StubDriverDAURL);\n+        DriverManager.deregisterDriver(d);\n+        assertFalse(isDriverRegistered(d), \"Driver is registered\");\n+        assertTrue(file.exists());\n+    }\n+\n+    \/**\n+     * Create a PrintStream and use to send output via DriverManager.println\n+     * Validate that if you disable the stream, the output sent is not present\n+     *\/\n+    @Test\n+    public void tests17() throws Exception {\n+        ByteArrayOutputStream os = new ByteArrayOutputStream();\n+        PrintStream ps = new PrintStream(os);\n+        DriverManager.setLogStream(ps);\n+        assertTrue(DriverManager.getLogStream() == ps);\n+\n+        DriverManager.println(results[0]);\n+        DriverManager.setLogStream((PrintStream) null);\n+        assertTrue(DriverManager.getLogStream() == null);\n+        DriverManager.println(noOutput);\n+        DriverManager.setLogStream(ps);\n+        DriverManager.println(results[1]);\n+        DriverManager.println(results[2]);\n+        DriverManager.println(results[3]);\n+        DriverManager.setLogStream((PrintStream) null);\n+        DriverManager.println(noOutput);\n+\n+        \/*\n+         * Check we do not get the output when the stream is disabled\n+         *\/\n+        InputStreamReader is\n+                = new InputStreamReader(new ByteArrayInputStream(os.toByteArray()));\n+        BufferedReader reader = new BufferedReader(is);\n+        for (String result : results) {\n+            assertTrue(result.equals(reader.readLine()));\n+        }\n+    }\n+\n+    \/**\n+     * Create a PrintWriter and use it to send output via DriverManager.println\n+     * Validate that if you disable the writer, the output sent is not present\n+     *\/\n+    @Test\n+    public void tests18() throws Exception {\n+        CharArrayWriter cw = new CharArrayWriter();\n+        PrintWriter pw = new PrintWriter(cw);\n+        DriverManager.setLogWriter(pw);\n+        assertTrue(DriverManager.getLogWriter() == pw);\n+\n+        DriverManager.println(results[0]);\n+        DriverManager.setLogWriter(null);\n+        assertTrue(DriverManager.getLogWriter() == null);\n+        DriverManager.println(noOutput);\n+        DriverManager.setLogWriter(pw);\n+        DriverManager.println(results[1]);\n+        DriverManager.println(results[2]);\n+        DriverManager.println(results[3]);\n+        DriverManager.setLogWriter(null);\n+        DriverManager.println(noOutput);\n+\n+        \/*\n+         * Check we do not get the output when the stream is disabled\n+         *\/\n+        BufferedReader reader\n+                = new BufferedReader(new CharArrayReader(cw.toCharArray()));\n+        for (String result : results) {\n+            assertTrue(result.equals(reader.readLine()));\n+        }\n+    }\n+\n+    \/**\n+     * Register some driver implementations and validate that the driver\n+     * elements covered by the Enumeration obtained from\n+     * {@link DriverManager#getDrivers()} are the same as driver elements\n+     * covered by the stream obtained from {@link DriverManager#drivers()}}\n+     *\/\n+    @Test\n+    public void tests19() throws Exception {\n+        int n = 8;\n+        for (int i = 0; i < n; i++) {\n+            DriverManager.registerDriver(new StubDriver());\n+        }\n+\n+        Collection<Driver> expectedDrivers = Collections.list(DriverManager.getDrivers());\n+        assertEquals(n, expectedDrivers.size());\n+        Collection<Driver> drivers = DriverManager.drivers().collect(Collectors.toList());\n+\n+        assertEquals(expectedDrivers, drivers);\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/DriverManagerTests.java","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2013, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+\/*\n+ * @test\n+ * @bug 8007520\n+ * @summary Test those bridge methods to\/from java.time date\/time classes\n+ * @key randomness\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.FieldSource;\n+\n+import java.util.List;\n+import java.util.Random;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.LocalDate;\n+import java.time.LocalTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.stream.IntStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertAll;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class JavatimeTest {\n+\n+    private static final int NANOS_PER_SECOND = 1000000000;\n+    private static final long t1970 = new java.util.Date(70, 0, 01).getTime();\n+    private static final Random R = new Random();\n+    \/\/ Data provider contains 10,000 randomized arguments\n+    \/\/ which are used as the dates and times for the tests\n+    private static final List<Arguments> DATE_TIME_ARGS = IntStream.range(0, 10_000)\n+            .mapToObj(i -> {\n+                int days = R.nextInt(50) * 365 + R.nextInt(365);\n+                long secs = t1970 + days * 86400 + R.nextInt(86400);\n+                int nanos = R.nextInt(NANOS_PER_SECOND);\n+                int nanos_ms = nanos \/ 1000000 * 1000000; \/\/ millis precision\n+                long millis = secs * 1000 + R.nextInt(1000);\n+                LocalDateTime ldt = LocalDateTime.ofEpochSecond(secs, nanos, ZoneOffset.UTC);\n+                return Arguments.of(millis, nanos, ldt, secs, nanos_ms);\n+            }).toList();\n+\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @FieldSource(\"DATE_TIME_ARGS\")\n+    void timestampTest(long millis, int nanos, LocalDateTime ldt, long secs) {\n+        Timestamp ta = new Timestamp(millis);\n+        ta.setNanos(nanos);\n+        assertTrue(isEqual(ta.toLocalDateTime(), ta),\n+                errMsg(\"j.s.ts -> ldt\", millis, nanos, ldt, results(ta.toLocalDateTime(), ta)));\n+\n+        assertTrue(isEqual(ldt, Timestamp.valueOf(ldt)),\n+                errMsg(\"ldt -> j.s.ts\", millis, nanos, ldt, results(ldt, Timestamp.valueOf(ldt))));\n+\n+        Instant inst0 = ta.toInstant();\n+        assertAll(errMsg(\"j.s.ts -> instant -> j.s.ts\", millis, nanos, ldt),\n+                () -> assertEquals(ta.getTime(), inst0.toEpochMilli()),\n+                () -> assertEquals(ta.getNanos(), inst0.getNano()),\n+                () -> assertEquals(ta, Timestamp.from(inst0))\n+        );\n+\n+        Instant inst = Instant.ofEpochSecond(secs, nanos);\n+        Timestamp ta0 = Timestamp.from(inst);\n+        assertAll(errMsg(\"instant -> timestamp -> instant\", millis, nanos, ldt),\n+                () -> assertEquals(ta0.getTime(), inst.toEpochMilli()),\n+                () -> assertEquals(ta0.getNanos(), inst.getNano()),\n+                () -> assertEquals(inst, ta0.toInstant())\n+        );\n+    }\n+\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @FieldSource(\"DATE_TIME_ARGS\")\n+    void sqlDateTest(long millis, int nanos, LocalDateTime ldt) {\n+        \/\/ j.s.d\/t uses j.u.d.equals() !!!!!!!!\n+        java.sql.Date jsd = new java.sql.Date(millis);\n+        assertTrue(isEqual(jsd.toLocalDate(), jsd),\n+                errMsg(\"j.s.d -> ld\", millis, nanos, ldt, results(jsd.toLocalDate(), jsd)));\n+\n+        LocalDate ld = ldt.toLocalDate();\n+        assertTrue(isEqual(ld, java.sql.Date.valueOf(ld)),\n+                errMsg(\"ld -> j.s.d\", millis, nanos, ldt, results(ld, java.sql.Date.valueOf(ld))));\n+    }\n+\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @FieldSource(\"DATE_TIME_ARGS\")\n+    void sqlTimeTest(long millis, int nanos, LocalDateTime ldt, long secs, int nanos_ms) {\n+        java.sql.Time jst = new java.sql.Time(millis);\n+        assertTrue(isEqual(jst.toLocalTime(), jst),\n+                errMsg(\"j.s.t -> lt\", millis, nanos, ldt, results(jst.toLocalTime(), jst)));\n+\n+        \/\/ millis precision\n+        LocalDateTime ldt_ms = LocalDateTime.ofEpochSecond(secs, nanos_ms, ZoneOffset.UTC);\n+        LocalTime lt = ldt_ms.toLocalTime();\n+        assertTrue(isEqual(lt, java.sql.Time.valueOf(lt)),\n+                errMsg(\"lt -> j.s.t\", millis, nanos, ldt, results(lt, java.sql.Time.valueOf(lt))));\n+    }\n+\n+    private static boolean isEqual(LocalDateTime ldt, Timestamp ts) {\n+        ZonedDateTime zdt = ZonedDateTime.of(ldt, ZoneId.systemDefault());\n+        return zdt.getYear() == ts.getYear() + 1900 &&\n+               zdt.getMonthValue() == ts.getMonth() + 1 &&\n+               zdt.getDayOfMonth() == ts.getDate() &&\n+               zdt.getHour() == ts.getHours() &&\n+               zdt.getMinute() == ts.getMinutes() &&\n+               zdt.getSecond() == ts.getSeconds() &&\n+               zdt.getNano() == ts.getNanos();\n+    }\n+\n+    private static String results(LocalDateTime ldt, Timestamp ts) {\n+        ZonedDateTime zdt = ZonedDateTime.of(ldt, ZoneId.systemDefault());\n+        return \"ldt:ts  %d\/%d, %d\/%d, %d\/%d, %d\/%d, %d\/%d, %d\/%d, nano:[%d\/%d]%n\".formatted(\n+               zdt.getYear(), ts.getYear() + 1900,\n+               zdt.getMonthValue(), ts.getMonth() + 1,\n+               zdt.getDayOfMonth(), ts.getDate(),\n+               zdt.getHour(), ts.getHours(),\n+               zdt.getMinute(), ts.getMinutes(),\n+               zdt.getSecond(), ts.getSeconds(),\n+               zdt.getNano(), ts.getNanos());\n+    }\n+\n+    private static boolean isEqual(LocalDate ld, java.sql.Date d) {\n+        return ld.getYear() == d.getYear() + 1900 &&\n+               ld.getMonthValue() == d.getMonth() + 1 &&\n+               ld.getDayOfMonth() == d.getDate();\n+    }\n+\n+    private static String results(LocalDate ld, java.sql.Date d) {\n+        return \"%d\/%d, %d\/%d, %d\/%d%n\".formatted(\n+               ld.getYear(), d.getYear() + 1900,\n+               ld.getMonthValue(), d.getMonth() + 1,\n+               ld.getDayOfMonth(), d.getDate());\n+    }\n+\n+    private static boolean isEqual(LocalTime lt, java.sql.Time t) {\n+        return lt.getHour() == t.getHours() &&\n+               lt.getMinute() == t.getMinutes() &&\n+               lt.getSecond() == t.getSeconds();\n+    }\n+\n+    private static String results(LocalTime lt, java.sql.Time t) {\n+        return \"%d\/%d, %d\/%d, %d\/%d%n\".formatted(\n+                lt.getHour(), t.getHours(),\n+                lt.getMinute(), t.getMinutes(),\n+                lt.getSecond(), t.getSeconds());\n+    }\n+\n+    private static String errMsg(String testCase, long millis, int nanos,\n+                                 LocalDateTime ldt, String results) {\n+        return \"FAILED: %s%n INPUTS: ms: %16d  ns: %10d  ldt:[%s]%n ACTUAL: %s\"\n+                .formatted(testCase, millis, nanos, ldt, results);\n+    }\n+\n+    private static String errMsg(String testCase, long millis, int nanos,\n+                                 LocalDateTime ldt) {\n+        return \"FAILED: %s%n INPUTS: ms: %16d  ns: %10d  ldt:[%s]%n\"\n+                .formatted(testCase, millis, nanos, ldt);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/JavatimeTest.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import org.junit.jupiter.params.provider.ValueSource;\n+import util.BaseTest;\n+import util.StubConnection;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class PreparedStatementTests extends BaseTest {\n+\n+    private PreparedStatement pstmt;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        pstmt = new StubConnection().prepareStatement(\"Select * from foo were bar = ?\");\n+    }\n+\n+    @AfterEach\n+    public void tearDownMethod() throws Exception {\n+        pstmt.close();\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedLiteralValues\")\n+    public void test00(String s, String expected) throws SQLException {\n+        assertEquals(expected, pstmt.enquoteLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteLiteral is null\n+     *\/\n+    @Test\n+    public void test01() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> pstmt.enquoteLiteral(null));\n+    }\n+\n+    \/*\n+     * Validate that enquoteIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedIdentifierValues\")\n+    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n+        assertEquals(expected, pstmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that a SQLException is thrown for values that are not valid\n+     * for a SQL identifier\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidEnquotedIdentifierValues\")\n+    public void test03(String s, boolean alwaysQuote) throws SQLException {\n+        assertThrows(SQLException.class, () -> pstmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown is the string passed to\n+     * enquoteIdentiifer is null\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @ValueSource(booleans = {true, false})\n+    public void test04(boolean alwaysQuote) throws SQLException {\n+        assertThrows(NullPointerException.class, () -> pstmt.enquoteIdentifier(null, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that isSimpleIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"simpleIdentifierValues\")\n+    public void test05(String s, boolean expected) throws SQLException {\n+        assertEquals(expected, pstmt.isSimpleIdentifier(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * isSimpleIdentifier is null\n+     *\/\n+    @Test\n+    public void test06() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> pstmt.isSimpleIdentifier(null));\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedNCharLiteralValues\")\n+    public void test07(String s, String expected) throws SQLException {\n+        assertEquals(expected, pstmt.enquoteNCharLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteNCharLiteral is null\n+     *\/\n+    @Test\n+    public void test08() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> pstmt.enquoteNCharLiteral(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/PreparedStatementTests.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLClientInfoExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLClientInfoExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLDataExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLDataExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLFeatureNotSupportedExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLFeatureNotSupportedExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLIntegrityConstraintViolationExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLIntegrityConstraintViolationExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLInvalidAuthorizationSpecExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLInvalidAuthorizationSpecExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLNonTransientConnectionExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLNonTransientConnectionExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLNonTransientExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLNonTransientExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLRecoverableExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLRecoverableExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLSyntaxErrorExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLSyntaxErrorExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLTimeoutExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLTimeoutExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLTransactionRollbackExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLTransactionRollbackExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLTransientConnectionExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLTransientConnectionExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLTransientExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLTransientExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLWarningTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLWarningTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import org.junit.jupiter.params.provider.ValueSource;\n+import util.BaseTest;\n+import util.StubConnection;\n+\n+public class StatementTests extends BaseTest {\n+\n+    private Statement stmt;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        stmt = new StubConnection().createStatement();\n+    }\n+\n+    @AfterEach\n+    public void tearDownMethod() throws Exception {\n+        stmt.close();\n+    }\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedLiteralValues\")\n+    public void test00(String s, String expected) throws SQLException {\n+        assertEquals(expected, stmt.enquoteLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteLiteral is null\n+     *\/\n+    @Test\n+    public void test01() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> stmt.enquoteLiteral(null));\n+    }\n+\n+    \/*\n+     * Validate that enquoteIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedIdentifierValues\")\n+    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n+        assertEquals(expected, stmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that a SQLException is thrown for values that are not valid\n+     * for a SQL identifier\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidEnquotedIdentifierValues\")\n+    public void test03(String s, boolean alwaysQuote) throws SQLException {\n+        assertThrows(SQLException.class, () -> stmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown is the string passed to\n+     * enquoteIdentiifer is null\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @ValueSource(booleans = {true, false})\n+    public void test04(boolean alwaysQuote) throws SQLException {\n+        assertThrows(NullPointerException.class, () -> stmt.enquoteIdentifier(null, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that isSimpleIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"simpleIdentifierValues\")\n+    public void test05(String s, boolean expected) throws SQLException {\n+        assertEquals(expected, stmt.isSimpleIdentifier(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * isSimpleIdentifier is null\n+     *\/\n+    @Test\n+    public void test06() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> stmt.isSimpleIdentifier(null));\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validEnquotedNCharLiteralValues\")\n+    public void test07(String s, String expected) throws SQLException {\n+        assertEquals(expected, stmt.enquoteNCharLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteNCharLiteral is null\n+     *\/\n+    @Test\n+    public void test08() throws SQLException {\n+        assertThrows(NullPointerException.class, () -> stmt.enquoteNCharLiteral(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/StatementTests.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import java.sql.Time;\n+import java.time.LocalTime;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import util.BaseTest;\n+\n+public class TimeTests extends BaseTest {\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getYear\n+     *\/\n+    @Test\n+    public void test01() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertThrows(IllegalArgumentException.class, t::getYear);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getMonth\n+     *\/\n+    @Test\n+    public void test02() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertThrows(IllegalArgumentException.class, t::getMonth);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getDay\n+     *\/\n+    @Test\n+    public void test03() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertThrows(IllegalArgumentException.class, t::getDay);\n+    }\n+\n+    \/**\n+     * Validate an IllegalArgumentException is thrown for calling getDate\n+     *\/\n+    @Test\n+    public void test04() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertThrows(IllegalArgumentException.class, t::getDate);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setYear\n+     *\/\n+    @Test\n+    public void test05() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertThrows(IllegalArgumentException.class, () -> t.setYear(8));\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setMonth\n+     *\/\n+    @Test\n+    public void test06() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertThrows(IllegalArgumentException.class, () -> t.setMonth(8));\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setDate\n+     *\/\n+    @Test\n+    public void test07() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertThrows(IllegalArgumentException.class, () -> t.setDate(30));\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getDate\n+     *\/\n+    @Test\n+    public void test08() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertThrows(IllegalArgumentException.class, t::getDate);\n+    }\n+\n+    \/*\n+     * Validate that a Time made from a toLocalTime() LocalTime are equal\n+     *\/\n+    @Test\n+    public void test09() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = Time.valueOf(t.toLocalTime());\n+        assertTrue(t.equals(t2), \"Error t != t2\");\n+    }\n+\n+    \/*\n+     * Validate that a Time LocalTime value, made from a LocalTime are equal\n+     *\/\n+    @Test\n+    public void test10() {\n+        LocalTime lt = LocalTime.of(8, 30, 59);\n+        Time t = Time.valueOf(lt);\n+        System.out.println(\"lt=\" + lt + \",t=\" + t.toLocalTime());\n+        assertTrue(lt.equals(t.toLocalTime()),\n+                \"Error LocalTime values are not equal\");\n+    }\n+\n+    \/*\n+     * Validate an NPE occurs when a null LocalDate is passed to valueOf\n+     *\/\n+    @Test\n+    public void test11() throws Exception {\n+        LocalTime ld = null;\n+        assertThrows(NullPointerException.class, () -> Time.valueOf(ld));\n+    }\n+\n+    \/*\n+     * Validate an UnsupportedOperationException occurs when toInstant() is\n+     * called\n+     *\/\n+    @Test\n+    public void test12() throws Exception {\n+        Time t = new Time(System.currentTimeMillis());\n+        assertThrows(UnsupportedOperationException.class, t::toInstant);\n+    }\n+\n+    \/*\n+     * Validate that two Time objects are equal when one is created from the\n+     * toString() of the other and that the correct value is returned from\n+     * toString()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validTimeValues\")\n+    public void test13(String time, String expected) {\n+        Time t1 = Time.valueOf(time);\n+        Time t2 = Time.valueOf(t1.toString());\n+        assertTrue(t1.equals(t2) && t2.equals(t1)\n+                && t1.toString().equals(expected), \"Error t1 != t2\");\n+    }\n+\n+    \/*\n+     * Validate that two Time values one created using valueOf and another via a\n+     * constructor are equal\n+     *\/\n+    @Test\n+    public void test14() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(8, 30, 59);\n+        assertTrue(t.equals(t2) && t2.equals(t), \"Error t != t2\");\n+    }\n+\n+    \/*\n+     * Validate that two Time values one created using valueOf and another via a\n+     * constructor are equal\n+     *\/\n+    @Test\n+    public void test15() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime());\n+        assertTrue(t.equals(t2) && t2.equals(t), \"Error t != t2\");\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for an invalid Time string\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidTimeValues\")\n+    public void test16(String time) throws Exception {\n+        assertThrows(IllegalArgumentException.class, () -> Time.valueOf(time));\n+    }\n+\n+    \/*\n+     * Validate that Time.after() returns false when same date is compared\n+     *\/\n+    @Test\n+    public void test17() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertFalse(t.after(t), \"Error t.after(t) = true\");\n+    }\n+\n+    \/*\n+     * Validate that Time.after() returns true when later date is compared to\n+     * earlier date\n+     *\/\n+    @Test\n+    public void test18() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(System.currentTimeMillis());\n+        assertTrue(t2.after(t), \"Error t2.after(t) = false\");\n+    }\n+\n+    \/*\n+     * Validate that Time.after() returns false when earlier date is compared to\n+     * itself\n+     *\/\n+    @Test\n+    public void test19() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime());\n+        assertFalse(t.after(t2), \"Error t.after(t2) = true\");\n+        assertFalse(t2.after(t), \"Error t2.after(t) = true\");\n+    }\n+\n+    \/*\n+     * Validate that Time.before() returns false when same date is compared\n+     *\/\n+    @Test\n+    public void test20() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertFalse(t.before(t), \"Error t.before(t) = true\");\n+    }\n+\n+    \/*\n+     * Validate that Time.before() returns true when earlier date is compared to\n+     * later date\n+     *\/\n+    @Test\n+    public void test21() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(System.currentTimeMillis());\n+        assertTrue(t.before(t2), \"Error t.before(t2) = false\");\n+    }\n+\n+    \/*\n+     * Validate that Time.before() returns false when earlier date is compared\n+     * to itself\n+     *\/\n+    @Test\n+    public void test22() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime());\n+        assertFalse(t.before(t2), \"Error t.after(t2) = true\");\n+        assertFalse(t2.before(t), \"Error t2.after(t) = true\");\n+    }\n+\n+    \/*\n+     * Validate that Time.compareTo returns 0 when both Date objects are the\n+     * same\n+     *\/\n+    @Test\n+    public void test23() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertTrue(t.compareTo(t) == 0, \"Error t.compareTo(t) !=0\");\n+    }\n+\n+    \/*\n+     * Validate thatTime.compareTo returns 0 when both Time objects are the same\n+     *\/\n+    @Test\n+    public void test24() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime());\n+        assertTrue(t.compareTo(t2) == 0, \"Error t.compareTo(t2) !=0\");\n+    }\n+\n+    \/*\n+     * Validate that Time.compareTo returns 1 when comparing a later Time to an\n+     * earlier Time\n+     *\/\n+    @Test\n+    public void test25() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime() + 1);\n+        assertTrue(t2.compareTo(t) == 1, \"Error t2.compareTo(t) !=1\");\n+    }\n+\n+    \/*\n+     * Validate thatTime.compareTo returns 1 when comparing a later Time to an\n+     * earlier Time\n+     *\/\n+    @Test\n+    public void test26() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime() + 1);\n+        assertTrue(t.compareTo(t2) == -1, \"Error t.compareTo(t2) != -1\");\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Time values which are not valid and are used\n+     * to validate that an IllegalArgumentException will be thrown from the\n+     * valueOf method\n+     *\/\n+    private Stream<String> invalidTimeValues() {\n+        return Stream.of(\n+            \"2009-11-01 10:50:01\",\n+            \"1961-08-30 10:50:01.1\",\n+            \"1961-08-30\",\n+            \"00:00:00.\",\n+            \"10:50:0.1\",\n+            \":00:00\",\n+            \"00::00\",\n+            \"00:00:\",\n+            \"::\",\n+            \" : : \",\n+            \"0a:00:00\",\n+            \"00:bb:00\",\n+            \"00:01:cc\",\n+            \"08:10:Batman\",\n+            \"08:10:10:10\",\n+            \"08:10\",\n+            \"a:b:c\",\n+            null,\n+            \"8:\"\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Time values which are  valid and are used\n+     * to validate that an IllegalArgumentException will  not be thrown from the\n+     * valueOf method.  It also contains the expected return value from\n+     * toString()\n+     *\/\n+    private Stream<Arguments> validTimeValues() {\n+        return Stream.of(\n+            Arguments.of(\"10:50:01\", \"10:50:01\"),\n+            Arguments.of(\"01:1:1\", \"01:01:01\"),\n+            Arguments.of(\"01:01:1\", \"01:01:01\"),\n+            Arguments.of(\"1:01:1\", \"01:01:01\"),\n+            Arguments.of(\"2:02:02\", \"02:02:02\"),\n+            Arguments.of(\"2:02:2\", \"02:02:02\"),\n+            Arguments.of(\"10:50:1\", \"10:50:01\"),\n+            Arguments.of(\"00:00:00\", \"00:00:00\"),\n+            Arguments.of(\"08:30:59\", \"08:30:59\"),\n+            Arguments.of(\"9:0:1\", \"09:00:01\")\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/TimeTests.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -0,0 +1,844 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import java.sql.Date;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.Calendar;\n+import java.util.TimeZone;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import util.BaseTest;\n+\n+public class TimestampTests extends BaseTest {\n+\n+    private static TimeZone defaultTimeZone = null;\n+\n+    \/*\n+     * Need to set and use a custom TimeZone which does not\n+     * observe daylight savings time for this test.\n+     *\/\n+    @BeforeAll\n+    public static void setUpClass() throws Exception {\n+        defaultTimeZone = TimeZone.getDefault();\n+        TimeZone tzone = TimeZone.getTimeZone(\"GMT+01\");\n+        assertFalse(tzone.observesDaylightTime());\n+        TimeZone.setDefault(tzone);\n+    }\n+\n+    \/*\n+     * Conservatively reset the default time zone after test.\n+     *\/\n+    @AfterAll\n+    public static void tearDownClass() throws Exception {\n+        TimeZone.setDefault(defaultTimeZone);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for an invalid Timestamp\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidTimestampValues\")\n+    public void test(String ts) throws Exception {\n+        assertThrows(IllegalArgumentException.class, () -> Timestamp.valueOf(ts));\n+    }\n+\n+    \/*\n+     * Validate that two Timestamp are equal when the leading 0 in seconds is\n+     * omitted\n+     *\/\n+    @Test\n+    public void test01() throws Exception {\n+        String testTS = \"2009-01-01 10:50:00\";\n+        String ExpectedTS = \"2009-01-01 10:50:0\";\n+        Timestamp ts = Timestamp.valueOf(testTS);\n+        Timestamp ts2 = Timestamp.valueOf(ExpectedTS);\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate two Timestamps created from the same string are equal\n+     *\/\n+    @Test\n+    public void test02() throws Exception {\n+        String testTS = \"2009-01-01 10:50:0\";\n+        Timestamp ts = Timestamp.valueOf(testTS);\n+        Timestamp ts2 = Timestamp.valueOf(testTS);\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate that two Timestamp values one with leading 0s for month and day\n+     * equals same string without the leading 0s.\n+     *\/\n+    @Test\n+    public void test03() throws Exception {\n+        String testTS = \"2009-1-1 10:50:0\";\n+        String ExpectedTS = \"2009-01-01 10:50:0\";\n+        Timestamp ts = Timestamp.valueOf(testTS);\n+        Timestamp ts2 = Timestamp.valueOf(ExpectedTS);\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate that two Timestamp values one with leading 0s for day omitted\n+     * are equal\n+     *\/\n+    @Test\n+    public void test04() throws Exception {\n+        String testTS = \"2009-01-1 10:50:0\";\n+        String ExpectedTS = \"2009-01-01 10:50:0\";\n+        Timestamp ts = Timestamp.valueOf(testTS);\n+        Timestamp ts2 = Timestamp.valueOf(ExpectedTS);\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate that two Timestamp values one with leading 0s for month omitted\n+     * and both with leading 0s for seconds omitted are equal\n+     *\/\n+    @Test\n+    public void test05() throws Exception {\n+        String testTS = \"2009-1-01 10:50:0\";\n+        String ExpectedTS = \"2009-01-01 10:50:0\";\n+        Timestamp ts = Timestamp.valueOf(testTS);\n+        Timestamp ts2 = Timestamp.valueOf(ExpectedTS);\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate that two Timestamp values one with leading 0s for month omitted\n+     *\/\n+    @Test\n+    public void test06() throws Exception {\n+        String testTS = \"2005-1-01 10:20:50.00\";\n+        String ExpectedTS = \"2005-01-01 10:20:50.00\";\n+        Timestamp ts = Timestamp.valueOf(testTS);\n+        Timestamp ts2 = Timestamp.valueOf(ExpectedTS);\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate that two Timestamp values one created using valueOf and another\n+     * via a constructor are equal\n+     *\/\n+    @Test\n+    public void test07() {\n+\n+        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.001\");\n+        Timestamp ts2 = new Timestamp(96, 11, 13, 14, 15, 25, 1000000);\n+        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate that two Timestamp values one created using valueOf and another\n+     * via a constructor are equal\n+     *\/\n+    @Test\n+    public void test08() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.001\");\n+        Timestamp ts2 = new Timestamp(ts1.getTime());\n+        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate that two Timestamp values one created using valueOf and another\n+     * via a constructor are equal\n+     *\/\n+    @Test\n+    public void test09() {\n+\n+        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.0\");\n+        Timestamp ts2 = new Timestamp(96, 11, 13, 14, 15, 25, 0);\n+        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate that a Timestamp cannot be equal to null\n+     *\/\n+    @Test\n+    public void test10() {\n+\n+        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 14:15:25.745634\");\n+        Timestamp ts2 = null;\n+        assertFalse(ts1.equals(ts2), \"Error ts1 == null\");\n+    }\n+\n+    \/*\n+     * Validate that a Timestamp is equal to another timestamp created with the\n+     * using the same value but not equal to a Timestamp which is one day later\n+     *\/\n+    @Test\n+    public void test11() {\n+\n+        Timestamp ts1 = Timestamp.valueOf(\"1996-12-10 12:26:19.12\");\n+        Timestamp ts2 = Timestamp.valueOf(\"1996-12-10 12:26:19.12\");\n+        Timestamp ts3 = Timestamp.valueOf(\"1996-12-11 12:24:19.12\");\n+        assertTrue(ts1.equals(ts2) && ts2.equals(ts1), \"Error ts1 != ts2\");\n+        assertFalse(ts1.equals(ts3) && ts3.equals(ts1), \"Error ts1 == ts3\");\n+\n+    }\n+\n+    \/*\n+     * Validate that a Timestamp is equal to itself\n+     *\/\n+    @Test\n+    public void test12() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1996-10-15 12:26:19.12\");\n+        assertTrue(ts1.equals(ts1), \"Error ts1 != ts1\");\n+    }\n+\n+    \/*\n+     * Validate that two Timestamps are equal when one is created from the\n+     * toString() of the other\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validTimestampValues\")\n+    public void test13(String ts, String expectedTS) {\n+        Timestamp ts1 = Timestamp.valueOf(ts);\n+        Timestamp ts2 = Timestamp.valueOf(ts1.toString());\n+        assertTrue(ts1.equals(ts2) && ts2.equals(ts1)\n+                && ts1.toString().equals(expectedTS), \"Error ts1 != ts2\");\n+    }\n+\n+    \/\/ Before Tests\n+    \/*\n+     * Validate that Timestamp ts1 is before Timestamp ts2\n+     *\/\n+    @Test\n+    public void test14() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.745634\");\n+        Timestamp ts2 = Timestamp.valueOf(\"1996-12-13 15:15:25.645634\");\n+        assertTrue(ts1.before(ts2), \"Error ts1 not before ts2\");\n+    }\n+\n+    \/*\n+     * Validate that Timestamp ts1 is before Timestamp ts2\n+     *\/\n+    @Test\n+    public void test15() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 14:15:25\");\n+        Timestamp ts2 = Timestamp.valueOf(\"1999-12-13 15:15:25\");\n+        assertTrue(ts1.before(ts2), \"Error ts1 not before ts2\");\n+    }\n+\n+    \/*\n+     * Validate that Timestamp ts1 is before Timestamp ts2\n+     *\/\n+    @Test\n+    public void test16() {\n+\n+        Timestamp ts1 = Timestamp.valueOf(\"1999-12-13 14:15:25.745634\");\n+        Timestamp ts2 = Timestamp.valueOf(\"1999-11-13 15:15:25.645634\");\n+        assertFalse(ts1.before(ts2), \"Error ts1 before ts2\");\n+    }\n+\n+    \/*\n+     * Validate that a NullPointerException is thrown if a null is passed to\n+     * the before method\n+     *\/\n+    @Test\n+    public void test17() throws Exception {\n+        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.745634\");\n+        assertThrows(NullPointerException.class, () -> ts1.before(null));\n+    }\n+\n+    \/*\n+     * Validate a Timestamp cannot be before itself\n+     *\/\n+    @Test\n+    public void test18() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1999-11-10 12:26:19.3456543\");\n+        assertFalse(ts1.before(ts1), \"Error ts1 before ts1!\");\n+    }\n+\n+    \/*\n+     * Create 3 Timestamps and make sure the 1st is before the other two\n+     * Timestamps which are each greater than the one before it\n+     *\/\n+    @Test\n+    public void test19() {\n+\n+        Timestamp ts1 = new Timestamp(1234560000);\n+        Timestamp ts2 = new Timestamp(1234567000);\n+        Timestamp ts3 = new Timestamp(1234569000);\n+        assertTrue(ts1.before(ts2) && ts2.before(ts3) && ts1.before(ts3));\n+    }\n+\n+    \/*\n+     * Validate that Timestamp ts1 is not after Timestamp ts2\n+     *\/\n+    @Test\n+    public void test20() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1999-12-13 14:15:25.745634\");\n+        Timestamp ts2 = Timestamp.valueOf(\"1999-12-13 15:15:25.645634\");\n+        assertFalse(ts1.after(ts2), \"Error ts1 is after ts2\");\n+\n+    }\n+\n+    \/*\n+     * Validate that Timestamp ts1 is after Timestamp ts2\n+     *\/\n+    @Test\n+    public void test21() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.745634\");\n+        Timestamp ts2 = Timestamp.valueOf(\"1996-11-13 15:15:25.645634\");\n+        assertTrue(ts1.after(ts2), \"Error ts1 not after ts2\");\n+    }\n+\n+    \/*\n+     * Validate that a NullPointerException is thrown if a null is passed to the\n+     * after method\n+     *\/\n+    @Test\n+    public void test22() throws Exception {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        assertThrows(NullPointerException.class, () -> ts1.after(null));\n+    }\n+\n+    \/*\n+     * Validate that a Timestamp cannot be after itself\n+     *\/\n+    @Test\n+    public void test23() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1999-11-10 12:26:19.3456543\");\n+        assertFalse(ts1.after(ts1), \"Error ts1 is after itself\");\n+    }\n+\n+    \/*\n+     * Validate that a Timestamp after() works correctly with Timestamp created\n+     * using milliseconds\n+     *\/\n+    @Test\n+    public void test24() {\n+\n+        Timestamp ts1 = new Timestamp(1234568000);\n+        Timestamp ts2 = new Timestamp(1234565000);\n+        Timestamp ts3 = new Timestamp(1234562000);\n+        assertTrue(ts1.after(ts2) && ts2.after(ts3) && ts1.after(ts3));\n+    }\n+\n+    \/*\n+     * Validate compareTo returns 0 for Timestamps that are the same\n+     *\/\n+    @Test\n+    public void test25() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        Timestamp ts2 = new Timestamp(ts1.getTime());\n+        assertTrue(ts1.compareTo(ts2) == 0, \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate compareTo returns -1 for when the 1st Timestamp is earlier than\n+     * the 2nd Timestamp\n+     *\/\n+    @Test\n+    public void test26() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        Timestamp ts2 = new Timestamp(ts1.getTime() + 1000);\n+        assertTrue(ts1.compareTo(ts2) == -1, \"Error ts1 not before ts2\");\n+        assertTrue(ts2.compareTo(ts1) == 1, \"Error ts1 is not before ts2\");\n+    }\n+\n+    \/*\n+     * Validate compareTo returns 1 for when the 1st Timestamp is later than the\n+     * 2nd Timestamp\n+     *\/\n+    @Test\n+    public void test27() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        Timestamp ts2 = new Timestamp(ts1.getTime() - 1000);\n+        assertTrue(ts1.compareTo(ts2) == 1, \"Error ts1 not after ts2\");\n+        assertTrue(ts2.compareTo(ts1) == -1, \"Error ts1 not after ts2\");\n+    }\n+\n+    \/*\n+     * Validate compareTo returns 0 for Timestamps that are the same\n+     *\/\n+    @Test\n+    public void test28() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        java.util.Date ts2 = new java.util.Date(ts1.getTime());\n+        assertTrue(ts1.compareTo(ts2) == 0, \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate compareTo returns 0 for Timestamps that are the same\n+     *\/\n+    @Test\n+    public void test29() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        java.util.Date d = new java.util.Date(ts1.getTime());\n+        assertFalse(ts1.equals(d), \"Error ts1 == d\");\n+    }\n+\n+    \/*\n+     * Validate compareTo returns 0 for Timestamps that are the same\n+     *\/\n+    @Test\n+    public void test30() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        java.util.Date d = new Timestamp(ts1.getTime());\n+        assertTrue(ts1.equals(d), \"Error ts1 != d\");\n+    }\n+\n+    \/*\n+     * Validate equals returns false when a Date object is passed to equals\n+     *\/\n+    @Test\n+    public void test31() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        Date d = new Date(ts1.getTime());\n+        assertFalse(ts1.equals(d), \"Error ts1 != d\");\n+    }\n+\n+    \/*\n+     * Validate equals returns false when a Date object is passed to equals\n+     *\/\n+    @Test\n+    public void test32() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        java.util.Date d = new Date(ts1.getTime());\n+        assertFalse(ts1.equals(d), \"Error ts1 != d\");\n+    }\n+\n+    \/*\n+     * Validate equals returns false when a Time object is passed to equals\n+     *\/\n+    @Test\n+    public void test33() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        Time t1 = new Time(ts1.getTime());\n+        assertFalse(ts1.equals(t1), \"Error ts1 == t1\");\n+    }\n+\n+    \/*\n+     * Validate equals returns false when a String object is passed to equals\n+     *\/\n+    @Test\n+    public void test34() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        assertFalse(ts1.equals(\"1966-08-30 08:08:08\"), \"Error ts1 == a String\");\n+    }\n+\n+    \/*\n+     * Validate getTime() returns the same value from 2 timeStamps created by\n+     *\/\n+    @Test\n+    public void test35() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        Timestamp ts2 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        assertTrue(ts2.getTime() == ts1.getTime(),\n+                \"ts1.getTime() != ts2.getTime()\");\n+        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate getTime() returns the same value from 2 timeStamps when\n+     * setTime() is used to specify the same value for both Timestamps\n+     *\/\n+    @Test\n+    public void test36() {\n+        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n+        Timestamp ts2 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n+        ts2.setTime(ts1.getTime());\n+        assertTrue(ts2.getTime() == ts1.getTime(),\n+                \"ts1.getTime() != ts2.getTime()\");\n+        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for an invalid nanos value\n+     *\/\n+    @Test\n+    public void test38() throws Exception {\n+        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n+        assertThrows(IllegalArgumentException.class, () -> ts1.setNanos(-1));\n+\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for an invalid nanos value\n+     *\/\n+    @Test\n+    public void test39() throws Exception {\n+        int nanos = 999999999;\n+        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n+        assertThrows(IllegalArgumentException.class, () -> ts1.setNanos(nanos + 1));\n+    }\n+\n+    \/*\n+     * Validate you can set nanos to 999999999\n+     *\/\n+    @Test\n+    public void test40() throws Exception {\n+        int nanos = 999999999;\n+        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n+        ts1.setNanos(nanos);\n+        assertTrue(ts1.getNanos() == nanos, \"Error Invalid Nanos value\");\n+    }\n+\n+    \/*\n+     * Validate you can set nanos to 0\n+     *\/\n+    @Test\n+    public void test41() throws Exception {\n+        int nanos = 0;\n+        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n+        ts1.setNanos(nanos);\n+        assertTrue(ts1.getNanos() == nanos, \"Error Invalid Nanos value\");\n+    }\n+\n+    \/*\n+     * Validate that a Timestamp made from a LocalDateTime are equal\n+     *\/\n+    @Test\n+    public void test42() throws Exception {\n+        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n+        LocalDateTime ldt = ts1.toLocalDateTime();\n+        Timestamp ts2 = Timestamp.valueOf(ldt);\n+        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate that a Timestamp LocalDateTime value, made from a LocalDateTime\n+     * are equal\n+     *\/\n+    @Test\n+    public void test43() throws Exception {\n+        LocalDateTime ldt = LocalDateTime.now();\n+        Timestamp ts2 = Timestamp.valueOf(ldt);\n+        assertTrue(ldt.equals(ts2.toLocalDateTime()),\n+                \"Error LocalDateTime values are not equal\");\n+    }\n+\n+    \/*\n+     * Validate an NPE occurs when a null LocalDateTime is passed to valueOF\n+     *\/\n+    @Test\n+    public void test44() throws Exception {\n+        LocalDateTime ldt = null;\n+        assertThrows(NullPointerException.class, () -> Timestamp.valueOf(ldt));\n+    }\n+\n+    \/*\n+     * Validate that a Timestamp made from a Instant are equal\n+     *\/\n+    @Test\n+    public void test45() throws Exception {\n+        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n+        Instant instant = ts1.toInstant();\n+        Timestamp ts2 = Timestamp.from(instant);\n+        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n+    }\n+\n+    \/*\n+     * Validate that a Timestamp made from a Instant are equal\n+     *\/\n+    @Test\n+    public void test46() throws Exception {\n+        Instant instant = Instant.now();\n+        Timestamp ts2 = Timestamp.from(instant);\n+        assertTrue(instant.equals(ts2.toInstant()),\n+                \"Error Instant values do not match\");\n+    }\n+\n+    \/*\n+     * Validate an NPE occurs when a null instant is passed to from\n+     *\/\n+    @Test\n+    public void test47() throws Exception {\n+        Instant instant = null;\n+        assertThrows(NullPointerException.class, () -> Timestamp.from(instant));\n+    }\n+\n+    \/\/ Added SQE tests\n+    \/*\n+     * Create a Timestamp and a 2nd Timestamp that is 1 month earlier and\n+     * validate that it is not before or after the original Timestamp\n+     *\/\n+    @Test\n+    public void test48() {\n+        Calendar cal = Calendar.getInstance();\n+        Timestamp ts1 = new Timestamp(System.currentTimeMillis());\n+        cal.setTimeInMillis(ts1.getTime());\n+        cal.add(Calendar.MONTH, -1);\n+        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));\n+        Timestamp ts2 = new Timestamp(cal.getTimeInMillis());\n+        assertFalse(ts1.before(ts2) || ts2.after(ts1));\n+    }\n+\n+    \/*\n+     * Create two Timestamps and validate that compareTo returns 1 to indicate\n+     * the 1st Timestamp is greater than the 2nd Timestamp\n+     *\/\n+    @Test\n+    public void test49() {\n+        Calendar cal = Calendar.getInstance();\n+        Timestamp ts1 = new Timestamp(System.currentTimeMillis());\n+        cal.setTimeInMillis(ts1.getTime());\n+        cal.add(Calendar.MONTH, -1);\n+        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));\n+        Timestamp ts2 = new Timestamp(cal.getTimeInMillis());\n+        assertTrue(ts1.compareTo(ts2) == 1);\n+    }\n+\n+    \/*\n+     * Create two Timestamps and validate that the 1st Timestamp is not equal to\n+     * the 2nd Timestamp but equal to itself\n+     *\/\n+    @Test\n+    public void test50() {\n+        Calendar cal = Calendar.getInstance();\n+        Timestamp ts1 = new Timestamp(System.currentTimeMillis());\n+        cal.setTimeInMillis(ts1.getTime());\n+        cal.add(Calendar.MONTH, -1);\n+        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));\n+        Timestamp ts2 = new Timestamp(cal.getTimeInMillis());\n+        assertTrue(!ts1.equals(ts2) && ts1.equals(ts1));\n+    }\n+\n+    \/*\n+     * Validate that two Timestamps are equal when one is created from the\n+     * toString() of the other\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validateNanos\")\n+    public void test51(String ts, int nanos) {\n+        Timestamp ts1 = Timestamp.valueOf(ts);\n+        Timestamp ts2 = Timestamp.valueOf(ts1.toString());\n+        assertTrue(ts1.getNanos() == nanos && ts1.equals(ts2),\n+                \"Error with Nanos\");\n+    }\n+\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validTimestampLongValues\")\n+    public void test52(long value, String ts) {\n+        Timestamp ts1 = new Timestamp(value);\n+        assertEquals(ts, ts1.toString(), \"ts1.toString() != ts\");\n+    }\n+\n+    @Test\n+    public void test53() {\n+        \/\/ The latest Instant that can be converted to a Timestamp.\n+        Instant instant1 = Instant.ofEpochSecond(Long.MAX_VALUE \/ 1000, 999_999_999);\n+        assertEquals(instant1, Timestamp.from(instant1).toInstant());\n+\n+        \/\/ One nanosecond more, and converting it gets an overflow.\n+        Instant instant2 = instant1.plusNanos(1);\n+        assertThrows(IllegalArgumentException.class, () -> Timestamp.from(instant2));\n+\n+        \/\/ The earliest Instant that can be converted to a Timestamp.\n+        Instant instant3 = Instant.ofEpochSecond(Long.MIN_VALUE \/ 1000, 0);\n+        assertEquals(instant3, Timestamp.from(instant3).toInstant());\n+\n+        \/\/ One nanosecond less, and converting it gets an overflow.\n+        Instant instant4 = instant3.minusNanos(1);\n+        assertThrows(IllegalArgumentException.class, () -> Timestamp.from(instant4));\n+\n+        \/\/ The latest possible Instant will certainly overflow.\n+        assertThrows(IllegalArgumentException.class, () -> Timestamp.from(Instant.MAX));\n+\n+        \/\/ The earliest possible Instant will certainly overflow.\n+        assertThrows(IllegalArgumentException.class, () -> Timestamp.from(Instant.MIN));\n+    }\n+\n+    \/*\n+     * Validate that two Timestamp hashCode values are equal when\n+     * the Timestamp values match, including the nanos.\n+     *\/\n+    @Test\n+    public void test54() {\n+        long t = System.currentTimeMillis();\n+        Timestamp ts1 = new Timestamp(t);\n+        Timestamp ts2 = new Timestamp(t);\n+        ts1.setNanos(123456789);\n+        ts2.setNanos(123456789);\n+        assertTrue(ts1.equals(ts1));\n+        assertTrue(ts2.equals(ts2));\n+        assertTrue(ts1.equals(ts2));\n+        \/\/ As the Timestamp values, including the nanos are the same, the hashCode's\n+        \/\/ should be equal\n+        assertEquals(ts2.hashCode(), ts1.hashCode());\n+    }\n+\n+    \/*\n+     * Validate that two Timestamp hashCode values are not equal when only\n+     * the nanos value for the Timestamp differ.\n+     *\/\n+    @Test\n+    public void test55() {\n+        long t = System.currentTimeMillis();\n+        Timestamp ts1 = new Timestamp(t);\n+        Timestamp ts2 = new Timestamp(t);\n+        \/\/ Modify the nanos so that the Timestamp values differ\n+        ts1.setNanos(123456789);\n+        ts2.setNanos(987654321);\n+        assertTrue(ts1.equals(ts1));\n+        assertTrue(ts2.equals(ts2));\n+        assertFalse(ts1.equals(ts2));\n+        \/\/ As the nanos differ, the hashCode values should differ\n+        assertNotEquals(ts2.hashCode(), ts1.hashCode());\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Timestamps which are not valid and are used\n+     * to validate that an IllegalArgumentException will be thrown from the\n+     * valueOf method\n+     *\/\n+    private Stream<String> invalidTimestampValues() {\n+        return Stream.of(\n+            \"2009-11-01-01 10:50:01\",\n+            \"aaaa-11-01-01 10:50\",\n+            \"aaaa-11-01 10:50\",\n+            \"1961--30 00:00:00\",\n+            \"--30 00:00:00\",\n+            \"-- 00:00:00\",\n+            \"1961-1- 00:00:00\",\n+            \"2009-11-01\",\n+            \"10:50:01\",\n+            \"1961-a-30 00:00:00\",\n+            \"1961-01-bb 00:00:00\",\n+            \"1961-08-30 00:00:00.\",\n+            \"1961-08-30 :00:00\",\n+            \"1961-08-30 00::00\",\n+            \"1961-08-30 00:00:\",\n+            \"1961-08-30 ::\",\n+            \"1961-08-30 0a:00:00\",\n+            \"1961-08-30 00:bb:00\",\n+            \"1961-08-30 00:01:cc\",\n+            \"1961-08-30 00:00:00.01a\",\n+            \"1961-08-30 00:00:00.a\",\n+            \"1996-12-10 12:26:19.1234567890\",\n+            null\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Timestamps which are  valid and are used\n+     * to validate that an IllegalArgumentException will not be thrown from the\n+     * valueOf method and the corect value from toString() is returned\n+     *\/\n+    private Stream<Arguments> validTimestampValues() {\n+        return Stream.of(\n+            Arguments.of(\"1961-08-30 00:00:00\", \"1961-08-30 00:00:00.0\"),\n+            Arguments.of(\"1961-08-30 11:22:33\", \"1961-08-30 11:22:33.0\"),\n+            Arguments.of(\"1961-8-30 00:00:00\", \"1961-08-30 00:00:00.0\"),\n+            Arguments.of(\"1966-08-1 00:00:00\", \"1966-08-01 00:00:00.0\"),\n+            Arguments.of(\"1996-12-10 12:26:19.1\", \"1996-12-10 12:26:19.1\"),\n+            Arguments.of(\"1996-12-10 12:26:19.12\", \"1996-12-10 12:26:19.12\"),\n+            Arguments.of(\"1996-12-10 12:26:19.123\", \"1996-12-10 12:26:19.123\"),\n+            Arguments.of(\"1996-12-10 12:26:19.1234\", \"1996-12-10 12:26:19.1234\"),\n+            Arguments.of(\"1996-12-10 12:26:19.12345\", \"1996-12-10 12:26:19.12345\"),\n+            Arguments.of(\"1996-12-10 12:26:19.123456\", \"1996-12-10 12:26:19.123456\"),\n+            Arguments.of(\"1996-12-10 12:26:19.1234567\", \"1996-12-10 12:26:19.1234567\"),\n+            Arguments.of(\"1996-12-10 12:26:19.12345678\", \"1996-12-10 12:26:19.12345678\"),\n+            Arguments.of(\"1996-12-10 12:26:19.123456789\", \"1996-12-10 12:26:19.123456789\"),\n+            Arguments.of(\"1996-12-10 12:26:19.000000001\", \"1996-12-10 12:26:19.000000001\"),\n+            Arguments.of(\"1996-12-10 12:26:19.000000012\", \"1996-12-10 12:26:19.000000012\"),\n+            Arguments.of(\"1996-12-10 12:26:19.000000123\", \"1996-12-10 12:26:19.000000123\"),\n+            Arguments.of(\"1996-12-10 12:26:19.000001234\", \"1996-12-10 12:26:19.000001234\"),\n+            Arguments.of(\"1996-12-10 12:26:19.000012345\", \"1996-12-10 12:26:19.000012345\"),\n+            Arguments.of(\"1996-12-10 12:26:19.000123456\", \"1996-12-10 12:26:19.000123456\"),\n+            Arguments.of(\"1996-12-10 12:26:19.001234567\", \"1996-12-10 12:26:19.001234567\"),\n+            Arguments.of(\"1996-12-10 12:26:19.12345678\", \"1996-12-10 12:26:19.12345678\"),\n+            Arguments.of(\"1996-12-10 12:26:19.0\", \"1996-12-10 12:26:19.0\"),\n+            Arguments.of(\"1996-12-10 12:26:19.01230\", \"1996-12-10 12:26:19.0123\")\n+        );\n+    }\n+\n+    private Stream<Arguments> validTimestampLongValues() {\n+        return Stream.of(\n+            Arguments.of(1L, \"1970-01-01 01:00:00.001\"),\n+            Arguments.of(-3600*1000L - 1, \"1969-12-31 23:59:59.999\"),\n+            Arguments.of(-(20000L*365*24*60*60*1000), \"18018-08-28 01:00:00.0\"),\n+            Arguments.of(Timestamp.valueOf(\"1961-08-30 11:22:33\").getTime(), \"1961-08-30 11:22:33.0\"),\n+            Arguments.of(Timestamp.valueOf(\"1961-08-30 11:22:33.54321000\").getTime(), \"1961-08-30 11:22:33.543\"), \/\/ nanoprecision lost\n+            Arguments.of(new Timestamp(114, 10, 10, 10, 10, 10, 100000000).getTime(), \"2014-11-10 10:10:10.1\"),\n+            Arguments.of(new Timestamp(0, 10, 10, 10, 10, 10, 100000).getTime(), \"1900-11-10 10:10:10.0\"), \/\/ nanoprecision lost\n+            Arguments.of(new Date(114, 10, 10).getTime(), \"2014-11-10 00:00:00.0\"),\n+            Arguments.of(new Date(0, 10, 10).getTime(), \"1900-11-10 00:00:00.0\"),\n+            Arguments.of(LocalDateTime.of(1960, 10, 10, 10, 10, 10, 50000).atZone(ZoneId.of(\"America\/Los_Angeles\"))\n+                .toInstant().toEpochMilli(), \"1960-10-10 19:10:10.0\"),\n+\n+            \/\/ millisecond timestamps wraps around at year 1, so Long.MIN_VALUE looks similar\n+            \/\/ Long.MAX_VALUE, while actually representing 292278994 BCE\n+            Arguments.of(Long.MIN_VALUE, \"292278994-08-17 08:12:55.192\"),\n+            Arguments.of(Long.MAX_VALUE + 1, \"292278994-08-17 08:12:55.192\"),\n+            Arguments.of(Long.MAX_VALUE, \"292278994-08-17 08:12:55.807\"),\n+            Arguments.of(Long.MIN_VALUE - 1, \"292278994-08-17 08:12:55.807\"),\n+\n+            \/\/ wrap around point near 0001-01-01, test that we never get a negative year:\n+            Arguments.of(-(1970L*365*24*60*60*1000), \"0001-04-25 01:00:00.0\"),\n+            Arguments.of(-(1970L*365*24*60*60*1000 + 115*24*60*60*1000L), \"0001-12-31 01:00:00.0\"),\n+            Arguments.of(-(1970L*365*24*60*60*1000 + 115*24*60*60*1000L - 23*60*60*1000L), \"0001-01-01 00:00:00.0\"),\n+\n+            Arguments.of(LocalDateTime.of(0, 1, 1, 10, 10, 10, 50000).atZone(ZoneId.of(\"America\/Los_Angeles\"))\n+                .toInstant().toEpochMilli() - 2*24*60*60*1000L, \"0001-01-01 19:03:08.0\"), \/\/ 1 BCE\n+            Arguments.of(LocalDateTime.of(0, 1, 1, 10, 10, 10, 50000).atZone(ZoneId.of(\"America\/Los_Angeles\"))\n+                .toInstant().toEpochMilli() - 3*24*60*60*1000L, \"0002-12-31 19:03:08.0\") \/\/ 2 BCE\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Timestamp and Nanos values in order to\n+     * validate that the correct Nanos value is generated from the specified\n+     * Timestamp\n+     *\/\n+    private Stream<Arguments> validateNanos() {\n+        return Stream.of(\n+            Arguments.of(\"1961-08-30 00:00:00\", 0),\n+            Arguments.of(\"1996-12-10 12:26:19.1\", 100000000),\n+            Arguments.of(\"1996-12-10 12:26:19.12\", 120000000),\n+            Arguments.of(\"1996-12-10 12:26:19.123\", 123000000),\n+            Arguments.of(\"1996-12-10 12:26:19.1234\", 123400000),\n+            Arguments.of(\"1996-12-10 12:26:19.12345\", 123450000),\n+            Arguments.of(\"1996-12-10 12:26:19.123456\", 123456000),\n+            Arguments.of(\"1996-12-10 12:26:19.1234567\", 123456700),\n+            Arguments.of(\"1996-12-10 12:26:19.12345678\", 123456780),\n+            Arguments.of(\"1996-12-10 12:26:19.123456789\", 123456789),\n+            Arguments.of(\"1996-12-10 12:26:19.000000001\", 1),\n+            Arguments.of(\"1996-12-10 12:26:19.000000012\", 12),\n+            Arguments.of(\"1996-12-10 12:26:19.000000123\", 123),\n+            Arguments.of(\"1996-12-10 12:26:19.000001234\", 1234),\n+            Arguments.of(\"1996-12-10 12:26:19.000012345\", 12345),\n+            Arguments.of(\"1996-12-10 12:26:19.000123456\", 123456),\n+            Arguments.of(\"1996-12-10 12:26:19.001234567\", 1234567),\n+            Arguments.of(\"1996-12-10 12:26:19.012345678\", 12345678),\n+            Arguments.of(\"1996-12-10 12:26:19.0\", 0),\n+            Arguments.of(\"1996-12-10 12:26:19.01230\", 12300000)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/TimestampTests.java","additions":844,"deletions":0,"binary":false,"changes":844,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/othervm\/DriverManagerInitTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/othervm\/DriverManagerInitTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package util;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.sql.JDBCType;\n+import java.sql.SQLException;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class BaseTest {\n+\n+    protected final String reason = \"reason\";\n+    protected final String state = \"SQLState\";\n+    protected final String cause = \"java.lang.Throwable: cause\";\n+    protected final Throwable t = new Throwable(\"cause\");\n+    protected final Throwable t1 = new Throwable(\"cause 1\");\n+    protected final Throwable t2 = new Throwable(\"cause 2\");\n+    protected final int errorCode = 21;\n+    protected final String[] msgs = {\"Exception 1\", \"cause 1\", \"Exception 2\",\n+        \"Exception 3\", \"cause 2\"};\n+    private static final String MAX_LENGTH_IDENTIFIER = \"a\".repeat(128);\n+\n+    \/*\n+     * Take some form of SQLException, serialize and deserialize it\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T extends SQLException> T\n+            createSerializedException(T ex)\n+            throws IOException, ClassNotFoundException {\n+        return (T) serializeDeserializeObject(ex);\n+    }\n+\n+    \/*\n+     * Utility method to serialize and deserialize an object\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T serializeDeserializeObject(T o)\n+            throws IOException, ClassNotFoundException {\n+        T o1;\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            oos.writeObject(o);\n+        }\n+        try (ObjectInputStream ois\n+                = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()))) {\n+            o1 = (T) ois.readObject();\n+        }\n+        return o1;\n+    }\n+\n+    \/*\n+     * DataProvider used to specify the standard JDBC Types\n+     *\/\n+    protected Stream<Integer> jdbcTypes() {\n+        return Stream.of(JDBCType.values()).map(JDBCType::getVendorTypeNumber);\n+    }\n+\n+    \/*\n+     * DataProvider used to provide strings that will be used to validate\n+     * that enquoteLiteral converts a string to a literal and every instance of\n+     * a single quote will be converted into two single quotes in the literal.\n+     *\/\n+    protected Stream<Arguments> validEnquotedLiteralValues() {\n+        return Stream.of(\n+                Arguments.of(\"Hello\", \"'Hello'\"),\n+                Arguments.of(\"G'Day\", \"'G''Day'\"),\n+                Arguments.of(\"'G''Day'\", \"'''G''''Day'''\"),\n+                Arguments.of(\"I'''M\", \"'I''''''M'\"),\n+                Arguments.of(\"The Dark Knight\", \"'The Dark Knight'\")\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to provide strings that will be used to validate\n+     * that enqouteIdentifier returns a simple SQL Identifier or a\n+     * quoted identifier\n+     *\/\n+    protected Stream<Arguments> validEnquotedIdentifierValues() {\n+        return Stream.of(\n+                Arguments.of(\"b\", false, \"b\"),\n+                Arguments.of(\"b\", true, \"\\\"b\\\"\"),\n+                Arguments.of(MAX_LENGTH_IDENTIFIER, false, MAX_LENGTH_IDENTIFIER),\n+                Arguments.of(MAX_LENGTH_IDENTIFIER, true, \"\\\"\" + MAX_LENGTH_IDENTIFIER + \"\\\"\"),\n+                Arguments.of(\"Hello\", false, \"Hello\"),\n+                Arguments.of(\"Hello\", true, \"\\\"Hello\\\"\"),\n+                Arguments.of(\"G'Day\", false, \"\\\"G'Day\\\"\"),\n+                Arguments.of(\"G'Day\", true, \"\\\"G'Day\\\"\"),\n+                Arguments.of(\"Bruce Wayne\", false, \"\\\"Bruce Wayne\\\"\"),\n+                Arguments.of(\"Bruce Wayne\", true, \"\\\"Bruce Wayne\\\"\"),\n+                Arguments.of(\"select\", false, \"\\\"select\\\"\"),\n+                Arguments.of(\"table\", true, \"\\\"table\\\"\"),\n+                Arguments.of(\"GoodDay$\", false, \"\\\"GoodDay$\\\"\"),\n+                Arguments.of(\"GoodDay$\", true, \"\\\"GoodDay$\\\"\")\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to provide strings are invalid for enquoteIdentifier\n+     * resulting in a SQLException being thrown\n+     *\/\n+    protected Stream<Arguments> invalidEnquotedIdentifierValues() {\n+        return Stream.of(\n+                Arguments.of(\"Hel\\\"lo\", false),\n+                Arguments.of(\"\\\"Hel\\\"lo\\\"\", true),\n+                Arguments.of(\"Hello\" + '\\0', false),\n+                Arguments.of(\"\", false),\n+                Arguments.of(MAX_LENGTH_IDENTIFIER + 'a', false)\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to provide strings that will be used to validate\n+     * that isSimpleIdentifier returns the correct value based on the\n+     * identifier specified.\n+     *\/\n+    protected Stream<Arguments> simpleIdentifierValues() {\n+        return Stream.of(\n+                Arguments.of(\"b\", true),\n+                Arguments.of(\"Hello\", true),\n+                Arguments.of(\"\\\"Gotham\\\"\", false),\n+                Arguments.of(\"G'Day\", false),\n+                Arguments.of(\"Bruce Wayne\", false),\n+                Arguments.of(\"GoodDay$\", false),\n+                Arguments.of(\"Dick_Grayson\", true),\n+                Arguments.of(\"Batmobile1966\", true),\n+                Arguments.of(MAX_LENGTH_IDENTIFIER, true),\n+                Arguments.of(MAX_LENGTH_IDENTIFIER + 'a', false),\n+                Arguments.of(\"\", false),\n+                Arguments.of(\"select\", false)\n+            );\n+    }\n+\n+    \/*\n+     * DataProvider used to provide strings that will be used to validate\n+     * that enquoteNCharLiteral converts a string to a National Character\n+     * literal and every instance of\n+     * a single quote will be converted into two single quotes in the literal.\n+     *\/\n+    protected Stream<Arguments> validEnquotedNCharLiteralValues() {\n+        return Stream.of(\n+                Arguments.of(\"Hello\", \"N'Hello'\"),\n+                Arguments.of(\"G'Day\", \"N'G''Day'\"),\n+                Arguments.of(\"'G''Day'\", \"N'''G''''Day'''\"),\n+                Arguments.of(\"I'''M\", \"N'I''''''M'\"),\n+                Arguments.of(\"N'Hello'\", \"N'N''Hello'''\"),\n+                Arguments.of(\"The Dark Knight\", \"N'The Dark Knight'\")\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/util\/BaseTest.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/DriverActionImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/DriverActionImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/SerializedBatchUpdateException.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/SerializedBatchUpdateException.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubCallableStatement.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubCallableStatement.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubConnection.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubDatabaseMetaData.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubDatabaseMetaData.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubDriver.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubDriver.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubDriverDA.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubDriverDA.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubPreparedStatement.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubPreparedStatement.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubStatement.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubStatement.java","status":"renamed"},{"patch":"@@ -1,4 +0,0 @@\n-# JDBC unit tests uses TestNG\n-TestNG.dirs = .\n-othervm.dirs = test\/sql\/othervm\n-\n","filename":"test\/jdk\/java\/sql\/testng\/TEST.properties","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubConnection;\n-\n-import java.sql.CallableStatement;\n-import java.sql.SQLException;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class CallableStatementTests extends BaseTest {\n-    private CallableStatement cstmt;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        cstmt = new StubConnection().prepareCall(\"{call SuperHero_Proc(?)}\");\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-        cstmt.close();\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedLiteralValues\")\n-    public void test00(String s, String expected) throws SQLException {\n-        assertEquals(cstmt.enquoteLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test01() throws SQLException {\n-        cstmt.enquoteLiteral(null);\n-    }\n-\n-    \/*\n-     * Validate that enquoteIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"validIdentifierValues\")\n-    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n-        assertEquals(cstmt.enquoteIdentifier(s, alwaysQuote), expected);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException is thrown for values that are not valid\n-     * for a SQL identifier\n-     *\/\n-    @Test(dataProvider = \"invalidIdentifierValues\",\n-            expectedExceptions = SQLException.class)\n-    public void test03(String s, boolean alwaysQuote) throws SQLException {\n-        cstmt.enquoteIdentifier(s, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown is the string passed to\n-     * enquoteIdentiifer is null\n-     *\/\n-    @Test(dataProvider = \"trueFalse\",\n-            expectedExceptions = NullPointerException.class)\n-    public void test04(boolean alwaysQuote) throws SQLException {\n-        cstmt.enquoteIdentifier(null, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate that isSimpleIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"simpleIdentifierValues\")\n-    public void test05(String s, boolean expected) throws SQLException {\n-        assertEquals(cstmt.isSimpleIdentifier(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * isSimpleIdentifier is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test06() throws SQLException {\n-        cstmt.isSimpleIdentifier(null);\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedNCharLiteralValues\")\n-    public void test07(String s, String expected) throws SQLException {\n-        assertEquals(cstmt.enquoteNCharLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteNCharLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test08() throws SQLException {\n-        cstmt.enquoteNCharLiteral(null);\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/CallableStatementTests.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubConnection;\n-\n-import java.sql.SQLException;\n-\n-import static org.testng.Assert.*;\n-\n-public class ConnectionTests extends BaseTest {\n-\n-    protected StubConnection conn;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        conn = new StubConnection();\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedLiteralValues\")\n-    public void test00(String s, String expected) throws SQLException {\n-        assertEquals(conn.enquoteLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test01() throws SQLException {\n-        conn.enquoteLiteral(null);\n-    }\n-\n-    \/*\n-     * Validate that enquoteIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"validIdentifierValues\")\n-    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n-        assertEquals(conn.enquoteIdentifier(s, alwaysQuote), expected);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException is thrown for values that are not valid\n-     * for a SQL identifier\n-     *\/\n-    @Test(dataProvider = \"invalidIdentifierValues\",\n-            expectedExceptions = SQLException.class)\n-    public void test03(String s, boolean alwaysQuote) throws SQLException {\n-        conn.enquoteIdentifier(s, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown is the string passed to\n-     * enquoteIdentiifer is null\n-     *\/\n-    @Test(dataProvider = \"trueFalse\",\n-            expectedExceptions = NullPointerException.class)\n-    public void test04(boolean alwaysQuote) throws SQLException {\n-        conn.enquoteIdentifier(null, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate that isSimpleIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"simpleIdentifierValues\")\n-    public void test05(String s, boolean expected) throws SQLException {\n-        assertEquals(conn.isSimpleIdentifier(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * isSimpleIdentifier is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test06() throws SQLException {\n-        conn.isSimpleIdentifier(null);\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedNCharLiteralValues\")\n-    public void test07(String s, String expected) throws SQLException {\n-        assertEquals(conn.enquoteNCharLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteNCharLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test08() throws SQLException {\n-        conn.enquoteNCharLiteral(null);\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/ConnectionTests.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,373 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import java.sql.Date;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-\n-public class DateTests extends BaseTest {\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for an invalid Date string\n-     *\/\n-    @Test(dataProvider = \"invalidDateValues\",\n-            expectedExceptions = IllegalArgumentException.class)\n-    public void test(String d) throws Exception {\n-        Date.valueOf(d);\n-    }\n-\n-    \/*\n-     * Test that a date created from a date string is equal to the value\n-     * returned from toString()\n-     *\/\n-    @Test(dataProvider = \"validDateValues\")\n-    public void test00(String d, String expectedD) {\n-        Date d1 = Date.valueOf(d);\n-        Date d2 = Date.valueOf(expectedD);\n-        assertTrue(d1.equals(d2) && d2.equals(d1)\n-                && d1.toString().equals(expectedD), \"Error d1 != d2\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.after() returns false when same date is compared\n-     *\/\n-    @Test\n-    public void test01() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        assertFalse(d.after(d), \"Error d.after(d) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.after() returns true when later date is compared to\n-     * earlier date\n-     *\/\n-    @Test\n-    public void test2() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(System.currentTimeMillis());\n-        assertTrue(d2.after(d), \"Error d2.after(d) = false\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.after() returns false when earlier date is compared\n-     * to later date\n-     *\/\n-    @Test\n-    public void test3() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertFalse(d.after(d2), \"Error d.after(d2) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.after() returns false when date compared to another\n-     * date created from the original date\n-     *\/\n-    @Test\n-    public void test4() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertFalse(d.after(d2), \"Error d.after(d2) = true\");\n-        assertFalse(d2.after(d), \"Error d2.after(d) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.before() returns false when same date is compared\n-     *\/\n-    @Test\n-    public void test5() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        assertFalse(d.before(d), \"Error d.before(d) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.before() returns true when earlier date is compared\n-     * to later date\n-     *\/\n-    @Test\n-    public void test6() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(System.currentTimeMillis());\n-        assertTrue(d.before(d2), \"Error d.before(d2) = false\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.before() returns false when later date is compared\n-     * to earlier date\n-     *\/\n-    @Test\n-    public void test7() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertFalse(d2.before(d), \"Error d2.before(d) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.before() returns false when date compared to another\n-     * date created from the original date\n-     *\/\n-    @Test\n-    public void test8() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertFalse(d.before(d2), \"Error d.before(d2) = true\");\n-        assertFalse(d2.before(d), \"Error d2.before(d) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.compareTo returns 0 when both Date objects are the\n-     * same\n-     *\/\n-    @Test\n-    public void test9() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        assertTrue(d.compareTo(d) == 0, \"Error d.compareTo(d) !=0\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.compareTo returns 0 when both Date objects represent\n-     * the same date\n-     *\/\n-    @Test\n-    public void test10() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertTrue(d.compareTo(d2) == 0, \"Error d.compareTo(d2) !=0\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.compareTo returns -1 when comparing a date to a\n-     * later date\n-     *\/\n-    @Test\n-    public void test11() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(System.currentTimeMillis());\n-        assertTrue(d.compareTo(d2) == -1, \"Error d.compareTo(d2) != -1\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.compareTo returns 1 when comparing a date to an\n-     * earlier date\n-     *\/\n-    @Test\n-    public void test12() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(System.currentTimeMillis());\n-        assertTrue(d2.compareTo(d) == 1, \"Error d.compareTo(d2) != 1\");\n-    }\n-\n-    \/*\n-     * Validate that a Date made from a LocalDate are equal\n-     *\/\n-    @Test\n-    public void test13() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        LocalDate ldt = d.toLocalDate();\n-        Date d2 = Date.valueOf(ldt);\n-        assertTrue(d.equals(d2), \"Error d != d2\");\n-    }\n-\n-    \/*\n-     * Validate that a Date LocalDate value, made from a LocalDate are equal\n-     *\/\n-    @Test\n-    public void test14() {\n-        LocalDate ldt = LocalDate.now();\n-        Date d = Date.valueOf(ldt);\n-        assertTrue(ldt.equals(d.toLocalDate()),\n-                \"Error LocalDate values are not equal\");\n-    }\n-\n-    \/*\n-     * Validate an NPE occurs when a null LocalDate is passed to valueOf\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test15() throws Exception {\n-        LocalDate ld = null;\n-        Date.valueOf(ld);\n-    }\n-\n-    \/*\n-     * Validate an UnsupportedOperationException occurs when toInstant() is\n-     * called\n-     *\/\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void test16() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Instant instant = d.toInstant();\n-    }\n-\n-    \/*\n-     * Validate that two Date objects are equal when one is created from the\n-     * toString() of the other\n-     *\/\n-    @Test\n-    public void test17() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = Date.valueOf(d.toString());\n-        assertTrue(d.equals(d2) && d2.equals(d), \"Error d != d2\");\n-    }\n-\n-    \/*\n-     * Validate that two Date values one created using valueOf and another via a\n-     * constructor are equal\n-     *\/\n-    @Test\n-    public void test18() {\n-\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(61, 7, 30);\n-        assertTrue(d.equals(d2), \"Error d != d2\");\n-    }\n-\n-    \/*\n-     * Validate that two Date values one created using getTime() of the other\n-     * are equal\n-     *\/\n-    @Test\n-    public void test19() {\n-\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertTrue(d.equals(d2), \"Error d != d2\");\n-    }\n-\n-    \/*\n-     * Validate that a Date value is equal to itself\n-     *\/\n-    @Test\n-    public void test20() {\n-\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        assertTrue(d.equals(d), \"Error d != d\");\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getHours\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test21() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.getHours();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getMinutes\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test22() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.getMinutes();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getSeconds\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test23() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.getSeconds();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setHours\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test24() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.setHours(8);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setMinutes\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test25() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.setMinutes(0);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setSeconds\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test26() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.setSeconds(0);\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Date which are not valid and are used\n-     * to validate that an IllegalArgumentException will be thrown from the\n-     * valueOf method\n-     *\/\n-    @DataProvider(name = \"invalidDateValues\")\n-    private Object[][] invalidDateValues() {\n-        return new Object[][]{\n-            {\"20009-11-01\"},\n-            {\"09-11-01\"},\n-            {\"-11-01\"},\n-            {\"2009-111-01\"},\n-            {\"2009--01\"},\n-            {\"2009-13-01\"},\n-            {\"2009-11-011\"},\n-            {\"2009-11-\"},\n-            {\"2009-11-00\"},\n-            {\"2009-11-33\"},\n-            {\"--\"},\n-            {\"\"},\n-            {null},\n-            {\"-\"},\n-            {\"2009\"},\n-            {\"2009-01\"},\n-            {\"---\"},\n-            {\"2009-13--1\"},\n-            {\"1900-1-0\"},\n-            {\"2009-01-01 10:50:01\"},\n-            {\"1996-12-10 12:26:19.1\"},\n-            {\"10:50:01\"}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Dates which are  valid and are used\n-     * to validate that an IllegalArgumentException will not be thrown from the\n-     * valueOf method and the corect value from toString() is returned\n-     *\/\n-    @DataProvider(name = \"validDateValues\")\n-    private Object[][] validDateValues() {\n-        return new Object[][]{\n-            {\"2009-08-30\", \"2009-08-30\"},\n-            {\"2009-01-8\", \"2009-01-08\"},\n-            {\"2009-1-01\", \"2009-01-01\"},\n-            {\"2009-1-1\", \"2009-01-01\"}\n-\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/DateTests.java","additions":0,"deletions":373,"binary":false,"changes":373,"status":"deleted"},{"patch":"@@ -1,378 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import java.io.BufferedReader;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.CharArrayReader;\n-import java.io.CharArrayWriter;\n-import java.io.File;\n-import java.io.InputStreamReader;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n-import java.sql.Driver;\n-import java.sql.DriverManager;\n-import java.sql.SQLException;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Properties;\n-import java.util.stream.Collectors;\n-\n-import static org.testng.Assert.*;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import util.StubDriver;\n-\n-public class DriverManagerTests {\n-\n-    private final String StubDriverURL = \"jdbc:tennis:boy\";\n-    private final String StubDriverDAURL = \"jdbc:luckydog:tennis\";\n-    private final String InvalidURL = \"jdbc:cardio:tennis\";\n-    private String[] results = {\"output\", \"more output\", \"and more\", \"the end\"};\n-    private String noOutput = \"should not find this\";\n-\n-    public DriverManagerTests() {\n-    }\n-\n-    @BeforeClass\n-    public static void setUpClass() throws Exception {\n-    }\n-\n-    @AfterClass\n-    public static void tearDownClass() throws Exception {\n-    }\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        removeAllDrivers();\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-    }\n-\n-    \/**\n-     * Utility method to remove all registered drivers\n-     *\/\n-    private static void removeAllDrivers() {\n-        java.util.Enumeration e = DriverManager.getDrivers();\n-        while (e.hasMoreElements()) {\n-            try {\n-                DriverManager.deregisterDriver((Driver) (e.nextElement()));\n-            } catch (SQLException ex) {\n-                System.out.print(ex.getMessage());\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Utility method to see if a driver is registered\n-     *\/\n-    private boolean isDriverRegistered(Driver d) {\n-        boolean foundDriver = false;\n-        java.util.Enumeration e = DriverManager.getDrivers();\n-        while (e.hasMoreElements()) {\n-            if (d == (Driver) e.nextElement()) {\n-                foundDriver = true;\n-                break;\n-            }\n-        }\n-        return foundDriver;\n-    }\n-\n-    \/**\n-     * Validate that values set using setLoginTimeout will be returned by\n-     * getLoginTimeout\n-     *\/\n-    @Test\n-    public void test() {\n-        int[] vals = {-1, 0, 5};\n-        for (int val : vals) {\n-            DriverManager.setLoginTimeout(val);\n-            assertEquals(val, DriverManager.getLoginTimeout());\n-        }\n-    }\n-\n-    \/**\n-     * Validate that NullPointerException is thrown when null is passed to\n-     * registerDriver\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test1() throws Exception {\n-        Driver d = null;\n-        DriverManager.registerDriver(d);\n-    }\n-\n-    \/**\n-     * Validate that NullPointerException is thrown when null is passed to\n-     * registerDriver\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test2() throws Exception {\n-        Driver d = null;\n-        DriverManager.registerDriver(d, null);\n-    }\n-\n-    \/**\n-     * Validate that a null value allows for deRegisterDriver to return\n-     *\/\n-    @Test\n-    public void test3() throws Exception {\n-        DriverManager.deregisterDriver(null);\n-\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when there is no Driver to service\n-     * the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test4() throws Exception {\n-        DriverManager.getConnection(InvalidURL);\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when there is no Driver to service\n-     * the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test5() throws Exception {\n-        DriverManager.getConnection(InvalidURL, new Properties());\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when there is no Driver to service\n-     * the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test6() throws Exception {\n-        DriverManager.getConnection(InvalidURL, \"LuckyDog\", \"tennisanyone\");\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when null is passed for the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test7() throws Exception {\n-        DriverManager.getConnection(null);\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when null is passed for the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test8() throws Exception {\n-        DriverManager.getConnection(null, new Properties());\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when null is passed for the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test9() throws Exception {\n-        DriverManager.getConnection(null, \"LuckyDog\", \"tennisanyone\");\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when there is no Driver to service\n-     * the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test10() throws Exception {\n-        DriverManager.getDriver(InvalidURL);\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when null is passed for the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test11() throws Exception {\n-        DriverManager.getDriver(null);\n-    }\n-\n-    \/**\n-     * Validate that a non-null Driver is returned by getDriver when a valid URL\n-     * is specified\n-     *\/\n-    @Test\n-    public void test12() throws Exception {\n-\n-        DriverManager.registerDriver(new StubDriver());\n-        assertTrue(DriverManager.getDriver(StubDriverURL) != null);\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when the URL is not valid for any of\n-     * the registered drivers\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test13() throws Exception {\n-        DriverManager.registerDriver(new StubDriver());\n-        DriverManager.getDriver(InvalidURL);\n-    }\n-\n-    \/**\n-     * Validate that a Connection object is returned when a valid URL is\n-     * specified to getConnection\n-     *\n-     *\/\n-    @Test\n-    public void test14() throws Exception {\n-\n-        DriverManager.registerDriver(new StubDriver());\n-        assertTrue(\n-                DriverManager.getConnection(StubDriverURL) != null);\n-        assertTrue(DriverManager.getConnection(StubDriverURL,\n-                \"LuckyDog\", \"tennisanyone\") != null);\n-        Properties props = new Properties();\n-        props.put(\"user\", \"LuckyDog\");\n-        props.put(\"password\", \"tennisanyone\");\n-        assertTrue(\n-                DriverManager.getConnection(StubDriverURL,\n-                        props) != null);\n-    }\n-\n-    \/**\n-     * Register a driver and make sure you find it via its URL. Deregister the\n-     * driver and validate it is not longer registered\n-     *\n-     * @throws Exception\n-     *\/\n-    @Test()\n-    public void test15() throws Exception {\n-        DriverManager.registerDriver(new StubDriver());\n-        Driver d = DriverManager.getDriver(StubDriverURL);\n-        assertTrue(d != null);\n-        assertTrue(isDriverRegistered(d));\n-        DriverManager.deregisterDriver(d);\n-        assertFalse(isDriverRegistered(d));\n-    }\n-\n-    \/**\n-     * Validate that DriverAction.release is called when a driver is registered\n-     * via registerDriver(Driver, DriverAction)\n-     *\n-     * @throws Exception\n-     *\/\n-    @Test\n-    public void test16() throws Exception {\n-        File file = new File(util.StubDriverDA.DriverActionCalled);\n-        file.delete();\n-        assertFalse(file.exists());\n-        Driver d = null;\n-        Class.forName(\"util.StubDriverDA\");\n-        d = DriverManager.getDriver(StubDriverDAURL);\n-        DriverManager.deregisterDriver(d);\n-        assertFalse(isDriverRegistered(d), \"Driver is registered\");\n-        assertTrue(file.exists());\n-    }\n-\n-    \/**\n-     * Create a PrintStream and use to send output via DriverManager.println\n-     * Validate that if you disable the stream, the output sent is not present\n-     *\/\n-    @Test\n-    public void tests17() throws Exception {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream();\n-        PrintStream ps = new PrintStream(os);\n-        DriverManager.setLogStream(ps);\n-        assertTrue(DriverManager.getLogStream() == ps);\n-\n-        DriverManager.println(results[0]);\n-        DriverManager.setLogStream((PrintStream) null);\n-        assertTrue(DriverManager.getLogStream() == null);\n-        DriverManager.println(noOutput);\n-        DriverManager.setLogStream(ps);\n-        DriverManager.println(results[1]);\n-        DriverManager.println(results[2]);\n-        DriverManager.println(results[3]);\n-        DriverManager.setLogStream((PrintStream) null);\n-        DriverManager.println(noOutput);\n-\n-        \/*\n-         * Check we do not get the output when the stream is disabled\n-         *\/\n-        InputStreamReader is\n-                = new InputStreamReader(new ByteArrayInputStream(os.toByteArray()));\n-        BufferedReader reader = new BufferedReader(is);\n-        for (String result : results) {\n-            assertTrue(result.equals(reader.readLine()));\n-        }\n-    }\n-\n-    \/**\n-     * Create a PrintWriter and use it to send output via DriverManager.println\n-     * Validate that if you disable the writer, the output sent is not present\n-     *\/\n-    @Test\n-    public void tests18() throws Exception {\n-        CharArrayWriter cw = new CharArrayWriter();\n-        PrintWriter pw = new PrintWriter(cw);\n-        DriverManager.setLogWriter(pw);\n-        assertTrue(DriverManager.getLogWriter() == pw);\n-\n-        DriverManager.println(results[0]);\n-        DriverManager.setLogWriter(null);\n-        assertTrue(DriverManager.getLogWriter() == null);\n-        DriverManager.println(noOutput);\n-        DriverManager.setLogWriter(pw);\n-        DriverManager.println(results[1]);\n-        DriverManager.println(results[2]);\n-        DriverManager.println(results[3]);\n-        DriverManager.setLogWriter(null);\n-        DriverManager.println(noOutput);\n-\n-        \/*\n-         * Check we do not get the output when the stream is disabled\n-         *\/\n-        BufferedReader reader\n-                = new BufferedReader(new CharArrayReader(cw.toCharArray()));\n-        for (String result : results) {\n-            assertTrue(result.equals(reader.readLine()));\n-        }\n-    }\n-\n-    \/**\n-     * Register some driver implementations and validate that the driver\n-     * elements covered by the Enumeration obtained from\n-     * {@link DriverManager#getDrivers()} are the same as driver elements\n-     * covered by the stream obtained from {@link DriverManager#drivers()}}\n-     *\/\n-    @Test\n-    public void tests19() throws Exception {\n-        int n = 8;\n-        for (int i = 0; i < n; i++) {\n-            DriverManager.registerDriver(new StubDriver());\n-        }\n-\n-        Collection<Driver> expectedDrivers = Collections.list(DriverManager.getDrivers());\n-        assertEquals(expectedDrivers.size(), n);\n-        Collection<Driver> drivers = DriverManager.drivers().collect(Collectors.toList());\n-\n-        assertEquals(drivers, expectedDrivers);\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/DriverManagerTests.java","additions":0,"deletions":378,"binary":false,"changes":378,"status":"deleted"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubConnection;\n-\n-import java.sql.PreparedStatement;\n-import java.sql.SQLException;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class PreparedStatementTests extends BaseTest {\n-\n-    private PreparedStatement pstmt;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        pstmt = new StubConnection().prepareStatement(\"Select * from foo were bar = ?\");\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-        pstmt.close();\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedLiteralValues\")\n-    public void test00(String s, String expected) throws SQLException {\n-        assertEquals(pstmt.enquoteLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test01() throws SQLException {\n-        pstmt.enquoteLiteral(null);\n-    }\n-\n-    \/*\n-     * Validate that enquoteIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"validIdentifierValues\")\n-    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n-        assertEquals(pstmt.enquoteIdentifier(s, alwaysQuote), expected);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException is thrown for values that are not valid\n-     * for a SQL identifier\n-     *\/\n-    @Test(dataProvider = \"invalidIdentifierValues\",\n-            expectedExceptions = SQLException.class)\n-    public void test03(String s, boolean alwaysQuote) throws SQLException {\n-        pstmt.enquoteIdentifier(s, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown is the string passed to\n-     * enquoteIdentiifer is null\n-     *\/\n-    @Test(dataProvider = \"trueFalse\",\n-            expectedExceptions = NullPointerException.class)\n-    public void test04(boolean alwaysQuote) throws SQLException {\n-        pstmt.enquoteIdentifier(null, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate that isSimpleIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"simpleIdentifierValues\")\n-    public void test05(String s, boolean expected) throws SQLException {\n-        assertEquals(pstmt.isSimpleIdentifier(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * isSimpleIdentifier is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test06() throws SQLException {\n-        pstmt.isSimpleIdentifier(null);\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedNCharLiteralValues\")\n-    public void test07(String s, String expected) throws SQLException {\n-        assertEquals(pstmt.enquoteNCharLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteNCharLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test08() throws SQLException {\n-        pstmt.enquoteNCharLiteral(null);\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/PreparedStatementTests.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import java.sql.SQLException;\n-import java.sql.Statement;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-import org.testng.annotations.*;\n-import util.BaseTest;\n-import util.StubConnection;\n-\n-public class StatementTests extends BaseTest {\n-\n-    private Statement stmt;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        stmt = new StubConnection().createStatement();\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-        stmt.close();\n-    }\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedLiteralValues\")\n-    public void test00(String s, String expected) throws SQLException {\n-        assertEquals(stmt.enquoteLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test01() throws SQLException {\n-        stmt.enquoteLiteral(null);\n-    }\n-\n-    \/*\n-     * Validate that enquoteIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"validIdentifierValues\")\n-    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n-        assertEquals(stmt.enquoteIdentifier(s, alwaysQuote), expected);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException is thrown for values that are not valid\n-     * for a SQL identifier\n-     *\/\n-    @Test(dataProvider = \"invalidIdentifierValues\",\n-            expectedExceptions = SQLException.class)\n-    public void test03(String s, boolean alwaysQuote) throws SQLException {\n-        stmt.enquoteIdentifier(s, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown is the string passed to\n-     * enquoteIdentiifer is null\n-     *\/\n-    @Test(dataProvider = \"trueFalse\",\n-            expectedExceptions = NullPointerException.class)\n-    public void test04(boolean alwaysQuote) throws SQLException {\n-        stmt.enquoteIdentifier(null, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate that isSimpleIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"simpleIdentifierValues\")\n-    public void test05(String s, boolean expected) throws SQLException {\n-        assertEquals(stmt.isSimpleIdentifier(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * isSimpleIdentifier is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test06() throws SQLException {\n-        stmt.isSimpleIdentifier(null);\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedNCharLiteralValues\")\n-    public void test07(String s, String expected) throws SQLException {\n-        assertEquals(stmt.enquoteNCharLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteNCharLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test08() throws SQLException {\n-        stmt.enquoteNCharLiteral(null);\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/StatementTests.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,348 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import java.sql.Time;\n-import java.time.LocalTime;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-\n-public class TimeTests extends BaseTest {\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getYear\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test01() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.getYear();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getMonth\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test02() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.getMonth();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getDay\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test03() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.getDay();\n-    }\n-\n-    \/**\n-     * Validate an IllegalArgumentException is thrown for calling getDate\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test04() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.getDate();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setYear\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test05() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.setYear(8);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setMonth\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test06() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.setMonth(8);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setDate\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test07() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.setDate(30);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getDate\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test08() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.getDate();\n-    }\n-\n-    \/*\n-     * Validate that a Time made from a toLocalTime() LocalTime are equal\n-     *\/\n-    @Test\n-    public void test09() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = Time.valueOf(t.toLocalTime());\n-        assertTrue(t.equals(t2), \"Error t != t2\");\n-    }\n-\n-    \/*\n-     * Validate that a Time LocalTime value, made from a LocalTime are equal\n-     *\/\n-    @Test\n-    public void test10() {\n-        LocalTime lt = LocalTime.of(8, 30, 59);\n-        Time t = Time.valueOf(lt);\n-        System.out.println(\"lt=\" + lt + \",t=\" + t.toLocalTime());\n-        assertTrue(lt.equals(t.toLocalTime()),\n-                \"Error LocalTime values are not equal\");\n-    }\n-\n-    \/*\n-     * Validate an NPE occurs when a null LocalDate is passed to valueOf\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test11() throws Exception {\n-        LocalTime ld = null;\n-        Time.valueOf(ld);\n-    }\n-\n-    \/*\n-     * Validate an UnsupportedOperationException occurs when toInstant() is\n-     * called\n-     *\/\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void test12() throws Exception {\n-        Time t = new Time(System.currentTimeMillis());\n-        t.toInstant();\n-    }\n-\n-    \/*\n-     * Validate that two Time objects are equal when one is created from the\n-     * toString() of the other and that the correct value is returned from\n-     * toString()\n-     *\/\n-    @Test(dataProvider = \"validTimeValues\")\n-    public void test13(String time, String expected) {\n-        Time t1 = Time.valueOf(time);\n-        Time t2 = Time.valueOf(t1.toString());\n-        assertTrue(t1.equals(t2) && t2.equals(t1)\n-                && t1.toString().equals(expected), \"Error t1 != t2\");\n-    }\n-\n-    \/*\n-     * Validate that two Time values one created using valueOf and another via a\n-     * constructor are equal\n-     *\/\n-    @Test\n-    public void test14() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(8, 30, 59);\n-        assertTrue(t.equals(t2) && t2.equals(t), \"Error t != t2\");\n-    }\n-\n-    \/*\n-     * Validate that two Time values one created using valueOf and another via a\n-     * constructor are equal\n-     *\/\n-    @Test\n-    public void test15() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime());\n-        assertTrue(t.equals(t2) && t2.equals(t), \"Error t != t2\");\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for an invalid Time string\n-     *\/\n-    @Test(dataProvider = \"invalidTimeValues\",\n-            expectedExceptions = IllegalArgumentException.class)\n-    public void test16(String time) throws Exception {\n-        Time.valueOf(time);\n-    }\n-\n-    \/*\n-     * Validate that Time.after() returns false when same date is compared\n-     *\/\n-    @Test\n-    public void test17() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        assertFalse(t.after(t), \"Error t.after(t) = true\");\n-    }\n-\n-    \/*\n-     * Validate that Time.after() returns true when later date is compared to\n-     * earlier date\n-     *\/\n-    @Test\n-    public void test18() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(System.currentTimeMillis());\n-        assertTrue(t2.after(t), \"Error t2.after(t) = false\");\n-    }\n-\n-    \/*\n-     * Validate that Time.after() returns false when earlier date is compared to\n-     * itself\n-     *\/\n-    @Test\n-    public void test19() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime());\n-        assertFalse(t.after(t2), \"Error t.after(t2) = true\");\n-        assertFalse(t2.after(t), \"Error t2.after(t) = true\");\n-    }\n-\n-    \/*\n-     * Validate that Time.before() returns false when same date is compared\n-     *\/\n-    @Test\n-    public void test20() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        assertFalse(t.before(t), \"Error t.before(t) = true\");\n-    }\n-\n-    \/*\n-     * Validate that Time.before() returns true when earlier date is compared to\n-     * later date\n-     *\/\n-    @Test\n-    public void test21() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(System.currentTimeMillis());\n-        assertTrue(t.before(t2), \"Error t.before(t2) = false\");\n-    }\n-\n-    \/*\n-     * Validate that Time.before() returns false when earlier date is compared\n-     * to itself\n-     *\/\n-    @Test\n-    public void test22() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime());\n-        assertFalse(t.before(t2), \"Error t.after(t2) = true\");\n-        assertFalse(t2.before(t), \"Error t2.after(t) = true\");\n-    }\n-\n-    \/*\n-     * Validate that Time.compareTo returns 0 when both Date objects are the\n-     * same\n-     *\/\n-    @Test\n-    public void test23() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        assertTrue(t.compareTo(t) == 0, \"Error t.compareTo(t) !=0\");\n-    }\n-\n-    \/*\n-     * Validate thatTime.compareTo returns 0 when both Time objects are the same\n-     *\/\n-    @Test\n-    public void test24() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime());\n-        assertTrue(t.compareTo(t2) == 0, \"Error t.compareTo(t2) !=0\");\n-    }\n-\n-    \/*\n-     * Validate that Time.compareTo returns 1 when comparing a later Time to an\n-     * earlier Time\n-     *\/\n-    @Test\n-    public void test25() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime() + 1);\n-        assertTrue(t2.compareTo(t) == 1, \"Error t2.compareTo(t) !=1\");\n-    }\n-\n-    \/*\n-     * Validate thatTime.compareTo returns 1 when comparing a later Time to an\n-     * earlier Time\n-     *\/\n-    @Test\n-    public void test26() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime() + 1);\n-        assertTrue(t.compareTo(t2) == -1, \"Error t.compareTo(t2) != -1\");\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Time values which are not valid and are used\n-     * to validate that an IllegalArgumentException will be thrown from the\n-     * valueOf method\n-     *\/\n-    @DataProvider(name = \"invalidTimeValues\")\n-    private Object[][] invalidTimeValues() {\n-        return new Object[][]{\n-            {\"2009-11-01 10:50:01\"},\n-            {\"1961-08-30 10:50:01.1\"},\n-            {\"1961-08-30\"},\n-            {\"00:00:00.\"},\n-            {\"10:50:0.1\"},\n-            {\":00:00\"},\n-            {\"00::00\"},\n-            {\"00:00:\"},\n-            {\"::\"},\n-            {\" : : \"},\n-            {\"0a:00:00\"},\n-            {\"00:bb:00\"},\n-            {\"00:01:cc\"},\n-            {\"08:10:Batman\"},\n-            {\"08:10:10:10\"},\n-            {\"08:10\"},\n-            {\"a:b:c\"},\n-            {null},\n-            {\"8:\"}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Time values which are  valid and are used\n-     * to validate that an IllegalArgumentException will  not be thrown from the\n-     * valueOf method.  It also contains the expected return value from\n-     * toString()\n-     *\/\n-    @DataProvider(name = \"validTimeValues\")\n-    private Object[][] validTimeValues() {\n-        return new Object[][]{\n-            {\"10:50:01\", \"10:50:01\"},\n-            {\"01:1:1\", \"01:01:01\"},\n-            {\"01:01:1\", \"01:01:01\"},\n-            {\"1:01:1\", \"01:01:01\"},\n-            {\"2:02:02\", \"02:02:02\"},\n-            {\"2:02:2\", \"02:02:02\"},\n-            {\"10:50:1\", \"10:50:01\"},\n-            {\"00:00:00\", \"00:00:00\"},\n-            {\"08:30:59\", \"08:30:59\"},\n-            {\"9:0:1\", \"09:00:01\"}\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/TimeTests.java","additions":0,"deletions":348,"binary":false,"changes":348,"status":"deleted"},{"patch":"@@ -1,840 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import java.sql.Date;\n-import java.sql.Time;\n-import java.sql.Timestamp;\n-import java.time.Instant;\n-import java.time.LocalDateTime;\n-import java.time.ZoneId;\n-import java.util.Calendar;\n-import java.util.TimeZone;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-\n-public class TimestampTests extends BaseTest {\n-\n-    private static TimeZone defaultTimeZone = null;\n-\n-    \/*\n-     * Need to set and use a custom TimeZone which does not\n-     * observe daylight savings time for this test.\n-     *\/\n-    @BeforeClass\n-    public static void setUpClass() throws Exception {\n-        defaultTimeZone = TimeZone.getDefault();\n-        TimeZone tzone = TimeZone.getTimeZone(\"GMT+01\");\n-        assertFalse(tzone.observesDaylightTime());\n-        TimeZone.setDefault(tzone);\n-    }\n-\n-    \/*\n-     * Conservatively reset the default time zone after test.\n-     *\/\n-    @AfterClass\n-    public static void tearDownClass() throws Exception {\n-        TimeZone.setDefault(defaultTimeZone);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for an invalid Timestamp\n-     *\/\n-    @Test(dataProvider = \"invalidTimestampValues\",\n-            expectedExceptions = IllegalArgumentException.class)\n-    public void test(String ts) throws Exception {\n-        Timestamp.valueOf(ts);\n-    }\n-\n-    \/*\n-     * Validate that two Timestamp are equal when the leading 0 in seconds is\n-     * omitted\n-     *\/\n-    @Test\n-    public void test01() throws Exception {\n-        String testTS = \"2009-01-01 10:50:00\";\n-        String ExpectedTS = \"2009-01-01 10:50:0\";\n-        Timestamp ts = Timestamp.valueOf(testTS);\n-        Timestamp ts2 = Timestamp.valueOf(ExpectedTS);\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate two Timestamps created from the same string are equal\n-     *\/\n-    @Test\n-    public void test02() throws Exception {\n-        String testTS = \"2009-01-01 10:50:0\";\n-        Timestamp ts = Timestamp.valueOf(testTS);\n-        Timestamp ts2 = Timestamp.valueOf(testTS);\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate that two Timestamp values one with leading 0s for month and day\n-     * equals same string without the leading 0s.\n-     *\/\n-    @Test\n-    public void test03() throws Exception {\n-        String testTS = \"2009-1-1 10:50:0\";\n-        String ExpectedTS = \"2009-01-01 10:50:0\";\n-        Timestamp ts = Timestamp.valueOf(testTS);\n-        Timestamp ts2 = Timestamp.valueOf(ExpectedTS);\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate that two Timestamp values one with leading 0s for day omitted\n-     * are equal\n-     *\/\n-    @Test\n-    public void test04() throws Exception {\n-        String testTS = \"2009-01-1 10:50:0\";\n-        String ExpectedTS = \"2009-01-01 10:50:0\";\n-        Timestamp ts = Timestamp.valueOf(testTS);\n-        Timestamp ts2 = Timestamp.valueOf(ExpectedTS);\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate that two Timestamp values one with leading 0s for month omitted\n-     * and both with leading 0s for seconds omitted are equal\n-     *\/\n-    @Test\n-    public void test05() throws Exception {\n-        String testTS = \"2009-1-01 10:50:0\";\n-        String ExpectedTS = \"2009-01-01 10:50:0\";\n-        Timestamp ts = Timestamp.valueOf(testTS);\n-        Timestamp ts2 = Timestamp.valueOf(ExpectedTS);\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate that two Timestamp values one with leading 0s for month omitted\n-     *\/\n-    @Test\n-    public void test06() throws Exception {\n-        String testTS = \"2005-1-01 10:20:50.00\";\n-        String ExpectedTS = \"2005-01-01 10:20:50.00\";\n-        Timestamp ts = Timestamp.valueOf(testTS);\n-        Timestamp ts2 = Timestamp.valueOf(ExpectedTS);\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate that two Timestamp values one created using valueOf and another\n-     * via a constructor are equal\n-     *\/\n-    @Test\n-    public void test07() {\n-\n-        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.001\");\n-        Timestamp ts2 = new Timestamp(96, 11, 13, 14, 15, 25, 1000000);\n-        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate that two Timestamp values one created using valueOf and another\n-     * via a constructor are equal\n-     *\/\n-    @Test\n-    public void test08() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.001\");\n-        Timestamp ts2 = new Timestamp(ts1.getTime());\n-        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate that two Timestamp values one created using valueOf and another\n-     * via a constructor are equal\n-     *\/\n-    @Test\n-    public void test09() {\n-\n-        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.0\");\n-        Timestamp ts2 = new Timestamp(96, 11, 13, 14, 15, 25, 0);\n-        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate that a Timestamp cannot be equal to null\n-     *\/\n-    @Test\n-    public void test10() {\n-\n-        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 14:15:25.745634\");\n-        Timestamp ts2 = null;\n-        assertFalse(ts1.equals(ts2), \"Error ts1 == null\");\n-    }\n-\n-    \/*\n-     * Validate that a Timestamp is equal to another timestamp created with the\n-     * using the same value but not equal to a Timestamp which is one day later\n-     *\/\n-    @Test\n-    public void test11() {\n-\n-        Timestamp ts1 = Timestamp.valueOf(\"1996-12-10 12:26:19.12\");\n-        Timestamp ts2 = Timestamp.valueOf(\"1996-12-10 12:26:19.12\");\n-        Timestamp ts3 = Timestamp.valueOf(\"1996-12-11 12:24:19.12\");\n-        assertTrue(ts1.equals(ts2) && ts2.equals(ts1), \"Error ts1 != ts2\");\n-        assertFalse(ts1.equals(ts3) && ts3.equals(ts1), \"Error ts1 == ts3\");\n-\n-    }\n-\n-    \/*\n-     * Validate that a Timestamp is equal to itself\n-     *\/\n-    @Test\n-    public void test12() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1996-10-15 12:26:19.12\");\n-        assertTrue(ts1.equals(ts1), \"Error ts1 != ts1\");\n-    }\n-\n-    \/*\n-     * Validate that two Timestamps are equal when one is created from the\n-     * toString() of the other\n-     *\/\n-    @Test(dataProvider = \"validTimestampValues\")\n-    public void test13(String ts, String expectedTS) {\n-        Timestamp ts1 = Timestamp.valueOf(ts);\n-        Timestamp ts2 = Timestamp.valueOf(ts1.toString());\n-        assertTrue(ts1.equals(ts2) && ts2.equals(ts1)\n-                && ts1.toString().equals(expectedTS), \"Error ts1 != ts2\");\n-    }\n-\n-    \/\/ Before Tests\n-    \/*\n-     * Validate that Timestamp ts1 is before Timestamp ts2\n-     *\/\n-    @Test\n-    public void test14() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.745634\");\n-        Timestamp ts2 = Timestamp.valueOf(\"1996-12-13 15:15:25.645634\");\n-        assertTrue(ts1.before(ts2), \"Error ts1 not before ts2\");\n-    }\n-\n-    \/*\n-     * Validate that Timestamp ts1 is before Timestamp ts2\n-     *\/\n-    @Test\n-    public void test15() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 14:15:25\");\n-        Timestamp ts2 = Timestamp.valueOf(\"1999-12-13 15:15:25\");\n-        assertTrue(ts1.before(ts2), \"Error ts1 not before ts2\");\n-    }\n-\n-    \/*\n-     * Validate that Timestamp ts1 is before Timestamp ts2\n-     *\/\n-    @Test\n-    public void test16() {\n-\n-        Timestamp ts1 = Timestamp.valueOf(\"1999-12-13 14:15:25.745634\");\n-        Timestamp ts2 = Timestamp.valueOf(\"1999-11-13 15:15:25.645634\");\n-        assertFalse(ts1.before(ts2), \"Error ts1 before ts2\");\n-    }\n-\n-    \/*\n-     * Validate that a NullPointerException is thrown if a null is passed to\n-     * the before method\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test17() throws Exception {\n-        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.745634\");\n-        ts1.before(null);\n-    }\n-\n-    \/*\n-     * Validate a Timestamp cannot be before itself\n-     *\/\n-    @Test\n-    public void test18() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1999-11-10 12:26:19.3456543\");\n-        assertFalse(ts1.before(ts1), \"Error ts1 before ts1!\");\n-    }\n-\n-    \/*\n-     * Create 3 Timestamps and make sure the 1st is before the other two\n-     * Timestamps which are each greater than the one before it\n-     *\/\n-    @Test\n-    public void test19() {\n-\n-        Timestamp ts1 = new Timestamp(1234560000);\n-        Timestamp ts2 = new Timestamp(1234567000);\n-        Timestamp ts3 = new Timestamp(1234569000);\n-        assertTrue(ts1.before(ts2) && ts2.before(ts3) && ts1.before(ts3));\n-    }\n-\n-    \/*\n-     * Validate that Timestamp ts1 is not after Timestamp ts2\n-     *\/\n-    @Test\n-    public void test20() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1999-12-13 14:15:25.745634\");\n-        Timestamp ts2 = Timestamp.valueOf(\"1999-12-13 15:15:25.645634\");\n-        assertFalse(ts1.after(ts2), \"Error ts1 is after ts2\");\n-\n-    }\n-\n-    \/*\n-     * Validate that Timestamp ts1 is after Timestamp ts2\n-     *\/\n-    @Test\n-    public void test21() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1996-12-13 14:15:25.745634\");\n-        Timestamp ts2 = Timestamp.valueOf(\"1996-11-13 15:15:25.645634\");\n-        assertTrue(ts1.after(ts2), \"Error ts1 not after ts2\");\n-    }\n-\n-    \/*\n-     * Validate that a NullPointerException is thrown if a null is passed to the\n-     * after method\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test22() throws Exception {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        ts1.after(null);\n-    }\n-\n-    \/*\n-     * Validate that a Timestamp cannot be after itself\n-     *\/\n-    @Test\n-    public void test23() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1999-11-10 12:26:19.3456543\");\n-        assertFalse(ts1.after(ts1), \"Error ts1 is after itself\");\n-    }\n-\n-    \/*\n-     * Validate that a Timestamp after() works correctly with Timestamp created\n-     * using milliseconds\n-     *\/\n-    @Test\n-    public void test24() {\n-\n-        Timestamp ts1 = new Timestamp(1234568000);\n-        Timestamp ts2 = new Timestamp(1234565000);\n-        Timestamp ts3 = new Timestamp(1234562000);\n-        assertTrue(ts1.after(ts2) && ts2.after(ts3) && ts1.after(ts3));\n-    }\n-\n-    \/*\n-     * Validate compareTo returns 0 for Timestamps that are the same\n-     *\/\n-    @Test\n-    public void test25() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        Timestamp ts2 = new Timestamp(ts1.getTime());\n-        assertTrue(ts1.compareTo(ts2) == 0, \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate compareTo returns -1 for when the 1st Timestamp is earlier than\n-     * the 2nd Timestamp\n-     *\/\n-    @Test\n-    public void test26() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        Timestamp ts2 = new Timestamp(ts1.getTime() + 1000);\n-        assertTrue(ts1.compareTo(ts2) == -1, \"Error ts1 not before ts2\");\n-        assertTrue(ts2.compareTo(ts1) == 1, \"Error ts1 is not before ts2\");\n-    }\n-\n-    \/*\n-     * Validate compareTo returns 1 for when the 1st Timestamp is later than the\n-     * 2nd Timestamp\n-     *\/\n-    @Test\n-    public void test27() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        Timestamp ts2 = new Timestamp(ts1.getTime() - 1000);\n-        assertTrue(ts1.compareTo(ts2) == 1, \"Error ts1 not after ts2\");\n-        assertTrue(ts2.compareTo(ts1) == -1, \"Error ts1 not after ts2\");\n-    }\n-\n-    \/*\n-     * Validate compareTo returns 0 for Timestamps that are the same\n-     *\/\n-    @Test\n-    public void test28() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        java.util.Date ts2 = new java.util.Date(ts1.getTime());\n-        assertTrue(ts1.compareTo(ts2) == 0, \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate compareTo returns 0 for Timestamps that are the same\n-     *\/\n-    @Test\n-    public void test29() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        java.util.Date d = new java.util.Date(ts1.getTime());\n-        assertFalse(ts1.equals(d), \"Error ts1 == d\");\n-    }\n-\n-    \/*\n-     * Validate compareTo returns 0 for Timestamps that are the same\n-     *\/\n-    @Test\n-    public void test30() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        java.util.Date d = new Timestamp(ts1.getTime());\n-        assertTrue(ts1.equals(d), \"Error ts1 != d\");\n-    }\n-\n-    \/*\n-     * Validate equals returns false when a Date object is passed to equals\n-     *\/\n-    @Test\n-    public void test31() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        Date d = new Date(ts1.getTime());\n-        assertFalse(ts1.equals(d), \"Error ts1 != d\");\n-    }\n-\n-    \/*\n-     * Validate equals returns false when a Date object is passed to equals\n-     *\/\n-    @Test\n-    public void test32() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        java.util.Date d = new Date(ts1.getTime());\n-        assertFalse(ts1.equals(d), \"Error ts1 != d\");\n-    }\n-\n-    \/*\n-     * Validate equals returns false when a Time object is passed to equals\n-     *\/\n-    @Test\n-    public void test33() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        Time t1 = new Time(ts1.getTime());\n-        assertFalse(ts1.equals(t1), \"Error ts1 == t1\");\n-    }\n-\n-    \/*\n-     * Validate equals returns false when a String object is passed to equals\n-     *\/\n-    @Test\n-    public void test34() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        assertFalse(ts1.equals(\"1966-08-30 08:08:08\"), \"Error ts1 == a String\");\n-    }\n-\n-    \/*\n-     * Validate getTime() returns the same value from 2 timeStamps created by\n-     *\/\n-    @Test\n-    public void test35() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        Timestamp ts2 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        assertTrue(ts2.getTime() == ts1.getTime(),\n-                \"ts1.getTime() != ts2.getTime()\");\n-        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate getTime() returns the same value from 2 timeStamps when\n-     * setTime() is used to specify the same value for both Timestamps\n-     *\/\n-    @Test\n-    public void test36() {\n-        Timestamp ts1 = Timestamp.valueOf(\"1966-08-30 08:08:08\");\n-        Timestamp ts2 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n-        ts2.setTime(ts1.getTime());\n-        assertTrue(ts2.getTime() == ts1.getTime(),\n-                \"ts1.getTime() != ts2.getTime()\");\n-        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for an invalid nanos value\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test38() throws Exception {\n-        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n-        ts1.setNanos(-1);\n-\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for an invalid nanos value\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test39() throws Exception {\n-        int nanos = 999999999;\n-        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n-        ts1.setNanos(nanos + 1);\n-    }\n-\n-    \/*\n-     * Validate you can set nanos to 999999999\n-     *\/\n-    @Test\n-    public void test40() throws Exception {\n-        int nanos = 999999999;\n-        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n-        ts1.setNanos(nanos);\n-        assertTrue(ts1.getNanos() == nanos, \"Error Invalid Nanos value\");\n-    }\n-\n-    \/*\n-     * Validate you can set nanos to 0\n-     *\/\n-    @Test\n-    public void test41() throws Exception {\n-        int nanos = 0;\n-        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n-        ts1.setNanos(nanos);\n-        assertTrue(ts1.getNanos() == nanos, \"Error Invalid Nanos value\");\n-    }\n-\n-    \/*\n-     * Validate that a Timestamp made from a LocalDateTime are equal\n-     *\/\n-    @Test\n-    public void test42() throws Exception {\n-        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n-        LocalDateTime ldt = ts1.toLocalDateTime();\n-        Timestamp ts2 = Timestamp.valueOf(ldt);\n-        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate that a Timestamp LocalDateTime value, made from a LocalDateTime\n-     * are equal\n-     *\/\n-    @Test\n-    public void test43() throws Exception {\n-        LocalDateTime ldt = LocalDateTime.now();\n-        Timestamp ts2 = Timestamp.valueOf(ldt);\n-        assertTrue(ldt.equals(ts2.toLocalDateTime()),\n-                \"Error LocalDateTime values are not equal\");\n-    }\n-\n-    \/*\n-     * Validate an NPE occurs when a null LocalDateTime is passed to valueOF\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test44() throws Exception {\n-        LocalDateTime ldt = null;\n-        Timestamp.valueOf(ldt);\n-    }\n-\n-    \/*\n-     * Validate that a Timestamp made from a Instant are equal\n-     *\/\n-    @Test\n-    public void test45() throws Exception {\n-        Timestamp ts1 = Timestamp.valueOf(\"1961-08-30 00:00:00\");\n-        Instant instant = ts1.toInstant();\n-        Timestamp ts2 = Timestamp.from(instant);\n-        assertTrue(ts1.equals(ts2), \"Error ts1 != ts2\");\n-    }\n-\n-    \/*\n-     * Validate that a Timestamp made from a Instant are equal\n-     *\/\n-    @Test\n-    public void test46() throws Exception {\n-        Instant instant = Instant.now();\n-        Timestamp ts2 = Timestamp.from(instant);\n-        assertTrue(instant.equals(ts2.toInstant()),\n-                \"Error Instant values do not match\");\n-    }\n-\n-    \/*\n-     * Validate an NPE occurs when a null instant is passed to from\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test47() throws Exception {\n-        Instant instant = null;\n-        Timestamp.from(instant);\n-    }\n-\n-    \/\/ Added SQE tests\n-    \/*\n-     * Create a Timestamp and a 2nd Timestamp that is 1 month earlier and\n-     * validate that it is not before or after the original Timestamp\n-     *\/\n-    @Test\n-    public void test48() {\n-        Calendar cal = Calendar.getInstance();\n-        Timestamp ts1 = new Timestamp(System.currentTimeMillis());\n-        cal.setTimeInMillis(ts1.getTime());\n-        cal.add(Calendar.MONTH, -1);\n-        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));\n-        Timestamp ts2 = new Timestamp(cal.getTimeInMillis());\n-        assertFalse(ts1.before(ts2) || ts2.after(ts1));\n-    }\n-\n-    \/*\n-     * Create two Timestamps and validate that compareTo returns 1 to indicate\n-     * the 1st Timestamp is greater than the 2nd Timestamp\n-     *\/\n-    @Test\n-    public void test49() {\n-        Calendar cal = Calendar.getInstance();\n-        Timestamp ts1 = new Timestamp(System.currentTimeMillis());\n-        cal.setTimeInMillis(ts1.getTime());\n-        cal.add(Calendar.MONTH, -1);\n-        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));\n-        Timestamp ts2 = new Timestamp(cal.getTimeInMillis());\n-        assertTrue(ts1.compareTo(ts2) == 1);\n-    }\n-\n-    \/*\n-     * Create two Timestamps and validate that the 1st Timestamp is not equal to\n-     * the 2nd Timestamp but equal to itself\n-     *\/\n-    @Test\n-    public void test50() {\n-        Calendar cal = Calendar.getInstance();\n-        Timestamp ts1 = new Timestamp(System.currentTimeMillis());\n-        cal.setTimeInMillis(ts1.getTime());\n-        cal.add(Calendar.MONTH, -1);\n-        cal.set(Calendar.DAY_OF_MONTH, cal.getActualMaximum(Calendar.DAY_OF_MONTH));\n-        Timestamp ts2 = new Timestamp(cal.getTimeInMillis());\n-        assertTrue(!ts1.equals(ts2) && ts1.equals(ts1));\n-    }\n-\n-    \/*\n-     * Validate that two Timestamps are equal when one is created from the\n-     * toString() of the other\n-     *\/\n-    @Test(dataProvider = \"validateNanos\")\n-    public void test51(String ts, int nanos) {\n-        Timestamp ts1 = Timestamp.valueOf(ts);\n-        Timestamp ts2 = Timestamp.valueOf(ts1.toString());\n-        assertTrue(ts1.getNanos() == nanos && ts1.equals(ts2),\n-                \"Error with Nanos\");\n-    }\n-\n-    @Test(dataProvider = \"validTimestampLongValues\")\n-    public void test52(long value, String ts) {\n-        Timestamp ts1 = new Timestamp(value);\n-        assertEquals(ts1.toString(), ts, \"ts1.toString() != ts\");\n-    }\n-\n-    @Test\n-    public void test53() {\n-        \/\/ The latest Instant that can be converted to a Timestamp.\n-        Instant instant1 = Instant.ofEpochSecond(Long.MAX_VALUE \/ 1000, 999_999_999);\n-        assertEquals(Timestamp.from(instant1).toInstant(), instant1);\n-\n-        \/\/ One nanosecond more, and converting it gets an overflow.\n-        Instant instant2 = instant1.plusNanos(1);\n-        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(instant2));\n-\n-        \/\/ The earliest Instant that can be converted to a Timestamp.\n-        Instant instant3 = Instant.ofEpochSecond(Long.MIN_VALUE \/ 1000, 0);\n-        assertEquals(Timestamp.from(instant3).toInstant(), instant3);\n-\n-        \/\/ One nanosecond less, and converting it gets an overflow.\n-        Instant instant4 = instant3.minusNanos(1);\n-        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(instant4));\n-\n-        \/\/ The latest possible Instant will certainly overflow.\n-        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(Instant.MAX));\n-\n-        \/\/ The earliest possible Instant will certainly overflow.\n-        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(Instant.MIN));\n-    }\n-\n-    \/*\n-     * Validate that two Timestamp hashCode values are equal when\n-     * the Timestamp values match, including the nanos.\n-     *\/\n-    @Test\n-    public void test54() {\n-        long t = System.currentTimeMillis();\n-        Timestamp ts1 = new Timestamp(t);\n-        Timestamp ts2 = new Timestamp(t);\n-        ts1.setNanos(123456789);\n-        ts2.setNanos(123456789);\n-        assertTrue(ts1.equals(ts1));\n-        assertTrue(ts2.equals(ts2));\n-        assertTrue(ts1.equals(ts2));\n-        \/\/ As the Timestamp values, including the nanos are the same, the hashCode's\n-        \/\/ should be equal\n-        assertEquals(ts1.hashCode(), ts2.hashCode());\n-    }\n-\n-    \/*\n-     * Validate that two Timestamp hashCode values are not equal when only\n-     * the nanos value for the Timestamp differ.\n-     *\/\n-    @Test\n-    public void test55() {\n-        long t = System.currentTimeMillis();\n-        Timestamp ts1 = new Timestamp(t);\n-        Timestamp ts2 = new Timestamp(t);\n-        \/\/ Modify the nanos so that the Timestamp values differ\n-        ts1.setNanos(123456789);\n-        ts2.setNanos(987654321);\n-        assertTrue(ts1.equals(ts1));\n-        assertTrue(ts2.equals(ts2));\n-        assertFalse(ts1.equals(ts2));\n-        \/\/ As the nanos differ, the hashCode values should differ\n-        assertNotEquals(ts1.hashCode(), ts2.hashCode());\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Timestamps which are not valid and are used\n-     * to validate that an IllegalArgumentException will be thrown from the\n-     * valueOf method\n-     *\/\n-    @DataProvider(name = \"invalidTimestampValues\")\n-    private Object[][] invalidTimestampValues() {\n-        return new Object[][]{\n-            {\"2009-11-01-01 10:50:01\"},\n-            {\"aaaa-11-01-01 10:50\"},\n-            {\"aaaa-11-01 10:50\"},\n-            {\"1961--30 00:00:00\"},\n-            {\"--30 00:00:00\"},\n-            {\"-- 00:00:00\"},\n-            {\"1961-1- 00:00:00\"},\n-            {\"2009-11-01\"},\n-            {\"10:50:01\"},\n-            {\"1961-a-30 00:00:00\"},\n-            {\"1961-01-bb 00:00:00\"},\n-            {\"1961-08-30 00:00:00.\"},\n-            {\"1961-08-30 :00:00\"},\n-            {\"1961-08-30 00::00\"},\n-            {\"1961-08-30 00:00:\"},\n-            {\"1961-08-30 ::\"},\n-            {\"1961-08-30 0a:00:00\"},\n-            {\"1961-08-30 00:bb:00\"},\n-            {\"1961-08-30 00:01:cc\"},\n-            {\"1961-08-30 00:00:00.01a\"},\n-            {\"1961-08-30 00:00:00.a\"},\n-            {\"1996-12-10 12:26:19.1234567890\"},\n-            {null}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Timestamps which are  valid and are used\n-     * to validate that an IllegalArgumentException will not be thrown from the\n-     * valueOf method and the corect value from toString() is returned\n-     *\/\n-    @DataProvider(name = \"validTimestampValues\")\n-    private Object[][] validTimestampValues() {\n-        return new Object[][]{\n-            {\"1961-08-30 00:00:00\", \"1961-08-30 00:00:00.0\"},\n-            {\"1961-08-30 11:22:33\", \"1961-08-30 11:22:33.0\"},\n-            {\"1961-8-30 00:00:00\", \"1961-08-30 00:00:00.0\"},\n-            {\"1966-08-1 00:00:00\", \"1966-08-01 00:00:00.0\"},\n-            {\"1996-12-10 12:26:19.1\", \"1996-12-10 12:26:19.1\"},\n-            {\"1996-12-10 12:26:19.12\", \"1996-12-10 12:26:19.12\"},\n-            {\"1996-12-10 12:26:19.123\", \"1996-12-10 12:26:19.123\"},\n-            {\"1996-12-10 12:26:19.1234\", \"1996-12-10 12:26:19.1234\"},\n-            {\"1996-12-10 12:26:19.12345\", \"1996-12-10 12:26:19.12345\"},\n-            {\"1996-12-10 12:26:19.123456\", \"1996-12-10 12:26:19.123456\"},\n-            {\"1996-12-10 12:26:19.1234567\", \"1996-12-10 12:26:19.1234567\"},\n-            {\"1996-12-10 12:26:19.12345678\", \"1996-12-10 12:26:19.12345678\"},\n-            {\"1996-12-10 12:26:19.123456789\", \"1996-12-10 12:26:19.123456789\"},\n-            {\"1996-12-10 12:26:19.000000001\", \"1996-12-10 12:26:19.000000001\"},\n-            {\"1996-12-10 12:26:19.000000012\", \"1996-12-10 12:26:19.000000012\"},\n-            {\"1996-12-10 12:26:19.000000123\", \"1996-12-10 12:26:19.000000123\"},\n-            {\"1996-12-10 12:26:19.000001234\", \"1996-12-10 12:26:19.000001234\"},\n-            {\"1996-12-10 12:26:19.000012345\", \"1996-12-10 12:26:19.000012345\"},\n-            {\"1996-12-10 12:26:19.000123456\", \"1996-12-10 12:26:19.000123456\"},\n-            {\"1996-12-10 12:26:19.001234567\", \"1996-12-10 12:26:19.001234567\"},\n-            {\"1996-12-10 12:26:19.12345678\", \"1996-12-10 12:26:19.12345678\"},\n-            {\"1996-12-10 12:26:19.0\", \"1996-12-10 12:26:19.0\"},\n-            {\"1996-12-10 12:26:19.01230\", \"1996-12-10 12:26:19.0123\"}\n-        };\n-    }\n-\n-    @DataProvider(name = \"validTimestampLongValues\")\n-    private Object[][] validTimestampLongValues() {\n-        return new Object[][]{\n-            {1L, \"1970-01-01 01:00:00.001\"},\n-            {-3600*1000L - 1, \"1969-12-31 23:59:59.999\"},\n-            {-(20000L*365*24*60*60*1000), \"18018-08-28 01:00:00.0\"},\n-            {Timestamp.valueOf(\"1961-08-30 11:22:33\").getTime(), \"1961-08-30 11:22:33.0\"},\n-            {Timestamp.valueOf(\"1961-08-30 11:22:33.54321000\").getTime(), \"1961-08-30 11:22:33.543\"}, \/\/ nanoprecision lost\n-            {new Timestamp(114, 10, 10, 10, 10, 10, 100000000).getTime(), \"2014-11-10 10:10:10.1\"},\n-            {new Timestamp(0, 10, 10, 10, 10, 10, 100000).getTime(), \"1900-11-10 10:10:10.0\"}, \/\/ nanoprecision lost\n-            {new Date(114, 10, 10).getTime(), \"2014-11-10 00:00:00.0\"},\n-            {new Date(0, 10, 10).getTime(), \"1900-11-10 00:00:00.0\"},\n-            {LocalDateTime.of(1960, 10, 10, 10, 10, 10, 50000).atZone(ZoneId.of(\"America\/Los_Angeles\"))\n-                .toInstant().toEpochMilli(), \"1960-10-10 19:10:10.0\"},\n-\n-            \/\/ millisecond timestamps wraps around at year 1, so Long.MIN_VALUE looks similar\n-            \/\/ Long.MAX_VALUE, while actually representing 292278994 BCE\n-            {Long.MIN_VALUE, \"292278994-08-17 08:12:55.192\"},\n-            {Long.MAX_VALUE + 1, \"292278994-08-17 08:12:55.192\"},\n-            {Long.MAX_VALUE, \"292278994-08-17 08:12:55.807\"},\n-            {Long.MIN_VALUE - 1, \"292278994-08-17 08:12:55.807\"},\n-\n-            \/\/ wrap around point near 0001-01-01, test that we never get a negative year:\n-            {-(1970L*365*24*60*60*1000), \"0001-04-25 01:00:00.0\"},\n-            {-(1970L*365*24*60*60*1000 + 115*24*60*60*1000L), \"0001-12-31 01:00:00.0\"},\n-            {-(1970L*365*24*60*60*1000 + 115*24*60*60*1000L - 23*60*60*1000L), \"0001-01-01 00:00:00.0\"},\n-\n-            {LocalDateTime.of(0, 1, 1, 10, 10, 10, 50000).atZone(ZoneId.of(\"America\/Los_Angeles\"))\n-                .toInstant().toEpochMilli() - 2*24*60*60*1000L, \"0001-01-01 19:03:08.0\"}, \/\/ 1 BCE\n-            {LocalDateTime.of(0, 1, 1, 10, 10, 10, 50000).atZone(ZoneId.of(\"America\/Los_Angeles\"))\n-                .toInstant().toEpochMilli() - 3*24*60*60*1000L, \"0002-12-31 19:03:08.0\"} \/\/ 2 BCE\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Timestamp and Nanos values in order to\n-     * validate that the correct Nanos value is generated from the specified\n-     * Timestamp\n-     *\/\n-    @DataProvider(name = \"validateNanos\")\n-    private Object[][] validateNanos() {\n-        return new Object[][]{\n-            {\"1961-08-30 00:00:00\", 0},\n-            {\"1996-12-10 12:26:19.1\", 100000000},\n-            {\"1996-12-10 12:26:19.12\", 120000000},\n-            {\"1996-12-10 12:26:19.123\", 123000000},\n-            {\"1996-12-10 12:26:19.1234\", 123400000},\n-            {\"1996-12-10 12:26:19.12345\", 123450000},\n-            {\"1996-12-10 12:26:19.123456\", 123456000},\n-            {\"1996-12-10 12:26:19.1234567\", 123456700},\n-            {\"1996-12-10 12:26:19.12345678\", 123456780},\n-            {\"1996-12-10 12:26:19.123456789\", 123456789},\n-            {\"1996-12-10 12:26:19.000000001\", 1},\n-            {\"1996-12-10 12:26:19.000000012\", 12},\n-            {\"1996-12-10 12:26:19.000000123\", 123},\n-            {\"1996-12-10 12:26:19.000001234\", 1234},\n-            {\"1996-12-10 12:26:19.000012345\", 12345},\n-            {\"1996-12-10 12:26:19.000123456\", 123456},\n-            {\"1996-12-10 12:26:19.001234567\", 1234567},\n-            {\"1996-12-10 12:26:19.012345678\", 12345678},\n-            {\"1996-12-10 12:26:19.0\", 0},\n-            {\"1996-12-10 12:26:19.01230\", 12300000}\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/TimestampTests.java","additions":0,"deletions":840,"binary":false,"changes":840,"status":"deleted"},{"patch":"@@ -1,195 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package util;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.sql.JDBCType;\n-import java.sql.SQLException;\n-\n-import org.testng.annotations.DataProvider;\n-\n-public class BaseTest {\n-\n-    protected final String reason = \"reason\";\n-    protected final String state = \"SQLState\";\n-    protected final String cause = \"java.lang.Throwable: cause\";\n-    protected final Throwable t = new Throwable(\"cause\");\n-    protected final Throwable t1 = new Throwable(\"cause 1\");\n-    protected final Throwable t2 = new Throwable(\"cause 2\");\n-    protected final int errorCode = 21;\n-    protected final String[] msgs = {\"Exception 1\", \"cause 1\", \"Exception 2\",\n-        \"Exception 3\", \"cause 2\"};\n-    private static final String MAX_LENGTH_IDENTIFIER = \"a\".repeat(128);\n-\n-    \/*\n-     * Take some form of SQLException, serialize and deserialize it\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    protected <T extends SQLException> T\n-            createSerializedException(T ex)\n-            throws IOException, ClassNotFoundException {\n-        return (T) serializeDeserializeObject(ex);\n-    }\n-\n-    \/*\n-     * Utility method to serialize and deserialize an object\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    protected <T> T serializeDeserializeObject(T o)\n-            throws IOException, ClassNotFoundException {\n-        T o1;\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n-            oos.writeObject(o);\n-        }\n-        try (ObjectInputStream ois\n-                = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()))) {\n-            o1 = (T) ois.readObject();\n-        }\n-        return o1;\n-    }\n-\n-    \/*\n-     * DataProvider used to specify the value to set and check for\n-     * methods using boolean values\n-     *\/\n-    @DataProvider(name = \"trueFalse\")\n-    protected Object[][] trueFalse() {\n-        return new Object[][]{\n-            {true},\n-            {false}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to specify the standard JDBC Types\n-     *\/\n-    @DataProvider(name = \"jdbcTypes\")\n-    protected Object[][] jdbcTypes() {\n-        Object[][] o = new Object[JDBCType.values().length][1];\n-        int pos = 0;\n-        for (JDBCType c : JDBCType.values()) {\n-            o[pos++][0] = c.getVendorTypeNumber();\n-        }\n-        return o;\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that enquoteLiteral converts a string to a literal and every instance of\n-     * a single quote will be converted into two single quotes in the literal.\n-     *\/\n-    @DataProvider(name = \"validEnquotedLiteralValues\")\n-    protected Object[][] validEnquotedLiteralValues() {\n-        return new Object[][]{\n-                {\"Hello\", \"'Hello'\"},\n-                {\"G'Day\", \"'G''Day'\"},\n-                {\"'G''Day'\", \"'''G''''Day'''\"},\n-                {\"I'''M\", \"'I''''''M'\"},\n-                {\"The Dark Knight\", \"'The Dark Knight'\"},\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that enqouteIdentifier returns a simple SQL Identifier or a\n-     * quoted identifier\n-     *\/\n-    @DataProvider(name = \"validIdentifierValues\")\n-    protected Object[][] validEnquotedIdentifierValues() {\n-        return new Object[][]{\n-                {\"b\", false, \"b\"},\n-                {\"b\", true, \"\\\"b\\\"\"},\n-                {MAX_LENGTH_IDENTIFIER, false, MAX_LENGTH_IDENTIFIER},\n-                {MAX_LENGTH_IDENTIFIER, true, \"\\\"\" + MAX_LENGTH_IDENTIFIER + \"\\\"\"},\n-                {\"Hello\", false, \"Hello\"},\n-                {\"Hello\", true, \"\\\"Hello\\\"\"},\n-                {\"G'Day\", false, \"\\\"G'Day\\\"\"},\n-                {\"G'Day\", true, \"\\\"G'Day\\\"\"},\n-                {\"Bruce Wayne\", false, \"\\\"Bruce Wayne\\\"\"},\n-                {\"Bruce Wayne\", true, \"\\\"Bruce Wayne\\\"\"},\n-                {\"select\", false, \"\\\"select\\\"\"},\n-                {\"table\", true, \"\\\"table\\\"\"},\n-                {\"GoodDay$\", false, \"\\\"GoodDay$\\\"\"},\n-                {\"GoodDay$\", true, \"\\\"GoodDay$\\\"\"},};\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings are invalid for enquoteIdentifier\n-     * resulting in a SQLException being thrown\n-     *\/\n-    @DataProvider(name = \"invalidIdentifierValues\")\n-    protected Object[][] invalidEnquotedIdentifierValues() {\n-        return new Object[][]{\n-                {\"Hel\\\"lo\", false},\n-                {\"\\\"Hel\\\"lo\\\"\", true},\n-                {\"Hello\" + '\\0', false},\n-                {\"\", false},\n-                {MAX_LENGTH_IDENTIFIER + 'a', false},};\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that isSimpleIdentifier returns the correct value based on the\n-     * identifier specified.\n-     *\/\n-    @DataProvider(name = \"simpleIdentifierValues\")\n-    protected Object[][] simpleIdentifierValues() {\n-        return new Object[][]{\n-                {\"b\", true},\n-                {\"Hello\", true},\n-                {\"\\\"Gotham\\\"\", false},\n-                {\"G'Day\", false},\n-                {\"Bruce Wayne\", false},\n-                {\"GoodDay$\", false},\n-                {\"Dick_Grayson\", true},\n-                {\"Batmobile1966\", true},\n-                {MAX_LENGTH_IDENTIFIER, true},\n-                {MAX_LENGTH_IDENTIFIER + 'a', false},\n-                {\"\", false},\n-                {\"select\", false}\n-            };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide strings that will be used to validate\n-     * that enquoteNCharLiteral converts a string to a National Character\n-     * literal and every instance of\n-     * a single quote will be converted into two single quotes in the literal.\n-     *\/\n-    @DataProvider(name = \"validEnquotedNCharLiteralValues\")\n-    protected Object[][] validEnquotedNCharLiteralValues() {\n-        return new Object[][]{\n-                {\"Hello\", \"N'Hello'\"},\n-                {\"G'Day\", \"N'G''Day'\"},\n-                {\"'G''Day'\", \"N'''G''''Day'''\"},\n-                {\"I'''M\", \"N'I''''''M'\"},\n-                {\"N'Hello'\", \"N'N''Hello'''\"},\n-                {\"The Dark Knight\", \"N'The Dark Knight'\"}\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/util\/BaseTest.java","additions":0,"deletions":195,"binary":false,"changes":195,"status":"deleted"},{"patch":"@@ -0,0 +1,7 @@\n+# JDBC unit tests uses JUnit\n+JUnit.dirs= .\n+othervm.dirs= .\n+lib.dirs = \/java\/sql\/junit\n+modules = java.sql.rowset\/com.sun.rowset \\\n+          java.sql.rowset\/com.sun.rowset.internal \\\n+          java.sql.rowset\/com.sun.rowset.providers\n","filename":"test\/jdk\/javax\/sql\/junit\/TEST.properties","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"","filename":"test\/jdk\/javax\/sql\/junit\/jars\/badFactory\/META-INF\/services\/javax.sql.rowset.RowSetFactory","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/sql\/testng\/jars\/badFactory\/META-INF\/services\/javax.sql.rowset.RowSetFactory","status":"renamed"},{"patch":"","filename":"test\/jdk\/javax\/sql\/junit\/jars\/goodFactory\/META-INF\/services\/javax.sql.rowset.RowSetFactory","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/sql\/testng\/jars\/goodFactory\/META-INF\/services\/javax.sql.rowset.RowSetFactory","status":"renamed"},{"patch":"@@ -0,0 +1,460 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.StringBufferInputStream;\n+import java.io.StringReader;\n+import java.math.BigDecimal;\n+import java.sql.Array;\n+import java.sql.Blob;\n+import java.sql.Clob;\n+import java.sql.Date;\n+import java.sql.Ref;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.Calendar;\n+import java.util.stream.Stream;\n+import javax.sql.RowSet;\n+import javax.sql.rowset.serial.SerialArray;\n+import javax.sql.rowset.serial.SerialBlob;\n+import javax.sql.rowset.serial.SerialClob;\n+import javax.sql.rowset.serial.SerialRef;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import util.StubArray;\n+import util.StubBaseRowSet;\n+import util.StubBlob;\n+import util.StubClob;\n+import util.StubRef;\n+import util.TestRowSetListener;\n+\n+public class BaseRowSetTests extends CommonRowSetTests {\n+\n+    private StubBaseRowSet brs;\n+\n+    @Override\n+    protected RowSet newInstance() throws SQLException {\n+        return new StubBaseRowSet();\n+    }\n+\n+    \/*\n+     * Create a RowSetListener and validate that notifyCursorMoved is called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void baseRowSetTest0000(StubBaseRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.notifyCursorMoved();\n+        assertTrue(rsl.isNotified(TestRowSetListener.CURSOR_MOVED));\n+    }\n+\n+    \/*\n+     * Create a RowSetListener and validate that notifyRowChanged is called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void baseRowSetTest0001(StubBaseRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.notifyRowChanged();\n+        assertTrue(rsl.isNotified(TestRowSetListener.ROW_CHANGED));\n+    }\n+\n+    \/*\n+     * Create a RowSetListener and validate that notifyRowSetChanged is called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void baseRowSetTest0002(StubBaseRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.notifyRowSetChanged();\n+        assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n+    }\n+\n+    \/*\n+     * Create multiple RowSetListeners and validate that notifyRowSetChanged\n+     * is called on all listeners\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void baseRowSetTest0003(StubBaseRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        TestRowSetListener rsl2 = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.addRowSetListener(rsl2);\n+        rs.notifyRowSetChanged();\n+        assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n+        assertTrue(rsl2.isNotified(TestRowSetListener.ROWSET_CHANGED));\n+    }\n+\n+    \/*\n+     * Create multiple RowSetListeners and validate that notifyRowChanged\n+     * is called on all listeners\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void baseRowSetTest0004(StubBaseRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        TestRowSetListener rsl2 = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.addRowSetListener(rsl2);\n+        rs.notifyRowChanged();\n+        assertTrue(rsl.isNotified(TestRowSetListener.ROW_CHANGED));\n+        assertTrue(rsl2.isNotified(TestRowSetListener.ROW_CHANGED));\n+    }\n+\n+    \/*\n+     * Create multiple RowSetListeners and validate that notifyCursorMoved\n+     * is called on all listeners\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void baseRowSetTest0005(StubBaseRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        TestRowSetListener rsl2 = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.addRowSetListener(rsl2);\n+        rs.notifyCursorMoved();\n+        assertTrue(rsl.isNotified(TestRowSetListener.CURSOR_MOVED));\n+        assertTrue(rsl2.isNotified(TestRowSetListener.CURSOR_MOVED));\n+    }\n+\n+    \/*\n+     * Create a RowSetListener and validate that notifyRowSetChanged,\n+     * notifyRowChanged() and notifyCursorMoved are called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void baseRowSetTest0006(StubBaseRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.notifyRowSetChanged();\n+        rs.notifyRowChanged();\n+        rs.notifyCursorMoved();\n+        assertTrue(rsl.isNotified(\n+                TestRowSetListener.CURSOR_MOVED | TestRowSetListener.ROWSET_CHANGED\n+                | TestRowSetListener.ROW_CHANGED));\n+    }\n+\n+\n+    \/*\n+     * Create multiple RowSetListeners and validate that notifyRowSetChanged,\n+     * notifyRowChanged() and notifyCursorMoved are called on all listeners\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void baseRowSetTest0007(StubBaseRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        TestRowSetListener rsl2 = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.addRowSetListener(rsl2);\n+        rs.notifyRowSetChanged();\n+        rs.notifyRowChanged();\n+        rs.notifyCursorMoved();\n+        assertTrue(rsl.isNotified(\n+                TestRowSetListener.CURSOR_MOVED | TestRowSetListener.ROWSET_CHANGED\n+                | TestRowSetListener.ROW_CHANGED));\n+        assertTrue(rsl2.isNotified(\n+                TestRowSetListener.CURSOR_MOVED | TestRowSetListener.ROWSET_CHANGED\n+                | TestRowSetListener.ROW_CHANGED));\n+    }\n+\n+    \/*\n+     * Create a RowSetListener and validate that notifyRowSetChanged is called,\n+     * remove the listener, invoke notifyRowSetChanged again and verify the\n+     * listner is not called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void baseRowSetTest0008(StubBaseRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.notifyRowSetChanged();\n+        assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n+        \/\/ Clear the flag indicating the listener has been called\n+        rsl.resetFlag();\n+        rs.removeRowSetListener(rsl);\n+        rs.notifyRowSetChanged();\n+        assertFalse(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n+    }\n+\n+    \/*\n+     * Set the base parameters and validate that the value set is\n+     * the correct type and value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"testBaseParameters\")\n+    public void baseRowSetTest0009(int pos, Object o) throws Exception {\n+        assertTrue(getParam(pos, o).getClass().isInstance(o));\n+        assertTrue(o.equals(getParam(pos, o)));\n+    }\n+\n+    \/*\n+     * Set the complex parameters and validate that the value set is\n+     * the correct type\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"testAdvancedParameters\")\n+    public void baseRowSetTest0010(int pos, Object o) throws Exception {\n+        assertTrue(getParam(pos, o).getClass().isInstance(o));\n+    }\n+\n+    \/*\n+     * Validate setNull specifying the supported type values\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"jdbcTypes\")\n+    public void baseRowSetTest0011(Integer type) throws Exception {\n+        brs = new StubBaseRowSet();\n+        brs.setNull(1, type);\n+        assertTrue(checkNullParam(1, type, null));\n+    }\n+\n+    \/*\n+     * Validate setNull specifying the supported type values and that\n+     * typeName is set internally\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"jdbcTypes\")\n+    public void baseRowSetTest0012(Integer type) throws Exception {\n+        brs = new StubBaseRowSet();\n+        brs.setNull(1, type, \"SUPERHERO\");\n+        assertTrue(checkNullParam(1, type, \"SUPERHERO\"));\n+    }\n+\n+    \/*\n+     *  Validate that setDate sets the specified Calendar internally\n+     *\/\n+    @Test()\n+    public void baseRowSetTest0013() throws Exception {\n+        Calendar cal = Calendar.getInstance();\n+        brs = new StubBaseRowSet();\n+        brs.setDate(1, Date.valueOf(LocalDate.now()), cal);\n+        assertTrue(checkCalendarParam(1, cal));\n+    }\n+\n+    \/*\n+     *  Validate that setTime sets the specified Calendar internally\n+     *\/\n+    @Test()\n+    public void baseRowSetTest0014() throws Exception {\n+        Calendar cal = Calendar.getInstance();\n+        brs = new StubBaseRowSet();\n+        brs.setTime(1, Time.valueOf(LocalTime.now()), cal);\n+        assertTrue(checkCalendarParam(1, cal));\n+    }\n+\n+    \/*\n+     *  Validate that setTimestamp sets the specified Calendar internally\n+     *\/\n+    @Test()\n+    public void baseRowSetTest0015() throws Exception {\n+        Calendar cal = Calendar.getInstance();\n+        brs = new StubBaseRowSet();\n+        brs.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now()), cal);\n+        assertTrue(checkCalendarParam(1, cal));\n+    }\n+\n+    \/*\n+     * Validate that initParams() initializes the parameters\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void baseRowSetTest0016(StubBaseRowSet rs) throws Exception {\n+        rs.setInt(1, 1);\n+        rs.initParams();\n+        assertTrue(rs.getParams().length == 0);\n+    }\n+\n+\n+    \/*\n+     * DataProvider used to set parameters for basic types that are supported\n+     *\/\n+    private Stream<Arguments> testBaseParameters() throws SQLException {\n+        Integer aInt = 1;\n+        Long aLong = Long.MAX_VALUE;\n+        Short aShort = Short.MIN_VALUE;\n+        BigDecimal bd = BigDecimal.ONE;\n+        Double aDouble = Double.MAX_VALUE;\n+        Date aDate = Date.valueOf(LocalDate.now());\n+        Time aTime = Time.valueOf(LocalTime.now());\n+        Timestamp aTimeStamp = Timestamp.valueOf(LocalDateTime.now());\n+        Calendar cal = Calendar.getInstance();\n+        Boolean aBoolean = true;\n+        Float aFloat = 1.5f;\n+        Byte aByte = 1;\n+        brs = new StubBaseRowSet();\n+\n+        brs.setInt(1, aInt);\n+        brs.setString(2, query);\n+        brs.setLong(3, aLong);\n+        brs.setBoolean(4, aBoolean);\n+        brs.setShort(5, aShort);\n+        brs.setDouble(6, aDouble);\n+        brs.setBigDecimal(7, bd);\n+        brs.setFloat(8, aFloat);\n+        brs.setByte(9, aByte);\n+        brs.setDate(10, aDate);\n+        brs.setTime(11, aTime);\n+        brs.setTimestamp(12, aTimeStamp);\n+        brs.setDate(13, aDate, cal);\n+        brs.setTime(14, aTime, cal);\n+        brs.setTimestamp(15, aTimeStamp);\n+        brs.setObject(16, query);\n+        brs.setObject(17, query, Types.CHAR);\n+        brs.setObject(18, query, Types.CHAR, 0);\n+\n+        return Stream.of(\n+            Arguments.of(1, aInt),\n+            Arguments.of(2, query),\n+            Arguments.of(3, aLong),\n+            Arguments.of(4, aBoolean),\n+            Arguments.of(5, aShort),\n+            Arguments.of(6, aDouble),\n+            Arguments.of(7, bd),\n+            Arguments.of(8, aFloat),\n+            Arguments.of(9, aByte),\n+            Arguments.of(10, aDate),\n+            Arguments.of(11, aTime),\n+            Arguments.of(12, aTimeStamp),\n+            Arguments.of(13, aDate),\n+            Arguments.of(14, aTime),\n+            Arguments.of(15, aTimeStamp),\n+            Arguments.of(16, query),\n+            Arguments.of(17, query),\n+            Arguments.of(18, query)\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to set advanced parameters for types that are supported\n+     *\/\n+    private Stream<Arguments> testAdvancedParameters() throws SQLException {\n+\n+        byte[] bytes = new byte[10];\n+        Ref aRef = new SerialRef(new StubRef(\"INTEGER\", query));\n+        Array aArray = new SerialArray(new StubArray(\"INTEGER\", new Object[1]));\n+        Blob aBlob = new SerialBlob(new StubBlob());\n+        Clob aClob = new SerialClob(new StubClob());\n+        Reader rdr = new StringReader(query);\n+        InputStream is = new StringBufferInputStream(query);\n+        brs = new StubBaseRowSet();\n+        brs.setBytes(1, bytes);\n+        brs.setAsciiStream(2, is, query.length());\n+        brs.setRef(3, aRef);\n+        brs.setArray(4, aArray);\n+        brs.setBlob(5, aBlob);\n+        brs.setClob(6, aClob);\n+        brs.setBinaryStream(7, is, query.length());\n+        brs.setUnicodeStream(8, is, query.length());\n+        brs.setCharacterStream(9, rdr, query.length());\n+\n+        return Stream.of(\n+            Arguments.of(1, bytes),\n+            Arguments.of(2, is),\n+            Arguments.of(3, aRef),\n+            Arguments.of(4, aArray),\n+            Arguments.of(5, aBlob),\n+            Arguments.of(6, aClob),\n+            Arguments.of(7, is),\n+            Arguments.of(8, is),\n+            Arguments.of(9, rdr)\n+        );\n+    }\n+\n+    \/*\n+     *  Method that returns the specified parameter instance that was set via setXXX\n+     *  Note non-basic types are stored as an Object[] where the 1st element\n+     *  is the object instnace\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getParam(int pos, T o) throws SQLException {\n+        Object[] params = brs.getParams();\n+        if (params[pos - 1] instanceof Object[]) {\n+            Object[] param = (Object[]) params[pos - 1];\n+            return (T) param[0];\n+        } else {\n+            return (T) params[pos - 1];\n+        }\n+    }\n+\n+    \/*\n+     * Utility method to validate parameters when the param is an Object[]\n+     *\/\n+    private boolean checkParam(int pos, int type, Object val) throws SQLException {\n+        boolean result = false;\n+        Object[] params = brs.getParams();\n+        if (params[pos - 1] instanceof Object[]) {\n+            Object[] param = (Object[]) params[pos - 1];\n+\n+            if (param[0] == null) {\n+                \/\/ setNull was used\n+                if (param.length == 2 && (Integer) param[1] == type) {\n+                    result = true;\n+                } else {\n+                    if (param.length == 3 && (Integer) param[1] == type\n+                            && val.equals(param[2])) {\n+                        result = true;\n+                    }\n+                }\n+\n+            } else if (param[0] instanceof java.util.Date) {\n+                \/\/ setDate\/Time\/Timestamp with a Calendar object\n+                if (param[1] instanceof Calendar && val.equals(param[1])) {\n+                    result = true;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/*\n+     * Wrapper method for validating that a null was set and the appropriate\n+     * type and typeName if applicable\n+     *\/\n+    private boolean checkNullParam(int pos, int type, String typeName) throws SQLException {\n+        return checkParam(pos, type, typeName);\n+    }\n+\n+    \/*\n+     *  Wrapper method for validating that a Calander was set\n+     *\/\n+    private boolean checkCalendarParam(int pos, Calendar cal) throws SQLException {\n+        \/\/ 2nd param is ignored when instanceof java.util.Date\n+        return checkParam(pos, Types.DATE, cal);\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/BaseRowSetTests.java","additions":460,"deletions":0,"binary":false,"changes":460,"status":"added"},{"patch":"@@ -0,0 +1,1459 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset;\n+\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.math.BigDecimal;\n+import java.sql.Connection;\n+import java.sql.Date;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.RowId;\n+import java.sql.SQLException;\n+import java.sql.SQLFeatureNotSupportedException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Stream;\n+import javax.sql.RowSet;\n+import javax.sql.rowset.BaseRowSet;\n+import javax.sql.rowset.CachedRowSet;\n+import javax.sql.rowset.RowSetFactory;\n+import javax.sql.rowset.RowSetMetaDataImpl;\n+import javax.sql.rowset.RowSetProvider;\n+\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import util.BaseTest;\n+import util.StubBlob;\n+import util.StubClob;\n+import util.StubNClob;\n+import util.StubSQLXML;\n+\n+public abstract class CommonRowSetTests extends BaseTest {\n+\n+    protected final String stubProvider = \"util.StubSyncProvider\";\n+    protected final String query = \"SELECT * FROM SUPERHEROS\";\n+    private final String url = \"jdbc:derby:\/\/localhost:1527\/myDB\";\n+    private final String dsName = \"jdbc\/myDB\";\n+    private final String user = \"Bruce Wayne\";\n+    private final String password = \"The Dark Knight\";\n+    protected final String COFFEE_HOUSES_TABLE = \"COFFEE_HOUSES\";\n+    protected final String COFFEES_TABLE = \"COFFEES\";\n+    protected final int COFFEE_HOUSES_ROWS = 14;\n+    protected final int COFFEES_ROWS = 5;\n+    protected final Object[] COFFEES_PRIMARY_KEYS = {1, 2, 3, 4, 5};\n+    protected final Object[] COFFEE_HOUSES_PRIMARY_KEYS = {\n+        10023, 33002, 10040, 32001, 10042, 10024, 10039, 10041,\n+        33005, 33010, 10035, 10037, 10034, 32004\n+    };\n+\n+    \/*\n+     * COFFEES_HOUSES Table column names\n+     *\/\n+    protected final String[] COFFEE_HOUSES_COLUMN_NAMES = {\n+        \"STORE_ID\", \"CITY\", \"COFFEE\", \"MERCH\", \"TOTAL\"\n+    };\n+\n+    \/*\n+     * COFFEES Table column names\n+     *\/\n+    protected final String[] COFFEES_COLUMN_NAMES = {\n+        \"COF_ID\", \"COF_NAME\", \"SUP_ID\", \"PRICE\", \"SALES\", \"TOTAL\"\n+    };\n+\n+    protected RowSetFactory rsf;\n+\n+    public CommonRowSetTests() {\n+        try {\n+            rsf = RowSetProvider.newFactory();\n+        } catch (SQLException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    \/\/ Create an instance of the RowSet we are using\n+    protected abstract <T extends RowSet> T newInstance() throws SQLException;\n+\n+    \/\/DataProvider to use for common tests\n+\n+    \/*\n+     * DataProvider used to specify the value to set and check for the\n+     * methods for fetch direction\n+     *\/\n+    protected Stream<Arguments> rowSetFetchDirection() throws Exception {\n+        RowSet rs = newInstance();\n+        return Stream.of(\n+            Arguments.of(rs, ResultSet.FETCH_FORWARD),\n+            Arguments.of(rs, ResultSet.FETCH_REVERSE),\n+            Arguments.of(rs, ResultSet.FETCH_UNKNOWN)\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to specify the value to set and check for the\n+     * methods for Cursor Scroll Type\n+     *\/\n+    protected Stream<Arguments> rowSetScrollTypes() throws Exception {\n+        RowSet rs = newInstance();\n+\n+        return Stream.of(\n+            Arguments.of(rs, ResultSet.TYPE_FORWARD_ONLY),\n+            Arguments.of(rs, ResultSet.TYPE_SCROLL_INSENSITIVE),\n+            Arguments.of(rs, ResultSet.TYPE_SCROLL_SENSITIVE)\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to specify the value to set and check for\n+     * methods using transaction isolation types\n+     *\/\n+    protected Stream<Arguments> rowSetIsolationTypes() throws Exception {\n+        RowSet rs = newInstance();\n+\n+        return Stream.of(\n+            Arguments.of(rs, Connection.TRANSACTION_NONE),\n+            Arguments.of(rs, Connection.TRANSACTION_READ_COMMITTED),\n+            Arguments.of(rs, Connection.TRANSACTION_READ_UNCOMMITTED),\n+            Arguments.of(rs, Connection.TRANSACTION_REPEATABLE_READ),\n+            Arguments.of(rs, Connection.TRANSACTION_SERIALIZABLE)\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to specify the value to set and check for the\n+     * methods for Concurrency\n+     *\/\n+    protected Stream<Arguments> rowSetConcurrencyTypes() throws Exception {\n+        RowSet rs = newInstance();\n+        return Stream.of(\n+            Arguments.of(rs, ResultSet.CONCUR_READ_ONLY),\n+            Arguments.of(rs, ResultSet.CONCUR_UPDATABLE)\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to specify the value to set and check for\n+     * methods using boolean values\n+     *\/\n+    protected Stream<Arguments> rowSetTrueFalse() throws Exception {\n+        RowSet rs = newInstance();\n+        return Stream.of(\n+            Arguments.of(rs, true),\n+            Arguments.of(rs, false)\n+        );\n+    }\n+    \/*\n+     * DataProvider used to specify the type of RowSet to use.  We also must\n+     * initialize the RowSet\n+     *\/\n+    protected Stream<RowSet> rowSetType() throws Exception {\n+\n+        RowSet rs = newInstance();\n+        return Stream.of(rs);\n+    }\n+\n+    \/*\n+     * Initializes a RowSet containing the COFFEE_HOUSES data\n+     *\/\n+    protected <T extends RowSet> T createCoffeeHousesRowSet() throws SQLException {\n+        T rs = (T) newInstance();\n+        initCoffeeHousesMetaData((CachedRowSet) rs);\n+        createCoffeeHouseRows(rs);\n+        \/\/ Make sure you are not on the insertRow\n+        rs.moveToCurrentRow();\n+        return rs;\n+    }\n+\n+    \/*\n+     * Initializes a RowSet containing the COFFEE_HOUSES data\n+     *\/\n+    protected <T extends RowSet> T createCoffeesRowSet() throws SQLException {\n+        T rs = (T) newInstance();\n+        initCoffeesMetaData((CachedRowSet) rs);\n+        createCoffeesRows(rs);\n+        \/\/ Make sure you are not on the insertRow\n+        rs.moveToCurrentRow();\n+        return rs;\n+    }\n+\n+    \/*\n+     * Initializes the COFFEE_HOUSES metadata\n+     *\/\n+    private void initCoffeeHousesMetaData(CachedRowSet crs) throws SQLException {\n+        RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();\n+        crs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n+\n+        \/*\n+         *  CREATE TABLE COFFEE_HOUSES(\n+         *   STORE_ID Integer NOT NULL,\n+         *   CITY VARCHAR(32),\n+         *   COFFEE INTEGER NOT NULL,\n+         *   MERCH INTEGER NOT NULL,\n+         *   TOTAL INTEGER NOT NULL,\n+         *   PRIMARY KEY (STORE_ID))\n+         *\/\n+        rsmd.setColumnCount(COFFEE_HOUSES_COLUMN_NAMES.length);\n+        for(int i = 1; i <= COFFEE_HOUSES_COLUMN_NAMES.length; i++){\n+            rsmd.setColumnName(i, COFFEE_HOUSES_COLUMN_NAMES[i-1]);\n+            rsmd.setColumnLabel(i, rsmd.getColumnName(i));\n+        }\n+\n+        rsmd.setColumnType(1, Types.INTEGER);\n+        rsmd.setColumnType(2, Types.VARCHAR);\n+        rsmd.setColumnType(3, Types.INTEGER);\n+        rsmd.setColumnType(4, Types.INTEGER);\n+        rsmd.setColumnType(5, Types.INTEGER);\n+        crs.setMetaData(rsmd);\n+        crs.setTableName(COFFEE_HOUSES_TABLE);\n+\n+    }\n+\n+    \/*\n+     * Add rows to COFFEE_HOUSES table\n+     *\/\n+    protected void createCoffeeHouseRows(RowSet rs) throws SQLException {\n+\n+        \/\/ insert into COFFEE_HOUSES values(10023, 'Mendocino', 3450, 2005, 5455)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 10023);\n+        rs.updateString(2, \"Mendocino\");\n+        rs.updateInt(3, 3450);\n+        rs.updateInt(4, 2005);\n+        rs.updateInt(5, 5455);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(33002, 'Seattle', 4699, 3109, 7808)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 33002);\n+        rs.updateString(2, \"Seattle\");\n+        rs.updateInt(3, 4699);\n+        rs.updateInt(4, 3109);\n+        rs.updateInt(5, 7808);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(10040, 'SF', 5386, 2841, 8227)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 10040);\n+        rs.updateString(2, \"SF\");\n+        rs.updateInt(3, 5386);\n+        rs.updateInt(4, 2841);\n+        rs.updateInt(5, 8227);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(32001, 'Portland', 3147, 3579, 6726)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 32001);\n+        rs.updateString(2, \"Portland\");\n+        rs.updateInt(3, 3147);\n+        rs.updateInt(4, 3579);\n+        rs.updateInt(5, 6726);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(10042, 'SF', 2863, 1874, 4710)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 10042);\n+        rs.updateString(2, \"SF\");\n+        rs.updateInt(3, 2863);\n+        rs.updateInt(4, 1874);\n+        rs.updateInt(5, 4710);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(10024, 'Sacramento', 1987, 2341, 4328)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 10024);\n+        rs.updateString(2, \"Sacramento\");\n+        rs.updateInt(3, 1987);\n+        rs.updateInt(4, 2341);\n+        rs.updateInt(5, 4328);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(10039, 'Carmel', 2691, 1121, 3812)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 10039);\n+        rs.updateString(2, \"Carmel\");\n+        rs.updateInt(3, 2691);\n+        rs.updateInt(4, 1121);\n+        rs.updateInt(5, 3812);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(10041, 'LA', 1533, 1007, 2540)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 10041);\n+        rs.updateString(2, \"LA\");\n+        rs.updateInt(3, 1533);\n+        rs.updateInt(4, 1007);\n+        rs.updateInt(5, 2540);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(33005, 'Olympia', 2733, 1550, 1550)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 33005);\n+        rs.updateString(2, \"Olympia\");\n+        rs.updateInt(3, 2733);\n+        rs.updateInt(4, 1550);\n+        rs.updateInt(5, 1550);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(33010, 'Seattle', 3210, 2177, 5387)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 33010);\n+        rs.updateString(2, \"Seattle\");\n+        rs.updateInt(3, 3210);\n+        rs.updateInt(4, 2177);\n+        rs.updateInt(5, 5387);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(10035, 'SF', 1922, 1056, 2978)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 10035);\n+        rs.updateString(2, \"SF\");\n+        rs.updateInt(3, 1922);\n+        rs.updateInt(4, 1056);\n+        rs.updateInt(5, 2978);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(10037, 'LA', 2143, 1876, 4019)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 10037);\n+        rs.updateString(2, \"LA\");\n+        rs.updateInt(3, 2143);\n+        rs.updateInt(4, 1876);\n+        rs.updateInt(5, 4019);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(10034, 'San_Jose', 1234, 1032, 2266)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 10034);\n+        rs.updateString(2, \"San Jose\");\n+        rs.updateInt(3, 1234);\n+        rs.updateInt(4, 1032);\n+        rs.updateInt(5, 2266);\n+        rs.insertRow();\n+        \/\/ insert into COFFEE_HOUSES values(32004, 'Eugene', 1356, 1112, 2468)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 32004);\n+        rs.updateString(2, \"Eugene\");\n+        rs.updateInt(3, 1356);\n+        rs.updateInt(4, 1112);\n+        rs.updateInt(5, 2468);\n+        rs.insertRow();\n+        rs.moveToCurrentRow();\n+    }\n+\n+    \/*\n+     * Initializes the COFFEES metadata\n+     *\/\n+    protected void initCoffeesMetaData(CachedRowSet crs) throws SQLException {\n+        RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();\n+        crs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n+\n+        \/*\n+         *  CREATE TABLE COFFEES (\n+         *   COF_ID INTEGER NOT NULL,\n+         *   COF_NAME VARCHAR(32) NOT NULL,\n+         *   SUP_ID INTEGER NOT NULL,\n+         *   PRICE NUMBERIC(10,2 NOT NULL,\n+         *   SALES INTEGER NOT NULL,\n+         *   TOTAL INTEGER NOT NULL,\n+         *   PRIMARY KEY (COF_ID),\n+         *   FOREIGN KEY (SUP_ID) REFERENCES SUPPLIERS (SUP_ID) )\n+         *\/\n+        rsmd.setColumnCount(COFFEES_COLUMN_NAMES.length);\n+        for(int i = 1; i <= COFFEES_COLUMN_NAMES.length; i++){\n+            rsmd.setColumnName(i, COFFEES_COLUMN_NAMES[i-1]);\n+            rsmd.setColumnLabel(i, rsmd.getColumnName(i));\n+        }\n+\n+        rsmd.setColumnType(1, Types.INTEGER);\n+        rsmd.setColumnType(2, Types.VARCHAR);\n+        rsmd.setColumnType(3, Types.INTEGER);\n+        rsmd.setColumnType(4, Types.NUMERIC);\n+        rsmd.setPrecision(4, 10);\n+        rsmd.setScale(4, 2);\n+        rsmd.setColumnType(5, Types.INTEGER);\n+        rsmd.setColumnType(6, Types.INTEGER);\n+        crs.setMetaData(rsmd);\n+        crs.setTableName(COFFEES_TABLE);\n+\n+    }\n+\n+    \/*\n+     * Add rows to COFFEES table\n+     *\/\n+    protected void createCoffeesRows(RowSet rs) throws SQLException {\n+\n+        \/\/ insert into COFFEES values(1, 'Colombian', 101, 7.99, 0, 0)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 1);\n+        rs.updateString(2, \"Colombian\");\n+        rs.updateInt(3, 101);\n+        rs.updateBigDecimal(4, BigDecimal.valueOf(7.99));\n+        rs.updateInt(5, 0);\n+        rs.updateInt(6, 0);\n+        rs.insertRow();\n+        \/\/ insert into COFFEES values(2, 'French_Roast', 49, 8.99, 0, 0)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 2);\n+        rs.updateString(2, \"French_Roast\");\n+        rs.updateInt(3, 49);\n+        rs.updateBigDecimal(4, BigDecimal.valueOf(8.99));\n+        rs.updateInt(5, 0);\n+        rs.updateInt(6, 0);\n+        rs.insertRow();\n+        \/\/ insert into COFFEES values(3, 'Espresso', 150, 9.99, 0, 0)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 3);\n+        rs.updateString(2, \"Espresso\");\n+        rs.updateInt(3, 150);\n+        rs.updateBigDecimal(4, BigDecimal.valueOf(9.99));\n+        rs.updateInt(5, 0);\n+        rs.updateInt(6, 0);\n+        rs.insertRow();\n+        \/\/ insert into COFFEES values(4, 'Colombian_Decaf', 101, 8.99, 0, 0)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 4);\n+        rs.updateString(2, \"Colombian_Decaf\");\n+        rs.updateInt(3, 101);\n+        rs.updateBigDecimal(4, BigDecimal.valueOf(8.99));\n+        rs.updateInt(5, 0);\n+        rs.updateInt(6, 0);\n+        rs.insertRow();\n+        \/\/ insert into COFFEES values(5, 'French_Roast_Decaf', 049, 9.99, 0, 0)\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 5);\n+        rs.updateString(2, \"French_Roast_Decaf\");\n+        rs.updateInt(3, 49);\n+        rs.updateBigDecimal(4, BigDecimal.valueOf(9.99));\n+        rs.updateInt(5, 0);\n+        rs.updateInt(6, 0);\n+        rs.insertRow();\n+\n+    }\n+\n+\n+    \/*\n+     * Utility method to return the Primary Keys for a RowSet.  The Primary\n+     * keys are assumed to be in the first column of the RowSet\n+     *\/\n+    protected Object[] getPrimaryKeys(ResultSet rs) throws SQLException {\n+        List<? super Object> result = new ArrayList<>();\n+        if (rs == null) {\n+            return null;\n+        }\n+        rs.beforeFirst();\n+        while (rs.next()) {\n+            result.add(rs.getInt(1));\n+        }\n+        return result.toArray();\n+    }\n+\n+    \/*\n+     * Utility method to display the RowSet and will return the row count\n+     * it found\n+     *\/\n+    protected int displayResults(ResultSet rs) throws SQLException {\n+        int rows = 0;\n+        ResultSetMetaData rsmd = rs.getMetaData();\n+        int cols = rsmd.getColumnCount();\n+        if (rs != null) {\n+            rs.beforeFirst();\n+            while (rs.next()) {\n+                rows++;\n+\n+                for (int i = 0; i < cols; i++) {\n+                    System.out.print(rs.getString(i + 1) + \" \");\n+                }\n+                System.out.println();\n+            }\n+        }\n+\n+        return rows;\n+    }\n+\n+\n+     \/\/ Insert common tests here\n+\n+    \/*\n+     * Validate that getCommand() returns null by default\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0000(RowSet rs) {\n+        assertNull(rs.getCommand());\n+    }\n+\n+    \/*\n+     * Validate that getCommand() returns command specified to setCommand\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0001(RowSet rs) throws Exception {\n+        rs.setCommand(query);\n+        assertTrue(rs.getCommand().equals(query));\n+    }\n+\n+\n+    \/*\n+     * Validate that getCurrency() returns the correct default value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0002(RowSet rs) throws Exception {\n+        assertTrue(rs.getConcurrency() == ResultSet.CONCUR_UPDATABLE);\n+    }\n+\n+    \/*\n+     * Validate that getCurrency() returns the correct value\n+     * after a call to setConcurrency())\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetConcurrencyTypes\")\n+    public void commonRowSetTest0003(RowSet rs, int concurType) throws Exception {\n+        rs.setConcurrency(concurType);\n+        assertTrue(rs.getConcurrency() == concurType);\n+    }\n+\n+    \/*\n+     * Validate that getCurrency() throws a SQLException for an invalid value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0004(RowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> rs.setConcurrency(ResultSet.CLOSE_CURSORS_AT_COMMIT));\n+    }\n+\n+    \/*\n+     * Validate that getDataSourceName() returns null by default\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0005(RowSet rs) throws Exception {\n+        assertTrue(rs.getDataSourceName() == null);\n+    }\n+\n+    \/*\n+     * Validate that getDataSourceName() returns the value specified\n+     * by setDataSourceName() and getUrl() returns null\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0006(RowSet rs) throws Exception {\n+        rs.setUrl(url);\n+        rs.setDataSourceName(dsName);\n+        assertTrue(rs.getDataSourceName().equals(dsName));\n+        assertNull(rs.getUrl());\n+    }\n+\n+    \/*\n+     * Validate that setDataSourceName() throws a SQLException for an empty\n+     * String specified for the data source name\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0007(RowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            String dsname = \"\";\n+            rs.setDataSourceName(dsname);\n+        });\n+    }\n+\n+    \/*\n+     * Validate that getEscapeProcessing() returns false by default\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0008(RowSet rs) throws Exception {\n+        assertTrue(rs.getEscapeProcessing());\n+    }\n+\n+    \/*\n+     * Validate that getEscapeProcessing() returns value set by\n+     * setEscapeProcessing()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetTrueFalse\")\n+    public void commonRowSetTest0009(RowSet rs, boolean val) throws Exception {\n+        rs.setEscapeProcessing(val);\n+        assertTrue(rs.getEscapeProcessing() == val);\n+    }\n+\n+    \/*\n+     * Validate that getFetchDirection() returns the correct default value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0010(RowSet rs) throws Exception {\n+        assertTrue(rs.getFetchDirection() == ResultSet.FETCH_FORWARD);\n+    }\n+\n+    \/*\n+     * Validate that getFetchDirection() returns the value set by\n+     * setFetchDirection()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetFetchDirection\")\n+    public void commonRowSetTest0011(RowSet rs, int direction) throws Exception {\n+        rs.setFetchDirection(direction);\n+        assertTrue(rs.getFetchDirection() == direction);\n+    }\n+\n+    \/*\n+     * Validate that setFetchSize() throws a SQLException for an invalid value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0013(RowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> rs.setFetchSize(-1));\n+    }\n+\n+    \/*\n+     * Validate that setFetchSize() throws a SQLException for a\n+     * value greater than getMaxRows()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0014(RowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setMaxRows(5);\n+            rs.setFetchSize(rs.getMaxRows() + 1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate that getFetchSize() returns the correct value after\n+     * setFetchSize() has been called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0015(RowSet rs) throws Exception {\n+        int maxRows = 150;\n+        rs.setFetchSize(0);\n+        assertTrue(rs.getFetchSize() == 0);\n+        rs.setFetchSize(100);\n+        assertTrue(rs.getFetchSize() == 100);\n+        rs.setMaxRows(maxRows);\n+        rs.setFetchSize(maxRows);\n+        assertTrue(rs.getFetchSize() == maxRows);\n+    }\n+\n+    \/*\n+     * Validate that setMaxFieldSize() throws a SQLException for an invalid value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0016(RowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> rs.setMaxFieldSize(-1));\n+    }\n+\n+    \/*\n+     * Validate that getMaxFieldSize() returns the value set by\n+     * setMaxFieldSize()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0017(RowSet rs) throws Exception {\n+        rs.setMaxFieldSize(0);\n+        assertTrue(rs.getMaxFieldSize() == 0);\n+        rs.setMaxFieldSize(100);\n+        assertTrue(rs.getMaxFieldSize() == 100);\n+        rs.setMaxFieldSize(50);\n+        assertTrue(rs.getMaxFieldSize() == 50);\n+    }\n+\n+    \/*\n+     * Validate that isReadOnly() returns value set by\n+     * setReadOnly()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetTrueFalse\")\n+    public void commonRowSetTest0018(RowSet rs, boolean val) throws Exception {\n+        rs.setReadOnly(val);\n+        assertTrue(rs.isReadOnly() == val);\n+    }\n+\n+    \/*\n+     * Validate that getTransactionIsolation() returns value set by\n+     * setTransactionIsolation()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetIsolationTypes\")\n+    public void commonRowSetTest0019(RowSet rs, int val) throws Exception {\n+        rs.setTransactionIsolation(val);\n+        assertTrue(rs.getTransactionIsolation() == val);\n+    }\n+\n+    \/*\n+     * Validate that getType() returns value set by setType()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetScrollTypes\")\n+    public void commonRowSetTest0020(RowSet rs, int val) throws Exception {\n+        rs.setType(val);\n+        assertTrue(rs.getType() == val);\n+    }\n+\n+    \/*\n+     * Validate that getEscapeProcessing() returns value set by\n+     * setEscapeProcessing()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetTrueFalse\")\n+    public void commonRowSetTest0021(BaseRowSet rs, boolean val) throws Exception {\n+        rs.setShowDeleted(val);\n+        assertTrue(rs.getShowDeleted() == val);\n+    }\n+\n+    \/*\n+     * Validate that getTypeMap() returns same value set by\n+     * setTypeMap()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0022(RowSet rs) throws Exception {\n+        Map<String, Class<?>> map = new HashMap<>();\n+        map.put(\"SUPERHERO\", Class.forName(\"util.SuperHero\"));\n+        rs.setTypeMap(map);\n+        assertTrue(rs.getTypeMap().equals(map));\n+    }\n+\n+    \/*\n+     * Validate that getUsername() returns same value set by\n+     * setUsername()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0023(RowSet rs) throws Exception {\n+        rs.setUsername(user);\n+        assertTrue(rs.getUsername().equals(user));\n+    }\n+\n+    \/*\n+     * Validate that getPassword() returns same password set by\n+     * setPassword()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0024(RowSet rs) throws Exception {\n+        rs.setPassword(password);\n+        assertTrue(rs.getPassword().equals(password));\n+    }\n+\n+    \/*\n+     * Validate that getQueryTimeout() returns same value set by\n+     * setQueryTimeout() and that 0 is a valid timeout value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0025(RowSet rs) throws Exception {\n+        int timeout = 0;\n+        rs.setQueryTimeout(timeout);\n+        assertTrue(rs.getQueryTimeout() == timeout);\n+    }\n+\n+    \/*\n+     * Validate that getQueryTimeout() returns same value set by\n+     * setQueryTimeout() and that 0 is a valid timeout value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0026(RowSet rs) throws Exception {\n+        int timeout = 10000;\n+        rs.setQueryTimeout(timeout);\n+        assertTrue(rs.getQueryTimeout() == timeout);\n+    }\n+\n+    \/*\n+     * Validate that setQueryTimeout() throws a SQLException for a timeout\n+     * value < 0\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0027(RowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> rs.setQueryTimeout(-1));\n+    }\n+\n+\n+    \/*\n+     * Validate addRowSetListener does not throw an Exception when null is\n+     * passed as the parameter\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0028(RowSet rs) throws Exception {\n+        rs.addRowSetListener(null);\n+    }\n+\n+    \/*\n+     * Validate removeRowSetListener does not throw an Exception when null is\n+     * passed as the parameter\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0029(RowSet rs) throws Exception {\n+        rs.removeRowSetListener(null);\n+    }\n+\n+    \/*\n+     * Set two parameters and then validate clearParameters() will clear them\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0030(BaseRowSet rs) throws Exception {\n+        rs.setInt(1, 1);\n+        rs.setString(2, query);\n+        assertTrue(rs.getParams().length == 2);\n+        rs.clearParameters();\n+        assertTrue(rs.getParams().length == 0);\n+    }\n+\n+    \/*\n+     * Validate that getURL() returns same value set by\n+     * setURL()\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0031(RowSet rs) throws Exception {\n+        rs.setUrl(url);\n+        assertTrue(rs.getUrl().equals(url));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0100(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            InputStream is = null;\n+            rs.setAsciiStream(1, is);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0101(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            InputStream is = null;\n+            rs.setAsciiStream(\"one\", is);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0102(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            InputStream is = null;\n+            rs.setAsciiStream(\"one\", is, query.length());\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0103(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            InputStream is = null;\n+            rs.setBinaryStream(1, is);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0104(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            InputStream is = null;\n+            rs.setBinaryStream(\"one\", is);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0105(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            InputStream is = null;\n+            rs.setBinaryStream(\"one\", is, query.length());\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0106(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setBigDecimal(\"one\", BigDecimal.ONE));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0107(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            InputStream is = null;\n+            rs.setBlob(1, is);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0108(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            InputStream is = null;\n+            rs.setBlob(\"one\", is);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0109(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            InputStream is = null;\n+            rs.setBlob(\"one\", is, query.length());\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0110(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setBlob(\"one\", new StubBlob()));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0111(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setBoolean(\"one\", true));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0112(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            byte b = 1;\n+            rs.setByte(\"one\", b);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0113(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            byte b = 1;\n+            rs.setBytes(\"one\", new byte[10]);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0114(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setCharacterStream(\"one\", rdr, query.length());\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0115(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setCharacterStream(\"one\", rdr);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0116(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setCharacterStream(1, rdr);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0117(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setClob(1, rdr);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0118(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setClob(\"one\", rdr);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0119(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setClob(\"one\", rdr, query.length());\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0120(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setClob(\"one\", new StubClob()));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0121(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setDate(\"one\", Date.valueOf(LocalDate.now())));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0122(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setDate(\"one\", Date.valueOf(LocalDate.now()),\n+                Calendar.getInstance()));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0123(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setTime(\"one\", Time.valueOf(LocalTime.now())));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0124(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setTime(\"one\", Time.valueOf(LocalTime.now()),\n+                Calendar.getInstance()));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0125(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setTimestamp(\"one\", Timestamp.valueOf(LocalDateTime.now())));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0126(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setTimestamp(\"one\", Timestamp.valueOf(LocalDateTime.now()),\n+                Calendar.getInstance()));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0127(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setDouble(\"one\", 2.0d));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0128(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setFloat(\"one\", 2.0f));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0129(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setInt(\"one\", 21));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0130(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setLong(\"one\", 21l));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0131(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setNCharacterStream(\"one\", rdr, query.length());\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0132(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setNCharacterStream(\"one\", rdr);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0133(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setNCharacterStream(1, rdr);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0134(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setNCharacterStream(1, rdr, query.length());\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0135(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setClob(\"one\", rdr);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0136(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setClob(\"one\", rdr, query.length());\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0137(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setNClob(\"one\", new StubNClob()));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0138(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setNClob(1, rdr);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0139(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            Reader rdr = null;\n+            rs.setNClob(1, rdr, query.length());\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0140(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setNClob(1, new StubNClob()));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0141(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setNString(1, query));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0142(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setNull(\"one\", Types.INTEGER));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0143(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setNull(\"one\", Types.INTEGER, \"my.type\"));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0144(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setObject(\"one\", query, Types.VARCHAR));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0145(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setObject(\"one\", query, Types.VARCHAR, 0));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0146(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setObject(\"one\", query));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0147(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            RowId aRowid = null;\n+            rs.setRowId(\"one\", aRowid);\n+        });\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0148(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setSQLXML(\"one\", new StubSQLXML()));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0149(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setSQLXML(1, new StubSQLXML()));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0150(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setNString(1, query));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0151(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> rs.setNString(\"one\", query));\n+    }\n+\n+    \/*\n+     * This method is currently not implemented in BaseRowSet and will\n+     * throw a SQLFeatureNotSupportedException\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonRowSetTest0152(RowSet rs) throws Exception {\n+        assertThrows(SQLFeatureNotSupportedException.class, () -> {\n+            short val = 21;\n+            rs.setShort(\"one\", val);\n+        });\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/CommonRowSetTests.java","additions":1459,"deletions":0,"binary":false,"changes":1459,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset;\n+\n+import java.sql.SQLException;\n+import java.util.stream.Stream;\n+import javax.sql.rowset.RowSetFactory;\n+import javax.sql.rowset.RowSetProvider;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import util.BaseTest;\n+\n+public class RowSetFactoryTests extends BaseTest {\n+\n+    \/\/ RowSet implementations that we are testing for\n+    private final String DEFAULT_CACHEDROWSET_CLASSNAME = \"com.sun.rowset.CachedRowSetImpl\";\n+    private final String DEFAULT_FILTEREDROWSET_CLASSNAME = \"com.sun.rowset.FileteredRowSetImpl\";\n+    private final String DEFAULT_JDBCROWSET_CLASSNAME = \"com.sun.rowset.JdbcRowSetImpl\";\n+    private final String DEFAULT_JOINROWSET_CLASSNAME = \"com.sun.rowset.JoinRowSetImpl\";\n+    private final String DEFAULT_WEBROWSET_CLASSNAME = \"com.sun.rowset.WebRowSetImpl\";\n+    private final String STUB_FACTORY_CLASSNAME = \"util.StubRowSetFactory\";\n+    private final String STUB_CACHEDROWSET_CLASSNAME = \"util.StubCachedRowSetImpl\";\n+    private final String STUB_FILTEREDROWSET_CLASSNAME = \"util.StubFilteredRowSetImpl\";\n+    private final String STUB_JDBCROWSET_CLASSNAME = \"util.StubJdbcRowSetImpl\";\n+    private final String STUB_JOINROWSET_CLASSNAME = \"util.StubJoinRowSetImpl\";\n+    private final String STUB_WEBROWSET_CLASSNAME = \"util.StubWebRowSetImpl\";\n+\n+\n+    \/*\n+     * Validate that the RowSetFactory returned by RowSetProvider.newFactory()\n+     * returns the correct RowSet implementations\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"RowSetValues\")\n+    public void test(RowSetFactory rsf, String impl) throws SQLException {\n+        validateRowSetImpl(rsf, impl);\n+    }\n+\n+    \/*\n+     * Utility Method to validate the RowsetFactory returns the correct\n+     * RowSet implementation\n+     *\/\n+    private void validateRowSetImpl(RowSetFactory rsf, String implName)\n+            throws SQLException {\n+        assertNotNull(rsf, \"RowSetFactory should not be null\");\n+        switch (implName) {\n+            case DEFAULT_CACHEDROWSET_CLASSNAME:\n+                assertTrue(rsf.createCachedRowSet() instanceof com.sun.rowset.CachedRowSetImpl);\n+                break;\n+            case DEFAULT_FILTEREDROWSET_CLASSNAME:\n+                assertTrue(rsf.createFilteredRowSet() instanceof com.sun.rowset.FilteredRowSetImpl);\n+                break;\n+            case DEFAULT_JDBCROWSET_CLASSNAME:\n+                assertTrue(rsf.createJdbcRowSet() instanceof com.sun.rowset.JdbcRowSetImpl);\n+                break;\n+            case DEFAULT_JOINROWSET_CLASSNAME:\n+                assertTrue(rsf.createJoinRowSet() instanceof com.sun.rowset.JoinRowSetImpl);\n+                break;\n+            case DEFAULT_WEBROWSET_CLASSNAME:\n+                assertTrue(rsf.createWebRowSet() instanceof com.sun.rowset.WebRowSetImpl);\n+                break;\n+            case STUB_CACHEDROWSET_CLASSNAME:\n+                assertTrue(rsf.createCachedRowSet() instanceof util.StubCachedRowSetImpl);\n+                break;\n+            case STUB_FILTEREDROWSET_CLASSNAME:\n+                assertTrue(rsf.createFilteredRowSet() instanceof util.StubFilteredRowSetImpl);\n+                break;\n+            case STUB_JDBCROWSET_CLASSNAME:\n+                assertTrue(rsf.createJdbcRowSet() instanceof util.StubJdbcRowSetImpl);\n+                break;\n+            case STUB_WEBROWSET_CLASSNAME:\n+                assertTrue(rsf.createWebRowSet() instanceof util.StubWebRowSetImpl);\n+                break;\n+        }\n+\n+    }\n+\n+    \/*\n+     * DataProvider used to provide the RowSetFactory and the RowSet\n+     * implementation that should be returned\n+     *\/\n+    private Stream<Arguments> RowSetValues() throws SQLException {\n+        RowSetFactory rsf = RowSetProvider.newFactory();\n+        RowSetFactory rsf1 = RowSetProvider.newFactory(STUB_FACTORY_CLASSNAME, null);\n+        return Stream.of(\n+            Arguments.of(rsf, DEFAULT_CACHEDROWSET_CLASSNAME),\n+            Arguments.of(rsf, DEFAULT_FILTEREDROWSET_CLASSNAME),\n+            Arguments.of(rsf, DEFAULT_JDBCROWSET_CLASSNAME),\n+            Arguments.of(rsf, DEFAULT_JOINROWSET_CLASSNAME),\n+            Arguments.of(rsf, DEFAULT_WEBROWSET_CLASSNAME),\n+            Arguments.of(rsf1, STUB_CACHEDROWSET_CLASSNAME),\n+            Arguments.of(rsf1, STUB_FILTEREDROWSET_CLASSNAME),\n+            Arguments.of(rsf1, STUB_JDBCROWSET_CLASSNAME),\n+            Arguments.of(rsf1, STUB_JOINROWSET_CLASSNAME),\n+            Arguments.of(rsf1, STUB_WEBROWSET_CLASSNAME)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/RowSetFactoryTests.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,556 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset;\n+\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import javax.sql.RowSetMetaData;\n+import javax.sql.rowset.RowSetMetaDataImpl;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import org.junit.jupiter.params.provider.ValueSource;\n+import util.BaseTest;\n+\n+public class RowSetMetaDataTests extends BaseTest {\n+\n+    \/\/ Max columns used in the tests\n+    private final int MAX_COLUMNS = 5;\n+    \/\/ Instance to be used within the tests\n+    private RowSetMetaDataImpl rsmd;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        rsmd = new RowSetMetaDataImpl();\n+        rsmd.setColumnCount(MAX_COLUMNS);\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getCatalogName(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test01(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getColumnClassName(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test02(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getColumnDisplaySize(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test03(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getColumnLabel(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test04(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getColumnName(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test05(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getColumnType(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test06(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getColumnTypeName(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test07(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getPrecision(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test08(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getScale(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test09(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getSchemaName(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test10(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.getTableName(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test11(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.isAutoIncrement(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test12(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.isCaseSensitive(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test13(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.isCurrency(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test14(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.isDefinitelyWritable(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test15(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.isNullable(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test16(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.isReadOnly(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test17(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.isSearchable(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test18(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.isSigned(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test19(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.isWritable(col));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test20(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setAutoIncrement(col, true));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test21(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setCaseSensitive(col, true));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test22(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setCatalogName(col, null));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test23(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setColumnDisplaySize(col, 5));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test24(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setColumnLabel(col, \"label\"));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test25(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setColumnName(col, \"F1\"));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test26(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setColumnType(col, Types.CHAR));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test27(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setColumnTypeName(col, \"F1\"));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test28(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setCurrency(col, true));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test29(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setNullable(col, ResultSetMetaData.columnNoNulls));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test30(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setPrecision(col, 2));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test31(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setScale(col, 2));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test32(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setSchemaName(col, \"Gotham\"));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test33(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setSearchable(col, false));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test34(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setSigned(col, false));\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown for an invalid column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"invalidColumnRanges\")\n+    public void test35(Integer col) throws Exception {\n+        assertThrows(SQLException.class, () -> rsmd.setTableName(col, \"SUPERHEROS\"));\n+    }\n+\n+    \/*\n+     * Validate that the correct class name is returned for the column\n+     * Note:  Once setColumnClassName is added to RowSetMetaData, this\n+     * method will need to change.\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"columnClassNames\")\n+    public void test36(Integer type, String name) throws Exception {\n+        rsmd.setColumnType(1, type);\n+        assertTrue(rsmd.getColumnClassName(1).equals(name));\n+    }\n+\n+    \/*\n+     * Validate that all of the methods are accessible and the correct value\n+     * is returned for each column\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"columnRanges\")\n+    public void test37(Integer col) throws Exception {\n+        rsmd.setAutoIncrement(col, true);\n+        assertTrue(rsmd.isAutoIncrement(col));\n+        rsmd.setCaseSensitive(col, true);\n+        assertTrue(rsmd.isCaseSensitive(col));\n+        rsmd.setCatalogName(col, \"Gotham\");\n+        assertTrue(rsmd.getCatalogName(col).equals(\"Gotham\"));\n+        rsmd.setColumnDisplaySize(col, 20);\n+        assertTrue(rsmd.getColumnDisplaySize(col) == 20);\n+        rsmd.setColumnLabel(col, \"F1\");\n+        assertTrue(rsmd.getColumnLabel(col).equals(\"F1\"));\n+        rsmd.setColumnName(col, \"F1\");\n+        assertTrue(rsmd.getColumnName(col).equals(\"F1\"));\n+        rsmd.setColumnType(col, Types.INTEGER);\n+        assertTrue(rsmd.getColumnType(col) == Types.INTEGER);\n+        assertTrue(rsmd.getColumnClassName(col).equals(Integer.class.getName()));\n+        rsmd.setColumnTypeName(col, \"INTEGER\");\n+        assertTrue(rsmd.getColumnTypeName(col).equals(\"INTEGER\"));\n+        rsmd.setCurrency(col, true);\n+        assertTrue(rsmd.isCurrency(col));\n+        rsmd.setNullable(col, ResultSetMetaData.columnNoNulls);\n+        assertTrue(rsmd.isNullable(col) == ResultSetMetaData.columnNoNulls);\n+        rsmd.setPrecision(col, 2);\n+        assertTrue(rsmd.getPrecision(col) == 2);\n+        rsmd.setScale(col, 2);\n+        assertTrue(rsmd.getScale(col) == 2);\n+        rsmd.setSchemaName(col, \"GOTHAM\");\n+        assertTrue(rsmd.getSchemaName(col).equals(\"GOTHAM\"));\n+        rsmd.setSearchable(col, false);\n+        assertFalse(rsmd.isSearchable(col));\n+        rsmd.setSigned(col, false);\n+        assertFalse(rsmd.isSigned(col));\n+        rsmd.setTableName(col, \"SUPERHEROS\");\n+        assertTrue(rsmd.getTableName(col).equals(\"SUPERHEROS\"));\n+        rsmd.isReadOnly(col);\n+        rsmd.isDefinitelyWritable(col);\n+        rsmd.isWritable(col);\n+\n+    }\n+\n+    \/*\n+     * Validate that the proper values are accepted by setNullable\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"validSetNullableValues\")\n+    public void test38(Integer val) throws Exception {\n+        rsmd.setNullable(1, val);\n+    }\n+\n+    \/*\n+     * Validate that the correct type is returned for the column\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"jdbcTypes\")\n+    public void test39(Integer type) throws Exception {\n+        rsmd.setColumnType(1, type);\n+        assertTrue(type == rsmd.getColumnType(1));\n+    }\n+\n+    \/*\n+     * Validate that the correct value is returned from the isXXX methods\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @ValueSource(booleans = {true, false})\n+    public void test40(Boolean b) throws Exception {\n+        rsmd.setAutoIncrement(1, b);\n+        rsmd.setCaseSensitive(1, b);\n+        rsmd.setCurrency(1, b);\n+        rsmd.setSearchable(1, b);\n+        rsmd.setSigned(1, b);\n+        assertTrue(rsmd.isAutoIncrement(1) == b);\n+        assertTrue(rsmd.isCaseSensitive(1) == b);\n+        assertTrue(rsmd.isCurrency(1) == b);\n+        assertTrue(rsmd.isSearchable(1) == b);\n+        assertTrue(rsmd.isSigned(1) == b);\n+    }\n+\n+    \/*\n+     * Validate isWrapperFor and unwrap work correctly\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void test99() throws Exception {\n+        RowSetMetaData rsmd1 = rsmd;\n+        ResultSetMetaData rsmd2 = rsmd;\n+        Class clzz = rsmd.getClass();\n+        assertTrue(rsmd1.isWrapperFor(clzz));\n+        assertTrue(rsmd2.isWrapperFor(clzz));\n+        RowSetMetaDataImpl rsmdi = (RowSetMetaDataImpl) rsmd2.unwrap(clzz);\n+\n+        \/\/ False should be returned\n+        assertFalse(rsmd1.isWrapperFor(this.getClass()));\n+        assertFalse(rsmd2.isWrapperFor(this.getClass()));\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Date which are not valid and are used\n+     * to validate that an IllegalArgumentException will be thrown from the\n+     * valueOf method\n+     *\/\n+    private Stream<Integer> validSetNullableValues() {\n+        return Stream.of(\n+            ResultSetMetaData.columnNoNulls,\n+            ResultSetMetaData.columnNullable,\n+            ResultSetMetaData.columnNullableUnknown\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to provide column indexes that are out of range so that\n+     * SQLException is thrown\n+     *\/\n+    private Stream<Integer> invalidColumnRanges() {\n+        return Stream.of(\n+            -1,\n+            0,\n+            MAX_COLUMNS + 1\n+        );\n+    }\n+\n+    \/*\n+     * DataProvider used to provide the valid column ranges for the\n+     * RowSetMetaDataImpl object\n+     *\/\n+    private Stream<Integer> columnRanges() {\n+        return IntStream.rangeClosed(1, MAX_COLUMNS).boxed();\n+    }\n+\n+    \/*\n+     * DataProvider used to specify the value to set via setColumnType and\n+     * the expected value to be returned from getColumnClassName\n+     *\/\n+    private Stream<Arguments> columnClassNames() {\n+        return Stream.of(\n+            Arguments.of(Types.CHAR, \"java.lang.String\"),\n+            Arguments.of(Types.NCHAR, \"java.lang.String\"),\n+            Arguments.of(Types.VARCHAR, \"java.lang.String\"),\n+            Arguments.of(Types.NVARCHAR, \"java.lang.String\"),\n+            Arguments.of(Types.LONGVARCHAR, \"java.lang.String\"),\n+            Arguments.of(Types.LONGNVARCHAR, \"java.lang.String\"),\n+            Arguments.of(Types.NUMERIC, \"java.math.BigDecimal\"),\n+            Arguments.of(Types.DECIMAL, \"java.math.BigDecimal\"),\n+            Arguments.of(Types.BIT, \"java.lang.Boolean\"),\n+            Arguments.of(Types.TINYINT, \"java.lang.Byte\"),\n+            Arguments.of(Types.SMALLINT, \"java.lang.Short\"),\n+            Arguments.of(Types.INTEGER, \"java.lang.Integer\"),\n+            Arguments.of(Types.FLOAT, \"java.lang.Double\"),\n+            Arguments.of(Types.DOUBLE, \"java.lang.Double\"),\n+            Arguments.of(Types.BINARY, \"byte[]\"),\n+            Arguments.of(Types.VARBINARY, \"byte[]\"),\n+            Arguments.of(Types.LONGVARBINARY, \"byte[]\"),\n+            Arguments.of(Types.DATE, \"java.sql.Date\"),\n+            Arguments.of(Types.TIME, \"java.sql.Time\"),\n+            Arguments.of(Types.TIMESTAMP, \"java.sql.Timestamp\"),\n+            Arguments.of(Types.CLOB, \"java.sql.Clob\"),\n+            Arguments.of(Types.BLOB, \"java.sql.Blob\")\n+        );\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/RowSetMetaDataTests.java","additions":556,"deletions":0,"binary":false,"changes":556,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset;\n+\n+import com.sun.rowset.RowSetFactoryImpl;\n+import java.io.File;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.sql.SQLException;\n+import java.util.stream.Stream;\n+import javax.sql.rowset.RowSetFactory;\n+import javax.sql.rowset.RowSetProvider;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import util.BaseTest;\n+import util.StubRowSetFactory;\n+\n+public class RowSetProviderTests extends BaseTest {\n+\n+    \/\/ Default RowSetFactory Implementation\n+    private final String DEFFAULT_FACTORY_CLASSNAME = \"com.sun.rowset.RowSetFactoryImpl\";\n+    \/\/ Stub RowSetFactory Implementation\n+    private final String STUB_FACTORY_CLASSNAME = \"util.StubRowSetFactory\";\n+    \/\/ Indicator that the factory implementation does not need to be checked\n+    private final String NO_VALADATE_IMPL = \"\";\n+    \/\/ Original System property value for javax.sql.rowset.RowSetFactory\n+    private static String origFactoryProperty;\n+    \/\/ Original ClassLoader\n+    private static ClassLoader cl;\n+    \/\/ Path to the location of the jar files used by the ServiceLoader API\n+    private static String jarPath;\n+\n+    \/*\n+     * Save off the original property value for javax.sql.rowset.RowSetFactory,\n+     * original classloader and define the path to the jars directory\n+     *\/\n+    @BeforeAll\n+    public static void setUpClass() throws Exception {\n+        origFactoryProperty = System.getProperty(\"javax.sql.rowset.RowSetFactory\");\n+        cl = Thread.currentThread().getContextClassLoader();\n+        jarPath = System.getProperty(\"test.src\", \".\") + File.separatorChar\n+                + \"jars\" +  File.separatorChar;\n+    }\n+\n+    \/*\n+     * Install the original javax.sql.rowset.RowSetFactory property value\n+     *\/\n+    @AfterAll\n+    public static void tearDownClass() throws Exception {\n+        if (origFactoryProperty != null) {\n+            System.setProperty(\"javax.sql.rowset.RowSetFactory\",\n+                    origFactoryProperty);\n+        }\n+    }\n+\n+    \/*\n+     * Clear the javax.sql.rowset.RowSetFactory property value and\n+     * reset the classloader to its original value\n+     *\/\n+    @AfterEach\n+    public void tearDownMethod() throws Exception {\n+        System.clearProperty(\"javax.sql.rowset.RowSetFactory\");\n+        Thread.currentThread().setContextClassLoader(cl);\n+    }\n+\n+    \/*\n+     * Validate that the correct RowSetFactory is returned by newFactory().\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"RowSetFactoryValues\")\n+    public void test(RowSetFactory rsf, String impl) throws SQLException {\n+        validateProvider(rsf, impl);\n+    }\n+\n+    \/*\n+     * Validate that the default RowSetFactory is returned by newFactory()\n+     * when specified by the javax.sql.rowset.RowSetFactory property.\n+     *\/\n+    @Test\n+    public void test01() throws SQLException {\n+        System.setProperty(\"javax.sql.rowset.RowSetFactory\",\n+                DEFFAULT_FACTORY_CLASSNAME);\n+        validateProvider(RowSetProvider.newFactory(), DEFFAULT_FACTORY_CLASSNAME);\n+    }\n+\n+    \/*\n+     * Validate that the correct RowSetFactory is returned by newFactory()\n+     * when specified by the javax.sql.rowset.RowSetFactory property.\n+     *\/\n+    @Test\n+    public void test02() throws SQLException {\n+        System.setProperty(\"javax.sql.rowset.RowSetFactory\", STUB_FACTORY_CLASSNAME);\n+        validateProvider(RowSetProvider.newFactory(), STUB_FACTORY_CLASSNAME);\n+    }\n+\n+    \/*\n+     * Validate that a SQLException is thrown by newFactory()\n+     * when specified  RowSetFactory specified by the\n+     * javax.sql.rowset.RowSetFactory property is not valid.\n+     *\/\n+    @Test\n+    public void test03() throws SQLException {\n+        assertThrows(SQLException.class, () -> {\n+            System.setProperty(\"javax.sql.rowset.RowSetFactory\",\n+                    \"invalid.RowSetFactoryImpl\");\n+            RowSetFactory rsf = RowSetProvider.newFactory();\n+        });\n+    }\n+\n+    \/*\n+     * Validate that the correct RowSetFactory is returned by newFactory()\n+     * when specified by the ServiceLoader API.\n+     *\/\n+    @Test\n+    public void test04() throws Exception {\n+        File f = new File(jarPath + \"goodFactory\");\n+        URLClassLoader loader = new URLClassLoader(new URL[]{\n+            new URL(f.toURI().toString())}, getClass().getClassLoader());\n+        Thread.currentThread().setContextClassLoader(loader);\n+        validateProvider(RowSetProvider.newFactory(), STUB_FACTORY_CLASSNAME);\n+    }\n+\n+    \/*\n+     * Validate that a SQLException is thrown by newFactory() if the default\n+     * RowSetFactory specified by the ServiceLoader API is not valid\n+     *\/\n+    @Test\n+    public void test05() throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            File f = new File(jarPath + \"badFactory\");\n+            URLClassLoader loader = new URLClassLoader(new URL[]{\n+                new URL(f.toURI().toString())}, getClass().getClassLoader());\n+            Thread.currentThread().setContextClassLoader(loader);\n+            RowSetProvider.newFactory();\n+        });\n+    }\n+\n+    \/*\n+     * Utility Method to validate that the RowsetFactory returned from\n+     * RowSetProvider.newFactory() is correct\n+     *\/\n+    private void validateProvider(RowSetFactory rsf, String implName) {\n+        assertNotNull(rsf, \"RowSetFactory should not be null\");\n+        switch (implName) {\n+            case DEFFAULT_FACTORY_CLASSNAME:\n+                assertTrue(rsf instanceof RowSetFactoryImpl);\n+                break;\n+            case STUB_FACTORY_CLASSNAME:\n+                assertTrue(rsf instanceof StubRowSetFactory);\n+                break;\n+            default:\n+        }\n+    }\n+\n+    \/*\n+     * DataProvider used to provide a RowSetFactory and the expected\n+     * RowSetFactory implementation that should be returned\n+     *\/\n+    private Stream<Arguments> RowSetFactoryValues() throws SQLException {\n+        RowSetFactory rsf = RowSetProvider.newFactory();\n+        RowSetFactory rsf1 = RowSetProvider.newFactory(STUB_FACTORY_CLASSNAME, null);\n+        RowSetFactory rsf2 = RowSetProvider.newFactory(DEFFAULT_FACTORY_CLASSNAME, null);\n+        return Stream.of(\n+            Arguments.of(rsf, NO_VALADATE_IMPL),\n+            Arguments.of(rsf, DEFFAULT_FACTORY_CLASSNAME),\n+            Arguments.of(rsf1, STUB_FACTORY_CLASSNAME),\n+            Arguments.of(rsf2, DEFFAULT_FACTORY_CLASSNAME)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/RowSetProviderTests.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/RowSetWarningTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/RowSetWarningTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset;\n+\n+import java.util.Locale;\n+import java.sql.SQLException;\n+import javax.sql.rowset.RowSetProvider;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+\/**\n+ * @test\n+ * @bug 8294989\n+ * @summary Check that the resource bundle can be accessed\n+ * @throws SQLException if an unexpected error occurs\n+ * @run junit\/othervm\n+ *\/\n+public class ValidateResourceBundleAccess{\n+    \/\/ Expected JDBCResourceBundle message, jdbcrowsetimpl.invalstate\n+    private static final String INVALIDSTATE = \"Invalid state\";\n+    \/\/ Expected JDBCResourceBundle message, crsreader.connecterr\n+    private static final String RSREADERERROR = \"Internal Error in RowSetReader: no connection or command\";\n+\n+    \/\/ Checking against English messages, set to US Locale\n+    @BeforeAll\n+    public static void setEnglishEnvironment() {\n+        Locale.setDefault(Locale.US);\n+    }\n+\n+    @Test\n+    public void testResourceBundleAccess() throws SQLException {\n+        var rsr = RowSetProvider.newFactory();\n+        var crs =rsr.createCachedRowSet();\n+        var jrs = rsr.createJdbcRowSet();\n+        \/\/ Simple test to force an Exception to validate the expected message\n+        \/\/ is found from the resource bundle\n+        try {\n+            jrs.getMetaData();\n+            throw new RuntimeException(\"$$$ Expected SQLException was not thrown!\");\n+        } catch (SQLException sqe) {\n+            assertTrue(sqe.getMessage().equals(INVALIDSTATE));\n+        }\n+        \/\/ Now tests via CachedRowSet\n+        try {\n+            crs.execute();\n+            throw new RuntimeException(\"$$$ Expected SQLException was not thrown!\");\n+        } catch (SQLException e) {\n+            assertTrue(e.getMessage().equals(RSREADERERROR));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/ValidateResourceBundleAccess.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/cachedrowset\/CachedRowSetTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/cachedrowset\/CachedRowSetTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,1708 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset.cachedrowset;\n+\n+import java.math.BigDecimal;\n+import java.sql.Array;\n+import java.sql.Date;\n+import java.sql.JDBCType;\n+import java.sql.Ref;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.sql.Time;\n+import java.sql.Timestamp;\n+import java.sql.Types;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.util.Collection;\n+import java.util.stream.Stream;\n+import javax.sql.RowSet;\n+import javax.sql.rowset.CachedRowSet;\n+import javax.sql.rowset.RowSetMetaDataImpl;\n+import javax.sql.rowset.serial.SerialRef;\n+import javax.sql.rowset.spi.SyncFactory;\n+import javax.sql.rowset.spi.SyncProvider;\n+import javax.sql.rowset.spi.SyncProviderException;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import test.rowset.CommonRowSetTests;\n+import util.StubArray;\n+import util.StubRef;\n+import util.StubSyncProvider;\n+import util.TestRowSetListener;\n+\n+public abstract class CommonCachedRowSetTests extends CommonRowSetTests {\n+\n+    \/*\n+     * DATATYPES Table column names\n+     *\/\n+    private final String[] DATATYPES_COLUMN_NAMES = {\"AINTEGER\", \"ACHAR\",\n+        \"AVARCHAR\", \"ALONG\", \"ABOOLEAN\", \"ASHORT\", \"ADOUBLE\", \"ABIGDECIMAL\",\n+        \"AREAL\", \"ABYTE\", \"ADATE\", \"ATIME\", \"ATIMESTAMP\", \"ABYTES\", \"ARRAY\",\n+        \"AREF\", \"AFLOAT\"};\n+\n+    \/*\n+     * Initializes a RowSet containing the DATAYPES data\n+     *\/\n+    protected <T extends RowSet> T createDataTypesRowSet() throws SQLException {\n+        T rs = (T) newInstance();\n+        initDataTypesMetaData((CachedRowSet) rs);\n+        createDataTypesRows(rs);\n+        \/\/ Make sure you are not on the insertRow\n+        rs.moveToCurrentRow();\n+        return rs;\n+    }\n+\n+    \/\/DataProviders to use for common tests\n+\n+    \/*\n+     * DataProvider that uses a RowSet with the COFFEE_HOUSES Table\n+     *\/\n+    protected Stream<RowSet> rowsetUsingCoffeeHouses() throws Exception {\n+        return Stream.of(createCoffeeHousesRowSet());\n+    }\n+\n+    \/*\n+     * DataProvider that uses a RowSet with the COFFEES Table\n+     *\/\n+    protected Stream<RowSet> rowsetUsingCoffees() throws Exception {\n+        return Stream.of(createCoffeesRowSet());\n+    }\n+\n+    \/*\n+     * DataProvider that uses a RowSet with the DATAYPES Table and\n+     * used to validate the various supported data types\n+     *\/\n+    protected Stream<Arguments> rowsetUsingDataTypes() throws Exception {\n+\n+        CachedRowSet rs = createDataTypesRowSet();\n+        return Stream.of(\n+            Arguments.of(rs, JDBCType.INTEGER),\n+            Arguments.of(rs, JDBCType.CHAR),\n+            Arguments.of(rs, JDBCType.VARCHAR),\n+            Arguments.of(rs, JDBCType.BIGINT),\n+            Arguments.of(rs, JDBCType.BOOLEAN),\n+            Arguments.of(rs, JDBCType.SMALLINT),\n+            Arguments.of(rs, JDBCType.DOUBLE),\n+            Arguments.of(rs, JDBCType.DECIMAL),\n+            Arguments.of(rs, JDBCType.REAL),\n+            Arguments.of(rs, JDBCType.TINYINT),\n+            Arguments.of(rs, JDBCType.DATE),\n+            Arguments.of(rs, JDBCType.TIME),\n+            Arguments.of(rs, JDBCType.TIMESTAMP),\n+            Arguments.of(rs, JDBCType.VARBINARY),\n+            Arguments.of(rs, JDBCType.ARRAY),\n+            Arguments.of(rs, JDBCType.REF),\n+            Arguments.of(rs, JDBCType.FLOAT)\n+        );\n+    }\n+\n+    \/*\n+     * Initializes the DATAYPES table metadata\n+     *\/\n+    protected void initDataTypesMetaData(CachedRowSet crs) throws SQLException {\n+        RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();\n+        crs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n+\n+        rsmd.setColumnCount(DATATYPES_COLUMN_NAMES.length);\n+\n+        for (int i = 1; i <= DATATYPES_COLUMN_NAMES.length; i++) {\n+            rsmd.setColumnName(i, DATATYPES_COLUMN_NAMES[i - 1]);\n+            rsmd.setColumnLabel(i, rsmd.getColumnName(i));\n+        }\n+\n+        rsmd.setColumnType(1, Types.INTEGER);\n+        rsmd.setColumnType(2, Types.CHAR);\n+        rsmd.setColumnType(3, Types.VARCHAR);\n+        rsmd.setColumnType(4, Types.BIGINT);\n+        rsmd.setColumnType(5, Types.BOOLEAN);\n+        rsmd.setColumnType(6, Types.SMALLINT);\n+        rsmd.setColumnType(7, Types.DOUBLE);\n+        rsmd.setColumnType(8, Types.DECIMAL);\n+        rsmd.setColumnType(9, Types.REAL);\n+        rsmd.setColumnType(10, Types.TINYINT);\n+        rsmd.setColumnType(11, Types.DATE);\n+        rsmd.setColumnType(12, Types.TIME);\n+        rsmd.setColumnType(13, Types.TIMESTAMP);\n+        rsmd.setColumnType(14, Types.VARBINARY);\n+        rsmd.setColumnType(15, Types.ARRAY);\n+        rsmd.setColumnType(16, Types.REF);\n+        rsmd.setColumnType(17, Types.FLOAT);\n+        crs.setMetaData(rsmd);\n+\n+    }\n+\n+    \/*\n+     * Add rows to DATAYPES table\n+     *\/\n+    protected void createDataTypesRows(RowSet crs) throws SQLException {\n+\n+        Integer aInteger = 100;\n+        String aChar = \"Oswald Cobblepot\";\n+        Long aLong = Long.MAX_VALUE;\n+        Short aShort = Short.MAX_VALUE;\n+        Double aDouble = Double.MAX_VALUE;\n+        BigDecimal aBigDecimal = BigDecimal.ONE;\n+        Boolean aBoolean = false;\n+        Float aFloat = Float.MAX_VALUE;\n+        Byte aByte = Byte.MAX_VALUE;\n+        Date aDate = Date.valueOf(LocalDate.now());\n+        Time aTime = Time.valueOf(LocalTime.now());\n+        Timestamp aTimeStamp = Timestamp.valueOf(LocalDateTime.now());\n+        Array aArray = new StubArray(\"INTEGER\", new Object[1]);\n+        Ref aRef = new SerialRef(new StubRef(\"INTEGER\", query));\n+        byte[] bytes = new byte[10];\n+        crs.moveToInsertRow();\n+        crs.updateInt(1, aInteger);\n+        crs.updateString(2, aChar);\n+        crs.updateString(3, aChar);\n+        crs.updateLong(4, aLong);\n+        crs.updateBoolean(5, aBoolean);\n+        crs.updateShort(6, aShort);\n+        crs.updateDouble(7, aDouble);\n+        crs.updateBigDecimal(8, aBigDecimal);\n+        crs.updateFloat(9, aFloat);\n+        crs.updateByte(10, aByte);\n+        crs.updateDate(11, aDate);\n+        crs.updateTime(12, aTime);\n+        crs.updateTimestamp(13, aTimeStamp);\n+        crs.updateBytes(14, bytes);\n+        crs.updateArray(15, aArray);\n+        crs.updateRef(16, aRef);\n+        crs.updateDouble(17, aDouble);\n+        crs.insertRow();\n+        crs.moveToCurrentRow();\n+\n+    }\n+\n+    \/*\n+     * Dermine if a Row exists in a ResultSet by its primary key\n+     * If the parameter deleteRow is true, delete the row and validate\n+     * the RowSet indicates it is deleted\n+     *\/\n+    protected boolean findRowByPrimaryKey(RowSet rs, int id, int idPos,\n+            boolean deleteRow) throws Exception {\n+        boolean foundRow = false;\n+        rs.beforeFirst();\n+        while (rs.next()) {\n+            if (rs.getInt(idPos) == id) {\n+                foundRow = true;\n+                if (deleteRow) {\n+                    rs.deleteRow();\n+                    \/\/ validate row is marked as deleted\n+                    assertTrue(rs.rowDeleted());\n+                }\n+                break;\n+            }\n+        }\n+        return foundRow;\n+    }\n+\n+    \/*\n+     * Wrapper method to find if a row exists within a RowSet by its primary key\n+     *\/\n+    protected boolean findRowByPrimaryKey(RowSet rs, int id, int idPos) throws Exception {\n+        return findRowByPrimaryKey(rs, id, idPos, false);\n+    }\n+\n+    \/*\n+     * Wrapper method to find if a row exists within a RowSet by its primary key\n+     * and delete it\n+     *\/\n+    protected boolean deleteRowByPrimaryKey(RowSet rs, int id, int idPos) throws Exception {\n+        return findRowByPrimaryKey(rs, id, idPos, true);\n+    }\n+\n+    \/*\n+     * Utility method that compares two ResultSetMetaDataImpls for containing\n+     * the same values\n+     *\/\n+    private void compareMetaData(ResultSetMetaData rsmd,\n+            ResultSetMetaData rsmd1) throws SQLException {\n+\n+        assertEquals(rsmd.getColumnCount(), rsmd1.getColumnCount());\n+        int cols = rsmd.getColumnCount();\n+        for (int i = 1; i <= cols; i++) {\n+            assertTrue(rsmd1.getCatalogName(i).equals(rsmd.getCatalogName(i)));\n+            assertTrue(rsmd1.getColumnClassName(i).equals(rsmd.getColumnClassName(i)));\n+            assertTrue(rsmd1.getColumnDisplaySize(i) == rsmd.getColumnDisplaySize(i));\n+            assertTrue(rsmd1.getColumnLabel(i).equals(rsmd.getColumnLabel(i)));\n+            assertTrue(rsmd1.getColumnName(i).equals(rsmd.getColumnName(i)));\n+            assertTrue(rsmd1.getColumnType(i) == rsmd.getColumnType(i));\n+            assertTrue(rsmd1.getPrecision(i) == rsmd.getPrecision(i));\n+            assertTrue(rsmd1.getScale(i) == rsmd.getScale(i));\n+            assertTrue(rsmd1.getSchemaName(i).equals(rsmd.getSchemaName(i)));\n+            assertTrue(rsmd1.getTableName(i).equals(rsmd.getTableName(i)));\n+            assertTrue(rsmd1.isAutoIncrement(i) == rsmd.isAutoIncrement(i));\n+            assertTrue(rsmd1.isCaseSensitive(i) == rsmd.isCaseSensitive(i));\n+            assertTrue(rsmd1.isCurrency(i) == rsmd.isCurrency(i));\n+            assertTrue(rsmd1.isDefinitelyWritable(i) == rsmd.isDefinitelyWritable(i));\n+            assertTrue(rsmd1.isNullable(i) == rsmd.isNullable(i));\n+            assertTrue(rsmd1.isReadOnly(i) == rsmd.isReadOnly(i));\n+            assertTrue(rsmd1.isSearchable(i) == rsmd.isSearchable(i));\n+            assertTrue(rsmd1.isSigned(i) == rsmd.isSigned(i));\n+            assertTrue(rsmd1.isWritable(i) == rsmd.isWritable(i));\n+\n+        }\n+    }\n+\n+    \/*\n+     * Utility method to compare two rowsets\n+     *\/\n+    private void compareRowSets(CachedRowSet crs, CachedRowSet crs1) throws Exception {\n+\n+        int rows = crs.size();\n+        assertTrue(rows == crs1.size());\n+\n+        ResultSetMetaData rsmd = crs.getMetaData();\n+\n+        compareMetaData(rsmd, crs1.getMetaData());\n+        int cols = rsmd.getColumnCount();\n+\n+        for (int row = 1; row <= rows; row++) {\n+            crs.absolute((row));\n+            crs1.absolute(row);\n+            for (int col = 1; col <= cols; col++) {\n+                compareColumnValue(JDBCType.valueOf(rsmd.getColumnType(col)),\n+                        crs, crs1, col);\n+            }\n+        }\n+\n+    }\n+\n+    \/*\n+     * Utility method to compare two columns\n+     *\/\n+    private void compareColumnValue(JDBCType type, ResultSet rs, ResultSet rs1,\n+            int col) throws SQLException {\n+\n+        switch (type) {\n+            case INTEGER:\n+                assertTrue(rs.getInt(col) == rs1.getInt(col));\n+                break;\n+            case CHAR:\n+            case VARCHAR:\n+                assertTrue(rs.getString(col).equals(rs1.getString(col)));\n+                break;\n+            case BIGINT:\n+                assertTrue(rs.getLong(col) == rs1.getLong(col));\n+                break;\n+            case BOOLEAN:\n+                assertTrue(rs.getBoolean(col) == rs1.getBoolean(col));\n+                break;\n+            case SMALLINT:\n+                assertTrue(rs.getShort(col) == rs1.getShort(col));\n+                break;\n+            case DOUBLE:\n+            case FLOAT:\n+                assertTrue(rs.getDouble(col) == rs1.getDouble(col));\n+                break;\n+            case DECIMAL:\n+                assertTrue(rs.getBigDecimal(col).equals(rs1.getBigDecimal(col)));\n+                break;\n+            case REAL:\n+                assertTrue(rs.getFloat(col) == rs1.getFloat(col));\n+                break;\n+            case TINYINT:\n+                assertTrue(rs.getByte(col) == rs1.getByte(col));\n+                break;\n+            case DATE:\n+                assertTrue(rs.getDate(col).equals(rs1.getDate(col)));\n+                break;\n+            case TIME:\n+                assertTrue(rs.getTime(col).equals(rs1.getTime(col)));\n+                break;\n+            case TIMESTAMP:\n+                assertTrue(rs.getTimestamp(col).equals(rs1.getTimestamp(col)));\n+                break;\n+        }\n+    }\n+\n+    \/*\n+     * Validate SyncProviderException is thrown when acceptChanges is called\n+     * but there is not a way to make a connection to the datasource\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0000(CachedRowSet rs) throws Exception {\n+        assertThrows(SyncProviderException.class, () -> {\n+            rs.acceptChanges();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate SyncProviderException is thrown when acceptChanges is called\n+     * when null is passed as the datasource\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0001(CachedRowSet rs) throws Exception {\n+        assertThrows(SyncProviderException.class, () -> {\n+            rs.acceptChanges(null);\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate that that RIOPtimsticProvider is the default SyncProvider\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0002(CachedRowSet rs) throws SQLException {\n+        SyncProvider sp = rs.getSyncProvider();\n+        assertTrue(sp instanceof com.sun.rowset.providers.RIOptimisticProvider);\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that you can specify a SyncProvider\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0003(CachedRowSet rs) throws SQLException {\n+\n+        \/\/ Register a provider and make sure it is avaiable\n+        SyncFactory.registerProvider(stubProvider);\n+        rs.setSyncProvider(stubProvider);\n+        SyncProvider sp = rs.getSyncProvider();\n+        assertTrue(sp instanceof StubSyncProvider);\n+        SyncFactory.unregisterProvider(stubProvider);\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Create a RowSetListener and validate that notifyRowSetChanged is called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0004(CachedRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.release();\n+        assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Create a RowSetListener and validate that notifyRowSetChanged is called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0005(CachedRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.restoreOriginal();\n+        assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Create a RowSetListener and validate that notifyRowChanged is called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0006(RowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 10024);\n+        rs.updateString(2, \"Sacramento\");\n+        rs.updateInt(3, 1987);\n+        rs.updateInt(4, 2341);\n+        rs.updateInt(5, 4328);\n+        rs.insertRow();\n+        assertTrue(rsl.isNotified(TestRowSetListener.ROW_CHANGED));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Create a multiple RowSetListeners and validate that notifyRowChanged,\n+     * notifiyMoved is called on all listners\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0007(RowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        TestRowSetListener rsl2 = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.addRowSetListener(rsl2);\n+        rs.first();\n+        rs.updateInt(1, 1961);\n+        rs.updateString(2, \"Pittsburgh\");\n+        rs.updateInt(3, 1987);\n+        rs.updateInt(4, 2341);\n+        rs.updateInt(5, 6689);\n+        rs.updateRow();\n+        assertTrue(rsl.isNotified(TestRowSetListener.CURSOR_MOVED\n+                | TestRowSetListener.ROW_CHANGED));\n+        assertTrue(rsl2.isNotified(TestRowSetListener.CURSOR_MOVED\n+                | TestRowSetListener.ROW_CHANGED));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Create a RowSetListener and validate that notifyRowChanged  and\n+     * notifyCursorMoved are  called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0008(CachedRowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+\n+        rs.first();\n+        assertTrue(rsl.isNotified(TestRowSetListener.CURSOR_MOVED));\n+        rs.deleteRow();\n+        assertTrue(\n+                rsl.isNotified(TestRowSetListener.ROW_CHANGED | TestRowSetListener.CURSOR_MOVED));\n+        rsl.resetFlag();\n+        rs.setShowDeleted(true);\n+        rs.undoDelete();\n+        assertTrue(rsl.isNotified(TestRowSetListener.ROW_CHANGED));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Create a RowSetListener and validate that notifyCursorMoved is called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0009(RowSet rs) throws Exception {\n+        TestRowSetListener rsl = new TestRowSetListener();\n+        rs.addRowSetListener(rsl);\n+        rs.beforeFirst();\n+        assertTrue(rsl.isNotified(TestRowSetListener.CURSOR_MOVED));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that getTableName() returns the proper values\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0010(CachedRowSet rs) throws Exception {\n+        assertNull(rs.getTableName());\n+        rs.setTableName(COFFEE_HOUSES_TABLE);\n+        assertTrue(rs.getTableName().equals(COFFEE_HOUSES_TABLE));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that getKeyColumns() returns the proper values\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0011(CachedRowSet rs) throws Exception {\n+        int[] pkeys = {1, 3};\n+        assertNull(rs.getKeyColumns());\n+        rs.setKeyColumns(pkeys);\n+        assertArrayEquals(pkeys, rs.getKeyColumns());\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that setMatchColumn throws a SQLException if the column\n+     * index specified is out of range\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0012(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setMatchColumn(-1);\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate that setMatchColumn throws a SQLException if the column\n+     * index specified is out of range\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0013(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            int[] cols = {1, -1};\n+            rs.setMatchColumn(cols);\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate that setMatchColumn throws a SQLException if the column\n+     * index specified is out of range\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0014(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setMatchColumn((String) null);\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate that setMatchColumn throws a SQLException if the column\n+     * index specified is out of range\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0015(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            String[] cols = {\"ID\", null};\n+            rs.setMatchColumn(cols);\n+        });\n+    }\n+\n+    \/*\n+     * Validate that getMatchColumn returns the same value specified by\n+     * setMatchColumn\n+     *\/\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0016(CachedRowSet rs) throws Exception {\n+        int[] expectedCols = {1};\n+        String[] expectedColNames = {\"ID\"};\n+        rs.setMatchColumn(1);\n+        int[] actualCols = rs.getMatchColumnIndexes();\n+        String[] actualColNames = rs.getMatchColumnNames();\n+        for (int i = 0; i < actualCols.length; i++) {\n+            System.out.println(actualCols[i]);\n+        }\n+        assertArrayEquals(expectedCols, actualCols);\n+        assertArrayEquals(expectedColNames, actualColNames);\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that getMatchColumn returns the same value specified by\n+     * setMatchColumn\n+     *\/\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0017(CachedRowSet rs) throws Exception {\n+        int[] expectedCols = {1};\n+        String[] expectedColNames = {\"ID\"};\n+        rs.setMatchColumn(expectedColNames[0]);\n+        int[] actualCols = rs.getMatchColumnIndexes();\n+        String[] actualColNames = rs.getMatchColumnNames();\n+        assertArrayEquals(expectedCols, actualCols);\n+        assertArrayEquals(expectedColNames, actualColNames);\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that getMatchColumn returns the same valid value specified by\n+     * setMatchColumn\n+     *\/\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0018(CachedRowSet rs) throws Exception {\n+        int[] expectedCols = {1, 3};\n+        String[] expectedColNames = {\"COF_ID\", \"SUP_ID\"};\n+        rs.setMatchColumn(expectedCols);\n+        int[] actualCols = rs.getMatchColumnIndexes();\n+        String[] actualColNames = rs.getMatchColumnNames();\n+        assertArrayEquals(expectedCols, actualCols);\n+        assertArrayEquals(expectedColNames, actualColNames);\n+        assertArrayEquals(expectedCols, actualCols);\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that getMatchColumn returns the same valid value specified by\n+     * setMatchColumn\n+     *\/\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0019(CachedRowSet rs) throws Exception {\n+        int[] expectedCols = {1, 3};\n+        String[] expectedColNames = {\"COF_ID\", \"SUP_ID\"};\n+        rs.setMatchColumn(expectedColNames);\n+        int[] actualCols = rs.getMatchColumnIndexes();\n+        String[] actualColNames = rs.getMatchColumnNames();\n+        assertArrayEquals(expectedCols, actualCols);\n+        assertArrayEquals(expectedColNames, actualColNames);\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that getMatchColumnIndexes throws a SQLException if\n+     * unsetMatchColumn has been called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0020(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setMatchColumn(1);\n+            int[] actualCols = rs.getMatchColumnIndexes();\n+            assertTrue(actualCols != null);\n+            rs.unsetMatchColumn(1);\n+            actualCols = rs.getMatchColumnIndexes();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate that getMatchColumnNames throws a SQLException if\n+     * unsetMatchColumn has been called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0021(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            String matchColumn = \"ID\";\n+            rs.setMatchColumn(matchColumn);\n+            String[] actualColNames = rs.getMatchColumnNames();\n+            assertTrue(actualColNames != null);\n+            rs.unsetMatchColumn(matchColumn);\n+            actualColNames = rs.getMatchColumnNames();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate that getMatchColumnIndexes throws a SQLException if\n+     * unsetMatchColumn has been called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0022(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            int[] expectedCols = {1, 3};\n+            rs.setMatchColumn(expectedCols);\n+            int[] actualCols = rs.getMatchColumnIndexes();\n+            assertTrue(actualCols != null);\n+            rs.unsetMatchColumn(expectedCols);\n+            actualCols = rs.getMatchColumnIndexes();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate that getMatchColumnNames throws a SQLException if\n+     * unsetMatchColumn has been called\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0023(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            String[] expectedColNames = {\"COF_ID\", \"SUP_ID\"};\n+            rs.setMatchColumn(expectedColNames);\n+            String[] actualColNames = rs.getMatchColumnNames();\n+            assertTrue(actualColNames != null);\n+            rs.unsetMatchColumn(expectedColNames);\n+            actualColNames = rs.getMatchColumnNames();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate size() returns the correct number of rows\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0024(CachedRowSet rs) throws Exception {\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that the correct rows are returned comparing the primary\n+     * keys\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0025(RowSet rs) throws SQLException {\n+        assertArrayEquals(COFFEE_HOUSES_PRIMARY_KEYS, getPrimaryKeys(rs));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Delete a row within the RowSet using its primary key\n+     * Validate the visibility of the row depending on the value of\n+     * setShowdelete\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0026(CachedRowSet rs) throws Exception {\n+        Object[] afterDelete = {\n+            10023, 33002, 10040, 32001, 10042, 10024, 10039, 10041,\n+            33005, 33010, 10037, 10034, 32004\n+        };\n+        int rowToDelete = 10035;\n+        \/\/ All rows should be found\n+        assertArrayEquals(COFFEE_HOUSES_PRIMARY_KEYS, getPrimaryKeys(rs));\n+        \/\/ Delete the row\n+        assertTrue(deleteRowByPrimaryKey(rs, rowToDelete, 1));\n+        \/\/ With setShowDeleted(false) which is the default,\n+        \/\/ the deleted row should not be visible\n+        assertFalse(findRowByPrimaryKey(rs, rowToDelete, 1));\n+        assertArrayEquals(afterDelete, getPrimaryKeys(rs));\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n+        \/\/ With setShowDeleted(true), the deleted row should be visible\n+        rs.setShowDeleted(true);\n+        assertTrue(findRowByPrimaryKey(rs, rowToDelete, 1));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that there is no page size by default\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0027(CachedRowSet rs) throws Exception {\n+        assertTrue(rs.getPageSize() == 0);\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate the value you set via setPageSize is returned by getPageSize\n+     * then reset to having no limit\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0028(CachedRowSet rs) throws Exception {\n+        int rows = 100;\n+        rs.setPageSize(rows);\n+        assertTrue(rows == rs.getPageSize());\n+        rs.setPageSize(0);\n+        assertTrue(rs.getPageSize() == 0);\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate SQLException is thrown when an invalid value is specified\n+     * for setPageSize\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0029(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setPageSize(-1);\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate SQLException is thrown when nextPage is called without a\n+     * call to populate or execute\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0030(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.nextPage();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate SQLException is thrown when previousPage is called without a\n+     * call to populate or execute\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0031(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.previousPage();\n+            rs.close();\n+        });\n+    }\n+\n+\n+    \/*\n+     * Validate SQLException is thrown when execute is called\n+     * but there is not a way to make a connection to the datasource\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0032(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.execute(null);\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate SQLException is thrown when execute is called\n+     * but there is not a way to make a connection to the datasource\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0033(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.execute();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate that toCollection(<column>) returns the proper values\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0034(CachedRowSet rs) throws Exception {\n+        Object[] cities = {\"Mendocino\", \"Seattle\", \"SF\", \"Portland\", \"SF\",\n+            \"Sacramento\", \"Carmel\", \"LA\", \"Olympia\", \"Seattle\", \"SF\",\n+            \"LA\", \"San Jose\", \"Eugene\"};\n+        rs.beforeFirst();\n+        assertArrayEquals(cities, rs.toCollection(2).toArray());\n+        assertArrayEquals(cities, rs.toCollection(\"CITY\").toArray());\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that toCollection() returns the proper values\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0035(CachedRowSet rs) throws Exception {\n+        Collection<?> col = rs.toCollection();\n+        assertTrue(rs.size() == col.size());\n+        assertTrue(rs.toCollection().containsAll(col)\n+                && col.containsAll(rs.toCollection()));\n+        try ( \/\/ Validate that False is returned when compared to a different RowSet;\n+                CachedRowSet crs1 = createCoffeesRowSet()) {\n+            assertFalse(crs1.toCollection().containsAll(col)\n+                    && col.containsAll(crs1.toCollection()));\n+        }\n+        rs.close();\n+\n+    }\n+\n+    \/*\n+     * Validate that createCopy() returns the proper values\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0036(CachedRowSet rs) throws Exception {\n+        try (CachedRowSet crs1 = rs.createCopy()) {\n+            compareRowSets(rs, crs1);\n+        }\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that createCopySchema() returns the proper values\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0037(CachedRowSet rs) throws Exception {\n+        try (CachedRowSet crs1 = rs.createCopySchema()) {\n+            assertTrue(crs1.size() == 0);\n+            compareMetaData(crs1.getMetaData(), rs.getMetaData());\n+        }\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that createCopyNoConstraints() returns the proper values\n+     * and getMatchColumnIndexes should throw a SQLException. This test\n+     * specifies setMatchColumn(int)\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0038(CachedRowSet rs) throws Exception {\n+        rs.setMatchColumn(1);\n+        try (CachedRowSet crs1 = rs.createCopyNoConstraints()) {\n+            assertTrue(crs1.size() == COFFEE_HOUSES_ROWS);\n+            compareRowSets(rs, crs1);\n+            boolean recievedSQE = false;\n+            try {\n+                int[] indexes = crs1.getMatchColumnIndexes();\n+            } catch (SQLException e) {\n+                recievedSQE = true;\n+            }\n+            assertTrue(recievedSQE);\n+            recievedSQE = false;\n+            try {\n+                String[] colNames = crs1.getMatchColumnNames();\n+            } catch (SQLException e) {\n+                recievedSQE = true;\n+            }\n+            assertTrue(recievedSQE);\n+        }\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that createCopyNoConstraints() returns the proper values\n+     * and getMatchColumnIndexes should throw a SQLException. This test\n+     * specifies setMatchColumn(String)\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0039(CachedRowSet rs) throws Exception {\n+        rs.setMatchColumn(\"ID\");\n+        try (CachedRowSet crs1 = rs.createCopyNoConstraints()) {\n+            assertTrue(crs1.size() == COFFEE_HOUSES_ROWS);\n+            compareRowSets(rs, crs1);\n+            boolean recievedSQE = false;\n+            try {\n+                int[] indexes = crs1.getMatchColumnIndexes();\n+            } catch (SQLException e) {\n+                recievedSQE = true;\n+            }\n+            assertTrue(recievedSQE);\n+            recievedSQE = false;\n+            try {\n+                String[] colNames = crs1.getMatchColumnNames();\n+            } catch (SQLException e) {\n+                recievedSQE = true;\n+            }\n+            assertTrue(recievedSQE);\n+        }\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that columnUpdated works with the various datatypes specifying\n+     * the column index\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingDataTypes\")\n+    public void commonCachedRowSetTest0040(CachedRowSet rs, JDBCType type) throws Exception {\n+        rs.beforeFirst();\n+        assertTrue(rs.next());\n+        switch (type) {\n+            case INTEGER:\n+                assertFalse(rs.columnUpdated(1));\n+                rs.updateInt(1, Integer.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(1));\n+                break;\n+            case CHAR:\n+                assertFalse(rs.columnUpdated(2));\n+                rs.updateString(2, \"foo\");\n+                assertTrue(rs.columnUpdated(2));\n+                break;\n+            case VARCHAR:\n+                assertFalse(rs.columnUpdated(3));\n+                rs.updateString(3, \"foo\");\n+                assertTrue(rs.columnUpdated(3));\n+                break;\n+            case BIGINT:\n+                assertFalse(rs.columnUpdated(4));\n+                rs.updateLong(4, Long.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(4));\n+                break;\n+            case BOOLEAN:\n+                assertFalse(rs.columnUpdated(5));\n+                rs.updateBoolean(5, false);\n+                assertTrue(rs.columnUpdated(5));\n+                break;\n+            case SMALLINT:\n+                assertFalse(rs.columnUpdated(6));\n+                rs.updateShort(6, Short.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(6));\n+                break;\n+            case DOUBLE:\n+                assertFalse(rs.columnUpdated(7));\n+                rs.updateDouble(7, Double.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(7));\n+                break;\n+            case DECIMAL:\n+                assertFalse(rs.columnUpdated(8));\n+                rs.updateBigDecimal(8, BigDecimal.TEN);\n+                assertTrue(rs.columnUpdated(8));\n+                break;\n+            case REAL:\n+                assertFalse(rs.columnUpdated(9));\n+                rs.updateFloat(9, Float.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(9));\n+                break;\n+            case TINYINT:\n+                assertFalse(rs.columnUpdated(10));\n+                rs.updateByte(10, Byte.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(10));\n+                break;\n+            case DATE:\n+                assertFalse(rs.columnUpdated(11));\n+                rs.updateDate(11, Date.valueOf(LocalDate.now()));\n+                assertTrue(rs.columnUpdated(11));\n+                break;\n+            case TIME:\n+                assertFalse(rs.columnUpdated(12));\n+                rs.updateTime(12, Time.valueOf(LocalTime.now()));\n+                assertTrue(rs.columnUpdated(12));\n+                break;\n+            case TIMESTAMP:\n+                assertFalse(rs.columnUpdated(13));\n+                rs.updateTimestamp(13, Timestamp.valueOf(LocalDateTime.now()));\n+                assertTrue(rs.columnUpdated(13));\n+                break;\n+            case VARBINARY:\n+                assertFalse(rs.columnUpdated(14));\n+                rs.updateBytes(14, new byte[1]);\n+                assertTrue(rs.columnUpdated(14));\n+                break;\n+            case ARRAY:\n+                assertFalse(rs.columnUpdated(15));\n+                rs.updateArray(15, new StubArray(\"VARCHAR\", new Object[10]));\n+                assertTrue(rs.columnUpdated(15));\n+                break;\n+            case REF:\n+                assertFalse(rs.columnUpdated(16));\n+                rs.updateRef(16, new StubRef(\"INTEGER\", query));\n+                assertTrue(rs.columnUpdated(16));\n+                break;\n+            case FLOAT:\n+                assertFalse(rs.columnUpdated(17));\n+                rs.updateDouble(17, Double.MIN_NORMAL);\n+                assertTrue(rs.columnUpdated(17));\n+        }\n+\n+    }\n+\n+    \/*\n+     * Validate that columnUpdated works with the various datatypes specifying\n+     * the column name\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingDataTypes\")\n+    public void commonCachedRowSetTest0041(CachedRowSet rs, JDBCType type) throws Exception {\n+        rs.beforeFirst();\n+        assertTrue(rs.next());\n+        switch (type) {\n+            case INTEGER:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[0]));\n+                rs.updateInt(DATATYPES_COLUMN_NAMES[0], Integer.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[0]));\n+                break;\n+            case CHAR:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[1]));\n+                rs.updateString(DATATYPES_COLUMN_NAMES[1], \"foo\");\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[1]));\n+                break;\n+            case VARCHAR:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[2]));\n+                rs.updateString(DATATYPES_COLUMN_NAMES[2], \"foo\");\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[2]));\n+                break;\n+            case BIGINT:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[3]));\n+                rs.updateLong(DATATYPES_COLUMN_NAMES[3], Long.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[3]));\n+                break;\n+            case BOOLEAN:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[4]));\n+                rs.updateBoolean(DATATYPES_COLUMN_NAMES[4], false);\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[4]));\n+                break;\n+            case SMALLINT:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[5]));\n+                rs.updateShort(DATATYPES_COLUMN_NAMES[5], Short.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[5]));\n+                break;\n+            case DOUBLE:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[6]));\n+                rs.updateDouble(DATATYPES_COLUMN_NAMES[6], Double.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[6]));\n+                break;\n+            case DECIMAL:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[7]));\n+                rs.updateBigDecimal(DATATYPES_COLUMN_NAMES[7], BigDecimal.TEN);\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[7]));\n+                break;\n+            case REAL:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[8]));\n+                rs.updateFloat(DATATYPES_COLUMN_NAMES[8], Float.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[8]));\n+                break;\n+            case TINYINT:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[9]));\n+                rs.updateByte(DATATYPES_COLUMN_NAMES[9], Byte.MIN_VALUE);\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[9]));\n+                break;\n+            case DATE:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[10]));\n+                rs.updateDate(DATATYPES_COLUMN_NAMES[10], Date.valueOf(LocalDate.now()));\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[10]));\n+                break;\n+            case TIME:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[11]));\n+                rs.updateTime(DATATYPES_COLUMN_NAMES[11], Time.valueOf(LocalTime.now()));\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[11]));\n+                break;\n+            case TIMESTAMP:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[12]));\n+                rs.updateTimestamp(DATATYPES_COLUMN_NAMES[12], Timestamp.valueOf(LocalDateTime.now()));\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[12]));\n+                break;\n+            case VARBINARY:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[13]));\n+                rs.updateBytes(DATATYPES_COLUMN_NAMES[13], new byte[1]);\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[13]));\n+                break;\n+            case ARRAY:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[14]));\n+                rs.updateArray(DATATYPES_COLUMN_NAMES[14], new StubArray(\"VARCHAR\", new Object[10]));\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[14]));\n+                break;\n+            case REF:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[15]));\n+                rs.updateRef(DATATYPES_COLUMN_NAMES[15], new StubRef(\"INTEGER\", query));\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[15]));\n+                break;\n+            case FLOAT:\n+                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[16]));\n+                rs.updateDouble(DATATYPES_COLUMN_NAMES[16], Double.MIN_NORMAL);\n+                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[16]));\n+                break;\n+        }\n+\n+    }\n+\n+    \/*\n+     * Validate isBeforeFirst(), isFirst() and first() return the correct\n+     * results\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0042(RowSet rs) throws Exception {\n+        assertFalse(rs.isBeforeFirst());\n+        assertFalse(rs.isFirst());\n+        rs.beforeFirst();\n+        assertTrue(rs.isBeforeFirst());\n+        assertFalse(rs.isFirst());\n+        rs.next();\n+        assertFalse(rs.isBeforeFirst());\n+        assertTrue(rs.isFirst());\n+        rs.next();\n+        assertFalse(rs.isBeforeFirst());\n+        assertFalse(rs.isFirst());\n+        rs.first();\n+        assertFalse(rs.isBeforeFirst());\n+        assertTrue(rs.isFirst());\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate isAfterLast(), isLast() and last() return the correct\n+     * results\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0043(RowSet rs) throws Exception {\n+        assertFalse(rs.isAfterLast());\n+        assertFalse(rs.isLast());\n+        rs.afterLast();\n+        assertTrue(rs.isAfterLast());\n+        assertFalse(rs.isLast());\n+        rs.previous();\n+        assertFalse(rs.isAfterLast());\n+        assertTrue(rs.isLast());\n+        rs.previous();\n+        assertFalse(rs.isAfterLast());\n+        assertFalse(rs.isLast());\n+        rs.last();\n+        assertFalse(rs.isAfterLast());\n+        assertTrue(rs.isLast());\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown when undoDelete is called on the\n+     * insertRow\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0044(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.insertRow();\n+            rs.undoDelete();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown when undoDelete is called when\n+     * cursor is before the first row\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0045(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setShowDeleted(true);\n+            rs.beforeFirst();\n+            rs.undoDelete();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown when undoDelete is called when\n+     * cursor is after the last row\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0046(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setShowDeleted(true);\n+            rs.afterLast();\n+            rs.undoDelete();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown when undoUpdate is called on the\n+     * insertRow\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0047(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.insertRow();\n+            rs.undoUpdate();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown when undoUpdate is called when\n+     * cursor is before the first row\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0048(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setShowDeleted(true);\n+            rs.beforeFirst();\n+            rs.undoUpdate();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown when undoUpdate is called when\n+     * cursor is after the last row\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0049(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setShowDeleted(true);\n+            rs.afterLast();\n+            rs.undoUpdate();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown when undoInsert is called on the\n+     * insertRow\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0050(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.insertRow();\n+            rs.undoInsert();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown when undoInsert is called when\n+     * cursor is before the first row\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0051(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setShowDeleted(true);\n+            rs.beforeFirst();\n+            rs.undoInsert();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown when undoInsert is called when\n+     * cursor is after the last row\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0052(CachedRowSet rs) throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            rs.setShowDeleted(true);\n+            rs.afterLast();\n+            rs.undoInsert();\n+            rs.close();\n+        });\n+    }\n+\n+    \/*\n+     * Insert a row, then call undoInsert to roll back the insert and validate\n+     * the row is not there\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0053(CachedRowSet rs) throws Exception {\n+        int rowToInsert = 1961;\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n+        \/\/ Add new row\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, rowToInsert);\n+        rs.updateString(2, \"GOTHAM\");\n+        rs.updateInt(3, 3450);\n+        rs.updateInt(4, 2005);\n+        rs.updateInt(5, 5455);\n+        rs.insertRow();\n+        rs.moveToCurrentRow();\n+        \/\/ check that the number of rows has increased\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS + 1);\n+        assertTrue(findRowByPrimaryKey(rs, rowToInsert, 1));\n+        rs.undoInsert();\n+        \/\/ Check to make sure the row is no longer there\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n+        assertFalse(findRowByPrimaryKey(rs, rowToInsert, 1));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Insert a row, delete the row and then call undoDelete to make sure it\n+     * is comes back\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0054(CachedRowSet rs) throws Exception {\n+        int rowToDelete = 1961;\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n+        \/\/ Add new row\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, rowToDelete);\n+        rs.updateString(2, \"GOTHAM\");\n+        rs.updateInt(3, 3450);\n+        rs.updateInt(4, 2005);\n+        rs.updateInt(5, 5455);\n+        rs.insertRow();\n+        rs.moveToCurrentRow();\n+        \/\/ check that the number of rows has increased\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS + 1);\n+        assertTrue(findRowByPrimaryKey(rs, rowToDelete, 1));\n+        rs.absolute(COFFEE_HOUSES_ROWS + 1);\n+        rs.deleteRow();\n+        \/\/ Check to make sure the row is no longer there\n+        \/\/assertTrue(rs.size() ==  COFFEE_HOUSES_ROWS);\n+        assertFalse(findRowByPrimaryKey(rs, rowToDelete, 1));\n+        rs.setShowDeleted(true);\n+        rs.absolute(COFFEE_HOUSES_ROWS + 1);\n+        rs.undoDelete();\n+        \/\/ check that the row is back\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS + 1);\n+        assertTrue(findRowByPrimaryKey(rs, rowToDelete, 1));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Insert a row, modify a field and then call undoUpdate to revert the\n+     * insert\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0055(CachedRowSet rs) throws Exception {\n+        int rowToInsert = 1961;\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n+        \/\/ Add new row\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, rowToInsert);\n+        rs.updateString(2, \"GOTHAM\");\n+        rs.updateInt(3, 3450);\n+        rs.updateInt(4, 2005);\n+        rs.updateInt(5, 5455);\n+        rs.insertRow();\n+        rs.moveToCurrentRow();\n+        \/\/ check that the number of rows has increased\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS + 1);\n+        assertTrue(findRowByPrimaryKey(rs, rowToInsert, 1));\n+        rs.absolute(COFFEE_HOUSES_ROWS + 1);\n+        \/\/ Save off the original column values\n+        String f2 = rs.getString(2);\n+        int f3 = rs.getInt(3);\n+        rs.updateString(2, \"SMALLVILLE\");\n+        rs.updateInt(3, 500);\n+        \/\/ Validate the columns have been updated\n+        assertTrue(rs.columnUpdated(2));\n+        assertTrue(rs.columnUpdated(3));\n+        \/\/ Undo the update and validate it has taken place\n+        rs.absolute(COFFEE_HOUSES_ROWS + 1);\n+        rs.undoUpdate();\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n+        assertFalse(findRowByPrimaryKey(rs, rowToInsert, 1));\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate getOriginal returns a ResultSet which is a copy of the original\n+     * RowSet\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffees\")\n+    public void commonCachedRowSetTest0056(CachedRowSet rs) throws Exception {\n+        String coffee = \"Hazelnut\";\n+        int sales = 100;\n+        int id = 200;\n+        Object[] updatedPkeys = {1, id, 3, 4, 5};\n+        \/\/ Change the coffee name and sales total for row 2 and save the\n+        \/\/ previous values\n+        rs.absolute(2);\n+        int origId = rs.getInt(1);\n+        String origCoffee = rs.getString(2);\n+        int origSales = rs.getInt(5);\n+        rs.updateInt(1, id);\n+        rs.updateString(2, coffee);\n+        rs.updateInt(5, sales);\n+        \/\/ MetaData should match\n+        try ( \/\/ Get the original RowSet and validate that the changes\n+                \/\/ are only made to the current, not the original\n+                ResultSet rs1 = rs.getOriginal()) {\n+            \/\/ MetaData should match\n+            compareMetaData(rs.getMetaData(), rs1.getMetaData());\n+            assertTrue(rs1.isBeforeFirst());\n+            assertTrue(rs1.getConcurrency() == ResultSet.CONCUR_UPDATABLE);\n+            assertTrue(rs1.getType() == ResultSet.TYPE_SCROLL_INSENSITIVE);\n+            rs1.absolute(2);\n+            \/\/ Check original rowset is not changed\n+            assertTrue(rs1.getInt(1) == origId);\n+            assertTrue(rs1.getString(2).equals(origCoffee));\n+            assertTrue(rs1.getInt(5) == origSales);\n+            assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(rs1));\n+            \/\/ Check current rowset\n+            assertTrue(rs.getInt(1) == id);\n+            assertTrue(rs.getString(2).equals(coffee));\n+            assertTrue(rs.getInt(5) == sales);\n+            assertArrayEquals(updatedPkeys, getPrimaryKeys(rs));\n+        }\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate getOriginalRow returns a ResultSet which is a copy of the\n+     * original row that was modified\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffees\")\n+    public void commonCachedRowSetTest0057(CachedRowSet rs) throws Exception {\n+        String coffee = \"Hazelnut\";\n+        int sales = 100;\n+        int id = 200;\n+        Object[] updatedPkeys = {1, id, 3, 4, 5};\n+        \/\/ Change the coffee name and sales total for row 2 and save the\n+        \/\/ previous values\n+        rs.absolute(2);\n+        int origId = rs.getInt(1);\n+        String origCoffee = rs.getString(2);\n+        int origSales = rs.getInt(5);\n+        rs.updateInt(1, id);\n+        rs.updateString(2, coffee);\n+        rs.updateInt(5, sales);\n+        \/\/ MetaData should match\n+        try ( \/\/ Get the original row and validate that the changes\n+                \/\/ are only made to the current, not the original\n+                ResultSet rs1 = rs.getOriginalRow()) {\n+            \/\/ MetaData should match\n+            compareMetaData(rs.getMetaData(), rs1.getMetaData());\n+            assertTrue(rs1.isBeforeFirst());\n+            assertTrue(rs1.getConcurrency() == ResultSet.CONCUR_UPDATABLE);\n+            assertTrue(rs1.getType() == ResultSet.TYPE_SCROLL_INSENSITIVE);\n+            rs1.next();\n+            assertTrue(rs1.isFirst() && rs1.isLast());\n+            assertTrue(rs1.getRow() == 1);\n+            \/\/ Check original row is not changed\n+            assertTrue(rs1.getInt(1) == origId);\n+            assertTrue(rs1.getString(2).equals(origCoffee));\n+            assertTrue(rs1.getInt(5) == origSales);\n+            \/\/ Check current row\n+            assertTrue(rs.getInt(1) == id);\n+            assertTrue(rs.getString(2).equals(coffee));\n+            assertTrue(rs.getInt(5) == sales);\n+            assertArrayEquals(updatedPkeys, getPrimaryKeys(rs));\n+        }\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that restoreOrginal will restore the RowSet to its\n+     * state prior to the insert of a row\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0058(CachedRowSet rs) throws Exception {\n+        int rowToInsert = 1961;\n+        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n+        try ( \/\/ Add new row\n+                CachedRowSet crs1 = rsf.createCachedRowSet()) {\n+            rs.beforeFirst();\n+            crs1.populate(rs);\n+            TestRowSetListener rsl = new TestRowSetListener();\n+            crs1.addRowSetListener(rsl);\n+            crs1.moveToInsertRow();\n+            crs1.updateInt(1, rowToInsert);\n+            crs1.updateString(2, \"GOTHAM\");\n+            crs1.updateInt(3, 3450);\n+            crs1.updateInt(4, 2005);\n+            crs1.updateInt(5, 5455);\n+            crs1.insertRow();\n+            assertTrue(rsl.isNotified(TestRowSetListener.ROW_CHANGED));\n+            crs1.moveToCurrentRow();\n+            assertTrue(findRowByPrimaryKey(crs1, rowToInsert, 1));\n+            \/\/ Restore back to our original state and the\n+            \/\/ previously inserted row should not be there\n+            rsl.resetFlag();\n+            crs1.restoreOriginal();\n+            assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n+            assertTrue(crs1.isBeforeFirst());\n+            crs1.last();\n+            assertFalse(crs1.rowInserted());\n+            assertFalse(findRowByPrimaryKey(crs1, rowToInsert, 1));\n+        }\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that restoreOrginal will restore the RowSet to its\n+     * state prior to deleting a row\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffees\")\n+    public void commonCachedRowSetTest0059(CachedRowSet rs) throws Exception {\n+        int rowToDelete = 2;\n+        try (CachedRowSet crs1 = rsf.createCachedRowSet()) {\n+            rs.beforeFirst();\n+            crs1.populate(rs);\n+            TestRowSetListener rsl = new TestRowSetListener();\n+            crs1.addRowSetListener(rsl);\n+            \/\/ Delete a row, the PK is also the absolute position as a List\n+            \/\/ backs the RowSet\n+            crs1.absolute(rowToDelete);\n+            crs1.deleteRow();\n+            assertTrue(crs1.rowDeleted());\n+            assertFalse(findRowByPrimaryKey(crs1, rowToDelete, 1));\n+            \/\/ Restore back to our original state and the\n+            \/\/ previously deleted row should be there\n+            rsl.resetFlag();\n+            crs1.restoreOriginal();\n+            assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n+            assertTrue(crs1.isBeforeFirst());\n+            crs1.absolute(rowToDelete);\n+            assertFalse(crs1.rowDeleted());\n+            assertTrue(findRowByPrimaryKey(crs1, rowToDelete, 1));\n+        }\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Validate that restoreOrginal will restore the RowSet to its\n+     * state prior to updating a row\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffees\")\n+    public void commonCachedRowSetTest0060(CachedRowSet rs) throws Exception {\n+        int rowToUpdate = 2;\n+        String coffee = \"Hazelnut\";\n+        try (CachedRowSet crs1 = rsf.createCachedRowSet()) {\n+            rs.beforeFirst();\n+            crs1.populate(rs);\n+            TestRowSetListener rsl = new TestRowSetListener();\n+            crs1.addRowSetListener(rsl);\n+            \/\/ Delete a row, the PK is also the absolute position as a List\n+            \/\/ backs the RowSet\n+            crs1.absolute(rowToUpdate);\n+            String origCoffee = crs1.getString(2);\n+            crs1.updateString(2, coffee);\n+            assertTrue(crs1.columnUpdated(2));\n+            crs1.updateRow();\n+            assertTrue(crs1.rowUpdated());\n+            assertFalse(origCoffee.equals(crs1.getString(2)));\n+            \/\/ Restore back to our original state and the\n+            \/\/ previous value for the column within the row should be there\n+            rsl.resetFlag();\n+            crs1.restoreOriginal();\n+            assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n+            assertTrue(crs1.isBeforeFirst());\n+            \/\/ absolute() is failing for some reason so need to look at this later\n+            crs1.next();\n+            crs1.next();\n+            assertFalse(crs1.columnUpdated(2));\n+            assertFalse(crs1.rowUpdated());\n+            assertTrue(origCoffee.equals(crs1.getString(2)));\n+        }\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Initialize a RowSet via the populate method. Validate it matches\n+     * the original ResultSet\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0061(CachedRowSet rs) throws Exception {\n+        try (CachedRowSet crs1 = rsf.createCachedRowSet()) {\n+            rs.beforeFirst();\n+            crs1.populate(rs);\n+            compareRowSets(rs, crs1);\n+        }\n+        rs.close();\n+    }\n+\n+    \/*\n+     * Initialize a RowSet via the populate method specifying a starting row.\n+     * Validate it matches the original ResultSet starting for the specofied\n+     * offset\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffeeHouses\")\n+    public void commonCachedRowSetTest0062(CachedRowSet rs) throws Exception {\n+        Object[] expectedRows = {\n+            32001, 10042, 10024, 10039, 10041, 33005, 33010, 10035, 10037,\n+            10034, 32004\n+        };\n+        int startingRow = 4;\n+        try (CachedRowSet crs1 = rsf.createCachedRowSet()) {\n+            rs.beforeFirst();\n+            crs1.populate(rs, startingRow);\n+            assertEquals(COFFEE_HOUSES_ROWS - startingRow + 1, crs1.size());\n+            assertArrayEquals(expectedRows, getPrimaryKeys(crs1));\n+        }\n+        rs.close();\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/cachedrowset\/CommonCachedRowSetTests.java","additions":1708,"deletions":0,"binary":false,"changes":1708,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/filteredrowset\/CityFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/filteredrowset\/CityFilter.java","status":"renamed"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset.filteredrowset;\n+\n+import java.sql.SQLException;\n+import javax.sql.RowSet;\n+import javax.sql.rowset.FilteredRowSet;\n+import javax.sql.rowset.Predicate;\n+\n+import org.junit.jupiter.api.AfterEach;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import test.rowset.webrowset.CommonWebRowSetTests;\n+\n+public class FilteredRowSetTests extends CommonWebRowSetTests {\n+\n+    private FilteredRowSet frs;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        frs = createCoffeeHousesRowSet();\n+    }\n+\n+    @AfterEach\n+    public void tearDownMethod() throws Exception {\n+        frs.close();\n+    }\n+\n+    protected FilteredRowSet newInstance() throws SQLException {\n+        return rsf.createFilteredRowSet();\n+    }\n+\n+    \/*\n+     * Validate getFilter returns null if setFilter has not been called\n+     *\/\n+    @Test\n+    public void FilteredRowSetTest0000() throws SQLException {\n+        assertNull(frs.getFilter());\n+    }\n+\n+    \/*\n+     * Call setFilter to set a Predicate and validate that getFilter\n+     * returns the correct Predicate\n+     *\/\n+    @Test\n+    public void FilteredRowSetTest0001() throws SQLException {\n+        Predicate p = new PrimaryKeyFilter(0, 100030, 1);\n+        frs.setFilter(p);\n+        assertTrue(frs.getFilter().equals(p));\n+        frs.setFilter(null);\n+        assertNull(frs.getFilter());\n+    }\n+\n+    \/*\n+     * Validate that the correct rows are returned when a Predicate using\n+     * a column index is used\n+     *\/\n+    @Test\n+    public void FilteredRowSetTest0002() throws SQLException {\n+        Object[] expectedKeys = {\n+            10023, 10040, 10042, 10024, 10039, 10041, 10035, 10037, 10034\n+        };\n+        frs.setFilter(new PrimaryKeyFilter(10000, 10999, 1));\n+        assertArrayEquals(expectedKeys, getPrimaryKeys(frs));\n+    }\n+\n+    \/*\n+     * Validate that the correct rows are returned when a Predicate using\n+     * a column Label is used\n+     *\/\n+    @Test\n+    public void FilteredRowSetTest0003() throws SQLException {\n+        Object[] expectedKeys = {\n+            10023, 10040, 10042, 10024, 10039, 10041, 10035, 10037, 10034\n+        };\n+        frs.setFilter(new PrimaryKeyFilter(10000, 10999, \"STORE_ID\"));\n+        assertArrayEquals(expectedKeys, getPrimaryKeys(frs));\n+\n+    }\n+\n+    \/*\n+     * Validate that the correct rows are returned when a Predicate using\n+     * a column index is used\n+     *\/\n+    @Test\n+    public void FilteredRowSetTest0004() throws SQLException {\n+        Object[] expectedKeys = {\n+            10040, 10042, 10041, 10035, 10037\n+        };\n+        String[] cityArray = {\"SF\", \"LA\"};\n+        frs.setFilter(new CityFilter(cityArray, 2));\n+        assertArrayEquals(expectedKeys, getPrimaryKeys(frs));\n+    }\n+\n+    \/*\n+     * Validate that the correct rows are returned when a Predicate using\n+     * a column Label is used\n+     *\/\n+    @Test\n+    public void FilteredRowSetTest0005() throws SQLException {\n+        Object[] expectedKeys = {\n+            10040, 10042, 10041, 10035, 10037\n+        };\n+        String[] cityArray = {\"SF\", \"LA\"};\n+        frs.setFilter(new CityFilter(cityArray, \"CITY\"));\n+        assertArrayEquals(expectedKeys, getPrimaryKeys(frs));\n+    }\n+\n+\n+    \/\/ Tests that are common but need to be disabled due to an implementation bug\n+\n+\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0043(RowSet rs) throws Exception {\n+        \/\/ Need to fix bug in FilteredRowSets\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/filteredrowset\/FilteredRowSetTests.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/filteredrowset\/PrimaryKeyFilter.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/filteredrowset\/PrimaryKeyFilter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,3 @@\n-import org.testng.annotations.Test;\n+\n+import org.junit.jupiter.api.Test;\n+\n@@ -44,1 +46,1 @@\n-    @Test(enabled = true)\n+    @Test\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/jdbcrowset\/JdbcRowSetDriverManagerTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/jdbcrowset\/JdbcRowSetDriverManagerTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset.joinrowset;\n+\n+import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import javax.sql.RowSet;\n+import javax.sql.rowset.CachedRowSet;\n+import javax.sql.rowset.JoinRowSet;\n+import javax.sql.rowset.RowSetMetaDataImpl;\n+import javax.sql.rowset.WebRowSet;\n+\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import test.rowset.webrowset.CommonWebRowSetTests;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+public class JoinRowSetTests extends CommonWebRowSetTests {\n+\n+    private final String SUPPLIERS_TABLE = \"SUPPLIERS\";\n+    \/\/ Expected COF_IDs to be found\n+    private final Object[] EXPECTED = {4, 1};\n+    \/\/ SUPPLIERS Primary Key to use to validate the joins\n+    private final int SUP_ID = 101;\n+    \/\/ Join Column between the SUPPLIERS and COFFEES table\n+    private final String JOIN_COLNAME = \"SUP_ID\";\n+    \/\/ Column index in COFFEES table which contains SUP_ID\n+    private final int COFFEES_JOIN_COLUMN_INDEX = 3;\n+    \/\/ Column index in SUPPLIERS table which contains SUP_ID\n+    private final int SUPPLIERS_JOIN_COLUMN_INDEX = 1;\n+\n+    @Override\n+    protected JoinRowSet newInstance() throws SQLException {\n+        return rsf.createJoinRowSet();\n+    }\n+\n+    \/*\n+     * Initializes the SUPPLIERS metadata\n+     *\/\n+    private void initSuppliersMetaData(CachedRowSet crs) throws SQLException {\n+        RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();\n+\n+        \/*\n+         *  CREATE TABLE SUPPLIERS (\n+         *   SUP_ID INTEGER NOT NULL,\n+         *   SUP_NAME VARCHAR(32) NOT NULL,\n+         *   STREET VARCHAR(32) NOT NULL,\n+         *   CITY VARCHAR(32) NOT NULL,\n+         *   STATE CHAR(2) NOT NULL,\n+         *   ZIP CHAR(5) NOT NULL,\n+         *   PRIMARY KEY (SUP_ID))\n+         *\/\n+        rsmd.setColumnCount(6);\n+        rsmd.setColumnName(1, \"SUP_ID\");\n+        rsmd.setColumnName(2, \"SUP_NAME\");\n+        rsmd.setColumnName(3, \"STREET\");\n+        rsmd.setColumnName(4, \"CITY\");\n+        rsmd.setColumnName(5, \"STATE\");\n+        rsmd.setColumnName(6, \"ZIP\");\n+\n+        rsmd.setColumnType(1, Types.INTEGER);\n+        rsmd.setColumnType(2, Types.VARCHAR);\n+        rsmd.setColumnType(3, Types.VARCHAR);\n+        rsmd.setColumnType(4, Types.VARCHAR);\n+        rsmd.setColumnType(5, Types.CHAR);\n+        rsmd.setColumnType(6, Types.CHAR);\n+        crs.setMetaData(rsmd);\n+        crs.setTableName(SUPPLIERS_TABLE);\n+    }\n+\n+    \/*\n+     * Add rows to SUPPLIERS table\n+     *\/\n+    protected void createSuppiersRows(RowSet rs) throws SQLException {\n+\n+        \/\/ insert into SUPPLIERS values(49, 'Superior Coffee', '1 Party Place',\n+        \/\/ 'Mendocino', 'CA', '95460')\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 49);\n+        rs.updateString(2, \"Superior Coffee\");\n+        rs.updateString(3, \"1 Party Place\");\n+        rs.updateString(4, \"Mendocino\");\n+        rs.updateString(5, \"CA\");\n+        rs.updateString(6, \"95460\");\n+        rs.insertRow();\n+\n+        \/\/ insert into SUPPLIERS values(101, 'Acme, Inc.', '99 Market Street',\n+        \/\/ 'Groundsville', 'CA', '95199')\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 101);\n+        rs.updateString(2, \"Acme, Inc.\");\n+        rs.updateString(3, \"99 Market Street\");\n+        rs.updateString(4, \"Groundsville\");\n+        rs.updateString(5, \"CA\");\n+        rs.updateString(6, \"95199\");\n+        rs.insertRow();\n+        \/\/ insert into SUPPLIERS values(150, 'The High Ground',\n+        \/\/ '100 Coffee Lane', 'Meadows', 'CA', '93966')\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 150);\n+        rs.updateString(2, \"The High Ground\");\n+        rs.updateString(3, \"100 Coffee Lane\");\n+        rs.updateString(4, \"Meadows\");\n+        rs.updateString(5, \"CA\");\n+        rs.updateString(6, \"93966\");\n+        rs.insertRow();\n+        \/\/ insert into SUPPLIERS values(456,\" 'Restaurant Supplies, Inc.',\n+        \/\/ '200 Magnolia Street', 'Meadows', 'CA', '93966')\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 456);\n+        rs.updateString(2, \"Restaurant Supplies, Inc.\");\n+        rs.updateString(3, \"200 Magnolia Stree\");\n+        rs.updateString(4, \"Meadows\");\n+        rs.updateString(5, \"CA\");\n+        rs.updateString(6, \"93966\");\n+        rs.insertRow();\n+        \/\/ insert into SUPPLIERS values(927, 'Professional Kitchen',\n+        \/\/ '300 Daisy Avenue', 'Groundsville',\" 'CA', '95199')\n+        rs.moveToInsertRow();\n+        rs.updateInt(1, 927);\n+        rs.updateString(2, \"Professional Kitchen\");\n+        rs.updateString(3, \"300 Daisy Avenue\");\n+        rs.updateString(4, \"Groundsville\");\n+        rs.updateString(5, \"CA\");\n+        rs.updateString(6, \"95199\");\n+        rs.insertRow();\n+    }\n+\n+    \/*\n+     * DataProvider used to set parameters for basic types that are supported\n+     *\/\n+    private Stream<Arguments> createCachedRowSetsToUse() throws SQLException {\n+        CachedRowSet crs = rsf.createCachedRowSet();\n+        initCoffeesMetaData(crs);\n+        createCoffeesRows(crs);\n+        \/\/ Make sure you are not on the insertRow\n+        crs.moveToCurrentRow();\n+        CachedRowSet crs1 = rsf.createCachedRowSet();\n+        initSuppliersMetaData(crs1);\n+        createSuppiersRows(crs1);\n+        \/\/ Make sure you are not on the insertRow\n+        crs1.moveToCurrentRow();\n+        return Stream.of(Arguments.of(crs, crs1));\n+    }\n+\n+    \/*\n+     * Validate that the correct coffees are returned for SUP_ID\n+     *\/\n+    private void validateResults(final JoinRowSet jrs) throws SQLException {\n+        List<Integer> results = new ArrayList<>();\n+        jrs.beforeFirst();\n+        while (jrs.next()) {\n+            if (jrs.getInt(JOIN_COLNAME) == SUP_ID) {\n+                results.add(jrs.getInt(\"COF_ID\"));\n+            }\n+        }\n+        assertArrayEquals(EXPECTED, results.toArray());\n+    }\n+\n+    \/*\n+     * Join two CachedRowSets specifying a column name to join against\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"createCachedRowSetsToUse\")\n+    public void joinRowSetTests0000(CachedRowSet crs, CachedRowSet crs1)\n+            throws Exception {\n+\n+        try (JoinRowSet jrs = newInstance()) {\n+            jrs.addRowSet(crs, JOIN_COLNAME);\n+            jrs.addRowSet(crs1, JOIN_COLNAME);\n+            validateResults(jrs);\n+            crs.close();\n+            crs1.close();\n+        }\n+    }\n+\n+    \/*\n+     * Join two CachedRowSets specifying a column index to join against\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"createCachedRowSetsToUse\")\n+    public void joinRowSetTests0001(CachedRowSet crs, CachedRowSet crs1)\n+            throws Exception {\n+\n+        try (JoinRowSet jrs = newInstance()) {\n+            jrs.addRowSet(crs, COFFEES_JOIN_COLUMN_INDEX);\n+            jrs.addRowSet(crs1, SUPPLIERS_JOIN_COLUMN_INDEX);\n+            validateResults(jrs);\n+            crs.close();\n+            crs1.close();\n+        }\n+    }\n+\n+    \/*\n+     * Join two CachedRowSets specifying a column name to join against\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"createCachedRowSetsToUse\")\n+    public void joinRowSetTests0002(CachedRowSet crs, CachedRowSet crs1)\n+            throws Exception {\n+\n+        try (JoinRowSet jrs = newInstance()) {\n+            RowSet[] rowsets = {crs, crs1};\n+            String[] joinCols = {JOIN_COLNAME, JOIN_COLNAME};\n+            jrs.addRowSet(rowsets, joinCols);\n+            validateResults(jrs);\n+            crs.close();\n+            crs1.close();\n+        }\n+    }\n+\n+    \/*\n+     * Join two CachedRowSets specifying a column index to join against\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"createCachedRowSetsToUse\")\n+    public void joinRowSetTests0003(CachedRowSet crs, CachedRowSet crs1)\n+            throws Exception {\n+\n+        try (JoinRowSet jrs = newInstance()) {\n+            RowSet[] rowsets = {crs, crs1};\n+            int[] joinCols = {COFFEES_JOIN_COLUMN_INDEX,\n+                SUPPLIERS_JOIN_COLUMN_INDEX};\n+            jrs.addRowSet(rowsets, joinCols);\n+            validateResults(jrs);\n+            crs.close();\n+            crs1.close();\n+        }\n+    }\n+\n+    \/*\n+     * Join two CachedRowSets specifying a column name to join against\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"createCachedRowSetsToUse\")\n+    public void joinRowSetTests0005(CachedRowSet crs, CachedRowSet crs1)\n+            throws Exception {\n+\n+        try (JoinRowSet jrs = newInstance()) {\n+            crs.setMatchColumn(JOIN_COLNAME);\n+            crs1.setMatchColumn(JOIN_COLNAME);\n+            jrs.addRowSet(crs);\n+            jrs.addRowSet(crs1);\n+            validateResults(jrs);\n+            crs.close();\n+            crs1.close();\n+        }\n+    }\n+\n+    \/*\n+     * Join two CachedRowSets specifying a column index to join against\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"createCachedRowSetsToUse\")\n+    public void joinRowSetTests0006(CachedRowSet crs, CachedRowSet crs1)\n+            throws Exception {\n+\n+        try (JoinRowSet jrs = newInstance()) {\n+            crs.setMatchColumn(COFFEES_JOIN_COLUMN_INDEX);\n+            crs1.setMatchColumn(SUPPLIERS_JOIN_COLUMN_INDEX);\n+\n+            jrs.addRowSet(crs);\n+            jrs.addRowSet(crs1);\n+            validateResults(jrs);\n+            crs.close();\n+            crs1.close();\n+        }\n+    }\n+\n+    \/\/ Disabled tests due to bugs in JoinRowSet\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0004(CachedRowSet rs) throws Exception {\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0005(CachedRowSet rs) throws Exception {\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0008(CachedRowSet rs) throws Exception {\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0026(CachedRowSet rs) throws Exception {\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0027(CachedRowSet rs) throws Exception {\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0053(CachedRowSet rs) throws Exception {\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0054(CachedRowSet rs) throws Exception {\n+    }\n+\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void commonCachedRowSetTest0055(CachedRowSet rs) throws Exception {\n+    }\n+\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void WebRowSetTest0009(WebRowSet wrs1) throws Exception {\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/joinrowset\/JoinRowSetTests.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,5 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -57,1 +59,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -71,1 +73,1 @@\n-    @Test(expectedExceptions = SQLException.class)\n+    @Test\n@@ -73,1 +75,3 @@\n-        SQLInputImpl x = new SQLInputImpl(null, map);\n+        assertThrows(SQLException.class, () -> {\n+            SQLInputImpl x = new SQLInputImpl(null, map);\n+        });\n@@ -80,1 +84,1 @@\n-    @Test(expectedExceptions = SQLException.class)\n+    @Test\n@@ -82,1 +86,3 @@\n-        SQLInputImpl x = new SQLInputImpl(typeValues, null);\n+        assertThrows(SQLException.class, () -> {\n+            SQLInputImpl x = new SQLInputImpl(typeValues, null);\n+        });\n@@ -127,1 +133,1 @@\n-    @Test(enabled = true)\n+    @Test\n@@ -142,1 +148,1 @@\n-    @Test(enabled = true)\n+    @Test\n@@ -156,1 +162,1 @@\n-    @Test(enabled = true)\n+    @Test\n@@ -169,1 +175,1 @@\n-    @Test(enabled = true)\n+    @Test\n@@ -182,1 +188,1 @@\n-    @Test(enabled = true)\n+    @Test\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/serial\/SQLInputImplTests.java","additions":20,"deletions":14,"binary":false,"changes":34,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SQLInputImplTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,3 +44,5 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -67,1 +69,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -81,1 +83,1 @@\n-    @Test(expectedExceptions = SQLException.class)\n+    @Test\n@@ -83,1 +85,3 @@\n-        SQLOutputImpl x = new SQLOutputImpl(null, map);\n+        assertThrows(SQLException.class, () -> {\n+            SQLOutputImpl x = new SQLOutputImpl(null, map);\n+        });\n@@ -90,1 +94,1 @@\n-    @Test(expectedExceptions = SQLException.class)\n+    @Test\n@@ -92,1 +96,3 @@\n-        SQLOutputImpl x = new SQLOutputImpl(results, null);\n+        assertThrows(SQLException.class, () -> {\n+            SQLOutputImpl x = new SQLOutputImpl(results, null);\n+        });\n@@ -112,1 +118,1 @@\n-    @Test(enabled = true)\n+    @Test\n@@ -126,1 +132,1 @@\n-    @Test(enabled = true)\n+    @Test\n@@ -139,1 +145,1 @@\n-    @Test(enabled = true)\n+    @Test\n@@ -151,1 +157,1 @@\n-    @Test(enabled = true)\n+    @Test\n@@ -162,1 +168,1 @@\n-    @Test(enabled = true)\n+    @Test\n@@ -176,1 +182,1 @@\n-    @Test(enabled = true)\n+    @Test\n@@ -189,1 +195,1 @@\n-    @Test(enabled = true)\n+    @Test\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/serial\/SQLOutputImplTests.java","additions":22,"deletions":16,"binary":false,"changes":38,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SQLOutputImplTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset.serial;\n+\n+import java.sql.Array;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.sql.rowset.serial.SerialArray;\n+import javax.sql.rowset.serial.SerialException;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import util.BaseTest;\n+import util.StubArray;\n+\n+public class SerialArrayTests extends BaseTest {\n+\n+    private Object[] coffees;\n+    private final String sqlType = \"VARCHAR\";\n+    private Array a;\n+    private Map<String, Class<?>> map;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        coffees = new Object[]{\"Espresso\", \"Colombian\", \"French Roast\",\n+            \"Cappuccino\"};\n+        a = new StubArray(sqlType, coffees);\n+        map = new HashMap<>();\n+    }\n+\n+    \/*\n+     * Validate a SerialArray can be created from an Array\n+     *\/\n+    @Test\n+    public void test01() throws Exception {\n+        SerialArray sa = new SerialArray(a);\n+    }\n+\n+    \/*\n+     * Validate a SQLException is thrown if the map is null\n+     *\/\n+    @Test\n+    public void test02() throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            SerialArray sa = new SerialArray(a, null);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown when getResultSet() is called\n+     *\/\n+    @Test\n+    public void test03() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialArray sa = new SerialArray(a);\n+            sa.getResultSet();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown when getResultSet() is called\n+     *\/\n+    @Test\n+    public void test04() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialArray sa = new SerialArray(a);\n+            sa.getResultSet(null);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown when getResultSet() is called\n+     *\/\n+    @Test\n+    public void test05() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialArray sa = new SerialArray(a);\n+            sa.getResultSet(1, 1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown when getResultSet() is called\n+     *\/\n+    @Test\n+    public void test06() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialArray sa = new SerialArray(a);\n+            sa.getResultSet(1, 1, null);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown when  getArray() is invoked after\n+     * free() is called\n+     *\/\n+    @Test\n+    public void test07() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialArray sa = new SerialArray(a);\n+            sa.free();\n+            sa.getArray();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown when  getArray() is invoked after\n+     * free() is called\n+     *\/\n+    @Test\n+    public void test08() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialArray sa = new SerialArray(a);\n+            sa.free();\n+            sa.getArray(map);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown when  getArray() is invoked after\n+     * free() is called\n+     *\/\n+    @Test\n+    public void test09() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialArray sa = new SerialArray(a);\n+            sa.free();\n+            sa.getArray(1, 1, map);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown when  getArray() is invoked after\n+     * free() is called\n+     *\/\n+    @Test\n+    public void test10() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialArray sa = new SerialArray(a);\n+            sa.free();\n+            sa.getArray(1, 1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown when  getBaseType() is invoked after\n+     * free() is called\n+     *\/\n+    @Test\n+    public void test11() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialArray sa = new SerialArray(a);\n+            sa.free();\n+            sa.getBaseType();\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown when  getBaseTypeName() is invoked after\n+     * free() is called\n+     *\/\n+    @Test\n+    public void test12() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialArray sa = new SerialArray(a);\n+            sa.free();\n+            sa.getBaseTypeName();\n+        });\n+    }\n+\n+    \/*\n+     * Validate getArray() returns the same Object[] used to create the\n+     * SerialArray\n+     *\/\n+    @Test\n+    public void test13() throws Exception {\n+        SerialArray sa = new SerialArray(a);\n+        Object[] o = (Object[]) sa.getArray();\n+        assertTrue(Arrays.equals(o, coffees));\n+    }\n+\n+    \/*\n+     * Validate getArray() returns the same Object[] used to create the\n+     * SerialArray\n+     *\/\n+    @Test\n+    public void test14() throws Exception {\n+        SerialArray sa = new SerialArray(a);\n+        Object[] o = (Object[]) sa.getArray(map);\n+        assertTrue(Arrays.equals(o, coffees));\n+    }\n+\n+    \/*\n+     * Validate getArray() returns the same Object[] used to create the\n+     * SerialArray\n+     *\/\n+    @Test\n+    public void test15() throws Exception {\n+        SerialArray sa = new SerialArray(a);\n+        Object[] o = (Object[]) sa.getArray(1, 2);\n+        assertTrue(Arrays.equals(o, Arrays.copyOfRange(coffees, 1, 3)));\n+    }\n+\n+    \/*\n+     * Validate getArray() returns the same Object[] used to create the\n+     * SerialArray\n+     *\/\n+    @Test\n+    public void test16() throws Exception {\n+        SerialArray sa = new SerialArray(a);\n+        Object[] o = (Object[]) sa.getArray(1, 2, map);\n+        assertTrue(Arrays.equals(o, Arrays.copyOfRange(coffees, 1, 3)));\n+    }\n+\n+    \/*\n+     * clone() a SerialArray and check that it is equal to the\n+     * object it was cloned from\n+     *\/\n+    @Test\n+    public void test17() throws Exception {\n+        SerialArray sa = new SerialArray(a);\n+        SerialArray sa1 = (SerialArray) sa.clone();\n+        assertTrue(sa.equals(sa1));\n+    }\n+\n+    \/*\n+     * Validate that a SerialArray that is serialized & deserialized is equal to\n+     * itself\n+     *\/\n+    @Test\n+    public void test18() throws Exception {\n+        SerialArray sa = new SerialArray(a);\n+        SerialArray sa1 = serializeDeserializeObject(sa);\n+        assertTrue(sa.equals(sa1));\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/serial\/SerialArrayTests.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -0,0 +1,515 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset.serial;\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Arrays;\n+import javax.sql.rowset.serial.SerialBlob;\n+import javax.sql.rowset.serial.SerialException;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n+import util.BaseTest;\n+import util.StubBlob;\n+\n+public class SerialBlobTests extends BaseTest {\n+\n+    \/\/ byte[] used to populate SerialBlob\n+    private byte[] bytes = new byte[]{1, 2, 3, 4, 5};\n+\n+    \/*\n+     * Validate calling free() does not throw an Exception\n+     *\/\n+    @Test\n+    public void test() throws Exception {\n+        SerialBlob sb = new SerialBlob(new StubBlob());\n+        sb.free();\n+    }\n+\n+    \/*\n+     * Validate calling getBinaryStream() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test01() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(new StubBlob());\n+            sb.free();\n+            sb.getBinaryStream();\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling getBinaryStream() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test02() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(new StubBlob());\n+            sb.free();\n+            sb.getBinaryStream(1, 5);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling getBytes() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test03() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(new StubBlob());\n+            sb.free();\n+            sb.getBytes(1, 1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling getLength() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test04() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(new StubBlob());\n+            sb.free();\n+            sb.length();\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling position() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test05() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(new StubBlob());\n+            sb.free();\n+            sb.position(new byte[5], 1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling position() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test06() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(new StubBlob());\n+            sb.free();\n+            sb.position(new StubBlob(), 1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling free() after calling setBinaryStream() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test07() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(new StubBlob());\n+            sb.free();\n+            sb.setBinaryStream(5);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling free() after calling setBytes() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test08() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(new StubBlob());\n+            sb.free();\n+            sb.setBytes(1, new byte[5]);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling setBytes() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test09() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(new StubBlob());\n+            sb.free();\n+            sb.setBytes(1, new byte[10], 0, 5);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling truncate() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test10() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(new StubBlob());\n+            sb.free();\n+            sb.truncate(1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate getBinaryStream returns the correct bytes\n+     *\/\n+    @Test\n+    public void test11() throws Exception {\n+        byte[] expected = new byte[]{1, 2, 3};\n+        SerialBlob sb = new SerialBlob(bytes);\n+        InputStream is = sb.getBinaryStream(1, 3);\n+        for (byte b : expected) {\n+            byte val = (byte) is.read();\n+            assertTrue(b == val, val + \" does not match \" + b);\n+        }\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if pos < 0 for getBinaryStream\n+     *\/\n+    @Test\n+    public void test12() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(bytes);\n+            InputStream is = sb.getBinaryStream(-1, 3);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if pos = 0 for getBinaryStream\n+     *\/\n+    @Test\n+    public void test13() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(bytes);\n+            InputStream is = sb.getBinaryStream(0, 3);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if len > the length of the stream\n+     * for getBinaryStream\n+     *\/\n+    @Test\n+    public void test14() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(bytes);\n+            InputStream is = sb.getBinaryStream(0, 3);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if length < 1\n+     *\/\n+    @Test\n+    public void test15() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(bytes);\n+            InputStream is = sb.getBinaryStream(1, 0);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if length > byte array length\n+     *\/\n+    @Test\n+    public void test16() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(bytes);\n+            InputStream is = sb.getBinaryStream(1, 6);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if pos > byte array length\n+     *\/\n+    @Test\n+    public void test17() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(bytes);\n+            InputStream is = sb.getBinaryStream(bytes.length + 2, 6);\n+        });\n+    }\n+\n+    \/*\n+     * Validate that a cloned SerializedBlob bytes match the original\n+     *\/\n+    @Test\n+    public void test18() throws Exception {\n+        SerialBlob sb = new SerialBlob(bytes);\n+        SerialBlob sb2 = (SerialBlob) sb.clone();\n+        assertTrue(\n+                Arrays.equals(sb.getBytes(1, (int) sb.length()),\n+                        sb2.getBytes(1, (int) sb2.length())),\n+                \"arrays do not match \");\n+    }\n+\n+    \/*\n+     * Test clone after free has been called that the clone is not accessible\n+     *\/\n+    @Test\n+    public void test19() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(bytes);\n+            sb.free();\n+            SerialBlob sb2 = (SerialBlob) sb.clone();\n+            InputStream is = sb2.getBinaryStream(1, 3);\n+        });\n+    }\n+\n+    \/*\n+     * Validate that a SerialBlob that is serialized & deserialized is equal to\n+     * itself\n+     *\/\n+    @Test\n+    public void test20() throws Exception {\n+        SerialBlob sb = new SerialBlob(bytes);\n+        SerialBlob sb2 = serializeDeserializeObject(sb);\n+        assertTrue(sb.equals(sb2), \"SerialBlob not equal\");\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if byte[] is used to\n+     * create the SeriablBlob and setBinaryStream is called\n+     *\/\n+    @Test\n+    public void test21() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialBlob sb = new SerialBlob(bytes);\n+            sb.setBinaryStream(3);\n+        });\n+    }\n+\n+    \/*\n+     * Validate that setBytes will properly write a set of bytes to the\n+     * specified location in the SerialBlob and the correct count is returned\n+     * for bytes written\n+     *\/\n+    @Test\n+    public void test22() throws Exception {\n+        byte[] diff = new byte[]{7, 8, 9};\n+        byte[] expected = new byte[]{1, 7, 8, 9, 5};\n+        SerialBlob sb = new SerialBlob(bytes);\n+        int written = sb.setBytes(2, diff);\n+        assertEquals(diff.length, written);\n+        assertTrue(\n+                Arrays.equals(sb.getBytes(1, (int) sb.length()),\n+                        expected),\n+                \"arrays do not match \");\n+    }\n+\n+    \/*\n+     * Validate that setBytes will properly write a set of bytes to the\n+     * specified location in the SerialBlob and the correct count is returned\n+     * for bytes written\n+     *\/\n+    @Test\n+    public void test23() throws Exception {\n+        int bytesToWrite = 3;\n+        byte[] diff = new byte[]{7, 8, 9, 0};\n+        byte[] expected = new byte[]{1, 8, 9, 0, 5};\n+        SerialBlob sb = new SerialBlob(bytes);\n+        int written = sb.setBytes(2, diff, 1, bytesToWrite);\n+        assertEquals(bytesToWrite, written);\n+        assertTrue(\n+                Arrays.equals(sb.getBytes(1, (int) sb.length()),\n+                        expected),\n+                \"arrays do not match \");\n+    }\n+\n+    \/*\n+     * Validate that truncate reduces the length of the SerlizedBlob to the\n+     * specified value\n+     *\/\n+    @Test\n+    public void test24() throws Exception {\n+        SerialBlob sb = new SerialBlob(bytes);\n+        sb.truncate(0);\n+        assertTrue(sb.length() == 0);\n+        sb = new SerialBlob(bytes);\n+        sb.truncate(3);\n+        assertTrue(sb.length() == 3);\n+    }\n+\n+    \/*\n+     * Validate getBinaryStream returns the correct bytes\n+     *\/\n+    @Test\n+    public void test25() throws Exception {\n+        byte[] expected = bytes;\n+        SerialBlob sb = new SerialBlob(bytes);\n+        InputStream is = sb.getBinaryStream();\n+        for (byte b : expected) {\n+            byte val = (byte) is.read();\n+            assertTrue(b == val, val + \" does not match \" + b);\n+        }\n+    }\n+\n+    \/*\n+     * Validate setBinaryStream returns an OutputStream when passed a Blob\n+     *\/\n+    @Test\n+    public void test26() throws Exception {\n+        SerialBlob sb = new SerialBlob(new StubBlob());\n+        OutputStream os = sb.setBinaryStream(0);\n+        assertTrue(os != null);\n+    }\n+\n+    \/*\n+     * Validate that position returns the correct starting location for a\n+     * pattern in the SerialBlob\n+     *\/\n+    @Test\n+    public void test27() throws Exception {\n+        long expectedPos = 3; \/\/ starting offset is 1 vs 0\n+        byte[] pattern = new byte[]{3, 4};\n+        SerialBlob sb = new SerialBlob(bytes);\n+        long pos = sb.position(pattern, 1);\n+        assertEquals(expectedPos, pos);\n+    }\n+\n+    \/*\n+     * Validate that position returns the correct starting location for a\n+     * pattern in the SerialBlob\n+     *\/\n+    @Test\n+    public void test28() throws Exception {\n+        long expectedPos = 3; \/\/ starting offset is 1 vs 0\n+        byte[] pattern = new byte[]{3, 4, 5};\n+        SerialBlob sb = new SerialBlob(bytes);\n+        long pos = sb.position(pattern, 2);\n+        assertEquals(expectedPos, pos);\n+    }\n+\n+    \/*\n+     * Validate that position returns the correct starting location for a\n+     * pattern in the SerialBlob\n+     *\/\n+    @Test\n+    public void test29() throws Exception {\n+        long expectedPos = 2; \/\/ starting offset is 1 vs 0\n+        byte[] pattern = new byte[]{4, 6};\n+        SerialBlob sb = new SerialBlob(new StubBlob());\n+        long pos = sb.position(pattern, 1);\n+        assertEquals(expectedPos, pos);\n+    }\n+\n+    \/*\n+     * Validate that position returns the correct starting location for a\n+     * pattern in the SerialBlob\n+     *\/\n+    @Test\n+    public void test30() throws Exception {\n+        long expectedPos = 3; \/\/ starting offset is 1 vs 0\n+        byte[] pattern = new byte[]{6, 8};\n+        SerialBlob sb = new SerialBlob(new StubBlob());\n+        long pos = sb.position(pattern, 2);\n+        assertEquals(expectedPos, pos);\n+    }\n+\n+    \/*\n+     * Validate that setBytes will properly write a set of bytes to the\n+     * specified location in the SerialBlob and the correct count is returned\n+     * for bytes written (writePos - 1 + diff.length > sb.length() &&\n+     * writePos - 1 + bytesToWrite <= sb.length())\n+     *\/\n+    @Test\n+    public void test31() throws Exception {\n+        int writePos = 5;\n+        int bytesToWrite = 1;\n+        byte[] diff = new byte[]{7, 8, 9};\n+        byte[] expected = new byte[]{1, 2, 3, 4, 7};\n+        SerialBlob sb = new SerialBlob(bytes);\n+        int written = sb.setBytes(writePos, diff, 0, bytesToWrite);\n+        assertEquals(bytesToWrite, written);\n+        assertArrayEquals(expected, sb.getBytes(1, (int) sb.length()));\n+    }\n+\n+    \/*\n+     * Validate that setBytes will properly write a set of bytes to the\n+     * specified location in the SerialBlob and the correct count is returned\n+     * for bytes written (writePos - 1 + bytesToWrite > sb.length())\n+     *\/\n+    @Test\n+    public void test32() throws Exception {\n+        int writePos = 5;\n+        int bytesToWrite = 2;\n+        byte[] diff = new byte[]{7, 8, 9, 0};\n+        byte[] expected = new byte[]{1, 2, 3, 4, 8, 9};\n+        SerialBlob sb = new SerialBlob(bytes);\n+        int written = sb.setBytes(writePos, diff, 1, bytesToWrite);\n+        assertEquals(bytesToWrite, written);\n+        assertArrayEquals(expected, sb.getBytes(1, (int) sb.length()));\n+    }\n+\n+    \/*\n+     * Validate that setBytes will properly write a set of bytes to the\n+     * specified location in the SerialBlob and the correct count is returned\n+     * for bytes written (writePos == sb.length() + 1)\n+     *\/\n+    @Test\n+    public void test33() throws Exception {\n+        int writePos = 6;\n+        int bytesToWrite = 3;\n+        byte[] diff = new byte[]{7, 8, 9, 0};\n+        byte[] expected = new byte[]{1, 2, 3, 4, 5, 8, 9, 0};\n+        SerialBlob sb = new SerialBlob(bytes);\n+        int written = sb.setBytes(writePos, diff, 1, bytesToWrite);\n+        assertEquals(bytesToWrite, written);\n+        assertArrayEquals(expected, sb.getBytes(1, (int) sb.length()));\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if length < 0 for setBytes\n+     *\/\n+    @Test\n+    public void test34() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            int length = -1;\n+            SerialBlob sb = new SerialBlob(bytes);\n+            int written = sb.setBytes(1, new byte[]{1}, 1, length);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if length + offset >\n+     * Integer.MAX_VALUE for setBytes\n+     *\/\n+    @Test\n+    public void test35() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            int offset = 1;\n+            int length = Integer.MAX_VALUE;\n+            SerialBlob sb = new SerialBlob(bytes);\n+            int written = sb.setBytes(1, new byte[]{1, 2, 3}, offset, length);\n+        });\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/serial\/SerialBlobTests.java","additions":515,"deletions":0,"binary":false,"changes":515,"status":"added"},{"patch":"@@ -0,0 +1,618 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset.serial;\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import javax.sql.rowset.serial.SerialClob;\n+import javax.sql.rowset.serial.SerialException;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import util.BaseTest;\n+import util.StubClob;\n+\n+public class SerialClobTests extends BaseTest {\n+\n+    \/\/ char[] used to populate SerialClob\n+    private final char[] chars;\n+\n+    public SerialClobTests() {\n+        this.chars = new char[]{'h', 'e', 'l', 'l', 'o', ' ', 'w',\n+            'o', 'r', 'l', 'd'};\n+    }\n+\n+    \/*\n+     * Validate calling free() does not throw an Exception\n+     *\/\n+    @Test\n+    public void test() throws Exception {\n+        SerialClob sc = new SerialClob(new StubClob());\n+        sc.free();\n+    }\n+\n+    \/*\n+     * Validate calling getCharacterStream() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test01() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.getCharacterStream();\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling getCharacterStream() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test02() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(chars);\n+            sc.free();\n+            sc.getCharacterStream();\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling getCharacterStream() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test03() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.getCharacterStream(1, 5);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling getSubString() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test04() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.getSubString(1, 1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling truncate() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test05() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.truncate(1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling getAsciiStream() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test06() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.getAsciiStream();\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling length() after calling free() throws an SerialException\n+     *\/\n+    @Test\n+    public void test07() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.length();\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling position() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test08() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.position(\"hello\", 1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling position() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test09() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.position(new StubClob(), 1);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling setAsciiStream() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test10() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.setAsciiStream(5);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling setCharacterStream() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test11() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.setCharacterStream(5);\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling setString() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test12() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.setString(1, \"hello\");\n+        });\n+    }\n+\n+    \/*\n+     * Validate calling setString() after calling free() throws an\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test13() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(new StubClob());\n+            sc.free();\n+            sc.setString(1, \"hello\", 0, 5);\n+        });\n+    }\n+\n+    \/*\n+     * Test that SerialException is thrown if pos < 0 on a call to\n+     * getCharacterStream\n+     *\/\n+    @Test\n+    public void test14() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(chars);\n+            sc.getCharacterStream(-1, 5);\n+        });\n+    }\n+\n+    \/*\n+     * Test that SerialException is thrown if pos = 0 on a call to\n+     * getCharacterStream\n+     *\/\n+    @Test\n+    public void test15() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(chars);\n+            sc.getCharacterStream(0, 5);\n+        });\n+    }\n+\n+    \/*\n+     * Test that SerialException is thrown if pos = 0 on a call to\n+     * getCharacterStream\n+     *\/\n+    @Test\n+    public void test16() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(chars);\n+            sc.getCharacterStream(1, 100);\n+        });\n+    }\n+\n+    \/*\n+     * Test that SerialException is thrown if length = 0 on a call to\n+     * getCharacterStream\n+     *\/\n+    @Test\n+    public void test17() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(chars);\n+            sc.getCharacterStream(1, 0);\n+        });\n+    }\n+\n+    \/*\n+     * Test that SerialException is thrown if pos > length on a call to\n+     * getCharacterStream\n+     *\/\n+    @Test\n+    public void test18() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialClob sc = new SerialClob(chars);\n+            sc.getCharacterStream(100, 5);\n+        });\n+    }\n+\n+    \/*\n+     * Clone a SerialClob and check that it is equal to itself\n+     *\/\n+    @Test\n+    public void test19() throws Exception {\n+        SerialClob sc = new SerialClob(chars);\n+        SerialClob sc1 = (SerialClob) sc.clone();\n+        assertTrue(sc.equals(sc1), \"SerialClobs not equal\");\n+    }\n+\n+    \/*\n+     * Validate that a getAsciiStream() returns an InputStream when a Clob is\n+     * used to create the SerialClob\n+     *\/\n+    @Test\n+    public void test20() throws Exception {\n+        SerialClob sc = new SerialClob(new StubClob());\n+        InputStream is = sc.getAsciiStream();\n+        assertTrue(is != null);\n+    }\n+\n+    \/*\n+     * Validate that a getCharacterStream() returns an Reader when a Clob is\n+     * used to create the SerialClob\n+     *\/\n+    @Test\n+    public void test21() throws Exception {\n+        SerialClob sc = new SerialClob(new StubClob());\n+        Reader is = sc.getCharacterStream();\n+        assertTrue(is != null);\n+    }\n+\n+    \/*\n+     * Validate that a getCharacterStream() returns an Reader when a char[] is\n+     * used to create the SerialClob\n+     *\/\n+    @Test\n+    public void test22() throws Exception {\n+        SerialClob sc = new SerialClob(chars);\n+        Reader is = sc.getCharacterStream();\n+        assertTrue(is != null);\n+    }\n+\n+    \/*\n+     * Validate that a getSubString() returns the correct value when a char[] is\n+     * used to create the SerialClob\n+     *\/\n+    @Test\n+    public void test23() throws Exception {\n+        SerialClob sc = new SerialClob(chars);\n+        String expected = \"world\";\n+        assertEquals(expected, sc.getSubString(7, 5));\n+    }\n+\n+    \/*\n+     * Validate that a getSubString() returns the correct value when a Clob is\n+     * used to create the SerialClob\n+     *\/\n+    @Test\n+    public void test24() throws Exception {\n+        SerialClob sc = new SerialClob(new StubClob());\n+        String expected = \"test string\";\n+        assertEquals(expected, sc.getSubString(5, 11));\n+    }\n+\n+    \/*\n+     * Validate that position() returns the correct value when a Clob is used to\n+     * create the SerialClob\n+     *\/\n+    @Test\n+    public void test25() throws Exception {\n+        long expectedPos = 5;\n+        SerialClob sc = new SerialClob(new StubClob());\n+        String expected = \"test string\";\n+        long pos = sc.position(expected, 1);\n+        assertEquals(expectedPos, pos);\n+    }\n+\n+    \/*\n+     * Validate that position returned is -1 when the search string is not\n+     * part of the SerialClob\n+     *\/\n+    @Test\n+    public void test26() throws Exception {\n+        long expectedPos = -1;\n+        SerialClob sc = new SerialClob(chars);\n+        String expected = \"test string\";\n+        long pos = sc.position(expected, 1);\n+        assertEquals(expectedPos, pos);\n+    }\n+\n+    \/*\n+     * Validate that position() returned is -1 when the search string is not\n+     * part of the SerialClob\n+     *\/\n+    @Test\n+    public void test27() throws Exception {\n+        long expectedPos = -1;\n+        SerialClob sc = new SerialClob(new StubClob());\n+        String expected = \"I am Batman\";\n+        long pos = sc.position(expected, 2);\n+        assertEquals(expectedPos, pos);\n+    }\n+\n+    \/*\n+     * Validate that position() returns the correct value when a char[] is used\n+     * to create the SerialClob\n+     *\/\n+    @Test\n+    public void test28() throws Exception {\n+        long expectedPos = 2;\n+        SerialClob sc = new SerialClob(chars);\n+        String expected = \"ello\";\n+        long pos = sc.position(expected, 1);\n+        assertEquals(expectedPos, pos);\n+    }\n+\n+    \/*\n+     * Validate that position() returns the correct value when a SerialClob is\n+     * used for the search argument\n+     *\/\n+    @Test\n+    public void test29() throws Exception {\n+        long expectedPos = 21;\n+        String expected = \"Batman\";\n+        String buf = \"I am Joker, not the Batman, hahaha\";\n+        SerialClob sc = new SerialClob(expected.toCharArray());\n+        SerialClob sc1 = new SerialClob(buf.toCharArray());\n+        long pos = sc1.position(sc, 1);\n+        assertEquals(expectedPos, pos);\n+    }\n+\n+    \/*\n+     * Validate that position() returns the correct value when a SerialClob is\n+     * used for the search argument\n+     *\/\n+    @Test\n+    public void test30() throws Exception {\n+        long expectedPos = 17;\n+        String expected = \"012\";\n+        SerialClob sc = new SerialClob(expected.toCharArray());\n+        SerialClob sc1 = new SerialClob(new StubClob());\n+        long pos = sc1.position(sc, 1);\n+        assertEquals(expectedPos, pos);\n+    }\n+\n+    \/*\n+     * Check that setString() updates the appropriate characters in the\n+     * SerialClob\n+     *\/\n+    @Test\n+    public void test31() throws Exception {\n+        String val = \"Hello, I am Bruce Wayne\";\n+        String val1 = \"the Batman!\";\n+        String expected = \"Hello, I am the Batman!\";\n+        SerialClob sc = new SerialClob(val.toCharArray());\n+        int written = sc.setString(13, val1);\n+        assertEquals(written, val1.length());\n+        assertTrue(expected.equals(sc.getSubString(1, (int) sc.length())));\n+    }\n+\n+    \/*\n+     * Check that setString() updates the appropriate characters in the\n+     * SerialClob (writePos - 1 + val1.length() - offset > sc.length() &&\n+     * writePos - 1 + expectedWritten <= sc.length())\n+     *\/\n+    @Test\n+    public void test32() throws Exception {\n+        int writePos = 10;\n+        int offset = 7;\n+        int expectedWritten = 9;\n+        String val = \"Hi, I am Catwoman!!!!!!\";\n+        String val1 = \"Hahaha the Joker, who are you?!\";\n+        String expected = \"Hi, I am the Joker!!!!!\";\n+        SerialClob sc = new SerialClob(val.toCharArray());\n+        int written = sc.setString(writePos, val1, offset, expectedWritten);\n+        assertEquals(expectedWritten, written);\n+        assertEquals(expected, sc.getSubString(1, (int) sc.length()));\n+    }\n+\n+    \/*\n+     * Check that setCharacterStream() returns a non-null Writer for an\n+     * SerialClob created from a Clob\n+     *\/\n+    @Test\n+    public void test33() throws Exception {\n+        SerialClob sc = new SerialClob(new StubClob());\n+        Writer w = sc.setCharacterStream(1);\n+        assertTrue(w != null);\n+    }\n+\n+    \/*\n+     * Check that setAsciiStream() returns a non-null OutputStream for an SerialClob\n+     * created from a Clob\n+     *\/\n+    @Test\n+    public void test34() throws Exception {\n+        SerialClob sc = new SerialClob(new StubClob());\n+        OutputStream os = sc.setAsciiStream(1);\n+        assertTrue(os != null);\n+    }\n+\n+    \/*\n+     * Check that truncate() truncates the length of the SerialClob to the\n+     * specified size\n+     *\/\n+    @Test\n+    public void test35() throws Exception {\n+        SerialClob sc = new SerialClob(new StubClob());\n+        sc.truncate(0);\n+        assertTrue(sc.length() == 0);\n+        sc = new SerialClob(chars);\n+        sc.truncate(5);\n+        assertTrue(sc.length() == 5);\n+    }\n+\n+    \/*\n+     * Check that getCharacterStream() returns a Reader and that the char[] that\n+     * was specified to create the SerialClob can be returned via the Reader\n+     *\/\n+    @Test\n+    public void test36() throws Exception {\n+        SerialClob sc = new SerialClob(chars);\n+        Reader r = sc.getCharacterStream();\n+        for (char c : chars) {\n+            char val = (char) r.read();\n+            assertTrue(c == val, val + \" does not match \" + c);\n+        }\n+    }\n+\n+    \/*\n+     * Check that getCharacterStream() returns a Reader and that the char[] that\n+     * was specified to create the SerialClob can be returned via the Reader\n+     *\/\n+    @Test\n+    @Disabled\n+    public void test37() throws Exception {\n+        SerialClob sc = new SerialClob(chars);\n+        String expected = \"ello w\";\n+        Reader r = sc.getCharacterStream(2, 6);\n+        for (char c : expected.toCharArray()) {\n+            char val = (char) r.read();\n+            assertTrue(c == val, val + \" does not match \" + c);\n+        }\n+    }\n+\n+    \/*\n+     * Validate that a SerialClob that is serialized & deserialized is equal to\n+     * itself\n+     *\/\n+    @Test\n+    public void test38() throws Exception {\n+        SerialClob sc = new SerialClob(chars);\n+        SerialClob sc2 = serializeDeserializeObject(sc);\n+        assertTrue(sc.equals(sc2), \"SerialClobs not equal\");\n+    }\n+\n+    \/*\n+     * Check calling setString() with offset > val1.length() throws a\n+     * SerialException\n+     *\/\n+    @Test\n+    public void test39() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            String val1 = \"hello\";\n+            int offset = val1.length() + 1;\n+            SerialClob sc = new SerialClob(chars);\n+            sc.setString(1, val1, offset, 0);\n+        });\n+    }\n+\n+    \/*\n+     * Check that setString() updates the appropriate characters in the\n+     * SerialClob (writePos - 1 + expectedWritten > sc.length())\n+     *\/\n+    @Test\n+    public void test40() throws Exception {\n+        int writePos = 13;\n+        int offset = 7;\n+        int expectedWritten = 24;\n+        String val = \"Hello, I am Bruce Wayne\";\n+        String val1 = \"Hahaha the Joker, who are you?!\";\n+        String expected = \"Hello, I am the Joker, who are you?!\";\n+        SerialClob sc = new SerialClob(val.toCharArray());\n+        int written = sc.setString(writePos, val1, offset, expectedWritten);\n+        assertEquals(expectedWritten, written);\n+        assertEquals(expected, sc.getSubString(1, (int) sc.length()));\n+    }\n+\n+    \/*\n+     * Check that setString() updates the appropriate characters in the\n+     * SerialClob (writePos == sc.length() + 1)\n+     *\/\n+    @Test\n+    public void test41() throws Exception {\n+        int writePos = 10;\n+        int offset = 7;\n+        int expectedWritten = 10;\n+        String val = \"Hi, I am \";\n+        String val1 = \"Hahaha the Joker!\";\n+        String expected = \"Hi, I am the Joker!\";\n+        SerialClob sc = new SerialClob(val.toCharArray());\n+        int written = sc.setString(writePos, val1, offset, expectedWritten);\n+        assertEquals(expectedWritten, written);\n+        assertEquals(expected, sc.getSubString(1, (int) sc.length()));\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if length < 0 for setString\n+     *\/\n+    @Test\n+    public void test42() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            int length = -1;\n+            SerialClob sc = new SerialClob(chars);\n+            int written = sc.setString(1, \"hello\", 1, length);\n+        });\n+    }\n+\n+    \/*\n+     * Validate a SerialException is thrown if length + offset >\n+     * Integer.MAX_VALUE for setString\n+     *\/\n+    @Test\n+    public void test43() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            int offset = 1;\n+            int length = Integer.MAX_VALUE;\n+            SerialClob sc = new SerialClob(chars);\n+            int written = sc.setString(1, \"hello\", offset, length);\n+        });\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/serial\/SerialClobTests.java","additions":618,"deletions":0,"binary":false,"changes":618,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,5 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -39,1 +41,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -49,1 +51,1 @@\n-    @Test(expectedExceptions = SerialException.class)\n+    @Test\n@@ -51,1 +53,3 @@\n-        SerialDatalink dl1 = new SerialDatalink(null);\n+        assertThrows(SerialException.class, () -> {\n+            SerialDatalink dl1 = new SerialDatalink(null);\n+        });\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/serial\/SerialDataLinkTests.java","additions":11,"deletions":7,"binary":false,"changes":18,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialDataLinkTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/serial\/SerialExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialExceptionTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset.serial;\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import javax.sql.rowset.RowSetMetaDataImpl;\n+import javax.sql.rowset.serial.SerialException;\n+import javax.sql.rowset.serial.SerialJavaObject;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import util.BaseTest;\n+\n+public class SerialJavaObjectTests extends BaseTest {\n+\n+    \/*\n+     * Validate that an NPE is thrown when null is specified to create\n+     * the SerialJavaObject\n+     *\/\n+    @Test\n+    public void test() throws Exception {\n+        assertThrows(NullPointerException.class, () -> {\n+            SerialJavaObject sjo = new SerialJavaObject(null);\n+        });\n+    }\n+\n+    \/*\n+     * Validate that a SerialException is thrown when the object specified\n+     * contains public static fields\n+     *\/\n+    @Test\n+    @Disabled\n+    public void test01() throws Exception {\n+        assertThrows(SerialException.class, () -> {\n+            SerialJavaObject sjo = new SerialJavaObject(new RowSetMetaDataImpl());\n+        });\n+    }\n+\n+    \/*\n+     * Validate that an getFields()s returns the same Field[] for the object\n+     * used to create the SerialJavaObject\n+     *\/\n+    @Test\n+    public void test02() throws Exception {\n+        SerialException e = new SerialException();\n+        SerialJavaObject sjo = new SerialJavaObject(e);\n+        Field[] f = e.getClass().getFields();\n+        assertTrue(Arrays.equals(f, sjo.getFields()));\n+        assertFalse(Arrays.equals(\"hello\".getClass().getFields(),\n+                sjo.getFields()));\n+    }\n+\n+    \/*\n+     * clone() a SerialJavaObject and check that it is equal to the\n+     * object it was cloned from\n+     *\/\n+    @Test\n+    public void test03() throws Exception {\n+        SerialJavaObject sjo = new SerialJavaObject(\"Hello\");\n+        SerialJavaObject sjo2 = (SerialJavaObject) sjo.clone();\n+        assertTrue(sjo.equals(sjo2));\n+    }\n+\n+    \/**\n+     * Validate that a SerialJavaObject that is serialized & deserialized is\n+     * equal to itself\n+     *\/\n+    @Test\n+    public void test04() throws Exception {\n+        SerialJavaObject sjo = new SerialJavaObject(\"Hello\");\n+        SerialJavaObject sjo2 = serializeDeserializeObject(sjo);\n+        assertTrue(sjo.equals(sjo2));\n+    }\n+\n+    \/*\n+     * Validate that a getObject() returns an object used to create the\n+     * SerialJavaObject\n+     *\/\n+    @Test\n+    public void test05() throws Exception {\n+        String s = \"Hello world\";\n+        SerialJavaObject sjo = new SerialJavaObject(s);\n+        assertTrue(s.equals(sjo.getObject()));\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/serial\/SerialJavaObjectTests.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset.serial;\n+\n+import java.sql.Ref;\n+import java.sql.SQLException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import javax.sql.rowset.serial.SerialRef;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import util.BaseTest;\n+import util.StubRef;\n+import util.SuperHero;\n+\n+public class SerialRefTests extends BaseTest {\n+\n+    private static Map<String, Class<?>> map = new HashMap<>();\n+    private Ref ref;\n+    private final String sqlType = \"SUPERHERO\";\n+    private SuperHero hero;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        map.put(sqlType, Class.forName(\"util.SuperHero\"));\n+        hero = new SuperHero(sqlType, \"Bruce\", \"Wayne\", 1939, \"Batman\");\n+        ref = new StubRef(sqlType, hero);\n+    }\n+\n+    \/*\n+     * Validate that a SQLException() is thrown if the Ref is null\n+     *\/\n+    @Test\n+    public void test01() throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            SerialRef sr = new SerialRef(null);\n+        });\n+    }\n+\n+    \/*\n+     * Validate that a SQLException() is thrown if the typeName is null in the\n+     * Ref used to create the SerialRef\n+     *\/\n+    @Test\n+    public void test02() throws Exception {\n+        assertThrows(SQLException.class, () -> {\n+            SerialRef sr = new SerialRef(new StubRef(null, hero));\n+        });\n+    }\n+\n+    \/*\n+     * Validate that getBaseTypeName() returns the same SQLType specified\n+     * to create the Ref\n+     *\/\n+    @Test\n+    public void test03() throws Exception {\n+        SerialRef sr = new SerialRef(ref);\n+        assertEquals(sqlType, sr.getBaseTypeName());\n+    }\n+\n+    \/*\n+     * Validate that getObject() returns the same object used to create the Ref\n+     *\/\n+    @Test\n+    public void test04() throws Exception {\n+        SerialRef sr = new SerialRef(ref);\n+        assertTrue(hero.equals(sr.getObject()));\n+    }\n+\n+    \/*\n+     * Validate that getObject() returns the same object used to create the Ref\n+     *\/\n+    @Test\n+    @Disabled\n+    public void test05() throws Exception {\n+        SerialRef sr = new SerialRef(ref);\n+        assertTrue(hero.equals(sr.getObject(map)));\n+    }\n+\n+    \/*\n+     * Validate that setObject() can be used to change the value of the object\n+     * pointed to by the SerialRef\n+     *\/\n+    @Test\n+    public void test06() throws Exception {\n+        SerialRef sr = new SerialRef(ref);\n+        assertTrue(hero.equals(sr.getObject()));\n+        SuperHero h = new SuperHero(sqlType, \"Dick\", \"Grayson\", 1940, \"Robin\");\n+        sr.setObject(h);\n+        assertFalse(hero.equals(sr.getObject()));\n+    }\n+\n+    \/*\n+     * clone() a SerialRef and check that it is equal to the\n+     * object it was cloned from\n+     *\/\n+    @Test\n+    public void test09() throws Exception {\n+        SerialRef sr = new SerialRef(ref);\n+        SerialRef sr1 = (SerialRef) sr.clone();\n+        assertTrue(sr.equals(sr1));\n+    }\n+\n+    \/**\n+     * Validate that a SerialRef that is serialized & deserialized is equal to\n+     * itself for the Object & baseTypeName\n+     *\/\n+    @Test\n+    public void test10() throws Exception {\n+        SerialRef sr = new SerialRef(ref);\n+        SerialRef sr1 = serializeDeserializeObject(sr);\n+        assertTrue(sr1.getObject().equals(sr.getObject())\n+                && sr1.getBaseTypeName().equals(sr.getBaseTypeName()));\n+    }\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/serial\/SerialRefTests.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,5 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -45,1 +47,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -61,1 +63,1 @@\n-        assertEquals(ss.getSQLTypeName(), sqlType);\n+        assertEquals(sqlType, ss.getSQLTypeName());\n@@ -71,1 +73,1 @@\n-        assertEquals(ss.getSQLTypeName(), sqlType);\n+        assertEquals(sqlType, ss.getSQLTypeName());\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/serial\/SerialStructTests.java","additions":9,"deletions":7,"binary":false,"changes":16,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialStructTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/spi\/SyncFactoryExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/spi\/SyncFactoryExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,5 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -70,1 +72,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -123,1 +125,1 @@\n-    @Test(expectedExceptions = SyncFactoryException.class)\n+    @Test\n@@ -125,1 +127,3 @@\n-        SyncProvider p = SyncFactory.getInstance(null);\n+        assertThrows(SyncFactoryException.class, () -> {\n+            SyncProvider p = SyncFactory.getInstance(null);\n+        });\n@@ -131,1 +135,1 @@\n-    @Test(expectedExceptions = SyncFactoryException.class,enabled=true)\n+    @Test\n@@ -133,1 +137,3 @@\n-        Logger l = SyncFactory.getLogger();\n+        assertThrows(SyncFactoryException.class, () -> {\n+            Logger l = SyncFactory.getLogger();\n+        });\n@@ -182,1 +188,1 @@\n-    @Test(expectedExceptions = SyncFactoryException.class, enabled=true)\n+    @Test\n@@ -184,1 +190,1 @@\n-        SyncFactory.setJNDIContext(null);\n+        assertThrows(SyncFactoryException.class, () -> SyncFactory.setJNDIContext(null));\n@@ -190,1 +196,1 @@\n-    @Test(enabled=true)\n+    @Test\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/spi\/SyncFactoryTests.java","additions":18,"deletions":12,"binary":false,"changes":30,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/spi\/SyncFactoryTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,5 +30,6 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -43,1 +44,1 @@\n-    @BeforeClass\n+    @BeforeAll\n@@ -48,1 +49,1 @@\n-    @AfterClass\n+    @AfterAll\n@@ -52,1 +53,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/spi\/SyncProviderExceptionTests.java","additions":10,"deletions":9,"binary":false,"changes":19,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/spi\/SyncProviderExceptionTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,421 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.rowset.webrowset;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.InputStreamReader;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStreamWriter;\n+import java.math.BigDecimal;\n+import java.sql.ResultSet;\n+import java.util.Arrays;\n+import javax.sql.rowset.WebRowSet;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import test.rowset.cachedrowset.CommonCachedRowSetTests;\n+\n+public abstract class CommonWebRowSetTests extends CommonCachedRowSetTests {\n+\n+    protected final String XMLFILEPATH = System.getProperty(\"test.src\", \".\")\n+            + File.separatorChar + \"xml\" + File.separatorChar;\n+    protected final String COFFEE_ROWS_XML = XMLFILEPATH + \"COFFEE_ROWS.xml\";\n+    protected final String DELETED_COFFEE_ROWS_XML\n+            = XMLFILEPATH + \"DELETED_COFFEE_ROWS.xml\";\n+    protected final String MODFIED_DELETED_COFFEE_ROWS_XML\n+            = XMLFILEPATH + \"MODFIED_DELETED_COFFEE_ROWS.xml\";\n+    protected final String UPDATED_COFFEE_ROWS_XML\n+            = XMLFILEPATH + \"UPDATED_COFFEE_ROWS.xml\";\n+    protected final String INSERTED_COFFEE_ROWS_XML\n+            = XMLFILEPATH + \"INSERTED_COFFEE_ROWS.xml\";\n+    protected final String UPDATED_INSERTED_COFFEE_ROWS_XML\n+            = XMLFILEPATH + \"UPDATED_INSERTED_COFFEE_ROWS.xml\";\n+\n+\n+    \/*\n+     * Utility method to write a WebRowSet XML file via an OutputStream\n+     *\/\n+    protected ByteArrayOutputStream writeWebRowSetWithOutputStream(WebRowSet rs) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            rs.writeXml(oos);\n+        }\n+        return baos;\n+    }\n+\n+    \/*\n+     * Utility method to write a WebRowSet XML file via an OutputStream\n+     * and populating the WebRowSet via a ResultSet\n+     *\/\n+    protected ByteArrayOutputStream writeWebRowSetWithOutputStream(ResultSet rs) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n+            WebRowSet wrs = rsf.createWebRowSet();\n+            wrs.writeXml(rs, oos);\n+        }\n+        return baos;\n+    }\n+\n+\n+    \/*\n+     * Utility method to popoulate a WebRowSet via a InputStream\n+     *\/\n+    protected WebRowSet readWebRowSetWithOInputStream(ByteArrayOutputStream baos) throws Exception {\n+        WebRowSet wrs1 = rsf.createWebRowSet();\n+        try (ObjectInputStream ois\n+                = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()))) {\n+            wrs1.readXml(ois);\n+        }\n+        return wrs1;\n+    }\n+\n+    \/*\n+     * Utility method to write a WebRowSet XML file via an Writer\n+     *\/\n+    protected ByteArrayOutputStream writeWebRowSetWithOutputStreamWithWriter(WebRowSet rs) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        OutputStreamWriter osw = new OutputStreamWriter(baos);\n+        rs.writeXml(osw);\n+        return baos;\n+    }\n+\n+    \/*\n+     * Utility method to write a WebRowSet XML file via an Writer and populating\n+     * the WebRowSet via a ResultSet\n+     *\/\n+    protected ByteArrayOutputStream writeWebRowSetWithOutputStreamWithWriter(ResultSet rs) throws Exception {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        OutputStreamWriter osw = new OutputStreamWriter(baos);\n+        WebRowSet wrs = rsf.createWebRowSet();\n+        wrs.writeXml(rs, osw);\n+        return baos;\n+    }\n+\n+    \/*\n+     * Utility method to popoulate a WebRowSet via a Readar\n+     *\/\n+    protected WebRowSet readWebRowSetWithOInputStreamWithReader(ByteArrayOutputStream baos) throws Exception {\n+        WebRowSet wrs1 = rsf.createWebRowSet();\n+        InputStreamReader isr = new InputStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n+        wrs1.readXml(isr);\n+        return wrs1;\n+    }\n+\n+    \/*\n+     * Validate the expected Rows are contained within the RowSet\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffees\")\n+    public void WebRowSetTest0000(WebRowSet wrs) throws Exception {\n+        assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs));\n+        assertEquals(COFFEES_ROWS, wrs.size());\n+        wrs.close();\n+    }\n+\n+    \/*\n+     * Validate the expected Rows are contained within the RowSet\n+     * populated by readXML(Reader)\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void WebRowSetTest0001(WebRowSet wrs1) throws Exception {\n+\n+        try (FileReader fr = new FileReader(COFFEE_ROWS_XML)) {\n+            wrs1.readXml(fr);\n+        }\n+        assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs1));\n+        assertEquals(COFFEES_ROWS, wrs1.size());\n+        wrs1.close();\n+\n+    }\n+\n+    \/*\n+     * Validate the expected Rows are contained within the RowSet\n+     * populated by readXML(InputStream)\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void WebRowSetTest0002(WebRowSet wrs1) throws Exception {\n+        try (FileInputStream fis = new FileInputStream(COFFEE_ROWS_XML)) {\n+            wrs1.readXml(fis);\n+        }\n+        assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs1));\n+        assertEquals(COFFEES_ROWS, wrs1.size());\n+        wrs1.close();\n+    }\n+\n+    \/*\n+     * Write a WebRowSet via writeXML(OutputStream), read it\n+     * back via readXML(InputStream) and validate the primary  keys\n+     * are the same\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffees\")\n+    public void WebRowSetTest0003(WebRowSet wrs) throws Exception {\n+        ByteArrayOutputStream baos = writeWebRowSetWithOutputStream(wrs);\n+        try (WebRowSet wrs1 = readWebRowSetWithOInputStream(baos)) {\n+            assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs1));\n+            assertEquals(COFFEES_ROWS, wrs1.size());\n+        }\n+    }\n+\n+    \/*\n+     * Write a ResultSet via writeXML(OutputStream), read it\n+     * back via readXML(InputStream) and validate the primary  keys\n+     * are the same\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffees\")\n+    public void WebRowSetTest0004(WebRowSet wrs) throws Exception {\n+        ResultSet rs = wrs;\n+        rs.beforeFirst();\n+        ByteArrayOutputStream baos = writeWebRowSetWithOutputStream(rs);\n+        try (WebRowSet wrs1 = readWebRowSetWithOInputStream(baos)) {\n+            assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs1));\n+            assertEquals(COFFEES_ROWS, wrs1.size());\n+        }\n+    }\n+\n+    \/*\n+     * Write a WebRowSet via writeXML(Writer), read it\n+     * back via readXML(Reader) and validate the primary  keys\n+     * are the same\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffees\")\n+    public void WebRowSetTest0005(WebRowSet wrs) throws Exception {\n+        ByteArrayOutputStream baos = writeWebRowSetWithOutputStreamWithWriter(wrs);\n+        try (WebRowSet wrs1 = readWebRowSetWithOInputStreamWithReader(baos)) {\n+            assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs1));\n+            assertEquals(COFFEES_ROWS, wrs1.size());\n+        }\n+    }\n+\n+    \/*\n+     * Write a WebRowSet via writeXML(Writer), read it\n+     * back via readXML(Reader) and validate the primary  keys\n+     * are the same\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffees\")\n+    public void WebRowSetTest0006(WebRowSet wrs) throws Exception {\n+        ResultSet rs = wrs;\n+        rs.beforeFirst();\n+        ByteArrayOutputStream baos = writeWebRowSetWithOutputStreamWithWriter(rs);\n+        try (WebRowSet wrs1 = readWebRowSetWithOInputStreamWithReader(baos)) {\n+            assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs1));\n+            assertEquals(COFFEES_ROWS, wrs1.size());\n+        }\n+    }\n+\n+    \/*\n+     * Validate the expected Rows are contained within the RowSet\n+     * after deleting the specified rows\n+     *\/\n+    @Disabled\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowsetUsingCoffees\")\n+    public void WebRowSetTest0007(WebRowSet wrs) throws Exception {\n+        assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs));\n+        int[] rowsToDelete = {2, 4};\n+        assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs));\n+        for (int row : rowsToDelete) {\n+            assertTrue(deleteRowByPrimaryKey(wrs, row, 1));\n+        }\n+\n+        FileInputStream fis = new FileInputStream(MODFIED_DELETED_COFFEE_ROWS_XML);\n+        try (WebRowSet wrs1 = rsf.createWebRowSet()) {\n+            wrs1.readXml(fis);\n+            \/\/ With setShowDeleted(false) which is the default,\n+            \/\/ the deleted row should not be visible\n+            for (int row : rowsToDelete) {\n+                assertTrue(findRowByPrimaryKey(wrs1, row, 1));\n+            }\n+            assertTrue(wrs.size() == COFFEES_ROWS);\n+            \/\/ With setShowDeleted(true), the deleted row should be visible\n+            for (int row : rowsToDelete) {\n+                assertTrue(findRowByPrimaryKey(wrs, row, 1));\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Validate the expected Rows are contained within the RowSet\n+     * that was populated by reading an xml file with all rows\n+     * marked as a currentRow\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void WebRowSetTest0008(WebRowSet wrs1) throws Exception {\n+        FileInputStream fis = new FileInputStream(COFFEE_ROWS_XML);\n+        wrs1.readXml(fis);\n+        assertTrue(wrs1.size() == COFFEES_ROWS);\n+        assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs1));\n+        \/\/ Validate that the rows are not marked as deleted, inserted or updated\n+        wrs1.beforeFirst();\n+        while (wrs1.next()) {\n+            assertFalse(wrs1.rowDeleted());\n+            assertFalse(wrs1.rowInserted());\n+            assertFalse(wrs1.rowUpdated());\n+        }\n+        wrs1.close();\n+    }\n+\n+    \/*\n+     * Read an XML file to populate a WebRowSet and validate that the rows\n+     * that are marked as deleted are marked as such in the WebRowSet\n+     * Also validate that they are or are not visible based on the\n+     * setShowDeleted value\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void WebRowSetTest0009(WebRowSet wrs1) throws Exception {\n+        int[] rowsToDelete = {2, 4};\n+        Object[] expectedRows = {1, 3, 5};\n+        FileInputStream fis = new FileInputStream(DELETED_COFFEE_ROWS_XML);\n+        wrs1.readXml(fis);\n+        assertTrue(wrs1.size() == COFFEES_ROWS);\n+        assertArrayEquals(expectedRows, getPrimaryKeys(wrs1));\n+        \/\/ With setShowDeleted(false) which is the default,\n+        \/\/ the deleted row should not be visible\n+        for (int row : rowsToDelete) {\n+            assertFalse(findRowByPrimaryKey(wrs1, row, 1));\n+        }\n+        \/\/ With setShowDeleted(true), the deleted row should be visible\n+        wrs1.setShowDeleted(true);\n+        for (int row : rowsToDelete) {\n+            assertTrue(findRowByPrimaryKey(wrs1, row, 1));\n+        }\n+        assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs1));\n+        wrs1.close();\n+\n+    }\n+\n+    \/*\n+     * Validate that the correct row in the WebRowSet that had been created\n+     * from an xml file is marked as updated and contains the correct values\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void WebRowSetTest0010(WebRowSet wrs1) throws Exception {\n+        FileInputStream fis = new FileInputStream(UPDATED_COFFEE_ROWS_XML);\n+        wrs1.readXml(fis);\n+        assertTrue(wrs1.size() == COFFEES_ROWS);\n+        assertArrayEquals(COFFEES_PRIMARY_KEYS, getPrimaryKeys(wrs1));\n+        wrs1.beforeFirst();\n+        while (wrs1.next()) {\n+            if (wrs1.getInt(1) == 3) {\n+                assertTrue(wrs1.rowUpdated());\n+                assertTrue(wrs1.getInt(5) == 21 && wrs1.getInt(6) == 69);\n+                assertFalse(wrs1.rowDeleted());\n+                assertFalse(wrs1.rowInserted());\n+            } else {\n+                assertFalse(wrs1.rowUpdated());\n+                assertFalse(wrs1.rowDeleted());\n+                assertFalse(wrs1.rowInserted());\n+            }\n+        }\n+        wrs1.close();\n+    }\n+\n+    \/*\n+     * Validate the correct row is marked as inserted in a WebRowSet\n+     * that is read from an xml file\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void WebRowSetTest0011(WebRowSet wrs1) throws Exception {\n+        int expectedSize = COFFEES_ROWS + 2;\n+        int addedRowPK = 15;\n+        int addedRowPK2 = 20;\n+        Object[] expected = Arrays.copyOf(COFFEES_PRIMARY_KEYS, expectedSize);\n+        expected[expectedSize - 2] = addedRowPK;\n+        expected[expectedSize - 1] = addedRowPK2;\n+        FileInputStream fis = new FileInputStream(INSERTED_COFFEE_ROWS_XML);\n+        wrs1.readXml(fis);\n+        assertTrue(wrs1.size() == expectedSize);\n+        var actual = getPrimaryKeys(wrs1);\n+        Arrays.sort(actual);\n+        Arrays.sort(expected);\n+        assertArrayEquals(expected, actual);\n+        wrs1.beforeFirst();\n+        while (wrs1.next()) {\n+            if (wrs1.getInt(1) == 15 || wrs1.getInt(1) == 20) {\n+                assertTrue(wrs1.rowInserted());\n+                assertFalse(wrs1.rowDeleted());\n+                assertFalse(wrs1.rowUpdated());\n+            } else {\n+                assertFalse(wrs1.rowInserted());\n+                assertFalse(wrs1.rowDeleted());\n+                assertFalse(wrs1.rowUpdated());\n+            }\n+        }\n+        wrs1.close();\n+    }\n+\n+    \/*\n+     * Read an xml file which contains a row that was inserted and updated\n+     *\/\n+    @ParameterizedTest(autoCloseArguments = false)\n+    @MethodSource(\"rowSetType\")\n+    public void WebRowSetTest0012(WebRowSet wrs1) throws Exception {\n+        int expectedSize = COFFEES_ROWS + 1;\n+        int addedRowPK = 100;\n+        Object[] expected = Arrays.copyOf(COFFEES_PRIMARY_KEYS, expectedSize);\n+        expected[expectedSize - 1] = addedRowPK;\n+        FileInputStream fis = new FileInputStream(UPDATED_INSERTED_COFFEE_ROWS_XML);\n+        wrs1.readXml(fis);\n+        assertTrue(wrs1.size() == expectedSize);\n+        assertArrayEquals(expected, getPrimaryKeys(wrs1));\n+        wrs1.beforeFirst();\n+        while (wrs1.next()) {\n+            if (wrs1.getInt(1) == addedRowPK) {\n+                \/\/ Row that was inserted and updated\n+                assertTrue(wrs1.rowUpdated());\n+                assertTrue(\n+                        wrs1.getBigDecimal(4).equals(BigDecimal.valueOf(12.99))\n+                        && wrs1.getInt(6) == 125);\n+                assertFalse(wrs1.rowDeleted());\n+                assertTrue(wrs1.rowInserted());\n+            } else {\n+                \/\/ Remaining rows should only be inserted\n+                assertFalse(wrs1.rowUpdated());\n+                assertFalse(wrs1.rowDeleted());\n+                assertTrue(wrs1.rowInserted());\n+            }\n+        }\n+        wrs1.close();\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/webrowset\/CommonWebRowSetTests.java","additions":421,"deletions":0,"binary":false,"changes":421,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/test\/rowset\/webrowset\/WebRowSetTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/webrowset\/WebRowSetTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/PropertyStubProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/PropertyStubProvider.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubArray.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubArray.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubBaseRowSet.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubBaseRowSet.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubBlob.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubBlob.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubCachedRowSetImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubCachedRowSetImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubClob.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubClob.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubContext.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubFilteredRowSetImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubFilteredRowSetImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubJdbcRowSetImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubJdbcRowSetImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubJoinRowSetImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubJoinRowSetImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubNClob.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubNClob.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubRef.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubRef.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubRowId.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubRowId.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubRowSetFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubRowSetFactory.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubSQLXML.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubSQLXML.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubStruct.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubStruct.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubSyncProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubSyncProvider.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubSyncResolver.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubSyncResolver.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/StubWebRowSetImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/StubWebRowSetImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/SuperHero.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/SuperHero.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/TestRowSetListener.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/TestRowSetListener.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/sql\/junit\/util\/TestSQLDataImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/javax\/sql\/testng\/util\/TestSQLDataImpl.java","status":"renamed"},{"patch":"","filename":"test\/jdk\/javax\/sql\/junit\/xml\/COFFEE_ROWS.xml","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/sql\/testng\/xml\/COFFEE_ROWS.xml","status":"renamed"},{"patch":"","filename":"test\/jdk\/javax\/sql\/junit\/xml\/DELETED_COFFEE_ROWS.xml","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/sql\/testng\/xml\/DELETED_COFFEE_ROWS.xml","status":"renamed"},{"patch":"","filename":"test\/jdk\/javax\/sql\/junit\/xml\/INSERTED_COFFEE_ROWS.xml","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/sql\/testng\/xml\/INSERTED_COFFEE_ROWS.xml","status":"renamed"},{"patch":"","filename":"test\/jdk\/javax\/sql\/junit\/xml\/MODFIED_DELETED_COFFEE_ROWS.xml","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/sql\/testng\/xml\/MODFIED_DELETED_COFFEE_ROWS.xml","status":"renamed"},{"patch":"","filename":"test\/jdk\/javax\/sql\/junit\/xml\/UPDATED_COFFEE_ROWS.xml","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/sql\/testng\/xml\/UPDATED_COFFEE_ROWS.xml","status":"renamed"},{"patch":"","filename":"test\/jdk\/javax\/sql\/junit\/xml\/UPDATED_INSERTED_COFFEE_ROWS.xml","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/javax\/sql\/testng\/xml\/UPDATED_INSERTED_COFFEE_ROWS.xml","status":"renamed"},{"patch":"@@ -1,7 +0,0 @@\n-# JDBC unit tests uses TestNG\n-TestNG.dirs= .\n-othervm.dirs= .\n-lib.dirs = \/java\/sql\/testng\n-modules = java.sql.rowset\/com.sun.rowset \\\n-          java.sql.rowset\/com.sun.rowset.internal \\\n-          java.sql.rowset\/com.sun.rowset.providers\n","filename":"test\/jdk\/javax\/sql\/testng\/TEST.properties","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,444 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset;\n-\n-import java.io.InputStream;\n-import java.io.Reader;\n-import java.io.StringBufferInputStream;\n-import java.io.StringReader;\n-import java.math.BigDecimal;\n-import java.sql.Array;\n-import java.sql.Blob;\n-import java.sql.Clob;\n-import java.sql.Date;\n-import java.sql.Ref;\n-import java.sql.SQLException;\n-import java.sql.Time;\n-import java.sql.Timestamp;\n-import java.sql.Types;\n-import java.time.LocalDate;\n-import java.time.LocalDateTime;\n-import java.time.LocalTime;\n-import java.util.Calendar;\n-import javax.sql.RowSet;\n-import javax.sql.rowset.serial.SerialArray;\n-import javax.sql.rowset.serial.SerialBlob;\n-import javax.sql.rowset.serial.SerialClob;\n-import javax.sql.rowset.serial.SerialRef;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import util.StubArray;\n-import util.StubBaseRowSet;\n-import util.StubBlob;\n-import util.StubClob;\n-import util.StubRef;\n-import util.TestRowSetListener;\n-\n-public class BaseRowSetTests extends CommonRowSetTests {\n-\n-    private StubBaseRowSet brs;\n-\n-    @Override\n-    protected RowSet newInstance() throws SQLException {\n-        return new StubBaseRowSet();\n-    }\n-\n-    \/*\n-     * Create a RowSetListener and validate that notifyCursorMoved is called\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void baseRowSetTest0000(StubBaseRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.notifyCursorMoved();\n-        assertTrue(rsl.isNotified(TestRowSetListener.CURSOR_MOVED));\n-    }\n-\n-    \/*\n-     * Create a RowSetListener and validate that notifyRowChanged is called\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void baseRowSetTest0001(StubBaseRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.notifyRowChanged();\n-        assertTrue(rsl.isNotified(TestRowSetListener.ROW_CHANGED));\n-    }\n-\n-    \/*\n-     * Create a RowSetListener and validate that notifyRowSetChanged is called\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void baseRowSetTest0002(StubBaseRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.notifyRowSetChanged();\n-        assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n-    }\n-\n-    \/*\n-     * Create multiple RowSetListeners and validate that notifyRowSetChanged\n-     * is called on all listeners\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void baseRowSetTest0003(StubBaseRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        TestRowSetListener rsl2 = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.addRowSetListener(rsl2);\n-        rs.notifyRowSetChanged();\n-        assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n-        assertTrue(rsl2.isNotified(TestRowSetListener.ROWSET_CHANGED));\n-    }\n-\n-    \/*\n-     * Create multiple RowSetListeners and validate that notifyRowChanged\n-     * is called on all listeners\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void baseRowSetTest0004(StubBaseRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        TestRowSetListener rsl2 = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.addRowSetListener(rsl2);\n-        rs.notifyRowChanged();\n-        assertTrue(rsl.isNotified(TestRowSetListener.ROW_CHANGED));\n-        assertTrue(rsl2.isNotified(TestRowSetListener.ROW_CHANGED));\n-    }\n-\n-    \/*\n-     * Create multiple RowSetListeners and validate that notifyCursorMoved\n-     * is called on all listeners\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void baseRowSetTest0005(StubBaseRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        TestRowSetListener rsl2 = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.addRowSetListener(rsl2);\n-        rs.notifyCursorMoved();\n-        assertTrue(rsl.isNotified(TestRowSetListener.CURSOR_MOVED));\n-        assertTrue(rsl2.isNotified(TestRowSetListener.CURSOR_MOVED));\n-    }\n-\n-    \/*\n-     * Create a RowSetListener and validate that notifyRowSetChanged,\n-     * notifyRowChanged() and notifyCursorMoved are called\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void baseRowSetTest0006(StubBaseRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.notifyRowSetChanged();\n-        rs.notifyRowChanged();\n-        rs.notifyCursorMoved();\n-        assertTrue(rsl.isNotified(\n-                TestRowSetListener.CURSOR_MOVED | TestRowSetListener.ROWSET_CHANGED\n-                | TestRowSetListener.ROW_CHANGED));\n-    }\n-\n-\n-    \/*\n-     * Create multiple RowSetListeners and validate that notifyRowSetChanged,\n-     * notifyRowChanged() and notifyCursorMoved are called on all listeners\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void baseRowSetTest0007(StubBaseRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        TestRowSetListener rsl2 = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.addRowSetListener(rsl2);\n-        rs.notifyRowSetChanged();\n-        rs.notifyRowChanged();\n-        rs.notifyCursorMoved();\n-        assertTrue(rsl.isNotified(\n-                TestRowSetListener.CURSOR_MOVED | TestRowSetListener.ROWSET_CHANGED\n-                | TestRowSetListener.ROW_CHANGED));\n-        assertTrue(rsl2.isNotified(\n-                TestRowSetListener.CURSOR_MOVED | TestRowSetListener.ROWSET_CHANGED\n-                | TestRowSetListener.ROW_CHANGED));\n-    }\n-\n-    \/*\n-     * Create a RowSetListener and validate that notifyRowSetChanged is called,\n-     * remove the listener, invoke notifyRowSetChanged again and verify the\n-     * listner is not called\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void baseRowSetTest0008(StubBaseRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.notifyRowSetChanged();\n-        assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n-        \/\/ Clear the flag indicating the listener has been called\n-        rsl.resetFlag();\n-        rs.removeRowSetListener(rsl);\n-        rs.notifyRowSetChanged();\n-        assertFalse(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n-    }\n-\n-    \/*\n-     * Set the base parameters and validate that the value set is\n-     * the correct type and value\n-     *\/\n-    @Test(dataProvider = \"testBaseParameters\")\n-    public void baseRowSetTest0009(int pos, Object o) throws Exception {\n-        assertTrue(getParam(pos, o).getClass().isInstance(o));\n-        assertTrue(o.equals(getParam(pos, o)));\n-    }\n-\n-    \/*\n-     * Set the complex parameters and validate that the value set is\n-     * the correct type\n-     *\/\n-    @Test(dataProvider = \"testAdvancedParameters\")\n-    public void baseRowSetTest0010(int pos, Object o) throws Exception {\n-        assertTrue(getParam(pos, o).getClass().isInstance(o));\n-    }\n-\n-    \/*\n-     * Validate setNull specifying the supported type values\n-     *\/\n-    @Test(dataProvider = \"jdbcTypes\")\n-    public void baseRowSetTest0011(Integer type) throws Exception {\n-        brs = new StubBaseRowSet();\n-        brs.setNull(1, type);\n-        assertTrue(checkNullParam(1, type, null));\n-    }\n-\n-    \/*\n-     * Validate setNull specifying the supported type values and that\n-     * typeName is set internally\n-     *\/\n-    @Test(dataProvider = \"jdbcTypes\")\n-    public void baseRowSetTest0012(Integer type) throws Exception {\n-        brs = new StubBaseRowSet();\n-        brs.setNull(1, type, \"SUPERHERO\");\n-        assertTrue(checkNullParam(1, type, \"SUPERHERO\"));\n-    }\n-\n-    \/*\n-     *  Validate that setDate sets the specified Calendar internally\n-     *\/\n-    @Test()\n-    public void baseRowSetTest0013() throws Exception {\n-        Calendar cal = Calendar.getInstance();\n-        brs = new StubBaseRowSet();\n-        brs.setDate(1, Date.valueOf(LocalDate.now()), cal);\n-        assertTrue(checkCalendarParam(1, cal));\n-    }\n-\n-    \/*\n-     *  Validate that setTime sets the specified Calendar internally\n-     *\/\n-    @Test()\n-    public void baseRowSetTest0014() throws Exception {\n-        Calendar cal = Calendar.getInstance();\n-        brs = new StubBaseRowSet();\n-        brs.setTime(1, Time.valueOf(LocalTime.now()), cal);\n-        assertTrue(checkCalendarParam(1, cal));\n-    }\n-\n-    \/*\n-     *  Validate that setTimestamp sets the specified Calendar internally\n-     *\/\n-    @Test()\n-    public void baseRowSetTest0015() throws Exception {\n-        Calendar cal = Calendar.getInstance();\n-        brs = new StubBaseRowSet();\n-        brs.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now()), cal);\n-        assertTrue(checkCalendarParam(1, cal));\n-    }\n-\n-    \/*\n-     * Validate that initParams() initializes the parameters\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void baseRowSetTest0016(StubBaseRowSet rs) throws Exception {\n-        rs.setInt(1, 1);\n-        rs.initParams();\n-        assertTrue(rs.getParams().length == 0);\n-    }\n-\n-\n-    \/*\n-     * DataProvider used to set parameters for basic types that are supported\n-     *\/\n-    @DataProvider(name = \"testBaseParameters\")\n-    private Object[][] testBaseParameters() throws SQLException {\n-        Integer aInt = 1;\n-        Long aLong = Long.MAX_VALUE;\n-        Short aShort = Short.MIN_VALUE;\n-        BigDecimal bd = BigDecimal.ONE;\n-        Double aDouble = Double.MAX_VALUE;\n-        Date aDate = Date.valueOf(LocalDate.now());\n-        Time aTime = Time.valueOf(LocalTime.now());\n-        Timestamp aTimeStamp = Timestamp.valueOf(LocalDateTime.now());\n-        Calendar cal = Calendar.getInstance();\n-        Boolean aBoolean = true;\n-        Float aFloat = 1.5f;\n-        Byte aByte = 1;\n-        brs = new StubBaseRowSet();\n-\n-        brs.setInt(1, aInt);\n-        brs.setString(2, query);\n-        brs.setLong(3, aLong);\n-        brs.setBoolean(4, aBoolean);\n-        brs.setShort(5, aShort);\n-        brs.setDouble(6, aDouble);\n-        brs.setBigDecimal(7, bd);\n-        brs.setFloat(8, aFloat);\n-        brs.setByte(9, aByte);\n-        brs.setDate(10, aDate);\n-        brs.setTime(11, aTime);\n-        brs.setTimestamp(12, aTimeStamp);\n-        brs.setDate(13, aDate, cal);\n-        brs.setTime(14, aTime, cal);\n-        brs.setTimestamp(15, aTimeStamp);\n-        brs.setObject(16, query);\n-        brs.setObject(17, query, Types.CHAR);\n-        brs.setObject(18, query, Types.CHAR, 0);\n-\n-        return new Object[][]{\n-            {1, aInt},\n-            {2, query},\n-            {3, aLong},\n-            {4, aBoolean},\n-            {5, aShort},\n-            {6, aDouble},\n-            {7, bd},\n-            {8, aFloat},\n-            {9, aByte},\n-            {10, aDate},\n-            {11, aTime},\n-            {12, aTimeStamp},\n-            {13, aDate},\n-            {14, aTime},\n-            {15, aTimeStamp},\n-            {16, query},\n-            {17, query},\n-            {18, query}\n-\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to set advanced parameters for types that are supported\n-     *\/\n-    @DataProvider(name = \"testAdvancedParameters\")\n-    private Object[][] testAdvancedParameters() throws SQLException {\n-\n-        byte[] bytes = new byte[10];\n-        Ref aRef = new SerialRef(new StubRef(\"INTEGER\", query));\n-        Array aArray = new SerialArray(new StubArray(\"INTEGER\", new Object[1]));\n-        Blob aBlob = new SerialBlob(new StubBlob());\n-        Clob aClob = new SerialClob(new StubClob());\n-        Reader rdr = new StringReader(query);\n-        InputStream is = new StringBufferInputStream(query);\n-        brs = new StubBaseRowSet();\n-        brs.setBytes(1, bytes);\n-        brs.setAsciiStream(2, is, query.length());\n-        brs.setRef(3, aRef);\n-        brs.setArray(4, aArray);\n-        brs.setBlob(5, aBlob);\n-        brs.setClob(6, aClob);\n-        brs.setBinaryStream(7, is, query.length());\n-        brs.setUnicodeStream(8, is, query.length());\n-        brs.setCharacterStream(9, rdr, query.length());\n-\n-        return new Object[][]{\n-            {1, bytes},\n-            {2, is},\n-            {3, aRef},\n-            {4, aArray},\n-            {5, aBlob},\n-            {6, aClob},\n-            {7, is},\n-            {8, is},\n-            {9, rdr}\n-        };\n-    }\n-\n-    \/*\n-     *  Method that returns the specified parameter instance that was set via setXXX\n-     *  Note non-basic types are stored as an Object[] where the 1st element\n-     *  is the object instnace\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    private <T> T getParam(int pos, T o) throws SQLException {\n-        Object[] params = brs.getParams();\n-        if (params[pos - 1] instanceof Object[]) {\n-            Object[] param = (Object[]) params[pos - 1];\n-            return (T) param[0];\n-        } else {\n-            return (T) params[pos - 1];\n-        }\n-    }\n-\n-    \/*\n-     * Utility method to validate parameters when the param is an Object[]\n-     *\/\n-    private boolean checkParam(int pos, int type, Object val) throws SQLException {\n-        boolean result = false;\n-        Object[] params = brs.getParams();\n-        if (params[pos - 1] instanceof Object[]) {\n-            Object[] param = (Object[]) params[pos - 1];\n-\n-            if (param[0] == null) {\n-                \/\/ setNull was used\n-                if (param.length == 2 && (Integer) param[1] == type) {\n-                    result = true;\n-                } else {\n-                    if (param.length == 3 && (Integer) param[1] == type\n-                            && val.equals(param[2])) {\n-                        result = true;\n-                    }\n-                }\n-\n-            } else if (param[0] instanceof java.util.Date) {\n-                \/\/ setDate\/Time\/Timestamp with a Calendar object\n-                if (param[1] instanceof Calendar && val.equals(param[1])) {\n-                    result = true;\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    \/*\n-     * Wrapper method for validating that a null was set and the appropriate\n-     * type and typeName if applicable\n-     *\/\n-    private boolean checkNullParam(int pos, int type, String typeName) throws SQLException {\n-        return checkParam(pos, type, typeName);\n-    }\n-\n-    \/*\n-     *  Wrapper method for validating that a Calander was set\n-     *\/\n-    private boolean checkCalendarParam(int pos, Calendar cal) throws SQLException {\n-        \/\/ 2nd param is ignored when instanceof java.util.Date\n-        return checkParam(pos, Types.DATE, cal);\n-    }\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/BaseRowSetTests.java","additions":0,"deletions":444,"binary":false,"changes":444,"status":"deleted"},{"patch":"@@ -1,1372 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset;\n-\n-import java.io.InputStream;\n-import java.io.Reader;\n-import java.math.BigDecimal;\n-import java.sql.Connection;\n-import java.sql.Date;\n-import java.sql.ResultSet;\n-import java.sql.ResultSetMetaData;\n-import java.sql.RowId;\n-import java.sql.SQLException;\n-import java.sql.SQLFeatureNotSupportedException;\n-import java.sql.Time;\n-import java.sql.Timestamp;\n-import java.sql.Types;\n-import java.time.LocalDate;\n-import java.time.LocalDateTime;\n-import java.time.LocalTime;\n-import java.util.ArrayList;\n-import java.util.Calendar;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import javax.sql.RowSet;\n-import javax.sql.rowset.BaseRowSet;\n-import javax.sql.rowset.CachedRowSet;\n-import javax.sql.rowset.RowSetFactory;\n-import javax.sql.rowset.RowSetMetaDataImpl;\n-import javax.sql.rowset.RowSetProvider;\n-import org.testng.Assert;\n-import static org.testng.Assert.assertNull;\n-import static org.testng.Assert.assertTrue;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubBlob;\n-import util.StubClob;\n-import util.StubNClob;\n-import util.StubSQLXML;\n-\n-public abstract class CommonRowSetTests extends BaseTest {\n-\n-    protected final String stubProvider = \"util.StubSyncProvider\";\n-    protected final String query = \"SELECT * FROM SUPERHEROS\";\n-    private final String url = \"jdbc:derby:\/\/localhost:1527\/myDB\";\n-    private final String dsName = \"jdbc\/myDB\";\n-    private final String user = \"Bruce Wayne\";\n-    private final String password = \"The Dark Knight\";\n-    protected final String COFFEE_HOUSES_TABLE = \"COFFEE_HOUSES\";\n-    protected final String COFFEES_TABLE = \"COFFEES\";\n-    protected final int COFFEE_HOUSES_ROWS = 14;\n-    protected final int COFFEES_ROWS = 5;\n-    protected final Object[] COFFEES_PRIMARY_KEYS = {1, 2, 3, 4, 5};\n-    protected final Object[] COFFEE_HOUSES_PRIMARY_KEYS = {\n-        10023, 33002, 10040, 32001, 10042, 10024, 10039, 10041,\n-        33005, 33010, 10035, 10037, 10034, 32004\n-    };\n-\n-    \/*\n-     * COFFEES_HOUSES Table column names\n-     *\/\n-    protected final String[] COFFEE_HOUSES_COLUMN_NAMES = {\n-        \"STORE_ID\", \"CITY\", \"COFFEE\", \"MERCH\", \"TOTAL\"\n-    };\n-\n-    \/*\n-     * COFFEES Table column names\n-     *\/\n-    protected final String[] COFFEES_COLUMN_NAMES = {\n-        \"COF_ID\", \"COF_NAME\", \"SUP_ID\", \"PRICE\", \"SALES\", \"TOTAL\"\n-    };\n-\n-    protected RowSetFactory rsf;\n-\n-    public CommonRowSetTests() {\n-        try {\n-            rsf = RowSetProvider.newFactory();\n-        } catch (SQLException ex) {\n-            Assert.fail(ex.getMessage());\n-        }\n-    }\n-\n-    \/\/ Create an instance of the RowSet we are using\n-    protected abstract <T extends RowSet> T newInstance() throws SQLException;\n-\n-    \/\/DataProvider to use for common tests\n-\n-    \/*\n-     * DataProvider used to specify the value to set and check for the\n-     * methods for fetch direction\n-     *\/\n-    @DataProvider(name = \"rowSetFetchDirection\")\n-    protected Object[][] rowSetFetchDirection() throws Exception {\n-        RowSet rs = newInstance();\n-        return new Object[][]{\n-            {rs, ResultSet.FETCH_FORWARD},\n-            {rs, ResultSet.FETCH_REVERSE},\n-            {rs, ResultSet.FETCH_UNKNOWN}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to specify the value to set and check for the\n-     * methods for Cursor Scroll Type\n-     *\/\n-    @DataProvider(name = \"rowSetScrollTypes\")\n-    protected Object[][] rowSetScrollTypes() throws Exception {\n-        RowSet rs = newInstance();\n-\n-        return new Object[][]{\n-            {rs, ResultSet.TYPE_FORWARD_ONLY},\n-            {rs, ResultSet.TYPE_SCROLL_INSENSITIVE},\n-            {rs, ResultSet.TYPE_SCROLL_SENSITIVE}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to specify the value to set and check for\n-     * methods using transaction isolation types\n-     *\/\n-    @DataProvider(name = \"rowSetIsolationTypes\")\n-    protected Object[][] rowSetIsolationTypes() throws Exception {\n-        RowSet rs = newInstance();\n-\n-        return new Object[][]{\n-            {rs, Connection.TRANSACTION_NONE},\n-            {rs, Connection.TRANSACTION_READ_COMMITTED},\n-            {rs, Connection.TRANSACTION_READ_UNCOMMITTED},\n-            {rs, Connection.TRANSACTION_REPEATABLE_READ},\n-            {rs, Connection.TRANSACTION_SERIALIZABLE}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to specify the value to set and check for the\n-     * methods for Concurrency\n-     *\/\n-    @DataProvider(name = \"rowSetConcurrencyTypes\")\n-    protected Object[][] rowSetConcurrencyTypes() throws Exception {\n-        RowSet rs = newInstance();\n-        return new Object[][]{\n-            {rs, ResultSet.CONCUR_READ_ONLY},\n-            {rs, ResultSet.CONCUR_UPDATABLE}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to specify the value to set and check for\n-     * methods using boolean values\n-     *\/\n-    @DataProvider(name = \"rowSetTrueFalse\")\n-    protected Object[][] rowSetTrueFalse() throws Exception {\n-        RowSet rs = newInstance();\n-        return new Object[][]{\n-            {rs, true},\n-            {rs, false}\n-        };\n-    }\n-    \/*\n-     * DataProvider used to specify the type of RowSet to use.  We also must\n-     * initialize the RowSet\n-     *\/\n-    @DataProvider(name = \"rowSetType\")\n-    protected Object[][] rowSetType() throws Exception {\n-\n-        RowSet rs = newInstance();\n-        return new Object[][]{\n-            {rs}\n-        };\n-    }\n-\n-    \/*\n-     * Initializes a RowSet containing the COFFEE_HOUSES data\n-     *\/\n-    protected <T extends RowSet> T createCoffeeHousesRowSet() throws SQLException {\n-        T rs = (T) newInstance();\n-        initCoffeeHousesMetaData((CachedRowSet) rs);\n-        createCoffeeHouseRows(rs);\n-        \/\/ Make sure you are not on the insertRow\n-        rs.moveToCurrentRow();\n-        return rs;\n-    }\n-\n-    \/*\n-     * Initializes a RowSet containing the COFFEE_HOUSES data\n-     *\/\n-    protected <T extends RowSet> T createCoffeesRowSet() throws SQLException {\n-        T rs = (T) newInstance();\n-        initCoffeesMetaData((CachedRowSet) rs);\n-        createCoffeesRows(rs);\n-        \/\/ Make sure you are not on the insertRow\n-        rs.moveToCurrentRow();\n-        return rs;\n-    }\n-\n-    \/*\n-     * Initializes the COFFEE_HOUSES metadata\n-     *\/\n-    private void initCoffeeHousesMetaData(CachedRowSet crs) throws SQLException {\n-        RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();\n-        crs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n-\n-        \/*\n-         *  CREATE TABLE COFFEE_HOUSES(\n-         *   STORE_ID Integer NOT NULL,\n-         *   CITY VARCHAR(32),\n-         *   COFFEE INTEGER NOT NULL,\n-         *   MERCH INTEGER NOT NULL,\n-         *   TOTAL INTEGER NOT NULL,\n-         *   PRIMARY KEY (STORE_ID))\n-         *\/\n-        rsmd.setColumnCount(COFFEE_HOUSES_COLUMN_NAMES.length);\n-        for(int i = 1; i <= COFFEE_HOUSES_COLUMN_NAMES.length; i++){\n-            rsmd.setColumnName(i, COFFEE_HOUSES_COLUMN_NAMES[i-1]);\n-            rsmd.setColumnLabel(i, rsmd.getColumnName(i));\n-        }\n-\n-        rsmd.setColumnType(1, Types.INTEGER);\n-        rsmd.setColumnType(2, Types.VARCHAR);\n-        rsmd.setColumnType(3, Types.INTEGER);\n-        rsmd.setColumnType(4, Types.INTEGER);\n-        rsmd.setColumnType(5, Types.INTEGER);\n-        crs.setMetaData(rsmd);\n-        crs.setTableName(COFFEE_HOUSES_TABLE);\n-\n-    }\n-\n-    \/*\n-     * Add rows to COFFEE_HOUSES table\n-     *\/\n-    protected void createCoffeeHouseRows(RowSet rs) throws SQLException {\n-\n-        \/\/ insert into COFFEE_HOUSES values(10023, 'Mendocino', 3450, 2005, 5455)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 10023);\n-        rs.updateString(2, \"Mendocino\");\n-        rs.updateInt(3, 3450);\n-        rs.updateInt(4, 2005);\n-        rs.updateInt(5, 5455);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(33002, 'Seattle', 4699, 3109, 7808)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 33002);\n-        rs.updateString(2, \"Seattle\");\n-        rs.updateInt(3, 4699);\n-        rs.updateInt(4, 3109);\n-        rs.updateInt(5, 7808);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(10040, 'SF', 5386, 2841, 8227)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 10040);\n-        rs.updateString(2, \"SF\");\n-        rs.updateInt(3, 5386);\n-        rs.updateInt(4, 2841);\n-        rs.updateInt(5, 8227);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(32001, 'Portland', 3147, 3579, 6726)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 32001);\n-        rs.updateString(2, \"Portland\");\n-        rs.updateInt(3, 3147);\n-        rs.updateInt(4, 3579);\n-        rs.updateInt(5, 6726);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(10042, 'SF', 2863, 1874, 4710)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 10042);\n-        rs.updateString(2, \"SF\");\n-        rs.updateInt(3, 2863);\n-        rs.updateInt(4, 1874);\n-        rs.updateInt(5, 4710);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(10024, 'Sacramento', 1987, 2341, 4328)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 10024);\n-        rs.updateString(2, \"Sacramento\");\n-        rs.updateInt(3, 1987);\n-        rs.updateInt(4, 2341);\n-        rs.updateInt(5, 4328);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(10039, 'Carmel', 2691, 1121, 3812)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 10039);\n-        rs.updateString(2, \"Carmel\");\n-        rs.updateInt(3, 2691);\n-        rs.updateInt(4, 1121);\n-        rs.updateInt(5, 3812);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(10041, 'LA', 1533, 1007, 2540)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 10041);\n-        rs.updateString(2, \"LA\");\n-        rs.updateInt(3, 1533);\n-        rs.updateInt(4, 1007);\n-        rs.updateInt(5, 2540);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(33005, 'Olympia', 2733, 1550, 1550)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 33005);\n-        rs.updateString(2, \"Olympia\");\n-        rs.updateInt(3, 2733);\n-        rs.updateInt(4, 1550);\n-        rs.updateInt(5, 1550);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(33010, 'Seattle', 3210, 2177, 5387)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 33010);\n-        rs.updateString(2, \"Seattle\");\n-        rs.updateInt(3, 3210);\n-        rs.updateInt(4, 2177);\n-        rs.updateInt(5, 5387);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(10035, 'SF', 1922, 1056, 2978)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 10035);\n-        rs.updateString(2, \"SF\");\n-        rs.updateInt(3, 1922);\n-        rs.updateInt(4, 1056);\n-        rs.updateInt(5, 2978);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(10037, 'LA', 2143, 1876, 4019)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 10037);\n-        rs.updateString(2, \"LA\");\n-        rs.updateInt(3, 2143);\n-        rs.updateInt(4, 1876);\n-        rs.updateInt(5, 4019);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(10034, 'San_Jose', 1234, 1032, 2266)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 10034);\n-        rs.updateString(2, \"San Jose\");\n-        rs.updateInt(3, 1234);\n-        rs.updateInt(4, 1032);\n-        rs.updateInt(5, 2266);\n-        rs.insertRow();\n-        \/\/ insert into COFFEE_HOUSES values(32004, 'Eugene', 1356, 1112, 2468)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 32004);\n-        rs.updateString(2, \"Eugene\");\n-        rs.updateInt(3, 1356);\n-        rs.updateInt(4, 1112);\n-        rs.updateInt(5, 2468);\n-        rs.insertRow();\n-        rs.moveToCurrentRow();\n-    }\n-\n-    \/*\n-     * Initializes the COFFEES metadata\n-     *\/\n-    protected void initCoffeesMetaData(CachedRowSet crs) throws SQLException {\n-        RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();\n-        crs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n-\n-        \/*\n-         *  CREATE TABLE COFFEES (\n-         *   COF_ID INTEGER NOT NULL,\n-         *   COF_NAME VARCHAR(32) NOT NULL,\n-         *   SUP_ID INTEGER NOT NULL,\n-         *   PRICE NUMBERIC(10,2 NOT NULL,\n-         *   SALES INTEGER NOT NULL,\n-         *   TOTAL INTEGER NOT NULL,\n-         *   PRIMARY KEY (COF_ID),\n-         *   FOREIGN KEY (SUP_ID) REFERENCES SUPPLIERS (SUP_ID) )\n-         *\/\n-        rsmd.setColumnCount(COFFEES_COLUMN_NAMES.length);\n-        for(int i = 1; i <= COFFEES_COLUMN_NAMES.length; i++){\n-            rsmd.setColumnName(i, COFFEES_COLUMN_NAMES[i-1]);\n-            rsmd.setColumnLabel(i, rsmd.getColumnName(i));\n-        }\n-\n-        rsmd.setColumnType(1, Types.INTEGER);\n-        rsmd.setColumnType(2, Types.VARCHAR);\n-        rsmd.setColumnType(3, Types.INTEGER);\n-        rsmd.setColumnType(4, Types.NUMERIC);\n-        rsmd.setPrecision(4, 10);\n-        rsmd.setScale(4, 2);\n-        rsmd.setColumnType(5, Types.INTEGER);\n-        rsmd.setColumnType(6, Types.INTEGER);\n-        crs.setMetaData(rsmd);\n-        crs.setTableName(COFFEES_TABLE);\n-\n-    }\n-\n-    \/*\n-     * Add rows to COFFEES table\n-     *\/\n-    protected void createCoffeesRows(RowSet rs) throws SQLException {\n-\n-        \/\/ insert into COFFEES values(1, 'Colombian', 101, 7.99, 0, 0)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 1);\n-        rs.updateString(2, \"Colombian\");\n-        rs.updateInt(3, 101);\n-        rs.updateBigDecimal(4, BigDecimal.valueOf(7.99));\n-        rs.updateInt(5, 0);\n-        rs.updateInt(6, 0);\n-        rs.insertRow();\n-        \/\/ insert into COFFEES values(2, 'French_Roast', 49, 8.99, 0, 0)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 2);\n-        rs.updateString(2, \"French_Roast\");\n-        rs.updateInt(3, 49);\n-        rs.updateBigDecimal(4, BigDecimal.valueOf(8.99));\n-        rs.updateInt(5, 0);\n-        rs.updateInt(6, 0);\n-        rs.insertRow();\n-        \/\/ insert into COFFEES values(3, 'Espresso', 150, 9.99, 0, 0)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 3);\n-        rs.updateString(2, \"Espresso\");\n-        rs.updateInt(3, 150);\n-        rs.updateBigDecimal(4, BigDecimal.valueOf(9.99));\n-        rs.updateInt(5, 0);\n-        rs.updateInt(6, 0);\n-        rs.insertRow();\n-        \/\/ insert into COFFEES values(4, 'Colombian_Decaf', 101, 8.99, 0, 0)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 4);\n-        rs.updateString(2, \"Colombian_Decaf\");\n-        rs.updateInt(3, 101);\n-        rs.updateBigDecimal(4, BigDecimal.valueOf(8.99));\n-        rs.updateInt(5, 0);\n-        rs.updateInt(6, 0);\n-        rs.insertRow();\n-        \/\/ insert into COFFEES values(5, 'French_Roast_Decaf', 049, 9.99, 0, 0)\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 5);\n-        rs.updateString(2, \"French_Roast_Decaf\");\n-        rs.updateInt(3, 49);\n-        rs.updateBigDecimal(4, BigDecimal.valueOf(9.99));\n-        rs.updateInt(5, 0);\n-        rs.updateInt(6, 0);\n-        rs.insertRow();\n-\n-    }\n-\n-\n-    \/*\n-     * Utility method to return the Primary Keys for a RowSet.  The Primary\n-     * keys are assumed to be in the first column of the RowSet\n-     *\/\n-    protected Object[] getPrimaryKeys(ResultSet rs) throws SQLException {\n-        List<? super Object> result = new ArrayList<>();\n-        if (rs == null) {\n-            return null;\n-        }\n-        rs.beforeFirst();\n-        while (rs.next()) {\n-            result.add(rs.getInt(1));\n-        }\n-        return result.toArray();\n-    }\n-\n-    \/*\n-     * Utility method to display the RowSet and will return the row count\n-     * it found\n-     *\/\n-    protected int displayResults(ResultSet rs) throws SQLException {\n-        int rows = 0;\n-        ResultSetMetaData rsmd = rs.getMetaData();\n-        int cols = rsmd.getColumnCount();\n-        if (rs != null) {\n-            rs.beforeFirst();\n-            while (rs.next()) {\n-                rows++;\n-\n-                for (int i = 0; i < cols; i++) {\n-                    System.out.print(rs.getString(i + 1) + \" \");\n-                }\n-                System.out.println();\n-            }\n-        }\n-\n-        return rows;\n-    }\n-\n-\n-     \/\/ Insert common tests here\n-\n-    \/*\n-     * Validate that getCommand() returns null by default\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0000(RowSet rs) {\n-        assertNull(rs.getCommand());\n-    }\n-\n-    \/*\n-     * Validate that getCommand() returns command specified to setCommand\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0001(RowSet rs) throws Exception {\n-        rs.setCommand(query);\n-        assertTrue(rs.getCommand().equals(query));\n-    }\n-\n-\n-    \/*\n-     * Validate that getCurrency() returns the correct default value\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0002(RowSet rs) throws Exception {\n-        assertTrue(rs.getConcurrency() == ResultSet.CONCUR_UPDATABLE);\n-    }\n-\n-    \/*\n-     * Validate that getCurrency() returns the correct value\n-     * after a call to setConcurrency())\n-     *\/\n-    @Test(dataProvider = \"rowSetConcurrencyTypes\")\n-    public void commonRowSetTest0003(RowSet rs, int concurType) throws Exception {\n-        rs.setConcurrency(concurType);\n-        assertTrue(rs.getConcurrency() == concurType);\n-    }\n-\n-    \/*\n-     * Validate that getCurrency() throws a SQLException for an invalid value\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonRowSetTest0004(RowSet rs) throws Exception {\n-        rs.setConcurrency(ResultSet.CLOSE_CURSORS_AT_COMMIT);\n-    }\n-\n-    \/*\n-     * Validate that getDataSourceName() returns null by default\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0005(RowSet rs) throws Exception {\n-        assertTrue(rs.getDataSourceName() == null);\n-    }\n-\n-    \/*\n-     * Validate that getDataSourceName() returns the value specified\n-     * by setDataSourceName() and getUrl() returns null\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0006(RowSet rs) throws Exception {\n-        rs.setUrl(url);\n-        rs.setDataSourceName(dsName);\n-        assertTrue(rs.getDataSourceName().equals(dsName));\n-        assertNull(rs.getUrl());\n-    }\n-\n-    \/*\n-     * Validate that setDataSourceName() throws a SQLException for an empty\n-     * String specified for the data source name\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonRowSetTest0007(RowSet rs) throws Exception {\n-        String dsname = \"\";\n-        rs.setDataSourceName(dsname);\n-    }\n-\n-    \/*\n-     * Validate that getEscapeProcessing() returns false by default\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0008(RowSet rs) throws Exception {\n-        assertTrue(rs.getEscapeProcessing());\n-    }\n-\n-    \/*\n-     * Validate that getEscapeProcessing() returns value set by\n-     * setEscapeProcessing()\n-     *\/\n-    @Test(dataProvider = \"rowSetTrueFalse\")\n-    public void commonRowSetTest0009(RowSet rs, boolean val) throws Exception {\n-        rs.setEscapeProcessing(val);\n-        assertTrue(rs.getEscapeProcessing() == val);\n-    }\n-\n-    \/*\n-     * Validate that getFetchDirection() returns the correct default value\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0010(RowSet rs) throws Exception {\n-        assertTrue(rs.getFetchDirection() == ResultSet.FETCH_FORWARD);\n-    }\n-\n-    \/*\n-     * Validate that getFetchDirection() returns the value set by\n-     * setFetchDirection()\n-     *\/\n-    @Test(dataProvider = \"rowSetFetchDirection\")\n-    public void commonRowSetTest0011(RowSet rs, int direction) throws Exception {\n-        rs.setFetchDirection(direction);\n-        assertTrue(rs.getFetchDirection() == direction);\n-    }\n-\n-    \/*\n-     * Validate that setFetchSize() throws a SQLException for an invalid value\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonRowSetTest0013(RowSet rs) throws Exception {\n-        rs.setFetchSize(-1);\n-    }\n-\n-    \/*\n-     * Validate that setFetchSize() throws a SQLException for a\n-     * value greater than getMaxRows()\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonRowSetTest0014(RowSet rs) throws Exception {\n-        rs.setMaxRows(5);\n-        rs.setFetchSize(rs.getMaxRows() + 1);\n-    }\n-\n-    \/*\n-     * Validate that getFetchSize() returns the correct value after\n-     * setFetchSize() has been called\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0015(RowSet rs) throws Exception {\n-        int maxRows = 150;\n-        rs.setFetchSize(0);\n-        assertTrue(rs.getFetchSize() == 0);\n-        rs.setFetchSize(100);\n-        assertTrue(rs.getFetchSize() == 100);\n-        rs.setMaxRows(maxRows);\n-        rs.setFetchSize(maxRows);\n-        assertTrue(rs.getFetchSize() == maxRows);\n-    }\n-\n-    \/*\n-     * Validate that setMaxFieldSize() throws a SQLException for an invalid value\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonRowSetTest0016(RowSet rs) throws Exception {\n-        rs.setMaxFieldSize(-1);\n-    }\n-\n-    \/*\n-     * Validate that getMaxFieldSize() returns the value set by\n-     * setMaxFieldSize()\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0017(RowSet rs) throws Exception {\n-        rs.setMaxFieldSize(0);\n-        assertTrue(rs.getMaxFieldSize() == 0);\n-        rs.setMaxFieldSize(100);\n-        assertTrue(rs.getMaxFieldSize() == 100);\n-        rs.setMaxFieldSize(50);\n-        assertTrue(rs.getMaxFieldSize() == 50);\n-    }\n-\n-    \/*\n-     * Validate that isReadOnly() returns value set by\n-     * setReadOnly()\n-     *\/\n-    @Test(dataProvider = \"rowSetTrueFalse\")\n-    public void commonRowSetTest0018(RowSet rs, boolean val) throws Exception {\n-        rs.setReadOnly(val);\n-        assertTrue(rs.isReadOnly() == val);\n-    }\n-\n-    \/*\n-     * Validate that getTransactionIsolation() returns value set by\n-     * setTransactionIsolation()\n-     *\/\n-    @Test(dataProvider = \"rowSetIsolationTypes\")\n-    public void commonRowSetTest0019(RowSet rs, int val) throws Exception {\n-        rs.setTransactionIsolation(val);\n-        assertTrue(rs.getTransactionIsolation() == val);\n-    }\n-\n-    \/*\n-     * Validate that getType() returns value set by setType()\n-     *\/\n-    @Test(dataProvider = \"rowSetScrollTypes\")\n-    public void commonRowSetTest0020(RowSet rs, int val) throws Exception {\n-        rs.setType(val);\n-        assertTrue(rs.getType() == val);\n-    }\n-\n-    \/*\n-     * Validate that getEscapeProcessing() returns value set by\n-     * setEscapeProcessing()\n-     *\/\n-    @Test(dataProvider = \"rowSetTrueFalse\")\n-    public void commonRowSetTest0021(BaseRowSet rs, boolean val) throws Exception {\n-        rs.setShowDeleted(val);\n-        assertTrue(rs.getShowDeleted() == val);\n-    }\n-\n-    \/*\n-     * Validate that getTypeMap() returns same value set by\n-     * setTypeMap()\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0022(RowSet rs) throws Exception {\n-        Map<String, Class<?>> map = new HashMap<>();\n-        map.put(\"SUPERHERO\", Class.forName(\"util.SuperHero\"));\n-        rs.setTypeMap(map);\n-        assertTrue(rs.getTypeMap().equals(map));\n-    }\n-\n-    \/*\n-     * Validate that getUsername() returns same value set by\n-     * setUsername()\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0023(RowSet rs) throws Exception {\n-        rs.setUsername(user);\n-        assertTrue(rs.getUsername().equals(user));\n-    }\n-\n-    \/*\n-     * Validate that getPassword() returns same password set by\n-     * setPassword()\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0024(RowSet rs) throws Exception {\n-        rs.setPassword(password);\n-        assertTrue(rs.getPassword().equals(password));\n-    }\n-\n-    \/*\n-     * Validate that getQueryTimeout() returns same value set by\n-     * setQueryTimeout() and that 0 is a valid timeout value\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0025(RowSet rs) throws Exception {\n-        int timeout = 0;\n-        rs.setQueryTimeout(timeout);\n-        assertTrue(rs.getQueryTimeout() == timeout);\n-    }\n-\n-    \/*\n-     * Validate that getQueryTimeout() returns same value set by\n-     * setQueryTimeout() and that 0 is a valid timeout value\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0026(RowSet rs) throws Exception {\n-        int timeout = 10000;\n-        rs.setQueryTimeout(timeout);\n-        assertTrue(rs.getQueryTimeout() == timeout);\n-    }\n-\n-    \/*\n-     * Validate that setQueryTimeout() throws a SQLException for a timeout\n-     * value < 0\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonRowSetTest0027(RowSet rs) throws Exception {\n-        rs.setQueryTimeout(-1);\n-    }\n-\n-\n-    \/*\n-     * Validate addRowSetListener does not throw an Exception when null is\n-     * passed as the parameter\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0028(RowSet rs) throws Exception {\n-        rs.addRowSetListener(null);\n-    }\n-\n-    \/*\n-     * Validate removeRowSetListener does not throw an Exception when null is\n-     * passed as the parameter\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0029(RowSet rs) throws Exception {\n-        rs.removeRowSetListener(null);\n-    }\n-\n-    \/*\n-     * Set two parameters and then validate clearParameters() will clear them\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0030(BaseRowSet rs) throws Exception {\n-        rs.setInt(1, 1);\n-        rs.setString(2, query);\n-        assertTrue(rs.getParams().length == 2);\n-        rs.clearParameters();\n-        assertTrue(rs.getParams().length == 0);\n-    }\n-\n-    \/*\n-     * Validate that getURL() returns same value set by\n-     * setURL()\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonRowSetTest0031(RowSet rs) throws Exception {\n-        rs.setUrl(url);\n-        assertTrue(rs.getUrl().equals(url));\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0100(RowSet rs) throws Exception {\n-        InputStream is = null;\n-        rs.setAsciiStream(1, is);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0101(RowSet rs) throws Exception {\n-        InputStream is = null;\n-        rs.setAsciiStream(\"one\", is);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0102(RowSet rs) throws Exception {\n-        InputStream is = null;\n-        rs.setAsciiStream(\"one\", is, query.length());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0103(RowSet rs) throws Exception {\n-        InputStream is = null;\n-        rs.setBinaryStream(1, is);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0104(RowSet rs) throws Exception {\n-        InputStream is = null;\n-        rs.setBinaryStream(\"one\", is);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0105(RowSet rs) throws Exception {\n-        InputStream is = null;\n-        rs.setBinaryStream(\"one\", is, query.length());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0106(RowSet rs) throws Exception {\n-        rs.setBigDecimal(\"one\", BigDecimal.ONE);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0107(RowSet rs) throws Exception {\n-        InputStream is = null;\n-        rs.setBlob(1, is);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0108(RowSet rs) throws Exception {\n-        InputStream is = null;\n-        rs.setBlob(\"one\", is);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0109(RowSet rs) throws Exception {\n-        InputStream is = null;\n-        rs.setBlob(\"one\", is, query.length());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0110(RowSet rs) throws Exception {\n-        rs.setBlob(\"one\", new StubBlob());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0111(RowSet rs) throws Exception {\n-        rs.setBoolean(\"one\", true);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0112(RowSet rs) throws Exception {\n-        byte b = 1;\n-        rs.setByte(\"one\", b);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0113(RowSet rs) throws Exception {\n-        byte b = 1;\n-        rs.setBytes(\"one\", new byte[10]);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0114(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setCharacterStream(\"one\", rdr, query.length());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0115(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setCharacterStream(\"one\", rdr);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0116(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setCharacterStream(1, rdr);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0117(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setClob(1, rdr);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0118(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setClob(\"one\", rdr);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0119(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setClob(\"one\", rdr, query.length());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0120(RowSet rs) throws Exception {\n-        rs.setClob(\"one\", new StubClob());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0121(RowSet rs) throws Exception {\n-        rs.setDate(\"one\", Date.valueOf(LocalDate.now()));\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0122(RowSet rs) throws Exception {\n-        rs.setDate(\"one\", Date.valueOf(LocalDate.now()),\n-                Calendar.getInstance());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0123(RowSet rs) throws Exception {\n-        rs.setTime(\"one\", Time.valueOf(LocalTime.now()));\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0124(RowSet rs) throws Exception {\n-        rs.setTime(\"one\", Time.valueOf(LocalTime.now()),\n-                Calendar.getInstance());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0125(RowSet rs) throws Exception {\n-        rs.setTimestamp(\"one\", Timestamp.valueOf(LocalDateTime.now()));\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0126(RowSet rs) throws Exception {\n-        rs.setTimestamp(\"one\", Timestamp.valueOf(LocalDateTime.now()),\n-                Calendar.getInstance());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0127(RowSet rs) throws Exception {\n-        rs.setDouble(\"one\", 2.0d);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0128(RowSet rs) throws Exception {\n-        rs.setFloat(\"one\", 2.0f);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0129(RowSet rs) throws Exception {\n-        rs.setInt(\"one\", 21);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0130(RowSet rs) throws Exception {\n-        rs.setLong(\"one\", 21l);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0131(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setNCharacterStream(\"one\", rdr, query.length());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0132(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setNCharacterStream(\"one\", rdr);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0133(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setNCharacterStream(1, rdr);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0134(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setNCharacterStream(1, rdr, query.length());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0135(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setClob(\"one\", rdr);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0136(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setClob(\"one\", rdr, query.length());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0137(RowSet rs) throws Exception {\n-        rs.setNClob(\"one\", new StubNClob());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0138(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setNClob(1, rdr);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0139(RowSet rs) throws Exception {\n-        Reader rdr = null;\n-        rs.setNClob(1, rdr, query.length());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0140(RowSet rs) throws Exception {\n-        rs.setNClob(1, new StubNClob());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0141(RowSet rs) throws Exception {\n-        rs.setNString(1, query);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0142(RowSet rs) throws Exception {\n-        rs.setNull(\"one\", Types.INTEGER);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0143(RowSet rs) throws Exception {\n-        rs.setNull(\"one\", Types.INTEGER, \"my.type\");\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0144(RowSet rs) throws Exception {\n-        rs.setObject(\"one\", query, Types.VARCHAR);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0145(RowSet rs) throws Exception {\n-        rs.setObject(\"one\", query, Types.VARCHAR, 0);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0146(RowSet rs) throws Exception {\n-        rs.setObject(\"one\", query);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0147(RowSet rs) throws Exception {\n-        RowId aRowid = null;\n-        rs.setRowId(\"one\", aRowid);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0148(RowSet rs) throws Exception {\n-        rs.setSQLXML(\"one\", new StubSQLXML());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0149(RowSet rs) throws Exception {\n-        rs.setSQLXML(1, new StubSQLXML());\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0150(RowSet rs) throws Exception {\n-        rs.setNString(1, query);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0151(RowSet rs) throws Exception {\n-        rs.setNString(\"one\", query);\n-    }\n-\n-    \/*\n-     * This method is currently not implemented in BaseRowSet and will\n-     * throw a SQLFeatureNotSupportedException\n-     *\/\n-    @Test(dataProvider = \"rowSetType\",\n-            expectedExceptions = SQLFeatureNotSupportedException.class)\n-    public void commonRowSetTest0152(RowSet rs) throws Exception {\n-        short val = 21;\n-        rs.setShort(\"one\", val);\n-    }\n-\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/CommonRowSetTests.java","additions":0,"deletions":1372,"binary":false,"changes":1372,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset;\n-\n-import java.sql.SQLException;\n-import javax.sql.rowset.RowSetFactory;\n-import javax.sql.rowset.RowSetProvider;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-\n-public class RowSetFactoryTests extends BaseTest {\n-\n-    \/\/ RowSet implementations that we are testing for\n-    private final String DEFAULT_CACHEDROWSET_CLASSNAME = \"com.sun.rowset.CachedRowSetImpl\";\n-    private final String DEFAULT_FILTEREDROWSET_CLASSNAME = \"com.sun.rowset.FileteredRowSetImpl\";\n-    private final String DEFAULT_JDBCROWSET_CLASSNAME = \"com.sun.rowset.JdbcRowSetImpl\";\n-    private final String DEFAULT_JOINROWSET_CLASSNAME = \"com.sun.rowset.JoinRowSetImpl\";\n-    private final String DEFAULT_WEBROWSET_CLASSNAME = \"com.sun.rowset.WebRowSetImpl\";\n-    private final String STUB_FACTORY_CLASSNAME = \"util.StubRowSetFactory\";\n-    private final String STUB_CACHEDROWSET_CLASSNAME = \"util.StubCachedRowSetImpl\";\n-    private final String STUB_FILTEREDROWSET_CLASSNAME = \"util.StubFilteredRowSetImpl\";\n-    private final String STUB_JDBCROWSET_CLASSNAME = \"util.StubJdbcRowSetImpl\";\n-    private final String STUB_JOINROWSET_CLASSNAME = \"util.StubJoinRowSetImpl\";\n-    private final String STUB_WEBROWSET_CLASSNAME = \"util.StubWebRowSetImpl\";\n-\n-\n-    \/*\n-     * Validate that the RowSetFactory returned by RowSetProvider.newFactory()\n-     * returns the correct RowSet implementations\n-     *\/\n-    @Test(dataProvider = \"RowSetValues\", enabled = true)\n-    public void test(RowSetFactory rsf, String impl) throws SQLException {\n-        validateRowSetImpl(rsf, impl);\n-    }\n-\n-    \/*\n-     * Utility Method to validate the RowsetFactory returns the correct\n-     * RowSet implementation\n-     *\/\n-    private void validateRowSetImpl(RowSetFactory rsf, String implName)\n-            throws SQLException {\n-        assertNotNull(rsf, \"RowSetFactory should not be null\");\n-        switch (implName) {\n-            case DEFAULT_CACHEDROWSET_CLASSNAME:\n-                assertTrue(rsf.createCachedRowSet() instanceof com.sun.rowset.CachedRowSetImpl);\n-                break;\n-            case DEFAULT_FILTEREDROWSET_CLASSNAME:\n-                assertTrue(rsf.createFilteredRowSet() instanceof com.sun.rowset.FilteredRowSetImpl);\n-                break;\n-            case DEFAULT_JDBCROWSET_CLASSNAME:\n-                assertTrue(rsf.createJdbcRowSet() instanceof com.sun.rowset.JdbcRowSetImpl);\n-                break;\n-            case DEFAULT_JOINROWSET_CLASSNAME:\n-                assertTrue(rsf.createJoinRowSet() instanceof com.sun.rowset.JoinRowSetImpl);\n-                break;\n-            case DEFAULT_WEBROWSET_CLASSNAME:\n-                assertTrue(rsf.createWebRowSet() instanceof com.sun.rowset.WebRowSetImpl);\n-                break;\n-            case STUB_CACHEDROWSET_CLASSNAME:\n-                assertTrue(rsf.createCachedRowSet() instanceof util.StubCachedRowSetImpl);\n-                break;\n-            case STUB_FILTEREDROWSET_CLASSNAME:\n-                assertTrue(rsf.createFilteredRowSet() instanceof util.StubFilteredRowSetImpl);\n-                break;\n-            case STUB_JDBCROWSET_CLASSNAME:\n-                assertTrue(rsf.createJdbcRowSet() instanceof util.StubJdbcRowSetImpl);\n-                break;\n-            case STUB_WEBROWSET_CLASSNAME:\n-                assertTrue(rsf.createWebRowSet() instanceof util.StubWebRowSetImpl);\n-                break;\n-        }\n-\n-    }\n-\n-    \/*\n-     * DataProvider used to provide the RowSetFactory and the RowSet\n-     * implementation that should be returned\n-     *\/\n-    @DataProvider(name = \"RowSetValues\")\n-    private Object[][] RowSetValues() throws SQLException {\n-        RowSetFactory rsf = RowSetProvider.newFactory();\n-        RowSetFactory rsf1 = RowSetProvider.newFactory(STUB_FACTORY_CLASSNAME, null);\n-        return new Object[][]{\n-            {rsf, DEFAULT_CACHEDROWSET_CLASSNAME},\n-            {rsf, DEFAULT_FILTEREDROWSET_CLASSNAME},\n-            {rsf, DEFAULT_JDBCROWSET_CLASSNAME},\n-            {rsf, DEFAULT_JOINROWSET_CLASSNAME},\n-            {rsf, DEFAULT_WEBROWSET_CLASSNAME},\n-            {rsf1, STUB_CACHEDROWSET_CLASSNAME},\n-            {rsf1, STUB_FILTEREDROWSET_CLASSNAME},\n-            {rsf1, STUB_JDBCROWSET_CLASSNAME},\n-            {rsf1, STUB_JOINROWSET_CLASSNAME},\n-            {rsf1, STUB_WEBROWSET_CLASSNAME}\n-\n-        };\n-    }\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/RowSetFactoryTests.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,555 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset;\n-\n-import java.sql.ResultSetMetaData;\n-import java.sql.SQLException;\n-import java.sql.Types;\n-import javax.sql.RowSetMetaData;\n-import javax.sql.rowset.RowSetMetaDataImpl;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-\n-public class RowSetMetaDataTests extends BaseTest {\n-\n-    \/\/ Max columns used in the tests\n-    private final int MAX_COLUMNS = 5;\n-    \/\/ Instance to be used within the tests\n-    private RowSetMetaDataImpl rsmd;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        rsmd = new RowSetMetaDataImpl();\n-        rsmd.setColumnCount(MAX_COLUMNS);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test(Integer col) throws Exception {\n-        rsmd.getCatalogName(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test01(Integer col) throws Exception {\n-        rsmd.getColumnClassName(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test02(Integer col) throws Exception {\n-        rsmd.getColumnDisplaySize(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test03(Integer col) throws Exception {\n-        rsmd.getColumnLabel(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test04(Integer col) throws Exception {\n-        rsmd.getColumnName(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test05(Integer col) throws Exception {\n-        rsmd.getColumnType(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test06(Integer col) throws Exception {\n-        rsmd.getColumnTypeName(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test07(Integer col) throws Exception {\n-        rsmd.getPrecision(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test08(Integer col) throws Exception {\n-        rsmd.getScale(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test09(Integer col) throws Exception {\n-        rsmd.getSchemaName(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test10(Integer col) throws Exception {\n-        rsmd.getTableName(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test11(Integer col) throws Exception {\n-        rsmd.isAutoIncrement(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test12(Integer col) throws Exception {\n-        rsmd.isCaseSensitive(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test13(Integer col) throws Exception {\n-        rsmd.isCurrency(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test14(Integer col) throws Exception {\n-        rsmd.isDefinitelyWritable(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test15(Integer col) throws Exception {\n-        rsmd.isNullable(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test16(Integer col) throws Exception {\n-        rsmd.isReadOnly(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test17(Integer col) throws Exception {\n-        rsmd.isSearchable(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test18(Integer col) throws Exception {\n-        rsmd.isSigned(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test19(Integer col) throws Exception {\n-        rsmd.isWritable(col);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test20(Integer col) throws Exception {\n-        rsmd.setAutoIncrement(col, true);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test21(Integer col) throws Exception {\n-        rsmd.setCaseSensitive(col, true);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test22(Integer col) throws Exception {\n-        rsmd.setCatalogName(col, null);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test23(Integer col) throws Exception {\n-        rsmd.setColumnDisplaySize(col, 5);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test24(Integer col) throws Exception {\n-        rsmd.setColumnLabel(col, \"label\");\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test25(Integer col) throws Exception {\n-        rsmd.setColumnName(col, \"F1\");\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test26(Integer col) throws Exception {\n-        rsmd.setColumnType(col, Types.CHAR);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test27(Integer col) throws Exception {\n-        rsmd.setColumnTypeName(col, \"F1\");\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test28(Integer col) throws Exception {\n-        rsmd.setCurrency(col, true);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test29(Integer col) throws Exception {\n-        rsmd.setNullable(col, ResultSetMetaData.columnNoNulls);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test30(Integer col) throws Exception {\n-        rsmd.setPrecision(col, 2);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test31(Integer col) throws Exception {\n-        rsmd.setScale(col, 2);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test32(Integer col) throws Exception {\n-        rsmd.setSchemaName(col, \"Gotham\");\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test33(Integer col) throws Exception {\n-        rsmd.setSearchable(col, false);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test34(Integer col) throws Exception {\n-        rsmd.setSigned(col, false);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown for an invalid column index\n-     *\/\n-    @Test(dataProvider = \"invalidColumnRanges\",\n-            expectedExceptions = SQLException.class)\n-    public void test35(Integer col) throws Exception {\n-        rsmd.setTableName(col, \"SUPERHEROS\");\n-    }\n-\n-    \/*\n-     * Validate that the correct class name is returned for the column\n-     * Note:  Once setColumnClassName is added to RowSetMetaData, this\n-     * method will need to change.\n-     *\/\n-    @Test(dataProvider = \"columnClassNames\")\n-    public void test36(Integer type, String name) throws Exception {\n-        rsmd.setColumnType(1, type);\n-        assertTrue(rsmd.getColumnClassName(1).equals(name));\n-    }\n-\n-    \/*\n-     * Validate that all of the methods are accessible and the correct value\n-     * is returned for each column\n-     *\/\n-    @Test(dataProvider = \"columnRanges\")\n-    public void test37(Integer col) throws Exception {\n-        rsmd.setAutoIncrement(col, true);\n-        assertTrue(rsmd.isAutoIncrement(col));\n-        rsmd.setCaseSensitive(col, true);\n-        assertTrue(rsmd.isCaseSensitive(col));\n-        rsmd.setCatalogName(col, \"Gotham\");\n-        assertTrue(rsmd.getCatalogName(col).equals(\"Gotham\"));\n-        rsmd.setColumnDisplaySize(col, 20);\n-        assertTrue(rsmd.getColumnDisplaySize(col) == 20);\n-        rsmd.setColumnLabel(col, \"F1\");\n-        assertTrue(rsmd.getColumnLabel(col).equals(\"F1\"));\n-        rsmd.setColumnName(col, \"F1\");\n-        assertTrue(rsmd.getColumnName(col).equals(\"F1\"));\n-        rsmd.setColumnType(col, Types.INTEGER);\n-        assertTrue(rsmd.getColumnType(col) == Types.INTEGER);\n-        assertTrue(rsmd.getColumnClassName(col).equals(Integer.class.getName()));\n-        rsmd.setColumnTypeName(col, \"INTEGER\");\n-        assertTrue(rsmd.getColumnTypeName(col).equals(\"INTEGER\"));\n-        rsmd.setCurrency(col, true);\n-        assertTrue(rsmd.isCurrency(col));\n-        rsmd.setNullable(col, ResultSetMetaData.columnNoNulls);\n-        assertTrue(rsmd.isNullable(col) == ResultSetMetaData.columnNoNulls);\n-        rsmd.setPrecision(col, 2);\n-        assertTrue(rsmd.getPrecision(col) == 2);\n-        rsmd.setScale(col, 2);\n-        assertTrue(rsmd.getScale(col) == 2);\n-        rsmd.setSchemaName(col, \"GOTHAM\");\n-        assertTrue(rsmd.getSchemaName(col).equals(\"GOTHAM\"));\n-        rsmd.setSearchable(col, false);\n-        assertFalse(rsmd.isSearchable(col));\n-        rsmd.setSigned(col, false);\n-        assertFalse(rsmd.isSigned(col));\n-        rsmd.setTableName(col, \"SUPERHEROS\");\n-        assertTrue(rsmd.getTableName(col).equals(\"SUPERHEROS\"));\n-        rsmd.isReadOnly(col);\n-        rsmd.isDefinitelyWritable(col);\n-        rsmd.isWritable(col);\n-\n-    }\n-\n-    \/*\n-     * Validate that the proper values are accepted by setNullable\n-     *\/\n-    @Test(dataProvider = \"validSetNullableValues\")\n-    public void test38(Integer val) throws Exception {\n-        rsmd.setNullable(1, val);\n-    }\n-\n-    \/*\n-     * Validate that the correct type is returned for the column\n-     *\/\n-    @Test(dataProvider = \"jdbcTypes\")\n-    public void test39(Integer type) throws Exception {\n-        rsmd.setColumnType(1, type);\n-        assertTrue(type == rsmd.getColumnType(1));\n-    }\n-\n-    \/*\n-     * Validate that the correct value is returned from the isXXX methods\n-     *\/\n-    @Test(dataProvider = \"trueFalse\")\n-    public void test40(Boolean b) throws Exception {\n-        rsmd.setAutoIncrement(1, b);\n-        rsmd.setCaseSensitive(1, b);\n-        rsmd.setCurrency(1, b);\n-        rsmd.setSearchable(1, b);\n-        rsmd.setSigned(1, b);\n-        assertTrue(rsmd.isAutoIncrement(1) == b);\n-        assertTrue(rsmd.isCaseSensitive(1) == b);\n-        assertTrue(rsmd.isCurrency(1) == b);\n-        assertTrue(rsmd.isSearchable(1) == b);\n-        assertTrue(rsmd.isSigned(1) == b);\n-    }\n-\n-    \/*\n-     * Validate isWrapperFor and unwrap work correctly\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    @Test\n-    public void test99() throws Exception {\n-        RowSetMetaData rsmd1 = rsmd;\n-        ResultSetMetaData rsmd2 = rsmd;\n-        Class clzz = rsmd.getClass();\n-        assertTrue(rsmd1.isWrapperFor(clzz));\n-        assertTrue(rsmd2.isWrapperFor(clzz));\n-        RowSetMetaDataImpl rsmdi = (RowSetMetaDataImpl) rsmd2.unwrap(clzz);\n-\n-        \/\/ False should be returned\n-        assertFalse(rsmd1.isWrapperFor(this.getClass()));\n-        assertFalse(rsmd2.isWrapperFor(this.getClass()));\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Date which are not valid and are used\n-     * to validate that an IllegalArgumentException will be thrown from the\n-     * valueOf method\n-     *\/\n-    @DataProvider(name = \"validSetNullableValues\")\n-    private Object[][] validSetNullableValues() {\n-        return new Object[][]{\n-            {ResultSetMetaData.columnNoNulls},\n-            {ResultSetMetaData.columnNullable},\n-            {ResultSetMetaData.columnNullableUnknown}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide column indexes that are out of range so that\n-     * SQLException is thrown\n-     *\/\n-    @DataProvider(name = \"invalidColumnRanges\")\n-    private Object[][] invalidColumnRanges() {\n-        return new Object[][]{\n-            {-1},\n-            {0},\n-            {MAX_COLUMNS + 1}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide the valid column ranges for the\n-     * RowSetMetaDataImpl object\n-     *\/\n-    @DataProvider(name = \"columnRanges\")\n-    private Object[][] columnRanges() {\n-        Object[][] o = new Object[MAX_COLUMNS][1];\n-        for (int i = 1; i <= MAX_COLUMNS; i++) {\n-            o[i - 1][0] = i;\n-        }\n-        return o;\n-    }\n-\n-    \/*\n-     * DataProvider used to specify the value to set via setColumnType and\n-     * the expected value to be returned from getColumnClassName\n-     *\/\n-    @DataProvider(name = \"columnClassNames\")\n-    private Object[][] columnClassNames() {\n-        return new Object[][]{\n-            {Types.CHAR, \"java.lang.String\"},\n-            {Types.NCHAR, \"java.lang.String\"},\n-            {Types.VARCHAR, \"java.lang.String\"},\n-            {Types.NVARCHAR, \"java.lang.String\"},\n-            {Types.LONGVARCHAR, \"java.lang.String\"},\n-            {Types.LONGNVARCHAR, \"java.lang.String\"},\n-            {Types.NUMERIC, \"java.math.BigDecimal\"},\n-            {Types.DECIMAL, \"java.math.BigDecimal\"},\n-            {Types.BIT, \"java.lang.Boolean\"},\n-            {Types.TINYINT, \"java.lang.Byte\"},\n-            {Types.SMALLINT, \"java.lang.Short\"},\n-            {Types.INTEGER, \"java.lang.Integer\"},\n-            {Types.FLOAT, \"java.lang.Double\"},\n-            {Types.DOUBLE, \"java.lang.Double\"},\n-            {Types.BINARY, \"byte[]\"},\n-            {Types.VARBINARY, \"byte[]\"},\n-            {Types.LONGVARBINARY, \"byte[]\"},\n-            {Types.DATE, \"java.sql.Date\"},\n-            {Types.TIME, \"java.sql.Time\"},\n-            {Types.TIMESTAMP, \"java.sql.Timestamp\"},\n-            {Types.CLOB, \"java.sql.Clob\"},\n-            {Types.BLOB, \"java.sql.Blob\"}\n-\n-        };\n-\n-    }\n-\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/RowSetMetaDataTests.java","additions":0,"deletions":555,"binary":false,"changes":555,"status":"deleted"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset;\n-\n-import com.sun.rowset.RowSetFactoryImpl;\n-import java.io.File;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.sql.SQLException;\n-import javax.sql.rowset.RowSetFactory;\n-import javax.sql.rowset.RowSetProvider;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubRowSetFactory;\n-\n-public class RowSetProviderTests extends BaseTest {\n-\n-    \/\/ Default RowSetFactory Implementation\n-    private final String DEFFAULT_FACTORY_CLASSNAME = \"com.sun.rowset.RowSetFactoryImpl\";\n-    \/\/ Stub RowSetFactory Implementation\n-    private final String STUB_FACTORY_CLASSNAME = \"util.StubRowSetFactory\";\n-    \/\/ Indicator that the factory implementation does not need to be checked\n-    private final String NO_VALADATE_IMPL = \"\";\n-    \/\/ Original System property value for javax.sql.rowset.RowSetFactory\n-    private static String origFactoryProperty;\n-    \/\/ Original ClassLoader\n-    private static ClassLoader cl;\n-    \/\/ Path to the location of the jar files used by the ServiceLoader API\n-    private static String jarPath;\n-\n-    \/*\n-     * Save off the original property value for javax.sql.rowset.RowSetFactory,\n-     * original classloader and define the path to the jars directory\n-     *\/\n-    @BeforeClass\n-    public static void setUpClass() throws Exception {\n-        origFactoryProperty = System.getProperty(\"javax.sql.rowset.RowSetFactory\");\n-        cl = Thread.currentThread().getContextClassLoader();\n-        jarPath = System.getProperty(\"test.src\", \".\") + File.separatorChar\n-                + \"jars\" +  File.separatorChar;\n-    }\n-\n-    \/*\n-     * Install the original javax.sql.rowset.RowSetFactory property value\n-     *\/\n-    @AfterClass\n-    public static void tearDownClass() throws Exception {\n-        if (origFactoryProperty != null) {\n-            System.setProperty(\"javax.sql.rowset.RowSetFactory\",\n-                    origFactoryProperty);\n-        }\n-    }\n-\n-    \/*\n-     * Clear the javax.sql.rowset.RowSetFactory property value and\n-     * reset the classloader to its original value\n-     *\/\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-        System.clearProperty(\"javax.sql.rowset.RowSetFactory\");\n-        Thread.currentThread().setContextClassLoader(cl);\n-    }\n-\n-    \/*\n-     * Validate that the correct RowSetFactory is returned by newFactory().\n-     *\/\n-    @Test(dataProvider = \"RowSetFactoryValues\")\n-    public void test(RowSetFactory rsf, String impl) throws SQLException {\n-        validateProvider(rsf, impl);\n-    }\n-\n-    \/*\n-     * Validate that the default RowSetFactory is returned by newFactory()\n-     * when specified by the javax.sql.rowset.RowSetFactory property.\n-     *\/\n-    @Test\n-    public void test01() throws SQLException {\n-        System.setProperty(\"javax.sql.rowset.RowSetFactory\",\n-                DEFFAULT_FACTORY_CLASSNAME);\n-        validateProvider(RowSetProvider.newFactory(), DEFFAULT_FACTORY_CLASSNAME);\n-    }\n-\n-    \/*\n-     * Validate that the correct RowSetFactory is returned by newFactory()\n-     * when specified by the javax.sql.rowset.RowSetFactory property.\n-     *\/\n-    @Test(enabled = true)\n-    public void test02() throws SQLException {\n-        System.setProperty(\"javax.sql.rowset.RowSetFactory\", STUB_FACTORY_CLASSNAME);\n-        validateProvider(RowSetProvider.newFactory(), STUB_FACTORY_CLASSNAME);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException is thrown by newFactory()\n-     * when specified  RowSetFactory specified by the\n-     * javax.sql.rowset.RowSetFactory property is not valid.\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test03() throws SQLException {\n-        System.setProperty(\"javax.sql.rowset.RowSetFactory\",\n-                \"invalid.RowSetFactoryImpl\");\n-        RowSetFactory rsf = RowSetProvider.newFactory();\n-    }\n-\n-    \/*\n-     * Validate that the correct RowSetFactory is returned by newFactory()\n-     * when specified by the ServiceLoader API.\n-     *\/\n-    @Test\n-    public void test04() throws Exception {\n-        File f = new File(jarPath + \"goodFactory\");\n-        URLClassLoader loader = new URLClassLoader(new URL[]{\n-            new URL(f.toURI().toString())}, getClass().getClassLoader());\n-        Thread.currentThread().setContextClassLoader(loader);\n-        validateProvider(RowSetProvider.newFactory(), STUB_FACTORY_CLASSNAME);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException is thrown by newFactory() if the default\n-     * RowSetFactory specified by the ServiceLoader API is not valid\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test05() throws Exception {\n-        File f = new File(jarPath + \"badFactory\");\n-        URLClassLoader loader = new URLClassLoader(new URL[]{\n-            new URL(f.toURI().toString())}, getClass().getClassLoader());\n-        Thread.currentThread().setContextClassLoader(loader);\n-        RowSetProvider.newFactory();\n-    }\n-\n-    \/*\n-     * Utility Method to validate that the RowsetFactory returned from\n-     * RowSetProvider.newFactory() is correct\n-     *\/\n-    private void validateProvider(RowSetFactory rsf, String implName) {\n-        assertNotNull(rsf, \"RowSetFactory should not be null\");\n-        switch (implName) {\n-            case DEFFAULT_FACTORY_CLASSNAME:\n-                assertTrue(rsf instanceof RowSetFactoryImpl);\n-                break;\n-            case STUB_FACTORY_CLASSNAME:\n-                assertTrue(rsf instanceof StubRowSetFactory);\n-                break;\n-            default:\n-        }\n-    }\n-\n-    \/*\n-     * DataProvider used to provide a RowSetFactory and the expected\n-     * RowSetFactory implementation that should be returned\n-     *\/\n-    @DataProvider(name = \"RowSetFactoryValues\")\n-    private Object[][] RowSetFactoryValues() throws SQLException {\n-        RowSetFactory rsf = RowSetProvider.newFactory();\n-        RowSetFactory rsf1 = RowSetProvider.newFactory(STUB_FACTORY_CLASSNAME, null);\n-        RowSetFactory rsf2 = RowSetProvider.newFactory(DEFFAULT_FACTORY_CLASSNAME, null);\n-        return new Object[][]{\n-            {rsf, NO_VALADATE_IMPL},\n-            {rsf, DEFFAULT_FACTORY_CLASSNAME},\n-            {rsf1, STUB_FACTORY_CLASSNAME},\n-            {rsf2, DEFFAULT_FACTORY_CLASSNAME}\n-        };\n-    }\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/RowSetProviderTests.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset;\n-\n-import java.util.Locale;\n-import java.sql.SQLException;\n-import javax.sql.rowset.RowSetProvider;\n-import org.testng.annotations.Test;\n-import org.testng.annotations.BeforeClass;\n-import static org.testng.Assert.*;\n-\n-\/**\n- * @test\n- * @bug 8294989\n- * @summary Check that the resource bundle can be accessed\n- * @throws SQLException if an unexpected error occurs\n- * @run testng\/othervm\n- *\/\n-public class ValidateResourceBundleAccess{\n-    \/\/ Expected JDBCResourceBundle message, jdbcrowsetimpl.invalstate\n-    private static final String INVALIDSTATE = \"Invalid state\";\n-    \/\/ Expected JDBCResourceBundle message, crsreader.connecterr\n-    private static final String RSREADERERROR = \"Internal Error in RowSetReader: no connection or command\";\n-\n-    \/\/ Checking against English messages, set to US Locale\n-    @BeforeClass\n-    public void setEnglishEnvironment() {\n-        Locale.setDefault(Locale.US);\n-    }\n-\n-    @Test\n-    public void testResourceBundleAccess() throws SQLException {\n-        var rsr = RowSetProvider.newFactory();\n-        var crs =rsr.createCachedRowSet();\n-        var jrs = rsr.createJdbcRowSet();\n-        \/\/ Simple test to force an Exception to validate the expected message\n-        \/\/ is found from the resource bundle\n-        try {\n-            jrs.getMetaData();\n-            throw new RuntimeException(\"$$$ Expected SQLException was not thrown!\");\n-        } catch (SQLException sqe) {\n-            assertTrue(sqe.getMessage().equals(INVALIDSTATE));\n-        }\n-        \/\/ Now tests via CachedRowSet\n-        try {\n-            crs.execute();\n-            throw new RuntimeException(\"$$$ Expected SQLException was not thrown!\");\n-        } catch (SQLException e) {\n-            assertTrue(e.getMessage().equals(RSREADERERROR));\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/ValidateResourceBundleAccess.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,1612 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset.cachedrowset;\n-\n-import java.math.BigDecimal;\n-import java.sql.Array;\n-import java.sql.Date;\n-import java.sql.JDBCType;\n-import java.sql.Ref;\n-import java.sql.ResultSet;\n-import java.sql.ResultSetMetaData;\n-import java.sql.SQLException;\n-import java.sql.Time;\n-import java.sql.Timestamp;\n-import java.sql.Types;\n-import java.time.LocalDate;\n-import java.time.LocalDateTime;\n-import java.time.LocalTime;\n-import java.util.Collection;\n-import javax.sql.RowSet;\n-import javax.sql.rowset.CachedRowSet;\n-import javax.sql.rowset.RowSetMetaDataImpl;\n-import javax.sql.rowset.serial.SerialRef;\n-import javax.sql.rowset.spi.SyncFactory;\n-import javax.sql.rowset.spi.SyncProvider;\n-import javax.sql.rowset.spi.SyncProviderException;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertNull;\n-import static org.testng.Assert.assertTrue;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import test.rowset.CommonRowSetTests;\n-import util.StubArray;\n-import util.StubRef;\n-import util.StubSyncProvider;\n-import util.TestRowSetListener;\n-\n-public abstract class CommonCachedRowSetTests extends CommonRowSetTests {\n-\n-    \/*\n-     * DATATYPES Table column names\n-     *\/\n-    private final String[] DATATYPES_COLUMN_NAMES = {\"AINTEGER\", \"ACHAR\",\n-        \"AVARCHAR\", \"ALONG\", \"ABOOLEAN\", \"ASHORT\", \"ADOUBLE\", \"ABIGDECIMAL\",\n-        \"AREAL\", \"ABYTE\", \"ADATE\", \"ATIME\", \"ATIMESTAMP\", \"ABYTES\", \"ARRAY\",\n-        \"AREF\", \"AFLOAT\"};\n-\n-    \/*\n-     * Initializes a RowSet containing the DATAYPES data\n-     *\/\n-    protected <T extends RowSet> T createDataTypesRowSet() throws SQLException {\n-        T rs = (T) newInstance();\n-        initDataTypesMetaData((CachedRowSet) rs);\n-        createDataTypesRows(rs);\n-        \/\/ Make sure you are not on the insertRow\n-        rs.moveToCurrentRow();\n-        return rs;\n-    }\n-\n-    \/\/DataProviders to use for common tests\n-\n-    \/*\n-     * DataProvider that uses a RowSet with the COFFEE_HOUSES Table\n-     *\/\n-    @DataProvider(name = \"rowsetUsingCoffeeHouses\")\n-    protected Object[][] rowsetUsingCoffeeHouses() throws Exception {\n-        RowSet rs = createCoffeeHousesRowSet();\n-        return new Object[][]{\n-            {rs}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider that uses a RowSet with the COFFEES Table\n-     *\/\n-    @DataProvider(name = \"rowsetUsingCoffees\")\n-    protected Object[][] rowsetUsingCoffees() throws Exception {\n-        RowSet rs = createCoffeesRowSet();\n-        return new Object[][]{\n-            {rs}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider that uses a RowSet with the DATAYPES Table and\n-     * used to validate the various supported data types\n-     *\/\n-    @DataProvider(name = \"rowsetUsingDataTypes\")\n-    protected Object[][] rowsetUsingDataTypes() throws Exception {\n-\n-        CachedRowSet rs = createDataTypesRowSet();\n-        return new Object[][]{\n-            {rs, JDBCType.INTEGER},\n-            {rs, JDBCType.CHAR},\n-            {rs, JDBCType.VARCHAR},\n-            {rs, JDBCType.BIGINT},\n-            {rs, JDBCType.BOOLEAN},\n-            {rs, JDBCType.SMALLINT},\n-            {rs, JDBCType.DOUBLE},\n-            {rs, JDBCType.DECIMAL},\n-            {rs, JDBCType.REAL},\n-            {rs, JDBCType.TINYINT},\n-            {rs, JDBCType.DATE},\n-            {rs, JDBCType.TIME},\n-            {rs, JDBCType.TIMESTAMP},\n-            {rs, JDBCType.VARBINARY},\n-            {rs, JDBCType.ARRAY},\n-            {rs, JDBCType.REF},\n-            {rs, JDBCType.FLOAT}\n-        };\n-    }\n-\n-    \/*\n-     * Initializes the DATAYPES table metadata\n-     *\/\n-    protected void initDataTypesMetaData(CachedRowSet crs) throws SQLException {\n-        RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();\n-        crs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n-\n-        rsmd.setColumnCount(DATATYPES_COLUMN_NAMES.length);\n-\n-        for (int i = 1; i <= DATATYPES_COLUMN_NAMES.length; i++) {\n-            rsmd.setColumnName(i, DATATYPES_COLUMN_NAMES[i - 1]);\n-            rsmd.setColumnLabel(i, rsmd.getColumnName(i));\n-        }\n-\n-        rsmd.setColumnType(1, Types.INTEGER);\n-        rsmd.setColumnType(2, Types.CHAR);\n-        rsmd.setColumnType(3, Types.VARCHAR);\n-        rsmd.setColumnType(4, Types.BIGINT);\n-        rsmd.setColumnType(5, Types.BOOLEAN);\n-        rsmd.setColumnType(6, Types.SMALLINT);\n-        rsmd.setColumnType(7, Types.DOUBLE);\n-        rsmd.setColumnType(8, Types.DECIMAL);\n-        rsmd.setColumnType(9, Types.REAL);\n-        rsmd.setColumnType(10, Types.TINYINT);\n-        rsmd.setColumnType(11, Types.DATE);\n-        rsmd.setColumnType(12, Types.TIME);\n-        rsmd.setColumnType(13, Types.TIMESTAMP);\n-        rsmd.setColumnType(14, Types.VARBINARY);\n-        rsmd.setColumnType(15, Types.ARRAY);\n-        rsmd.setColumnType(16, Types.REF);\n-        rsmd.setColumnType(17, Types.FLOAT);\n-        crs.setMetaData(rsmd);\n-\n-    }\n-\n-    \/*\n-     * Add rows to DATAYPES table\n-     *\/\n-    protected void createDataTypesRows(RowSet crs) throws SQLException {\n-\n-        Integer aInteger = 100;\n-        String aChar = \"Oswald Cobblepot\";\n-        Long aLong = Long.MAX_VALUE;\n-        Short aShort = Short.MAX_VALUE;\n-        Double aDouble = Double.MAX_VALUE;\n-        BigDecimal aBigDecimal = BigDecimal.ONE;\n-        Boolean aBoolean = false;\n-        Float aFloat = Float.MAX_VALUE;\n-        Byte aByte = Byte.MAX_VALUE;\n-        Date aDate = Date.valueOf(LocalDate.now());\n-        Time aTime = Time.valueOf(LocalTime.now());\n-        Timestamp aTimeStamp = Timestamp.valueOf(LocalDateTime.now());\n-        Array aArray = new StubArray(\"INTEGER\", new Object[1]);\n-        Ref aRef = new SerialRef(new StubRef(\"INTEGER\", query));\n-        byte[] bytes = new byte[10];\n-        crs.moveToInsertRow();\n-        crs.updateInt(1, aInteger);\n-        crs.updateString(2, aChar);\n-        crs.updateString(3, aChar);\n-        crs.updateLong(4, aLong);\n-        crs.updateBoolean(5, aBoolean);\n-        crs.updateShort(6, aShort);\n-        crs.updateDouble(7, aDouble);\n-        crs.updateBigDecimal(8, aBigDecimal);\n-        crs.updateFloat(9, aFloat);\n-        crs.updateByte(10, aByte);\n-        crs.updateDate(11, aDate);\n-        crs.updateTime(12, aTime);\n-        crs.updateTimestamp(13, aTimeStamp);\n-        crs.updateBytes(14, bytes);\n-        crs.updateArray(15, aArray);\n-        crs.updateRef(16, aRef);\n-        crs.updateDouble(17, aDouble);\n-        crs.insertRow();\n-        crs.moveToCurrentRow();\n-\n-    }\n-\n-    \/*\n-     * Dermine if a Row exists in a ResultSet by its primary key\n-     * If the parameter deleteRow is true, delete the row and validate\n-     * the RowSet indicates it is deleted\n-     *\/\n-    protected boolean findRowByPrimaryKey(RowSet rs, int id, int idPos,\n-            boolean deleteRow) throws Exception {\n-        boolean foundRow = false;\n-        rs.beforeFirst();\n-        while (rs.next()) {\n-            if (rs.getInt(idPos) == id) {\n-                foundRow = true;\n-                if (deleteRow) {\n-                    rs.deleteRow();\n-                    \/\/ validate row is marked as deleted\n-                    assertTrue(rs.rowDeleted());\n-                }\n-                break;\n-            }\n-        }\n-        return foundRow;\n-    }\n-\n-    \/*\n-     * Wrapper method to find if a row exists within a RowSet by its primary key\n-     *\/\n-    protected boolean findRowByPrimaryKey(RowSet rs, int id, int idPos) throws Exception {\n-        return findRowByPrimaryKey(rs, id, idPos, false);\n-    }\n-\n-    \/*\n-     * Wrapper method to find if a row exists within a RowSet by its primary key\n-     * and delete it\n-     *\/\n-    protected boolean deleteRowByPrimaryKey(RowSet rs, int id, int idPos) throws Exception {\n-        return findRowByPrimaryKey(rs, id, idPos, true);\n-    }\n-\n-    \/*\n-     * Utility method that compares two ResultSetMetaDataImpls for containing\n-     * the same values\n-     *\/\n-    private void compareMetaData(ResultSetMetaData rsmd,\n-            ResultSetMetaData rsmd1) throws SQLException {\n-\n-        assertEquals(rsmd1.getColumnCount(), rsmd.getColumnCount());\n-        int cols = rsmd.getColumnCount();\n-        for (int i = 1; i <= cols; i++) {\n-            assertTrue(rsmd1.getCatalogName(i).equals(rsmd.getCatalogName(i)));\n-            assertTrue(rsmd1.getColumnClassName(i).equals(rsmd.getColumnClassName(i)));\n-            assertTrue(rsmd1.getColumnDisplaySize(i) == rsmd.getColumnDisplaySize(i));\n-            assertTrue(rsmd1.getColumnLabel(i).equals(rsmd.getColumnLabel(i)));\n-            assertTrue(rsmd1.getColumnName(i).equals(rsmd.getColumnName(i)));\n-            assertTrue(rsmd1.getColumnType(i) == rsmd.getColumnType(i));\n-            assertTrue(rsmd1.getPrecision(i) == rsmd.getPrecision(i));\n-            assertTrue(rsmd1.getScale(i) == rsmd.getScale(i));\n-            assertTrue(rsmd1.getSchemaName(i).equals(rsmd.getSchemaName(i)));\n-            assertTrue(rsmd1.getTableName(i).equals(rsmd.getTableName(i)));\n-            assertTrue(rsmd1.isAutoIncrement(i) == rsmd.isAutoIncrement(i));\n-            assertTrue(rsmd1.isCaseSensitive(i) == rsmd.isCaseSensitive(i));\n-            assertTrue(rsmd1.isCurrency(i) == rsmd.isCurrency(i));\n-            assertTrue(rsmd1.isDefinitelyWritable(i) == rsmd.isDefinitelyWritable(i));\n-            assertTrue(rsmd1.isNullable(i) == rsmd.isNullable(i));\n-            assertTrue(rsmd1.isReadOnly(i) == rsmd.isReadOnly(i));\n-            assertTrue(rsmd1.isSearchable(i) == rsmd.isSearchable(i));\n-            assertTrue(rsmd1.isSigned(i) == rsmd.isSigned(i));\n-            assertTrue(rsmd1.isWritable(i) == rsmd.isWritable(i));\n-\n-        }\n-    }\n-\n-    \/*\n-     * Utility method to compare two rowsets\n-     *\/\n-    private void compareRowSets(CachedRowSet crs, CachedRowSet crs1) throws Exception {\n-\n-        int rows = crs.size();\n-        assertTrue(rows == crs1.size());\n-\n-        ResultSetMetaData rsmd = crs.getMetaData();\n-\n-        compareMetaData(rsmd, crs1.getMetaData());\n-        int cols = rsmd.getColumnCount();\n-\n-        for (int row = 1; row <= rows; row++) {\n-            crs.absolute((row));\n-            crs1.absolute(row);\n-            for (int col = 1; col <= cols; col++) {\n-                compareColumnValue(JDBCType.valueOf(rsmd.getColumnType(col)),\n-                        crs, crs1, col);\n-            }\n-        }\n-\n-    }\n-\n-    \/*\n-     * Utility method to compare two columns\n-     *\/\n-    private void compareColumnValue(JDBCType type, ResultSet rs, ResultSet rs1,\n-            int col) throws SQLException {\n-\n-        switch (type) {\n-            case INTEGER:\n-                assertTrue(rs.getInt(col) == rs1.getInt(col));\n-                break;\n-            case CHAR:\n-            case VARCHAR:\n-                assertTrue(rs.getString(col).equals(rs1.getString(col)));\n-                break;\n-            case BIGINT:\n-                assertTrue(rs.getLong(col) == rs1.getLong(col));\n-                break;\n-            case BOOLEAN:\n-                assertTrue(rs.getBoolean(col) == rs1.getBoolean(col));\n-                break;\n-            case SMALLINT:\n-                assertTrue(rs.getShort(col) == rs1.getShort(col));\n-                break;\n-            case DOUBLE:\n-            case FLOAT:\n-                assertTrue(rs.getDouble(col) == rs1.getDouble(col));\n-                break;\n-            case DECIMAL:\n-                assertTrue(rs.getBigDecimal(col).equals(rs1.getBigDecimal(col)));\n-                break;\n-            case REAL:\n-                assertTrue(rs.getFloat(col) == rs1.getFloat(col));\n-                break;\n-            case TINYINT:\n-                assertTrue(rs.getByte(col) == rs1.getByte(col));\n-                break;\n-            case DATE:\n-                assertTrue(rs.getDate(col).equals(rs1.getDate(col)));\n-                break;\n-            case TIME:\n-                assertTrue(rs.getTime(col).equals(rs1.getTime(col)));\n-                break;\n-            case TIMESTAMP:\n-                assertTrue(rs.getTimestamp(col).equals(rs1.getTimestamp(col)));\n-                break;\n-        }\n-    }\n-\n-    \/*\n-     * Validate SyncProviderException is thrown when acceptChanges is called\n-     * but there is not a way to make a connection to the datasource\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SyncProviderException.class)\n-    public void commonCachedRowSetTest0000(CachedRowSet rs) throws Exception {\n-        rs.acceptChanges();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate SyncProviderException is thrown when acceptChanges is called\n-     * when null is passed as the datasource\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SyncProviderException.class)\n-    public void commonCachedRowSetTest0001(CachedRowSet rs) throws Exception {\n-        rs.acceptChanges(null);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that that RIOPtimsticProvider is the default SyncProvider\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonCachedRowSetTest0002(CachedRowSet rs) throws SQLException {\n-        SyncProvider sp = rs.getSyncProvider();\n-        assertTrue(sp instanceof com.sun.rowset.providers.RIOptimisticProvider);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that you can specify a SyncProvider\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonCachedRowSetTest0003(CachedRowSet rs) throws SQLException {\n-\n-        \/\/ Register a provider and make sure it is avaiable\n-        SyncFactory.registerProvider(stubProvider);\n-        rs.setSyncProvider(stubProvider);\n-        SyncProvider sp = rs.getSyncProvider();\n-        assertTrue(sp instanceof StubSyncProvider);\n-        SyncFactory.unregisterProvider(stubProvider);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Create a RowSetListener and validate that notifyRowSetChanged is called\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonCachedRowSetTest0004(CachedRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.release();\n-        assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Create a RowSetListener and validate that notifyRowSetChanged is called\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonCachedRowSetTest0005(CachedRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.restoreOriginal();\n-        assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Create a RowSetListener and validate that notifyRowChanged is called\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0006(RowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 10024);\n-        rs.updateString(2, \"Sacramento\");\n-        rs.updateInt(3, 1987);\n-        rs.updateInt(4, 2341);\n-        rs.updateInt(5, 4328);\n-        rs.insertRow();\n-        assertTrue(rsl.isNotified(TestRowSetListener.ROW_CHANGED));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Create a multiple RowSetListeners and validate that notifyRowChanged,\n-     * notifiyMoved is called on all listners\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0007(RowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        TestRowSetListener rsl2 = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.addRowSetListener(rsl2);\n-        rs.first();\n-        rs.updateInt(1, 1961);\n-        rs.updateString(2, \"Pittsburgh\");\n-        rs.updateInt(3, 1987);\n-        rs.updateInt(4, 2341);\n-        rs.updateInt(5, 6689);\n-        rs.updateRow();\n-        assertTrue(rsl.isNotified(TestRowSetListener.CURSOR_MOVED\n-                | TestRowSetListener.ROW_CHANGED));\n-        assertTrue(rsl2.isNotified(TestRowSetListener.CURSOR_MOVED\n-                | TestRowSetListener.ROW_CHANGED));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Create a RowSetListener and validate that notifyRowChanged  and\n-     * notifyCursorMoved are  called\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0008(CachedRowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-\n-        rs.first();\n-        assertTrue(rsl.isNotified(TestRowSetListener.CURSOR_MOVED));\n-        rs.deleteRow();\n-        assertTrue(\n-                rsl.isNotified(TestRowSetListener.ROW_CHANGED | TestRowSetListener.CURSOR_MOVED));\n-        rsl.resetFlag();\n-        rs.setShowDeleted(true);\n-        rs.undoDelete();\n-        assertTrue(rsl.isNotified(TestRowSetListener.ROW_CHANGED));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Create a RowSetListener and validate that notifyCursorMoved is called\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonCachedRowSetTest0009(RowSet rs) throws Exception {\n-        TestRowSetListener rsl = new TestRowSetListener();\n-        rs.addRowSetListener(rsl);\n-        rs.beforeFirst();\n-        assertTrue(rsl.isNotified(TestRowSetListener.CURSOR_MOVED));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that getTableName() returns the proper values\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonCachedRowSetTest0010(CachedRowSet rs) throws Exception {\n-        assertNull(rs.getTableName());\n-        rs.setTableName(COFFEE_HOUSES_TABLE);\n-        assertTrue(rs.getTableName().equals(COFFEE_HOUSES_TABLE));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that getKeyColumns() returns the proper values\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonCachedRowSetTest0011(CachedRowSet rs) throws Exception {\n-        int[] pkeys = {1, 3};\n-        assertNull(rs.getKeyColumns());\n-        rs.setKeyColumns(pkeys);\n-        assertEquals(rs.getKeyColumns(), pkeys);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that setMatchColumn throws a SQLException if the column\n-     * index specified is out of range\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0012(CachedRowSet rs) throws Exception {\n-        rs.setMatchColumn(-1);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that setMatchColumn throws a SQLException if the column\n-     * index specified is out of range\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0013(CachedRowSet rs) throws Exception {\n-        int[] cols = {1, -1};\n-        rs.setMatchColumn(cols);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that setMatchColumn throws a SQLException if the column\n-     * index specified is out of range\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0014(CachedRowSet rs) throws Exception {\n-        rs.setMatchColumn((String) null);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that setMatchColumn throws a SQLException if the column\n-     * index specified is out of range\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0015(CachedRowSet rs) throws Exception {\n-        String[] cols = {\"ID\", null};\n-        rs.setMatchColumn(cols);\n-    }\n-\n-    \/*\n-     * Validate that getMatchColumn returns the same value specified by\n-     * setMatchColumn\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\", enabled = false)\n-    public void commonCachedRowSetTest0016(CachedRowSet rs) throws Exception {\n-        int[] expectedCols = {1};\n-        String[] expectedColNames = {\"ID\"};\n-        rs.setMatchColumn(1);\n-        int[] actualCols = rs.getMatchColumnIndexes();\n-        String[] actualColNames = rs.getMatchColumnNames();\n-        for (int i = 0; i < actualCols.length; i++) {\n-            System.out.println(actualCols[i]);\n-        }\n-        assertEquals(actualCols, expectedCols);\n-        assertEquals(actualColNames, expectedColNames);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that getMatchColumn returns the same value specified by\n-     * setMatchColumn\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\", enabled = false)\n-    public void commonCachedRowSetTest0017(CachedRowSet rs) throws Exception {\n-        int[] expectedCols = {1};\n-        String[] expectedColNames = {\"ID\"};\n-        rs.setMatchColumn(expectedColNames[0]);\n-        int[] actualCols = rs.getMatchColumnIndexes();\n-        String[] actualColNames = rs.getMatchColumnNames();\n-        assertEquals(actualCols, expectedCols);\n-        assertEquals(actualColNames, expectedColNames);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that getMatchColumn returns the same valid value specified by\n-     * setMatchColumn\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\", enabled = false)\n-    public void commonCachedRowSetTest0018(CachedRowSet rs) throws Exception {\n-        int[] expectedCols = {1, 3};\n-        String[] expectedColNames = {\"COF_ID\", \"SUP_ID\"};\n-        rs.setMatchColumn(expectedCols);\n-        int[] actualCols = rs.getMatchColumnIndexes();\n-        String[] actualColNames = rs.getMatchColumnNames();\n-        assertEquals(actualCols, expectedCols);\n-        assertEquals(actualColNames, expectedColNames);\n-        assertEquals(actualCols, expectedCols);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that getMatchColumn returns the same valid value specified by\n-     * setMatchColumn\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\", enabled = false)\n-    public void commonCachedRowSetTest0019(CachedRowSet rs) throws Exception {\n-        int[] expectedCols = {1, 3};\n-        String[] expectedColNames = {\"COF_ID\", \"SUP_ID\"};\n-        rs.setMatchColumn(expectedColNames);\n-        int[] actualCols = rs.getMatchColumnIndexes();\n-        String[] actualColNames = rs.getMatchColumnNames();\n-        assertEquals(actualCols, expectedCols);\n-        assertEquals(actualColNames, expectedColNames);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that getMatchColumnIndexes throws a SQLException if\n-     * unsetMatchColumn has been called\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0020(CachedRowSet rs) throws Exception {\n-        rs.setMatchColumn(1);\n-        int[] actualCols = rs.getMatchColumnIndexes();\n-        assertTrue(actualCols != null);\n-        rs.unsetMatchColumn(1);\n-        actualCols = rs.getMatchColumnIndexes();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that getMatchColumnNames throws a SQLException if\n-     * unsetMatchColumn has been called\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0021(CachedRowSet rs) throws Exception {\n-        String matchColumn = \"ID\";\n-        rs.setMatchColumn(matchColumn);\n-        String[] actualColNames = rs.getMatchColumnNames();\n-        assertTrue(actualColNames != null);\n-        rs.unsetMatchColumn(matchColumn);\n-        actualColNames = rs.getMatchColumnNames();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that getMatchColumnIndexes throws a SQLException if\n-     * unsetMatchColumn has been called\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0022(CachedRowSet rs) throws Exception {\n-        int[] expectedCols = {1, 3};\n-        rs.setMatchColumn(expectedCols);\n-        int[] actualCols = rs.getMatchColumnIndexes();\n-        assertTrue(actualCols != null);\n-        rs.unsetMatchColumn(expectedCols);\n-        actualCols = rs.getMatchColumnIndexes();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that getMatchColumnNames throws a SQLException if\n-     * unsetMatchColumn has been called\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0023(CachedRowSet rs) throws Exception {\n-        String[] expectedColNames = {\"COF_ID\", \"SUP_ID\"};\n-        rs.setMatchColumn(expectedColNames);\n-        String[] actualColNames = rs.getMatchColumnNames();\n-        assertTrue(actualColNames != null);\n-        rs.unsetMatchColumn(expectedColNames);\n-        actualColNames = rs.getMatchColumnNames();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate size() returns the correct number of rows\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0024(CachedRowSet rs) throws Exception {\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that the correct rows are returned comparing the primary\n-     * keys\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0025(RowSet rs) throws SQLException {\n-        assertEquals(getPrimaryKeys(rs), COFFEE_HOUSES_PRIMARY_KEYS);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Delete a row within the RowSet using its primary key\n-     * Validate the visibility of the row depending on the value of\n-     * setShowdelete\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0026(CachedRowSet rs) throws Exception {\n-        Object[] afterDelete = {\n-            10023, 33002, 10040, 32001, 10042, 10024, 10039, 10041,\n-            33005, 33010, 10037, 10034, 32004\n-        };\n-        int rowToDelete = 10035;\n-        \/\/ All rows should be found\n-        assertEquals(getPrimaryKeys(rs), COFFEE_HOUSES_PRIMARY_KEYS);\n-        \/\/ Delete the row\n-        assertTrue(deleteRowByPrimaryKey(rs, rowToDelete, 1));\n-        \/\/ With setShowDeleted(false) which is the default,\n-        \/\/ the deleted row should not be visible\n-        assertFalse(findRowByPrimaryKey(rs, rowToDelete, 1));\n-        assertEquals(getPrimaryKeys(rs), afterDelete);\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n-        \/\/ With setShowDeleted(true), the deleted row should be visible\n-        rs.setShowDeleted(true);\n-        assertTrue(findRowByPrimaryKey(rs, rowToDelete, 1));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that there is no page size by default\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonCachedRowSetTest0027(CachedRowSet rs) throws Exception {\n-        assertTrue(rs.getPageSize() == 0);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate the value you set via setPageSize is returned by getPageSize\n-     * then reset to having no limit\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void commonCachedRowSetTest0028(CachedRowSet rs) throws Exception {\n-        int rows = 100;\n-        rs.setPageSize(rows);\n-        assertTrue(rows == rs.getPageSize());\n-        rs.setPageSize(0);\n-        assertTrue(rs.getPageSize() == 0);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate SQLException is thrown when an invalid value is specified\n-     * for setPageSize\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0029(CachedRowSet rs) throws Exception {\n-        rs.setPageSize(-1);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate SQLException is thrown when nextPage is called without a\n-     * call to populate or execute\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0030(CachedRowSet rs) throws Exception {\n-        rs.nextPage();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate SQLException is thrown when previousPage is called without a\n-     * call to populate or execute\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0031(CachedRowSet rs) throws Exception {\n-        rs.previousPage();\n-        rs.close();\n-    }\n-\n-\n-    \/*\n-     * Validate SQLException is thrown when execute is called\n-     * but there is not a way to make a connection to the datasource\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0032(CachedRowSet rs) throws Exception {\n-        rs.execute(null);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate SQLException is thrown when execute is called\n-     * but there is not a way to make a connection to the datasource\n-     *\/\n-    @Test(dataProvider = \"rowSetType\", expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0033(CachedRowSet rs) throws Exception {\n-        rs.execute();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that toCollection(<column>) returns the proper values\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0034(CachedRowSet rs) throws Exception {\n-        Object[] cities = {\"Mendocino\", \"Seattle\", \"SF\", \"Portland\", \"SF\",\n-            \"Sacramento\", \"Carmel\", \"LA\", \"Olympia\", \"Seattle\", \"SF\",\n-            \"LA\", \"San Jose\", \"Eugene\"};\n-        rs.beforeFirst();\n-        assertEquals(rs.toCollection(2).toArray(), cities);\n-        assertEquals(rs.toCollection(\"CITY\").toArray(), cities);\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that toCollection() returns the proper values\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0035(CachedRowSet rs) throws Exception {\n-        Collection<?> col = rs.toCollection();\n-        assertTrue(rs.size() == col.size());\n-        assertTrue(rs.toCollection().containsAll(col)\n-                && col.containsAll(rs.toCollection()));\n-        try ( \/\/ Validate that False is returned when compared to a different RowSet;\n-                CachedRowSet crs1 = createCoffeesRowSet()) {\n-            assertFalse(crs1.toCollection().containsAll(col)\n-                    && col.containsAll(crs1.toCollection()));\n-        }\n-        rs.close();\n-\n-    }\n-\n-    \/*\n-     * Validate that createCopy() returns the proper values\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0036(CachedRowSet rs) throws Exception {\n-        try (CachedRowSet crs1 = rs.createCopy()) {\n-            compareRowSets(rs, crs1);\n-        }\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that createCopySchema() returns the proper values\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0037(CachedRowSet rs) throws Exception {\n-        try (CachedRowSet crs1 = rs.createCopySchema()) {\n-            assertTrue(crs1.size() == 0);\n-            compareMetaData(crs1.getMetaData(), rs.getMetaData());\n-        }\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that createCopyNoConstraints() returns the proper values\n-     * and getMatchColumnIndexes should throw a SQLException. This test\n-     * specifies setMatchColumn(int)\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0038(CachedRowSet rs) throws Exception {\n-        rs.setMatchColumn(1);\n-        try (CachedRowSet crs1 = rs.createCopyNoConstraints()) {\n-            assertTrue(crs1.size() == COFFEE_HOUSES_ROWS);\n-            compareRowSets(rs, crs1);\n-            boolean recievedSQE = false;\n-            try {\n-                int[] indexes = crs1.getMatchColumnIndexes();\n-            } catch (SQLException e) {\n-                recievedSQE = true;\n-            }\n-            assertTrue(recievedSQE);\n-            recievedSQE = false;\n-            try {\n-                String[] colNames = crs1.getMatchColumnNames();\n-            } catch (SQLException e) {\n-                recievedSQE = true;\n-            }\n-            assertTrue(recievedSQE);\n-        }\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that createCopyNoConstraints() returns the proper values\n-     * and getMatchColumnIndexes should throw a SQLException. This test\n-     * specifies setMatchColumn(String)\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0039(CachedRowSet rs) throws Exception {\n-        rs.setMatchColumn(\"ID\");\n-        try (CachedRowSet crs1 = rs.createCopyNoConstraints()) {\n-            assertTrue(crs1.size() == COFFEE_HOUSES_ROWS);\n-            compareRowSets(rs, crs1);\n-            boolean recievedSQE = false;\n-            try {\n-                int[] indexes = crs1.getMatchColumnIndexes();\n-            } catch (SQLException e) {\n-                recievedSQE = true;\n-            }\n-            assertTrue(recievedSQE);\n-            recievedSQE = false;\n-            try {\n-                String[] colNames = crs1.getMatchColumnNames();\n-            } catch (SQLException e) {\n-                recievedSQE = true;\n-            }\n-            assertTrue(recievedSQE);\n-        }\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that columnUpdated works with the various datatypes specifying\n-     * the column index\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingDataTypes\")\n-    public void commonCachedRowSetTest0040(CachedRowSet rs, JDBCType type) throws Exception {\n-        rs.beforeFirst();\n-        assertTrue(rs.next());\n-        switch (type) {\n-            case INTEGER:\n-                assertFalse(rs.columnUpdated(1));\n-                rs.updateInt(1, Integer.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(1));\n-                break;\n-            case CHAR:\n-                assertFalse(rs.columnUpdated(2));\n-                rs.updateString(2, \"foo\");\n-                assertTrue(rs.columnUpdated(2));\n-                break;\n-            case VARCHAR:\n-                assertFalse(rs.columnUpdated(3));\n-                rs.updateString(3, \"foo\");\n-                assertTrue(rs.columnUpdated(3));\n-                break;\n-            case BIGINT:\n-                assertFalse(rs.columnUpdated(4));\n-                rs.updateLong(4, Long.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(4));\n-                break;\n-            case BOOLEAN:\n-                assertFalse(rs.columnUpdated(5));\n-                rs.updateBoolean(5, false);\n-                assertTrue(rs.columnUpdated(5));\n-                break;\n-            case SMALLINT:\n-                assertFalse(rs.columnUpdated(6));\n-                rs.updateShort(6, Short.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(6));\n-                break;\n-            case DOUBLE:\n-                assertFalse(rs.columnUpdated(7));\n-                rs.updateDouble(7, Double.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(7));\n-                break;\n-            case DECIMAL:\n-                assertFalse(rs.columnUpdated(8));\n-                rs.updateBigDecimal(8, BigDecimal.TEN);\n-                assertTrue(rs.columnUpdated(8));\n-                break;\n-            case REAL:\n-                assertFalse(rs.columnUpdated(9));\n-                rs.updateFloat(9, Float.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(9));\n-                break;\n-            case TINYINT:\n-                assertFalse(rs.columnUpdated(10));\n-                rs.updateByte(10, Byte.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(10));\n-                break;\n-            case DATE:\n-                assertFalse(rs.columnUpdated(11));\n-                rs.updateDate(11, Date.valueOf(LocalDate.now()));\n-                assertTrue(rs.columnUpdated(11));\n-                break;\n-            case TIME:\n-                assertFalse(rs.columnUpdated(12));\n-                rs.updateTime(12, Time.valueOf(LocalTime.now()));\n-                assertTrue(rs.columnUpdated(12));\n-                break;\n-            case TIMESTAMP:\n-                assertFalse(rs.columnUpdated(13));\n-                rs.updateTimestamp(13, Timestamp.valueOf(LocalDateTime.now()));\n-                assertTrue(rs.columnUpdated(13));\n-                break;\n-            case VARBINARY:\n-                assertFalse(rs.columnUpdated(14));\n-                rs.updateBytes(14, new byte[1]);\n-                assertTrue(rs.columnUpdated(14));\n-                break;\n-            case ARRAY:\n-                assertFalse(rs.columnUpdated(15));\n-                rs.updateArray(15, new StubArray(\"VARCHAR\", new Object[10]));\n-                assertTrue(rs.columnUpdated(15));\n-                break;\n-            case REF:\n-                assertFalse(rs.columnUpdated(16));\n-                rs.updateRef(16, new StubRef(\"INTEGER\", query));\n-                assertTrue(rs.columnUpdated(16));\n-                break;\n-            case FLOAT:\n-                assertFalse(rs.columnUpdated(17));\n-                rs.updateDouble(17, Double.MIN_NORMAL);\n-                assertTrue(rs.columnUpdated(17));\n-        }\n-\n-    }\n-\n-    \/*\n-     * Validate that columnUpdated works with the various datatypes specifying\n-     * the column name\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingDataTypes\")\n-    public void commonCachedRowSetTest0041(CachedRowSet rs, JDBCType type) throws Exception {\n-        rs.beforeFirst();\n-        assertTrue(rs.next());\n-        switch (type) {\n-            case INTEGER:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[0]));\n-                rs.updateInt(DATATYPES_COLUMN_NAMES[0], Integer.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[0]));\n-                break;\n-            case CHAR:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[1]));\n-                rs.updateString(DATATYPES_COLUMN_NAMES[1], \"foo\");\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[1]));\n-                break;\n-            case VARCHAR:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[2]));\n-                rs.updateString(DATATYPES_COLUMN_NAMES[2], \"foo\");\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[2]));\n-                break;\n-            case BIGINT:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[3]));\n-                rs.updateLong(DATATYPES_COLUMN_NAMES[3], Long.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[3]));\n-                break;\n-            case BOOLEAN:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[4]));\n-                rs.updateBoolean(DATATYPES_COLUMN_NAMES[4], false);\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[4]));\n-                break;\n-            case SMALLINT:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[5]));\n-                rs.updateShort(DATATYPES_COLUMN_NAMES[5], Short.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[5]));\n-                break;\n-            case DOUBLE:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[6]));\n-                rs.updateDouble(DATATYPES_COLUMN_NAMES[6], Double.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[6]));\n-                break;\n-            case DECIMAL:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[7]));\n-                rs.updateBigDecimal(DATATYPES_COLUMN_NAMES[7], BigDecimal.TEN);\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[7]));\n-                break;\n-            case REAL:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[8]));\n-                rs.updateFloat(DATATYPES_COLUMN_NAMES[8], Float.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[8]));\n-                break;\n-            case TINYINT:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[9]));\n-                rs.updateByte(DATATYPES_COLUMN_NAMES[9], Byte.MIN_VALUE);\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[9]));\n-                break;\n-            case DATE:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[10]));\n-                rs.updateDate(DATATYPES_COLUMN_NAMES[10], Date.valueOf(LocalDate.now()));\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[10]));\n-                break;\n-            case TIME:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[11]));\n-                rs.updateTime(DATATYPES_COLUMN_NAMES[11], Time.valueOf(LocalTime.now()));\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[11]));\n-                break;\n-            case TIMESTAMP:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[12]));\n-                rs.updateTimestamp(DATATYPES_COLUMN_NAMES[12], Timestamp.valueOf(LocalDateTime.now()));\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[12]));\n-                break;\n-            case VARBINARY:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[13]));\n-                rs.updateBytes(DATATYPES_COLUMN_NAMES[13], new byte[1]);\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[13]));\n-                break;\n-            case ARRAY:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[14]));\n-                rs.updateArray(DATATYPES_COLUMN_NAMES[14], new StubArray(\"VARCHAR\", new Object[10]));\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[14]));\n-                break;\n-            case REF:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[15]));\n-                rs.updateRef(DATATYPES_COLUMN_NAMES[15], new StubRef(\"INTEGER\", query));\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[15]));\n-                break;\n-            case FLOAT:\n-                assertFalse(rs.columnUpdated(DATATYPES_COLUMN_NAMES[16]));\n-                rs.updateDouble(DATATYPES_COLUMN_NAMES[16], Double.MIN_NORMAL);\n-                assertTrue(rs.columnUpdated(DATATYPES_COLUMN_NAMES[16]));\n-                break;\n-        }\n-\n-    }\n-\n-    \/*\n-     * Validate isBeforeFirst(), isFirst() and first() return the correct\n-     * results\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0042(RowSet rs) throws Exception {\n-        assertFalse(rs.isBeforeFirst());\n-        assertFalse(rs.isFirst());\n-        rs.beforeFirst();\n-        assertTrue(rs.isBeforeFirst());\n-        assertFalse(rs.isFirst());\n-        rs.next();\n-        assertFalse(rs.isBeforeFirst());\n-        assertTrue(rs.isFirst());\n-        rs.next();\n-        assertFalse(rs.isBeforeFirst());\n-        assertFalse(rs.isFirst());\n-        rs.first();\n-        assertFalse(rs.isBeforeFirst());\n-        assertTrue(rs.isFirst());\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate isAfterLast(), isLast() and last() return the correct\n-     * results\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0043(RowSet rs) throws Exception {\n-        assertFalse(rs.isAfterLast());\n-        assertFalse(rs.isLast());\n-        rs.afterLast();\n-        assertTrue(rs.isAfterLast());\n-        assertFalse(rs.isLast());\n-        rs.previous();\n-        assertFalse(rs.isAfterLast());\n-        assertTrue(rs.isLast());\n-        rs.previous();\n-        assertFalse(rs.isAfterLast());\n-        assertFalse(rs.isLast());\n-        rs.last();\n-        assertFalse(rs.isAfterLast());\n-        assertTrue(rs.isLast());\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown when undoDelete is called on the\n-     * insertRow\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0044(CachedRowSet rs) throws Exception {\n-        rs.insertRow();\n-        rs.undoDelete();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown when undoDelete is called when\n-     * cursor is before the first row\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0045(CachedRowSet rs) throws Exception {\n-        rs.setShowDeleted(true);\n-        rs.beforeFirst();\n-        rs.undoDelete();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown when undoDelete is called when\n-     * cursor is after the last row\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0046(CachedRowSet rs) throws Exception {\n-        rs.setShowDeleted(true);\n-        rs.afterLast();\n-        rs.undoDelete();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown when undoUpdate is called on the\n-     * insertRow\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0047(CachedRowSet rs) throws Exception {\n-        rs.insertRow();\n-        rs.undoUpdate();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown when undoUpdate is called when\n-     * cursor is before the first row\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0048(CachedRowSet rs) throws Exception {\n-        rs.setShowDeleted(true);\n-        rs.beforeFirst();\n-        rs.undoUpdate();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown when undoUpdate is called when\n-     * cursor is after the last row\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0049(CachedRowSet rs) throws Exception {\n-        rs.setShowDeleted(true);\n-        rs.afterLast();\n-        rs.undoUpdate();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown when undoInsert is called on the\n-     * insertRow\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0050(CachedRowSet rs) throws Exception {\n-        rs.insertRow();\n-        rs.undoInsert();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown when undoInsert is called when\n-     * cursor is before the first row\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0051(CachedRowSet rs) throws Exception {\n-        rs.setShowDeleted(true);\n-        rs.beforeFirst();\n-        rs.undoInsert();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown when undoInsert is called when\n-     * cursor is after the last row\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\",\n-            expectedExceptions = SQLException.class)\n-    public void commonCachedRowSetTest0052(CachedRowSet rs) throws Exception {\n-        rs.setShowDeleted(true);\n-        rs.afterLast();\n-        rs.undoInsert();\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Insert a row, then call undoInsert to roll back the insert and validate\n-     * the row is not there\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0053(CachedRowSet rs) throws Exception {\n-        int rowToInsert = 1961;\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n-        \/\/ Add new row\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, rowToInsert);\n-        rs.updateString(2, \"GOTHAM\");\n-        rs.updateInt(3, 3450);\n-        rs.updateInt(4, 2005);\n-        rs.updateInt(5, 5455);\n-        rs.insertRow();\n-        rs.moveToCurrentRow();\n-        \/\/ check that the number of rows has increased\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS + 1);\n-        assertTrue(findRowByPrimaryKey(rs, rowToInsert, 1));\n-        rs.undoInsert();\n-        \/\/ Check to make sure the row is no longer there\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n-        assertFalse(findRowByPrimaryKey(rs, rowToInsert, 1));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Insert a row, delete the row and then call undoDelete to make sure it\n-     * is comes back\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0054(CachedRowSet rs) throws Exception {\n-        int rowToDelete = 1961;\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n-        \/\/ Add new row\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, rowToDelete);\n-        rs.updateString(2, \"GOTHAM\");\n-        rs.updateInt(3, 3450);\n-        rs.updateInt(4, 2005);\n-        rs.updateInt(5, 5455);\n-        rs.insertRow();\n-        rs.moveToCurrentRow();\n-        \/\/ check that the number of rows has increased\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS + 1);\n-        assertTrue(findRowByPrimaryKey(rs, rowToDelete, 1));\n-        rs.absolute(COFFEE_HOUSES_ROWS + 1);\n-        rs.deleteRow();\n-        \/\/ Check to make sure the row is no longer there\n-        \/\/assertTrue(rs.size() ==  COFFEE_HOUSES_ROWS);\n-        assertFalse(findRowByPrimaryKey(rs, rowToDelete, 1));\n-        rs.setShowDeleted(true);\n-        rs.absolute(COFFEE_HOUSES_ROWS + 1);\n-        rs.undoDelete();\n-        \/\/ check that the row is back\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS + 1);\n-        assertTrue(findRowByPrimaryKey(rs, rowToDelete, 1));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Insert a row, modify a field and then call undoUpdate to revert the\n-     * insert\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0055(CachedRowSet rs) throws Exception {\n-        int rowToInsert = 1961;\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n-        \/\/ Add new row\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, rowToInsert);\n-        rs.updateString(2, \"GOTHAM\");\n-        rs.updateInt(3, 3450);\n-        rs.updateInt(4, 2005);\n-        rs.updateInt(5, 5455);\n-        rs.insertRow();\n-        rs.moveToCurrentRow();\n-        \/\/ check that the number of rows has increased\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS + 1);\n-        assertTrue(findRowByPrimaryKey(rs, rowToInsert, 1));\n-        rs.absolute(COFFEE_HOUSES_ROWS + 1);\n-        \/\/ Save off the original column values\n-        String f2 = rs.getString(2);\n-        int f3 = rs.getInt(3);\n-        rs.updateString(2, \"SMALLVILLE\");\n-        rs.updateInt(3, 500);\n-        \/\/ Validate the columns have been updated\n-        assertTrue(rs.columnUpdated(2));\n-        assertTrue(rs.columnUpdated(3));\n-        \/\/ Undo the update and validate it has taken place\n-        rs.absolute(COFFEE_HOUSES_ROWS + 1);\n-        rs.undoUpdate();\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n-        assertFalse(findRowByPrimaryKey(rs, rowToInsert, 1));\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate getOriginal returns a ResultSet which is a copy of the original\n-     * RowSet\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffees\")\n-    public void commonCachedRowSetTest0056(CachedRowSet rs) throws Exception {\n-        String coffee = \"Hazelnut\";\n-        int sales = 100;\n-        int id = 200;\n-        Object[] updatedPkeys = {1, id, 3, 4, 5};\n-        \/\/ Change the coffee name and sales total for row 2 and save the\n-        \/\/ previous values\n-        rs.absolute(2);\n-        int origId = rs.getInt(1);\n-        String origCoffee = rs.getString(2);\n-        int origSales = rs.getInt(5);\n-        rs.updateInt(1, id);\n-        rs.updateString(2, coffee);\n-        rs.updateInt(5, sales);\n-        \/\/ MetaData should match\n-        try ( \/\/ Get the original RowSet and validate that the changes\n-                \/\/ are only made to the current, not the original\n-                ResultSet rs1 = rs.getOriginal()) {\n-            \/\/ MetaData should match\n-            compareMetaData(rs.getMetaData(), rs1.getMetaData());\n-            assertTrue(rs1.isBeforeFirst());\n-            assertTrue(rs1.getConcurrency() == ResultSet.CONCUR_UPDATABLE);\n-            assertTrue(rs1.getType() == ResultSet.TYPE_SCROLL_INSENSITIVE);\n-            rs1.absolute(2);\n-            \/\/ Check original rowset is not changed\n-            assertTrue(rs1.getInt(1) == origId);\n-            assertTrue(rs1.getString(2).equals(origCoffee));\n-            assertTrue(rs1.getInt(5) == origSales);\n-            assertEquals(getPrimaryKeys(rs1), COFFEES_PRIMARY_KEYS);\n-            \/\/ Check current rowset\n-            assertTrue(rs.getInt(1) == id);\n-            assertTrue(rs.getString(2).equals(coffee));\n-            assertTrue(rs.getInt(5) == sales);\n-            assertEquals(getPrimaryKeys(rs), updatedPkeys);\n-        }\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate getOriginalRow returns a ResultSet which is a copy of the\n-     * original row that was modified\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffees\")\n-    public void commonCachedRowSetTest0057(CachedRowSet rs) throws Exception {\n-        String coffee = \"Hazelnut\";\n-        int sales = 100;\n-        int id = 200;\n-        Object[] updatedPkeys = {1, id, 3, 4, 5};\n-        \/\/ Change the coffee name and sales total for row 2 and save the\n-        \/\/ previous values\n-        rs.absolute(2);\n-        int origId = rs.getInt(1);\n-        String origCoffee = rs.getString(2);\n-        int origSales = rs.getInt(5);\n-        rs.updateInt(1, id);\n-        rs.updateString(2, coffee);\n-        rs.updateInt(5, sales);\n-        \/\/ MetaData should match\n-        try ( \/\/ Get the original row and validate that the changes\n-                \/\/ are only made to the current, not the original\n-                ResultSet rs1 = rs.getOriginalRow()) {\n-            \/\/ MetaData should match\n-            compareMetaData(rs.getMetaData(), rs1.getMetaData());\n-            assertTrue(rs1.isBeforeFirst());\n-            assertTrue(rs1.getConcurrency() == ResultSet.CONCUR_UPDATABLE);\n-            assertTrue(rs1.getType() == ResultSet.TYPE_SCROLL_INSENSITIVE);\n-            rs1.next();\n-            assertTrue(rs1.isFirst() && rs1.isLast());\n-            assertTrue(rs1.getRow() == 1);\n-            \/\/ Check original row is not changed\n-            assertTrue(rs1.getInt(1) == origId);\n-            assertTrue(rs1.getString(2).equals(origCoffee));\n-            assertTrue(rs1.getInt(5) == origSales);\n-            \/\/ Check current row\n-            assertTrue(rs.getInt(1) == id);\n-            assertTrue(rs.getString(2).equals(coffee));\n-            assertTrue(rs.getInt(5) == sales);\n-            assertEquals(getPrimaryKeys(rs), updatedPkeys);\n-        }\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that restoreOrginal will restore the RowSet to its\n-     * state prior to the insert of a row\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0058(CachedRowSet rs) throws Exception {\n-        int rowToInsert = 1961;\n-        assertTrue(rs.size() == COFFEE_HOUSES_ROWS);\n-        try ( \/\/ Add new row\n-                CachedRowSet crs1 = rsf.createCachedRowSet()) {\n-            rs.beforeFirst();\n-            crs1.populate(rs);\n-            TestRowSetListener rsl = new TestRowSetListener();\n-            crs1.addRowSetListener(rsl);\n-            crs1.moveToInsertRow();\n-            crs1.updateInt(1, rowToInsert);\n-            crs1.updateString(2, \"GOTHAM\");\n-            crs1.updateInt(3, 3450);\n-            crs1.updateInt(4, 2005);\n-            crs1.updateInt(5, 5455);\n-            crs1.insertRow();\n-            assertTrue(rsl.isNotified(TestRowSetListener.ROW_CHANGED));\n-            crs1.moveToCurrentRow();\n-            assertTrue(findRowByPrimaryKey(crs1, rowToInsert, 1));\n-            \/\/ Restore back to our original state and the\n-            \/\/ previously inserted row should not be there\n-            rsl.resetFlag();\n-            crs1.restoreOriginal();\n-            assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n-            assertTrue(crs1.isBeforeFirst());\n-            crs1.last();\n-            assertFalse(crs1.rowInserted());\n-            assertFalse(findRowByPrimaryKey(crs1, rowToInsert, 1));\n-        }\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that restoreOrginal will restore the RowSet to its\n-     * state prior to deleting a row\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffees\", enabled = true)\n-    public void commonCachedRowSetTest0059(CachedRowSet rs) throws Exception {\n-        int rowToDelete = 2;\n-        try (CachedRowSet crs1 = rsf.createCachedRowSet()) {\n-            rs.beforeFirst();\n-            crs1.populate(rs);\n-            TestRowSetListener rsl = new TestRowSetListener();\n-            crs1.addRowSetListener(rsl);\n-            \/\/ Delete a row, the PK is also the absolute position as a List\n-            \/\/ backs the RowSet\n-            crs1.absolute(rowToDelete);\n-            crs1.deleteRow();\n-            assertTrue(crs1.rowDeleted());\n-            assertFalse(findRowByPrimaryKey(crs1, rowToDelete, 1));\n-            \/\/ Restore back to our original state and the\n-            \/\/ previously deleted row should be there\n-            rsl.resetFlag();\n-            crs1.restoreOriginal();\n-            assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n-            assertTrue(crs1.isBeforeFirst());\n-            crs1.absolute(rowToDelete);\n-            assertFalse(crs1.rowDeleted());\n-            assertTrue(findRowByPrimaryKey(crs1, rowToDelete, 1));\n-        }\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Validate that restoreOrginal will restore the RowSet to its\n-     * state prior to updating a row\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffees\", enabled = true)\n-    public void commonCachedRowSetTest0060(CachedRowSet rs) throws Exception {\n-        int rowToUpdate = 2;\n-        String coffee = \"Hazelnut\";\n-        try (CachedRowSet crs1 = rsf.createCachedRowSet()) {\n-            rs.beforeFirst();\n-            crs1.populate(rs);\n-            TestRowSetListener rsl = new TestRowSetListener();\n-            crs1.addRowSetListener(rsl);\n-            \/\/ Delete a row, the PK is also the absolute position as a List\n-            \/\/ backs the RowSet\n-            crs1.absolute(rowToUpdate);\n-            String origCoffee = crs1.getString(2);\n-            crs1.updateString(2, coffee);\n-            assertTrue(crs1.columnUpdated(2));\n-            crs1.updateRow();\n-            assertTrue(crs1.rowUpdated());\n-            assertFalse(origCoffee.equals(crs1.getString(2)));\n-            \/\/ Restore back to our original state and the\n-            \/\/ previous value for the column within the row should be there\n-            rsl.resetFlag();\n-            crs1.restoreOriginal();\n-            assertTrue(rsl.isNotified(TestRowSetListener.ROWSET_CHANGED));\n-            assertTrue(crs1.isBeforeFirst());\n-            \/\/ absolute() is failing for some reason so need to look at this later\n-            crs1.next();\n-            crs1.next();\n-            assertFalse(crs1.columnUpdated(2));\n-            assertFalse(crs1.rowUpdated());\n-            assertTrue(origCoffee.equals(crs1.getString(2)));\n-        }\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Initialize a RowSet via the populate method. Validate it matches\n-     * the original ResultSet\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0061(CachedRowSet rs) throws Exception {\n-        try (CachedRowSet crs1 = rsf.createCachedRowSet()) {\n-            rs.beforeFirst();\n-            crs1.populate(rs);\n-            compareRowSets(rs, crs1);\n-        }\n-        rs.close();\n-    }\n-\n-    \/*\n-     * Initialize a RowSet via the populate method specifying a starting row.\n-     * Validate it matches the original ResultSet starting for the specofied\n-     * offset\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffeeHouses\")\n-    public void commonCachedRowSetTest0062(CachedRowSet rs) throws Exception {\n-        Object[] expectedRows = {\n-            32001, 10042, 10024, 10039, 10041, 33005, 33010, 10035, 10037,\n-            10034, 32004\n-        };\n-        int startingRow = 4;\n-        try (CachedRowSet crs1 = rsf.createCachedRowSet()) {\n-            rs.beforeFirst();\n-            crs1.populate(rs, startingRow);\n-            assertEquals(crs1.size(), COFFEE_HOUSES_ROWS - startingRow + 1);\n-            assertEquals(getPrimaryKeys(crs1), expectedRows);\n-        }\n-        rs.close();\n-    }\n-\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/cachedrowset\/CommonCachedRowSetTests.java","additions":0,"deletions":1612,"binary":false,"changes":1612,"status":"deleted"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset.filteredrowset;\n-\n-import java.sql.SQLException;\n-import javax.sql.RowSet;\n-import javax.sql.rowset.FilteredRowSet;\n-import javax.sql.rowset.Predicate;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertNull;\n-import static org.testng.Assert.assertTrue;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import test.rowset.webrowset.CommonWebRowSetTests;\n-\n-public class FilteredRowSetTests extends CommonWebRowSetTests {\n-\n-    private FilteredRowSet frs;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        frs = createCoffeeHousesRowSet();\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-        frs.close();\n-    }\n-\n-    protected FilteredRowSet newInstance() throws SQLException {\n-        return rsf.createFilteredRowSet();\n-    }\n-\n-    \/*\n-     * Validate getFilter returns null if setFilter has not been called\n-     *\/\n-    @Test\n-    public void FilteredRowSetTest0000() throws SQLException {\n-        assertNull(frs.getFilter());\n-    }\n-\n-    \/*\n-     * Call setFilter to set a Predicate and validate that getFilter\n-     * returns the correct Predicate\n-     *\/\n-    @Test\n-    public void FilteredRowSetTest0001() throws SQLException {\n-        Predicate p = new PrimaryKeyFilter(0, 100030, 1);\n-        frs.setFilter(p);\n-        assertTrue(frs.getFilter().equals(p));\n-        frs.setFilter(null);\n-        assertNull(frs.getFilter());\n-    }\n-\n-    \/*\n-     * Validate that the correct rows are returned when a Predicate using\n-     * a column index is used\n-     *\/\n-    @Test\n-    public void FilteredRowSetTest0002() throws SQLException {\n-        Object[] expectedKeys = {\n-            10023, 10040, 10042, 10024, 10039, 10041, 10035, 10037, 10034\n-        };\n-        frs.setFilter(new PrimaryKeyFilter(10000, 10999, 1));\n-        assertEquals(getPrimaryKeys(frs), expectedKeys);\n-    }\n-\n-    \/*\n-     * Validate that the correct rows are returned when a Predicate using\n-     * a column Label is used\n-     *\/\n-    @Test\n-    public void FilteredRowSetTest0003() throws SQLException {\n-        Object[] expectedKeys = {\n-            10023, 10040, 10042, 10024, 10039, 10041, 10035, 10037, 10034\n-        };\n-        frs.setFilter(new PrimaryKeyFilter(10000, 10999, \"STORE_ID\"));\n-        assertEquals(getPrimaryKeys(frs), expectedKeys);\n-\n-    }\n-\n-    \/*\n-     * Validate that the correct rows are returned when a Predicate using\n-     * a column index is used\n-     *\/\n-    @Test\n-    public void FilteredRowSetTest0004() throws SQLException {\n-        Object[] expectedKeys = {\n-            10040, 10042, 10041, 10035, 10037\n-        };\n-        String[] cityArray = {\"SF\", \"LA\"};\n-        frs.setFilter(new CityFilter(cityArray, 2));\n-        assertEquals(getPrimaryKeys(frs), expectedKeys);\n-    }\n-\n-    \/*\n-     * Validate that the correct rows are returned when a Predicate using\n-     * a column Label is used\n-     *\/\n-    @Test\n-    public void FilteredRowSetTest0005() throws SQLException {\n-        Object[] expectedKeys = {\n-            10040, 10042, 10041, 10035, 10037\n-        };\n-        String[] cityArray = {\"SF\", \"LA\"};\n-        frs.setFilter(new CityFilter(cityArray, \"CITY\"));\n-        assertEquals(getPrimaryKeys(frs), expectedKeys);\n-    }\n-\n-\n-    \/\/ Tests that are common but need to be disabled due to an implementation bug\n-\n-\n-    @Test(dataProvider = \"rowSetType\", enabled = false)\n-    public void commonCachedRowSetTest0043(RowSet rs) throws Exception {\n-        \/\/ Need to fix bug in FilteredRowSets\n-    }\n-\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/filteredrowset\/FilteredRowSetTests.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"},{"patch":"@@ -1,324 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset.joinrowset;\n-\n-import java.sql.SQLException;\n-import java.sql.Types;\n-import java.util.ArrayList;\n-import java.util.List;\n-import javax.sql.RowSet;\n-import javax.sql.rowset.CachedRowSet;\n-import javax.sql.rowset.JoinRowSet;\n-import javax.sql.rowset.RowSetMetaDataImpl;\n-import javax.sql.rowset.WebRowSet;\n-import static org.testng.Assert.assertEquals;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import test.rowset.webrowset.CommonWebRowSetTests;\n-\n-public class JoinRowSetTests extends CommonWebRowSetTests {\n-\n-    private final String SUPPLIERS_TABLE = \"SUPPLIERS\";\n-    \/\/ Expected COF_IDs to be found\n-    private final Object[] EXPECTED = {4, 1};\n-    \/\/ SUPPLIERS Primary Key to use to validate the joins\n-    private final int SUP_ID = 101;\n-    \/\/ Join Column between the SUPPLIERS and COFFEES table\n-    private final String JOIN_COLNAME = \"SUP_ID\";\n-    \/\/ Column index in COFFEES table which contains SUP_ID\n-    private final int COFFEES_JOIN_COLUMN_INDEX = 3;\n-    \/\/ Column index in SUPPLIERS table which contains SUP_ID\n-    private final int SUPPLIERS_JOIN_COLUMN_INDEX = 1;\n-\n-    @Override\n-    protected JoinRowSet newInstance() throws SQLException {\n-        return rsf.createJoinRowSet();\n-    }\n-\n-    \/*\n-     * Initializes the SUPPLIERS metadata\n-     *\/\n-    private void initSuppliersMetaData(CachedRowSet crs) throws SQLException {\n-        RowSetMetaDataImpl rsmd = new RowSetMetaDataImpl();\n-\n-        \/*\n-         *  CREATE TABLE SUPPLIERS (\n-         *   SUP_ID INTEGER NOT NULL,\n-         *   SUP_NAME VARCHAR(32) NOT NULL,\n-         *   STREET VARCHAR(32) NOT NULL,\n-         *   CITY VARCHAR(32) NOT NULL,\n-         *   STATE CHAR(2) NOT NULL,\n-         *   ZIP CHAR(5) NOT NULL,\n-         *   PRIMARY KEY (SUP_ID))\n-         *\/\n-        rsmd.setColumnCount(6);\n-        rsmd.setColumnName(1, \"SUP_ID\");\n-        rsmd.setColumnName(2, \"SUP_NAME\");\n-        rsmd.setColumnName(3, \"STREET\");\n-        rsmd.setColumnName(4, \"CITY\");\n-        rsmd.setColumnName(5, \"STATE\");\n-        rsmd.setColumnName(6, \"ZIP\");\n-\n-        rsmd.setColumnType(1, Types.INTEGER);\n-        rsmd.setColumnType(2, Types.VARCHAR);\n-        rsmd.setColumnType(3, Types.VARCHAR);\n-        rsmd.setColumnType(4, Types.VARCHAR);\n-        rsmd.setColumnType(5, Types.CHAR);\n-        rsmd.setColumnType(6, Types.CHAR);\n-        crs.setMetaData(rsmd);\n-        crs.setTableName(SUPPLIERS_TABLE);\n-    }\n-\n-    \/*\n-     * Add rows to SUPPLIERS table\n-     *\/\n-    protected void createSuppiersRows(RowSet rs) throws SQLException {\n-\n-        \/\/ insert into SUPPLIERS values(49, 'Superior Coffee', '1 Party Place',\n-        \/\/ 'Mendocino', 'CA', '95460')\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 49);\n-        rs.updateString(2, \"Superior Coffee\");\n-        rs.updateString(3, \"1 Party Place\");\n-        rs.updateString(4, \"Mendocino\");\n-        rs.updateString(5, \"CA\");\n-        rs.updateString(6, \"95460\");\n-        rs.insertRow();\n-\n-        \/\/ insert into SUPPLIERS values(101, 'Acme, Inc.', '99 Market Street',\n-        \/\/ 'Groundsville', 'CA', '95199')\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 101);\n-        rs.updateString(2, \"Acme, Inc.\");\n-        rs.updateString(3, \"99 Market Street\");\n-        rs.updateString(4, \"Groundsville\");\n-        rs.updateString(5, \"CA\");\n-        rs.updateString(6, \"95199\");\n-        rs.insertRow();\n-        \/\/ insert into SUPPLIERS values(150, 'The High Ground',\n-        \/\/ '100 Coffee Lane', 'Meadows', 'CA', '93966')\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 150);\n-        rs.updateString(2, \"The High Ground\");\n-        rs.updateString(3, \"100 Coffee Lane\");\n-        rs.updateString(4, \"Meadows\");\n-        rs.updateString(5, \"CA\");\n-        rs.updateString(6, \"93966\");\n-        rs.insertRow();\n-        \/\/ insert into SUPPLIERS values(456,\" 'Restaurant Supplies, Inc.',\n-        \/\/ '200 Magnolia Street', 'Meadows', 'CA', '93966')\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 456);\n-        rs.updateString(2, \"Restaurant Supplies, Inc.\");\n-        rs.updateString(3, \"200 Magnolia Stree\");\n-        rs.updateString(4, \"Meadows\");\n-        rs.updateString(5, \"CA\");\n-        rs.updateString(6, \"93966\");\n-        rs.insertRow();\n-        \/\/ insert into SUPPLIERS values(927, 'Professional Kitchen',\n-        \/\/ '300 Daisy Avenue', 'Groundsville',\" 'CA', '95199')\n-        rs.moveToInsertRow();\n-        rs.updateInt(1, 927);\n-        rs.updateString(2, \"Professional Kitchen\");\n-        rs.updateString(3, \"300 Daisy Avenue\");\n-        rs.updateString(4, \"Groundsville\");\n-        rs.updateString(5, \"CA\");\n-        rs.updateString(6, \"95199\");\n-        rs.insertRow();\n-    }\n-\n-    \/*\n-     * DataProvider used to set parameters for basic types that are supported\n-     *\/\n-    @DataProvider(name = \"createCachedRowSetsToUse\")\n-    private Object[][] createCachedRowSetsToUse() throws SQLException {\n-        CachedRowSet crs = rsf.createCachedRowSet();\n-        initCoffeesMetaData(crs);\n-        createCoffeesRows(crs);\n-        \/\/ Make sure you are not on the insertRow\n-        crs.moveToCurrentRow();\n-        CachedRowSet crs1 = rsf.createCachedRowSet();\n-        initSuppliersMetaData(crs1);\n-        createSuppiersRows(crs1);\n-        \/\/ Make sure you are not on the insertRow\n-        crs1.moveToCurrentRow();\n-        return new Object[][]{\n-            {crs, crs1}\n-        };\n-    }\n-\n-    \/*\n-     * Validate that the correct coffees are returned for SUP_ID\n-     *\/\n-    private void validateResults(final JoinRowSet jrs) throws SQLException {\n-        List<Integer> results = new ArrayList<>();\n-        jrs.beforeFirst();\n-        while (jrs.next()) {\n-            if (jrs.getInt(JOIN_COLNAME) == SUP_ID) {\n-                results.add(jrs.getInt(\"COF_ID\"));\n-            }\n-        }\n-        assertEquals(results.toArray(), EXPECTED);\n-    }\n-\n-    \/*\n-     * Join two CachedRowSets specifying a column name to join against\n-     *\/\n-    @Test(dataProvider = \"createCachedRowSetsToUse\")\n-    public void joinRowSetTests0000(CachedRowSet crs, CachedRowSet crs1)\n-            throws Exception {\n-\n-        try (JoinRowSet jrs = newInstance()) {\n-            jrs.addRowSet(crs, JOIN_COLNAME);\n-            jrs.addRowSet(crs1, JOIN_COLNAME);\n-            validateResults(jrs);\n-            crs.close();\n-            crs1.close();\n-        }\n-    }\n-\n-    \/*\n-     * Join two CachedRowSets specifying a column index to join against\n-     *\/\n-    @Test(dataProvider = \"createCachedRowSetsToUse\")\n-    public void joinRowSetTests0001(CachedRowSet crs, CachedRowSet crs1)\n-            throws Exception {\n-\n-        try (JoinRowSet jrs = newInstance()) {\n-            jrs.addRowSet(crs, COFFEES_JOIN_COLUMN_INDEX);\n-            jrs.addRowSet(crs1, SUPPLIERS_JOIN_COLUMN_INDEX);\n-            validateResults(jrs);\n-            crs.close();\n-            crs1.close();\n-        }\n-    }\n-\n-    \/*\n-     * Join two CachedRowSets specifying a column name to join against\n-     *\/\n-    @Test(dataProvider = \"createCachedRowSetsToUse\")\n-    public void joinRowSetTests0002(CachedRowSet crs, CachedRowSet crs1)\n-            throws Exception {\n-\n-        try (JoinRowSet jrs = newInstance()) {\n-            RowSet[] rowsets = {crs, crs1};\n-            String[] joinCols = {JOIN_COLNAME, JOIN_COLNAME};\n-            jrs.addRowSet(rowsets, joinCols);\n-            validateResults(jrs);\n-            crs.close();\n-            crs1.close();\n-        }\n-    }\n-\n-    \/*\n-     * Join two CachedRowSets specifying a column index to join against\n-     *\/\n-    @Test(dataProvider = \"createCachedRowSetsToUse\")\n-    public void joinRowSetTests0003(CachedRowSet crs, CachedRowSet crs1)\n-            throws Exception {\n-\n-        try (JoinRowSet jrs = newInstance()) {\n-            RowSet[] rowsets = {crs, crs1};\n-            int[] joinCols = {COFFEES_JOIN_COLUMN_INDEX,\n-                SUPPLIERS_JOIN_COLUMN_INDEX};\n-            jrs.addRowSet(rowsets, joinCols);\n-            validateResults(jrs);\n-            crs.close();\n-            crs1.close();\n-        }\n-    }\n-\n-    \/*\n-     * Join two CachedRowSets specifying a column name to join against\n-     *\/\n-    @Test(dataProvider = \"createCachedRowSetsToUse\")\n-    public void joinRowSetTests0005(CachedRowSet crs, CachedRowSet crs1)\n-            throws Exception {\n-\n-        try (JoinRowSet jrs = newInstance()) {\n-            crs.setMatchColumn(JOIN_COLNAME);\n-            crs1.setMatchColumn(JOIN_COLNAME);\n-            jrs.addRowSet(crs);\n-            jrs.addRowSet(crs1);\n-            validateResults(jrs);\n-            crs.close();\n-            crs1.close();\n-        }\n-    }\n-\n-    \/*\n-     * Join two CachedRowSets specifying a column index to join against\n-     *\/\n-    @Test(dataProvider = \"createCachedRowSetsToUse\")\n-    public void joinRowSetTests0006(CachedRowSet crs, CachedRowSet crs1)\n-            throws Exception {\n-\n-        try (JoinRowSet jrs = newInstance()) {\n-            crs.setMatchColumn(COFFEES_JOIN_COLUMN_INDEX);\n-            crs1.setMatchColumn(SUPPLIERS_JOIN_COLUMN_INDEX);\n-\n-            jrs.addRowSet(crs);\n-            jrs.addRowSet(crs1);\n-            validateResults(jrs);\n-            crs.close();\n-            crs1.close();\n-        }\n-    }\n-\n-    \/\/ Disabled tests due to bugs in JoinRowSet\n-    @Test(dataProvider = \"rowSetType\", enabled = false)\n-    public void commonCachedRowSetTest0004(CachedRowSet rs) throws Exception {\n-    }\n-\n-    @Test(dataProvider = \"rowSetType\", enabled = false)\n-    public void commonCachedRowSetTest0005(CachedRowSet rs) throws Exception {\n-    }\n-\n-    @Test(dataProvider = \"rowSetType\", enabled = false)\n-    public void commonCachedRowSetTest0008(CachedRowSet rs) throws Exception {\n-    }\n-\n-    @Test(dataProvider = \"rowSetType\", enabled = false)\n-    public void commonCachedRowSetTest0026(CachedRowSet rs) throws Exception {\n-    }\n-\n-    @Test(dataProvider = \"rowSetType\", enabled = false)\n-    public void commonCachedRowSetTest0027(CachedRowSet rs) throws Exception {\n-    }\n-\n-    @Test(dataProvider = \"rowSetType\", enabled = false)\n-    public void commonCachedRowSetTest0053(CachedRowSet rs) throws Exception {\n-    }\n-\n-    @Test(dataProvider = \"rowSetType\", enabled = false)\n-    public void commonCachedRowSetTest0054(CachedRowSet rs) throws Exception {\n-    }\n-\n-    @Test(dataProvider = \"rowSetType\", enabled = false)\n-    public void commonCachedRowSetTest0055(CachedRowSet rs) throws Exception {\n-    }\n-\n-    @Test(dataProvider = \"rowSetType\")\n-    public void WebRowSetTest0009(WebRowSet wrs1) throws Exception {\n-    }\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/joinrowset\/JoinRowSetTests.java","additions":0,"deletions":324,"binary":false,"changes":324,"status":"deleted"},{"patch":"@@ -1,236 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset.serial;\n-\n-import java.sql.Array;\n-import java.sql.SQLException;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Map;\n-import javax.sql.rowset.serial.SerialArray;\n-import javax.sql.rowset.serial.SerialException;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubArray;\n-\n-public class SerialArrayTests extends BaseTest {\n-\n-    private Object[] coffees;\n-    private final String sqlType = \"VARCHAR\";\n-    private Array a;\n-    private Map<String, Class<?>> map;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        coffees = new Object[]{\"Espresso\", \"Colombian\", \"French Roast\",\n-            \"Cappuccino\"};\n-        a = new StubArray(sqlType, coffees);\n-        map = new HashMap<>();\n-    }\n-\n-    \/*\n-     * Validate a SerialArray can be created from an Array\n-     *\/\n-    @Test\n-    public void test01() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-    }\n-\n-    \/*\n-     * Validate a SQLException is thrown if the map is null\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test02() throws Exception {\n-        SerialArray sa = new SerialArray(a, null);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown when getResultSet() is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test03() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        sa.getResultSet();\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown when getResultSet() is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test04() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        sa.getResultSet(null);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown when getResultSet() is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test05() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        sa.getResultSet(1, 1);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown when getResultSet() is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test06() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        sa.getResultSet(1, 1, null);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown when  getArray() is invoked after\n-     * free() is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test07() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        sa.free();\n-        sa.getArray();\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown when  getArray() is invoked after\n-     * free() is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test08() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        sa.free();\n-        sa.getArray(map);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown when  getArray() is invoked after\n-     * free() is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test09() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        sa.free();\n-        sa.getArray(1, 1, map);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown when  getArray() is invoked after\n-     * free() is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test10() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        sa.free();\n-        sa.getArray(1, 1);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown when  getBaseType() is invoked after\n-     * free() is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test11() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        sa.free();\n-        sa.getBaseType();\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown when  getBaseTypeName() is invoked after\n-     * free() is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test12() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        sa.free();\n-        sa.getBaseTypeName();\n-    }\n-\n-    \/*\n-     * Validate getArray() returns the same Object[] used to create the\n-     * SerialArray\n-     *\/\n-    @Test\n-    public void test13() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        Object[] o = (Object[]) sa.getArray();\n-        assertTrue(Arrays.equals(o, coffees));\n-    }\n-\n-    \/*\n-     * Validate getArray() returns the same Object[] used to create the\n-     * SerialArray\n-     *\/\n-    @Test\n-    public void test14() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        Object[] o = (Object[]) sa.getArray(map);\n-        assertTrue(Arrays.equals(o, coffees));\n-    }\n-\n-    \/*\n-     * Validate getArray() returns the same Object[] used to create the\n-     * SerialArray\n-     *\/\n-    @Test\n-    public void test15() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        Object[] o = (Object[]) sa.getArray(1, 2);\n-        assertTrue(Arrays.equals(o, Arrays.copyOfRange(coffees, 1, 3)));\n-    }\n-\n-    \/*\n-     * Validate getArray() returns the same Object[] used to create the\n-     * SerialArray\n-     *\/\n-    @Test\n-    public void test16() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        Object[] o = (Object[]) sa.getArray(1, 2, map);\n-        assertTrue(Arrays.equals(o, Arrays.copyOfRange(coffees, 1, 3)));\n-    }\n-\n-    \/*\n-     * clone() a SerialArray and check that it is equal to the\n-     * object it was cloned from\n-     *\/\n-    @Test\n-    public void test17() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        SerialArray sa1 = (SerialArray) sa.clone();\n-        assertTrue(sa.equals(sa1));\n-    }\n-\n-    \/*\n-     * Validate that a SerialArray that is serialized & deserialized is equal to\n-     * itself\n-     *\/\n-    @Test\n-    public void test18() throws Exception {\n-        SerialArray sa = new SerialArray(a);\n-        SerialArray sa1 = serializeDeserializeObject(sa);\n-        assertTrue(sa.equals(sa1));\n-    }\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialArrayTests.java","additions":0,"deletions":236,"binary":false,"changes":236,"status":"deleted"},{"patch":"@@ -1,473 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset.serial;\n-\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.util.Arrays;\n-import javax.sql.rowset.serial.SerialBlob;\n-import javax.sql.rowset.serial.SerialException;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubBlob;\n-\n-public class SerialBlobTests extends BaseTest {\n-\n-    \/\/ byte[] used to populate SerialBlob\n-    private byte[] bytes = new byte[]{1, 2, 3, 4, 5};\n-\n-    \/*\n-     * Validate calling free() does not throw an Exception\n-     *\/\n-    @Test\n-    public void test() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-    }\n-\n-    \/*\n-     * Validate calling getBinaryStream() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test01() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-        sb.getBinaryStream();\n-    }\n-\n-    \/*\n-     * Validate calling getBinaryStream() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test02() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-        sb.getBinaryStream(1, 5);\n-    }\n-\n-    \/*\n-     * Validate calling getBytes() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test03() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-        sb.getBytes(1, 1);\n-    }\n-\n-    \/*\n-     * Validate calling getLength() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test04() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-        sb.length();\n-    }\n-\n-    \/*\n-     * Validate calling position() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test05() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-        sb.position(new byte[5], 1);\n-    }\n-\n-    \/*\n-     * Validate calling position() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test06() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-        sb.position(new StubBlob(), 1);\n-    }\n-\n-    \/*\n-     * Validate calling free() after calling setBinaryStream() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test07() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-        sb.setBinaryStream(5);\n-    }\n-\n-    \/*\n-     * Validate calling free() after calling setBytes() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test08() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-        sb.setBytes(1, new byte[5]);\n-    }\n-\n-    \/*\n-     * Validate calling setBytes() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test09() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-        sb.setBytes(1, new byte[10], 0, 5);\n-    }\n-\n-    \/*\n-     * Validate calling truncate() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test10() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        sb.free();\n-        sb.truncate(1);\n-    }\n-\n-    \/*\n-     * Validate getBinaryStream returns the correct bytes\n-     *\/\n-    @Test\n-    public void test11() throws Exception {\n-        byte[] expected = new byte[]{1, 2, 3};\n-        SerialBlob sb = new SerialBlob(bytes);\n-        InputStream is = sb.getBinaryStream(1, 3);\n-        for (byte b : expected) {\n-            byte val = (byte) is.read();\n-            assertTrue(b == val, val + \" does not match \" + b);\n-        }\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if pos < 0 for getBinaryStream\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test12() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        InputStream is = sb.getBinaryStream(-1, 3);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if pos = 0 for getBinaryStream\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test13() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        InputStream is = sb.getBinaryStream(0, 3);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if len > the length of the stream\n-     * for getBinaryStream\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test14() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        InputStream is = sb.getBinaryStream(0, 3);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if length < 1\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test15() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        InputStream is = sb.getBinaryStream(1, 0);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if length > byte array length\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test16() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        InputStream is = sb.getBinaryStream(1, 6);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if pos > byte array length\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test17() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        InputStream is = sb.getBinaryStream(bytes.length + 2, 6);\n-    }\n-\n-    \/*\n-     * Validate that a cloned SerializedBlob bytes match the original\n-     *\/\n-    @Test\n-    public void test18() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        SerialBlob sb2 = (SerialBlob) sb.clone();\n-        assertTrue(\n-                Arrays.equals(sb.getBytes(1, (int) sb.length()),\n-                        sb2.getBytes(1, (int) sb2.length())),\n-                \"arrays do not match \");\n-    }\n-\n-    \/*\n-     * Test clone after free has been called that the clone is not accessible\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test19() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        sb.free();\n-        SerialBlob sb2 = (SerialBlob) sb.clone();\n-        InputStream is = sb2.getBinaryStream(1, 3);\n-    }\n-\n-    \/*\n-     * Validate that a SerialBlob that is serialized & deserialized is equal to\n-     * itself\n-     *\/\n-    @Test\n-    public void test20() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        SerialBlob sb2 = serializeDeserializeObject(sb);\n-        assertTrue(sb.equals(sb2), \"SerialBlob not equal\");\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if byte[] is used to\n-     * create the SeriablBlob and setBinaryStream is called\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test21() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        sb.setBinaryStream(3);\n-    }\n-\n-    \/*\n-     * Validate that setBytes will properly write a set of bytes to the\n-     * specified location in the SerialBlob and the correct count is returned\n-     * for bytes written\n-     *\/\n-    @Test\n-    public void test22() throws Exception {\n-        byte[] diff = new byte[]{7, 8, 9};\n-        byte[] expected = new byte[]{1, 7, 8, 9, 5};\n-        SerialBlob sb = new SerialBlob(bytes);\n-        int written = sb.setBytes(2, diff);\n-        assertEquals(written, diff.length);\n-        assertTrue(\n-                Arrays.equals(sb.getBytes(1, (int) sb.length()),\n-                        expected),\n-                \"arrays do not match \");\n-    }\n-\n-    \/*\n-     * Validate that setBytes will properly write a set of bytes to the\n-     * specified location in the SerialBlob and the correct count is returned\n-     * for bytes written\n-     *\/\n-    @Test\n-    public void test23() throws Exception {\n-        int bytesToWrite = 3;\n-        byte[] diff = new byte[]{7, 8, 9, 0};\n-        byte[] expected = new byte[]{1, 8, 9, 0, 5};\n-        SerialBlob sb = new SerialBlob(bytes);\n-        int written = sb.setBytes(2, diff, 1, bytesToWrite);\n-        assertEquals(written, bytesToWrite);\n-        assertTrue(\n-                Arrays.equals(sb.getBytes(1, (int) sb.length()),\n-                        expected),\n-                \"arrays do not match \");\n-    }\n-\n-    \/*\n-     * Validate that truncate reduces the length of the SerlizedBlob to the\n-     * specified value\n-     *\/\n-    @Test\n-    public void test24() throws Exception {\n-        SerialBlob sb = new SerialBlob(bytes);\n-        sb.truncate(0);\n-        assertTrue(sb.length() == 0);\n-        sb = new SerialBlob(bytes);\n-        sb.truncate(3);\n-        assertTrue(sb.length() == 3);\n-    }\n-\n-    \/*\n-     * Validate getBinaryStream returns the correct bytes\n-     *\/\n-    @Test\n-    public void test25() throws Exception {\n-        byte[] expected = bytes;\n-        SerialBlob sb = new SerialBlob(bytes);\n-        InputStream is = sb.getBinaryStream();\n-        for (byte b : expected) {\n-            byte val = (byte) is.read();\n-            assertTrue(b == val, val + \" does not match \" + b);\n-        }\n-    }\n-\n-    \/*\n-     * Validate setBinaryStream returns an OutputStream when passed a Blob\n-     *\/\n-    @Test\n-    public void test26() throws Exception {\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        OutputStream os = sb.setBinaryStream(0);\n-        assertTrue(os != null);\n-    }\n-\n-    \/*\n-     * Validate that position returns the correct starting location for a\n-     * pattern in the SerialBlob\n-     *\/\n-    @Test\n-    public void test27() throws Exception {\n-        long expectedPos = 3; \/\/ starting offset is 1 vs 0\n-        byte[] pattern = new byte[]{3, 4};\n-        SerialBlob sb = new SerialBlob(bytes);\n-        long pos = sb.position(pattern, 1);\n-        assertEquals(pos, expectedPos);\n-    }\n-\n-    \/*\n-     * Validate that position returns the correct starting location for a\n-     * pattern in the SerialBlob\n-     *\/\n-    @Test\n-    public void test28() throws Exception {\n-        long expectedPos = 3; \/\/ starting offset is 1 vs 0\n-        byte[] pattern = new byte[]{3, 4, 5};\n-        SerialBlob sb = new SerialBlob(bytes);\n-        long pos = sb.position(pattern, 2);\n-        assertEquals(pos, expectedPos);\n-    }\n-\n-    \/*\n-     * Validate that position returns the correct starting location for a\n-     * pattern in the SerialBlob\n-     *\/\n-    @Test\n-    public void test29() throws Exception {\n-        long expectedPos = 2; \/\/ starting offset is 1 vs 0\n-        byte[] pattern = new byte[]{4, 6};\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        long pos = sb.position(pattern, 1);\n-        assertEquals(pos, expectedPos);\n-    }\n-\n-    \/*\n-     * Validate that position returns the correct starting location for a\n-     * pattern in the SerialBlob\n-     *\/\n-    @Test\n-    public void test30() throws Exception {\n-        long expectedPos = 3; \/\/ starting offset is 1 vs 0\n-        byte[] pattern = new byte[]{6, 8};\n-        SerialBlob sb = new SerialBlob(new StubBlob());\n-        long pos = sb.position(pattern, 2);\n-        assertEquals(pos, expectedPos);\n-    }\n-\n-    \/*\n-     * Validate that setBytes will properly write a set of bytes to the\n-     * specified location in the SerialBlob and the correct count is returned\n-     * for bytes written (writePos - 1 + diff.length > sb.length() &&\n-     * writePos - 1 + bytesToWrite <= sb.length())\n-     *\/\n-    @Test\n-    public void test31() throws Exception {\n-        int writePos = 5;\n-        int bytesToWrite = 1;\n-        byte[] diff = new byte[]{7, 8, 9};\n-        byte[] expected = new byte[]{1, 2, 3, 4, 7};\n-        SerialBlob sb = new SerialBlob(bytes);\n-        int written = sb.setBytes(writePos, diff, 0, bytesToWrite);\n-        assertEquals(written, bytesToWrite);\n-        assertEquals(sb.getBytes(1, (int) sb.length()), expected);\n-    }\n-\n-    \/*\n-     * Validate that setBytes will properly write a set of bytes to the\n-     * specified location in the SerialBlob and the correct count is returned\n-     * for bytes written (writePos - 1 + bytesToWrite > sb.length())\n-     *\/\n-    @Test\n-    public void test32() throws Exception {\n-        int writePos = 5;\n-        int bytesToWrite = 2;\n-        byte[] diff = new byte[]{7, 8, 9, 0};\n-        byte[] expected = new byte[]{1, 2, 3, 4, 8, 9};\n-        SerialBlob sb = new SerialBlob(bytes);\n-        int written = sb.setBytes(writePos, diff, 1, bytesToWrite);\n-        assertEquals(written, bytesToWrite);\n-        assertEquals(sb.getBytes(1, (int) sb.length()), expected);\n-    }\n-\n-    \/*\n-     * Validate that setBytes will properly write a set of bytes to the\n-     * specified location in the SerialBlob and the correct count is returned\n-     * for bytes written (writePos == sb.length() + 1)\n-     *\/\n-    @Test\n-    public void test33() throws Exception {\n-        int writePos = 6;\n-        int bytesToWrite = 3;\n-        byte[] diff = new byte[]{7, 8, 9, 0};\n-        byte[] expected = new byte[]{1, 2, 3, 4, 5, 8, 9, 0};\n-        SerialBlob sb = new SerialBlob(bytes);\n-        int written = sb.setBytes(writePos, diff, 1, bytesToWrite);\n-        assertEquals(written, bytesToWrite);\n-        assertEquals(sb.getBytes(1, (int) sb.length()), expected);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if length < 0 for setBytes\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test34() throws Exception {\n-        int length = -1;\n-        SerialBlob sb = new SerialBlob(bytes);\n-        int written = sb.setBytes(1, new byte[]{1}, 1, length);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if length + offset >\n-     * Integer.MAX_VALUE for setBytes\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test35() throws Exception {\n-        int offset = 1;\n-        int length = Integer.MAX_VALUE;\n-        SerialBlob sb = new SerialBlob(bytes);\n-        int written = sb.setBytes(1, new byte[]{1, 2, 3}, offset, length);\n-    }\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialBlobTests.java","additions":0,"deletions":473,"binary":false,"changes":473,"status":"deleted"},{"patch":"@@ -1,572 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset.serial;\n-\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.Reader;\n-import java.io.Writer;\n-import javax.sql.rowset.serial.SerialClob;\n-import javax.sql.rowset.serial.SerialException;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubClob;\n-\n-public class SerialClobTests extends BaseTest {\n-\n-    \/\/ char[] used to populate SerialClob\n-    private final char[] chars;\n-\n-    public SerialClobTests() {\n-        this.chars = new char[]{'h', 'e', 'l', 'l', 'o', ' ', 'w',\n-            'o', 'r', 'l', 'd'};\n-    }\n-\n-    \/*\n-     * Validate calling free() does not throw an Exception\n-     *\/\n-    @Test\n-    public void test() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-    }\n-\n-    \/*\n-     * Validate calling getCharacterStream() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test01() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.getCharacterStream();\n-    }\n-\n-    \/*\n-     * Validate calling getCharacterStream() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test02() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        sc.free();\n-        sc.getCharacterStream();\n-    }\n-\n-    \/*\n-     * Validate calling getCharacterStream() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test03() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.getCharacterStream(1, 5);\n-    }\n-\n-    \/*\n-     * Validate calling getSubString() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test04() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.getSubString(1, 1);\n-    }\n-\n-    \/*\n-     * Validate calling truncate() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test05() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.truncate(1);\n-    }\n-\n-    \/*\n-     * Validate calling getAsciiStream() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test06() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.getAsciiStream();\n-    }\n-\n-    \/*\n-     * Validate calling length() after calling free() throws an SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test07() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.length();\n-    }\n-\n-    \/*\n-     * Validate calling position() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test08() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.position(\"hello\", 1);\n-    }\n-\n-    \/*\n-     * Validate calling position() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test09() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.position(new StubClob(), 1);\n-    }\n-\n-    \/*\n-     * Validate calling setAsciiStream() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test10() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.setAsciiStream(5);\n-    }\n-\n-    \/*\n-     * Validate calling setCharacterStream() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test11() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.setCharacterStream(5);\n-    }\n-\n-    \/*\n-     * Validate calling setString() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test12() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.setString(1, \"hello\");\n-    }\n-\n-    \/*\n-     * Validate calling setString() after calling free() throws an\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test13() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.free();\n-        sc.setString(1, \"hello\", 0, 5);\n-    }\n-\n-    \/*\n-     * Test that SerialException is thrown if pos < 0 on a call to\n-     * getCharacterStream\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test14() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        sc.getCharacterStream(-1, 5);\n-    }\n-\n-    \/*\n-     * Test that SerialException is thrown if pos = 0 on a call to\n-     * getCharacterStream\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test15() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        sc.getCharacterStream(0, 5);\n-    }\n-\n-    \/*\n-     * Test that SerialException is thrown if pos = 0 on a call to\n-     * getCharacterStream\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test16() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        sc.getCharacterStream(1, 100);\n-    }\n-\n-    \/*\n-     * Test that SerialException is thrown if length = 0 on a call to\n-     * getCharacterStream\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test17() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        sc.getCharacterStream(1, 0);\n-    }\n-\n-    \/*\n-     * Test that SerialException is thrown if pos > length on a call to\n-     * getCharacterStream\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test18() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        sc.getCharacterStream(100, 5);\n-    }\n-\n-    \/*\n-     * Clone a SerialClob and check that it is equal to itself\n-     *\/\n-    @Test\n-    public void test19() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        SerialClob sc1 = (SerialClob) sc.clone();\n-        assertTrue(sc.equals(sc1), \"SerialClobs not equal\");\n-    }\n-\n-    \/*\n-     * Validate that a getAsciiStream() returns an InputStream when a Clob is\n-     * used to create the SerialClob\n-     *\/\n-    @Test\n-    public void test20() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        InputStream is = sc.getAsciiStream();\n-        assertTrue(is != null);\n-    }\n-\n-    \/*\n-     * Validate that a getCharacterStream() returns an Reader when a Clob is\n-     * used to create the SerialClob\n-     *\/\n-    @Test\n-    public void test21() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        Reader is = sc.getCharacterStream();\n-        assertTrue(is != null);\n-    }\n-\n-    \/*\n-     * Validate that a getCharacterStream() returns an Reader when a char[] is\n-     * used to create the SerialClob\n-     *\/\n-    @Test\n-    public void test22() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        Reader is = sc.getCharacterStream();\n-        assertTrue(is != null);\n-    }\n-\n-    \/*\n-     * Validate that a getSubString() returns the correct value when a char[] is\n-     * used to create the SerialClob\n-     *\/\n-    @Test\n-    public void test23() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        String expected = \"world\";\n-        assertEquals(expected, sc.getSubString(7, 5));\n-    }\n-\n-    \/*\n-     * Validate that a getSubString() returns the correct value when a Clob is\n-     * used to create the SerialClob\n-     *\/\n-    @Test\n-    public void test24() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        String expected = \"test string\";\n-        assertEquals(expected, sc.getSubString(5, 11));\n-    }\n-\n-    \/*\n-     * Validate that position() returns the correct value when a Clob is used to\n-     * create the SerialClob\n-     *\/\n-    @Test\n-    public void test25() throws Exception {\n-        long expectedPos = 5;\n-        SerialClob sc = new SerialClob(new StubClob());\n-        String expected = \"test string\";\n-        long pos = sc.position(expected, 1);\n-        assertEquals(expectedPos, pos);\n-    }\n-\n-    \/*\n-     * Validate that position returned is -1 when the search string is not\n-     * part of the SerialClob\n-     *\/\n-    @Test\n-    public void test26() throws Exception {\n-        long expectedPos = -1;\n-        SerialClob sc = new SerialClob(chars);\n-        String expected = \"test string\";\n-        long pos = sc.position(expected, 1);\n-        assertEquals(expectedPos, pos);\n-    }\n-\n-    \/*\n-     * Validate that position() returned is -1 when the search string is not\n-     * part of the SerialClob\n-     *\/\n-    @Test\n-    public void test27() throws Exception {\n-        long expectedPos = -1;\n-        SerialClob sc = new SerialClob(new StubClob());\n-        String expected = \"I am Batman\";\n-        long pos = sc.position(expected, 2);\n-        assertEquals(expectedPos, pos);\n-    }\n-\n-    \/*\n-     * Validate that position() returns the correct value when a char[] is used\n-     * to create the SerialClob\n-     *\/\n-    @Test\n-    public void test28() throws Exception {\n-        long expectedPos = 2;\n-        SerialClob sc = new SerialClob(chars);\n-        String expected = \"ello\";\n-        long pos = sc.position(expected, 1);\n-        assertEquals(expectedPos, pos);\n-    }\n-\n-    \/*\n-     * Validate that position() returns the correct value when a SerialClob is\n-     * used for the search argument\n-     *\/\n-    @Test\n-    public void test29() throws Exception {\n-        long expectedPos = 21;\n-        String expected = \"Batman\";\n-        String buf = \"I am Joker, not the Batman, hahaha\";\n-        SerialClob sc = new SerialClob(expected.toCharArray());\n-        SerialClob sc1 = new SerialClob(buf.toCharArray());\n-        long pos = sc1.position(sc, 1);\n-        assertEquals(expectedPos, pos);\n-    }\n-\n-    \/*\n-     * Validate that position() returns the correct value when a SerialClob is\n-     * used for the search argument\n-     *\/\n-    @Test\n-    public void test30() throws Exception {\n-        long expectedPos = 17;\n-        String expected = \"012\";\n-        SerialClob sc = new SerialClob(expected.toCharArray());\n-        SerialClob sc1 = new SerialClob(new StubClob());\n-        long pos = sc1.position(sc, 1);\n-        assertEquals(expectedPos, pos);\n-    }\n-\n-    \/*\n-     * Check that setString() updates the appropriate characters in the\n-     * SerialClob\n-     *\/\n-    @Test\n-    public void test31() throws Exception {\n-        String val = \"Hello, I am Bruce Wayne\";\n-        String val1 = \"the Batman!\";\n-        String expected = \"Hello, I am the Batman!\";\n-        SerialClob sc = new SerialClob(val.toCharArray());\n-        int written = sc.setString(13, val1);\n-        assertEquals(val1.length(), written);\n-        assertTrue(expected.equals(sc.getSubString(1, (int) sc.length())));\n-    }\n-\n-    \/*\n-     * Check that setString() updates the appropriate characters in the\n-     * SerialClob (writePos - 1 + val1.length() - offset > sc.length() &&\n-     * writePos - 1 + expectedWritten <= sc.length())\n-     *\/\n-    @Test\n-    public void test32() throws Exception {\n-        int writePos = 10;\n-        int offset = 7;\n-        int expectedWritten = 9;\n-        String val = \"Hi, I am Catwoman!!!!!!\";\n-        String val1 = \"Hahaha the Joker, who are you?!\";\n-        String expected = \"Hi, I am the Joker!!!!!\";\n-        SerialClob sc = new SerialClob(val.toCharArray());\n-        int written = sc.setString(writePos, val1, offset, expectedWritten);\n-        assertEquals(written, expectedWritten);\n-        assertEquals(sc.getSubString(1, (int) sc.length()), expected);\n-    }\n-\n-    \/*\n-     * Check that setCharacterStream() returns a non-null Writer for an\n-     * SerialClob created from a Clob\n-     *\/\n-    @Test\n-    public void test33() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        Writer w = sc.setCharacterStream(1);\n-        assertTrue(w != null);\n-    }\n-\n-    \/*\n-     * Check that setAsciiStream() returns a non-null OutputStream for an SerialClob\n-     * created from a Clob\n-     *\/\n-    @Test\n-    public void test34() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        OutputStream os = sc.setAsciiStream(1);\n-        assertTrue(os != null);\n-    }\n-\n-    \/*\n-     * Check that truncate() truncates the length of the SerialClob to the\n-     * specified size\n-     *\/\n-    @Test\n-    public void test35() throws Exception {\n-        SerialClob sc = new SerialClob(new StubClob());\n-        sc.truncate(0);\n-        assertTrue(sc.length() == 0);\n-        sc = new SerialClob(chars);\n-        sc.truncate(5);\n-        assertTrue(sc.length() == 5);\n-    }\n-\n-    \/*\n-     * Check that getCharacterStream() returns a Reader and that the char[] that\n-     * was specified to create the SerialClob can be returned via the Reader\n-     *\/\n-    @Test\n-    public void test36() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        Reader r = sc.getCharacterStream();\n-        for (char c : chars) {\n-            char val = (char) r.read();\n-            assertTrue(c == val, val + \" does not match \" + c);\n-        }\n-    }\n-\n-    \/*\n-     * Check that getCharacterStream() returns a Reader and that the char[] that\n-     * was specified to create the SerialClob can be returned via the Reader\n-     *\/\n-    @Test(enabled = false)\n-    public void test37() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        String expected = \"ello w\";\n-        Reader r = sc.getCharacterStream(2, 6);\n-        for (char c : expected.toCharArray()) {\n-            char val = (char) r.read();\n-            assertTrue(c == val, val + \" does not match \" + c);\n-        }\n-    }\n-\n-    \/*\n-     * Validate that a SerialClob that is serialized & deserialized is equal to\n-     * itself\n-     *\/\n-    @Test\n-    public void test38() throws Exception {\n-        SerialClob sc = new SerialClob(chars);\n-        SerialClob sc2 = serializeDeserializeObject(sc);\n-        assertTrue(sc.equals(sc2), \"SerialClobs not equal\");\n-    }\n-\n-    \/*\n-     * Check calling setString() with offset > val1.length() throws a\n-     * SerialException\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test39() throws Exception {\n-        String val1 = \"hello\";\n-        int offset = val1.length() + 1;\n-        SerialClob sc = new SerialClob(chars);\n-        sc.setString(1, val1, offset, 0);\n-    }\n-\n-    \/*\n-     * Check that setString() updates the appropriate characters in the\n-     * SerialClob (writePos - 1 + expectedWritten > sc.length())\n-     *\/\n-    @Test\n-    public void test40() throws Exception {\n-        int writePos = 13;\n-        int offset = 7;\n-        int expectedWritten = 24;\n-        String val = \"Hello, I am Bruce Wayne\";\n-        String val1 = \"Hahaha the Joker, who are you?!\";\n-        String expected = \"Hello, I am the Joker, who are you?!\";\n-        SerialClob sc = new SerialClob(val.toCharArray());\n-        int written = sc.setString(writePos, val1, offset, expectedWritten);\n-        assertEquals(written, expectedWritten);\n-        assertEquals(sc.getSubString(1, (int) sc.length()), expected);\n-    }\n-\n-    \/*\n-     * Check that setString() updates the appropriate characters in the\n-     * SerialClob (writePos == sc.length() + 1)\n-     *\/\n-    @Test\n-    public void test41() throws Exception {\n-        int writePos = 10;\n-        int offset = 7;\n-        int expectedWritten = 10;\n-        String val = \"Hi, I am \";\n-        String val1 = \"Hahaha the Joker!\";\n-        String expected = \"Hi, I am the Joker!\";\n-        SerialClob sc = new SerialClob(val.toCharArray());\n-        int written = sc.setString(writePos, val1, offset, expectedWritten);\n-        assertEquals(written, expectedWritten);\n-        assertEquals(sc.getSubString(1, (int) sc.length()), expected);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if length < 0 for setString\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test42() throws Exception {\n-        int length = -1;\n-        SerialClob sc = new SerialClob(chars);\n-        int written = sc.setString(1, \"hello\", 1, length);\n-    }\n-\n-    \/*\n-     * Validate a SerialException is thrown if length + offset >\n-     * Integer.MAX_VALUE for setString\n-     *\/\n-    @Test(expectedExceptions = SerialException.class)\n-    public void test43() throws Exception {\n-        int offset = 1;\n-        int length = Integer.MAX_VALUE;\n-        SerialClob sc = new SerialClob(chars);\n-        int written = sc.setString(1, \"hello\", offset, length);\n-    }\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialClobTests.java","additions":0,"deletions":572,"binary":false,"changes":572,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset.serial;\n-\n-import java.lang.reflect.Field;\n-import java.util.Arrays;\n-import javax.sql.rowset.RowSetMetaDataImpl;\n-import javax.sql.rowset.serial.SerialException;\n-import javax.sql.rowset.serial.SerialJavaObject;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-\n-public class SerialJavaObjectTests extends BaseTest {\n-\n-    \/*\n-     * Validate that an NPE is thrown when null is specified to create\n-     * the SerialJavaObject\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test() throws Exception {\n-        SerialJavaObject sjo = new SerialJavaObject(null);\n-    }\n-\n-    \/*\n-     * Validate that a SerialException is thrown when the object specified\n-     * contains public static fields\n-     *\/\n-    @Test(expectedExceptions = SerialException.class, enabled = false)\n-    public void test01() throws Exception {\n-        SerialJavaObject sjo = new SerialJavaObject(new RowSetMetaDataImpl());\n-    }\n-\n-    \/*\n-     * Validate that an getFields()s returns the same Field[] for the object\n-     * used to create the SerialJavaObject\n-     *\/\n-    @Test\n-    public void test02() throws Exception {\n-        SerialException e = new SerialException();\n-        SerialJavaObject sjo = new SerialJavaObject(e);\n-        Field[] f = e.getClass().getFields();\n-        assertTrue(Arrays.equals(f, sjo.getFields()));\n-        assertFalse(Arrays.equals(\"hello\".getClass().getFields(),\n-                sjo.getFields()));\n-    }\n-\n-    \/*\n-     * clone() a SerialJavaObject and check that it is equal to the\n-     * object it was cloned from\n-     *\/\n-    @Test\n-    public void test03() throws Exception {\n-        SerialJavaObject sjo = new SerialJavaObject(\"Hello\");\n-        SerialJavaObject sjo2 = (SerialJavaObject) sjo.clone();\n-        assertTrue(sjo.equals(sjo2));\n-    }\n-\n-    \/**\n-     * Validate that a SerialJavaObject that is serialized & deserialized is\n-     * equal to itself\n-     *\/\n-    @Test\n-    public void test04() throws Exception {\n-        SerialJavaObject sjo = new SerialJavaObject(\"Hello\");\n-        SerialJavaObject sjo2 = serializeDeserializeObject(sjo);\n-        assertTrue(sjo.equals(sjo2));\n-    }\n-\n-    \/*\n-     * Validate that a getObject() returns an object used to create the\n-     * SerialJavaObject\n-     *\/\n-    @Test\n-    public void test05() throws Exception {\n-        String s = \"Hello world\";\n-        SerialJavaObject sjo = new SerialJavaObject(s);\n-        assertTrue(s.equals(sjo.getObject()));\n-    }\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialJavaObjectTests.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset.serial;\n-\n-import java.sql.Ref;\n-import java.sql.SQLException;\n-import java.util.HashMap;\n-import java.util.Map;\n-import javax.sql.rowset.serial.SerialRef;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubRef;\n-import util.SuperHero;\n-\n-public class SerialRefTests extends BaseTest {\n-\n-    private static Map<String, Class<?>> map = new HashMap<>();\n-    private Ref ref;\n-    private final String sqlType = \"SUPERHERO\";\n-    private SuperHero hero;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        map.put(sqlType, Class.forName(\"util.SuperHero\"));\n-        hero = new SuperHero(sqlType, \"Bruce\", \"Wayne\", 1939, \"Batman\");\n-        ref = new StubRef(sqlType, hero);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException() is thrown if the Ref is null\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test01() throws Exception {\n-        SerialRef sr = new SerialRef(null);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException() is thrown if the typeName is null in the\n-     * Ref used to create the SerialRef\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test02() throws Exception {\n-        SerialRef sr = new SerialRef(new StubRef(null, hero));\n-    }\n-\n-    \/*\n-     * Validate that getBaseTypeName() returns the same SQLType specified\n-     * to create the Ref\n-     *\/\n-    @Test\n-    public void test03() throws Exception {\n-        SerialRef sr = new SerialRef(ref);\n-        assertEquals(sr.getBaseTypeName(), sqlType);\n-    }\n-\n-    \/*\n-     * Validate that getObject() returns the same object used to create the Ref\n-     *\/\n-    @Test\n-    public void test04() throws Exception {\n-        SerialRef sr = new SerialRef(ref);\n-        assertTrue(hero.equals(sr.getObject()));\n-    }\n-\n-    \/*\n-     * Validate that getObject() returns the same object used to create the Ref\n-     *\/\n-    @Test(enabled = false)\n-    public void test05() throws Exception {\n-        SerialRef sr = new SerialRef(ref);\n-        assertTrue(hero.equals(sr.getObject(map)));\n-    }\n-\n-    \/*\n-     * Validate that setObject() can be used to change the value of the object\n-     * pointed to by the SerialRef\n-     *\/\n-    @Test\n-    public void test06() throws Exception {\n-        SerialRef sr = new SerialRef(ref);\n-        assertTrue(hero.equals(sr.getObject()));\n-        SuperHero h = new SuperHero(sqlType, \"Dick\", \"Grayson\", 1940, \"Robin\");\n-        sr.setObject(h);\n-        assertFalse(hero.equals(sr.getObject()));\n-    }\n-\n-    \/*\n-     * clone() a SerialRef and check that it is equal to the\n-     * object it was cloned from\n-     *\/\n-    @Test\n-    public void test09() throws Exception {\n-        SerialRef sr = new SerialRef(ref);\n-        SerialRef sr1 = (SerialRef) sr.clone();\n-        assertTrue(sr.equals(sr1));\n-    }\n-\n-    \/**\n-     * Validate that a SerialRef that is serialized & deserialized is equal to\n-     * itself for the Object & baseTypeName\n-     *\/\n-    @Test\n-    public void test10() throws Exception {\n-        SerialRef sr = new SerialRef(ref);\n-        SerialRef sr1 = serializeDeserializeObject(sr);\n-        assertTrue(sr1.getObject().equals(sr.getObject())\n-                && sr1.getBaseTypeName().equals(sr.getBaseTypeName()));\n-    }\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/serial\/SerialRefTests.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,400 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.rowset.webrowset;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileReader;\n-import java.io.InputStreamReader;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.OutputStreamWriter;\n-import java.math.BigDecimal;\n-import java.sql.ResultSet;\n-import java.util.Arrays;\n-import javax.sql.rowset.WebRowSet;\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertEqualsNoOrder;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n-import org.testng.annotations.Test;\n-import test.rowset.cachedrowset.CommonCachedRowSetTests;\n-\n-public abstract class CommonWebRowSetTests extends CommonCachedRowSetTests {\n-\n-    protected final String XMLFILEPATH = System.getProperty(\"test.src\", \".\")\n-            + File.separatorChar + \"xml\" + File.separatorChar;\n-    protected final String COFFEE_ROWS_XML = XMLFILEPATH + \"COFFEE_ROWS.xml\";\n-    protected final String DELETED_COFFEE_ROWS_XML\n-            = XMLFILEPATH + \"DELETED_COFFEE_ROWS.xml\";\n-    protected final String MODFIED_DELETED_COFFEE_ROWS_XML\n-            = XMLFILEPATH + \"MODFIED_DELETED_COFFEE_ROWS.xml\";\n-    protected final String UPDATED_COFFEE_ROWS_XML\n-            = XMLFILEPATH + \"UPDATED_COFFEE_ROWS.xml\";\n-    protected final String INSERTED_COFFEE_ROWS_XML\n-            = XMLFILEPATH + \"INSERTED_COFFEE_ROWS.xml\";\n-    protected final String UPDATED_INSERTED_COFFEE_ROWS_XML\n-            = XMLFILEPATH + \"UPDATED_INSERTED_COFFEE_ROWS.xml\";\n-\n-\n-    \/*\n-     * Utility method to write a WebRowSet XML file via an OutputStream\n-     *\/\n-    protected ByteArrayOutputStream writeWebRowSetWithOutputStream(WebRowSet rs) throws Exception {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n-            rs.writeXml(oos);\n-        }\n-        return baos;\n-    }\n-\n-    \/*\n-     * Utility method to write a WebRowSet XML file via an OutputStream\n-     * and populating the WebRowSet via a ResultSet\n-     *\/\n-    protected ByteArrayOutputStream writeWebRowSetWithOutputStream(ResultSet rs) throws Exception {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n-            WebRowSet wrs = rsf.createWebRowSet();\n-            wrs.writeXml(rs, oos);\n-        }\n-        return baos;\n-    }\n-\n-\n-    \/*\n-     * Utility method to popoulate a WebRowSet via a InputStream\n-     *\/\n-    protected WebRowSet readWebRowSetWithOInputStream(ByteArrayOutputStream baos) throws Exception {\n-        WebRowSet wrs1 = rsf.createWebRowSet();\n-        try (ObjectInputStream ois\n-                = new ObjectInputStream(new ByteArrayInputStream(baos.toByteArray()))) {\n-            wrs1.readXml(ois);\n-        }\n-        return wrs1;\n-    }\n-\n-    \/*\n-     * Utility method to write a WebRowSet XML file via an Writer\n-     *\/\n-    protected ByteArrayOutputStream writeWebRowSetWithOutputStreamWithWriter(WebRowSet rs) throws Exception {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        OutputStreamWriter osw = new OutputStreamWriter(baos);\n-        rs.writeXml(osw);\n-        return baos;\n-    }\n-\n-    \/*\n-     * Utility method to write a WebRowSet XML file via an Writer and populating\n-     * the WebRowSet via a ResultSet\n-     *\/\n-    protected ByteArrayOutputStream writeWebRowSetWithOutputStreamWithWriter(ResultSet rs) throws Exception {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        OutputStreamWriter osw = new OutputStreamWriter(baos);\n-        WebRowSet wrs = rsf.createWebRowSet();\n-        wrs.writeXml(rs, osw);\n-        return baos;\n-    }\n-\n-    \/*\n-     * Utility method to popoulate a WebRowSet via a Readar\n-     *\/\n-    protected WebRowSet readWebRowSetWithOInputStreamWithReader(ByteArrayOutputStream baos) throws Exception {\n-        WebRowSet wrs1 = rsf.createWebRowSet();\n-        InputStreamReader isr = new InputStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n-        wrs1.readXml(isr);\n-        return wrs1;\n-    }\n-\n-    \/*\n-     * Validate the expected Rows are contained within the RowSet\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffees\")\n-    public void WebRowSetTest0000(WebRowSet wrs) throws Exception {\n-        assertEquals(getPrimaryKeys(wrs), COFFEES_PRIMARY_KEYS);\n-        assertEquals(wrs.size(), COFFEES_ROWS);\n-        wrs.close();\n-    }\n-\n-    \/*\n-     * Validate the expected Rows are contained within the RowSet\n-     * populated by readXML(Reader)\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void WebRowSetTest0001(WebRowSet wrs1) throws Exception {\n-\n-        try (FileReader fr = new FileReader(COFFEE_ROWS_XML)) {\n-            wrs1.readXml(fr);\n-        }\n-        assertEquals(getPrimaryKeys(wrs1), COFFEES_PRIMARY_KEYS);\n-        assertEquals(wrs1.size(), COFFEES_ROWS);\n-        wrs1.close();\n-\n-    }\n-\n-    \/*\n-     * Validate the expected Rows are contained within the RowSet\n-     * populated by readXML(InputStream)\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void WebRowSetTest0002(WebRowSet wrs1) throws Exception {\n-        try (FileInputStream fis = new FileInputStream(COFFEE_ROWS_XML)) {\n-            wrs1.readXml(fis);\n-        }\n-        assertEquals(getPrimaryKeys(wrs1), COFFEES_PRIMARY_KEYS);\n-        assertEquals(wrs1.size(), COFFEES_ROWS);\n-        wrs1.close();\n-    }\n-\n-    \/*\n-     * Write a WebRowSet via writeXML(OutputStream), read it\n-     * back via readXML(InputStream) and validate the primary  keys\n-     * are the same\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffees\")\n-    public void WebRowSetTest0003(WebRowSet wrs) throws Exception {\n-        ByteArrayOutputStream baos = writeWebRowSetWithOutputStream(wrs);\n-        try (WebRowSet wrs1 = readWebRowSetWithOInputStream(baos)) {\n-            assertEquals(getPrimaryKeys(wrs1), COFFEES_PRIMARY_KEYS);\n-            assertEquals(wrs1.size(), COFFEES_ROWS);\n-        }\n-    }\n-\n-    \/*\n-     * Write a ResultSet via writeXML(OutputStream), read it\n-     * back via readXML(InputStream) and validate the primary  keys\n-     * are the same\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffees\")\n-    public void WebRowSetTest0004(WebRowSet wrs) throws Exception {\n-        ResultSet rs = wrs;\n-        rs.beforeFirst();\n-        ByteArrayOutputStream baos = writeWebRowSetWithOutputStream(rs);\n-        try (WebRowSet wrs1 = readWebRowSetWithOInputStream(baos)) {\n-            assertEquals(getPrimaryKeys(wrs1), COFFEES_PRIMARY_KEYS);\n-            assertEquals(wrs1.size(), COFFEES_ROWS);\n-        }\n-    }\n-\n-    \/*\n-     * Write a WebRowSet via writeXML(Writer), read it\n-     * back via readXML(Reader) and validate the primary  keys\n-     * are the same\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffees\")\n-    public void WebRowSetTest0005(WebRowSet wrs) throws Exception {\n-        ByteArrayOutputStream baos = writeWebRowSetWithOutputStreamWithWriter(wrs);\n-        try (WebRowSet wrs1 = readWebRowSetWithOInputStreamWithReader(baos)) {\n-            assertEquals(getPrimaryKeys(wrs1), COFFEES_PRIMARY_KEYS);\n-            assertEquals(wrs1.size(), COFFEES_ROWS);\n-        }\n-    }\n-\n-    \/*\n-     * Write a WebRowSet via writeXML(Writer), read it\n-     * back via readXML(Reader) and validate the primary  keys\n-     * are the same\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffees\")\n-    public void WebRowSetTest0006(WebRowSet wrs) throws Exception {\n-        ResultSet rs = wrs;\n-        rs.beforeFirst();\n-        ByteArrayOutputStream baos = writeWebRowSetWithOutputStreamWithWriter(rs);\n-        try (WebRowSet wrs1 = readWebRowSetWithOInputStreamWithReader(baos)) {\n-            assertEquals(getPrimaryKeys(wrs1), COFFEES_PRIMARY_KEYS);\n-            assertEquals(wrs1.size(), COFFEES_ROWS);\n-        }\n-    }\n-\n-    \/*\n-     * Validate the expected Rows are contained within the RowSet\n-     * after deleting the specified rows\n-     *\/\n-    @Test(dataProvider = \"rowsetUsingCoffees\", enabled = false)\n-    public void WebRowSetTest0007(WebRowSet wrs) throws Exception {\n-        assertEquals(getPrimaryKeys(wrs), COFFEES_PRIMARY_KEYS);\n-        int[] rowsToDelete = {2, 4};\n-        assertEquals(getPrimaryKeys(wrs), COFFEES_PRIMARY_KEYS);\n-        for (int row : rowsToDelete) {\n-            assertTrue(deleteRowByPrimaryKey(wrs, row, 1));\n-        }\n-\n-        FileInputStream fis = new FileInputStream(MODFIED_DELETED_COFFEE_ROWS_XML);\n-        try (WebRowSet wrs1 = rsf.createWebRowSet()) {\n-            wrs1.readXml(fis);\n-            \/\/ With setShowDeleted(false) which is the default,\n-            \/\/ the deleted row should not be visible\n-            for (int row : rowsToDelete) {\n-                assertTrue(findRowByPrimaryKey(wrs1, row, 1));\n-            }\n-            assertTrue(wrs.size() == COFFEES_ROWS);\n-            \/\/ With setShowDeleted(true), the deleted row should be visible\n-            for (int row : rowsToDelete) {\n-                assertTrue(findRowByPrimaryKey(wrs, row, 1));\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Validate the expected Rows are contained within the RowSet\n-     * that was populated by reading an xml file with all rows\n-     * marked as a currentRow\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void WebRowSetTest0008(WebRowSet wrs1) throws Exception {\n-        FileInputStream fis = new FileInputStream(COFFEE_ROWS_XML);\n-        wrs1.readXml(fis);\n-        assertTrue(wrs1.size() == COFFEES_ROWS);\n-        assertEquals(getPrimaryKeys(wrs1), COFFEES_PRIMARY_KEYS);\n-        \/\/ Validate that the rows are not marked as deleted, inserted or updated\n-        wrs1.beforeFirst();\n-        while (wrs1.next()) {\n-            assertFalse(wrs1.rowDeleted());\n-            assertFalse(wrs1.rowInserted());\n-            assertFalse(wrs1.rowUpdated());\n-        }\n-        wrs1.close();\n-    }\n-\n-    \/*\n-     * Read an XML file to populate a WebRowSet and validate that the rows\n-     * that are marked as deleted are marked as such in the WebRowSet\n-     * Also validate that they are or are not visible based on the\n-     * setShowDeleted value\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void WebRowSetTest0009(WebRowSet wrs1) throws Exception {\n-        int[] rowsToDelete = {2, 4};\n-        Object[] expectedRows = {1, 3, 5};\n-        FileInputStream fis = new FileInputStream(DELETED_COFFEE_ROWS_XML);\n-        wrs1.readXml(fis);\n-        assertTrue(wrs1.size() == COFFEES_ROWS);\n-        assertEquals(getPrimaryKeys(wrs1), expectedRows);\n-        \/\/ With setShowDeleted(false) which is the default,\n-        \/\/ the deleted row should not be visible\n-        for (int row : rowsToDelete) {\n-            assertFalse(findRowByPrimaryKey(wrs1, row, 1));\n-        }\n-        \/\/ With setShowDeleted(true), the deleted row should be visible\n-        wrs1.setShowDeleted(true);\n-        for (int row : rowsToDelete) {\n-            assertTrue(findRowByPrimaryKey(wrs1, row, 1));\n-        }\n-        assertEquals(getPrimaryKeys(wrs1), COFFEES_PRIMARY_KEYS);\n-        wrs1.close();\n-\n-    }\n-\n-    \/*\n-     * Validate that the correct row in the WebRowSet that had been created\n-     * from an xml file is marked as updated and contains the correct values\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void WebRowSetTest0010(WebRowSet wrs1) throws Exception {\n-        FileInputStream fis = new FileInputStream(UPDATED_COFFEE_ROWS_XML);\n-        wrs1.readXml(fis);\n-        assertTrue(wrs1.size() == COFFEES_ROWS);\n-        assertEquals(getPrimaryKeys(wrs1), COFFEES_PRIMARY_KEYS);\n-        wrs1.beforeFirst();\n-        while (wrs1.next()) {\n-            if (wrs1.getInt(1) == 3) {\n-                assertTrue(wrs1.rowUpdated());\n-                assertTrue(wrs1.getInt(5) == 21 && wrs1.getInt(6) == 69);\n-                assertFalse(wrs1.rowDeleted());\n-                assertFalse(wrs1.rowInserted());\n-            } else {\n-                assertFalse(wrs1.rowUpdated());\n-                assertFalse(wrs1.rowDeleted());\n-                assertFalse(wrs1.rowInserted());\n-            }\n-        }\n-        wrs1.close();\n-    }\n-\n-    \/*\n-     * Validate the correct row is marked as inserted in a WebRowSet\n-     * that is read from an xml file\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void WebRowSetTest0011(WebRowSet wrs1) throws Exception {\n-        int expectedSize = COFFEES_ROWS + 2;\n-        int addedRowPK = 15;\n-        int addedRowPK2 = 20;\n-        Object[] expected = Arrays.copyOf(COFFEES_PRIMARY_KEYS, expectedSize);\n-        expected[expectedSize - 2] = addedRowPK;\n-        expected[expectedSize - 1] = addedRowPK2;\n-        FileInputStream fis = new FileInputStream(INSERTED_COFFEE_ROWS_XML);\n-        wrs1.readXml(fis);\n-        assertTrue(wrs1.size() == expectedSize);\n-        assertEqualsNoOrder(getPrimaryKeys(wrs1), expected);\n-        wrs1.beforeFirst();\n-        while (wrs1.next()) {\n-            if (wrs1.getInt(1) == 15 || wrs1.getInt(1) == 20) {\n-                assertTrue(wrs1.rowInserted());\n-                assertFalse(wrs1.rowDeleted());\n-                assertFalse(wrs1.rowUpdated());\n-            } else {\n-                assertFalse(wrs1.rowInserted());\n-                assertFalse(wrs1.rowDeleted());\n-                assertFalse(wrs1.rowUpdated());\n-            }\n-        }\n-        wrs1.close();\n-    }\n-\n-    \/*\n-     * Read an xml file which contains a row that was inserted and updated\n-     *\/\n-    @Test(dataProvider = \"rowSetType\")\n-    public void WebRowSetTest0012(WebRowSet wrs1) throws Exception {\n-        int expectedSize = COFFEES_ROWS + 1;\n-        int addedRowPK = 100;\n-        Object[] expected = Arrays.copyOf(COFFEES_PRIMARY_KEYS, expectedSize);\n-        expected[expectedSize - 1] = addedRowPK;\n-        FileInputStream fis = new FileInputStream(UPDATED_INSERTED_COFFEE_ROWS_XML);\n-        wrs1.readXml(fis);\n-        assertTrue(wrs1.size() == expectedSize);\n-        assertEquals(getPrimaryKeys(wrs1), expected);\n-        wrs1.beforeFirst();\n-        while (wrs1.next()) {\n-            if (wrs1.getInt(1) == addedRowPK) {\n-                \/\/ Row that was inserted and updated\n-                assertTrue(wrs1.rowUpdated());\n-                assertTrue(\n-                        wrs1.getBigDecimal(4).equals(BigDecimal.valueOf(12.99))\n-                        && wrs1.getInt(6) == 125);\n-                assertFalse(wrs1.rowDeleted());\n-                assertTrue(wrs1.rowInserted());\n-            } else {\n-                \/\/ Remaining rows should only be inserted\n-                assertFalse(wrs1.rowUpdated());\n-                assertFalse(wrs1.rowDeleted());\n-                assertTrue(wrs1.rowInserted());\n-            }\n-        }\n-        wrs1.close();\n-    }\n-\n-}\n","filename":"test\/jdk\/javax\/sql\/testng\/test\/rowset\/webrowset\/CommonWebRowSetTests.java","additions":0,"deletions":400,"binary":false,"changes":400,"status":"deleted"}]}