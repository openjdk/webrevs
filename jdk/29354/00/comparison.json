{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,8 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n@@ -39,1 +41,1 @@\n- * @run testng\/othervm DriverManagerModuleTests\n+ * @run junit\/othervm DriverManagerModuleTests\n@@ -43,0 +45,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -49,1 +52,1 @@\n-    @BeforeClass\n+    @BeforeAll\n@@ -53,1 +56,1 @@\n-    @AfterClass\n+    @AfterAll\n@@ -57,1 +60,1 @@\n-    @BeforeMethod\n+    @BeforeEach\n@@ -61,1 +64,1 @@\n-    @AfterMethod\n+    @AfterEach\n","filename":"test\/jdk\/java\/sql\/driverModuleTests\/DriverManagerModuleTests.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+# JDBC unit tests uses JUnit\n+JUnit.dirs = .\n+othervm.dirs = test\/sql\/othervm\n+\n","filename":"test\/jdk\/java\/sql\/junit\/TEST.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/BatchUpdateExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/BatchUpdateExceptionTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import org.junit.jupiter.params.provider.ValueSource;\n+import util.BaseTest;\n+import util.StubConnection;\n+\n+import java.sql.CallableStatement;\n+import java.sql.SQLException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class CallableStatementTests extends BaseTest {\n+    private CallableStatement cstmt;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        cstmt = new StubConnection().prepareCall(\"{call SuperHero_Proc(?)}\");\n+    }\n+\n+    @AfterEach\n+    public void tearDownMethod() throws Exception {\n+        cstmt.close();\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedLiteralValues\")\n+    public void test00(String s, String expected) throws SQLException {\n+        assertEquals(expected, cstmt.enquoteLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteLiteral is null\n+     *\/\n+    @Test\n+    public void test01() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> cstmt.enquoteLiteral(null));\n+    }\n+\n+    \/*\n+     * Validate that enquoteIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedIdentifierValues\")\n+    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n+        assertEquals(expected, cstmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that a SQLException is thrown for values that are not valid\n+     * for a SQL identifier\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"invalidEnquotedIdentifierValues\")\n+    public void test03(String s, boolean alwaysQuote) throws SQLException {\n+        Assertions.assertThrows(SQLException.class, () -> cstmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown is the string passed to\n+     * enquoteIdentiifer is null\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test04(boolean alwaysQuote) throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> cstmt.enquoteIdentifier(null, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that isSimpleIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"simpleIdentifierValues\")\n+    public void test05(String s, boolean expected) throws SQLException {\n+        assertEquals(expected, cstmt.isSimpleIdentifier(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * isSimpleIdentifier is null\n+     *\/\n+    @Test\n+    public void test06() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> cstmt.isSimpleIdentifier(null));\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedNCharLiteralValues\")\n+    public void test07(String s, String expected) throws SQLException {\n+        assertEquals(expected, cstmt.enquoteNCharLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteNCharLiteral is null\n+     *\/\n+    @Test\n+    public void test08() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> cstmt.enquoteNCharLiteral(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/CallableStatementTests.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import org.junit.jupiter.params.provider.ValueSource;\n+import util.BaseTest;\n+import util.StubConnection;\n+\n+import java.sql.SQLException;\n+\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class ConnectionTests extends BaseTest {\n+\n+    protected StubConnection conn;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        conn = new StubConnection();\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedLiteralValues\")\n+    public void test00(String s, String expected) throws SQLException {\n+        assertEquals(expected, conn.enquoteLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteLiteral is null\n+     *\/\n+    @Test\n+    public void test01() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> conn.enquoteLiteral(null));\n+    }\n+\n+    \/*\n+     * Validate that enquoteIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedIdentifierValues\")\n+    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n+        assertEquals(expected, conn.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that a SQLException is thrown for values that are not valid\n+     * for a SQL identifier\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"invalidEnquotedIdentifierValues\")\n+    public void test03(String s, boolean alwaysQuote) throws SQLException {\n+        Assertions.assertThrows(SQLException.class, () -> conn.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown is the string passed to\n+     * enquoteIdentiifer is null\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test04(boolean alwaysQuote) throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> conn.enquoteIdentifier(null, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that isSimpleIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"simpleIdentifierValues\")\n+    public void test05(String s, boolean expected) throws SQLException {\n+        assertEquals(expected, conn.isSimpleIdentifier(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * isSimpleIdentifier is null\n+     *\/\n+    @Test\n+    public void test06() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> conn.isSimpleIdentifier(null));\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedNCharLiteralValues\")\n+    public void test07(String s, String expected) throws SQLException {\n+        assertEquals(expected, conn.enquoteNCharLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteNCharLiteral is null\n+     *\/\n+    @Test\n+    public void test08() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> conn.enquoteNCharLiteral(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/ConnectionTests.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/DataTruncationTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/DataTruncationTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import java.sql.Date;\n+import java.time.LocalDate;\n+\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import util.BaseTest;\n+\n+public class DateTests extends BaseTest {\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for an invalid Date string\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"invalidDateValues\")\n+    public void test(String d) throws Exception {\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> Date.valueOf(d));\n+    }\n+\n+    \/*\n+     * Test that a date created from a date string is equal to the value\n+     * returned from toString()\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validDateValues\")\n+    public void test00(String d, String expectedD) {\n+        Date d1 = Date.valueOf(d);\n+        Date d2 = Date.valueOf(expectedD);\n+        assertTrue(d1.equals(d2) && d2.equals(d1)\n+                && d1.toString().equals(expectedD), \"Error d1 != d2\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.after() returns false when same date is compared\n+     *\/\n+    @Test\n+    public void test01() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertFalse(d.after(d), \"Error d.after(d) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.after() returns true when later date is compared to\n+     * earlier date\n+     *\/\n+    @Test\n+    public void test2() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(System.currentTimeMillis());\n+        assertTrue(d2.after(d), \"Error d2.after(d) = false\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.after() returns false when earlier date is compared\n+     * to later date\n+     *\/\n+    @Test\n+    public void test3() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertFalse(d.after(d2), \"Error d.after(d2) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.after() returns false when date compared to another\n+     * date created from the original date\n+     *\/\n+    @Test\n+    public void test4() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertFalse(d.after(d2), \"Error d.after(d2) = true\");\n+        assertFalse(d2.after(d), \"Error d2.after(d) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.before() returns false when same date is compared\n+     *\/\n+    @Test\n+    public void test5() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertFalse(d.before(d), \"Error d.before(d) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.before() returns true when earlier date is compared\n+     * to later date\n+     *\/\n+    @Test\n+    public void test6() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(System.currentTimeMillis());\n+        assertTrue(d.before(d2), \"Error d.before(d2) = false\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.before() returns false when later date is compared\n+     * to earlier date\n+     *\/\n+    @Test\n+    public void test7() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertFalse(d2.before(d), \"Error d2.before(d) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.before() returns false when date compared to another\n+     * date created from the original date\n+     *\/\n+    @Test\n+    public void test8() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertFalse(d.before(d2), \"Error d.before(d2) = true\");\n+        assertFalse(d2.before(d), \"Error d2.before(d) = true\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.compareTo returns 0 when both Date objects are the\n+     * same\n+     *\/\n+    @Test\n+    public void test9() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertTrue(d.compareTo(d) == 0, \"Error d.compareTo(d) !=0\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.compareTo returns 0 when both Date objects represent\n+     * the same date\n+     *\/\n+    @Test\n+    public void test10() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertTrue(d.compareTo(d2) == 0, \"Error d.compareTo(d2) !=0\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.compareTo returns -1 when comparing a date to a\n+     * later date\n+     *\/\n+    @Test\n+    public void test11() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(System.currentTimeMillis());\n+        assertTrue(d.compareTo(d2) == -1, \"Error d.compareTo(d2) != -1\");\n+    }\n+\n+    \/*\n+     * Validate that a Date.compareTo returns 1 when comparing a date to an\n+     * earlier date\n+     *\/\n+    @Test\n+    public void test12() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(System.currentTimeMillis());\n+        assertTrue(d2.compareTo(d) == 1, \"Error d.compareTo(d2) != 1\");\n+    }\n+\n+    \/*\n+     * Validate that a Date made from a LocalDate are equal\n+     *\/\n+    @Test\n+    public void test13() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        LocalDate ldt = d.toLocalDate();\n+        Date d2 = Date.valueOf(ldt);\n+        assertTrue(d.equals(d2), \"Error d != d2\");\n+    }\n+\n+    \/*\n+     * Validate that a Date LocalDate value, made from a LocalDate are equal\n+     *\/\n+    @Test\n+    public void test14() {\n+        LocalDate ldt = LocalDate.now();\n+        Date d = Date.valueOf(ldt);\n+        assertTrue(ldt.equals(d.toLocalDate()),\n+                \"Error LocalDate values are not equal\");\n+    }\n+\n+    \/*\n+     * Validate an NPE occurs when a null LocalDate is passed to valueOf\n+     *\/\n+    @Test\n+    public void test15() throws Exception {\n+        LocalDate ld = null;\n+        Assertions.assertThrows(NullPointerException.class, () -> Date.valueOf(ld));\n+    }\n+\n+    \/*\n+     * Validate an UnsupportedOperationException occurs when toInstant() is\n+     * called\n+     *\/\n+    @Test\n+    public void test16() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Assertions.assertThrows(UnsupportedOperationException.class, d::toInstant);\n+    }\n+\n+    \/*\n+     * Validate that two Date objects are equal when one is created from the\n+     * toString() of the other\n+     *\/\n+    @Test\n+    public void test17() {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = Date.valueOf(d.toString());\n+        assertTrue(d.equals(d2) && d2.equals(d), \"Error d != d2\");\n+    }\n+\n+    \/*\n+     * Validate that two Date values one created using valueOf and another via a\n+     * constructor are equal\n+     *\/\n+    @Test\n+    public void test18() {\n+\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(61, 7, 30);\n+        assertTrue(d.equals(d2), \"Error d != d2\");\n+    }\n+\n+    \/*\n+     * Validate that two Date values one created using getTime() of the other\n+     * are equal\n+     *\/\n+    @Test\n+    public void test19() {\n+\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Date d2 = new Date(d.getTime());\n+        assertTrue(d.equals(d2), \"Error d != d2\");\n+    }\n+\n+    \/*\n+     * Validate that a Date value is equal to itself\n+     *\/\n+    @Test\n+    public void test20() {\n+\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        assertTrue(d.equals(d), \"Error d != d\");\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getHours\n+     *\/\n+    @Test\n+    public void test21() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Assertions.assertThrows(IllegalArgumentException.class, d::getHours);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getMinutes\n+     *\/\n+    @Test\n+    public void test22() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Assertions.assertThrows(IllegalArgumentException.class, d::getMinutes);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getSeconds\n+     *\/\n+    @Test\n+    public void test23() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Assertions.assertThrows(IllegalArgumentException.class, d::getSeconds);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setHours\n+     *\/\n+    @Test\n+    public void test24() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> d.setHours(8));\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setMinutes\n+     *\/\n+    @Test\n+    public void test25() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> d.setMinutes(0));\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setSeconds\n+     *\/\n+    @Test\n+    public void test26() throws Exception {\n+        Date d = Date.valueOf(\"1961-08-30\");\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> d.setSeconds(0));\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Date which are not valid and are used\n+     * to validate that an IllegalArgumentException will be thrown from the\n+     * valueOf method\n+     *\/\n+    private Object[][] invalidDateValues() {\n+        return new Object[][]{\n+            {\"20009-11-01\"},\n+            {\"09-11-01\"},\n+            {\"-11-01\"},\n+            {\"2009-111-01\"},\n+            {\"2009--01\"},\n+            {\"2009-13-01\"},\n+            {\"2009-11-011\"},\n+            {\"2009-11-\"},\n+            {\"2009-11-00\"},\n+            {\"2009-11-33\"},\n+            {\"--\"},\n+            {\"\"},\n+            {null},\n+            {\"-\"},\n+            {\"2009\"},\n+            {\"2009-01\"},\n+            {\"---\"},\n+            {\"2009-13--1\"},\n+            {\"1900-1-0\"},\n+            {\"2009-01-01 10:50:01\"},\n+            {\"1996-12-10 12:26:19.1\"},\n+            {\"10:50:01\"}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Dates which are  valid and are used\n+     * to validate that an IllegalArgumentException will not be thrown from the\n+     * valueOf method and the corect value from toString() is returned\n+     *\/\n+    private Object[][] validDateValues() {\n+        return new Object[][]{\n+            {\"2009-08-30\", \"2009-08-30\"},\n+            {\"2009-01-8\", \"2009-01-08\"},\n+            {\"2009-1-01\", \"2009-01-01\"},\n+            {\"2009-1-1\", \"2009-01-01\"}\n+\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/DateTests.java","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.CharArrayReader;\n+import java.io.CharArrayWriter;\n+import java.io.File;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.sql.Driver;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+\n+import util.StubDriver;\n+\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class DriverManagerTests {\n+\n+    private final String StubDriverURL = \"jdbc:tennis:boy\";\n+    private final String StubDriverDAURL = \"jdbc:luckydog:tennis\";\n+    private final String InvalidURL = \"jdbc:cardio:tennis\";\n+    private String[] results = {\"output\", \"more output\", \"and more\", \"the end\"};\n+    private String noOutput = \"should not find this\";\n+\n+    public DriverManagerTests() {\n+    }\n+\n+    @BeforeAll\n+    public static void setUpClass() throws Exception {\n+    }\n+\n+    @AfterAll\n+    public static void tearDownClass() throws Exception {\n+    }\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        removeAllDrivers();\n+    }\n+\n+    @AfterEach\n+    public void tearDownMethod() throws Exception {\n+    }\n+\n+    \/**\n+     * Utility method to remove all registered drivers\n+     *\/\n+    private static void removeAllDrivers() {\n+        java.util.Enumeration e = DriverManager.getDrivers();\n+        while (e.hasMoreElements()) {\n+            try {\n+                DriverManager.deregisterDriver((Driver) (e.nextElement()));\n+            } catch (SQLException ex) {\n+                System.out.print(ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Utility method to see if a driver is registered\n+     *\/\n+    private boolean isDriverRegistered(Driver d) {\n+        boolean foundDriver = false;\n+        java.util.Enumeration e = DriverManager.getDrivers();\n+        while (e.hasMoreElements()) {\n+            if (d == (Driver) e.nextElement()) {\n+                foundDriver = true;\n+                break;\n+            }\n+        }\n+        return foundDriver;\n+    }\n+\n+    \/**\n+     * Validate that values set using setLoginTimeout will be returned by\n+     * getLoginTimeout\n+     *\/\n+    @Test\n+    public void test() {\n+        int[] vals = {-1, 0, 5};\n+        for (int val : vals) {\n+            DriverManager.setLoginTimeout(val);\n+            assertEquals(DriverManager.getLoginTimeout(), val);\n+        }\n+    }\n+\n+    \/**\n+     * Validate that NullPointerException is thrown when null is passed to\n+     * registerDriver\n+     *\/\n+    @Test\n+    public void test1() throws Exception {\n+        Driver d = null;\n+        Assertions.assertThrows(NullPointerException.class,\n+                () -> DriverManager.registerDriver(d));\n+    }\n+\n+    \/**\n+     * Validate that NullPointerException is thrown when null is passed to\n+     * registerDriver\n+     *\/\n+    @Test\n+    public void test2() throws Exception {\n+        Driver d = null;\n+        Assertions.assertThrows(NullPointerException.class, () ->\n+                DriverManager.registerDriver(d, null));\n+    }\n+\n+    \/**\n+     * Validate that a null value allows for deRegisterDriver to return\n+     *\/\n+    @Test\n+    public void test3() throws Exception {\n+        DriverManager.deregisterDriver(null);\n+\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when there is no Driver to service\n+     * the URL\n+     *\/\n+    @Test\n+    public void test4() throws Exception {\n+        Assertions.assertThrows(SQLException.class, () -> DriverManager.getConnection(InvalidURL));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when there is no Driver to service\n+     * the URL\n+     *\/\n+    @Test\n+    public void test5() throws Exception {\n+        Assertions.assertThrows(SQLException.class, () -> DriverManager.getConnection(InvalidURL, new Properties()));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when there is no Driver to service\n+     * the URL\n+     *\/\n+    @Test\n+    public void test6() throws Exception {\n+        Assertions.assertThrows(SQLException.class, () -> DriverManager.getConnection(InvalidURL, \"LuckyDog\", \"tennisanyone\"));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when null is passed for the URL\n+     *\/\n+    @Test\n+    public void test7() throws Exception {\n+        Assertions.assertThrows(SQLException.class, () -> DriverManager.getConnection(null));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when null is passed for the URL\n+     *\/\n+    @Test\n+    public void test8() throws Exception {\n+        Assertions.assertThrows(SQLException.class, () -> DriverManager.getConnection(null, new Properties()));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when null is passed for the URL\n+     *\/\n+    @Test\n+    public void test9() throws Exception {\n+        Assertions.assertThrows(SQLException.class, () -> DriverManager.getConnection(null, \"LuckyDog\", \"tennisanyone\"));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when there is no Driver to service\n+     * the URL\n+     *\/\n+    @Test\n+    public void test10() throws Exception {\n+        Assertions.assertThrows(SQLException.class, () -> DriverManager.getDriver(InvalidURL));\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when null is passed for the URL\n+     *\/\n+    @Test\n+    public void test11() throws Exception {\n+        Assertions.assertThrows(SQLException.class, () -> DriverManager.getDriver(null));\n+    }\n+\n+    \/**\n+     * Validate that a non-null Driver is returned by getDriver when a valid URL\n+     * is specified\n+     *\/\n+    @Test\n+    public void test12() throws Exception {\n+\n+        DriverManager.registerDriver(new StubDriver());\n+        assertTrue(DriverManager.getDriver(StubDriverURL) != null);\n+    }\n+\n+    \/**\n+     * Validate that SQLException is thrown when the URL is not valid for any of\n+     * the registered drivers\n+     *\/\n+    @Test\n+    public void test13() throws Exception {\n+        DriverManager.registerDriver(new StubDriver());\n+        Assertions.assertThrows(SQLException.class, () -> DriverManager.getDriver(InvalidURL));\n+    }\n+\n+    \/**\n+     * Validate that a Connection object is returned when a valid URL is\n+     * specified to getConnection\n+     *\n+     *\/\n+    @Test\n+    public void test14() throws Exception {\n+\n+        DriverManager.registerDriver(new StubDriver());\n+        assertTrue(\n+                DriverManager.getConnection(StubDriverURL) != null);\n+        assertTrue(DriverManager.getConnection(StubDriverURL,\n+                \"LuckyDog\", \"tennisanyone\") != null);\n+        Properties props = new Properties();\n+        props.put(\"user\", \"LuckyDog\");\n+        props.put(\"password\", \"tennisanyone\");\n+        assertTrue(\n+                DriverManager.getConnection(StubDriverURL,\n+                        props) != null);\n+    }\n+\n+    \/**\n+     * Register a driver and make sure you find it via its URL. Deregister the\n+     * driver and validate it is not longer registered\n+     *\n+     * @throws Exception\n+     *\/\n+    @Test()\n+    public void test15() throws Exception {\n+        DriverManager.registerDriver(new StubDriver());\n+        Driver d = DriverManager.getDriver(StubDriverURL);\n+        assertTrue(d != null);\n+        assertTrue(isDriverRegistered(d));\n+        DriverManager.deregisterDriver(d);\n+        assertFalse(isDriverRegistered(d));\n+    }\n+\n+    \/**\n+     * Validate that DriverAction.release is called when a driver is registered\n+     * via registerDriver(Driver, DriverAction)\n+     *\n+     * @throws Exception\n+     *\/\n+    @Test\n+    public void test16() throws Exception {\n+        File file = new File(util.StubDriverDA.DriverActionCalled);\n+        file.delete();\n+        assertFalse(file.exists());\n+        Driver d = null;\n+        Class.forName(\"util.StubDriverDA\");\n+        d = DriverManager.getDriver(StubDriverDAURL);\n+        DriverManager.deregisterDriver(d);\n+        assertFalse(isDriverRegistered(d), \"Driver is registered\");\n+        assertTrue(file.exists());\n+    }\n+\n+    \/**\n+     * Create a PrintStream and use to send output via DriverManager.println\n+     * Validate that if you disable the stream, the output sent is not present\n+     *\/\n+    @Test\n+    public void tests17() throws Exception {\n+        ByteArrayOutputStream os = new ByteArrayOutputStream();\n+        PrintStream ps = new PrintStream(os);\n+        DriverManager.setLogStream(ps);\n+        assertTrue(DriverManager.getLogStream() == ps);\n+\n+        DriverManager.println(results[0]);\n+        DriverManager.setLogStream((PrintStream) null);\n+        assertTrue(DriverManager.getLogStream() == null);\n+        DriverManager.println(noOutput);\n+        DriverManager.setLogStream(ps);\n+        DriverManager.println(results[1]);\n+        DriverManager.println(results[2]);\n+        DriverManager.println(results[3]);\n+        DriverManager.setLogStream((PrintStream) null);\n+        DriverManager.println(noOutput);\n+\n+        \/*\n+         * Check we do not get the output when the stream is disabled\n+         *\/\n+        InputStreamReader is\n+                = new InputStreamReader(new ByteArrayInputStream(os.toByteArray()));\n+        BufferedReader reader = new BufferedReader(is);\n+        for (String result : results) {\n+            assertTrue(result.equals(reader.readLine()));\n+        }\n+    }\n+\n+    \/**\n+     * Create a PrintWriter and use it to send output via DriverManager.println\n+     * Validate that if you disable the writer, the output sent is not present\n+     *\/\n+    @Test\n+    public void tests18() throws Exception {\n+        CharArrayWriter cw = new CharArrayWriter();\n+        PrintWriter pw = new PrintWriter(cw);\n+        DriverManager.setLogWriter(pw);\n+        assertTrue(DriverManager.getLogWriter() == pw);\n+\n+        DriverManager.println(results[0]);\n+        DriverManager.setLogWriter(null);\n+        assertTrue(DriverManager.getLogWriter() == null);\n+        DriverManager.println(noOutput);\n+        DriverManager.setLogWriter(pw);\n+        DriverManager.println(results[1]);\n+        DriverManager.println(results[2]);\n+        DriverManager.println(results[3]);\n+        DriverManager.setLogWriter(null);\n+        DriverManager.println(noOutput);\n+\n+        \/*\n+         * Check we do not get the output when the stream is disabled\n+         *\/\n+        BufferedReader reader\n+                = new BufferedReader(new CharArrayReader(cw.toCharArray()));\n+        for (String result : results) {\n+            assertTrue(result.equals(reader.readLine()));\n+        }\n+    }\n+\n+    \/**\n+     * Register some driver implementations and validate that the driver\n+     * elements covered by the Enumeration obtained from\n+     * {@link DriverManager#getDrivers()} are the same as driver elements\n+     * covered by the stream obtained from {@link DriverManager#drivers()}}\n+     *\/\n+    @Test\n+    public void tests19() throws Exception {\n+        int n = 8;\n+        for (int i = 0; i < n; i++) {\n+            DriverManager.registerDriver(new StubDriver());\n+        }\n+\n+        Collection<Driver> expectedDrivers = Collections.list(DriverManager.getDrivers());\n+        assertEquals(n, expectedDrivers.size());\n+        Collection<Driver> drivers = DriverManager.drivers().collect(Collectors.toList());\n+\n+        assertEquals(expectedDrivers, drivers);\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/DriverManagerTests.java","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import org.junit.jupiter.params.provider.ValueSource;\n+import util.BaseTest;\n+import util.StubConnection;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class PreparedStatementTests extends BaseTest {\n+\n+    private PreparedStatement pstmt;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        pstmt = new StubConnection().prepareStatement(\"Select * from foo were bar = ?\");\n+    }\n+\n+    @AfterEach\n+    public void tearDownMethod() throws Exception {\n+        pstmt.close();\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedLiteralValues\")\n+    public void test00(String s, String expected) throws SQLException {\n+        assertEquals(expected, pstmt.enquoteLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteLiteral is null\n+     *\/\n+    @Test\n+    public void test01() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> pstmt.enquoteLiteral(null));\n+    }\n+\n+    \/*\n+     * Validate that enquoteIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedIdentifierValues\")\n+    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n+        assertEquals(expected, pstmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that a SQLException is thrown for values that are not valid\n+     * for a SQL identifier\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"invalidEnquotedIdentifierValues\")\n+    public void test03(String s, boolean alwaysQuote) throws SQLException {\n+        Assertions.assertThrows(SQLException.class, () -> pstmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown is the string passed to\n+     * enquoteIdentiifer is null\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test04(boolean alwaysQuote) throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> pstmt.enquoteIdentifier(null, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that isSimpleIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"simpleIdentifierValues\")\n+    public void test05(String s, boolean expected) throws SQLException {\n+        assertEquals(expected, pstmt.isSimpleIdentifier(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * isSimpleIdentifier is null\n+     *\/\n+    @Test\n+    public void test06() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> pstmt.isSimpleIdentifier(null));\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedNCharLiteralValues\")\n+    public void test07(String s, String expected) throws SQLException {\n+        assertEquals(expected, pstmt.enquoteNCharLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteNCharLiteral is null\n+     *\/\n+    @Test\n+    public void test08() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> pstmt.enquoteNCharLiteral(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/PreparedStatementTests.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLClientInfoExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLClientInfoExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLDataExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLDataExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLFeatureNotSupportedExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLFeatureNotSupportedExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLIntegrityConstraintViolationExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLIntegrityConstraintViolationExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLInvalidAuthorizationSpecExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLInvalidAuthorizationSpecExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLNonTransientConnectionExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLNonTransientConnectionExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLNonTransientExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLNonTransientExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLRecoverableExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLRecoverableExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLSyntaxErrorExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLSyntaxErrorExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLTimeoutExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLTimeoutExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLTransactionRollbackExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLTransactionRollbackExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLTransientConnectionExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLTransientConnectionExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLTransientExceptionTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLTransientExceptionTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,4 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/SQLWarningTests.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/SQLWarningTests.java","status":"renamed"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import org.junit.jupiter.params.provider.ValueSource;\n+import util.BaseTest;\n+import util.StubConnection;\n+\n+public class StatementTests extends BaseTest {\n+\n+    private Statement stmt;\n+\n+    @BeforeEach\n+    public void setUpMethod() throws Exception {\n+        stmt = new StubConnection().createStatement();\n+    }\n+\n+    @AfterEach\n+    public void tearDownMethod() throws Exception {\n+        stmt.close();\n+    }\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedLiteralValues\")\n+    public void test00(String s, String expected) throws SQLException {\n+        assertEquals(expected, stmt.enquoteLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteLiteral is null\n+     *\/\n+    @Test\n+    public void test01() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> stmt.enquoteLiteral(null));\n+    }\n+\n+    \/*\n+     * Validate that enquoteIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedIdentifierValues\")\n+    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n+        assertEquals(expected, stmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that a SQLException is thrown for values that are not valid\n+     * for a SQL identifier\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"invalidEnquotedIdentifierValues\")\n+    public void test03(String s, boolean alwaysQuote) throws SQLException {\n+        Assertions.assertThrows(SQLException.class, () -> stmt.enquoteIdentifier(s, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown is the string passed to\n+     * enquoteIdentiifer is null\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void test04(boolean alwaysQuote) throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> stmt.enquoteIdentifier(null, alwaysQuote));\n+    }\n+\n+    \/*\n+     * Validate that isSimpleIdentifier returns the expected value\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"simpleIdentifierValues\")\n+    public void test05(String s, boolean expected) throws SQLException {\n+        assertEquals(expected, stmt.isSimpleIdentifier(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * isSimpleIdentifier is null\n+     *\/\n+    @Test\n+    public void test06() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> stmt.isSimpleIdentifier(null));\n+    }\n+\n+    \/*\n+     * Verify that enquoteLiteral creates a  valid literal and converts every\n+     * single quote to two single quotes\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validEnquotedNCharLiteralValues\")\n+    public void test07(String s, String expected) throws SQLException {\n+        assertEquals(expected, stmt.enquoteNCharLiteral(s));\n+    }\n+\n+    \/*\n+     * Validate a NullPointerException is thrown if the string passed to\n+     * enquoteNCharLiteral is null\n+     *\/\n+    @Test\n+    public void test08() throws SQLException {\n+        Assertions.assertThrows(NullPointerException.class, () -> stmt.enquoteNCharLiteral(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/StatementTests.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,351 @@\n+\/*\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.sql;\n+\n+import java.sql.Time;\n+import java.time.LocalTime;\n+\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import util.BaseTest;\n+\n+public class TimeTests extends BaseTest {\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getYear\n+     *\/\n+    @Test\n+    public void test01() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Assertions.assertThrows(IllegalArgumentException.class, t::getYear);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getMonth\n+     *\/\n+    @Test\n+    public void test02() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Assertions.assertThrows(IllegalArgumentException.class, t::getMonth);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getDay\n+     *\/\n+    @Test\n+    public void test03() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Assertions.assertThrows(IllegalArgumentException.class, t::getDay);\n+    }\n+\n+    \/**\n+     * Validate an IllegalArgumentException is thrown for calling getDate\n+     *\/\n+    @Test\n+    public void test04() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Assertions.assertThrows(IllegalArgumentException.class, t::getDate);\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setYear\n+     *\/\n+    @Test\n+    public void test05() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> t.setYear(8));\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setMonth\n+     *\/\n+    @Test\n+    public void test06() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> t.setMonth(8));\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling setDate\n+     *\/\n+    @Test\n+    public void test07() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> t.setDate(30));\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for calling getDate\n+     *\/\n+    @Test\n+    public void test08() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Assertions.assertThrows(IllegalArgumentException.class, t::getDate);\n+    }\n+\n+    \/*\n+     * Validate that a Time made from a toLocalTime() LocalTime are equal\n+     *\/\n+    @Test\n+    public void test09() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = Time.valueOf(t.toLocalTime());\n+        assertTrue(t.equals(t2), \"Error t != t2\");\n+    }\n+\n+    \/*\n+     * Validate that a Time LocalTime value, made from a LocalTime are equal\n+     *\/\n+    @Test\n+    public void test10() {\n+        LocalTime lt = LocalTime.of(8, 30, 59);\n+        Time t = Time.valueOf(lt);\n+        System.out.println(\"lt=\" + lt + \",t=\" + t.toLocalTime());\n+        assertTrue(lt.equals(t.toLocalTime()),\n+                \"Error LocalTime values are not equal\");\n+    }\n+\n+    \/*\n+     * Validate an NPE occurs when a null LocalDate is passed to valueOf\n+     *\/\n+    @Test\n+    public void test11() throws Exception {\n+        LocalTime ld = null;\n+        Assertions.assertThrows(NullPointerException.class, () -> Time.valueOf(ld));\n+    }\n+\n+    \/*\n+     * Validate an UnsupportedOperationException occurs when toInstant() is\n+     * called\n+     *\/\n+    @Test\n+    public void test12() throws Exception {\n+        Time t = new Time(System.currentTimeMillis());\n+        Assertions.assertThrows(UnsupportedOperationException.class, t::toInstant);\n+    }\n+\n+    \/*\n+     * Validate that two Time objects are equal when one is created from the\n+     * toString() of the other and that the correct value is returned from\n+     * toString()\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"validTimeValues\")\n+    public void test13(String time, String expected) {\n+        Time t1 = Time.valueOf(time);\n+        Time t2 = Time.valueOf(t1.toString());\n+        assertTrue(t1.equals(t2) && t2.equals(t1)\n+                && t1.toString().equals(expected), \"Error t1 != t2\");\n+    }\n+\n+    \/*\n+     * Validate that two Time values one created using valueOf and another via a\n+     * constructor are equal\n+     *\/\n+    @Test\n+    public void test14() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(8, 30, 59);\n+        assertTrue(t.equals(t2) && t2.equals(t), \"Error t != t2\");\n+    }\n+\n+    \/*\n+     * Validate that two Time values one created using valueOf and another via a\n+     * constructor are equal\n+     *\/\n+    @Test\n+    public void test15() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime());\n+        assertTrue(t.equals(t2) && t2.equals(t), \"Error t != t2\");\n+    }\n+\n+    \/*\n+     * Validate an IllegalArgumentException is thrown for an invalid Time string\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"invalidTimeValues\")\n+    public void test16(String time) throws Exception {\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> Time.valueOf(time));\n+    }\n+\n+    \/*\n+     * Validate that Time.after() returns false when same date is compared\n+     *\/\n+    @Test\n+    public void test17() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertFalse(t.after(t), \"Error t.after(t) = true\");\n+    }\n+\n+    \/*\n+     * Validate that Time.after() returns true when later date is compared to\n+     * earlier date\n+     *\/\n+    @Test\n+    public void test18() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(System.currentTimeMillis());\n+        assertTrue(t2.after(t), \"Error t2.after(t) = false\");\n+    }\n+\n+    \/*\n+     * Validate that Time.after() returns false when earlier date is compared to\n+     * itself\n+     *\/\n+    @Test\n+    public void test19() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime());\n+        assertFalse(t.after(t2), \"Error t.after(t2) = true\");\n+        assertFalse(t2.after(t), \"Error t2.after(t) = true\");\n+    }\n+\n+    \/*\n+     * Validate that Time.before() returns false when same date is compared\n+     *\/\n+    @Test\n+    public void test20() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertFalse(t.before(t), \"Error t.before(t) = true\");\n+    }\n+\n+    \/*\n+     * Validate that Time.before() returns true when earlier date is compared to\n+     * later date\n+     *\/\n+    @Test\n+    public void test21() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(System.currentTimeMillis());\n+        assertTrue(t.before(t2), \"Error t.before(t2) = false\");\n+    }\n+\n+    \/*\n+     * Validate that Time.before() returns false when earlier date is compared\n+     * to itself\n+     *\/\n+    @Test\n+    public void test22() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime());\n+        assertFalse(t.before(t2), \"Error t.after(t2) = true\");\n+        assertFalse(t2.before(t), \"Error t2.after(t) = true\");\n+    }\n+\n+    \/*\n+     * Validate that Time.compareTo returns 0 when both Date objects are the\n+     * same\n+     *\/\n+    @Test\n+    public void test23() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        assertTrue(t.compareTo(t) == 0, \"Error t.compareTo(t) !=0\");\n+    }\n+\n+    \/*\n+     * Validate thatTime.compareTo returns 0 when both Time objects are the same\n+     *\/\n+    @Test\n+    public void test24() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime());\n+        assertTrue(t.compareTo(t2) == 0, \"Error t.compareTo(t2) !=0\");\n+    }\n+\n+    \/*\n+     * Validate that Time.compareTo returns 1 when comparing a later Time to an\n+     * earlier Time\n+     *\/\n+    @Test\n+    public void test25() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime() + 1);\n+        assertTrue(t2.compareTo(t) == 1, \"Error t2.compareTo(t) !=1\");\n+    }\n+\n+    \/*\n+     * Validate thatTime.compareTo returns 1 when comparing a later Time to an\n+     * earlier Time\n+     *\/\n+    @Test\n+    public void test26() {\n+        Time t = Time.valueOf(\"08:30:59\");\n+        Time t2 = new Time(t.getTime() + 1);\n+        assertTrue(t.compareTo(t2) == -1, \"Error t.compareTo(t2) != -1\");\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Time values which are not valid and are used\n+     * to validate that an IllegalArgumentException will be thrown from the\n+     * valueOf method\n+     *\/\n+    private Object[][] invalidTimeValues() {\n+        return new Object[][]{\n+            {\"2009-11-01 10:50:01\"},\n+            {\"1961-08-30 10:50:01.1\"},\n+            {\"1961-08-30\"},\n+            {\"00:00:00.\"},\n+            {\"10:50:0.1\"},\n+            {\":00:00\"},\n+            {\"00::00\"},\n+            {\"00:00:\"},\n+            {\"::\"},\n+            {\" : : \"},\n+            {\"0a:00:00\"},\n+            {\"00:bb:00\"},\n+            {\"00:01:cc\"},\n+            {\"08:10:Batman\"},\n+            {\"08:10:10:10\"},\n+            {\"08:10\"},\n+            {\"a:b:c\"},\n+            {null},\n+            {\"8:\"}\n+        };\n+    }\n+\n+    \/*\n+     * DataProvider used to provide Time values which are  valid and are used\n+     * to validate that an IllegalArgumentException will  not be thrown from the\n+     * valueOf method.  It also contains the expected return value from\n+     * toString()\n+     *\/\n+    private Object[][] validTimeValues() {\n+        return new Object[][]{\n+            {\"10:50:01\", \"10:50:01\"},\n+            {\"01:1:1\", \"01:01:01\"},\n+            {\"01:01:1\", \"01:01:01\"},\n+            {\"1:01:1\", \"01:01:01\"},\n+            {\"2:02:02\", \"02:02:02\"},\n+            {\"2:02:2\", \"02:02:02\"},\n+            {\"10:50:1\", \"10:50:01\"},\n+            {\"00:00:00\", \"00:00:00\"},\n+            {\"08:30:59\", \"08:30:59\"},\n+            {\"9:0:1\", \"09:00:01\"}\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/TimeTests.java","additions":351,"deletions":0,"binary":false,"changes":351,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,5 +33,9 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Assertions;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -48,1 +52,1 @@\n-    @BeforeClass\n+    @BeforeAll\n@@ -59,1 +63,1 @@\n-    @AfterClass\n+    @AfterAll\n@@ -67,2 +71,2 @@\n-    @Test(dataProvider = \"invalidTimestampValues\",\n-            expectedExceptions = IllegalArgumentException.class)\n+    @ParameterizedTest\n+    @MethodSource(\"invalidTimestampValues\")\n@@ -70,1 +74,1 @@\n-        Timestamp.valueOf(ts);\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> Timestamp.valueOf(ts));\n@@ -83,1 +87,1 @@\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n@@ -94,1 +98,1 @@\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n@@ -107,1 +111,1 @@\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n@@ -120,1 +124,1 @@\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n@@ -133,1 +137,1 @@\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n@@ -145,1 +149,1 @@\n-        assertEquals(ts, ts2, \"Error ts1 != ts2\");\n+        assertEquals(ts2, ts, \"Error ts1 != ts2\");\n@@ -222,1 +226,2 @@\n-    @Test(dataProvider = \"validTimestampValues\")\n+    @ParameterizedTest\n+    @MethodSource(\"validTimestampValues\")\n@@ -266,1 +271,1 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n+    @Test\n@@ -269,1 +274,1 @@\n-        ts1.before(null);\n+        Assertions.assertThrows(NullPointerException.class, () -> ts1.before(null));\n@@ -319,1 +324,1 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n+    @Test\n@@ -322,1 +327,1 @@\n-        ts1.after(null);\n+        Assertions.assertThrows(NullPointerException.class, () -> ts1.after(null));\n@@ -479,1 +484,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test\n@@ -482,1 +487,1 @@\n-        ts1.setNanos(-1);\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ts1.setNanos(-1));\n@@ -489,1 +494,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test\n@@ -493,1 +498,1 @@\n-        ts1.setNanos(nanos + 1);\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ts1.setNanos(nanos + 1));\n@@ -544,1 +549,1 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n+    @Test\n@@ -547,1 +552,1 @@\n-        Timestamp.valueOf(ldt);\n+        Assertions.assertThrows(NullPointerException.class, () -> Timestamp.valueOf(ldt));\n@@ -575,1 +580,1 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n+    @Test\n@@ -578,1 +583,1 @@\n-        Timestamp.from(instant);\n+        Assertions.assertThrows(NullPointerException.class, () -> Timestamp.from(instant));\n@@ -631,1 +636,2 @@\n-    @Test(dataProvider = \"validateNanos\")\n+    @ParameterizedTest\n+    @MethodSource(\"validateNanos\")\n@@ -639,1 +645,2 @@\n-    @Test(dataProvider = \"validTimestampLongValues\")\n+    @ParameterizedTest\n+    @MethodSource(\"validTimestampLongValues\")\n@@ -642,1 +649,1 @@\n-        assertEquals(ts1.toString(), ts, \"ts1.toString() != ts\");\n+        assertEquals(ts, ts1.toString(), \"ts1.toString() != ts\");\n@@ -649,1 +656,1 @@\n-        assertEquals(Timestamp.from(instant1).toInstant(), instant1);\n+        assertEquals(instant1, Timestamp.from(instant1).toInstant());\n@@ -653,1 +660,1 @@\n-        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(instant2));\n+        assertThrows(IllegalArgumentException.class, () -> Timestamp.from(instant2));\n@@ -657,1 +664,1 @@\n-        assertEquals(Timestamp.from(instant3).toInstant(), instant3);\n+        assertEquals(instant3, Timestamp.from(instant3).toInstant());\n@@ -661,1 +668,1 @@\n-        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(instant4));\n+        assertThrows(IllegalArgumentException.class, () -> Timestamp.from(instant4));\n@@ -664,1 +671,1 @@\n-        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(Instant.MAX));\n+        assertThrows(IllegalArgumentException.class, () -> Timestamp.from(Instant.MAX));\n@@ -667,1 +674,1 @@\n-        expectThrows(IllegalArgumentException.class, () -> Timestamp.from(Instant.MIN));\n+        assertThrows(IllegalArgumentException.class, () -> Timestamp.from(Instant.MIN));\n@@ -686,1 +693,1 @@\n-        assertEquals(ts1.hashCode(), ts2.hashCode());\n+        assertEquals(ts2.hashCode(), ts1.hashCode());\n@@ -705,1 +712,1 @@\n-        assertNotEquals(ts1.hashCode(), ts2.hashCode());\n+        assertNotEquals(ts2.hashCode(), ts1.hashCode());\n@@ -713,1 +720,0 @@\n-    @DataProvider(name = \"invalidTimestampValues\")\n@@ -747,1 +753,0 @@\n-    @DataProvider(name = \"validTimestampValues\")\n@@ -776,1 +781,0 @@\n-    @DataProvider(name = \"validTimestampLongValues\")\n@@ -815,1 +819,0 @@\n-    @DataProvider(name = \"validateNanos\")\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/TimestampTests.java","additions":48,"deletions":45,"binary":false,"changes":93,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/TimestampTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-import static org.testng.Assert.*;\n-import org.testng.annotations.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.Test;\n","filename":"test\/jdk\/java\/sql\/junit\/test\/sql\/othervm\/DriverManagerInitTests.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/othervm\/DriverManagerInitTests.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-import org.testng.annotations.DataProvider;\n+import org.junit.jupiter.api.TestInstance;\n@@ -35,0 +35,1 @@\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n@@ -76,12 +77,0 @@\n-    \/*\n-     * DataProvider used to specify the value to set and check for\n-     * methods using boolean values\n-     *\/\n-    @DataProvider(name = \"trueFalse\")\n-    protected Object[][] trueFalse() {\n-        return new Object[][]{\n-            {true},\n-            {false}\n-        };\n-    }\n-\n@@ -91,1 +80,0 @@\n-    @DataProvider(name = \"jdbcTypes\")\n@@ -106,1 +94,0 @@\n-    @DataProvider(name = \"validEnquotedLiteralValues\")\n@@ -122,1 +109,0 @@\n-    @DataProvider(name = \"validIdentifierValues\")\n@@ -145,1 +131,0 @@\n-    @DataProvider(name = \"invalidIdentifierValues\")\n@@ -160,1 +145,0 @@\n-    @DataProvider(name = \"simpleIdentifierValues\")\n@@ -184,1 +168,0 @@\n-    @DataProvider(name = \"validEnquotedNCharLiteralValues\")\n","filename":"test\/jdk\/java\/sql\/junit\/util\/BaseTest.java","additions":3,"deletions":20,"binary":false,"changes":23,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/BaseTest.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/DriverActionImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/DriverActionImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/SerializedBatchUpdateException.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/SerializedBatchUpdateException.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubCallableStatement.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubCallableStatement.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubConnection.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubDatabaseMetaData.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubDatabaseMetaData.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubDriver.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubDriver.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubDriverDA.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubDriverDA.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubPreparedStatement.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubPreparedStatement.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2026, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/sql\/junit\/util\/StubStatement.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/sql\/testng\/util\/StubStatement.java","status":"renamed"},{"patch":"@@ -1,4 +0,0 @@\n-# JDBC unit tests uses TestNG\n-TestNG.dirs = .\n-othervm.dirs = test\/sql\/othervm\n-\n","filename":"test\/jdk\/java\/sql\/testng\/TEST.properties","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubConnection;\n-\n-import java.sql.CallableStatement;\n-import java.sql.SQLException;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class CallableStatementTests extends BaseTest {\n-    private CallableStatement cstmt;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        cstmt = new StubConnection().prepareCall(\"{call SuperHero_Proc(?)}\");\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-        cstmt.close();\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedLiteralValues\")\n-    public void test00(String s, String expected) throws SQLException {\n-        assertEquals(cstmt.enquoteLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test01() throws SQLException {\n-        cstmt.enquoteLiteral(null);\n-    }\n-\n-    \/*\n-     * Validate that enquoteIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"validIdentifierValues\")\n-    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n-        assertEquals(cstmt.enquoteIdentifier(s, alwaysQuote), expected);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException is thrown for values that are not valid\n-     * for a SQL identifier\n-     *\/\n-    @Test(dataProvider = \"invalidIdentifierValues\",\n-            expectedExceptions = SQLException.class)\n-    public void test03(String s, boolean alwaysQuote) throws SQLException {\n-        cstmt.enquoteIdentifier(s, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown is the string passed to\n-     * enquoteIdentiifer is null\n-     *\/\n-    @Test(dataProvider = \"trueFalse\",\n-            expectedExceptions = NullPointerException.class)\n-    public void test04(boolean alwaysQuote) throws SQLException {\n-        cstmt.enquoteIdentifier(null, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate that isSimpleIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"simpleIdentifierValues\")\n-    public void test05(String s, boolean expected) throws SQLException {\n-        assertEquals(cstmt.isSimpleIdentifier(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * isSimpleIdentifier is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test06() throws SQLException {\n-        cstmt.isSimpleIdentifier(null);\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedNCharLiteralValues\")\n-    public void test07(String s, String expected) throws SQLException {\n-        assertEquals(cstmt.enquoteNCharLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteNCharLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test08() throws SQLException {\n-        cstmt.enquoteNCharLiteral(null);\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/CallableStatementTests.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubConnection;\n-\n-import java.sql.SQLException;\n-\n-import static org.testng.Assert.*;\n-\n-public class ConnectionTests extends BaseTest {\n-\n-    protected StubConnection conn;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        conn = new StubConnection();\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedLiteralValues\")\n-    public void test00(String s, String expected) throws SQLException {\n-        assertEquals(conn.enquoteLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test01() throws SQLException {\n-        conn.enquoteLiteral(null);\n-    }\n-\n-    \/*\n-     * Validate that enquoteIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"validIdentifierValues\")\n-    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n-        assertEquals(conn.enquoteIdentifier(s, alwaysQuote), expected);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException is thrown for values that are not valid\n-     * for a SQL identifier\n-     *\/\n-    @Test(dataProvider = \"invalidIdentifierValues\",\n-            expectedExceptions = SQLException.class)\n-    public void test03(String s, boolean alwaysQuote) throws SQLException {\n-        conn.enquoteIdentifier(s, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown is the string passed to\n-     * enquoteIdentiifer is null\n-     *\/\n-    @Test(dataProvider = \"trueFalse\",\n-            expectedExceptions = NullPointerException.class)\n-    public void test04(boolean alwaysQuote) throws SQLException {\n-        conn.enquoteIdentifier(null, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate that isSimpleIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"simpleIdentifierValues\")\n-    public void test05(String s, boolean expected) throws SQLException {\n-        assertEquals(conn.isSimpleIdentifier(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * isSimpleIdentifier is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test06() throws SQLException {\n-        conn.isSimpleIdentifier(null);\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedNCharLiteralValues\")\n-    public void test07(String s, String expected) throws SQLException {\n-        assertEquals(conn.enquoteNCharLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteNCharLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test08() throws SQLException {\n-        conn.enquoteNCharLiteral(null);\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/ConnectionTests.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,373 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import java.sql.Date;\n-import java.time.Instant;\n-import java.time.LocalDate;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-\n-public class DateTests extends BaseTest {\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for an invalid Date string\n-     *\/\n-    @Test(dataProvider = \"invalidDateValues\",\n-            expectedExceptions = IllegalArgumentException.class)\n-    public void test(String d) throws Exception {\n-        Date.valueOf(d);\n-    }\n-\n-    \/*\n-     * Test that a date created from a date string is equal to the value\n-     * returned from toString()\n-     *\/\n-    @Test(dataProvider = \"validDateValues\")\n-    public void test00(String d, String expectedD) {\n-        Date d1 = Date.valueOf(d);\n-        Date d2 = Date.valueOf(expectedD);\n-        assertTrue(d1.equals(d2) && d2.equals(d1)\n-                && d1.toString().equals(expectedD), \"Error d1 != d2\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.after() returns false when same date is compared\n-     *\/\n-    @Test\n-    public void test01() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        assertFalse(d.after(d), \"Error d.after(d) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.after() returns true when later date is compared to\n-     * earlier date\n-     *\/\n-    @Test\n-    public void test2() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(System.currentTimeMillis());\n-        assertTrue(d2.after(d), \"Error d2.after(d) = false\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.after() returns false when earlier date is compared\n-     * to later date\n-     *\/\n-    @Test\n-    public void test3() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertFalse(d.after(d2), \"Error d.after(d2) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.after() returns false when date compared to another\n-     * date created from the original date\n-     *\/\n-    @Test\n-    public void test4() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertFalse(d.after(d2), \"Error d.after(d2) = true\");\n-        assertFalse(d2.after(d), \"Error d2.after(d) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.before() returns false when same date is compared\n-     *\/\n-    @Test\n-    public void test5() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        assertFalse(d.before(d), \"Error d.before(d) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.before() returns true when earlier date is compared\n-     * to later date\n-     *\/\n-    @Test\n-    public void test6() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(System.currentTimeMillis());\n-        assertTrue(d.before(d2), \"Error d.before(d2) = false\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.before() returns false when later date is compared\n-     * to earlier date\n-     *\/\n-    @Test\n-    public void test7() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertFalse(d2.before(d), \"Error d2.before(d) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.before() returns false when date compared to another\n-     * date created from the original date\n-     *\/\n-    @Test\n-    public void test8() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertFalse(d.before(d2), \"Error d.before(d2) = true\");\n-        assertFalse(d2.before(d), \"Error d2.before(d) = true\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.compareTo returns 0 when both Date objects are the\n-     * same\n-     *\/\n-    @Test\n-    public void test9() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        assertTrue(d.compareTo(d) == 0, \"Error d.compareTo(d) !=0\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.compareTo returns 0 when both Date objects represent\n-     * the same date\n-     *\/\n-    @Test\n-    public void test10() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertTrue(d.compareTo(d2) == 0, \"Error d.compareTo(d2) !=0\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.compareTo returns -1 when comparing a date to a\n-     * later date\n-     *\/\n-    @Test\n-    public void test11() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(System.currentTimeMillis());\n-        assertTrue(d.compareTo(d2) == -1, \"Error d.compareTo(d2) != -1\");\n-    }\n-\n-    \/*\n-     * Validate that a Date.compareTo returns 1 when comparing a date to an\n-     * earlier date\n-     *\/\n-    @Test\n-    public void test12() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(System.currentTimeMillis());\n-        assertTrue(d2.compareTo(d) == 1, \"Error d.compareTo(d2) != 1\");\n-    }\n-\n-    \/*\n-     * Validate that a Date made from a LocalDate are equal\n-     *\/\n-    @Test\n-    public void test13() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        LocalDate ldt = d.toLocalDate();\n-        Date d2 = Date.valueOf(ldt);\n-        assertTrue(d.equals(d2), \"Error d != d2\");\n-    }\n-\n-    \/*\n-     * Validate that a Date LocalDate value, made from a LocalDate are equal\n-     *\/\n-    @Test\n-    public void test14() {\n-        LocalDate ldt = LocalDate.now();\n-        Date d = Date.valueOf(ldt);\n-        assertTrue(ldt.equals(d.toLocalDate()),\n-                \"Error LocalDate values are not equal\");\n-    }\n-\n-    \/*\n-     * Validate an NPE occurs when a null LocalDate is passed to valueOf\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test15() throws Exception {\n-        LocalDate ld = null;\n-        Date.valueOf(ld);\n-    }\n-\n-    \/*\n-     * Validate an UnsupportedOperationException occurs when toInstant() is\n-     * called\n-     *\/\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void test16() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Instant instant = d.toInstant();\n-    }\n-\n-    \/*\n-     * Validate that two Date objects are equal when one is created from the\n-     * toString() of the other\n-     *\/\n-    @Test\n-    public void test17() {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = Date.valueOf(d.toString());\n-        assertTrue(d.equals(d2) && d2.equals(d), \"Error d != d2\");\n-    }\n-\n-    \/*\n-     * Validate that two Date values one created using valueOf and another via a\n-     * constructor are equal\n-     *\/\n-    @Test\n-    public void test18() {\n-\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(61, 7, 30);\n-        assertTrue(d.equals(d2), \"Error d != d2\");\n-    }\n-\n-    \/*\n-     * Validate that two Date values one created using getTime() of the other\n-     * are equal\n-     *\/\n-    @Test\n-    public void test19() {\n-\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        Date d2 = new Date(d.getTime());\n-        assertTrue(d.equals(d2), \"Error d != d2\");\n-    }\n-\n-    \/*\n-     * Validate that a Date value is equal to itself\n-     *\/\n-    @Test\n-    public void test20() {\n-\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        assertTrue(d.equals(d), \"Error d != d\");\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getHours\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test21() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.getHours();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getMinutes\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test22() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.getMinutes();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getSeconds\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test23() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.getSeconds();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setHours\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test24() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.setHours(8);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setMinutes\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test25() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.setMinutes(0);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setSeconds\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test26() throws Exception {\n-        Date d = Date.valueOf(\"1961-08-30\");\n-        d.setSeconds(0);\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Date which are not valid and are used\n-     * to validate that an IllegalArgumentException will be thrown from the\n-     * valueOf method\n-     *\/\n-    @DataProvider(name = \"invalidDateValues\")\n-    private Object[][] invalidDateValues() {\n-        return new Object[][]{\n-            {\"20009-11-01\"},\n-            {\"09-11-01\"},\n-            {\"-11-01\"},\n-            {\"2009-111-01\"},\n-            {\"2009--01\"},\n-            {\"2009-13-01\"},\n-            {\"2009-11-011\"},\n-            {\"2009-11-\"},\n-            {\"2009-11-00\"},\n-            {\"2009-11-33\"},\n-            {\"--\"},\n-            {\"\"},\n-            {null},\n-            {\"-\"},\n-            {\"2009\"},\n-            {\"2009-01\"},\n-            {\"---\"},\n-            {\"2009-13--1\"},\n-            {\"1900-1-0\"},\n-            {\"2009-01-01 10:50:01\"},\n-            {\"1996-12-10 12:26:19.1\"},\n-            {\"10:50:01\"}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Dates which are  valid and are used\n-     * to validate that an IllegalArgumentException will not be thrown from the\n-     * valueOf method and the corect value from toString() is returned\n-     *\/\n-    @DataProvider(name = \"validDateValues\")\n-    private Object[][] validDateValues() {\n-        return new Object[][]{\n-            {\"2009-08-30\", \"2009-08-30\"},\n-            {\"2009-01-8\", \"2009-01-08\"},\n-            {\"2009-1-01\", \"2009-01-01\"},\n-            {\"2009-1-1\", \"2009-01-01\"}\n-\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/DateTests.java","additions":0,"deletions":373,"binary":false,"changes":373,"status":"deleted"},{"patch":"@@ -1,378 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import java.io.BufferedReader;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.CharArrayReader;\n-import java.io.CharArrayWriter;\n-import java.io.File;\n-import java.io.InputStreamReader;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n-import java.sql.Driver;\n-import java.sql.DriverManager;\n-import java.sql.SQLException;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Properties;\n-import java.util.stream.Collectors;\n-\n-import static org.testng.Assert.*;\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import util.StubDriver;\n-\n-public class DriverManagerTests {\n-\n-    private final String StubDriverURL = \"jdbc:tennis:boy\";\n-    private final String StubDriverDAURL = \"jdbc:luckydog:tennis\";\n-    private final String InvalidURL = \"jdbc:cardio:tennis\";\n-    private String[] results = {\"output\", \"more output\", \"and more\", \"the end\"};\n-    private String noOutput = \"should not find this\";\n-\n-    public DriverManagerTests() {\n-    }\n-\n-    @BeforeClass\n-    public static void setUpClass() throws Exception {\n-    }\n-\n-    @AfterClass\n-    public static void tearDownClass() throws Exception {\n-    }\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        removeAllDrivers();\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-    }\n-\n-    \/**\n-     * Utility method to remove all registered drivers\n-     *\/\n-    private static void removeAllDrivers() {\n-        java.util.Enumeration e = DriverManager.getDrivers();\n-        while (e.hasMoreElements()) {\n-            try {\n-                DriverManager.deregisterDriver((Driver) (e.nextElement()));\n-            } catch (SQLException ex) {\n-                System.out.print(ex.getMessage());\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Utility method to see if a driver is registered\n-     *\/\n-    private boolean isDriverRegistered(Driver d) {\n-        boolean foundDriver = false;\n-        java.util.Enumeration e = DriverManager.getDrivers();\n-        while (e.hasMoreElements()) {\n-            if (d == (Driver) e.nextElement()) {\n-                foundDriver = true;\n-                break;\n-            }\n-        }\n-        return foundDriver;\n-    }\n-\n-    \/**\n-     * Validate that values set using setLoginTimeout will be returned by\n-     * getLoginTimeout\n-     *\/\n-    @Test\n-    public void test() {\n-        int[] vals = {-1, 0, 5};\n-        for (int val : vals) {\n-            DriverManager.setLoginTimeout(val);\n-            assertEquals(val, DriverManager.getLoginTimeout());\n-        }\n-    }\n-\n-    \/**\n-     * Validate that NullPointerException is thrown when null is passed to\n-     * registerDriver\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test1() throws Exception {\n-        Driver d = null;\n-        DriverManager.registerDriver(d);\n-    }\n-\n-    \/**\n-     * Validate that NullPointerException is thrown when null is passed to\n-     * registerDriver\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test2() throws Exception {\n-        Driver d = null;\n-        DriverManager.registerDriver(d, null);\n-    }\n-\n-    \/**\n-     * Validate that a null value allows for deRegisterDriver to return\n-     *\/\n-    @Test\n-    public void test3() throws Exception {\n-        DriverManager.deregisterDriver(null);\n-\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when there is no Driver to service\n-     * the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test4() throws Exception {\n-        DriverManager.getConnection(InvalidURL);\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when there is no Driver to service\n-     * the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test5() throws Exception {\n-        DriverManager.getConnection(InvalidURL, new Properties());\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when there is no Driver to service\n-     * the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test6() throws Exception {\n-        DriverManager.getConnection(InvalidURL, \"LuckyDog\", \"tennisanyone\");\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when null is passed for the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test7() throws Exception {\n-        DriverManager.getConnection(null);\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when null is passed for the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test8() throws Exception {\n-        DriverManager.getConnection(null, new Properties());\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when null is passed for the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test9() throws Exception {\n-        DriverManager.getConnection(null, \"LuckyDog\", \"tennisanyone\");\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when there is no Driver to service\n-     * the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test10() throws Exception {\n-        DriverManager.getDriver(InvalidURL);\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when null is passed for the URL\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test11() throws Exception {\n-        DriverManager.getDriver(null);\n-    }\n-\n-    \/**\n-     * Validate that a non-null Driver is returned by getDriver when a valid URL\n-     * is specified\n-     *\/\n-    @Test\n-    public void test12() throws Exception {\n-\n-        DriverManager.registerDriver(new StubDriver());\n-        assertTrue(DriverManager.getDriver(StubDriverURL) != null);\n-    }\n-\n-    \/**\n-     * Validate that SQLException is thrown when the URL is not valid for any of\n-     * the registered drivers\n-     *\/\n-    @Test(expectedExceptions = SQLException.class)\n-    public void test13() throws Exception {\n-        DriverManager.registerDriver(new StubDriver());\n-        DriverManager.getDriver(InvalidURL);\n-    }\n-\n-    \/**\n-     * Validate that a Connection object is returned when a valid URL is\n-     * specified to getConnection\n-     *\n-     *\/\n-    @Test\n-    public void test14() throws Exception {\n-\n-        DriverManager.registerDriver(new StubDriver());\n-        assertTrue(\n-                DriverManager.getConnection(StubDriverURL) != null);\n-        assertTrue(DriverManager.getConnection(StubDriverURL,\n-                \"LuckyDog\", \"tennisanyone\") != null);\n-        Properties props = new Properties();\n-        props.put(\"user\", \"LuckyDog\");\n-        props.put(\"password\", \"tennisanyone\");\n-        assertTrue(\n-                DriverManager.getConnection(StubDriverURL,\n-                        props) != null);\n-    }\n-\n-    \/**\n-     * Register a driver and make sure you find it via its URL. Deregister the\n-     * driver and validate it is not longer registered\n-     *\n-     * @throws Exception\n-     *\/\n-    @Test()\n-    public void test15() throws Exception {\n-        DriverManager.registerDriver(new StubDriver());\n-        Driver d = DriverManager.getDriver(StubDriverURL);\n-        assertTrue(d != null);\n-        assertTrue(isDriverRegistered(d));\n-        DriverManager.deregisterDriver(d);\n-        assertFalse(isDriverRegistered(d));\n-    }\n-\n-    \/**\n-     * Validate that DriverAction.release is called when a driver is registered\n-     * via registerDriver(Driver, DriverAction)\n-     *\n-     * @throws Exception\n-     *\/\n-    @Test\n-    public void test16() throws Exception {\n-        File file = new File(util.StubDriverDA.DriverActionCalled);\n-        file.delete();\n-        assertFalse(file.exists());\n-        Driver d = null;\n-        Class.forName(\"util.StubDriverDA\");\n-        d = DriverManager.getDriver(StubDriverDAURL);\n-        DriverManager.deregisterDriver(d);\n-        assertFalse(isDriverRegistered(d), \"Driver is registered\");\n-        assertTrue(file.exists());\n-    }\n-\n-    \/**\n-     * Create a PrintStream and use to send output via DriverManager.println\n-     * Validate that if you disable the stream, the output sent is not present\n-     *\/\n-    @Test\n-    public void tests17() throws Exception {\n-        ByteArrayOutputStream os = new ByteArrayOutputStream();\n-        PrintStream ps = new PrintStream(os);\n-        DriverManager.setLogStream(ps);\n-        assertTrue(DriverManager.getLogStream() == ps);\n-\n-        DriverManager.println(results[0]);\n-        DriverManager.setLogStream((PrintStream) null);\n-        assertTrue(DriverManager.getLogStream() == null);\n-        DriverManager.println(noOutput);\n-        DriverManager.setLogStream(ps);\n-        DriverManager.println(results[1]);\n-        DriverManager.println(results[2]);\n-        DriverManager.println(results[3]);\n-        DriverManager.setLogStream((PrintStream) null);\n-        DriverManager.println(noOutput);\n-\n-        \/*\n-         * Check we do not get the output when the stream is disabled\n-         *\/\n-        InputStreamReader is\n-                = new InputStreamReader(new ByteArrayInputStream(os.toByteArray()));\n-        BufferedReader reader = new BufferedReader(is);\n-        for (String result : results) {\n-            assertTrue(result.equals(reader.readLine()));\n-        }\n-    }\n-\n-    \/**\n-     * Create a PrintWriter and use it to send output via DriverManager.println\n-     * Validate that if you disable the writer, the output sent is not present\n-     *\/\n-    @Test\n-    public void tests18() throws Exception {\n-        CharArrayWriter cw = new CharArrayWriter();\n-        PrintWriter pw = new PrintWriter(cw);\n-        DriverManager.setLogWriter(pw);\n-        assertTrue(DriverManager.getLogWriter() == pw);\n-\n-        DriverManager.println(results[0]);\n-        DriverManager.setLogWriter(null);\n-        assertTrue(DriverManager.getLogWriter() == null);\n-        DriverManager.println(noOutput);\n-        DriverManager.setLogWriter(pw);\n-        DriverManager.println(results[1]);\n-        DriverManager.println(results[2]);\n-        DriverManager.println(results[3]);\n-        DriverManager.setLogWriter(null);\n-        DriverManager.println(noOutput);\n-\n-        \/*\n-         * Check we do not get the output when the stream is disabled\n-         *\/\n-        BufferedReader reader\n-                = new BufferedReader(new CharArrayReader(cw.toCharArray()));\n-        for (String result : results) {\n-            assertTrue(result.equals(reader.readLine()));\n-        }\n-    }\n-\n-    \/**\n-     * Register some driver implementations and validate that the driver\n-     * elements covered by the Enumeration obtained from\n-     * {@link DriverManager#getDrivers()} are the same as driver elements\n-     * covered by the stream obtained from {@link DriverManager#drivers()}}\n-     *\/\n-    @Test\n-    public void tests19() throws Exception {\n-        int n = 8;\n-        for (int i = 0; i < n; i++) {\n-            DriverManager.registerDriver(new StubDriver());\n-        }\n-\n-        Collection<Driver> expectedDrivers = Collections.list(DriverManager.getDrivers());\n-        assertEquals(expectedDrivers.size(), n);\n-        Collection<Driver> drivers = DriverManager.drivers().collect(Collectors.toList());\n-\n-        assertEquals(drivers, expectedDrivers);\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/DriverManagerTests.java","additions":0,"deletions":378,"binary":false,"changes":378,"status":"deleted"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import org.testng.annotations.AfterMethod;\n-import org.testng.annotations.BeforeMethod;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-import util.StubConnection;\n-\n-import java.sql.PreparedStatement;\n-import java.sql.SQLException;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class PreparedStatementTests extends BaseTest {\n-\n-    private PreparedStatement pstmt;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        pstmt = new StubConnection().prepareStatement(\"Select * from foo were bar = ?\");\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-        pstmt.close();\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedLiteralValues\")\n-    public void test00(String s, String expected) throws SQLException {\n-        assertEquals(pstmt.enquoteLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test01() throws SQLException {\n-        pstmt.enquoteLiteral(null);\n-    }\n-\n-    \/*\n-     * Validate that enquoteIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"validIdentifierValues\")\n-    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n-        assertEquals(pstmt.enquoteIdentifier(s, alwaysQuote), expected);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException is thrown for values that are not valid\n-     * for a SQL identifier\n-     *\/\n-    @Test(dataProvider = \"invalidIdentifierValues\",\n-            expectedExceptions = SQLException.class)\n-    public void test03(String s, boolean alwaysQuote) throws SQLException {\n-        pstmt.enquoteIdentifier(s, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown is the string passed to\n-     * enquoteIdentiifer is null\n-     *\/\n-    @Test(dataProvider = \"trueFalse\",\n-            expectedExceptions = NullPointerException.class)\n-    public void test04(boolean alwaysQuote) throws SQLException {\n-        pstmt.enquoteIdentifier(null, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate that isSimpleIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"simpleIdentifierValues\")\n-    public void test05(String s, boolean expected) throws SQLException {\n-        assertEquals(pstmt.isSimpleIdentifier(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * isSimpleIdentifier is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test06() throws SQLException {\n-        pstmt.isSimpleIdentifier(null);\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedNCharLiteralValues\")\n-    public void test07(String s, String expected) throws SQLException {\n-        assertEquals(pstmt.enquoteNCharLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteNCharLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test08() throws SQLException {\n-        pstmt.enquoteNCharLiteral(null);\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/PreparedStatementTests.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import java.sql.SQLException;\n-import java.sql.Statement;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-import org.testng.annotations.*;\n-import util.BaseTest;\n-import util.StubConnection;\n-\n-public class StatementTests extends BaseTest {\n-\n-    private Statement stmt;\n-\n-    @BeforeMethod\n-    public void setUpMethod() throws Exception {\n-        stmt = new StubConnection().createStatement();\n-    }\n-\n-    @AfterMethod\n-    public void tearDownMethod() throws Exception {\n-        stmt.close();\n-    }\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedLiteralValues\")\n-    public void test00(String s, String expected) throws SQLException {\n-        assertEquals(stmt.enquoteLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test01() throws SQLException {\n-        stmt.enquoteLiteral(null);\n-    }\n-\n-    \/*\n-     * Validate that enquoteIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"validIdentifierValues\")\n-    public void test02(String s, boolean alwaysQuote, String expected) throws SQLException {\n-        assertEquals(stmt.enquoteIdentifier(s, alwaysQuote), expected);\n-    }\n-\n-    \/*\n-     * Validate that a SQLException is thrown for values that are not valid\n-     * for a SQL identifier\n-     *\/\n-    @Test(dataProvider = \"invalidIdentifierValues\",\n-            expectedExceptions = SQLException.class)\n-    public void test03(String s, boolean alwaysQuote) throws SQLException {\n-        stmt.enquoteIdentifier(s, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown is the string passed to\n-     * enquoteIdentiifer is null\n-     *\/\n-    @Test(dataProvider = \"trueFalse\",\n-            expectedExceptions = NullPointerException.class)\n-    public void test04(boolean alwaysQuote) throws SQLException {\n-        stmt.enquoteIdentifier(null, alwaysQuote);\n-    }\n-\n-    \/*\n-     * Validate that isSimpleIdentifier returns the expected value\n-     *\/\n-    @Test(dataProvider = \"simpleIdentifierValues\")\n-    public void test05(String s, boolean expected) throws SQLException {\n-        assertEquals(stmt.isSimpleIdentifier(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * isSimpleIdentifier is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test06() throws SQLException {\n-        stmt.isSimpleIdentifier(null);\n-    }\n-\n-    \/*\n-     * Verify that enquoteLiteral creates a  valid literal and converts every\n-     * single quote to two single quotes\n-     *\/\n-    @Test(dataProvider = \"validEnquotedNCharLiteralValues\")\n-    public void test07(String s, String expected) throws SQLException {\n-        assertEquals(stmt.enquoteNCharLiteral(s), expected);\n-    }\n-\n-    \/*\n-     * Validate a NullPointerException is thrown if the string passed to\n-     * enquoteNCharLiteral is null\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test08() throws SQLException {\n-        stmt.enquoteNCharLiteral(null);\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/StatementTests.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,348 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.sql;\n-\n-import java.sql.Time;\n-import java.time.LocalTime;\n-import static org.testng.Assert.*;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import util.BaseTest;\n-\n-public class TimeTests extends BaseTest {\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getYear\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test01() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.getYear();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getMonth\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test02() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.getMonth();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getDay\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test03() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.getDay();\n-    }\n-\n-    \/**\n-     * Validate an IllegalArgumentException is thrown for calling getDate\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test04() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.getDate();\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setYear\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test05() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.setYear(8);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setMonth\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test06() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.setMonth(8);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling setDate\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test07() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.setDate(30);\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for calling getDate\n-     *\/\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void test08() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        t.getDate();\n-    }\n-\n-    \/*\n-     * Validate that a Time made from a toLocalTime() LocalTime are equal\n-     *\/\n-    @Test\n-    public void test09() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = Time.valueOf(t.toLocalTime());\n-        assertTrue(t.equals(t2), \"Error t != t2\");\n-    }\n-\n-    \/*\n-     * Validate that a Time LocalTime value, made from a LocalTime are equal\n-     *\/\n-    @Test\n-    public void test10() {\n-        LocalTime lt = LocalTime.of(8, 30, 59);\n-        Time t = Time.valueOf(lt);\n-        System.out.println(\"lt=\" + lt + \",t=\" + t.toLocalTime());\n-        assertTrue(lt.equals(t.toLocalTime()),\n-                \"Error LocalTime values are not equal\");\n-    }\n-\n-    \/*\n-     * Validate an NPE occurs when a null LocalDate is passed to valueOf\n-     *\/\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void test11() throws Exception {\n-        LocalTime ld = null;\n-        Time.valueOf(ld);\n-    }\n-\n-    \/*\n-     * Validate an UnsupportedOperationException occurs when toInstant() is\n-     * called\n-     *\/\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void test12() throws Exception {\n-        Time t = new Time(System.currentTimeMillis());\n-        t.toInstant();\n-    }\n-\n-    \/*\n-     * Validate that two Time objects are equal when one is created from the\n-     * toString() of the other and that the correct value is returned from\n-     * toString()\n-     *\/\n-    @Test(dataProvider = \"validTimeValues\")\n-    public void test13(String time, String expected) {\n-        Time t1 = Time.valueOf(time);\n-        Time t2 = Time.valueOf(t1.toString());\n-        assertTrue(t1.equals(t2) && t2.equals(t1)\n-                && t1.toString().equals(expected), \"Error t1 != t2\");\n-    }\n-\n-    \/*\n-     * Validate that two Time values one created using valueOf and another via a\n-     * constructor are equal\n-     *\/\n-    @Test\n-    public void test14() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(8, 30, 59);\n-        assertTrue(t.equals(t2) && t2.equals(t), \"Error t != t2\");\n-    }\n-\n-    \/*\n-     * Validate that two Time values one created using valueOf and another via a\n-     * constructor are equal\n-     *\/\n-    @Test\n-    public void test15() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime());\n-        assertTrue(t.equals(t2) && t2.equals(t), \"Error t != t2\");\n-    }\n-\n-    \/*\n-     * Validate an IllegalArgumentException is thrown for an invalid Time string\n-     *\/\n-    @Test(dataProvider = \"invalidTimeValues\",\n-            expectedExceptions = IllegalArgumentException.class)\n-    public void test16(String time) throws Exception {\n-        Time.valueOf(time);\n-    }\n-\n-    \/*\n-     * Validate that Time.after() returns false when same date is compared\n-     *\/\n-    @Test\n-    public void test17() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        assertFalse(t.after(t), \"Error t.after(t) = true\");\n-    }\n-\n-    \/*\n-     * Validate that Time.after() returns true when later date is compared to\n-     * earlier date\n-     *\/\n-    @Test\n-    public void test18() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(System.currentTimeMillis());\n-        assertTrue(t2.after(t), \"Error t2.after(t) = false\");\n-    }\n-\n-    \/*\n-     * Validate that Time.after() returns false when earlier date is compared to\n-     * itself\n-     *\/\n-    @Test\n-    public void test19() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime());\n-        assertFalse(t.after(t2), \"Error t.after(t2) = true\");\n-        assertFalse(t2.after(t), \"Error t2.after(t) = true\");\n-    }\n-\n-    \/*\n-     * Validate that Time.before() returns false when same date is compared\n-     *\/\n-    @Test\n-    public void test20() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        assertFalse(t.before(t), \"Error t.before(t) = true\");\n-    }\n-\n-    \/*\n-     * Validate that Time.before() returns true when earlier date is compared to\n-     * later date\n-     *\/\n-    @Test\n-    public void test21() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(System.currentTimeMillis());\n-        assertTrue(t.before(t2), \"Error t.before(t2) = false\");\n-    }\n-\n-    \/*\n-     * Validate that Time.before() returns false when earlier date is compared\n-     * to itself\n-     *\/\n-    @Test\n-    public void test22() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime());\n-        assertFalse(t.before(t2), \"Error t.after(t2) = true\");\n-        assertFalse(t2.before(t), \"Error t2.after(t) = true\");\n-    }\n-\n-    \/*\n-     * Validate that Time.compareTo returns 0 when both Date objects are the\n-     * same\n-     *\/\n-    @Test\n-    public void test23() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        assertTrue(t.compareTo(t) == 0, \"Error t.compareTo(t) !=0\");\n-    }\n-\n-    \/*\n-     * Validate thatTime.compareTo returns 0 when both Time objects are the same\n-     *\/\n-    @Test\n-    public void test24() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime());\n-        assertTrue(t.compareTo(t2) == 0, \"Error t.compareTo(t2) !=0\");\n-    }\n-\n-    \/*\n-     * Validate that Time.compareTo returns 1 when comparing a later Time to an\n-     * earlier Time\n-     *\/\n-    @Test\n-    public void test25() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime() + 1);\n-        assertTrue(t2.compareTo(t) == 1, \"Error t2.compareTo(t) !=1\");\n-    }\n-\n-    \/*\n-     * Validate thatTime.compareTo returns 1 when comparing a later Time to an\n-     * earlier Time\n-     *\/\n-    @Test\n-    public void test26() {\n-        Time t = Time.valueOf(\"08:30:59\");\n-        Time t2 = new Time(t.getTime() + 1);\n-        assertTrue(t.compareTo(t2) == -1, \"Error t.compareTo(t2) != -1\");\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Time values which are not valid and are used\n-     * to validate that an IllegalArgumentException will be thrown from the\n-     * valueOf method\n-     *\/\n-    @DataProvider(name = \"invalidTimeValues\")\n-    private Object[][] invalidTimeValues() {\n-        return new Object[][]{\n-            {\"2009-11-01 10:50:01\"},\n-            {\"1961-08-30 10:50:01.1\"},\n-            {\"1961-08-30\"},\n-            {\"00:00:00.\"},\n-            {\"10:50:0.1\"},\n-            {\":00:00\"},\n-            {\"00::00\"},\n-            {\"00:00:\"},\n-            {\"::\"},\n-            {\" : : \"},\n-            {\"0a:00:00\"},\n-            {\"00:bb:00\"},\n-            {\"00:01:cc\"},\n-            {\"08:10:Batman\"},\n-            {\"08:10:10:10\"},\n-            {\"08:10\"},\n-            {\"a:b:c\"},\n-            {null},\n-            {\"8:\"}\n-        };\n-    }\n-\n-    \/*\n-     * DataProvider used to provide Time values which are  valid and are used\n-     * to validate that an IllegalArgumentException will  not be thrown from the\n-     * valueOf method.  It also contains the expected return value from\n-     * toString()\n-     *\/\n-    @DataProvider(name = \"validTimeValues\")\n-    private Object[][] validTimeValues() {\n-        return new Object[][]{\n-            {\"10:50:01\", \"10:50:01\"},\n-            {\"01:1:1\", \"01:01:01\"},\n-            {\"01:01:1\", \"01:01:01\"},\n-            {\"1:01:1\", \"01:01:01\"},\n-            {\"2:02:02\", \"02:02:02\"},\n-            {\"2:02:2\", \"02:02:02\"},\n-            {\"10:50:1\", \"10:50:01\"},\n-            {\"00:00:00\", \"00:00:00\"},\n-            {\"08:30:59\", \"08:30:59\"},\n-            {\"9:0:1\", \"09:00:01\"}\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/sql\/testng\/test\/sql\/TimeTests.java","additions":0,"deletions":348,"binary":false,"changes":348,"status":"deleted"}]}