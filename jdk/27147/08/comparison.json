{"files":[{"patch":"@@ -50,1 +50,1 @@\n- * @see PEMRecord\n+ * @see PEM\n@@ -58,1 +58,1 @@\n-    X509Certificate, X509CRL, PEMRecord {\n+    X509Certificate, X509CRL, PEM {\n","filename":"src\/java.base\/share\/classes\/java\/security\/DEREncodable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.util.Pem;\n+\n+import java.io.InputStream;\n+import java.util.Base64;\n+import java.util.Objects;\n+\n+\/**\n+ * {@code PEM} is a {@link DEREncodable} that represents Privacy-Enhanced\n+ * Mail (PEM) data by its type and Base64-encoded content.\n+ *\n+ * <p> The {@link PEMDecoder#decode(String)} and\n+ * {@link PEMDecoder#decode(InputStream)} methods return a {@code PEM} object\n+ * when the data type cannot be represented by a cryptographic object.\n+ * If you need access to the leading data of a PEM text, or want to\n+ * handle the text content directly, use the decoding methods\n+ * {@link PEMDecoder#decode(String, Class)} or\n+ * {@link PEMDecoder#decode(InputStream, Class)} with {@code PEM.class} as an\n+ * argument type.\n+ *\n+ * <p> A {@code PEM} object can be encoded back to its textual format by calling\n+ * {@link #toString()} or by using the encode methods in {@link PEMEncoder}.\n+ *\n+ * <p> When constructing a {@code PEM} instance, both {@code type} and\n+ * {@code content} must not be {@code null}.\n+ *\n+ * <p>No validation is performed during instantiation to ensure that\n+ * {@code type} conforms to RFC 7468 or other legacy formats, that\n+ * {@code content} is valid Base64 data, or that {@code content} matches the\n+ * {@code type}.\n+\n+ * <p> Common {@code type} values include, but are not limited to:\n+ * CERTIFICATE, CERTIFICATE REQUEST, ATTRIBUTE CERTIFICATE, X509 CRL, PKCS7,\n+ * CMS, PRIVATE KEY, ENCRYPTED PRIVATE KEY, and PUBLIC KEY.\n+ *\n+ * <p> {@code leadingData} is {@code null} if there is no data preceding the PEM\n+ * header during decoding. {@code leadingData} can be useful for reading\n+ * metadata that accompanies the PEM data. Because the value may represent a large\n+ * amount of data, it is not defensively copied by the constructor, and the\n+ * {@link #leadingData()} method does not return a clone. Modification of the\n+ * passed-in or returned array changes the value stored in this record.\n+ *\n+ * @param type the type identifier from the PEM header, without PEM syntax\n+ *             labels; for example, for a public key, {@code type} would be\n+ *             \"PUBLIC KEY\"\n+ * @param content the Base64-encoded data, excluding the PEM header and footer\n+ * @param leadingData any non-PEM data that precedes the PEM header during\n+ *                    decoding.  This value may be {@code null}.\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n+ *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n+ *\n+ * @see PEMDecoder\n+ * @see PEMEncoder\n+ *\n+ * @since 25\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public record PEM(String type, String content, byte[] leadingData)\n+    implements DEREncodable {\n+\n+    \/**\n+     * Creates a {@code PEM} instance with the specified parameters.\n+     *\n+     * @param type the PEM type identifier\n+     * @param content the Base64-encoded data, excluding the PEM header and footer\n+     * @param leadingData any non-PEM data read during the decoding process\n+     *                    before the PEM header.  This value may be {@code null}.\n+     * @throws IllegalArgumentException if {@code type} is incorrectly formatted\n+     * @throws NullPointerException if {@code type} or {@code content} is {@code null}\n+     *\/\n+    public PEM {\n+        Objects.requireNonNull(type, \"\\\"type\\\" cannot be null.\");\n+        Objects.requireNonNull(content, \"\\\"content\\\" cannot be null.\");\n+\n+        \/\/ With no validity checking on `type`, the constructor accept anything\n+        \/\/ including lowercase.  The onus is on the caller.\n+        if (type.startsWith(\"-\") || type.startsWith(\"BEGIN \") ||\n+            type.startsWith(\"END \")) {\n+            throw new IllegalArgumentException(\"PEM syntax labels found. \" +\n+                \"Only the PEM type identifier is allowed.\");\n+        }\n+    }\n+\n+    \/**\n+     * Creates a {@code PEM} instance with the specified type and content. This\n+     * constructor sets {@code leadingData} to {@code null}.\n+     *\n+     * @param type the PEM type identifier\n+     * @param content the Base64-encoded data, excluding the PEM header and footer\n+     * @throws IllegalArgumentException if {@code type} is incorrectly formatted\n+     * @throws NullPointerException if {@code type} or {@code content} is {@code null}\n+     *\/\n+    public PEM(String type, String content) {\n+        this(type, content, null);\n+    }\n+\n+    \/**\n+     * Returns the PEM formatted string containing the {@code type} and\n+     * Base64-encoded {@code content}. {@code leadingData} is not included.\n+     *\n+     * @return the PEM text representation\n+     *\/\n+    @Override\n+    final public String toString() {\n+        return Pem.pemEncoded(this);\n+    }\n+\n+    \/**\n+     * Returns a Base64-decoded byte array of {@code content}, using\n+     * {@link Base64#getMimeDecoder()}.\n+     *\n+     * @return a decoded byte array\n+     * @throws IllegalArgumentException if decoding fails\n+     *\/\n+    final public byte[] decode() {\n+        return Base64.getMimeDecoder().decode(content);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEM.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.ref.CleanerFactory;\n@@ -38,0 +39,1 @@\n+import java.lang.ref.Reference;\n@@ -46,1 +48,1 @@\n- * PEM is a textual encoding used to store and transfer security\n+ * PEM is a textual encoding used to store and transfer cryptographic\n@@ -48,2 +50,2 @@\n- * lists (CRLs).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n- * Base64-formatted binary encoding enclosed by a type-identifying header\n+ * lists (CRLs).  It is defined in RFC 1421 and RFC 7468. PEM consists of a\n+ * Base64-encoded binary encoding enclosed by a type-identifying header\n@@ -52,6 +54,13 @@\n- * <p> The {@linkplain #decode(String)} and {@linkplain #decode(InputStream)}\n- * methods return an instance of a class that matches the data\n- * type and implements {@link DEREncodable}.\n- *\n- * <p> The following lists the supported PEM types and the {@code DEREncodable}\n- * types that each are decoded as:\n+ * <p>The {@link #decode(String)} and {@link #decode(InputStream)} methods\n+ * return an instance of a class that matches the PEM type and implements\n+ * {@link DEREncodable}, as follows:\n+ * <ul>\n+ *   <li>CERTIFICATE : {@link X509Certificate}<\/li>\n+ *   <li>X509 CRL : {@link X509CRL}<\/li>\n+ *   <li>PUBLIC KEY : {@link PublicKey}<\/li>\n+ *   <li>PRIVATE KEY : {@link PrivateKey} or {@link KeyPair}\n+ *   (if the encoding contains a public key)<\/li>\n+ *   <li>ENCRYPTED PRIVATE KEY : {@link EncryptedPrivateKeyInfo}<\/li>\n+ *   <li>Other types : {@link PEM}<\/li>\n+ * <\/ul>\n+ * When used with a {@code PEMDecoder} instance configured for decryption:\n@@ -59,14 +68,2 @@\n- *  <li>CERTIFICATE : {@code X509Certificate}<\/li>\n- *  <li>X509 CRL : {@code X509CRL}<\/li>\n- *  <li>PUBLIC KEY : {@code PublicKey}<\/li>\n- *  <li>PUBLIC KEY : {@code X509EncodedKeySpec} (Only supported when passed as\n- *  a {@code Class} parameter)<\/li>\n- *  <li>PRIVATE KEY : {@code PrivateKey}<\/li>\n- *  <li>PRIVATE KEY : {@code PKCS8EncodedKeySpec} (Only supported when passed\n- *  as a {@code Class} parameter)<\/li>\n- *  <li>PRIVATE KEY : {@code KeyPair} (if the encoding also contains a\n- *  public key)<\/li>\n- *  <li>ENCRYPTED PRIVATE KEY : {@code EncryptedPrivateKeyInfo} <\/li>\n- *  <li>ENCRYPTED PRIVATE KEY : {@code PrivateKey} (if configured with\n- *  Decryption)<\/li>\n- *  <li>Other types : {@code PEMRecord} <\/li>\n+ *   <li>ENCRYPTED PRIVATE KEY : {@link PrivateKey} or {@link KeyPair}\n+ *   (if the encoding contains a public key)<\/li>\n@@ -75,3 +72,3 @@\n- * <p> The {@code PublicKey} and {@code PrivateKey} types, an algorithm specific\n- * subclass is returned if the underlying algorithm is supported. For example an\n- * ECPublicKey and ECPrivateKey for Elliptic Curve keys.\n+ * <p> For {@code PublicKey} and {@code PrivateKey} types, an algorithm-specific\n+ * subclass is returned if the algorithm is supported. For example, an\n+ * {@code ECPublicKey} or an {@code ECPrivateKey} for Elliptic Curve keys.\n@@ -81,1 +78,1 @@\n- * {@link PEMRecord}.\n+ * {@code PEM} object.\n@@ -83,12 +80,27 @@\n- * <p> The {@linkplain #decode(String, Class)} and\n- * {@linkplain #decode(InputStream, Class)} methods take a class parameter\n- * which determines the type of {@code DEREncodable} that is returned. These\n- * methods are useful when extracting or changing the return class.\n- * For example, if the PEM contains both public and private keys, the\n- * class parameter can specify which to return. Use\n- * {@code PrivateKey.class} to return only the private key.\n- * If the class parameter is set to {@code X509EncodedKeySpec.class}, the\n- * public key will be returned in that format.  Any type of PEM data can be\n- * decoded into a {@code PEMRecord} by specifying {@code PEMRecord.class}.\n- * If the class parameter doesn't match the PEM content, a\n- * {@linkplain ClassCastException} will be thrown.\n+ * <p> The {@link #decode(String, Class)} and {@link #decode(InputStream, Class)}\n+ * methods take a class parameter that specifies the type of {@code DEREncodable}\n+ * to return. These methods are useful for avoiding casts when the PEM type is\n+ * known, or when extracting a specific type if there is more than one option.\n+ * For example, if the PEM contains both a public and private key, specifying\n+ * {@code PrivateKey.class} returns only the private key.\n+ * If the class parameter specifies {@code X509EncodedKeySpec.class}, the\n+ * public key encoding is returned as an instance of {@code X509EncodedKeySpec}\n+ * class. Any type of PEM data can be decoded into a {@code PEM} object by\n+ * specifying {@code PEM.class}. If the class parameter does not match the PEM\n+ * content, a {@code ClassCastException} is thrown.\n+ *\n+ * <p> In addition to the types listed above, these methods support the\n+ * following PEM types and {@code DEREncodable} classes when specified as\n+ * parameters:\n+ *  <ul>\n+ *   <li>PUBLIC KEY : {@link X509EncodedKeySpec}<\/li>\n+ *   <li>PRIVATE KEY : {@link PKCS8EncodedKeySpec}<\/li>\n+ *   <li>PRIVATE KEY : {@link PublicKey} (if the encoding contains a public key)<\/li>\n+ *   <li>PRIVATE KEY : {@link X509EncodedKeySpec} (if the encoding contains a public key)<\/li>\n+ * <\/ul>\n+ * When used with a {@code PEMDecoder} instance configured for decryption:\n+ * <ul>\n+ *   <li>ENCRYPTED PRIVATE KEY : {@link PKCS8EncodedKeySpec}<\/li>\n+ *   <li>ENCRYPTED PRIVATE KEY : {@link PublicKey} (if the encoding contains a public key)<\/li>\n+ *   <li>ENCRYPTED PRIVATE KEY : {@link X509EncodedKeySpec} (if the encoding contains a public key)<\/li>\n+ * <\/ul>\n@@ -97,11 +109,9 @@\n- * with {@linkplain #withFactory(Provider)} and\/or\n- * {@linkplain #withDecryption(char[])}. {@linkplain #withFactory(Provider)}\n- * configures the decoder to use only {@linkplain KeyFactory} and\n- * {@linkplain CertificateFactory} instances from the given {@code Provider}.\n- * {@linkplain #withDecryption(char[])} configures the decoder to decrypt all\n- * encrypted private key PEM data using the given password.\n- * Configuring an instance for decryption does not prevent decoding with\n- * unencrypted PEM. Any encrypted PEM that fails decryption\n- * will throw a {@link RuntimeException}. When an encrypted private key PEM is\n- * used with a decoder not configured for decryption, an\n- * {@link EncryptedPrivateKeyInfo} object is returned.\n+ * with {@link #withFactory(Provider)} or {@link #withDecryption(char[])}.\n+ * The {@link #withFactory(Provider)} method uses the specified provider\n+ * to produce cryptographic objects from {@link KeyFactory} and\n+ * {@link CertificateFactory}. The {@link #withDecryption(char[])} method configures the\n+ * decoder to decrypt and decode encrypted private key PEM data using the given\n+ * password.  If decryption fails, an {@link IllegalArgumentException} is thrown.\n+ * If an encrypted private key PEM is processed by a decoder not configured\n+ * for decryption, an {@link EncryptedPrivateKeyInfo} object is returned.\n+ * A {@code PEMDecoder} configured for decryption will decode unencrypted PEM.\n@@ -109,1 +119,1 @@\n- * <p>This class is immutable and thread-safe.\n+ * <p> This class is immutable and thread-safe.\n@@ -111,1 +121,1 @@\n- * <p> Here is an example of decoding a {@code PrivateKey} object:\n+ * <p> Example: decode a private key:\n@@ -117,2 +127,1 @@\n- * <p> Here is an example of a {@code PEMDecoder} configured with decryption\n- * and a factory provider:\n+ * <p> Example: configure decryption and a factory provider:\n@@ -121,2 +130,2 @@\n- *         withFactory(provider);\n- *     byte[] pemData = pd.decode(privKey);\n+ *             withFactory(provider);\n+ *     DEREncodable pemData = pd.decode(privKeyPEM);\n@@ -125,4 +134,4 @@\n- * @implNote An implementation may support other PEM types and\n- * {@code DEREncodable} objects. This implementation additionally supports\n- * the following PEM types:  {@code X509 CERTIFICATE},\n- * {@code X.509 CERTIFICATE}, {@code CRL}, and {@code RSA PRIVATE KEY}.\n+ * @implNote This implementation decodes RSA PRIVATE KEY as {@code PrivateKey},\n+ * X509 CERTIFICATE and X.509 CERTIFICATE as {@code X509Certificate},\n+ * and CRL as {@code X509CRL}. Other implementations may recognize\n+ * additional PEM types.\n@@ -131,1 +140,1 @@\n- * @see PEMRecord\n+ * @see PEM\n@@ -136,0 +145,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc5958\n+ *       RFC 5958: Asymmetric Key Packages\n@@ -145,1 +156,1 @@\n-    private final PBEKeySpec password;\n+    private final PBEKeySpec keySpec;\n@@ -157,1 +168,1 @@\n-        password = withPassword;\n+        keySpec = withPassword;\n@@ -159,0 +170,4 @@\n+        if (withPassword != null) {\n+            final var k = this.keySpec;\n+            CleanerFactory.cleaner().register(this, k::clearPassword);\n+        }\n@@ -175,1 +190,1 @@\n-    private DEREncodable decode(PEMRecord pem) {\n+    private DEREncodable decode(PEM pem) {\n@@ -188,5 +203,4 @@\n-                    PKCS8Key p8key = new PKCS8Key(decoder.decode(pem.content()));\n-                    String algo = p8key.getAlgorithm();\n-                    KeyFactory kf = getKeyFactory(algo);\n-                    DEREncodable d = kf.generatePrivate(\n-                        new PKCS8EncodedKeySpec(p8key.getEncoded(), algo));\n+                    DEREncodable d;\n+                    PKCS8Key p8key = null;\n+                    PKCS8EncodedKeySpec p8spec = null;\n+                    byte[] encoding = decoder.decode(pem.content());\n@@ -194,7 +208,6 @@\n-                    \/\/ Look for a public key inside the pkcs8 encoding.\n-                    if (p8key.getPubKeyEncoded() != null) {\n-                        \/\/ Check if this is a OneAsymmetricKey encoding\n-                        X509EncodedKeySpec spec = new X509EncodedKeySpec(\n-                            p8key.getPubKeyEncoded(), algo);\n-                        yield new KeyPair(getKeyFactory(algo).\n-                            generatePublic(spec), (PrivateKey) d);\n+                    try {\n+                        p8key = new PKCS8Key(encoding);\n+                        String algo = p8key.getAlgorithm();\n+                        KeyFactory kf = getKeyFactory(algo);\n+                        p8spec = new PKCS8EncodedKeySpec(encoding, algo);\n+                        d = kf.generatePrivate(p8spec);\n@@ -202,12 +215,22 @@\n-                    } else if (d instanceof PKCS8Key p8 &&\n-                        p8.getPubKeyEncoded() != null) {\n-                        \/\/ If the KeyFactory decoded an algorithm-specific\n-                        \/\/ encodings, look for the public key again.  This\n-                        \/\/ happens with EC and SEC1-v2 encoding\n-                        X509EncodedKeySpec spec = new X509EncodedKeySpec(\n-                            p8.getPubKeyEncoded(), algo);\n-                        yield new KeyPair(getKeyFactory(algo).\n-                            generatePublic(spec), p8);\n-                    } else {\n-                        \/\/ No public key, return the private key.\n-                        yield d;\n+                        \/\/ Look for a public key inside the pkcs8 encoding.\n+                        if (p8key.getPubKeyEncoded() != null) {\n+                            \/\/ Check if this is a OneAsymmetricKey encoding\n+                            X509EncodedKeySpec spec = new X509EncodedKeySpec(\n+                                p8key.getPubKeyEncoded(), algo);\n+                            yield new KeyPair(getKeyFactory(algo).\n+                                generatePublic(spec), (PrivateKey) d);\n+\n+                        } else if (d instanceof PKCS8Key p8 &&\n+                            p8.getPubKeyEncoded() != null) {\n+                            \/\/ If the KeyFactory decoded an algorithm-specific\n+                            \/\/ encodings, look for the public key again.\n+                            X509EncodedKeySpec spec = new X509EncodedKeySpec(\n+                                p8.getPubKeyEncoded(), algo);\n+                            yield new KeyPair(getKeyFactory(algo).\n+                                generatePublic(spec), (PrivateKey) d);\n+                        } else {\n+                            \/\/ No public key, return the private key.\n+                            yield d;\n+                        }\n+                    } finally {\n+                        KeyUtil.clear(encoding, p8spec, p8key);\n@@ -217,3 +240,13 @@\n-                    if (password == null) {\n-                        yield new EncryptedPrivateKeyInfo(decoder.decode(\n-                            pem.content()));\n+                    byte[] p8 = null;\n+                    byte[] encoding = null;\n+                    try {\n+                        encoding = decoder.decode(pem.content());\n+                        var ekpi = new EncryptedPrivateKeyInfo(encoding);\n+                        if (keySpec == null) {\n+                            yield ekpi;\n+                        }\n+                        p8 = Pem.decryptEncoding(ekpi, keySpec);\n+                        yield Pem.toDEREncodable(p8, true, factory);\n+                    } finally {\n+                        Reference.reachabilityFence(this);\n+                        KeyUtil.clear(encoding, p8);\n@@ -221,2 +254,0 @@\n-                    yield new EncryptedPrivateKeyInfo(decoder.decode(pem.content())).\n-                        getKey(password.getPassword());\n@@ -249,1 +280,1 @@\n-     * Decodes and returns a {@link DEREncodable} from the given {@code String}.\n+     * Decodes and returns a {@code DEREncodable} from the given {@code String}.\n@@ -255,7 +286,6 @@\n-     * <p> This method returns a Java API cryptographic object,\n-     * such as a {@code PrivateKey}, if the PEM type is supported.\n-     * Any non-PEM data preceding the PEM header is ignored by the decoder.\n-     * Otherwise, a {@link PEMRecord} will be returned containing\n-     * the type identifier and Base64-encoded data.\n-     * Any non-PEM data preceding the PEM header will be stored in\n-     * {@code leadingData}.\n+     * <p> A {@code DEREncodable} will be returned that best represents the\n+     * decoded data.  If the PEM type is not supported, a {@code PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the {@code DEREncodable} object.\n@@ -266,1 +296,1 @@\n-     * @param str a String containing PEM data\n+     * @param str a {@code String} containing PEM data\n@@ -268,3 +298,2 @@\n-     * @throws IllegalArgumentException on error in decoding or no PEM data\n-     * found\n-     * @throws NullPointerException when {@code str} is null\n+     * @throws IllegalArgumentException on error in decoding or no PEM data found\n+     * @throws NullPointerException when {@code str} is {@code null}\n@@ -284,1 +313,1 @@\n-     * Decodes and returns a {@link DEREncodable} from the given\n+     * Decodes and returns a {@code DEREncodable} from the given\n@@ -288,1 +317,1 @@\n-     * the PEM footer or the end of the stream. If an I\/O error occurs,\n+     * a PEM footer or the end of the stream. If an I\/O error occurs,\n@@ -293,7 +322,6 @@\n-     * <p> This method returns a Java API cryptographic object,\n-     * such as a {@code PrivateKey}, if the PEM type is supported.\n-     * Any non-PEM data preceding the PEM header is ignored by the decoder.\n-     * Otherwise, a {@link PEMRecord} will be returned containing\n-     * the type identifier and Base64-encoded data.\n-     * Any non-PEM data preceding the PEM header will be stored in\n-     * {@code leadingData}.\n+     * <p> A {@code DEREncodable} will be returned that best represents the\n+     * decoded data.  If the PEM type is not supported, a {@code PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the {@code DEREncodable} object.\n@@ -301,2 +329,1 @@\n-     * <p> If no PEM data is found, an {@code IllegalArgumentException} is\n-     * thrown.\n+     * <p> If no PEM data is found, an {@code EOFException} is thrown.\n@@ -304,1 +331,1 @@\n-     * @param is InputStream containing PEM data\n+     * @param is {@code InputStream} containing PEM data\n@@ -308,1 +335,2 @@\n-     * @throws EOFException at the end of the {@code InputStream}\n+     * @throws EOFException no PEM data found or unexpectedly reached the\n+     *   end of the {@code InputStream}\n@@ -310,1 +338,1 @@\n-     * @throws NullPointerException when {@code is} is null\n+     * @throws NullPointerException when {@code is} is {@code null}\n@@ -314,1 +342,1 @@\n-        PEMRecord pem = Pem.readPEM(is);\n+        PEM pem = Pem.readPEM(is);\n@@ -320,2 +348,2 @@\n-     * the given PEM string. {@code tClass} must extend {@link DEREncodable}\n-     * and be an appropriate class for the PEM type.\n+     * the given PEM string. {@code tClass} must be an appropriate class for\n+     * the PEM type.\n@@ -327,5 +355,5 @@\n-     * <p> If the class parameter is {@code PEMRecord.class},\n-     * a {@linkplain PEMRecord} is returned containing the\n-     * type identifier and Base64 encoding. Any non-PEM data preceding\n-     * the PEM header will be stored in {@code leadingData}.  Other\n-     * class parameters will not return preceding non-PEM data.\n+     * <p> If the class parameter is {@code PEM.class}, a {@code PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the {@code DEREncodable} object.\n@@ -336,4 +364,4 @@\n-     * @param <S> Class type parameter that extends {@code DEREncodable}\n-     * @param str the String containing PEM data\n-     * @param tClass the returned object class that implements\n-     * {@code DEREncodable}\n+     * @param <S> class type parameter that extends {@code DEREncodable}\n+     * @param str the {@code String} containing PEM data\n+     * @param tClass the returned object class that extends or implements\n+     *   {@code DEREncodable}\n@@ -341,4 +369,3 @@\n-     * @throws IllegalArgumentException on error in decoding or no PEM data\n-     * found\n-     * @throws ClassCastException if {@code tClass} is invalid for the PEM type\n-     * @throws NullPointerException when any input values are null\n+     * @throws IllegalArgumentException on error in decoding or no PEM data found\n+     * @throws ClassCastException if {@code tClass} does not represent the PEM type\n+     * @throws NullPointerException when any input values are {@code null}\n@@ -358,3 +385,3 @@\n-     * Decodes and returns the specified class for the given\n-     * {@link InputStream}.  The class must extend {@link DEREncodable} and be\n-     * an appropriate class for the PEM type.\n+     * Decodes and returns a {@code DEREncodable} of the specified class for the\n+     * given {@code InputStream}. {@code tClass} must be an appropriate class\n+     * for the PEM type.\n@@ -363,1 +390,1 @@\n-     * the PEM footer or the end of the stream. If an I\/O error occurs,\n+     * a PEM footer or the end of the stream. If an I\/O error occurs,\n@@ -368,5 +395,5 @@\n-     * <p> If the class parameter is {@code PEMRecord.class},\n-     * a {@linkplain PEMRecord} is returned containing the\n-     * type identifier and Base64 encoding. Any non-PEM data preceding\n-     * the PEM header will be stored in {@code leadingData}.  Other\n-     * class parameters will not return preceding non-PEM data.\n+     * <p> If the class parameter is {@code PEM.class}, a {@code PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the {@code DEREncodable} object.\n@@ -374,2 +401,1 @@\n-     * <p> If no PEM data is found, an {@code IllegalArgumentException} is\n-     * thrown.\n+     * <p> If no PEM data is found, an {@code EOFException} is thrown.\n@@ -377,3 +403,3 @@\n-     * @param <S> Class type parameter that extends {@code DEREncodable}.\n-     * @param is an InputStream containing PEM data\n-     * @param tClass the returned object class that implements\n+     * @param <S> class type parameter that extends {@code DEREncodable}.\n+     * @param is an {@code InputStream} containing PEM data\n+     * @param tClass the returned object class that extends or implements\n@@ -383,2 +409,3 @@\n-     * {@code InputStream} did not complete decoding.\n-     * @throws EOFException at the end of the {@code InputStream}\n+     *   {@code InputStream} did not complete decoding.\n+     * @throws EOFException no PEM data found or unexpectedly reached the\n+     *   end of the {@code InputStream}\n@@ -386,2 +413,2 @@\n-     * @throws ClassCastException if {@code tClass} is invalid for the PEM type\n-     * @throws NullPointerException when any input values are null\n+     * @throws ClassCastException if {@code tClass} does not represent the PEM type\n+     * @throws NullPointerException when any input values are {@code null}\n@@ -389,1 +416,1 @@\n-     * @see #decode(InputStream)\n+    * @see #decode(InputStream)\n@@ -396,1 +423,1 @@\n-        PEMRecord pem = Pem.readPEM(is);\n+        PEM pem = Pem.readPEM(is);\n@@ -398,1 +425,1 @@\n-        if (tClass.isAssignableFrom(PEMRecord.class)) {\n+        if (tClass.isAssignableFrom(PEM.class)) {\n@@ -481,2 +508,2 @@\n-     * {@link KeyFactory} and {@link CertificateFactory} implementations\n-     * from the specified {@link Provider} to produce cryptographic objects.\n+     * {@code KeyFactory} and {@code CertificateFactory} implementations\n+     * from the specified {@code Provider} to produce cryptographic objects.\n@@ -486,2 +513,2 @@\n-     * @return a new PEMEncoder instance configured to the {@code Provider}.\n-     * @throws NullPointerException if {@code provider} is null\n+     * @return a new {@code PEMDecoder} instance configured with the {@code Provider}\n+     * @throws NullPointerException if {@code provider} is {@code null}\n@@ -491,1 +518,1 @@\n-        return new PEMDecoder(provider, password);\n+        return new PEMDecoder(provider, keySpec);\n@@ -497,1 +524,1 @@\n-     * Non-encrypted PEM can still be decoded from this instance.\n+     * Non-encrypted PEM can also be decoded from this instance.\n@@ -499,1 +526,1 @@\n-     * @param password the password to decrypt encrypted PEM data.  This array\n+     * @param password the password to decrypt the encrypted PEM data. This array\n@@ -501,2 +528,2 @@\n-     * @return a new PEMEncoder instance configured for decryption\n-     * @throws NullPointerException if {@code password} is null\n+     * @return a new {@code PEMDecoder} instance configured for decryption\n+     * @throws NullPointerException if {@code password} is {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":192,"deletions":165,"binary":false,"changes":357,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n+import sun.security.util.KeyUtil;\n@@ -33,1 +32,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -44,1 +42,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -48,1 +45,1 @@\n- * data.  PEM is a textual encoding used to store and transfer security\n+ * data.  PEM is a textual encoding used to store and transfer cryptographic\n@@ -50,2 +47,2 @@\n- * lists (CRL).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n- * Base64-formatted binary encoding enclosed by a type-identifying header\n+ * lists (CRLs).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n+ * Base64-encoded binary encoding enclosed by a type-identifying header\n@@ -54,1 +51,1 @@\n- * <p> Encoding may be performed on Java API cryptographic objects that\n+ * <p> Encoding can be performed on cryptographic objects that\n@@ -57,1 +54,1 @@\n- * into PEM and return the data in a byte array or String.\n+ * into PEM and return the data in a byte array or {@code String}.\n@@ -60,1 +57,1 @@\n- * {@code PEMEncoder} with the {@linkplain #withEncryption(char[])} method,\n+ * {@code PEMEncoder} with the {@link #withEncryption(char[])} method,\n@@ -63,1 +60,1 @@\n- * private key encrypted as an {@code EncryptedKeyInfo} object can be encoded\n+ * private key encrypted as an {@link EncryptedPrivateKeyInfo} object can be encoded\n@@ -67,1 +64,1 @@\n- * <p> PKCS #8 2.0 defines the ASN.1 OneAsymmetricKey structure, which may\n+ * <p> PKCS #8 v2.0 defines the ASN.1 OneAsymmetricKey structure, which may\n@@ -69,1 +66,1 @@\n- * {@link KeyPair} objects passed to the {@code encode} or\n+ * {@code KeyPair} objects passed to the {@code encode} or\n@@ -73,8 +70,4 @@\n- * <p> When encoding a {@link PEMRecord}, the API surrounds the\n- * {@linkplain PEMRecord#content()} with the PEM header and footer\n- * from {@linkplain PEMRecord#type()}. {@linkplain PEMRecord#leadingData()} is\n- * not included in the encoding.  {@code PEMRecord} will not perform\n- * validity checks on the data.\n- *\n- * <p>The following lists the supported {@code DEREncodable} classes and\n- * the PEM types that each are encoded as:\n+ * <p> When encoding a {@link PEM} object, the API surrounds\n+ * {@link PEM#content()} with a PEM header and footer based on\n+ * {@link PEM#type()}. The value returned by {@link PEM#leadingData()} is not\n+ * included in the output.\n@@ -82,0 +75,14 @@\n+ * <p> The following lists the supported {@code DEREncodable} classes and\n+ * the PEM types they encode as:\n+ * <ul>\n+ *   <li>{@link X509Certificate} : CERTIFICATE<\/li>\n+ *   <li>{@link X509CRL} : X509 CRL<\/li>\n+ *   <li>{@link PublicKey} : PUBLIC KEY<\/li>\n+ *   <li>{@link PrivateKey} : PRIVATE KEY<\/li>\n+ *   <li>{@link EncryptedPrivateKeyInfo} : ENCRYPTED PRIVATE KEY<\/li>\n+ *   <li>{@link KeyPair} : PRIVATE KEY<\/li>\n+ *   <li>{@link X509EncodedKeySpec} : PUBLIC KEY<\/li>\n+ *   <li>{@link PKCS8EncodedKeySpec} : PRIVATE KEY<\/li>\n+ *   <li>{@link PEM} : {@code PEM.type()}<\/li>\n+ * <\/ul>\n+ * <p> When used with a {@code PEMEncoder} instance configured for encryption:\n@@ -83,12 +90,4 @@\n- *  <li>{@code X509Certificate} : CERTIFICATE<\/li>\n- *  <li>{@code X509CRL} : X509 CRL<\/li>\n- *  <li>{@code PublicKey}: PUBLIC KEY<\/li>\n- *  <li>{@code PrivateKey} : PRIVATE KEY<\/li>\n- *  <li>{@code PrivateKey} (if configured with encryption):\n- *  ENCRYPTED PRIVATE KEY<\/li>\n- *  <li>{@code EncryptedPrivateKeyInfo} : ENCRYPTED PRIVATE KEY<\/li>\n- *  <li>{@code KeyPair} : PRIVATE KEY<\/li>\n- *  <li>{@code X509EncodedKeySpec} : PUBLIC KEY<\/li>\n- *  <li>{@code PKCS8EncodedKeySpec} : PRIVATE KEY<\/li>\n- *  <li>{@code PEMRecord} : {@code PEMRecord.type()}<\/li>\n- *  <\/ul>\n+ *   <li>{@link PrivateKey} : ENCRYPTED PRIVATE KEY<\/li>\n+ *   <li>{@link KeyPair} : ENCRYPTED PRIVATE KEY<\/li>\n+ *   <li>{@link PKCS8EncodedKeySpec} : ENCRYPTED PRIVATE KEY<\/li>\n+ * <\/ul>\n@@ -98,1 +97,1 @@\n- * <p> Here is an example of encoding a {@code PrivateKey} object:\n+ * <p> Example: encode a private key:\n@@ -104,2 +103,1 @@\n- * <p> Here is an example that encrypts and encodes a private key using the\n- * specified password:\n+ * <p> Example: encrypt and encode a private key using a password:\n@@ -111,2 +109,1 @@\n- * @implNote An implementation may support other PEM types and\n- * {@code DEREncodable} objects.\n+ * @implNote Implementations may support additional PEM types.\n@@ -116,1 +113,1 @@\n- * @see PEMRecord\n+ * @see PEM\n@@ -121,0 +118,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc5958\n+ *       RFC 5958: Asymmetric Key Packages\n@@ -131,8 +130,2 @@\n-\n-    \/\/ Stores the password for an encrypted encoder that isn't setup yet.\n-    private PBEKeySpec keySpec;\n-    \/\/ Stores the key after the encoder is ready to encrypt.  The prevents\n-    \/\/ repeated SecretKeyFactory calls if the encoder is used on multiple keys.\n-    private SecretKey key;\n-    \/\/ Makes SecretKeyFactory generation thread-safe.\n-    private final ReentrantLock lock;\n+    \/\/ PBE key for encryption\n+    private final Key key;\n@@ -141,3 +134,1 @@\n-     * Instantiate a {@code PEMEncoder} for Encrypted Private Keys.\n-     *\n-     * @param pbe contains the password spec used for encryption.\n+     * Create an encrypted {@code PEMEncoder} instance.\n@@ -145,4 +136,14 @@\n-    private PEMEncoder(PBEKeySpec pbe) {\n-        keySpec = pbe;\n-        key = null;\n-        lock = new ReentrantLock();\n+    private PEMEncoder(PBEKeySpec keySpec) {\n+        if (keySpec != null) {\n+            try {\n+                key = SecretKeyFactory.getInstance(Pem.DEFAULT_ALGO).\n+                    generateSecret(keySpec);\n+            } catch (GeneralSecurityException e) {\n+                throw new IllegalArgumentException(\"Operation failed: \" +\n+                    \"unable to generate key or locate a valid algorithm. \" +\n+                    \"Check the jdk.epkcs8.defaultAlgorithm security \" +\n+                    \"property for a valid configuration.\", e);\n+            }\n+        } else {\n+            key = null;\n+        }\n@@ -161,1 +162,1 @@\n-     * Encodes the specified {@code DEREncodable} and returns a PEM encoded\n+     * Encodes the specified {@code DEREncodable} and returns a PEM-encoded\n@@ -165,3 +166,2 @@\n-     * @return a {@code String} containing the PEM encoded data\n-     * @throws IllegalArgumentException if the {@code DEREncodable} cannot be\n-     * encoded\n+     * @return a {@code String} containing the PEM-encoded data\n+     * @throws IllegalArgumentException if the {@code DEREncodable} cannot be encoded\n@@ -174,6 +174,7 @@\n-            case PublicKey pu -> buildKey(null, pu.getEncoded());\n-            case PrivateKey pr -> buildKey(pr.getEncoded(), null);\n-            case KeyPair kp -> {\n-                if (kp.getPublic() == null) {\n-                    throw new IllegalArgumentException(\"KeyPair does not \" +\n-                        \"contain PublicKey.\");\n+            case PublicKey pu -> buildKey(pu.getEncoded(), null);\n+            case PrivateKey pr -> {\n+                byte[] encoding = pr.getEncoded();\n+                try {\n+                    yield buildKey(null, encoding);\n+                } finally {\n+                    KeyUtil.clear(encoding);\n@@ -181,3 +182,16 @@\n-                if (kp.getPrivate() == null) {\n-                    throw new IllegalArgumentException(\"KeyPair does not \" +\n-                        \"contain PrivateKey.\");\n+            }\n+            case KeyPair kp -> {\n+                byte[] encoding = null;\n+                try {\n+                    if (kp.getPublic() == null) {\n+                        throw new IllegalArgumentException(\"KeyPair does not \" +\n+                            \"contain PublicKey.\");\n+                    }\n+                    if (kp.getPrivate() == null) {\n+                        throw new IllegalArgumentException(\"KeyPair does not \" +\n+                            \"contain PrivateKey.\");\n+                    }\n+                    encoding = kp.getPrivate().getEncoded();\n+                    yield buildKey(kp.getPublic().getEncoded(), encoding);\n+                } finally {\n+                    KeyUtil.clear(encoding);\n@@ -185,2 +199,0 @@\n-                yield buildKey(kp.getPrivate().getEncoded(),\n-                    kp.getPublic().getEncoded());\n@@ -189,1 +201,1 @@\n-                buildKey(null, x.getEncoded());\n+                buildKey(x.getEncoded(), null);\n@@ -191,1 +203,1 @@\n-                buildKey(p.getEncoded(), null);\n+                buildKey(null, p.getEncoded());\n@@ -193,0 +205,1 @@\n+                byte[] encoding = null;\n@@ -194,2 +207,2 @@\n-                    yield Pem.pemEncoded(Pem.ENCRYPTED_PRIVATE_KEY,\n-                        epki.getEncoded());\n+                    encoding = epki.getEncoded();\n+                    yield Pem.pemEncoded(Pem.ENCRYPTED_PRIVATE_KEY, encoding);\n@@ -198,0 +211,2 @@\n+                } finally {\n+                    KeyUtil.clear(encoding);\n@@ -202,1 +217,1 @@\n-                    if (isEncrypted()) {\n+                    if (key != null) {\n@@ -213,1 +228,1 @@\n-                    if (isEncrypted()) {\n+                    if (key != null) {\n@@ -222,3 +237,3 @@\n-            case PEMRecord rec -> {\n-                if (isEncrypted()) {\n-                    throw new IllegalArgumentException(\"PEMRecord cannot be \" +\n+            case PEM rec -> {\n+                if (key != null) {\n+                    throw new IllegalArgumentException(\"PEM cannot be \" +\n@@ -236,2 +251,2 @@\n-     * Encodes the specified {@code DEREncodable} and returns the PEM encoding\n-     * in a byte array.\n+     * Encodes the specified {@code DEREncodable} and returns a PEM-encoded\n+     * byte array.\n@@ -240,3 +255,2 @@\n-     * @return a PEM encoded byte array\n-     * @throws IllegalArgumentException if the {@code DEREncodable} cannot be\n-     * encoded\n+     * @return a PEM-encoded byte array\n+     * @throws IllegalArgumentException if the {@code DEREncodable} cannot be encoded\n@@ -251,2 +265,2 @@\n-     * Returns a new {@code PEMEncoder} instance configured for encryption\n-     * with the default algorithm and a given password.\n+     * Returns a copy of this PEMEncoder that encrypts and encodes\n+     * using the specified password and default encryption algorithm.\n@@ -254,2 +268,3 @@\n-     * <p> Only {@link PrivateKey} objects can be encrypted with this newly\n-     * configured instance.  Encoding other {@link DEREncodable} objects will\n+     * <p> Only {@code PrivateKey}, {@code KeyPair}, and\n+     * {@code PKCS8EncodedKeySpec} objects can be encoded with this newly\n+     * configured instance.  Encoding other {@code DEREncodable} objects will\n@@ -258,6 +273,5 @@\n-     * @implNote\n-     * The default password-based encryption algorithm is defined\n-     * by the {@code jdk.epkcs8.defaultAlgorithm} security property and\n-     * uses the default encryption parameters of the provider that is selected.\n-     * For greater flexibility with encryption options and parameters, use\n-     * {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, Key,\n+     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} security property\n+     * defines the default encryption algorithm. The {@code AlgorithmParameterSpec}\n+     * defaults are determined by the provider. To use non-default encryption\n+     * parameters, or to encrypt with a different encryption provider, use\n+     * {@link EncryptedPrivateKeyInfo#encrypt(DEREncodable, Key,\n@@ -268,1 +282,1 @@\n-     *                stored in the new instance.\n+     *                 stored in the new instance.\n@@ -270,1 +284,2 @@\n-     * @throws NullPointerException when password is {@code null}\n+     * @throws NullPointerException if password is {@code null}\n+     * @throws IllegalArgumentException if generating the encryption key fails\n@@ -273,1 +288,0 @@\n-        \/\/ PBEKeySpec clones the password\n@@ -275,1 +289,6 @@\n-        return new PEMEncoder(new PBEKeySpec(password));\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        try {\n+            return new PEMEncoder(keySpec);\n+        } finally {\n+            keySpec.clearPassword();\n+        }\n@@ -280,0 +299,2 @@\n+     *\n+     * privateKeyEncoding will be zeroed when the method returns\n@@ -281,5 +302,2 @@\n-    private String buildKey(byte[] privateBytes, byte[] publicBytes) {\n-        DerOutputStream out = new DerOutputStream();\n-        Cipher cipher;\n-\n-        if (privateBytes == null && publicBytes == null) {\n+    private String buildKey(byte[] publicEncoding, byte[] privateEncoding) {\n+        if (publicEncoding == null && privateEncoding == null) {\n@@ -290,23 +308,3 @@\n-        \/\/ If `keySpec` is non-null, then `key` hasn't been established.\n-        \/\/ Setting a `key` prevents repeated key generation operations.\n-        \/\/ withEncryption() is a configuration method and cannot throw an\n-        \/\/ exception; therefore generation is delayed.\n-        if (keySpec != null) {\n-            \/\/ For thread safety\n-            lock.lock();\n-            if (key == null) {\n-                try {\n-                    key = SecretKeyFactory.getInstance(Pem.DEFAULT_ALGO).\n-                        generateSecret(keySpec);\n-                    keySpec.clearPassword();\n-                    keySpec = null;\n-                } catch (GeneralSecurityException e) {\n-                    throw new IllegalArgumentException(\"Security property \" +\n-                        \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n-                        \"valid algorithm.  Operation cannot be performed.\", e);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                lock.unlock();\n-            }\n+        if (publicEncoding != null && publicEncoding.length == 0) {\n+            throw new IllegalArgumentException(\"Public key has no \" +\n+                \"encoding\");\n@@ -315,15 +313,4 @@\n-        \/\/ If `key` is non-null, this is an encoder ready to encrypt.\n-        if (key != null) {\n-            if (privateBytes == null || publicBytes != null) {\n-                throw new IllegalArgumentException(\"Can only encrypt a \" +\n-                    \"PrivateKey.\");\n-            }\n-\n-            try {\n-                cipher = Cipher.getInstance(Pem.DEFAULT_ALGO);\n-                cipher.init(Cipher.ENCRYPT_MODE, key);\n-            } catch (GeneralSecurityException e) {\n-                throw new IllegalArgumentException(\"Security property \" +\n-                    \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n-                    \"valid algorithm.  Operation cannot be performed.\", e);\n-            }\n+        if (privateEncoding != null && privateEncoding.length == 0) {\n+            throw new IllegalArgumentException(\"Private key has no \" +\n+                \"encoding\");\n+        }\n@@ -331,9 +318,3 @@\n-            try {\n-                new AlgorithmId(Pem.getPBEID(Pem.DEFAULT_ALGO),\n-                    cipher.getParameters()).encode(out);\n-                out.putOctetString(cipher.doFinal(privateBytes));\n-                return Pem.pemEncoded(Pem.ENCRYPTED_PRIVATE_KEY,\n-                    DerValue.wrap(DerValue.tag_Sequence, out).toByteArray());\n-            } catch (GeneralSecurityException e) {\n-                throw new IllegalArgumentException(e);\n-            }\n+        if (key != null && privateEncoding == null) {\n+            throw new IllegalArgumentException(\"This DEREncodable cannot \" +\n+                \"be encrypted.\");\n@@ -343,7 +324,2 @@\n-        if (publicBytes != null && privateBytes == null) {\n-            if (publicBytes.length == 0) {\n-                throw new IllegalArgumentException(\"No public key encoding \" +\n-                    \"given by the DEREncodable.\");\n-            }\n-\n-            return Pem.pemEncoded(Pem.PUBLIC_KEY, publicBytes);\n+        if (publicEncoding != null && privateEncoding == null) {\n+            return Pem.pemEncoded(Pem.PUBLIC_KEY, publicEncoding);\n@@ -352,3 +328,16 @@\n-        \/\/ PKCS8 only\n-        if (publicBytes == null && privateBytes != null) {\n-            if (privateBytes.length == 0) {\n+        byte[] encoding = null;\n+        PKCS8EncodedKeySpec p8KeySpec = null;\n+        try {\n+            if (publicEncoding == null) {\n+                encoding = privateEncoding;\n+            } else {\n+                encoding = PKCS8Key.getEncoded(publicEncoding,\n+                    privateEncoding);\n+            }\n+            if (key != null) {\n+                p8KeySpec = new PKCS8EncodedKeySpec(encoding);\n+                encoding = EncryptedPrivateKeyInfo.encrypt(p8KeySpec, key,\n+                    Pem.DEFAULT_ALGO, null, null, null).\n+                    getEncoded();\n+            }\n+            if (encoding.length == 0) {\n@@ -358,17 +347,3 @@\n-\n-            return Pem.pemEncoded(Pem.PRIVATE_KEY, privateBytes);\n-        }\n-\n-        \/\/ OneAsymmetricKey\n-        if (privateBytes.length == 0) {\n-            throw new IllegalArgumentException(\"No private key encoding \" +\n-                \"given by the DEREncodable.\");\n-        }\n-\n-        if (publicBytes.length == 0) {\n-            throw new IllegalArgumentException(\"No public key encoding \" +\n-                \"given by the DEREncodable.\");\n-        }\n-        try {\n-            return Pem.pemEncoded(Pem.PRIVATE_KEY,\n-                PKCS8Key.getEncoded(publicBytes, privateBytes));\n+            return Pem.pemEncoded(\n+                (key == null ? Pem.PRIVATE_KEY : Pem.ENCRYPTED_PRIVATE_KEY),\n+                encoding);\n@@ -376,1 +351,3 @@\n-            throw new IllegalArgumentException(e);\n+            throw new IllegalArgumentException(\"Error while encoding\", e);\n+        } finally {\n+            KeyUtil.clear(encoding, p8KeySpec);\n@@ -379,4 +356,0 @@\n-\n-    private boolean isEncrypted() {\n-        return (key != null || keySpec != null);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":154,"deletions":181,"binary":false,"changes":335,"status":"modified"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.security;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-import sun.security.util.Pem;\n-\n-import java.util.Objects;\n-\n-\/**\n- * {@code PEMRecord} is a {@link DEREncodable} that represents Privacy-Enhanced\n- * Mail (PEM) data by its type and Base64 form.  {@link PEMDecoder} and\n- * {@link PEMEncoder} use {@code PEMRecord} when representing the data as a\n- * cryptographic object is not desired or the type has no\n- * {@code DEREncodable}.\n- *\n- * <p> {@code type} and {@code content} may not be {@code null}.\n- * {@code leadingData} may be null if no non-PEM data preceded PEM header\n- * during decoding.  {@code leadingData} may be useful for reading metadata\n- * that accompanies PEM data.\n- *\n- * <p> No validation is performed during instantiation to ensure that\n- * {@code type} conforms to {@code RFC 7468}, that {@code content} is valid\n- * Base64, or that {@code content} matches the {@code type}.\n- * {@code leadingData} is not defensively copied and does not return a\n- * clone when {@linkplain #leadingData()} is called.\n- *\n- * @param type the type identifier in the PEM header without PEM syntax labels.\n- *           For a public key, {@code type} would be \"PUBLIC KEY\".\n- * @param content the Base64-encoded data, excluding the PEM header and footer\n- * @param leadingData any non-PEM data preceding the PEM header when decoding.\n- *\n- * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n- *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n- *\n- * @see PEMDecoder\n- * @see PEMEncoder\n- *\n- * @since 25\n- *\/\n-@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n-public record PEMRecord(String type, String content, byte[] leadingData)\n-    implements DEREncodable {\n-\n-    \/**\n-     * Creates a {@code PEMRecord} instance with the given parameters.\n-     *\n-     * @param type the type identifier\n-     * @param content the Base64-encoded data, excluding the PEM header and\n-     *               footer\n-     * @param leadingData any non-PEM data read during the decoding process\n-     *                    before the PEM header.  This value maybe {@code null}.\n-     * @throws IllegalArgumentException if {@code type} is incorrectly\n-     * formatted.\n-     * @throws NullPointerException if {@code type} and\/or {@code content} are\n-     * {@code null}.\n-     *\/\n-    public PEMRecord {\n-        Objects.requireNonNull(type, \"\\\"type\\\" cannot be null.\");\n-        Objects.requireNonNull(content, \"\\\"content\\\" cannot be null.\");\n-\n-        \/\/ With no validity checking on `type`, the constructor accept anything\n-        \/\/ including lowercase.  The onus is on the caller.\n-        if (type.startsWith(\"-\") || type.startsWith(\"BEGIN \") ||\n-            type.startsWith(\"END \")) {\n-            throw new IllegalArgumentException(\"PEM syntax labels found.  \" +\n-                \"Only the PEM type identifier is allowed\");\n-        }\n-\n-    }\n-\n-    \/**\n-     * Creates a {@code PEMRecord} instance with a given {@code type} and\n-     * {@code content} data in String form.  {@code leadingData} is set to null.\n-     *\n-     * @param type the PEM type identifier\n-     * @param content the Base64-encoded data, excluding the PEM header and\n-     *               footer\n-     * @throws IllegalArgumentException if {@code type} is incorrectly\n-     * formatted.\n-     * @throws NullPointerException if {@code type} and\/or {@code content} are\n-     * {@code null}.\n-     *\/\n-    public PEMRecord(String type, String content) {\n-        this(type, content, null);\n-    }\n-\n-    \/**\n-     * Returns the type and Base64 encoding in PEM format.  {@code leadingData}\n-     * is not returned by this method.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return Pem.pemEncoded(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -279,2 +279,1 @@\n-     * @exception NullPointerException if {@code cipher}\n-     * is {@code null}.\n+     * @exception NullPointerException if {@code cipher} is {@code null}.\n@@ -299,4 +298,3 @@\n-    private PKCS8EncodedKeySpec getKeySpecImpl(Key decryptKey,\n-        Provider provider) throws NoSuchAlgorithmException,\n-        InvalidKeyException {\n-        byte[] encoded;\n+    \/\/ Return the decrypted encryptedData in this instance.\n+    private byte[] decryptData(Key decryptKey, Provider provider)\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n@@ -311,0 +309,4 @@\n+        } catch (NoSuchPaddingException e) {\n+            throw new NoSuchAlgorithmException(e);\n+        }\n+        try {\n@@ -312,2 +314,14 @@\n-            encoded = c.doFinal(encryptedData);\n-            return pkcs8EncodingToSpec(encoded);\n+            return c.doFinal(encryptedData);\n+        } catch (GeneralSecurityException e) {\n+            throw new InvalidKeyException(e);\n+        }\n+    }\n+\n+    \/\/ Wrap the decrypted encryptedData in a P8EKS for getKeySpec methods.\n+    private PKCS8EncodedKeySpec getKeySpecImpl(Key decryptKey,\n+        Provider provider) throws NoSuchAlgorithmException,\n+        InvalidKeyException {\n+        byte[] encoding = null;\n+        try {\n+            encoding = decryptData(decryptKey, provider);\n+            return pkcs8EncodingToSpec(encoding);\n@@ -319,1 +333,3 @@\n-                    \"Cannot retrieve the PKCS8EncodedKeySpec\", ex);\n+                \"Cannot retrieve the PKCS8EncodedKeySpec\", ex);\n+        } finally {\n+            KeyUtil.clear(encoding);\n@@ -324,2 +340,2 @@\n-     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n-     * {@code PrivateKey}.  A valid password-based encryption (PBE) algorithm\n+     * Creates an {@code EncryptedPrivateKeyInfo} by encrypting the specified\n+     * {@code DEREncodable}.  A valid password-based encryption (PBE) algorithm\n@@ -328,1 +344,1 @@\n-     * <p> The PBE algorithm string format details can be found in the\n+     * <p>The format of the PBE algorithm string is described in the\n@@ -330,1 +346,1 @@\n-     * Cipher section<\/a> of the Java Security Standard Algorithm Names\n+     * Cipher Algorithms<\/a> section of the Java Security Standard Algorithm Names\n@@ -333,13 +349,10 @@\n-     * @param key the {@code PrivateKey} to be encrypted\n-     * @param password the password used in the PBE encryption.  This array\n-     *                 will be cloned before being used.\n-     * @param algorithm the PBE encryption algorithm.  The default algorithm\n-     *                  will be used if {@code null}.  However, {@code null} is\n-     *                  not allowed when {@code params} is non-null.\n-     * @param params the {@code AlgorithmParameterSpec} to be used with\n-     *               encryption.  The provider default will be used if\n-     *               {@code null}.\n-     * @param provider the {@code Provider} will be used for PBE\n-     *                 {@link SecretKeyFactory} generation and {@link Cipher}\n-     *                 encryption operations. The default provider list will be\n-     *                 used if {@code null}.\n+     * @param de the {@code DEREncodable} to encrypt. Supported types include\n+     *           {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     * @param password the password used for PBE encryption. This array is cloned\n+     *                 before use.\n+     * @param algorithm the PBE encryption algorithm.\n+     * @param params the {@code AlgorithmParameterSpec} used for encryption. If\n+     *               {@code null}, the providers default parameters are applied.\n+     * @param provider the {@code Provider} for {@link SecretKeyFactory} and\n+     *                 {@link Cipher} operations. If {@code null}, provider\n+     *                 defaults are used\n@@ -347,5 +360,7 @@\n-     * @throws IllegalArgumentException on initialization errors based on the\n-     * arguments passed to the method\n-     * @throws RuntimeException on an encryption error\n-     * @throws NullPointerException if the key or password are {@code null}. If\n-     * {@code params} is non-null when {@code algorithm} is {@code null}.\n+     * @throws NullPointerException if {@code de}, {@code password}, or\n+     *         {@code algorithm} is {@code null}\n+     * @throws IllegalArgumentException if {@code de} is an unsupported\n+     *         {@code DEREncodable}, if an error occurs while generating the\n+     *         PBE key, or if {@code algorithm} or {@code params} are\n+     *         not supported by any provider\n+     * @throws RuntimeException if encryption of the encoding fails\n@@ -353,3 +368,3 @@\n-     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} Security Property\n-     * defines the default encryption algorithm and the\n-     * {@code AlgorithmParameterSpec} are the provider's algorithm defaults.\n+     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} security property\n+     * defines the default encryption algorithm. The {@code AlgorithmParameterSpec}\n+     * defaults are determined by the provider.\n@@ -360,1 +375,1 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+    public static EncryptedPrivateKeyInfo encrypt(DEREncodable de,\n@@ -364,12 +379,5 @@\n-        SecretKey skey;\n-        Objects.requireNonNull(key, \"key cannot be null\");\n-        Objects.requireNonNull(password, \"password cannot be null.\");\n-        PBEKeySpec keySpec = new PBEKeySpec(password);\n-        if (algorithm == null) {\n-            if (params != null) {\n-                throw new NullPointerException(\"algorithm must be specified\" +\n-                    \" if params is non-null.\");\n-            }\n-            algorithm = Pem.DEFAULT_ALGO;\n-        }\n-\n+        Objects.requireNonNull(de, \"a key must be specified.\");\n+        Objects.requireNonNull(password, \"a password must be specified.\");\n+        Objects.requireNonNull(algorithm, \"an algorithm must be specified.\");\n+        char[] passwd = password.clone();\n+        byte[] encoding = getEncoding(de);\n@@ -377,9 +385,5 @@\n-            SecretKeyFactory factory;\n-            if (provider == null) {\n-                factory = SecretKeyFactory.getInstance(algorithm);\n-            } else {\n-                factory = SecretKeyFactory.getInstance(algorithm, provider);\n-            }\n-            skey = factory.generateSecret(keySpec);\n-        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n-            throw new IllegalArgumentException(e);\n+            return encryptImpl(encoding, algorithm,\n+                generateSecretKey(passwd, algorithm, provider), params,\n+                provider, null);\n+        } finally {\n+            KeyUtil.clear(passwd, encoding);\n@@ -387,1 +391,0 @@\n-        return encryptKeyImpl(key, algorithm, skey, params, provider, null);\n@@ -389,1 +392,0 @@\n-\n@@ -391,3 +393,3 @@\n-     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n-     * {@code PrivateKey} and password.  Default algorithm and parameters are\n-     * used.\n+     * Creates an {@code EncryptedPrivateKeyInfo} by encrypting the specified\n+     * {@code DEREncodable}. A valid password must be specified. A default\n+     * password-based encryption (PBE) algorithm and provider are used.\n@@ -395,3 +397,4 @@\n-     * @param key the {@code PrivateKey} to be encrypted\n-     * @param password the password used in the PBE encryption.  This array\n-     *                 will be cloned before being used.\n+     * @param de the {@code DEREncodable} to encrypt. Supported types include\n+     *           {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     * @param password the password used for PBE encryption. This array is cloned\n+     *                 before use.\n@@ -399,5 +402,5 @@\n-     * @throws IllegalArgumentException on initialization errors based on the\n-     * arguments passed to the method\n-     * @throws RuntimeException on an encryption error\n-     * @throws NullPointerException when the {@code key} or {@code password}\n-     * is {@code null}\n+     * @throws NullPointerException if {@code de} or {@code password} is {@code null}\n+     * @throws IllegalArgumentException if {@code de} is an unsupported\n+     *         {@code DEREncodable}, if an error occurs while generating the\n+     *         PBE key, or if the default algorithm is misconfigured\n+     * @throws RuntimeException if encryption of the encoding fails\n@@ -405,3 +408,3 @@\n-     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} Security Property\n-     * defines the default encryption algorithm and the\n-     * {@code AlgorithmParameterSpec} are the provider's algorithm defaults.\n+     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} security property\n+     * defines the default encryption algorithm. The {@code AlgorithmParameterSpec}\n+     * defaults are determined by the provider.\n@@ -412,1 +415,1 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+    public static EncryptedPrivateKeyInfo encrypt(DEREncodable de,\n@@ -414,1 +417,2 @@\n-        return encryptKey(key, password, Pem.DEFAULT_ALGO, null, null);\n+        return encrypt(de, password, Pem.DEFAULT_ALGO, null,\n+            null);\n@@ -418,2 +422,3 @@\n-     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from the given\n-     * {@link PrivateKey} using the {@code encKey} and given parameters.\n+     * Creates an {@code EncryptedPrivateKeyInfo} by encrypting the specified\n+     * {@link DEREncodable}. A valid encryption algorithm and {@code Key} must\n+     * be specified.\n@@ -421,21 +426,4 @@\n-     * @param key the {@code PrivateKey} to be encrypted\n-     * @param encKey the password-based encryption (PBE) {@code Key} used to\n-     *              encrypt {@code key}.\n-     * @param algorithm the PBE encryption algorithm.  The default algorithm is\n-     *                 will be used if {@code null}; however, {@code null} is\n-     *                 not allowed when {@code params} is non-null.\n-     * @param params the {@code AlgorithmParameterSpec} to be used with\n-     *               encryption. The provider list default will be used if\n-     *               {@code null}.\n-     * @param random the {@code SecureRandom} instance used during\n-     *               encryption.  The default will be used if {@code null}.\n-     * @param provider the {@code Provider} is used for {@link Cipher}\n-     *                encryption operation.  The default provider list will be\n-     *                used if {@code null}.\n-     * @return an {@code EncryptedPrivateKeyInfo}\n-     * @throws IllegalArgumentException on initialization errors based on the\n-     * arguments passed to the method\n-     * @throws RuntimeException on an encryption error\n-     * @throws NullPointerException if the {@code key} or {@code encKey} are\n-     * {@code null}. If {@code params} is non-null, {@code algorithm} cannot be\n-     * {@code null}.\n+     * <p>The format of the algorithm string is described in the\n+     * <a href=\"{@docRoot}\/..\/specs\/security\/standard-names.html#cipher-algorithms\">\n+     * Cipher Algorithms<\/a> section of the Java Security Standard Algorithm Names\n+     * Specification.\n@@ -443,3 +431,18 @@\n-     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} Security Property\n-     * defines the default encryption algorithm and the\n-     * {@code AlgorithmParameterSpec} are the provider's algorithm defaults.\n+     * @param de the {@code DEREncodable} to encrypt. Supported types include\n+     *           {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     * @param encryptKey the key used to encrypt the encoding.\n+     * @param algorithm the encryption algorithm, such as a password-based\n+     *                  encryption (PBE) algorithm.\n+     * @param params the {@code AlgorithmParameterSpec} used for encryption. If\n+     *               {@code null}, the providers default parameters are applied.\n+     * @param random the {@code SecureRandom} instance used during encryption.\n+     *               If {@code null}, the default is used\n+     * @param provider the {@code Provider} for {@link Cipher} operations.\n+     *                 If {@code null}, the default provider list is used.\n+     * @return an {@code EncryptedPrivateKeyInfo}\n+     * @throws NullPointerException if {@code de}, {@code encryptKey}, or\n+     *         {@code algorithm} is {@code null}\n+     * @throws IllegalArgumentException if {@code de} is an unsupported\n+     *         {@code DEREncodable}, if {@code encryptKey} is invalid, or if\n+     *         {@code algorithm} or {@code params} are not supported by any provider\n+     * @throws RuntimeException if encryption of the encoding fails\n@@ -450,14 +453,9 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key, Key encKey,\n-        String algorithm, AlgorithmParameterSpec params, Provider provider,\n-        SecureRandom random) {\n-\n-        Objects.requireNonNull(key);\n-        Objects.requireNonNull(encKey);\n-        if (algorithm == null) {\n-            if (params != null) {\n-                throw new NullPointerException(\"algorithm must be specified \" +\n-                    \"if params is non-null.\");\n-            }\n-            algorithm = Pem.DEFAULT_ALGO;\n-        }\n-        return encryptKeyImpl(key, algorithm, encKey, params, provider, random);\n+    public static EncryptedPrivateKeyInfo encrypt(DEREncodable de,\n+        Key encryptKey, String algorithm, AlgorithmParameterSpec params,\n+        Provider provider, SecureRandom random) {\n+\n+        Objects.requireNonNull(de, \"a key must be specified.\");\n+        Objects.requireNonNull(encryptKey, \"an encryption key must be specified.\");\n+        Objects.requireNonNull(algorithm, \"an algorithm must be specified.\");\n+        return encryptImpl(getEncoding(de), algorithm, encryptKey,\n+            params, provider, random);\n@@ -466,1 +464,1 @@\n-    private static EncryptedPrivateKeyInfo encryptKeyImpl(PrivateKey key,\n+    private static EncryptedPrivateKeyInfo encryptImpl(byte[] encoded,\n@@ -484,2 +482,9 @@\n-            encryptedData = c.doFinal(key.getEncoded());\n-            algId = new AlgorithmId(Pem.getPBEID(algorithm), c.getParameters());\n+            encryptedData = c.doFinal(encoded);\n+            try {\n+                \/\/ Use shared PEM method for very likely case the algorithm is PBE.\n+                algId = new AlgorithmId(Pem.getPBEID(algorithm), c.getParameters());\n+            } catch (IllegalArgumentException e) {\n+                \/\/ For the unlikely case a non-PBE cipher is used, get the OID.\n+                algId = new AlgorithmId(AlgorithmId.get(algorithm).getOID(),\n+                    c.getParameters());\n+            }\n@@ -490,1 +495,1 @@\n-                 NoSuchPaddingException e) {\n+                 IllegalStateException | NoSuchPaddingException e) {\n@@ -495,0 +500,2 @@\n+        } finally {\n+            KeyUtil.clear(encoded);\n@@ -502,2 +509,2 @@\n-     * Extract the enclosed {@code PrivateKey} object from the encrypted data\n-     * and return it.\n+     * Extracts and returns the enclosed {@code PrivateKey} using the\n+     * specified password.\n@@ -505,6 +512,7 @@\n-     * @param password the password used in the PBE encryption.  This array\n-     *                 will be cloned before being used.\n-     * @return a {@code PrivateKey}\n-     * @throws GeneralSecurityException if an error occurs parsing or\n-     * decrypting the encrypted data, or producing the key object.\n-     * @throws NullPointerException if {@code password} is null\n+     * @param password the password used for PBE decryption. The array is cloned\n+     *                 before use.\n+     * @return the decrypted {@code PrivateKey}\n+     * @throws NullPointerException if {@code password} is {@code null}\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if an error occurs during parsing,\n+     *         decryption, or key generation\n@@ -515,4 +523,3 @@\n-    public PrivateKey getKey(char[] password) throws GeneralSecurityException {\n-        SecretKeyFactory skf;\n-        PKCS8EncodedKeySpec p8KeySpec;\n-        Objects.requireNonNull(password, \"password cannot be null\");\n+    public PrivateKey getKey(char[] password)\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n+        Objects.requireNonNull(password, \"a password must be specified.\");\n@@ -520,4 +527,5 @@\n-        skf = SecretKeyFactory.getInstance(getAlgName());\n-        p8KeySpec = getKeySpec(skf.generateSecret(keySpec));\n-\n-        return PKCS8Key.parseKey(p8KeySpec.getEncoded());\n+        try {\n+            return PKCS8Key.parseKey(Pem.decryptEncoding(this, keySpec), null);\n+        } finally {\n+            keySpec.clearPassword();\n+        }\n@@ -527,2 +535,2 @@\n-     * Extract the enclosed {@code PrivateKey} object from the encrypted data\n-     * and return it.\n+     * Extracts and returns the enclosed {@code PrivateKey} using the specified\n+     * decryption key and provider.\n@@ -530,8 +538,9 @@\n-     * @param decryptKey the decryption key and cannot be {@code null}\n-     * @param provider the {@code Provider} used for Cipher decryption and\n-     *                 {@code PrivateKey} generation. A {@code null} value will\n-     *                 use the default provider configuration.\n-     * @return a {@code PrivateKey}\n-     * @throws GeneralSecurityException if an error occurs parsing or\n-     * decrypting the encrypted data, or producing the key object.\n-     * @throws NullPointerException if {@code decryptKey} is null\n+     * @param decryptKey the decryption key. Must not be {@code null}.\n+     * @param provider the {@code Provider} for {@link Cipher} decryption\n+     *                 and {@link PrivateKey} generation. If {@code null}, the\n+     *                 default provider configuration is used.\n+     * @return the decrypted {@code PrivateKey}\n+     * @throws NullPointerException if {@code decryptKey} is {@code null}\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if an error occurs during parsing,\n+     *         decryption, or key generation\n@@ -543,3 +552,3 @@\n-        throws GeneralSecurityException {\n-        Objects.requireNonNull(decryptKey,\"decryptKey cannot be null.\");\n-        PKCS8EncodedKeySpec p = getKeySpecImpl(decryptKey, provider);\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n+        Objects.requireNonNull(decryptKey,\"a decryptKey must be specified.\");\n+        byte[] encoding = null;\n@@ -547,9 +556,4 @@\n-            if (provider == null) {\n-                return KeyFactory.getInstance(\n-                    KeyUtil.getAlgorithm(p.getEncoded())).\n-                    generatePrivate(p);\n-            }\n-            return KeyFactory.getInstance(KeyUtil.getAlgorithm(p.getEncoded()),\n-                provider).generatePrivate(p);\n-        } catch (IOException e) {\n-            throw new GeneralSecurityException(e);\n+            encoding = decryptData(decryptKey, provider);\n+            return PKCS8Key.parseKey(encoding, null);\n+        } finally {\n+            KeyUtil.clear(encoding);\n@@ -559,0 +563,69 @@\n+    \/**\n+     * Extracts and returns the enclosed {@code KeyPair} using the specified\n+     * password. If the encoded data does not contain both a public and private\n+     * key, an {@code InvalidKeyException} is thrown.\n+     *\n+     * @param password the password used for PBE decryption. The array is cloned\n+     *                 before use.\n+     * @return a decrypted {@code KeyPair}\n+     * @throws NullPointerException if {@code password} is {@code null}\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if the encoded data lacks a public key, or if\n+     *         an error occurs during parsing, decryption, or key generation\n+     *\n+     * @since 26\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public KeyPair getKeyPair(char[] password)\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n+        Objects.requireNonNull(password, \"a password must be specified.\");\n+\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        DEREncodable d;\n+        try {\n+            d = Pem.toDEREncodable(Pem.decryptEncoding(this, keySpec), true, null);\n+        } finally {\n+            keySpec.clearPassword();\n+        }\n+        return switch (d) {\n+            case KeyPair kp -> kp;\n+            case PrivateKey ignored -> throw new InvalidKeyException(\n+                \"This encoding does not contain a public key.\");\n+            default -> throw new InvalidKeyException(\n+                \"Invalid class returned \" + d.getClass().getName());\n+        };\n+    }\n+\n+    \/**\n+     * Extracts and returns the enclosed {@code KeyPair} using the specified\n+     * decryption key and provider. If the encoded data does not contain both a\n+     * public and private key, an {@code InvalidKeyException} is thrown.\n+     *\n+     * @param decryptKey the decryption key. Must not be {@code null}.\n+     * @param provider the {@code Provider} for {@link Cipher} decryption\n+     *                 and key generation. If {@code null}, the default provider\n+     *                 configuration is used.\n+     * @return a decrypted {@code KeyPair}\n+     * @throws NullPointerException if {@code decryptKey} is {@code null}\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if the encoded data lacks a public key, or if\n+     *         an error occurs during parsing, decryption, or key generation\n+     *\n+     * @since 26\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public KeyPair getKeyPair(Key decryptKey, Provider provider)\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n+        Objects.requireNonNull(decryptKey,\"a decryptKey must be specified.\");\n+\n+        DEREncodable d = Pem.toDEREncodable(\n+            decryptData(decryptKey, provider),true, provider);\n+        return switch (d) {\n+            case KeyPair kp -> kp;\n+            case PrivateKey ignored -> throw new InvalidKeyException(\n+                \"This encoding does not contain a public key.\");\n+            default -> throw new InvalidKeyException(\n+                \"Invalid class returned \" + d.getClass().getName());\n+        };\n+    }\n+\n@@ -588,1 +661,1 @@\n-     * @return the PKCS8EncodedKeySpec object.\n+     * @return the PKCS8EncodedKeySpec object\n@@ -673,8 +746,1 @@\n-    private static void checkTag(DerValue val, byte tag, String valName)\n-        throws IOException {\n-        if (val.getTag() != tag) {\n-            throw new IOException(\"invalid key encoding - wrong tag for \" +\n-                                  valName);\n-        }\n-    }\n-\n+    \/\/ Read the encodedKey and return a P8EKS with the algorithm specified\n@@ -686,0 +752,38 @@\n+\n+    \/\/ Return the PKCS#8 encoding from a DEREncodable\n+    private static byte[] getEncoding(DEREncodable d) {\n+        return switch (d) {\n+            case PrivateKey p -> p.getEncoded();\n+            case PKCS8EncodedKeySpec p8 -> p8.getEncoded();\n+            case KeyPair kp -> {\n+                try {\n+                    yield PKCS8Key.getEncoded(kp.getPublic().getEncoded(),\n+                        kp.getPrivate().getEncoded());\n+                } catch (IOException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            default -> throw new IllegalArgumentException(\n+                d.getClass().getName() + \" not supported by this method\");\n+        };\n+    }\n+\n+    \/\/ Generate a SecretKey from the password.\n+    private static SecretKey generateSecretKey(char[] password, String algorithm,\n+        Provider provider) {\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+\n+        try {\n+            SecretKeyFactory factory;\n+            if (provider == null) {\n+                factory = SecretKeyFactory.getInstance(algorithm);\n+            } else {\n+                factory = SecretKeyFactory.getInstance(algorithm, provider);\n+            }\n+            return factory.generateSecret(keySpec);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            throw new IllegalArgumentException(e);\n+        } finally {\n+            keySpec.clearPassword();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":269,"deletions":165,"binary":false,"changes":434,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-        @JEP(number=470, title=\"PEM Encodings of Cryptographic Objects\", status=\"Preview\")\n+        @JEP(number=524, title=\"PEM Encodings of Cryptographic Objects\",\n+            status=\"Second Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.util.KeyUtil;\n@@ -216,3 +217,10 @@\n-                PKCS8Key p8key = new ECPrivateKeyImpl(p8.getEncoded());\n-                if (!p8key.hasPublicKey()) {\n-                    throw new InvalidKeySpecException(\"No public key found.\");\n+                byte[] encoded = p8.getEncoded();\n+                PKCS8Key p8key = null;\n+                try {\n+                    p8key = new ECPrivateKeyImpl(encoded);\n+                    if (!p8key.hasPublicKey()) {\n+                        throw new InvalidKeySpecException(\"No public key found.\");\n+                    }\n+                    yield new ECPublicKeyImpl(p8key.getPubKeyEncoded());\n+                } finally {\n+                    KeyUtil.clear(encoded, p8key);\n@@ -220,1 +228,0 @@\n-                yield new ECPublicKeyImpl(p8key.getPubKeyEncoded());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECKeyFactory.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    private final byte SEC1v2 = 1;\n@@ -95,28 +96,0 @@\n-        makeEncoding(s);\n-\n-    }\n-\n-    ECPrivateKeyImpl(byte[] s, ECParameterSpec params)\n-            throws InvalidKeyException {\n-        this.arrayS = s.clone();\n-        this.params = params;\n-        makeEncoding(s);\n-    }\n-\n-    private void makeEncoding(byte[] s) throws InvalidKeyException {\n-        algid = new AlgorithmId\n-                (AlgorithmId.EC_oid, ECParameters.getAlgorithmParameters(params));\n-        DerOutputStream out = new DerOutputStream();\n-        out.putInteger(1); \/\/ version 1\n-        byte[] privBytes = s.clone();\n-        ArrayUtil.reverse(privBytes);\n-        out.putOctetString(privBytes);\n-        Arrays.fill(privBytes, (byte) 0);\n-        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n-        privKeyMaterial = val.toByteArray();\n-        val.clear();\n-    }\n-\n-    private void makeEncoding(BigInteger s) throws InvalidKeyException {\n-        algid = new AlgorithmId(AlgorithmId.EC_oid,\n-                ECParameters.getAlgorithmParameters(params));\n@@ -132,0 +105,20 @@\n+        try {\n+            makeEncoding(sOctets);\n+        } finally {\n+            Arrays.fill(sOctets, (byte) 0);\n+        }\n+    }\n+\n+    ECPrivateKeyImpl(byte[] s, ECParameterSpec params)\n+            throws InvalidKeyException {\n+        this.arrayS = s.clone();\n+        this.params = params;\n+        byte[] privBytes = arrayS.clone();\n+        ArrayUtil.reverse(privBytes);\n+        try {\n+            makeEncoding(privBytes);\n+        } finally {\n+            Arrays.fill(privBytes, (byte) 0);\n+        }\n+\n+    }\n@@ -133,0 +126,3 @@\n+    private void makeEncoding(byte[] privBytes) throws InvalidKeyException {\n+        algid = new AlgorithmId(AlgorithmId.EC_oid,\n+            ECParameters.getAlgorithmParameters(params));\n@@ -135,2 +131,1 @@\n-        out.putOctetString(sOctets);\n-        Arrays.fill(sOctets, (byte) 0);\n+        out.putOctetString(privBytes);\n@@ -184,1 +179,1 @@\n-            if (version != V2) {\n+            if (version != SEC1v2) {\n@@ -256,0 +251,36 @@\n+\n+    \/\/ Parse the SEC1v2 encoding to extract public key, if available.\n+    public static BitArray parsePublicBits(byte[] privateBytes) {\n+        DerValue seq = null;\n+        try {\n+            seq = new DerValue(privateBytes);\n+            if (seq.tag == DerValue.tag_Sequence) {\n+                int version = seq.data.getInteger();\n+                if (version == 1) { \/\/ EC\n+                    seq.data.getDerValue();  \/\/ read pass the private key\n+                    if (seq.data.available() != 0) {\n+                        DerValue derValue = seq.data.getDerValue();\n+                        \/\/ check for optional [0] EC domain parameters\n+                        if (derValue.isContextSpecific((byte) 0)) {\n+                            if (seq.data.available() == 0) {\n+                                return null;\n+                            }\n+                            derValue = seq.data.getDerValue();\n+                        }\n+                        \/\/ [1] public key\n+                        if (derValue.isContextSpecific((byte) 1)) {\n+                            derValue = derValue.data.getDerValue();\n+                            return derValue.getUnalignedBitString();\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(e);\n+        } finally {\n+            if (seq != null) {\n+                seq.clear();\n+            }\n+        }\n+        return null;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":62,"deletions":31,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.util.KeyUtil;\n@@ -162,3 +163,13 @@\n-                PKCS8Key p8key = new XDHPrivateKeyImpl(p8.getEncoded());\n-                if (!p8key.hasPublicKey()) {\n-                    throw new InvalidKeySpecException(\"No public key found.\");\n+                byte[] encoded = p8.getEncoded();\n+                PKCS8Key p8key = new XDHPrivateKeyImpl(encoded);\n+                try {\n+                    if (!p8key.hasPublicKey()) {\n+                        throw new InvalidKeySpecException(\"No public key found.\");\n+                    }\n+                    XDHPublicKeyImpl result =\n+                        new XDHPublicKeyImpl(p8key.getPubKeyEncoded());\n+                    checkLockedParams(InvalidKeySpecException::new,\n+                        result.getParams());\n+                    yield result;\n+                } finally {\n+                    KeyUtil.clear(encoded, p8key);\n@@ -166,5 +177,0 @@\n-                XDHPublicKeyImpl result =\n-                    new XDHPublicKeyImpl(p8key.getPubKeyEncoded());\n-                checkLockedParams(InvalidKeySpecException::new,\n-                    result.getParams());\n-                yield result;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/XDHKeyFactory.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.util.KeyUtil;\n@@ -155,3 +156,10 @@\n-                PKCS8Key p8key = new EdDSAPrivateKeyImpl(p8.getEncoded());\n-                if (!p8key.hasPublicKey()) {\n-                    throw new InvalidKeySpecException(\"No public key found.\");\n+                byte[] encoded = p8.getEncoded();\n+                PKCS8Key p8key = null;\n+                try {\n+                     p8key = new EdDSAPrivateKeyImpl(encoded);\n+                    if (!p8key.hasPublicKey()) {\n+                        throw new InvalidKeySpecException(\"No public key found.\");\n+                    }\n+                    yield new EdDSAPublicKeyImpl(p8key.getPubKeyEncoded());\n+                } finally {\n+                    KeyUtil.clear(encoded, p8key);\n@@ -159,1 +167,0 @@\n-                yield new EdDSAPublicKeyImpl(p8key.getPubKeyEncoded());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ed\/EdDSAKeyFactory.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.ec.ECPrivateKeyImpl;\n@@ -107,1 +108,8 @@\n-    private PKCS8Key(byte[] privEncoding, byte[] pubEncoding)\n+    \/**\n+     * Constructor that takes both public and private encodings.\n+     *\n+     * If the private key includes a public key encoding (like an EC key in\n+     * SEC1v2 format), and a specified public key matches it, the existing\n+     * encoding is reused rather than recreated.\n+     *\/\n+    public PKCS8Key(byte[] publicEncoding, byte[] privateEncoding)\n@@ -109,3 +117,14 @@\n-        this(privEncoding);\n-        pubKeyEncoded = pubEncoding;\n-        version = V2;\n+        this(privateEncoding);\n+        if (publicEncoding != null) {\n+            if (pubKeyEncoded != null) {\n+                if (!Arrays.equals(pubKeyEncoded, publicEncoding)) {\n+                    Arrays.fill(privKeyMaterial, (byte) 0x0);\n+                    throw new InvalidKeyException(\"PrivateKey \" +\n+                        \"encoding has a public key that does not match \" +\n+                        \"the given PublicKey\");\n+                }\n+            } else {\n+                pubKeyEncoded = publicEncoding;\n+                version = V2;\n+            }\n+        }\n@@ -140,0 +159,8 @@\n+            \/\/ Special check and parsing for ECDSA's SEC1v2 format\n+            if (algid.getOID().equals(AlgorithmId.EC_oid)) {\n+                var bits = ECPrivateKeyImpl.parsePublicBits(privKeyMaterial);\n+                if (bits != null) {\n+                    pubKeyEncoded = new X509Key(algid, bits).getEncoded();\n+                }\n+            }\n+\n@@ -274,1 +301,1 @@\n-     * @param pubKeyEncoded DER-encoded PublicKey\n+     * @param pubKeyEncoded DER-encoded PublicKey, this may be null.\n@@ -281,0 +308,1 @@\n+        PKCS8Key pkcs8Key;\n@@ -282,2 +310,1 @@\n-            return new PKCS8Key(privKeyEncoded, pubKeyEncoded).\n-                generateEncoding();\n+            pkcs8Key = new PKCS8Key(pubKeyEncoded, privKeyEncoded);\n@@ -287,0 +314,5 @@\n+        try {\n+            return pkcs8Key.generateEncoding().clone();\n+        } finally {\n+            pkcs8Key.clear();\n+        }\n@@ -298,1 +330,1 @@\n-                encodedKey = generateEncoding();\n+                generateEncoding();\n@@ -329,1 +361,0 @@\n-                \/\/ X509Key x = X509Key.parse(pubKeyEncoded);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":40,"deletions":9,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.security.PEMRecord;\n+import java.security.PEM;\n@@ -562,1 +562,1 @@\n-                PEMRecord rec;\n+                PEM rec;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.crypto.spec.PBEKeySpec;\n@@ -44,0 +45,1 @@\n+import sun.security.pkcs.PKCS8Key;\n@@ -548,1 +550,17 @@\n-\n+    \/\/ Generic method for zeroing arrays and objects\n+    public static void clear(Object... list) {\n+        for (Object o: list) {\n+            switch (o) {\n+                case byte[] b -> Arrays.fill(b, (byte)0);\n+                case char[] c -> Arrays.fill(c, (char)0);\n+                case PKCS8Key p8 -> p8.clear();\n+                case PKCS8EncodedKeySpec p8 ->\n+                    SharedSecrets.getJavaSecuritySpecAccess().clearEncodedKeySpec(p8);\n+                case PBEKeySpec pbe -> pbe.clearPassword();\n+                case null -> {}\n+                default ->\n+                    throw new IllegalArgumentException(\n+                    o.getClass().getName() + \" not defined in KeyUtil.clear()\");\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.security.pkcs.PKCS8Key;\n@@ -30,0 +31,3 @@\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n@@ -32,3 +36,4 @@\n-import java.security.NoSuchAlgorithmException;\n-import java.security.PEMRecord;\n-import java.security.Security;\n+import java.security.*;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n@@ -162,1 +167,1 @@\n-    public static PEMRecord readPEM(InputStream is, boolean shortHeader)\n+    public static PEM readPEM(InputStream is, boolean shortHeader)\n@@ -314,1 +319,1 @@\n-        return new PEMRecord(typeConverter(headerType), data, preData);\n+        return new PEM(typeConverter(headerType), data, preData);\n@@ -317,1 +322,1 @@\n-    public static PEMRecord readPEM(InputStream is) throws IOException {\n+    public static PEM readPEM(InputStream is) throws IOException {\n@@ -345,1 +350,1 @@\n-    public static String pemEncoded(PEMRecord pem) {\n+    public static String pemEncoded(PEM pem) {\n@@ -349,0 +354,107 @@\n+\n+    \/*\n+     * Get PKCS8 encoding from an encrypted private key encoding.\n+     *\/\n+    public static byte[] decryptEncoding(byte[] encoded, char[] password)\n+        throws GeneralSecurityException {\n+        EncryptedPrivateKeyInfo ekpi;\n+\n+        Objects.requireNonNull(password, \"password cannot be null\");\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        try {\n+            ekpi = new EncryptedPrivateKeyInfo(encoded);\n+            return decryptEncoding(ekpi, keySpec);\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(e);\n+        } finally {\n+            keySpec.clearPassword();\n+        }\n+    }\n+\n+    public static byte[] decryptEncoding(EncryptedPrivateKeyInfo ekpi, PBEKeySpec keySpec)\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n+\n+        PKCS8EncodedKeySpec p8KeySpec = null;\n+        try {\n+            SecretKeyFactory skf = SecretKeyFactory.getInstance(ekpi.getAlgName());\n+            p8KeySpec = ekpi.getKeySpec(skf.generateSecret(keySpec));\n+            return p8KeySpec.getEncoded();\n+        } catch (InvalidKeySpecException e) {\n+            throw new InvalidKeyException(e);\n+        } finally {\n+            KeyUtil.clear(p8KeySpec);\n+        }\n+    }\n+\n+\n+    \/**\n+     * With a given PKCS8 encoding, construct a PrivateKey or KeyPair.  A\n+     * KeyPair is returned if requested and the encoding has a public key;\n+     * otherwise, a PrivateKey is returned.\n+     *\n+     * @param encoded PKCS8 encoding\n+     * @param pair set to true for returning a KeyPair, if possible. Otherwise,\n+     *             return a PrivateKey\n+     * @param provider KeyFactory provider\n+     *\/\n+    public static DEREncodable toDEREncodable(byte[] encoded, boolean pair,\n+        Provider provider) throws InvalidKeyException {\n+\n+        PrivateKey privKey;\n+        PublicKey pubKey = null;\n+        PKCS8EncodedKeySpec p8KeySpec;\n+        PKCS8Key p8key = new PKCS8Key(encoded);\n+        KeyFactory kf;\n+\n+        try {\n+            p8KeySpec = new PKCS8EncodedKeySpec(encoded);\n+        } catch (NullPointerException e) {\n+            p8key.clear();\n+            throw new InvalidKeyException(\"No encoding found\", e);\n+        }\n+\n+        try {\n+            if (provider == null) {\n+                kf = KeyFactory.getInstance(p8key.getAlgorithm());\n+            } else {\n+                kf = KeyFactory.getInstance(p8key.getAlgorithm(), provider);\n+            }\n+        } catch (NoSuchAlgorithmException e) {\n+            KeyUtil.clear(p8KeySpec, p8key);\n+            throw new InvalidKeyException(\"Unable to find the algorithm: \" +\n+                p8key.getAlgorithm(), e);\n+        }\n+\n+        try {\n+            privKey = kf.generatePrivate(p8KeySpec);\n+\n+            \/\/ Only want the PrivateKey? then return it.\n+            if (!pair) {\n+                return privKey;\n+            }\n+\n+            if (p8key.hasPublicKey()) {\n+                \/\/ PKCS8Key.decode() has extracted the public key already\n+                pubKey = kf.generatePublic(\n+                    new X509EncodedKeySpec(p8key.getPubKeyEncoded()));\n+            } else {\n+                \/\/ In case decode() could not read the public key, the\n+                \/\/ KeyFactory can try.  Failure is ok as there may not\n+                \/\/ be a public key in the encoding.\n+                try {\n+                    pubKey = kf.generatePublic(p8KeySpec);\n+                } catch (InvalidKeySpecException e) {\n+                    \/\/ ignore\n+                }\n+            }\n+        } catch (InvalidKeySpecException e) {\n+            throw new InvalidKeyException(e);\n+        } finally {\n+            KeyUtil.clear(p8KeySpec, p8key);\n+        }\n+        if (pair && pubKey != null) {\n+            return new KeyPair(pubKey, privKey);\n+        }\n+        return privKey;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":119,"deletions":7,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.security.PEMRecord;\n+import java.security.PEM;\n@@ -51,0 +51,11 @@\n+    \/\/ EC 256 with a domain parameter & public key\n+    public static final Entry ecsecp256dom0 = new Entry(\"ecsecp256dom0\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgkW3Jx561NlEgBnut\n+        KwDdi3cNwu7YYD\/QtJ+9+AEBdoqgCgYIKoZIzj0DAQehRANCAASL+REY4vvAI9M3\n+        gonaml5K3lRgHq5w+OO4oO0VNduC44gUN1nrk7\/wdNSpL+xXNEX52Dsff+2RD\/fo\n+        p224ANvB\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class, \"SunEC\");\n+\n@@ -152,1 +163,1 @@\n-    public static final Entry ec25519priv = new Entry(\"ed25519priv\",\n+    public static final Entry ed25519priv = new Entry(\"ed25519priv\",\n@@ -192,0 +203,1 @@\n+    \/\/ This is the public key contained in ecsecp256\n@@ -289,0 +301,13 @@\n+    static final Entry ecsecp256ekpi = new Entry(\"ecsecp256ekpi\",\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIH0MF8GCSqGSIb3DQEFDTBSMDEGCSqGSIb3DQEFDDAkBBDhqUj1Oadj1GZXUMXT\n+        b3QEAgIIADAMBggqhkiG9w0CCQUAMB0GCWCGSAFlAwQBAgQQitxCfcZcMtoNu+X+\n+        PQk+\/wSBkFL1NddKkUL2tRv6pNf1TR7eI7qJReGRgJexU\/6pDN+UQS5e5qSySa7E\n+        k1m2pUHgZlySUblXZj9nOzCsNFfq\/jxlL15ZpAviAM2fRINnNEJcvoB+qZTS5cRb\n+        Xs3wC7wymHW3EdIZ9sxfSHq9t7j9SnC1jGHjno0v1rKcdIvJtYloxsRYjsG\/Sxhz\n+        uNYnx8AMuQ==\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\", EncryptedPrivateKeyInfo.class, \"SunEC\", \"fish\".toCharArray());\n+\n+\n@@ -453,1 +478,1 @@\n-        \"\"\", PEMRecord.class, \"SunEC\");\n+        \"\"\", PEM.class, \"SunEC\");\n@@ -474,1 +499,1 @@\n-        \"\"\" + postData, PEMRecord.class, \"SunEC\");\n+        \"\"\" + postData, PEM.class, \"SunEC\");\n@@ -567,0 +592,1 @@\n+        privList.add(ecsecp256dom0);\n@@ -568,1 +594,1 @@\n-        privList.add(ec25519priv);\n+        privList.add(ed25519priv);\n","filename":"test\/jdk\/java\/security\/PEM\/PEMData.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -114,2 +114,2 @@\n-        DEREncodable result = PEMDecoder.of().decode(PEMData.ecCSRWithData.pem(), PEMRecord.class);\n-        if (result instanceof PEMRecord rec) {\n+        DEREncodable result = PEMDecoder.of().decode(PEMData.ecCSRWithData.pem(), PEM.class);\n+        if (result instanceof PEM rec) {\n@@ -131,2 +131,2 @@\n-        result = PEMDecoder.of().decode(PEMData.rsapub.pem(), PEMRecord.class);\n-        if (!(result instanceof PEMRecord)) {\n+        result = PEMDecoder.of().decode(PEMData.rsapub.pem(), PEM.class);\n+        if (!(result instanceof PEM)) {\n@@ -135,1 +135,1 @@\n-        if (((PEMRecord) result).type().compareTo(Pem.PUBLIC_KEY) != 0) {\n+        if (((PEM) result).type().compareTo(Pem.PUBLIC_KEY) != 0) {\n@@ -142,1 +142,1 @@\n-        testPEMRecord(PEMData.ec25519priv);\n+        testPEMRecord(PEMData.ed25519priv);\n@@ -147,1 +147,1 @@\n-        testPEMRecordDecode(PEMData.ec25519priv);\n+        testPEMRecordDecode(PEMData.ed25519priv);\n@@ -153,2 +153,2 @@\n-        String s = new PEMRecord(\"ONE\", \"1212\").toString()\n-            + new PEMRecord(\"TWO\", \"3434\").toString();\n+        String s = new PEM(\"ONE\", \"1212\").toString()\n+            + new PEM(\"TWO\", \"3434\").toString();\n@@ -156,1 +156,1 @@\n-        if (d.decode(ins, PEMRecord.class).leadingData() != null) {\n+        if (d.decode(ins, PEM.class).leadingData() != null) {\n@@ -159,1 +159,1 @@\n-        if (d.decode(ins, PEMRecord.class).leadingData() != null) {\n+        if (d.decode(ins, PEM.class).leadingData() != null) {\n@@ -176,2 +176,2 @@\n-        System.out.println(\"EncryptedPrivateKeyInfo.encryptKey with PBE: \");\n-        ekpi = EncryptedPrivateKeyInfo.encryptKey(privateKey,\n+        System.out.println(\"EncryptedPrivateKeyInfo.encrypt with PBE: \");\n+        ekpi = EncryptedPrivateKeyInfo.encrypt(privateKey,\n@@ -187,2 +187,2 @@\n-        System.out.println(\"EncryptedPrivateKeyInfo.encryptKey with default: \");\n-        ekpi = EncryptedPrivateKeyInfo.encryptKey(privateKey\n+        System.out.println(\"EncryptedPrivateKeyInfo.encrypt with default: \");\n+        ekpi = EncryptedPrivateKeyInfo.encrypt(privateKey\n@@ -214,1 +214,1 @@\n-        PEMRecord obj;\n+        PEM obj;\n@@ -217,1 +217,1 @@\n-            obj = PEMDecoder.of().decode(is, PEMRecord.class);\n+            obj = PEMDecoder.of().decode(is, PEM.class);\n@@ -228,1 +228,1 @@\n-            PEMDecoder.of().decode(is, PEMRecord.class);\n+            PEMDecoder.of().decode(is, PEM.class);\n@@ -237,1 +237,1 @@\n-                PEMDecoder.of().decode(is, PEMRecord.class));\n+                PEMDecoder.of().decode(is, PEM.class));\n@@ -268,1 +268,1 @@\n-        PEMRecord r = PEMDecoder.of().decode(entry.pem(), PEMRecord.class);\n+        PEM r = PEMDecoder.of().decode(entry.pem(), PEM.class);\n@@ -288,1 +288,1 @@\n-                entry.clazz().isAssignableFrom(PEMRecord.class);\n+                entry.clazz().isAssignableFrom(PEM.class);\n@@ -303,1 +303,1 @@\n-        PEMRecord r = PEMDecoder.of().decode(entry.pem(), PEMRecord.class);\n+        PEM r = PEMDecoder.of().decode(entry.pem(), PEM.class);\n@@ -314,1 +314,1 @@\n-            case \"CERTIFICATE REQUEST\" -> (de instanceof PEMRecord);\n+            case \"CERTIFICATE REQUEST\" -> (de instanceof PEM);\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        keymap.keySet().stream().forEach(key -> test(key, encoder));\n+        keymap.keySet().forEach(key -> test(key, encoder));\n@@ -75,1 +75,1 @@\n-        keymap.keySet().stream().forEach(key -> test(key, PEMEncoder.of()));\n+        keymap.keySet().forEach(key -> test(key, PEMEncoder.of()));\n@@ -77,1 +77,1 @@\n-        keymap.keySet().stream().forEach(key -> testToString(key, encoder));\n+        keymap.keySet().forEach(key -> testToString(key, encoder));\n@@ -79,1 +79,1 @@\n-        keymap.keySet().stream().forEach(key -> testToString(key,\n+        keymap.keySet().forEach(key -> testToString(key,\n@@ -89,1 +89,1 @@\n-        keymap.keySet().stream().forEach(key -> testEncryptedMatch(key, encoder));\n+        keymap.keySet().forEach(key -> testEncryptedMatch(key, encoder));\n@@ -91,1 +91,1 @@\n-        keymap.keySet().stream().forEach(key -> testEncrypted(key, encoder));\n+        keymap.keySet().forEach(key -> testEncrypted(key, encoder));\n@@ -93,1 +93,1 @@\n-        keymap.keySet().stream().forEach(key -> testEncrypted(key, PEMEncoder.of()));\n+        keymap.keySet().forEach(key -> testEncrypted(key, PEMEncoder.of()));\n@@ -96,1 +96,1 @@\n-        keymap.keySet().stream().forEach(key -> testSameEncryptor(key, encEncoder));\n+        keymap.keySet().forEach(key -> testSameEncryptor(key, encEncoder));\n@@ -106,3 +106,3 @@\n-        PEMRecord pemRecord =\n-            d.decode(PEMData.ed25519ep8.pem(), PEMRecord.class);\n-        PEMData.checkResults(PEMData.ed25519ep8, pemRecord.toString());\n+        PEM pem =\n+            d.decode(PEMData.ed25519ep8.pem(), PEM.class);\n+        PEMData.checkResults(PEMData.ed25519ep8, pem.toString());\n@@ -110,1 +110,1 @@\n-        \/\/ test PemRecord is encapsulated with PEM header and footer on encoding\n+        \/\/ test PEM is encapsulated with PEM header and footer on encoding\n@@ -113,1 +113,1 @@\n-        PEMRecord pemR = new PEMRecord(\"ENCRYPTED PRIVATE KEY\", String.join(\"\\n\",\n+        PEM pemR = new PEM(\"ENCRYPTED PRIVATE KEY\", String.join(\"\\n\",\n@@ -116,0 +116,20 @@\n+\n+        \/\/ Verify the same private key bytes are returned with an ECDSA private\n+        \/\/ key PEM and an encrypted PEM.\n+        KeyPair kp = d.decode(PEMData.ecsecp256.pem(), KeyPair.class);\n+        var origPriv = kp.getPrivate();\n+        String s = encoder.withEncryption(PEMData.ecsecp256ekpi.password()).encodeToString(kp);\n+        kp = d.withDecryption(PEMData.ecsecp256ekpi.password()).decode(s, KeyPair.class);\n+        var newPriv = kp.getPrivate();\n+        if (!Arrays.equals(origPriv.getEncoded(), newPriv.getEncoded())) {\n+            throw new AssertionError(\"compare fails\");\n+        }\n+\n+        \/\/ Encoded non-encrypted Keypair\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"XDH\");\n+        kp = kpg.generateKeyPair();\n+        s = PEMEncoder.of().encodeToString(kp);\n+        DEREncodable der = d.decode(s);\n+        if (!(der instanceof KeyPair)) {\n+            throw new AssertionError(\"returned Private key instead of KeyPair\");\n+        }\n@@ -218,1 +238,1 @@\n-                EncryptedPrivateKeyInfo.encryptKey(pkey, entry.password(),\n+                EncryptedPrivateKeyInfo.encrypt(pkey, entry.password(),\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":34,"deletions":14,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ * @bug 8298420\n+ * @summary Testing encryptKey\n+ * @enablePreview\n+ *\/\n+\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.AlgorithmParameters;\n+import java.security.PEMDecoder;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.util.Arrays;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+public class Encrypt {\n+\n+    private static final String encEdECKey =\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\";\n+    private static final String passwdText = \"fish\";\n+    private static final char[] password = passwdText.toCharArray();\n+    private static final SecretKey key = new SecretKeySpec(\n+        passwdText.getBytes(), \"PBE\");\n+\n+    public static void main(String[] args) throws Exception {\n+        Provider p = Security.getProvider(System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+\n+        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(encEdECKey,\n+            EncryptedPrivateKeyInfo.class);\n+        PrivateKey priKey = PEMDecoder.of().withDecryption(password).\n+            decode(encEdECKey, PrivateKey.class);\n+        AlgorithmParameters ap = ekpi.getAlgParameters();\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ... )\n+        var e = EncryptedPrivateKeyInfo.encrypt(priKey, password,\n+            ekpi.getAlgName(), ap.getParameterSpec(PBEParameterSpec.class),\n+            null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, password, ekpi.getAlgName(),\n+            ap.getParameterSpec(PBEParameterSpec.class), p);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider and null algorithm\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, password, Pem.DEFAULT_ALGO, null, p);\n+        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...)\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, ekpi.getAlgName(),\n+            ap.getParameterSpec(PBEParameterSpec.class), null, null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null random\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, ekpi.getAlgName(),\n+            ap.getParameterSpec(PBEParameterSpec.class), p, null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and SecureRandom\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, ekpi.getAlgName(),\n+            ap.getParameterSpec(PBEParameterSpec.class), p, new SecureRandom());\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null algorithm\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, Pem.DEFAULT_ALGO, null,\n+            p, new SecureRandom());\n+        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n+\n+\n+        SecretKey key2 = new SecretKeySpec(\"1234567890123456\".getBytes(), \"AES\");\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and SecureRandom\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key2, \"AES_128\/GCM\/NoPadding\",\n+            null, p, new SecureRandom());\n+        PrivateKey key3 = e.getKey(key2, null);\n+        assertEquals(key3, priKey, \"AES encryption failed\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/Encrypt.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @modules java.base\/sun.security.util\n- * @bug 8298420\n- * @summary Testing encryptKey\n- * @enablePreview\n- *\/\n-\n-import sun.security.util.Pem;\n-\n-import javax.crypto.EncryptedPrivateKeyInfo;\n-import javax.crypto.SecretKey;\n-import javax.crypto.spec.PBEParameterSpec;\n-import javax.crypto.spec.SecretKeySpec;\n-import java.security.AlgorithmParameters;\n-import java.security.PEMDecoder;\n-import java.security.PrivateKey;\n-import java.security.Provider;\n-import java.security.SecureRandom;\n-import java.security.Security;\n-import java.util.Arrays;\n-\n-import static jdk.test.lib.Asserts.assertEquals;\n-\n-public class EncryptKey {\n-\n-    private static final String encEdECKey =\n-        \"\"\"\n-        -----BEGIN ENCRYPTED PRIVATE KEY-----\n-        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n-        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n-        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n-        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n-        -----END ENCRYPTED PRIVATE KEY-----\n-        \"\"\";\n-    private static final String passwdText = \"fish\";\n-    private static final char[] password = passwdText.toCharArray();\n-    private static final SecretKey key = new SecretKeySpec(\n-        passwdText.getBytes(), \"PBE\");\n-\n-    public static void main(String[] args) throws Exception {\n-        Provider p = Security.getProvider(System.getProperty(\"test.provider.name\", \"SunJCE\"));\n-\n-        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(encEdECKey,\n-            EncryptedPrivateKeyInfo.class);\n-        PrivateKey priKey = PEMDecoder.of().withDecryption(password).\n-            decode(encEdECKey, PrivateKey.class);\n-        AlgorithmParameters ap = ekpi.getAlgParameters();\n-\n-        \/\/ Test encryptKey(PrivateKey, char[], String, ... )\n-        var e = EncryptedPrivateKeyInfo.encryptKey(priKey, password,\n-            ekpi.getAlgName(), ap.getParameterSpec(PBEParameterSpec.class),\n-            null);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, password, ekpi.getAlgName(),\n-                ap.getParameterSpec(PBEParameterSpec.class), p);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                    \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider and null algorithm\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, password, null, null,\n-                p);\n-        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...)\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n-            ap.getParameterSpec(PBEParameterSpec.class),null, null);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null random\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n-                ap.getParameterSpec(PBEParameterSpec.class), p, null);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                    \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and SecureRandom\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n-                ap.getParameterSpec(PBEParameterSpec.class), p, new SecureRandom());\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                    \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null algorithm\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, null, null,\n-                p, new SecureRandom());\n-        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n-    }\n-}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/EncryptKey.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -74,1 +74,2 @@\n-        Provider p = Security.getProvider(System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+        Provider p = Security.getProvider(\n+            System.getProperty(\"test.provider.name\", \"SunJCE\"));\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetKey.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8360563\n+ * @library \/test\/lib\n+ * @summary Testing getKeyPair using ML-KEM\n+ * @enablePreview\n+ * @modules java.base\/sun.security.util\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.util.DerValue;\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.*;\n+\n+\/*\n+ * This generates an ML-KEM key pair and makes it into PEM data.  By using\n+ * PEM, it constructs a OneAsymmetricKey structure that combines\n+ * the public key into the private key encoding.  Decode the PEM data into\n+ * a KeyPair and an EKPI for verification.\n+ *\n+ * The original private key does not have the public key encapsulated, so it\n+ * cannot be used for verification.\n+ *\n+ * Verify the decoded PEM KeyPair and EKPI.getKeyPair() return matching public\n+ * and private keys encodings; as well as, verify the original public key\n+ * matches.\n+ *\/\n+\n+public class GetKeyPair {\n+    private static final String passwdText = \"fish\";\n+    private static final char[] password = passwdText.toCharArray();\n+    private static final SecretKey key = new SecretKeySpec(\n+        passwdText.getBytes(), \"PBE\");\n+    static byte[] keyOrigPub, keyOrigPriv;\n+\n+    public static void main(String[] args) throws Exception {\n+        Provider p = Security.getProvider(\n+            System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ML-KEM\");\n+        KeyPair kpOrig = kpg.generateKeyPair();\n+        keyOrigPub = kpOrig.getPublic().getEncoded();\n+        keyOrigPriv = getPrivateKey(kpOrig.getPrivate());\n+\n+        \/\/ Encode the KeyPair into PEM, constructing an OneAsymmetricKey encoding\n+        String pem = PEMEncoder.of().withEncryption(password).\n+            encodeToString(kpOrig);\n+        \/\/ Decode to a KeyPair from the generated PEM for verification.\n+        KeyPair mlkemKP = PEMDecoder.of().withDecryption(password).\n+            decode(pem, KeyPair.class);\n+\n+        \/\/ Check decoded public key pair with original.\n+        Asserts.assertEqualsByteArray(mlkemKP.getPublic().getEncoded(),\n+            keyOrigPub, \"Initial PublicKey compare didn't match.\");\n+        byte[] priv = getPrivateKey(mlkemKP.getPrivate());\n+        Asserts.assertEqualsByteArray(priv, keyOrigPriv,\n+            \"Initial PrivateKey compare didn't match\");\n+\n+        \/\/ Decode to a EncryptedPrivateKeyInfo.\n+        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(pem,\n+            EncryptedPrivateKeyInfo.class);\n+\n+        \/\/ Test getKeyPair(password)\n+        System.out.print(\"Testing getKeyPair(char[]): \");\n+        arrayCheck(ekpi.getKeyPair(password));\n+\n+        \/\/ Test getKeyPair(key, provider) provider null\n+        System.out.print(\"Testing getKeyPair(key, null): \");\n+        arrayCheck(ekpi.getKeyPair(key, null));\n+\n+        \/\/ Test getKeyPair(key, provider) provider SunJCE\n+        System.out.print(\"Testing getKeyPair(key, SunJCE): \");\n+        arrayCheck(ekpi.getKeyPair(key, p));\n+    }\n+\n+    static void arrayCheck(KeyPair kp) throws Exception {\n+        Asserts.assertEqualsByteArray(getPrivateKey(kp.getPrivate()), keyOrigPriv,\n+            \"PrivateKey didn't match with expected.\");\n+        Asserts.assertEqualsByteArray(kp.getPublic().getEncoded(), keyOrigPub,\n+            \"PublicKey didn't match with expected.\");\n+        System.out.println(\"PASS\");\n+    }\n+\n+    static byte[] getPrivateKey(PrivateKey p) throws Exception{\n+        var val = new DerValue(p.getEncoded());\n+        \/\/ Get version\n+        val.data.getInteger();\n+        \/\/ Get AlgorithmID\n+        val.data.getDerValue();\n+        \/\/ Return PrivateKey\n+        return val.data.getOctetString();\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetKeyPair.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}