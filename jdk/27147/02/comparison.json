{"files":[{"patch":"@@ -50,1 +50,1 @@\n- * @see PEMRecord\n+ * @see PEM\n@@ -58,1 +58,1 @@\n-    X509Certificate, X509CRL, PEMRecord {\n+    X509Certificate, X509CRL, PEM {\n","filename":"src\/java.base\/share\/classes\/java\/security\/DEREncodable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.util.Pem;\n+\n+import java.io.InputStream;\n+import java.util.Base64;\n+import java.util.Objects;\n+\n+\/**\n+ * {@code PEM} is a {@link DEREncodable} that represents Privacy-Enhanced\n+ * Mail (PEM) data by its type and Base64 content.\n+ *\n+ * <p> The {@link PEMDecoder#decode(String)} and\n+ * {@link PEMDecoder#decode(InputStream)} methods return a {@code PEM} object\n+ * when the data type cannot be represented by a cryptographic object.\n+ * If {@code PEM} is desired instead of a cryptographic object, the\n+ * decoding methods {@link PEMDecoder#decode(String, Class)} or\n+ * {@link PEMDecoder#decode(InputStream, Class)} are used with\n+ * {@code PEM.class} as an argument.\n+ *\n+ * <p> A {@code PEM} object can be encoded back to its textual format by using\n+ * encode methods in {@link PEMEncoder} or the {@link #toString()} method.\n+ *\n+ * <p> When constructing a {@code PEM} instance, {@code type} and\n+ * {@code content} must not be {@code null}.\n+ *\n+ * <p>No validation is performed during instantiation to ensure that\n+ * {@code type} conforms to {@code RFC 7468} or other legacy formats, that\n+ * {@code content} is valid Base64, or that {@code content} matches the\n+ * {@code type}.\n+\n+ * Common {@code type} values include, but are not limited to:\n+ * CERTIFICATE, CERTIFICATE REQUEST, ATTRIBUTE CERTIFICATE, X509 CRL, PKCS7,\n+ * CMS, PRIVATE KEY, ENCRYPTED PRIVATE KEY, RSA PRIVATE KEY, or PUBLIC KEY.\n+ *\n+ * <p> {@code leadingData} may be null if there was no data preceding the PEM\n+ * header during decoding.  {@code leadingData} can be useful for reading\n+ * metadata that accompanies PEM data. {@code leadingData} is not defensively\n+ * copied and the {@link #leadingData()} method does not return a clone.\n+ *\n+ * @param type the type identifier from the PEM header, without PEM syntax\n+ *             labels; for example, for a public key, {@code type} would be\n+ *             \"PUBLIC KEY\"\n+ * @param content the Base64-encoded data, excluding the PEM header and footer\n+ * @param leadingData any non-PEM data that precedes the PEM header during\n+ *                   decoding.  This value may be {@code null}.\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n+ *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n+ *\n+ * @see PEMDecoder\n+ * @see PEMEncoder\n+ *\n+ * @since 25\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public record PEM(String type, String content, byte[] leadingData)\n+    implements DEREncodable {\n+\n+    \/**\n+     * Creates a {@code PEM} instance with the given parameters.\n+     *\n+     * @param type the type identifier\n+     * @param content the Base64-encoded data, excluding the PEM header and\n+     *               footer\n+     * @param leadingData any non-PEM data read during the decoding process\n+     *                    before the PEM header.  This value maybe {@code null}.\n+     * @throws IllegalArgumentException if {@code type} is incorrectly\n+     * formatted.\n+     * @throws NullPointerException if {@code type} and\/or {@code content} are\n+     * {@code null}.\n+     *\/\n+    public PEM {\n+        Objects.requireNonNull(type, \"\\\"type\\\" cannot be null.\");\n+        Objects.requireNonNull(content, \"\\\"content\\\" cannot be null.\");\n+\n+        \/\/ With no validity checking on `type`, the constructor accept anything\n+        \/\/ including lowercase.  The onus is on the caller.\n+        if (type.startsWith(\"-\") || type.startsWith(\"BEGIN \") ||\n+            type.startsWith(\"END \")) {\n+            throw new IllegalArgumentException(\"PEM syntax labels found.  \" +\n+                \"Only the PEM type identifier is allowed\");\n+        }\n+    }\n+\n+    \/**\n+     * Creates a {@code PEM} instance with a given {@code type} and\n+     * {@code content} data in String form.  {@code leadingData} is set to null.\n+     *\n+     * @param type the PEM type identifier\n+     * @param content the Base64-encoded data, excluding the PEM header and\n+     *               footer\n+     * @throws IllegalArgumentException if {@code type} is incorrectly\n+     * formatted.\n+     * @throws NullPointerException if {@code type} and\/or {@code content} are\n+     * {@code null}.\n+     *\/\n+    public PEM(String type, String content) {\n+        this(type, content, null);\n+    }\n+\n+    \/**\n+     * Returns the type and Base64 encoding in PEM textual format.\n+     * {@code leadingData} is not returned by this method.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return Pem.pemEncoded(this);\n+    }\n+\n+    \/**\n+     * Returns a Base64 decoded byte array of {@code content}.\n+     *\n+     * @return a decoded byte array of {@code content}\n+     * @throws IllegalArgumentException on a decoding error\n+     *\n+     * @see Base64#getMimeDecoder()\n+     *\/\n+    public byte[] decode() {\n+        return Base64.getMimeDecoder().decode(content);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEM.java","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.Arrays;\n@@ -48,1 +49,1 @@\n- * lists (CRLs).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n+ * lists (CRLs).  It is defined in RFC 1421 and RFC 7468. PEM consists of a\n@@ -52,3 +53,3 @@\n- * <p> The {@linkplain #decode(String)} and {@linkplain #decode(InputStream)}\n- * methods return an instance of a class that matches the data\n- * type and implements {@link DEREncodable}.\n+ * <p> The {@link #decode(String)} and {@link #decode(InputStream)}\n+ * methods return an instance of a class that matches the PEM type and\n+ * implements {@link DEREncodable}.\n@@ -71,2 +72,6 @@\n- *  Decryption)<\/li>\n- *  <li>Other types : {@code PEMRecord} <\/li>\n+ *  decryption)<\/li>\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code KeyPair} (if configured with\n+ *  decryption)<\/li>\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PKCS8EncodedKeySpec} (if configured with\n+ *  decryption)<\/li>\n+ *  <li>Other types : {@code PEM} <\/li>\n@@ -75,3 +80,3 @@\n- * <p> The {@code PublicKey} and {@code PrivateKey} types, an algorithm specific\n- * subclass is returned if the underlying algorithm is supported. For example an\n- * ECPublicKey and ECPrivateKey for Elliptic Curve keys.\n+ * <p> For {@code PublicKey} and {@code PrivateKey} types, an algorithm-specific\n+ * subclass is returned if the algorithm is supported. For example, an\n+ * {@code ECPublicKey} and {@code ECPrivateKey} for Elliptic Curve keys.\n@@ -81,1 +86,1 @@\n- * {@link PEMRecord}.\n+ * {@link PEM}.\n@@ -83,12 +88,12 @@\n- * <p> The {@linkplain #decode(String, Class)} and\n- * {@linkplain #decode(InputStream, Class)} methods take a class parameter\n- * which determines the type of {@code DEREncodable} that is returned. These\n- * methods are useful when extracting or changing the return class.\n- * For example, if the PEM contains both public and private keys, the\n- * class parameter can specify which to return. Use\n- * {@code PrivateKey.class} to return only the private key.\n- * If the class parameter is set to {@code X509EncodedKeySpec.class}, the\n- * public key will be returned in that format.  Any type of PEM data can be\n- * decoded into a {@code PEMRecord} by specifying {@code PEMRecord.class}.\n- * If the class parameter doesn't match the PEM content, a\n- * {@linkplain ClassCastException} will be thrown.\n+ * <p> The {@link #decode(String, Class)} and\n+ * {@link #decode(InputStream, Class)} methods take a class parameter\n+ * which specifies type of {@code DEREncodable} that is returned. These methods\n+ * are useful to avoid casting the return type when the PEM type is known, or\n+ * when extracting a specific type when there is more than one choice.\n+ * For example, if the PEM contains both a public and private key, specifying\n+ * {@code PrivateKey.class} returns only the private key.\n+ * If the class parameter specifies {@code X509EncodedKeySpec.class}, the\n+ * public key encoding is returned in an instance of the X509EncodedKeySpec\n+ * class.  Any type of PEM data can be decoded into a {@code PEM} object by\n+ * specifying {@code PEM.class}. If the class parameter doesn't match the PEM\n+ * content, a {@linkplain ClassCastException} will be thrown.\n@@ -97,5 +102,5 @@\n- * with {@linkplain #withFactory(Provider)} and\/or\n- * {@linkplain #withDecryption(char[])}. {@linkplain #withFactory(Provider)}\n- * configures the decoder to use only {@linkplain KeyFactory} and\n- * {@linkplain CertificateFactory} instances from the given {@code Provider}.\n- * {@linkplain #withDecryption(char[])} configures the decoder to decrypt all\n+ * with {@link #withFactory(Provider)} and\/or\n+ * {@link #withDecryption(char[])}. {@link #withFactory(Provider)}\n+ * restricts decoding to {@link KeyFactory} and\n+ * {@link CertificateFactory} instances from the specified {@code Provider}.\n+ * {@link #withDecryption(char[])} configures the decoder to process\n@@ -103,5 +108,4 @@\n- * Configuring an instance for decryption does not prevent decoding with\n- * unencrypted PEM. Any encrypted PEM that fails decryption\n- * will throw a {@link RuntimeException}. When an encrypted private key PEM is\n- * used with a decoder not configured for decryption, an\n- * {@link EncryptedPrivateKeyInfo} object is returned.\n+ * If decryption fails, a {@link RuntimeException} is thrown.\n+ * If an encrypted private key PEM is processed by a decoder not configured\n+ * for decryption, an {@link EncryptedPrivateKeyInfo} object is returned.\n+ * Decryption configured instances will decode unencrypted PEM.\n@@ -109,1 +113,1 @@\n- * <p>This class is immutable and thread-safe.\n+ * <p> This class is immutable and thread-safe.\n@@ -131,1 +135,1 @@\n- * @see PEMRecord\n+ * @see PEM\n@@ -175,1 +179,1 @@\n-    private DEREncodable decode(PEMRecord pem) {\n+    private DEREncodable decode(PEM pem) {\n@@ -205,2 +209,1 @@\n-                        \/\/ encodings, look for the public key again.  This\n-                        \/\/ happens with EC and SEC1-v2 encoding\n+                        \/\/ encodings, look for the public key again.\n@@ -221,2 +224,5 @@\n-                    yield new EncryptedPrivateKeyInfo(decoder.decode(pem.content())).\n-                        getKey(password.getPassword());\n+                    byte[] p8 = Pem.decryptEncoding(\n+                        decoder.decode(pem.content()), password.getPassword());\n+                    DEREncodable d = Pem.toDEREncodable(p8, true, factory);\n+                    Arrays.fill(p8, (byte)0x0);\n+                    yield d;\n@@ -258,1 +264,1 @@\n-     * Otherwise, a {@link PEMRecord} will be returned containing\n+     * Otherwise, a {@link PEM} will be returned containing\n@@ -296,1 +302,1 @@\n-     * Otherwise, a {@link PEMRecord} will be returned containing\n+     * Otherwise, a {@link PEM} will be returned containing\n@@ -314,1 +320,1 @@\n-        PEMRecord pem = Pem.readPEM(is);\n+        PEM pem = Pem.readPEM(is);\n@@ -327,2 +333,2 @@\n-     * <p> If the class parameter is {@code PEMRecord.class},\n-     * a {@linkplain PEMRecord} is returned containing the\n+     * <p> If the class parameter is {@code PEM.class},\n+     * a {@link PEM} is returned containing the\n@@ -368,2 +374,2 @@\n-     * <p> If the class parameter is {@code PEMRecord.class},\n-     * a {@linkplain PEMRecord} is returned containing the\n+     * <p> If the class parameter is {@code PEM.class},\n+     * a {@link PEM} is returned containing the\n@@ -385,1 +391,1 @@\n-     * @throws IllegalArgumentException on error in decoding\n+     * @throws IllegalArgumentException on error with arguments or in decoding\n@@ -396,1 +402,1 @@\n-        PEMRecord pem = Pem.readPEM(is);\n+        PEM pem = Pem.readPEM(is);\n@@ -398,1 +404,1 @@\n-        if (tClass.isAssignableFrom(PEMRecord.class)) {\n+        if (tClass.isAssignableFrom(PEM.class)) {\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":55,"deletions":49,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n@@ -33,1 +31,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -43,0 +40,1 @@\n+import java.util.Arrays;\n@@ -60,1 +58,1 @@\n- * {@code PEMEncoder} with the {@linkplain #withEncryption(char[])} method,\n+ * {@code PEMEncoder} with the {@link #withEncryption(char[])} method,\n@@ -73,4 +71,4 @@\n- * <p> When encoding a {@link PEMRecord}, the API surrounds the\n- * {@linkplain PEMRecord#content()} with the PEM header and footer\n- * from {@linkplain PEMRecord#type()}. {@linkplain PEMRecord#leadingData()} is\n- * not included in the encoding.  {@code PEMRecord} will not perform\n+ * <p> When encoding a {@link PEM}, the API surrounds the\n+ * {@link PEM#content()} with the PEM header and footer\n+ * from {@link PEM#type()}. {@link PEM#leadingData()} is\n+ * not included in the encoding.  {@code PEM} will not perform\n@@ -85,1 +83,1 @@\n- *  <li>{@code PublicKey}: PUBLIC KEY<\/li>\n+ *  <li>{@code PublicKey} : PUBLIC KEY<\/li>\n@@ -91,0 +89,2 @@\n+ *  <li>{@code KeyPair} (if configured with encryption) : ENCRYPTED PRIVATE KEY\n+ *  <\/li>\n@@ -93,1 +93,3 @@\n- *  <li>{@code PEMRecord} : {@code PEMRecord.type()}<\/li>\n+ *  <li>{@code PKCS8EncodedKeySpec} (if configured with encryption) :\n+ *  ENCRYPTED PRIVATE KEY<\/li>\n+ *  <li>{@code PEM} : {@code PEM.type()}<\/li>\n@@ -98,1 +100,1 @@\n- * <p> Here is an example of encoding a {@code PrivateKey} object:\n+ * <p> Here is an example of encoding a private key object:\n@@ -116,1 +118,1 @@\n- * @see PEMRecord\n+ * @see PEM\n@@ -121,0 +123,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc5958\n+ *       RFC 5958: Asymmetric Key Packages\n@@ -174,2 +178,2 @@\n-            case PublicKey pu -> buildKey(null, pu.getEncoded());\n-            case PrivateKey pr -> buildKey(pr.getEncoded(), null);\n+            case PublicKey pu -> buildKey(pu.getEncoded(), null);\n+            case PrivateKey pr -> buildKey(null, pr.getEncoded());\n@@ -185,2 +189,2 @@\n-                yield buildKey(kp.getPrivate().getEncoded(),\n-                    kp.getPublic().getEncoded());\n+                yield buildKey(kp.getPublic().getEncoded(),\n+                    kp.getPrivate().getEncoded());\n@@ -189,1 +193,1 @@\n-                buildKey(null, x.getEncoded());\n+                buildKey(x.getEncoded(), null);\n@@ -191,1 +195,1 @@\n-                buildKey(p.getEncoded(), null);\n+                buildKey(null, p.getEncoded());\n@@ -222,1 +226,1 @@\n-            case PEMRecord rec -> {\n+            case PEM rec -> {\n@@ -224,1 +228,1 @@\n-                    throw new IllegalArgumentException(\"PEMRecord cannot be \" +\n+                    throw new IllegalArgumentException(\"PEM cannot be \" +\n@@ -254,1 +258,2 @@\n-     * <p> Only {@link PrivateKey} objects can be encrypted with this newly\n+     * <p> Only {@link PrivateKey}, {@link KeyPair}, and\n+     * {@link PKCS8EncodedKeySpec} objects can be encoded with this newly\n@@ -263,1 +268,1 @@\n-     * {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, Key,\n+     * {@link EncryptedPrivateKeyInfo#encryptKey(DEREncodable, Key,\n@@ -280,0 +285,2 @@\n+     *\n+     * privateKeyEncoding will be zeroed when the method returns\n@@ -281,5 +288,2 @@\n-    private String buildKey(byte[] privateBytes, byte[] publicBytes) {\n-        DerOutputStream out = new DerOutputStream();\n-        Cipher cipher;\n-\n-        if (privateBytes == null && publicBytes == null) {\n+    private String buildKey(byte[] publicEncoding, byte[] privateEncoding) {\n+        if (publicEncoding == null && privateEncoding == null) {\n@@ -290,0 +294,5 @@\n+        if (publicEncoding != null && publicEncoding.length == 0) {\n+            throw new IllegalArgumentException(\"Public key has no \" +\n+                \"encoding\");\n+        }\n+\n@@ -317,3 +326,3 @@\n-            if (privateBytes == null || publicBytes != null) {\n-                throw new IllegalArgumentException(\"Can only encrypt a \" +\n-                    \"PrivateKey.\");\n+            if (privateEncoding == null) {\n+                throw new IllegalArgumentException(\"This DEREncodable cannot \" +\n+                    \"be encrypted.\");\n@@ -322,0 +331,1 @@\n+            byte[] encoding = null;\n@@ -323,16 +333,17 @@\n-                cipher = Cipher.getInstance(Pem.DEFAULT_ALGO);\n-                cipher.init(Cipher.ENCRYPT_MODE, key);\n-            } catch (GeneralSecurityException e) {\n-                throw new IllegalArgumentException(\"Security property \" +\n-                    \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n-                    \"valid algorithm.  Operation cannot be performed.\", e);\n-            }\n-\n-            try {\n-                new AlgorithmId(Pem.getPBEID(Pem.DEFAULT_ALGO),\n-                    cipher.getParameters()).encode(out);\n-                out.putOctetString(cipher.doFinal(privateBytes));\n-                return Pem.pemEncoded(Pem.ENCRYPTED_PRIVATE_KEY,\n-                    DerValue.wrap(DerValue.tag_Sequence, out).toByteArray());\n-            } catch (GeneralSecurityException e) {\n-                throw new IllegalArgumentException(e);\n+                if (publicEncoding == null) {\n+                    encoding = privateEncoding;\n+                } else {\n+                    encoding = PKCS8Key.getEncoded(publicEncoding,\n+                        privateEncoding);\n+                    \/\/ The public key is part of the private encoding.\n+                    publicEncoding = null;\n+                }\n+                privateEncoding = EncryptedPrivateKeyInfo.encryptKey(\n+                    new PKCS8EncodedKeySpec(encoding), key, null, null, null,\n+                    null).getEncoded();\n+            } catch (IOException e) {\n+                throw new IllegalArgumentException(\"Error while encoding\", e);\n+            } finally {\n+                if (encoding != null) {\n+                    Arrays.fill(encoding, (byte) 0x0);\n+                }\n@@ -343,2 +354,2 @@\n-        if (publicBytes != null && privateBytes == null) {\n-            if (publicBytes.length == 0) {\n+        if (publicEncoding != null && privateEncoding == null) {\n+            if (publicEncoding.length == 0) {\n@@ -348,2 +359,1 @@\n-\n-            return Pem.pemEncoded(Pem.PUBLIC_KEY, publicBytes);\n+            return Pem.pemEncoded(Pem.PUBLIC_KEY, publicEncoding);\n@@ -352,12 +362,1 @@\n-        \/\/ PKCS8 only\n-        if (publicBytes == null && privateBytes != null) {\n-            if (privateBytes.length == 0) {\n-                throw new IllegalArgumentException(\"No private key encoding \" +\n-                    \"given by the DEREncodable.\");\n-            }\n-\n-            return Pem.pemEncoded(Pem.PRIVATE_KEY, privateBytes);\n-        }\n-\n-        \/\/ OneAsymmetricKey\n-        if (privateBytes.length == 0) {\n+        if (privateEncoding.length == 0) {\n@@ -368,4 +367,0 @@\n-        if (publicBytes.length == 0) {\n-            throw new IllegalArgumentException(\"No public key encoding \" +\n-                \"given by the DEREncodable.\");\n-        }\n@@ -373,4 +368,5 @@\n-            return Pem.pemEncoded(Pem.PRIVATE_KEY,\n-                PKCS8Key.getEncoded(publicBytes, privateBytes));\n-        } catch (IOException e) {\n-            throw new IllegalArgumentException(e);\n+            return Pem.pemEncoded(\n+                (key == null ? Pem.PRIVATE_KEY : Pem.ENCRYPTED_PRIVATE_KEY),\n+                privateEncoding);\n+        } finally {\n+            Arrays.fill(privateEncoding, (byte)0x0);\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":66,"deletions":70,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.security;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-import sun.security.util.Pem;\n-\n-import java.util.Objects;\n-\n-\/**\n- * {@code PEMRecord} is a {@link DEREncodable} that represents Privacy-Enhanced\n- * Mail (PEM) data by its type and Base64 form.  {@link PEMDecoder} and\n- * {@link PEMEncoder} use {@code PEMRecord} when representing the data as a\n- * cryptographic object is not desired or the type has no\n- * {@code DEREncodable}.\n- *\n- * <p> {@code type} and {@code content} may not be {@code null}.\n- * {@code leadingData} may be null if no non-PEM data preceded PEM header\n- * during decoding.  {@code leadingData} may be useful for reading metadata\n- * that accompanies PEM data.\n- *\n- * <p> No validation is performed during instantiation to ensure that\n- * {@code type} conforms to {@code RFC 7468}, that {@code content} is valid\n- * Base64, or that {@code content} matches the {@code type}.\n- * {@code leadingData} is not defensively copied and does not return a\n- * clone when {@linkplain #leadingData()} is called.\n- *\n- * @param type the type identifier in the PEM header without PEM syntax labels.\n- *           For a public key, {@code type} would be \"PUBLIC KEY\".\n- * @param content the Base64-encoded data, excluding the PEM header and footer\n- * @param leadingData any non-PEM data preceding the PEM header when decoding.\n- *\n- * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n- *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n- *\n- * @see PEMDecoder\n- * @see PEMEncoder\n- *\n- * @since 25\n- *\/\n-@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n-public record PEMRecord(String type, String content, byte[] leadingData)\n-    implements DEREncodable {\n-\n-    \/**\n-     * Creates a {@code PEMRecord} instance with the given parameters.\n-     *\n-     * @param type the type identifier\n-     * @param content the Base64-encoded data, excluding the PEM header and\n-     *               footer\n-     * @param leadingData any non-PEM data read during the decoding process\n-     *                    before the PEM header.  This value maybe {@code null}.\n-     * @throws IllegalArgumentException if {@code type} is incorrectly\n-     * formatted.\n-     * @throws NullPointerException if {@code type} and\/or {@code content} are\n-     * {@code null}.\n-     *\/\n-    public PEMRecord {\n-        Objects.requireNonNull(type, \"\\\"type\\\" cannot be null.\");\n-        Objects.requireNonNull(content, \"\\\"content\\\" cannot be null.\");\n-\n-        \/\/ With no validity checking on `type`, the constructor accept anything\n-        \/\/ including lowercase.  The onus is on the caller.\n-        if (type.startsWith(\"-\") || type.startsWith(\"BEGIN \") ||\n-            type.startsWith(\"END \")) {\n-            throw new IllegalArgumentException(\"PEM syntax labels found.  \" +\n-                \"Only the PEM type identifier is allowed\");\n-        }\n-\n-    }\n-\n-    \/**\n-     * Creates a {@code PEMRecord} instance with a given {@code type} and\n-     * {@code content} data in String form.  {@code leadingData} is set to null.\n-     *\n-     * @param type the PEM type identifier\n-     * @param content the Base64-encoded data, excluding the PEM header and\n-     *               footer\n-     * @throws IllegalArgumentException if {@code type} is incorrectly\n-     * formatted.\n-     * @throws NullPointerException if {@code type} and\/or {@code content} are\n-     * {@code null}.\n-     *\/\n-    public PEMRecord(String type, String content) {\n-        this(type, content, null);\n-    }\n-\n-    \/**\n-     * Returns the type and Base64 encoding in PEM format.  {@code leadingData}\n-     * is not returned by this method.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return Pem.pemEncoded(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Arrays;\n@@ -299,0 +300,15 @@\n+    \/\/ Return the decrypted encryptedData in this instance.\n+    private byte[] decryptData(Key decryptKey, Provider provider)\n+        throws GeneralSecurityException {\n+        Cipher c;\n+        if (provider == null) {\n+            \/\/ use the most preferred one\n+            c = Cipher.getInstance(getAlgName());\n+        } else {\n+            c = Cipher.getInstance(getAlgName(), provider);\n+        }\n+        c.init(Cipher.DECRYPT_MODE, decryptKey, getAlgParameters());\n+        return c.doFinal(encryptedData);\n+    }\n+\n+    \/\/ Wrap the decrypted encryptedData in a P8EKS for getKeySpec methods.\n@@ -302,2 +318,0 @@\n-        byte[] encoded;\n-        Cipher c;\n@@ -305,9 +319,1 @@\n-            if (provider == null) {\n-                \/\/ use the most preferred one\n-                c = Cipher.getInstance(getAlgName());\n-            } else {\n-                c = Cipher.getInstance(getAlgName(), provider);\n-            }\n-            c.init(Cipher.DECRYPT_MODE, decryptKey, getAlgParameters());\n-            encoded = c.doFinal(encryptedData);\n-            return pkcs8EncodingToSpec(encoded);\n+            return pkcs8EncodingToSpec(decryptData(decryptKey, provider));\n@@ -319,1 +325,1 @@\n-                    \"Cannot retrieve the PKCS8EncodedKeySpec\", ex);\n+                \"Cannot retrieve the PKCS8EncodedKeySpec\", ex);\n@@ -325,1 +331,1 @@\n-     * {@code PrivateKey}.  A valid password-based encryption (PBE) algorithm\n+     * {@code DEREncodable}.  A valid password-based encryption (PBE) algorithm\n@@ -333,1 +339,3 @@\n-     * @param key the {@code PrivateKey} to be encrypted\n+     * @param de the {@code DEREncodable} to be encrypted. Usage\n+     *             limited to {@link PrivateKey}, {@link KeyPair}, and\n+     *            {@link PKCS8EncodedKeySpec}.\n@@ -360,1 +368,1 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+    public static EncryptedPrivateKeyInfo encryptKey(DEREncodable de,\n@@ -364,2 +372,1 @@\n-        SecretKey skey;\n-        Objects.requireNonNull(key, \"key cannot be null\");\n+        Objects.requireNonNull(de, \"key cannot be null\");\n@@ -367,1 +374,0 @@\n-        PBEKeySpec keySpec = new PBEKeySpec(password);\n@@ -376,0 +382,1 @@\n+        char[] passwd = password.clone();\n@@ -377,9 +384,5 @@\n-            SecretKeyFactory factory;\n-            if (provider == null) {\n-                factory = SecretKeyFactory.getInstance(algorithm);\n-            } else {\n-                factory = SecretKeyFactory.getInstance(algorithm, provider);\n-            }\n-            skey = factory.generateSecret(keySpec);\n-        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n-            throw new IllegalArgumentException(e);\n+            return encryptKeyImpl(getEncoding(de), algorithm,\n+                generateSecretKey(password, algorithm, provider), params,\n+                provider, null);\n+        } finally {\n+            Arrays.fill(passwd, (char)0x0);\n@@ -387,1 +390,0 @@\n-        return encryptKeyImpl(key, algorithm, skey, params, provider, null);\n@@ -392,1 +394,1 @@\n-     * {@code PrivateKey} and password.  Default algorithm and parameters are\n+     * {@code DEREncodable} and password.  Default algorithm and parameters are\n@@ -395,1 +397,3 @@\n-     * @param key the {@code PrivateKey} to be encrypted\n+     * @param de the {@code DEREncodable} to be encrypted. Usage\n+     *            limited to {@link PrivateKey}, {@link KeyPair}, and\n+     *            {@link PKCS8EncodedKeySpec}.\n@@ -412,1 +416,1 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+    public static EncryptedPrivateKeyInfo encryptKey(DEREncodable de,\n@@ -414,1 +418,2 @@\n-        return encryptKey(key, password, Pem.DEFAULT_ALGO, null, null);\n+        return encryptKey(de, password, Pem.DEFAULT_ALGO, null,\n+            null);\n@@ -419,1 +424,1 @@\n-     * {@link PrivateKey} using the {@code encKey} and given parameters.\n+     * {@link DEREncodable} using the {@code encKey} and given parameters.\n@@ -421,2 +426,4 @@\n-     * @param key the {@code PrivateKey} to be encrypted\n-     * @param encKey the password-based encryption (PBE) {@code Key} used to\n+     * @param de the {@code DEREncodable} to be encrypted. Usage\n+     *            limited to {@link PrivateKey}, {@link KeyPair}, and\n+     *            {@link PKCS8EncodedKeySpec}.\n+     * @param encryptKey the password-based encryption (PBE) {@code Key} used to\n@@ -450,3 +457,3 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key, Key encKey,\n-        String algorithm, AlgorithmParameterSpec params, Provider provider,\n-        SecureRandom random) {\n+    public static EncryptedPrivateKeyInfo encryptKey(DEREncodable de,\n+        Key encryptKey, String algorithm, AlgorithmParameterSpec params,\n+        Provider provider, SecureRandom random) {\n@@ -454,2 +461,3 @@\n-        Objects.requireNonNull(key);\n-        Objects.requireNonNull(encKey);\n+        Objects.requireNonNull(de, \"key cannot be null\");\n+        Objects.requireNonNull(encryptKey, \"an encryption key must be\" +\n+            \"specified.\");\n@@ -463,1 +471,2 @@\n-        return encryptKeyImpl(key, algorithm, encKey, params, provider, random);\n+        return encryptKeyImpl(getEncoding(de), algorithm, encryptKey,\n+            params, provider, random);\n@@ -466,1 +475,1 @@\n-    private static EncryptedPrivateKeyInfo encryptKeyImpl(PrivateKey key,\n+    private static EncryptedPrivateKeyInfo encryptKeyImpl(byte[] encoded,\n@@ -484,1 +493,1 @@\n-            encryptedData = c.doFinal(key.getEncoded());\n+            encryptedData = c.doFinal(encoded);\n@@ -495,0 +504,2 @@\n+        } finally {\n+            Arrays.fill(encoded, (byte) 0x0);\n@@ -502,2 +513,1 @@\n-     * Extract the enclosed {@code PrivateKey} object from the encrypted data\n-     * and return it.\n+     * Extracts and returns a {@code PrivateKey} object from the encrypted data.\n@@ -507,4 +517,4 @@\n-     * @return a {@code PrivateKey}\n-     * @throws GeneralSecurityException if an error occurs parsing or\n-     * decrypting the encrypted data, or producing the key object.\n-     * @throws NullPointerException if {@code password} is null\n+     * @return a {@code PrivateKey} extracted from the encrypted data\n+     * @throws GeneralSecurityException if an error occurs parsing,\n+     * decrypting the data, or producing the key object.\n+     * @throws NullPointerException if {@code password} is {@code null}\n@@ -516,2 +526,0 @@\n-        SecretKeyFactory skf;\n-        PKCS8EncodedKeySpec p8KeySpec;\n@@ -519,5 +527,1 @@\n-        PBEKeySpec keySpec = new PBEKeySpec(password);\n-        skf = SecretKeyFactory.getInstance(getAlgName());\n-        p8KeySpec = getKeySpec(skf.generateSecret(keySpec));\n-\n-        return PKCS8Key.parseKey(p8KeySpec.getEncoded());\n+        return PKCS8Key.parseKey(Pem.decryptEncoding(encoded, password),null);\n@@ -527,2 +531,1 @@\n-     * Extract the enclosed {@code PrivateKey} object from the encrypted data\n-     * and return it.\n+     * Extracts and returns a {@code PrivateKey} object from the encrypted data.\n@@ -534,4 +537,4 @@\n-     * @return a {@code PrivateKey}\n-     * @throws GeneralSecurityException if an error occurs parsing or\n-     * decrypting the encrypted data, or producing the key object.\n-     * @throws NullPointerException if {@code decryptKey} is null\n+     * @return a {@code PrivateKey} extracted from the encrypted data\n+     * @throws GeneralSecurityException if an error occurs parsing,\n+     * decrypting the data, or producing the key object.\n+     * @throws NullPointerException if {@code decryptKey} is {@code null}\n@@ -545,12 +548,60 @@\n-        PKCS8EncodedKeySpec p = getKeySpecImpl(decryptKey, provider);\n-        try {\n-            if (provider == null) {\n-                return KeyFactory.getInstance(\n-                    KeyUtil.getAlgorithm(p.getEncoded())).\n-                    generatePrivate(p);\n-            }\n-            return KeyFactory.getInstance(KeyUtil.getAlgorithm(p.getEncoded()),\n-                provider).generatePrivate(p);\n-        } catch (IOException e) {\n-            throw new GeneralSecurityException(e);\n-        }\n+        return PKCS8Key.parseKey(decryptData(decryptKey, provider), null);\n+    }\n+\n+    \/**\n+     * Extracts and returns a {@code KeyPair} object from the encrypted data.\n+     * The data must contain both a public and private key.\n+     *\n+     * @param password the password used in the PBE encryption.  This array\n+     *                 will be cloned before being used.\n+     * @return a {@code KeyPair} extracted from the encrypted data\n+     * @throws GeneralSecurityException if an error occurs while parsing,\n+     * decrypting the data, or producing the {@code KeyPair} object.\n+     * @throws NullPointerException if {@code password} is {@code null}\n+     *\n+     * @since 26\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public KeyPair getKeyPair(char[] password) throws GeneralSecurityException {\n+        Objects.requireNonNull(password, \"password cannot be null\");\n+\n+        DEREncodable d = Pem.toDEREncodable(\n+            Pem.decryptEncoding(encoded, password), true, null);\n+        return switch (d) {\n+            case KeyPair kp -> kp;\n+            case PrivateKey ignored -> throw new InvalidKeyException(\n+                \"This encoding do not contain a public key.\");\n+            default -> throw new InvalidKeyException(\n+                \"Invalid class returned \" + d.getClass().getName());\n+        };\n+    }\n+\n+    \/**\n+     * Extracts and returns a {@code KeyPair} object from the encrypted data.\n+     * The data must contain both a public and private key.\n+     *\n+     * @param decryptKey the decryption key and cannot be {@code null}\n+     * @param provider the {@code Provider} used for Cipher decryption and\n+     *                 key generation. A {@code null} value will\n+     *                 use the default provider configuration.\n+     * @return a {@code KeyPair} extracted from the encrypted data\n+     * @throws GeneralSecurityException if an error occurs parsing,\n+     * decrypting the data, or producing the {@code KeyPair} object.\n+     * @throws NullPointerException if {@code decryptKey} is {@code null}\n+     *\n+     * @since 26\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public KeyPair getKeyPair(Key decryptKey, Provider provider)\n+        throws GeneralSecurityException {\n+        Objects.requireNonNull(decryptKey,\"decryptKey cannot be null.\");\n+\n+        DEREncodable d = Pem.toDEREncodable(\n+            decryptData(decryptKey, provider),true, provider);\n+        return switch (d) {\n+            case KeyPair kp -> kp;\n+            case PrivateKey ignored -> throw new InvalidKeyException(\n+                \"This encoding do not contain a public key.\");\n+            default -> throw new InvalidKeyException(\n+                \"Invalid class returned \" + d.getClass().getName());\n+        };\n@@ -673,8 +724,1 @@\n-    private static void checkTag(DerValue val, byte tag, String valName)\n-        throws IOException {\n-        if (val.getTag() != tag) {\n-            throw new IOException(\"invalid key encoding - wrong tag for \" +\n-                                  valName);\n-        }\n-    }\n-\n+    \/\/ Read the encodedKey and return a P8EKS with the algorithm specified\n@@ -686,0 +730,38 @@\n+\n+    \/\/ Return the PKCS#8 encoding from a DEREncodable\n+    private static byte[] getEncoding(DEREncodable d) {\n+        return switch (d) {\n+            case PrivateKey p -> p.getEncoded();\n+            case PKCS8EncodedKeySpec p8 -> p8.getEncoded();\n+            case KeyPair kp -> {\n+                try {\n+                    yield PKCS8Key.getEncoded(kp.getPublic().getEncoded(),\n+                        kp.getPrivate().getEncoded());\n+                } catch (IOException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            default -> throw new IllegalArgumentException(\n+                d.getClass().getName() + \" not supported by this method\");\n+        };\n+    }\n+\n+    \/\/ Generate a SecretKey from the password.\n+    private static SecretKey generateSecretKey(char[] password, String algorithm,\n+        Provider provider) {\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+\n+        try {\n+            SecretKeyFactory factory;\n+            if (provider == null) {\n+                factory = SecretKeyFactory.getInstance(algorithm);\n+            } else {\n+                factory = SecretKeyFactory.getInstance(algorithm, provider);\n+            }\n+            return factory.generateSecret(keySpec);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            throw new IllegalArgumentException(e);\n+        } finally {\n+            keySpec.clearPassword();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":164,"deletions":82,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -95,2 +95,11 @@\n-        makeEncoding(s);\n-\n+        byte[] sArr = s.toByteArray();\n+        \/\/ convert to fixed-length array\n+        int numOctets = (params.getOrder().bitLength() + 7) \/ 8;\n+        byte[] sOctets = new byte[numOctets];\n+        int inPos = Math.max(sArr.length - sOctets.length, 0);\n+        int outPos = Math.max(sOctets.length - sArr.length, 0);\n+        int length = Math.min(sArr.length, sOctets.length);\n+        System.arraycopy(sArr, inPos, sOctets, outPos, length);\n+        Arrays.fill(sArr, (byte) 0);\n+        makeEncoding(sOctets);\n+        Arrays.fill(sOctets, (byte) 0);\n@@ -103,9 +112,1 @@\n-        makeEncoding(s);\n-    }\n-\n-    private void makeEncoding(byte[] s) throws InvalidKeyException {\n-        algid = new AlgorithmId\n-                (AlgorithmId.EC_oid, ECParameters.getAlgorithmParameters(params));\n-        DerOutputStream out = new DerOutputStream();\n-        out.putInteger(1); \/\/ version 1\n-        byte[] privBytes = s.clone();\n+        byte[] privBytes = arrayS.clone();\n@@ -113,1 +114,1 @@\n-        out.putOctetString(privBytes);\n+        makeEncoding(privBytes);\n@@ -115,3 +116,0 @@\n-        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n-        privKeyMaterial = val.toByteArray();\n-        val.clear();\n@@ -120,1 +118,1 @@\n-    private void makeEncoding(BigInteger s) throws InvalidKeyException {\n+    private void makeEncoding(byte[] privBytes) throws InvalidKeyException {\n@@ -122,11 +120,1 @@\n-                ECParameters.getAlgorithmParameters(params));\n-        byte[] sArr = s.toByteArray();\n-        \/\/ convert to fixed-length array\n-        int numOctets = (params.getOrder().bitLength() + 7) \/ 8;\n-        byte[] sOctets = new byte[numOctets];\n-        int inPos = Math.max(sArr.length - sOctets.length, 0);\n-        int outPos = Math.max(sOctets.length - sArr.length, 0);\n-        int length = Math.min(sArr.length, sOctets.length);\n-        System.arraycopy(sArr, inPos, sOctets, outPos, length);\n-        Arrays.fill(sArr, (byte) 0);\n-\n+            ECParameters.getAlgorithmParameters(params));\n@@ -135,2 +123,1 @@\n-        out.putOctetString(sOctets);\n-        Arrays.fill(sOctets, (byte) 0);\n+        out.putOctetString(privBytes);\n@@ -256,0 +243,37 @@\n+\n+    \/\/ Parse the SEC1v2 encoding to extract public key, if available.\n+    public static BitArray parsePublicBits(byte[] privateBytes) {\n+        DerValue seq = null;\n+        try {\n+            seq = new DerValue(privateBytes);\n+            if (seq.tag == DerValue.tag_Sequence) {\n+                int version = seq.data.getInteger();\n+                if (version == 1) { \/\/ EC\n+                    byte[] oct = seq.data.getOctetString();  \/\/ private key\n+                    Arrays.fill(oct, (byte) 0x0);\n+                    if (seq.data.available() != 0) {\n+                        DerValue derValue = seq.data.getDerValue();\n+                        \/\/ check for optional [0] EC domain parameters\n+                        if (derValue.isContextSpecific((byte) 0)) {\n+                            if (seq.data.available() == 0) {\n+                                return null;\n+                            }\n+                            derValue = seq.data.getDerValue();\n+                        }\n+                        \/\/ [1] public key\n+                        if (derValue.isContextSpecific((byte) 1)) {\n+                            derValue = derValue.data.getDerValue();\n+                            return derValue.getUnalignedBitString();\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(e);\n+        } finally {\n+            if (seq != null) {\n+                seq.clear();\n+            }\n+        }\n+        return null;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":53,"deletions":29,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.ec.ECPrivateKeyImpl;\n@@ -107,1 +108,6 @@\n-    private PKCS8Key(byte[] privEncoding, byte[] pubEncoding)\n+    \/**\n+     * Constructor that takes both public and private encodings.  If\n+     * publicEncoding is null, a V1 PKCS8 encoding is created; otherwise, V2 is\n+     * encoded.\n+     *\/\n+    public PKCS8Key(byte[] publicEncoding, byte[] privateEncoding)\n@@ -109,3 +115,15 @@\n-        this(privEncoding);\n-        pubKeyEncoded = pubEncoding;\n-        version = V2;\n+        this(privateEncoding);\n+        if (publicEncoding != null) {\n+            if (pubKeyEncoded != null) {\n+                if (!Arrays.equals(pubKeyEncoded, publicEncoding)) {\n+                    Arrays.fill(privKeyMaterial, (byte) 0x0);\n+                    throw new InvalidKeyException(\"PrivateKey \" +\n+                        \"encoding has a public key that does not match \" +\n+                        \"the given PublicKey\");\n+                }\n+                version = V1;\n+            } else {\n+                pubKeyEncoded = publicEncoding;\n+                version = V2;\n+            }\n+        }\n@@ -140,0 +158,8 @@\n+            \/\/ Special check and parsing for ECDSA's SEC1v2 format\n+            if (algid.getOID().equals(AlgorithmId.EC_oid)) {\n+                var bits = ECPrivateKeyImpl.parsePublicBits(privKeyMaterial);\n+                if (bits != null) {\n+                    pubKeyEncoded = new X509Key(algid, bits).getEncoded();\n+                }\n+            }\n+\n@@ -274,1 +300,1 @@\n-     * @param pubKeyEncoded DER-encoded PublicKey\n+     * @param pubKeyEncoded DER-encoded PublicKey, this may be null.\n@@ -281,0 +307,1 @@\n+        PKCS8Key pkcs8Key;\n@@ -282,2 +309,1 @@\n-            return new PKCS8Key(privKeyEncoded, pubKeyEncoded).\n-                generateEncoding();\n+            pkcs8Key = new PKCS8Key(pubKeyEncoded, privKeyEncoded);\n@@ -287,0 +313,3 @@\n+        byte[] result = pkcs8Key.generateEncoding().clone();\n+        pkcs8Key.clear();\n+        return result;\n@@ -329,1 +358,0 @@\n-                \/\/ X509Key x = X509Key.parse(pubKeyEncoded);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":36,"deletions":8,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.security.PEMRecord;\n+import java.security.PEM;\n@@ -562,1 +562,1 @@\n-                PEMRecord rec;\n+                PEM rec;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.pkcs.PKCS8Key;\n@@ -30,0 +32,3 @@\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n@@ -32,3 +37,4 @@\n-import java.security.NoSuchAlgorithmException;\n-import java.security.PEMRecord;\n-import java.security.Security;\n+import java.security.*;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n@@ -162,1 +168,1 @@\n-    public static PEMRecord readPEM(InputStream is, boolean shortHeader)\n+    public static PEM readPEM(InputStream is, boolean shortHeader)\n@@ -314,1 +320,1 @@\n-        return new PEMRecord(typeConverter(headerType), data, preData);\n+        return new PEM(typeConverter(headerType), data, preData);\n@@ -317,1 +323,1 @@\n-    public static PEMRecord readPEM(InputStream is) throws IOException {\n+    public static PEM readPEM(InputStream is) throws IOException {\n@@ -345,1 +351,1 @@\n-    public static String pemEncoded(PEMRecord pem) {\n+    public static String pemEncoded(PEM pem) {\n@@ -349,0 +355,100 @@\n+\n+    \/*\n+     * Get PKCS8 encoding from an encrypted private key encoding.\n+     *\/\n+    public static byte[] decryptEncoding(byte[] encoded, char[] password)\n+        throws GeneralSecurityException {\n+        EncryptedPrivateKeyInfo ekpi;\n+\n+        Objects.requireNonNull(password, \"password cannot be null\");\n+        try {\n+            ekpi = new EncryptedPrivateKeyInfo(encoded);\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        SecretKeyFactory skf = SecretKeyFactory.getInstance(ekpi.getAlgName());\n+        PKCS8EncodedKeySpec p8KeySpec =\n+            ekpi.getKeySpec(skf.generateSecret(keySpec));\n+        byte[] result = p8KeySpec.getEncoded();\n+            SharedSecrets.getJavaSecuritySpecAccess().\n+                clearEncodedKeySpec(p8KeySpec);\n+            keySpec.clearPassword();\n+        return result;\n+    }\n+\n+\n+    \/**\n+     * With a given PKCS8 encoding, construct a PrivateKey or KeyPair.  A\n+     * KeyPair is returned if requested and the encoding has a public key;\n+     * otherwise, a PrivateKey is returned.\n+     *\n+     * @param encoded PKCS8 encoding\n+     * @param pair set to true for returning a KeyPair, if possible. Otherwise,\n+     *             return a PrivateKey\n+     * @param provider KeyFactory provider\n+     *\/\n+    public static DEREncodable toDEREncodable(byte[] encoded, boolean pair,\n+        Provider provider) throws InvalidKeyException {\n+\n+        PrivateKey privKey;\n+        PublicKey pubKey = null;\n+        PKCS8EncodedKeySpec p8KeySpec;\n+        PKCS8Key p8key = new PKCS8Key(encoded);\n+        KeyFactory kf;\n+\n+        try {\n+            p8KeySpec = new PKCS8EncodedKeySpec(encoded);\n+        } catch (NullPointerException e) {\n+            throw new InvalidKeyException(\"No encoding found\", e);\n+        }\n+\n+        try {\n+            if (provider == null) {\n+                kf = KeyFactory.getInstance(p8key.getAlgorithm());\n+            } else {\n+                kf = KeyFactory.getInstance(p8key.getAlgorithm(), provider);\n+            }\n+        } catch (NoSuchAlgorithmException e) {\n+            p8key.clear();\n+            SharedSecrets.getJavaSecuritySpecAccess().\n+                clearEncodedKeySpec(p8KeySpec);\n+            throw new InvalidKeyException(\"Unable to find the algorithm: \" +\n+                p8key.getAlgorithm(), e);\n+        }\n+\n+        try {\n+            privKey = kf.generatePrivate(p8KeySpec);\n+\n+            \/\/ Only want the PrivateKey? then return it.\n+            if (!pair) {\n+                return privKey;\n+            }\n+\n+            if (p8key.hasPublicKey()) {\n+                \/\/ PKCS8Key.decode() has extracted the public key already\n+                pubKey = kf.generatePublic(\n+                    new X509EncodedKeySpec(p8key.getPubKeyEncoded()));\n+            } else {\n+                \/\/ In case decode() could not read the public key, the\n+                \/\/ KeyFactory can try.  Failure is ok as there may not\n+                \/\/ be a public key in the encoding.\n+                try {\n+                    pubKey = kf.generatePublic(p8KeySpec);\n+                } catch (InvalidKeySpecException e) {\n+                    \/\/ ignore\n+                }\n+            }\n+        } catch (InvalidKeySpecException e) {\n+            throw new InvalidKeyException(e);\n+        } finally {\n+            p8key.clear();\n+            SharedSecrets.getJavaSecuritySpecAccess().\n+                clearEncodedKeySpec(p8KeySpec);\n+        }\n+        if (pair && pubKey != null) {\n+            return new KeyPair(pubKey, privKey);\n+        }\n+        return privKey;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":113,"deletions":7,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.security.PEMRecord;\n+import java.security.PEM;\n@@ -152,1 +152,1 @@\n-    public static final Entry ec25519priv = new Entry(\"ed25519priv\",\n+    public static final Entry ed25519priv = new Entry(\"ed25519priv\",\n@@ -192,0 +192,1 @@\n+    \/\/ This is the public key contained in ecsecp256\n@@ -289,0 +290,13 @@\n+    static final Entry ecsecp256ekpi = new Entry(\"ecsecp256ekpi\",\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIH0MF8GCSqGSIb3DQEFDTBSMDEGCSqGSIb3DQEFDDAkBBDhqUj1Oadj1GZXUMXT\n+        b3QEAgIIADAMBggqhkiG9w0CCQUAMB0GCWCGSAFlAwQBAgQQitxCfcZcMtoNu+X+\n+        PQk+\/wSBkFL1NddKkUL2tRv6pNf1TR7eI7qJReGRgJexU\/6pDN+UQS5e5qSySa7E\n+        k1m2pUHgZlySUblXZj9nOzCsNFfq\/jxlL15ZpAviAM2fRINnNEJcvoB+qZTS5cRb\n+        Xs3wC7wymHW3EdIZ9sxfSHq9t7j9SnC1jGHjno0v1rKcdIvJtYloxsRYjsG\/Sxhz\n+        uNYnx8AMuQ==\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\", EncryptedPrivateKeyInfo.class, \"SunEC\", \"fish\".toCharArray());\n+\n+\n@@ -453,1 +467,1 @@\n-        \"\"\", PEMRecord.class, \"SunEC\");\n+        \"\"\", PEM.class, \"SunEC\");\n@@ -474,1 +488,1 @@\n-        \"\"\" + postData, PEMRecord.class, \"SunEC\");\n+        \"\"\" + postData, PEM.class, \"SunEC\");\n@@ -568,1 +582,1 @@\n-        privList.add(ec25519priv);\n+        privList.add(ed25519priv);\n","filename":"test\/jdk\/java\/security\/PEM\/PEMData.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -114,2 +114,2 @@\n-        DEREncodable result = PEMDecoder.of().decode(PEMData.ecCSRWithData.pem(), PEMRecord.class);\n-        if (result instanceof PEMRecord rec) {\n+        DEREncodable result = PEMDecoder.of().decode(PEMData.ecCSRWithData.pem(), PEM.class);\n+        if (result instanceof PEM rec) {\n@@ -131,2 +131,2 @@\n-        result = PEMDecoder.of().decode(PEMData.rsapub.pem(), PEMRecord.class);\n-        if (!(result instanceof PEMRecord)) {\n+        result = PEMDecoder.of().decode(PEMData.rsapub.pem(), PEM.class);\n+        if (!(result instanceof PEM)) {\n@@ -135,1 +135,1 @@\n-        if (((PEMRecord) result).type().compareTo(Pem.PUBLIC_KEY) != 0) {\n+        if (((PEM) result).type().compareTo(Pem.PUBLIC_KEY) != 0) {\n@@ -142,1 +142,1 @@\n-        testPEMRecord(PEMData.ec25519priv);\n+        testPEMRecord(PEMData.ed25519priv);\n@@ -147,1 +147,1 @@\n-        testPEMRecordDecode(PEMData.ec25519priv);\n+        testPEMRecordDecode(PEMData.ed25519priv);\n@@ -153,2 +153,2 @@\n-        String s = new PEMRecord(\"ONE\", \"1212\").toString()\n-            + new PEMRecord(\"TWO\", \"3434\").toString();\n+        String s = new PEM(\"ONE\", \"1212\").toString()\n+            + new PEM(\"TWO\", \"3434\").toString();\n@@ -156,1 +156,1 @@\n-        if (d.decode(ins, PEMRecord.class).leadingData() != null) {\n+        if (d.decode(ins, PEM.class).leadingData() != null) {\n@@ -159,1 +159,1 @@\n-        if (d.decode(ins, PEMRecord.class).leadingData() != null) {\n+        if (d.decode(ins, PEM.class).leadingData() != null) {\n@@ -214,1 +214,1 @@\n-        PEMRecord obj;\n+        PEM obj;\n@@ -217,1 +217,1 @@\n-            obj = PEMDecoder.of().decode(is, PEMRecord.class);\n+            obj = PEMDecoder.of().decode(is, PEM.class);\n@@ -228,1 +228,1 @@\n-            PEMDecoder.of().decode(is, PEMRecord.class);\n+            PEMDecoder.of().decode(is, PEM.class);\n@@ -237,1 +237,1 @@\n-                PEMDecoder.of().decode(is, PEMRecord.class));\n+                PEMDecoder.of().decode(is, PEM.class));\n@@ -268,1 +268,1 @@\n-        PEMRecord r = PEMDecoder.of().decode(entry.pem(), PEMRecord.class);\n+        PEM r = PEMDecoder.of().decode(entry.pem(), PEM.class);\n@@ -288,1 +288,1 @@\n-                entry.clazz().isAssignableFrom(PEMRecord.class);\n+                entry.clazz().isAssignableFrom(PEM.class);\n@@ -303,1 +303,1 @@\n-        PEMRecord r = PEMDecoder.of().decode(entry.pem(), PEMRecord.class);\n+        PEM r = PEMDecoder.of().decode(entry.pem(), PEM.class);\n@@ -314,1 +314,1 @@\n-            case \"CERTIFICATE REQUEST\" -> (de instanceof PEMRecord);\n+            case \"CERTIFICATE REQUEST\" -> (de instanceof PEM);\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        keymap.keySet().stream().forEach(key -> test(key, encoder));\n+        keymap.keySet().forEach(key -> test(key, encoder));\n@@ -75,1 +75,1 @@\n-        keymap.keySet().stream().forEach(key -> test(key, PEMEncoder.of()));\n+        keymap.keySet().forEach(key -> test(key, PEMEncoder.of()));\n@@ -77,1 +77,1 @@\n-        keymap.keySet().stream().forEach(key -> testToString(key, encoder));\n+        keymap.keySet().forEach(key -> testToString(key, encoder));\n@@ -79,1 +79,1 @@\n-        keymap.keySet().stream().forEach(key -> testToString(key,\n+        keymap.keySet().forEach(key -> testToString(key,\n@@ -89,1 +89,1 @@\n-        keymap.keySet().stream().forEach(key -> testEncryptedMatch(key, encoder));\n+        keymap.keySet().forEach(key -> testEncryptedMatch(key, encoder));\n@@ -91,1 +91,1 @@\n-        keymap.keySet().stream().forEach(key -> testEncrypted(key, encoder));\n+        keymap.keySet().forEach(key -> testEncrypted(key, encoder));\n@@ -93,1 +93,1 @@\n-        keymap.keySet().stream().forEach(key -> testEncrypted(key, PEMEncoder.of()));\n+        keymap.keySet().forEach(key -> testEncrypted(key, PEMEncoder.of()));\n@@ -96,1 +96,1 @@\n-        keymap.keySet().stream().forEach(key -> testSameEncryptor(key, encEncoder));\n+        keymap.keySet().forEach(key -> testSameEncryptor(key, encEncoder));\n@@ -106,3 +106,3 @@\n-        PEMRecord pemRecord =\n-            d.decode(PEMData.ed25519ep8.pem(), PEMRecord.class);\n-        PEMData.checkResults(PEMData.ed25519ep8, pemRecord.toString());\n+        PEM pem =\n+            d.decode(PEMData.ed25519ep8.pem(), PEM.class);\n+        PEMData.checkResults(PEMData.ed25519ep8, pem.toString());\n@@ -110,1 +110,1 @@\n-        \/\/ test PemRecord is encapsulated with PEM header and footer on encoding\n+        \/\/ test PEM is encapsulated with PEM header and footer on encoding\n@@ -113,1 +113,1 @@\n-        PEMRecord pemR = new PEMRecord(\"ENCRYPTED PRIVATE KEY\", String.join(\"\\n\",\n+        PEM pemR = new PEM(\"ENCRYPTED PRIVATE KEY\", String.join(\"\\n\",\n@@ -116,0 +116,11 @@\n+\n+        \/\/ Verify the same private key bytes are returned with an ECDSA private\n+        \/\/ key PEM and an encrypted PEM.\n+        KeyPair kp = d.decode(PEMData.ecsecp256.pem(), KeyPair.class);\n+        var origPriv = kp.getPrivate();\n+        String s = encoder.withEncryption(PEMData.ecsecp256ekpi.password()).encodeToString(kp);\n+        kp = d.withDecryption(PEMData.ecsecp256ekpi.password()).decode(s, KeyPair.class);\n+        var newPriv = kp.getPrivate();\n+        if (!Arrays.equals(origPriv.getEncoded(), newPriv.getEncoded())) {\n+            throw new AssertionError(\"compare fails\");\n+        }\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -74,1 +74,2 @@\n-        Provider p = Security.getProvider(System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+        Provider p = Security.getProvider(\n+            System.getProperty(\"test.provider.name\", \"SunJCE\"));\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetKey.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8360563\n+ * @library \/test\/lib\n+ * @summary Testing getKeyPair using ML-KEM\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.*;\n+\n+\/*\n+ * This generates an ML-KEM key pair and makes it into PEM data.  By using\n+ * PEM, it constructs a OneAsymmetricKey structure that combines\n+ * the public key into the private key encoding.  Decode the PEM data into\n+ * a KeyPair and an EKPI for verification.\n+ *\n+ * The original private key does not have the public key encapsulated, so it\n+ * cannot be used for verification.\n+ *\n+ * Verify the decoded PEM KeyPair and EKPI.getKeyPair() return matching public\n+ * and private keys encodings; as well as, verify the original public key\n+ * matches.\n+ *\/\n+\n+public class GetKeyPair {\n+    private static final String passwdText = \"fish\";\n+    private static final char[] password = passwdText.toCharArray();\n+    private static final SecretKey key = new SecretKeySpec(\n+        passwdText.getBytes(), \"PBE\");\n+\n+    public static void main(String[] args) throws Exception {\n+        Provider p = Security.getProvider(\n+            System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ML-KEM\");\n+        KeyPair kpOrig = kpg.generateKeyPair();\n+        \/\/ Generate the PEM, constructing a OneAsymmetricKey (OAS) encoding\n+        String pem = PEMEncoder.of().withEncryption(password).\n+            encodeToString(kpOrig);\n+        \/\/ Extracted the KeyPair from the generated PEM for verification.\n+        KeyPair mlkemKP = PEMDecoder.of().withDecryption(password).\n+            decode(pem, KeyPair.class);\n+        \/\/ Extract the EncryptedPrivateKeyInfo.\n+        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(pem,\n+            EncryptedPrivateKeyInfo.class);\n+\n+        KeyPairs kps = new KeyPairs(kpOrig, mlkemKP);\n+\n+        \/\/ Test getKey(password)\n+        System.out.println(\"Testing getKeyPair(char[]) \");\n+        KeyPair kp = ekpi.getKeyPair(password);\n+        arrayCheck(kps, kp);\n+\n+        \/\/ Test getKey(key, provider) provider null\n+        System.out.println(\"Testing getKeyPair(key, null)\");\n+        kp = ekpi.getKeyPair(key, null);\n+        arrayCheck(kps, kp);\n+\n+        \/\/ Test getKey(key, provider) provider SunJCE\n+        System.out.println(\"Testing getKeyPair(key, SunJCE)\");\n+        kp = ekpi.getKeyPair(key, p);\n+        arrayCheck(kps, kp);\n+    }\n+\n+    static void arrayCheck(KeyPairs kps, KeyPair actual) {\n+        byte[] actualPrivEncoding = actual.getPrivate().getEncoded();\n+        byte[] actualPubEncoding = actual.getPublic().getEncoded();\n+        Asserts.assertEqualsByteArray(kps.mlkemPrivEncoding, actualPrivEncoding,\n+            \"PrivateKey didn't match with expected.\");\n+        Asserts.assertEqualsByteArray(kps.mlkemPubEncoding, actualPubEncoding,\n+            \"PublicKey didn't match with decoded.\");\n+        Asserts.assertEqualsByteArray(kps.origPubEncoding, actualPubEncoding,\n+            \"PublicKey didn't match with decoded.\");\n+        System.out.println(\"Got KeyPair:  Pass\");\n+    }\n+\n+    record KeyPairs(byte[] origPubEncoding, byte[] mlkemPrivEncoding,\n+                    byte[] mlkemPubEncoding) {\n+         KeyPairs(KeyPair orig, KeyPair mlkem) {\n+             this(orig.getPublic().getEncoded(),\n+                 mlkem.getPrivate().getEncoded(),\n+                 mlkem.getPublic().getEncoded());\n+         }\n+    };\n+}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetKeyPair.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}