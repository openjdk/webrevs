{"files":[{"patch":"@@ -78,0 +78,1 @@\n+    private final byte SEC1v2 = 1;\n@@ -178,1 +179,1 @@\n-            if (version != V2) {\n+            if (version != SEC1v2) {\n@@ -259,2 +260,1 @@\n-                    byte[] oct = seq.data.getOctetString();  \/\/ private key\n-                    Arrays.fill(oct, (byte) 0x0);\n+                    seq.data.getDerValue();  \/\/ read pass the private key\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -109,3 +109,5 @@\n-     * Constructor that takes both public and private encodings.  If\n-     * publicEncoding is null, a V1 PKCS8 encoding is created; otherwise, V2 is\n-     * encoded.\n+     * Constructor that takes both public and private encodings.\n+     *\n+     * If the private key includes a public key encoding (like an EC key in\n+     * SEC1v2 format), and a specified public key matches it, the existing\n+     * encoding is reused rather than recreated.\n@@ -124,1 +126,0 @@\n-                version = V1;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -51,0 +51,10 @@\n+    public static final Entry ecsecp256dom0 = new Entry(\"ecsecp256dom0\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgkW3Jx561NlEgBnut\n+        KwDdi3cNwu7YYD\/QtJ+9+AEBdoqgCgYIKoZIzj0DAQehRANCAASL+REY4vvAI9M3\n+        gonaml5K3lRgHq5w+OO4oO0VNduC44gUN1nrk7\/wdNSpL+xXNEX52Dsff+2RD\/fo\n+        p224ANvB\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class, \"SunEC\");\n+\n@@ -581,0 +591,1 @@\n+        privList.add(ecsecp256dom0);\n","filename":"test\/jdk\/java\/security\/PEM\/PEMData.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}