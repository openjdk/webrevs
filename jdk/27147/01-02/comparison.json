{"files":[{"patch":"@@ -40,4 +40,4 @@\n- * <p> Methods {@link PEMDecoder#decode(String)} and\n- * {@link PEMDecoder#decode(InputStream)} return a {@code PEM} object when no\n- * cryptographic object is available to represent the data type.\n- * If {@code PEM} is desired instead of an available cryptographic object,\n+ * <p> The {@link PEMDecoder#decode(String)} and\n+ * {@link PEMDecoder#decode(InputStream)} methods return a {@code PEM} object\n+ * when the data type cannot be represented by a cryptographic object.\n+ * If {@code PEM} is desired instead of a cryptographic object, the\n@@ -52,1 +52,1 @@\n- * {@code content} may not be {@code null}.\n+ * {@code content} must not be {@code null}.\n@@ -60,2 +60,2 @@\n- * CERTIFICATE, CERTIFICATE REQUEST, ATTRIBUTE CERTIFICATE, X509 CRL, PKCS7, CMS,\n- * PRIVATE KEY, ENCRYPTED PRIVATE KEY, RSA PRIVATE KEY, or PUBLIC KEY.\n+ * CERTIFICATE, CERTIFICATE REQUEST, ATTRIBUTE CERTIFICATE, X509 CRL, PKCS7,\n+ * CMS, PRIVATE KEY, ENCRYPTED PRIVATE KEY, RSA PRIVATE KEY, or PUBLIC KEY.\n@@ -63,4 +63,4 @@\n- * <p> {@code leadingData} may be null if no non-PEM data preceded PEM header\n- * during decoding.  {@code leadingData} can be useful for reading metadata\n- * that accompanies PEM data. {@code leadingData} is not defensively copied and\n- * the {@link #leadingData()} method does not return a clone.\n+ * <p> {@code leadingData} may be null if there was no data preceding the PEM\n+ * header during decoding.  {@code leadingData} can be useful for reading\n+ * metadata that accompanies PEM data. {@code leadingData} is not defensively\n+ * copied and the {@link #leadingData()} method does not return a clone.\n@@ -139,1 +139,1 @@\n-     * Returns a Base64 decoded byte array of {@code content}\n+     * Returns a Base64 decoded byte array of {@code content}.\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEM.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,2 +49,2 @@\n- * lists (CRLs).  It is defined in RFC 1421 and RFC 7468.  A PEM structure\n- * consists of Base64-encoded binary data enclosed by a type-identifying header\n+ * lists (CRLs).  It is defined in RFC 1421 and RFC 7468. PEM consists of a\n+ * Base64-formatted binary encoding enclosed by a type-identifying header\n@@ -54,2 +54,2 @@\n- * methods return an instance of a class matching the PEM type and\n- * implementing {@link DEREncodable}.\n+ * methods return an instance of a class that matches the PEM type and\n+ * implements {@link DEREncodable}.\n@@ -57,2 +57,2 @@\n- * <p> Supported PEM types and their decoded {@code DEREncodable} classes\n- * include:\n+ * <p> The following lists the supported PEM types and the {@code DEREncodable}\n+ * types that each are decoded as:\n@@ -72,1 +72,1 @@\n- *  Decryption)<\/li>\n+ *  decryption)<\/li>\n@@ -74,1 +74,1 @@\n- *  Decryption)<\/li>\n+ *  decryption)<\/li>\n@@ -76,1 +76,1 @@\n- *  Decryption)<\/li>\n+ *  decryption)<\/li>\n@@ -81,2 +81,2 @@\n- * subclass is returned if the algorithm is supported. For example an\n- * ECPublicKey and ECPrivateKey for Elliptic Curve keys.\n+ * subclass is returned if the algorithm is supported. For example, an\n+ * {@code ECPublicKey} and {@code ECPrivateKey} for Elliptic Curve keys.\n@@ -90,3 +90,4 @@\n- * to specify the returned {@code DEREncodable} type. These\n- * methods are useful when extracting or changing the return class.\n- * For example, if the PEM contains both a public and private keys, specifying\n+ * which specifies type of {@code DEREncodable} that is returned. These methods\n+ * are useful to avoid casting the return type when the PEM type is known, or\n+ * when extracting a specific type when there is more than one choice.\n+ * For example, if the PEM contains both a public and private key, specifying\n@@ -95,4 +96,4 @@\n- * public key encoding is returned in that class.  Any type of PEM data can be\n- * decoded into a {@code PEM} object by specifying {@code PEM.class}.\n- * If the class parameter doesn't match the PEM content, a\n- * {@linkplain ClassCastException} will be thrown.\n+ * public key encoding is returned in an instance of the X509EncodedKeySpec\n+ * class.  Any type of PEM data can be decoded into a {@code PEM} object by\n+ * specifying {@code PEM.class}. If the class parameter doesn't match the PEM\n+ * content, a {@linkplain ClassCastException} will be thrown.\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n- *  <li>{@code KeyPair} (if configured with Encryption) : ENCRYPTED PRIVATE KEY\n+ *  <li>{@code KeyPair} (if configured with encryption) : ENCRYPTED PRIVATE KEY\n@@ -93,1 +93,1 @@\n- *  <li>{@code PKCS8EncodedKeySpec} (if configured with Encryption) :\n+ *  <li>{@code PKCS8EncodedKeySpec} (if configured with encryption) :\n@@ -100,1 +100,1 @@\n- * <p> Here is an example of encoding a {@code PrivateKey} object:\n+ * <p> Here is an example of encoding a private key object:\n@@ -123,0 +123,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc5958\n+ *       RFC 5958: Asymmetric Key Packages\n@@ -256,1 +258,2 @@\n-     * <p> Only {@link PrivateKey} objects can be encrypted with this newly\n+     * <p> Only {@link PrivateKey}, {@link KeyPair}, and\n+     * {@link PKCS8EncodedKeySpec} objects can be encoded with this newly\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-            Pem.decryptEncoding(encoded, password), true,null);\n+            Pem.decryptEncoding(encoded, password), true, null);\n@@ -764,0 +764,2 @@\n+        } finally {\n+            keySpec.clearPassword();\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -246,0 +246,1 @@\n+        DerValue seq = null;\n@@ -247,1 +248,1 @@\n-            DerValue seq = new DerValue(privateBytes);\n+            seq = new DerValue(privateBytes);\n@@ -251,1 +252,1 @@\n-                    byte[] oct = seq.data.getOctetString();\n+                    byte[] oct = seq.data.getOctetString();  \/\/ private key\n@@ -255,0 +256,8 @@\n+                        \/\/ check for optional [0] EC domain parameters\n+                        if (derValue.isContextSpecific((byte) 0)) {\n+                            if (seq.data.available() == 0) {\n+                                return null;\n+                            }\n+                            derValue = seq.data.getDerValue();\n+                        }\n+                        \/\/ [1] public key\n@@ -264,0 +273,4 @@\n+        } finally {\n+            if (seq != null) {\n+                seq.clear();\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.security.spec.EncodedKeySpec;\n@@ -40,1 +39,0 @@\n-import java.security.spec.X509EncodedKeySpec;\n@@ -112,1 +110,1 @@\n-     * pubEncoding is null, a V1 PKCS8 encoding is created; otherwise, V2 is\n+     * publicEncoding is null, a V1 PKCS8 encoding is created; otherwise, V2 is\n@@ -121,0 +119,1 @@\n+                    Arrays.fill(privKeyMaterial, (byte) 0x0);\n@@ -301,1 +300,1 @@\n-     * @param pubKeyEncoded DER-encoded PublicKey, this maybe null.\n+     * @param pubKeyEncoded DER-encoded PublicKey, this may be null.\n@@ -308,0 +307,1 @@\n+        PKCS8Key pkcs8Key;\n@@ -309,2 +309,1 @@\n-            return new PKCS8Key(pubKeyEncoded, privKeyEncoded).\n-                generateEncoding();\n+            pkcs8Key = new PKCS8Key(pubKeyEncoded, privKeyEncoded);\n@@ -314,0 +313,3 @@\n+        byte[] result = pkcs8Key.generateEncoding().clone();\n+        pkcs8Key.clear();\n+        return result;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -373,2 +373,5 @@\n-\n-        return p8KeySpec.getEncoded();\n+        byte[] result = p8KeySpec.getEncoded();\n+            SharedSecrets.getJavaSecuritySpecAccess().\n+                clearEncodedKeySpec(p8KeySpec);\n+            keySpec.clearPassword();\n+        return result;\n@@ -410,0 +413,3 @@\n+            p8key.clear();\n+            SharedSecrets.getJavaSecuritySpecAccess().\n+                clearEncodedKeySpec(p8KeySpec);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-    static final Entry ecsecp256ekpi = new Entry(\"ecsecp256epki\",\n+    static final Entry ecsecp256ekpi = new Entry(\"ecsecp256ekpi\",\n","filename":"test\/jdk\/java\/security\/PEM\/PEMData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        if (Arrays.compare(origPriv.getEncoded(), newPriv.getEncoded()) != 0) {\n+        if (!Arrays.equals(origPriv.getEncoded(), newPriv.getEncoded())) {\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}