{"files":[{"patch":"@@ -43,4 +43,5 @@\n- * If {@code PEM} is desired instead of a cryptographic object, the\n- * decoding methods {@link PEMDecoder#decode(String, Class)} or\n- * {@link PEMDecoder#decode(InputStream, Class)} are used with\n- * {@code PEM.class} as an argument.\n+ * If you need access to the leading data of a PEM text, or if you want to\n+ * handle the text content directly, use the decoding methods\n+ * {@link PEMDecoder#decode(String, Class)} or\n+ * {@link PEMDecoder#decode(InputStream, Class)} with {@code PEM.class} as a\n+ * argument type.\n@@ -48,2 +49,2 @@\n- * <p> A {@code PEM} object can be encoded back to its textual format by using\n- * encode methods in {@link PEMEncoder} or the {@link #toString()} method.\n+ * <p> A {@code PEM} object can be encoded back to its textual format by calling\n+ * {@link #toString()} or using the encode methods in {@link PEMEncoder}.\n@@ -51,1 +52,1 @@\n- * <p> When constructing a {@code PEM} instance, {@code type} and\n+ * <p> When constructing a {@code PEM} instance, both {@code type} and\n@@ -55,1 +56,1 @@\n- * {@code type} conforms to {@code RFC 7468} or other legacy formats, that\n+ * {@code type} conforms to RFC 7468 or other legacy formats, that\n@@ -59,1 +60,1 @@\n- * Common {@code type} values include, but are not limited to:\n+ * <p> Common {@code type} values include, but are not limited to:\n@@ -63,1 +64,1 @@\n- * <p> {@code leadingData} may be null if there was no data preceding the PEM\n+ * <p> {@code leadingData} is {@code null} if there is no data preceding the PEM\n@@ -65,2 +66,3 @@\n- * metadata that accompanies PEM data. {@code leadingData} is not defensively\n- * copied and the {@link #leadingData()} method does not return a clone.\n+ * metadata that accompanies the PEM data. This value was not defensively\n+ * copied by the constructor, and the {@link #leadingData()} method does not\n+ * return a clone.\n@@ -88,1 +90,1 @@\n-     * Creates a {@code PEM} instance with the given parameters.\n+     * Creates a {@code PEM} instance with the specified parameters.\n@@ -90,1 +92,1 @@\n-     * @param type the type identifier\n+     * @param type the PEM type identifier\n@@ -94,1 +96,1 @@\n-     *                    before the PEM header.  This value maybe {@code null}.\n+     *                    before the PEM header.  This value may be {@code null}\n@@ -96,3 +98,3 @@\n-     * formatted.\n-     * @throws NullPointerException if {@code type} and\/or {@code content} are\n-     * {@code null}.\n+     * formatted\n+     * @throws NullPointerException if {@code type} or {@code content} is\n+     * {@code null}\n@@ -114,2 +116,2 @@\n-     * Creates a {@code PEM} instance with a given {@code type} and\n-     * {@code content} data in String form.  {@code leadingData} is set to null.\n+     * Creates a {@code PEM} instance with the specified type and content. This\n+     * constructor sets {@code leadingData} to {@code null}.\n@@ -121,3 +123,3 @@\n-     * formatted.\n-     * @throws NullPointerException if {@code type} and\/or {@code content} are\n-     * {@code null}.\n+     * formatted\n+     * @throws NullPointerException if {@code type} or {@code content} is\n+     * {@code null}\n@@ -130,2 +132,4 @@\n-     * Returns the type and Base64 encoding in PEM textual format.\n-     * {@code leadingData} is not returned by this method.\n+     * Returns the PEM formatted string containing the {@code type} and\n+     * Base64-encoded {@code content}. {@code leadingData} is not included.\n+     *\n+     * @return the PEM text representation\n@@ -139,4 +143,2 @@\n-     * Returns a Base64 decoded byte array of {@code content}.\n-     *\n-     * @return a decoded byte array of {@code content}\n-     * @throws IllegalArgumentException on a decoding error\n+     * Returns a Base64-decoded byte array of {@code content}, using\n+     * {@link Base64#getMimeDecoder()}.\n@@ -144,1 +146,2 @@\n-     * @see Base64#getMimeDecoder()\n+     * @return a new decoded byte array of {@code content}\n+     * @throws IllegalArgumentException on a decoding fails\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEM.java","additions":33,"deletions":30,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+ *  <li>X509 CERTIFICATE : {@code X509Certificate}<\/li>\n+ *  <li>X.509 CERTIFICATE : {@code X509Certificate}<\/li>\n+ *  <li>CRL : {@code X509CRL}<\/li>\n@@ -63,2 +66,2 @@\n- *  <li>PUBLIC KEY : {@code X509EncodedKeySpec} (Only supported when passed as\n- *  a {@code Class} parameter)<\/li>\n+ *  <li>PUBLIC KEY : {@code X509EncodedKeySpec} (When passed as a {@code Class}\n+ *  parameter)<\/li>\n@@ -66,4 +69,6 @@\n- *  <li>PRIVATE KEY : {@code PKCS8EncodedKeySpec} (Only supported when passed\n- *  as a {@code Class} parameter)<\/li>\n- *  <li>PRIVATE KEY : {@code KeyPair} (if the encoding also contains a\n- *  public key)<\/li>\n+ *  <li>PRIVATE KEY : {@code PKCS8EncodedKeySpec} (When passed as a {@code Class}\n+ *  parameter)<\/li>\n+ *  <li>PRIVATE KEY : {@code PublicKey} (If the encoding contains a public key\n+ *  and is passed as a {@code Class} parameter)<\/li>\n+ *  <li>PRIVATE KEY : {@code KeyPair} (If the encoding contains a public key)\n+ *  <\/li>\n@@ -71,1 +76,1 @@\n- *  <li>ENCRYPTED PRIVATE KEY : {@code PrivateKey} (if configured with\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PrivateKey} (If configured with\n@@ -73,3 +78,3 @@\n- *  <li>ENCRYPTED PRIVATE KEY : {@code KeyPair} (if configured with\n- *  decryption)<\/li>\n- *  <li>ENCRYPTED PRIVATE KEY : {@code PKCS8EncodedKeySpec} (if configured with\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code KeyPair} (If configured with decryption)\n+ *  <\/li>\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PKCS8EncodedKeySpec} (If configured with\n@@ -77,0 +82,3 @@\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PublicKey} (If configured with\n+ *  decryption, the encoding contains a public key, and is passed as a\n+ *  {@code Class} parameter)<\/li>\n@@ -86,1 +94,1 @@\n- * {@link PEM}.\n+ * {@link PEM} object.\n@@ -103,7 +111,6 @@\n- * with {@link #withFactory(Provider)} and\/or\n- * {@link #withDecryption(char[])}. The {@link #withFactory(Provider)} method\n- * uses the specified provider to produce cryptographic objects from\n- * {@link KeyFactory} and{@link CertificateFactory}.\n- * {@link #withDecryption(char[])} configures the decoder to process\n- * encrypted private key PEM data using the given password.\n- * If decryption fails, a {@link IllegalArgumentException} is thrown.\n+ * with {@link #withFactory(Provider)} or {@link #withDecryption(char[])}.\n+ * The {@link #withFactory(Provider)} method uses the specified provider\n+ * to produce cryptographic objects from {@link KeyFactory} and\n+ * {@link CertificateFactory}. The {@link #withDecryption(char[])} configures the\n+ * decoder to decrypt and decode encrypted private key PEM data using the given\n+ * password.  If decryption fails, an {@link IllegalArgumentException} is thrown.\n@@ -116,1 +123,1 @@\n- * <p> Here is an example of decoding a private key object:\n+ * <p> Example: decode a private key:\n@@ -122,2 +129,1 @@\n- * <p> Here is an example of a {@code PEMDecoder} configured with decryption\n- * and a factory provider:\n+ * <p> Example: configure decryption and a factory provider:\n@@ -126,2 +132,2 @@\n- *         withFactory(provider);\n- *     byte[] pemData = pd.decode(privKey);\n+ *             withFactory(provider);\n+ *     DEREncodable pemData = pd.decode(privKeyPEM);\n@@ -130,4 +136,2 @@\n- * @implNote An implementation may support other PEM types and\n- * {@code DEREncodable} objects. This implementation additionally supports\n- * the following PEM types:  {@code X509 CERTIFICATE},\n- * {@code X.509 CERTIFICATE}, {@code CRL}, and {@code RSA PRIVATE KEY}.\n+ * @implNote This implementation decodes PEM type {@code RSA PRIVATE KEY} as\n+ * {@code PRIVATE KEY}. Other implementations may support additional types.\n@@ -264,7 +268,6 @@\n-     * <p> This method returns a Java API cryptographic object,\n-     * such as a {@code PrivateKey}, if the PEM type is supported.\n-     * Any non-PEM data preceding the PEM header is ignored by the decoder.\n-     * Otherwise, a {@link PEM} will be returned containing\n-     * the type identifier and Base64-encoded data.\n-     * Any non-PEM data preceding the PEM header will be stored in\n-     * {@code leadingData}.\n+     * <p> A {@code DEREncodable} will be returned that best represents the\n+     * decoded data.  If the PEM type is not supported, a {@link PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the DEREncodable object.\n@@ -279,1 +282,1 @@\n-     * @throws NullPointerException when {@code str} is null\n+     * @throws NullPointerException when {@code str} is {@code null}\n@@ -297,1 +300,1 @@\n-     * the PEM footer or the end of the stream. If an I\/O error occurs,\n+     * a PEM footer or the end of the stream. If an I\/O error occurs,\n@@ -302,7 +305,6 @@\n-     * <p> This method returns a Java API cryptographic object,\n-     * such as a {@code PrivateKey}, if the PEM type is supported.\n-     * Any non-PEM data preceding the PEM header is ignored by the decoder.\n-     * Otherwise, a {@link PEM} will be returned containing\n-     * the type identifier and Base64-encoded data.\n-     * Any non-PEM data preceding the PEM header will be stored in\n-     * {@code leadingData}.\n+     * <p> A {@code DEREncodable} will be returned that best represents the\n+     * decoded data.  If the PEM type is not supported, a {@link PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the DEREncodable object.\n@@ -317,1 +319,2 @@\n-     * @throws EOFException at the end of the {@code InputStream}\n+     * @throws EOFException no PEM data found or unexpectedly reached the\n+     *   end of the {@code InputStream}\n@@ -319,1 +322,1 @@\n-     * @throws NullPointerException when {@code is} is null\n+     * @throws NullPointerException when {@code is} is {@code null}\n@@ -329,2 +332,2 @@\n-     * the given PEM string. {@code tClass} must extend {@link DEREncodable}\n-     * and be an appropriate class for the PEM type.\n+     * the given PEM string. {@code tClass} must be an appropriate class for\n+     * the PEM type.\n@@ -336,5 +339,5 @@\n-     * <p> If the class parameter is {@code PEM.class},\n-     * a {@link PEM} is returned containing the\n-     * type identifier and Base64 encoding. Any non-PEM data preceding\n-     * the PEM header will be stored in {@code leadingData}.  Other\n-     * class parameters will not return preceding non-PEM data.\n+     * <p> If the class parameter is {@code PEM.class}, a {@link PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the DEREncodable object.\n@@ -347,1 +350,1 @@\n-     * @param tClass the returned object class that implements\n+     * @param tClass the returned object class that extends or implements\n@@ -352,2 +355,2 @@\n-     * @throws ClassCastException if {@code tClass} is invalid for the PEM type\n-     * @throws NullPointerException when any input values are null\n+     * @throws ClassCastException if {@code tClass} does not represent the PEM type\n+     * @throws NullPointerException when any input values are {@code null}\n@@ -367,3 +370,3 @@\n-     * Decodes and returns the specified class for the given\n-     * {@link InputStream}.  The class must extend {@link DEREncodable} and be\n-     * an appropriate class for the PEM type.\n+     * Decodes and returns a {@code DEREncodable} of the specified class for the\n+     * given {@link InputStream}. {@code tClass} must be an appropriate class\n+     * for the PEM type.\n@@ -372,1 +375,1 @@\n-     * the PEM footer or the end of the stream. If an I\/O error occurs,\n+     * a PEM footer or the end of the stream. If an I\/O error occurs,\n@@ -377,5 +380,5 @@\n-     * <p> If the class parameter is {@code PEM.class},\n-     * a {@link PEM} is returned containing the\n-     * type identifier and Base64 encoding. Any non-PEM data preceding\n-     * the PEM header will be stored in {@code leadingData}.  Other\n-     * class parameters will not return preceding non-PEM data.\n+     * <p> If the class parameter is {@code PEM.class}, a {@link PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the DEREncodable object.\n@@ -388,1 +391,1 @@\n-     * @param tClass the returned object class that implements\n+     * @param tClass the returned object class that extends or implements\n@@ -392,5 +395,6 @@\n-     * {@code InputStream} did not complete decoding.\n-     * @throws EOFException at the end of the {@code InputStream}\n-     * @throws IllegalArgumentException on error with arguments or in decoding\n-     * @throws ClassCastException if {@code tClass} is invalid for the PEM type\n-     * @throws NullPointerException when any input values are null\n+     *   {@code InputStream} did not complete decoding.\n+     * @throws EOFException no PEM data found or unexpectedly reached the\n+     *   end of the {@code InputStream}\n+     * @throws IllegalArgumentException on error in decoding\n+     * @throws ClassCastException if {@code tClass} does not represent the PEM type\n+     * @throws NullPointerException when any input values are {@code null}\n@@ -495,2 +499,2 @@\n-     * @return a new PEMEncoder instance configured to the {@code Provider}.\n-     * @throws NullPointerException if {@code provider} is null\n+     * @return a new PEMEncoder instance configured with the {@code Provider}.\n+     * @throws NullPointerException if {@code provider} is {@code null}\n@@ -506,1 +510,1 @@\n-     * Non-encrypted PEM can still be decoded from this instance.\n+     * Non-encrypted PEM can also be decoded from this instance.\n@@ -508,1 +512,1 @@\n-     * @param password the password to decrypt encrypted PEM data.  This array\n+     * @param password the password to decrypt the encrypted PEM data. This array\n@@ -510,2 +514,2 @@\n-     * @return a new PEMEncoder instance configured for decryption\n-     * @throws NullPointerException if {@code password} is null\n+     * @return a new PEMDecoder instance configured for decryption\n+     * @throws NullPointerException if {@code password} is {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":80,"deletions":76,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * data.  PEM is a textual encoding used to store and transfer security\n+ * data.  PEM is a textual encoding used to store and transfer cryptographic\n@@ -48,1 +48,1 @@\n- * lists (CRL).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n+ * lists (CRLs).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n@@ -52,1 +52,1 @@\n- * <p> Encoding may be performed on Java API cryptographic objects that\n+ * <p> Encoding can be performed on cryptographic objects that\n@@ -61,1 +61,1 @@\n- * private key encrypted as an {@code EncryptedKeyInfo} object can be encoded\n+ * private key encrypted as an {@link EncryptedPrivateKeyInfo} object can be encoded\n@@ -71,5 +71,4 @@\n- * <p> When encoding a {@link PEM}, the API surrounds the\n- * {@link PEM#content()} with the PEM header and footer\n- * from {@link PEM#type()}. {@link PEM#leadingData()} is\n- * not included in the encoding.  {@code PEM} will not perform\n- * validity checks on the data.\n+ * <p> When encoding a {@link PEM} object, the API surrounds\n+ * {@link PEM#content()} with a PEM header and footer based on\n+ * {@link PEM#type()}. The value returned by {@link PEM#leadingData()} is not\n+ * included in the output.\n@@ -77,2 +76,2 @@\n- * <p>The following lists the supported {@code DEREncodable} classes and\n- * the PEM types that each are encoded as:\n+ * <p> The following lists the supported {@code DEREncodable} classes and\n+ * the PEM types they encoded as:\n@@ -85,2 +84,2 @@\n- *  <li>{@code PrivateKey} (if configured with encryption):\n- *  ENCRYPTED PRIVATE KEY<\/li>\n+ *  <li>{@code PrivateKey} :\n+ *  ENCRYPTED PRIVATE KEY  (if configured with encryption)<\/li>\n@@ -89,2 +88,2 @@\n- *  <li>{@code KeyPair} (if configured with encryption) : ENCRYPTED PRIVATE KEY\n- *  <\/li>\n+ *  <li>{@code KeyPair} :\n+ *  ENCRYPTED PRIVATE KEY if configured with encryption)<\/li>\n@@ -93,2 +92,2 @@\n- *  <li>{@code PKCS8EncodedKeySpec} (if configured with encryption) :\n- *  ENCRYPTED PRIVATE KEY<\/li>\n+ *  <li>{@code PKCS8EncodedKeySpec} :\n+ *  ENCRYPTED PRIVATE KEY (if configured with encryption)<\/li>\n@@ -100,1 +99,1 @@\n- * <p> Here is an example of encoding a private key object:\n+ * <p> Example: encode a private key:\n@@ -106,2 +105,1 @@\n- * <p> Here is an example that encrypts and encodes a private key using the\n- * specified password:\n+ * <p> Example: encrypt and encode a private key using a password:\n@@ -113,2 +111,1 @@\n- * @implNote An implementation may support other PEM types and\n- * {@code DEREncodable} objects.\n+ * @implNote Implementations may support additional PEM types.\n@@ -165,1 +162,1 @@\n-     * Encodes the specified {@code DEREncodable} and returns a PEM encoded\n+     * Encodes the specified {@code DEREncodable} and returns a PEM-encoded\n@@ -169,1 +166,1 @@\n-     * @return a {@code String} containing the PEM encoded data\n+     * @return a {@code String} containing the PEM-encoded data\n@@ -240,2 +237,2 @@\n-     * Encodes the specified {@code DEREncodable} and returns the PEM encoding\n-     * in a byte array.\n+     * Encodes the specified {@code DEREncodable} and returns a PEM-encoded\n+     * byte array.\n@@ -244,1 +241,1 @@\n-     * @return a PEM encoded byte array\n+     * @return a PEM-encoded byte array\n@@ -255,2 +252,2 @@\n-     * Returns a new {@code PEMEncoder} instance configured for encryption\n-     * with the default algorithm and a given password.\n+     * Returns a copy of this PEMEncoder that encrypts and encodes\n+     * using the specified password and default encryption algorithm.\n@@ -267,2 +264,3 @@\n-     * For greater flexibility with encryption options and parameters, use\n-     * {@link EncryptedPrivateKeyInfo#encryptKey(DEREncodable, Key,\n+     * To use non-default encryption parameters, or to encrypt with a different\n+     * encryption provider, use\n+     * {@link EncryptedPrivateKeyInfo#encrypt(DEREncodable, Key,\n@@ -341,1 +339,1 @@\n-                privateEncoding = EncryptedPrivateKeyInfo.encryptKey(\n+                privateEncoding = EncryptedPrivateKeyInfo.encrypt(\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":30,"deletions":32,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-     * {@code encryptedData} is {@code null}.\n+     * {@code encryptedData} are {@code null}.\n@@ -181,1 +181,1 @@\n-     * {@code encryptedData} is {@code null}.\n+     * {@code encryptedData} are {@code null}.\n@@ -281,1 +281,1 @@\n-     * is {@code null}.\n+     * are {@code null}.\n@@ -330,1 +330,1 @@\n-     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n+     * Creates an {@code EncryptedPrivateKeyInfo} by encrypting the specified\n@@ -334,1 +334,1 @@\n-     * <p> The PBE algorithm string format details can be found in the\n+     * <p>The format of the PBE algorithm string is described in the\n@@ -336,1 +336,1 @@\n-     * Cipher section<\/a> of the Java Security Standard Algorithm Names\n+     * Cipher Algorithms<\/a> section of the Java Security Standard Algorithm Names\n@@ -339,15 +339,12 @@\n-     * @param de the {@code DEREncodable} to be encrypted. Usage\n-     *             limited to {@link PrivateKey}, {@link KeyPair}, and\n-     *            {@link PKCS8EncodedKeySpec}.\n-     * @param password the password used in the PBE encryption.  This array\n-     *                 will be cloned before being used.\n-     * @param algorithm the PBE encryption algorithm.  The default algorithm\n-     *                  will be used if {@code null}.  However, {@code null} is\n-     *                  not allowed when {@code params} is non-null.\n-     * @param params the {@code AlgorithmParameterSpec} to be used with\n-     *               encryption.  The provider default will be used if\n-     *               {@code null}.\n-     * @param provider the {@code Provider} will be used for PBE\n-     *                 {@link SecretKeyFactory} generation and {@link Cipher}\n-     *                 encryption operations. The default provider list will be\n-     *                 used if {@code null}.\n+     * @param de the {@code DEREncodable} to encrypt. Supported types include\n+     *            {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     * @param password the password used for PBE encryption. This array is cloned\n+     *                 before use.\n+     * @param algorithm the PBE encryption algorithm. If {@code null}, the default\n+     *                  algorithm is used. However, {@code null} is not permitted\n+     *                  when {@code params} is non-null.\n+     * @param params the {@code AlgorithmParameterSpec} used for encryption. If\n+     *               {@code null}, the provider’s default parameters are applied.\n+     * @param provider the {@code Provider} for {@link SecretKeyFactory} and\n+     *                 {@link Cipher} operations. If {@code null}, provider\n+     *                 defaults are used\n@@ -355,5 +352,8 @@\n-     * @throws IllegalArgumentException on initialization errors based on the\n-     * arguments passed to the method\n-     * @throws RuntimeException on an encryption error\n-     * @throws NullPointerException if the key or password are {@code null}. If\n-     * {@code params} is non-null when {@code algorithm} is {@code null}.\n+     * @throws NullPointerException if {@code de} or {@code password} is\n+     *         {@code null}, or if {@code params} is non-null while\n+     *         {@code algorithm} is {@code null}\n+     * @throws IllegalArgumentException if {@code de} is an unsupported\n+     *         {@code DEREncodable}, if an error occurs while generating the\n+     *         PBE key, or if {@code algorithm} or {@code params} are\n+     *         unsupported by any provider\n+     * @throws RuntimeException if encryption of the encoding fails\n@@ -362,2 +362,2 @@\n-     * defines the default encryption algorithm and the\n-     * {@code AlgorithmParameterSpec} are the provider's algorithm defaults.\n+     * defines the default encryption algorithm. The {@code AlgorithmParameterSpec}\n+     * defaults are determined by the provider.\n@@ -368,1 +368,1 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(DEREncodable de,\n+    public static EncryptedPrivateKeyInfo encrypt(DEREncodable de,\n@@ -384,1 +384,1 @@\n-            return encryptKeyImpl(getEncoding(de), algorithm,\n+            return encryptImpl(getEncoding(de), algorithm,\n@@ -391,1 +391,0 @@\n-\n@@ -393,3 +392,3 @@\n-     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n-     * {@code DEREncodable} and password.  Default algorithm and parameters are\n-     * used.\n+     * Creates an {@code EncryptedPrivateKeyInfo} by encrypting the specified\n+     * {@code DEREncodable} with the default password-based encryption (PBE)\n+     * algorithm and provider defaults.\n@@ -397,5 +396,4 @@\n-     * @param de the {@code DEREncodable} to be encrypted. Usage\n-     *            limited to {@link PrivateKey}, {@link KeyPair}, and\n-     *            {@link PKCS8EncodedKeySpec}.\n-     * @param password the password used in the PBE encryption.  This array\n-     *                 will be cloned before being used.\n+     * @param de the {@code DEREncodable} to encrypt. Supported types include\n+     *            {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     * @param password the password used for PBE encryption. This array is cloned\n+     *                 before use.\n@@ -403,5 +401,5 @@\n-     * @throws IllegalArgumentException on initialization errors based on the\n-     * arguments passed to the method\n-     * @throws RuntimeException on an encryption error\n-     * @throws NullPointerException when the {@code key} or {@code password}\n-     * is {@code null}\n+     * @throws NullPointerException if {@code de} or {@code password} is {@code null}\n+     * @throws IllegalArgumentException if {@code de} is an unsupported\n+     *         {@code DEREncodable}, if key generation fails, or if the\n+     *         default algorithm is misconfigured\n+     * @throws RuntimeException if encryption of the encoding fails\n@@ -410,2 +408,2 @@\n-     * defines the default encryption algorithm and the\n-     * {@code AlgorithmParameterSpec} are the provider's algorithm defaults.\n+     * defines the default encryption algorithm. The {@code AlgorithmParameterSpec}\n+     * defaults are determined by the provider.\n@@ -416,1 +414,1 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(DEREncodable de,\n+    public static EncryptedPrivateKeyInfo encrypt(DEREncodable de,\n@@ -418,1 +416,1 @@\n-        return encryptKey(de, password, Pem.DEFAULT_ALGO, null,\n+        return encrypt(de, password, Pem.DEFAULT_ALGO, null,\n@@ -423,2 +421,2 @@\n-     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from the given\n-     * {@link DEREncodable} using the {@code encKey} and given parameters.\n+     * Creates an {@code EncryptedPrivateKeyInfo} by encrypting the specified\n+     * {@link DEREncodable} using the provided encryption key, and parameters.\n@@ -426,16 +424,13 @@\n-     * @param de the {@code DEREncodable} to be encrypted. Usage\n-     *            limited to {@link PrivateKey}, {@link KeyPair}, and\n-     *            {@link PKCS8EncodedKeySpec}.\n-     * @param encryptKey the password-based encryption (PBE) {@code Key} used to\n-     *              encrypt {@code key}.\n-     * @param algorithm the PBE encryption algorithm.  The default algorithm is\n-     *                 will be used if {@code null}; however, {@code null} is\n-     *                 not allowed when {@code params} is non-null.\n-     * @param params the {@code AlgorithmParameterSpec} to be used with\n-     *               encryption. The provider list default will be used if\n-     *               {@code null}.\n-     * @param random the {@code SecureRandom} instance used during\n-     *               encryption.  The default will be used if {@code null}.\n-     * @param provider the {@code Provider} is used for {@link Cipher}\n-     *                encryption operation.  The default provider list will be\n-     *                used if {@code null}.\n+     * @param de the {@code DEREncodable} to encrypt. Supported types include\n+     *            {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     * @param encryptKey the key used to encrypt the encoding.  Must not be null\n+     * @param algorithm the password-based encryption (PBE) algorithm.\n+     *                 If {@code null}, the default algorithm is used, but\n+     *                 {@code null} is not permitted when {@code params} is\n+     *                 non-null.\n+     * @param params the {@code AlgorithmParameterSpec} used for encryption. If\n+     *               {@code null}, the provider’s default parameters are used\n+     * @param random the {@code SecureRandom} instance used during encryption.\n+     *               If {@code null}, the default is used\n+     * @param provider the {@code Provider} used for {@link Cipher} operations.\n+     *                 If {@code null}, the default provider list is used\n@@ -443,6 +438,7 @@\n-     * @throws IllegalArgumentException on initialization errors based on the\n-     * arguments passed to the method\n-     * @throws RuntimeException on an encryption error\n-     * @throws NullPointerException if the {@code key} or {@code encKey} are\n-     * {@code null}. If {@code params} is non-null, {@code algorithm} cannot be\n-     * {@code null}.\n+     * @throws NullPointerException if {@code de} or {@code encryptKey} is\n+     *         {@code null}, or if {@code params} is non-null while\n+     *         {@code algorithm} is {@code null}\n+     * @throws IllegalArgumentException if {@code de} is an unsupported\n+     *         {@code DEREncodable}, if {@code encryptKey} is invalid, or if\n+     *         {@code algorithm} or {@code params} are unsupported by any provider\n+     * @throws RuntimeException if encryption of the encoding fails\n@@ -451,2 +447,2 @@\n-     * defines the default encryption algorithm and the\n-     * {@code AlgorithmParameterSpec} are the provider's algorithm defaults.\n+     * defines the default encryption algorithm. The {@code AlgorithmParameterSpec}\n+     * defaults are determined by the provider.\n@@ -457,1 +453,1 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(DEREncodable de,\n+    public static EncryptedPrivateKeyInfo encrypt(DEREncodable de,\n@@ -471,1 +467,1 @@\n-        return encryptKeyImpl(getEncoding(de), algorithm, encryptKey,\n+        return encryptImpl(getEncoding(de), algorithm, encryptKey,\n@@ -475,1 +471,1 @@\n-    private static EncryptedPrivateKeyInfo encryptKeyImpl(byte[] encoded,\n+    private static EncryptedPrivateKeyInfo encryptImpl(byte[] encoded,\n@@ -499,1 +495,1 @@\n-                 NoSuchPaddingException e) {\n+                 IllegalStateException | NoSuchPaddingException e) {\n@@ -513,1 +509,2 @@\n-     * Extracts and returns a {@code PrivateKey} object from the encrypted data.\n+     * Extracts and returns the enclosed {@code PrivateKey} using the\n+     * specified password.\n@@ -515,5 +512,3 @@\n-     * @param password the password used in the PBE encryption.  This array\n-     *                 will be cloned before being used.\n-     * @return a {@code PrivateKey} extracted from the encrypted data\n-     * @throws GeneralSecurityException if an error occurs parsing,\n-     * decrypting the data, or producing the key object.\n+     * @param password the password for PBE decryption. The array is cloned\n+     *                before use.\n+     * @return the decrypted {@code PrivateKey}\n@@ -521,2 +516,4 @@\n-     *\n-     * @since 25\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if the encoded data does not contain both a\n+     * public and private key, or if an error occurs during parsing, decryption,\n+     * or key generation\n@@ -527,1 +524,1 @@\n-        return PKCS8Key.parseKey(Pem.decryptEncoding(encoded, password),null);\n+        return PKCS8Key.parseKey(Pem.decryptEncoding(this, password.clone()),null);\n@@ -531,1 +528,2 @@\n-     * Extracts and returns a {@code PrivateKey} object from the encrypted data.\n+     * Extracts and returns the enclosed {@code PrivateKey} using the specified\n+     * decryption key and provider.\n@@ -533,7 +531,5 @@\n-     * @param decryptKey the decryption key and cannot be {@code null}\n-     * @param provider the {@code Provider} used for Cipher decryption and\n-     *                 {@code PrivateKey} generation. A {@code null} value will\n-     *                 use the default provider configuration.\n-     * @return a {@code PrivateKey} extracted from the encrypted data\n-     * @throws GeneralSecurityException if an error occurs parsing,\n-     * decrypting the data, or producing the key object.\n+     * @param decryptKey the decryption key. Must not be {@code null}\n+     * @param provider the {@code Provider} used for {@link Cipher} decryption\n+     *                and {@link PrivateKey} generation. If {@code null}, the\n+     *                default provider configuration is used\n+     * @return the decrypted {@code PrivateKey}\n@@ -541,0 +537,4 @@\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if the encoded data does not contain both a\n+     * public and private key, or if an error occurs while parsing, decryption,\n+     * or key generation\n@@ -552,2 +552,3 @@\n-     * Extracts and returns a {@code KeyPair} object from the encrypted data.\n-     * The data must contain both a public and private key.\n+     * Extracts and returns the enclosed {@code KeyPair} using the specified\n+     * password. If the encoded data does not contain both a public and private\n+     * key, an {@code InvalidKeyException} is thrown.\n@@ -555,1 +556,1 @@\n-     * @param password the password used in the PBE encryption.  This array\n+     * @param password the password used for PBE encryption.  This array\n@@ -557,3 +558,1 @@\n-     * @return a {@code KeyPair} extracted from the encrypted data\n-     * @throws GeneralSecurityException if an error occurs while parsing,\n-     * decrypting the data, or producing the {@code KeyPair} object.\n+     * @return a decrypted {@code KeyPair}\n@@ -561,0 +560,3 @@\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if the encoded data lacks a public key or an\n+     *         error occurs during parsing, decryption, or key generation\n@@ -569,1 +571,1 @@\n-            Pem.decryptEncoding(encoded, password), true, null);\n+            Pem.decryptEncoding(this, password.clone()), true, null);\n@@ -580,2 +582,3 @@\n-     * Extracts and returns a {@code KeyPair} object from the encrypted data.\n-     * The data must contain both a public and private key.\n+     * Extracts and returns the enclosed {@code KeyPair} using the specified\n+     * decryption key and provider. If the encoded data does not contain both a\n+     * public and private key, an {@code InvalidKeyException} is thrown.\n@@ -583,7 +586,5 @@\n-     * @param decryptKey the decryption key and cannot be {@code null}\n-     * @param provider the {@code Provider} used for Cipher decryption and\n-     *                 key generation. A {@code null} value will\n-     *                 use the default provider configuration.\n-     * @return a {@code KeyPair} extracted from the encrypted data\n-     * @throws GeneralSecurityException if an error occurs parsing,\n-     * decrypting the data, or producing the {@code KeyPair} object.\n+     * @param decryptKey the decryption key; must not be {@code null}\n+     * @param provider the {@code Provider} used for (@link Cipher} decryption\n+     *                 and key generation. If {@code null} the default provider\n+     *                 configuration is used\n+     * @return a decrypted {@code KeyPair}\n@@ -591,0 +592,3 @@\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if the encoded data lacks a public key or an\n+     *         error occurs during parsing, decryption, or key generation\n@@ -639,1 +643,1 @@\n-     * @return the PKCS8EncodedKeySpec object.\n+     * @return the PKCS8EncodedKeySpec object\n@@ -641,1 +645,1 @@\n-     * or {@code providerName} is {@code null}.\n+     * or {@code providerName} are {@code null}.\n@@ -673,1 +677,1 @@\n-     * or {@code provider} is {@code null}.\n+     * or {@code provider} are {@code null}.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":118,"deletions":114,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-        @JEP(number=470, title=\"PEM Encodings of Cryptographic Objects\", status=\"Preview\")\n+        @JEP(number=524, title=\"PEM Encodings of Cryptographic Objects\",\n+            status=\"Second Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,2 +104,5 @@\n-        makeEncoding(sOctets);\n-        Arrays.fill(sOctets, (byte) 0);\n+        try {\n+            makeEncoding(sOctets);\n+        } finally {\n+            Arrays.fill(sOctets, (byte) 0);\n+        }\n@@ -114,2 +117,6 @@\n-        makeEncoding(privBytes);\n-        Arrays.fill(privBytes, (byte) 0);\n+        try {\n+            makeEncoding(privBytes);\n+        } finally {\n+            Arrays.fill(privBytes, (byte) 0);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -369,0 +369,6 @@\n+        return decryptEncoding(ekpi, password);\n+    }\n+\n+    public static byte[] decryptEncoding(EncryptedPrivateKeyInfo ekpi, char[] password)\n+        throws GeneralSecurityException {\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -176,2 +176,2 @@\n-        System.out.println(\"EncryptedPrivateKeyInfo.encryptKey with PBE: \");\n-        ekpi = EncryptedPrivateKeyInfo.encryptKey(privateKey,\n+        System.out.println(\"EncryptedPrivateKeyInfo.encrypt with PBE: \");\n+        ekpi = EncryptedPrivateKeyInfo.encrypt(privateKey,\n@@ -187,2 +187,2 @@\n-        System.out.println(\"EncryptedPrivateKeyInfo.encryptKey with default: \");\n-        ekpi = EncryptedPrivateKeyInfo.encryptKey(privateKey\n+        System.out.println(\"EncryptedPrivateKeyInfo.encrypt with default: \");\n+        ekpi = EncryptedPrivateKeyInfo.encrypt(privateKey\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-                EncryptedPrivateKeyInfo.encryptKey(pkey, entry.password(),\n+                EncryptedPrivateKeyInfo.encrypt(pkey, entry.password(),\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ * @bug 8298420\n+ * @summary Testing encryptKey\n+ * @enablePreview\n+ *\/\n+\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.AlgorithmParameters;\n+import java.security.PEMDecoder;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.util.Arrays;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+public class Encrypt {\n+\n+    private static final String encEdECKey =\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\";\n+    private static final String passwdText = \"fish\";\n+    private static final char[] password = passwdText.toCharArray();\n+    private static final SecretKey key = new SecretKeySpec(\n+        passwdText.getBytes(), \"PBE\");\n+\n+    public static void main(String[] args) throws Exception {\n+        Provider p = Security.getProvider(System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+\n+        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(encEdECKey,\n+            EncryptedPrivateKeyInfo.class);\n+        PrivateKey priKey = PEMDecoder.of().withDecryption(password).\n+            decode(encEdECKey, PrivateKey.class);\n+        AlgorithmParameters ap = ekpi.getAlgParameters();\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ... )\n+        var e = EncryptedPrivateKeyInfo.encrypt(priKey, password,\n+            ekpi.getAlgName(), ap.getParameterSpec(PBEParameterSpec.class),\n+            null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, password, ekpi.getAlgName(),\n+                ap.getParameterSpec(PBEParameterSpec.class), p);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                    \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider and null algorithm\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, password, null, null,\n+                p);\n+        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...)\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, ekpi.getAlgName(),\n+            ap.getParameterSpec(PBEParameterSpec.class),null, null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null random\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, ekpi.getAlgName(),\n+                ap.getParameterSpec(PBEParameterSpec.class), p, null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                    \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and SecureRandom\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, ekpi.getAlgName(),\n+                ap.getParameterSpec(PBEParameterSpec.class), p, new SecureRandom());\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                    \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null algorithm\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, null, null,\n+                p, new SecureRandom());\n+        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/Encrypt.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @modules java.base\/sun.security.util\n- * @bug 8298420\n- * @summary Testing encryptKey\n- * @enablePreview\n- *\/\n-\n-import sun.security.util.Pem;\n-\n-import javax.crypto.EncryptedPrivateKeyInfo;\n-import javax.crypto.SecretKey;\n-import javax.crypto.spec.PBEParameterSpec;\n-import javax.crypto.spec.SecretKeySpec;\n-import java.security.AlgorithmParameters;\n-import java.security.PEMDecoder;\n-import java.security.PrivateKey;\n-import java.security.Provider;\n-import java.security.SecureRandom;\n-import java.security.Security;\n-import java.util.Arrays;\n-\n-import static jdk.test.lib.Asserts.assertEquals;\n-\n-public class EncryptKey {\n-\n-    private static final String encEdECKey =\n-        \"\"\"\n-        -----BEGIN ENCRYPTED PRIVATE KEY-----\n-        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n-        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n-        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n-        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n-        -----END ENCRYPTED PRIVATE KEY-----\n-        \"\"\";\n-    private static final String passwdText = \"fish\";\n-    private static final char[] password = passwdText.toCharArray();\n-    private static final SecretKey key = new SecretKeySpec(\n-        passwdText.getBytes(), \"PBE\");\n-\n-    public static void main(String[] args) throws Exception {\n-        Provider p = Security.getProvider(System.getProperty(\"test.provider.name\", \"SunJCE\"));\n-\n-        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(encEdECKey,\n-            EncryptedPrivateKeyInfo.class);\n-        PrivateKey priKey = PEMDecoder.of().withDecryption(password).\n-            decode(encEdECKey, PrivateKey.class);\n-        AlgorithmParameters ap = ekpi.getAlgParameters();\n-\n-        \/\/ Test encryptKey(PrivateKey, char[], String, ... )\n-        var e = EncryptedPrivateKeyInfo.encryptKey(priKey, password,\n-            ekpi.getAlgName(), ap.getParameterSpec(PBEParameterSpec.class),\n-            null);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, password, ekpi.getAlgName(),\n-                ap.getParameterSpec(PBEParameterSpec.class), p);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                    \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider and null algorithm\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, password, null, null,\n-                p);\n-        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...)\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n-            ap.getParameterSpec(PBEParameterSpec.class),null, null);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null random\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n-                ap.getParameterSpec(PBEParameterSpec.class), p, null);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                    \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and SecureRandom\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n-                ap.getParameterSpec(PBEParameterSpec.class), p, new SecureRandom());\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                    \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null algorithm\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, null, null,\n-                p, new SecureRandom());\n-        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n-    }\n-}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/EncryptKey.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"}]}