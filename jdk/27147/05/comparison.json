{"files":[{"patch":"@@ -50,1 +50,1 @@\n- * @see PEMRecord\n+ * @see PEM\n@@ -58,1 +58,1 @@\n-    X509Certificate, X509CRL, PEMRecord {\n+    X509Certificate, X509CRL, PEM {\n","filename":"src\/java.base\/share\/classes\/java\/security\/DEREncodable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.security;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+import sun.security.util.Pem;\n+\n+import java.io.InputStream;\n+import java.util.Base64;\n+import java.util.Objects;\n+\n+\/**\n+ * {@code PEM} is a {@link DEREncodable} that represents Privacy-Enhanced\n+ * Mail (PEM) data by its type and Base64 content.\n+ *\n+ * <p> The {@link PEMDecoder#decode(String)} and\n+ * {@link PEMDecoder#decode(InputStream)} methods return a {@code PEM} object\n+ * when the data type cannot be represented by a cryptographic object.\n+ * If you need access to the leading data of a PEM text, or if you want to\n+ * handle the text content directly, use the decoding methods\n+ * {@link PEMDecoder#decode(String, Class)} or\n+ * {@link PEMDecoder#decode(InputStream, Class)} with {@code PEM.class} as a\n+ * argument type.\n+ *\n+ * <p> A {@code PEM} object can be encoded back to its textual format by calling\n+ * {@link #toString()} or using the encode methods in {@link PEMEncoder}.\n+ *\n+ * <p> When constructing a {@code PEM} instance, both {@code type} and\n+ * {@code content} must not be {@code null}.\n+ *\n+ * <p>No validation is performed during instantiation to ensure that\n+ * {@code type} conforms to RFC 7468 or other legacy formats, that\n+ * {@code content} is valid Base64, or that {@code content} matches the\n+ * {@code type}.\n+\n+ * <p> Common {@code type} values include, but are not limited to:\n+ * CERTIFICATE, CERTIFICATE REQUEST, ATTRIBUTE CERTIFICATE, X509 CRL, PKCS7,\n+ * CMS, PRIVATE KEY, ENCRYPTED PRIVATE KEY, RSA PRIVATE KEY, or PUBLIC KEY.\n+ *\n+ * <p> {@code leadingData} is {@code null} if there is no data preceding the PEM\n+ * header during decoding.  {@code leadingData} can be useful for reading\n+ * metadata that accompanies the PEM data. This value was not defensively\n+ * copied by the constructor, and the {@link #leadingData()} method does not\n+ * return a clone.\n+ *\n+ * @param type the type identifier from the PEM header, without PEM syntax\n+ *             labels; for example, for a public key, {@code type} would be\n+ *             \"PUBLIC KEY\"\n+ * @param content the Base64-encoded data, excluding the PEM header and footer\n+ * @param leadingData any non-PEM data that precedes the PEM header during\n+ *                   decoding.  This value may be {@code null}.\n+ *\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n+ *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n+ *\n+ * @see PEMDecoder\n+ * @see PEMEncoder\n+ *\n+ * @since 25\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+public record PEM(String type, String content, byte[] leadingData)\n+    implements DEREncodable {\n+\n+    \/**\n+     * Creates a {@code PEM} instance with the specified parameters.\n+     *\n+     * @param type the PEM type identifier\n+     * @param content the Base64-encoded data, excluding the PEM header and\n+     *               footer\n+     * @param leadingData any non-PEM data read during the decoding process\n+     *                    before the PEM header.  This value may be {@code null}\n+     * @throws IllegalArgumentException if {@code type} is incorrectly\n+     * formatted\n+     * @throws NullPointerException if {@code type} or {@code content} is\n+     * {@code null}\n+     *\/\n+    public PEM {\n+        Objects.requireNonNull(type, \"\\\"type\\\" cannot be null.\");\n+        Objects.requireNonNull(content, \"\\\"content\\\" cannot be null.\");\n+\n+        \/\/ With no validity checking on `type`, the constructor accept anything\n+        \/\/ including lowercase.  The onus is on the caller.\n+        if (type.startsWith(\"-\") || type.startsWith(\"BEGIN \") ||\n+            type.startsWith(\"END \")) {\n+            throw new IllegalArgumentException(\"PEM syntax labels found.  \" +\n+                \"Only the PEM type identifier is allowed\");\n+        }\n+    }\n+\n+    \/**\n+     * Creates a {@code PEM} instance with the specified type and content. This\n+     * constructor sets {@code leadingData} to {@code null}.\n+     *\n+     * @param type the PEM type identifier\n+     * @param content the Base64-encoded data, excluding the PEM header and\n+     *               footer\n+     * @throws IllegalArgumentException if {@code type} is incorrectly\n+     * formatted\n+     * @throws NullPointerException if {@code type} or {@code content} is\n+     * {@code null}\n+     *\/\n+    public PEM(String type, String content) {\n+        this(type, content, null);\n+    }\n+\n+    \/**\n+     * Returns the PEM formatted string containing the {@code type} and\n+     * Base64-encoded {@code content}. {@code leadingData} is not included.\n+     *\n+     * @return the PEM text representation\n+     *\/\n+    @Override\n+    public String toString() {\n+        return Pem.pemEncoded(this);\n+    }\n+\n+    \/**\n+     * Returns a Base64-decoded byte array of {@code content}, using\n+     * {@link Base64#getMimeDecoder()}.\n+     *\n+     * @return a new decoded byte array of {@code content}\n+     * @throws IllegalArgumentException on a decoding fails\n+     *\/\n+    public byte[] decode() {\n+        return Base64.getMimeDecoder().decode(content);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEM.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.Arrays;\n@@ -48,1 +49,1 @@\n- * lists (CRLs).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n+ * lists (CRLs).  It is defined in RFC 1421 and RFC 7468. PEM consists of a\n@@ -52,3 +53,3 @@\n- * <p> The {@linkplain #decode(String)} and {@linkplain #decode(InputStream)}\n- * methods return an instance of a class that matches the data\n- * type and implements {@link DEREncodable}.\n+ * <p> The {@link #decode(String)} and {@link #decode(InputStream)}\n+ * methods return an instance of a class that matches the PEM type and\n+ * implements {@link DEREncodable}.\n@@ -60,0 +61,3 @@\n+ *  <li>X509 CERTIFICATE : {@code X509Certificate}<\/li>\n+ *  <li>X.509 CERTIFICATE : {@code X509Certificate}<\/li>\n+ *  <li>CRL : {@code X509CRL}<\/li>\n@@ -62,2 +66,2 @@\n- *  <li>PUBLIC KEY : {@code X509EncodedKeySpec} (Only supported when passed as\n- *  a {@code Class} parameter)<\/li>\n+ *  <li>PUBLIC KEY : {@code X509EncodedKeySpec} (When passed as a {@code Class}\n+ *  parameter)<\/li>\n@@ -65,4 +69,6 @@\n- *  <li>PRIVATE KEY : {@code PKCS8EncodedKeySpec} (Only supported when passed\n- *  as a {@code Class} parameter)<\/li>\n- *  <li>PRIVATE KEY : {@code KeyPair} (if the encoding also contains a\n- *  public key)<\/li>\n+ *  <li>PRIVATE KEY : {@code PKCS8EncodedKeySpec} (When passed as a {@code Class}\n+ *  parameter)<\/li>\n+ *  <li>PRIVATE KEY : {@code PublicKey} (If the encoding contains a public key\n+ *  and is passed as a {@code Class} parameter)<\/li>\n+ *  <li>PRIVATE KEY : {@code KeyPair} (If the encoding contains a public key)\n+ *  <\/li>\n@@ -70,3 +76,10 @@\n- *  <li>ENCRYPTED PRIVATE KEY : {@code PrivateKey} (if configured with\n- *  Decryption)<\/li>\n- *  <li>Other types : {@code PEMRecord} <\/li>\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PrivateKey} (If configured with\n+ *  decryption)<\/li>\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code KeyPair} (If configured with decryption)\n+ *  <\/li>\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PKCS8EncodedKeySpec} (If configured with\n+ *  decryption)<\/li>\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PublicKey} (If configured with\n+ *  decryption, the encoding contains a public key, and is passed as a\n+ *  {@code Class} parameter)<\/li>\n+ *  <li>Other types : {@code PEM} <\/li>\n@@ -75,3 +88,3 @@\n- * <p> The {@code PublicKey} and {@code PrivateKey} types, an algorithm specific\n- * subclass is returned if the underlying algorithm is supported. For example an\n- * ECPublicKey and ECPrivateKey for Elliptic Curve keys.\n+ * <p> For {@code PublicKey} and {@code PrivateKey} types, an algorithm-specific\n+ * subclass is returned if the algorithm is supported. For example, an\n+ * {@code ECPublicKey} and {@code ECPrivateKey} for Elliptic Curve keys.\n@@ -81,1 +94,1 @@\n- * {@link PEMRecord}.\n+ * {@link PEM} object.\n@@ -83,12 +96,13 @@\n- * <p> The {@linkplain #decode(String, Class)} and\n- * {@linkplain #decode(InputStream, Class)} methods take a class parameter\n- * which determines the type of {@code DEREncodable} that is returned. These\n- * methods are useful when extracting or changing the return class.\n- * For example, if the PEM contains both public and private keys, the\n- * class parameter can specify which to return. Use\n- * {@code PrivateKey.class} to return only the private key.\n- * If the class parameter is set to {@code X509EncodedKeySpec.class}, the\n- * public key will be returned in that format.  Any type of PEM data can be\n- * decoded into a {@code PEMRecord} by specifying {@code PEMRecord.class}.\n- * If the class parameter doesn't match the PEM content, a\n- * {@linkplain ClassCastException} will be thrown.\n+ * <p> The {@link #decode(String, Class)} and\n+ * {@link #decode(InputStream, Class)} methods take a class parameter which\n+ * specifies the type of {@code DEREncodable} that is returned. These methods\n+ * are useful to avoid casting the return type when the PEM type is known, or\n+ * when extracting a specific type when there is more than one choice.\n+ * For example, if the PEM contains both a public and private key, specifying\n+ * {@code PrivateKey.class} returns only the private key.\n+ * If the class parameter specifies {@code X509EncodedKeySpec.class}, the\n+ * public key encoding is returned in an instance of the\n+ * {@code X509EncodedKeySpec} class.  Any type of PEM data can be decoded into\n+ * a {@code PEM} object by specifying {@code PEM.class}. If the class parameter\n+ * doesn't match the PEM content, a {@linkplain ClassCastException} will be\n+ * thrown.\n@@ -97,11 +111,9 @@\n- * with {@linkplain #withFactory(Provider)} and\/or\n- * {@linkplain #withDecryption(char[])}. {@linkplain #withFactory(Provider)}\n- * configures the decoder to use only {@linkplain KeyFactory} and\n- * {@linkplain CertificateFactory} instances from the given {@code Provider}.\n- * {@linkplain #withDecryption(char[])} configures the decoder to decrypt all\n- * encrypted private key PEM data using the given password.\n- * Configuring an instance for decryption does not prevent decoding with\n- * unencrypted PEM. Any encrypted PEM that fails decryption\n- * will throw a {@link RuntimeException}. When an encrypted private key PEM is\n- * used with a decoder not configured for decryption, an\n- * {@link EncryptedPrivateKeyInfo} object is returned.\n+ * with {@link #withFactory(Provider)} or {@link #withDecryption(char[])}.\n+ * The {@link #withFactory(Provider)} method uses the specified provider\n+ * to produce cryptographic objects from {@link KeyFactory} and\n+ * {@link CertificateFactory}. The {@link #withDecryption(char[])} configures the\n+ * decoder to decrypt and decode encrypted private key PEM data using the given\n+ * password.  If decryption fails, an {@link IllegalArgumentException} is thrown.\n+ * If an encrypted private key PEM is processed by a decoder not configured\n+ * for decryption, an {@link EncryptedPrivateKeyInfo} object is returned.\n+ * Decryption configured instances will decode unencrypted PEM.\n@@ -109,1 +121,1 @@\n- * <p>This class is immutable and thread-safe.\n+ * <p> This class is immutable and thread-safe.\n@@ -111,1 +123,1 @@\n- * <p> Here is an example of decoding a {@code PrivateKey} object:\n+ * <p> Example: decode a private key:\n@@ -117,2 +129,1 @@\n- * <p> Here is an example of a {@code PEMDecoder} configured with decryption\n- * and a factory provider:\n+ * <p> Example: configure decryption and a factory provider:\n@@ -121,2 +132,2 @@\n- *         withFactory(provider);\n- *     byte[] pemData = pd.decode(privKey);\n+ *             withFactory(provider);\n+ *     DEREncodable pemData = pd.decode(privKeyPEM);\n@@ -125,4 +136,2 @@\n- * @implNote An implementation may support other PEM types and\n- * {@code DEREncodable} objects. This implementation additionally supports\n- * the following PEM types:  {@code X509 CERTIFICATE},\n- * {@code X.509 CERTIFICATE}, {@code CRL}, and {@code RSA PRIVATE KEY}.\n+ * @implNote This implementation decodes PEM type {@code RSA PRIVATE KEY} as\n+ * {@code PRIVATE KEY}. Other implementations may support additional types.\n@@ -131,1 +140,1 @@\n- * @see PEMRecord\n+ * @see PEM\n@@ -136,0 +145,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc5958\n+ *       RFC 5958: Asymmetric Key Packages\n@@ -175,1 +186,1 @@\n-    private DEREncodable decode(PEMRecord pem) {\n+    private DEREncodable decode(PEM pem) {\n@@ -205,2 +216,1 @@\n-                        \/\/ encodings, look for the public key again.  This\n-                        \/\/ happens with EC and SEC1-v2 encoding\n+                        \/\/ encodings, look for the public key again.\n@@ -221,2 +231,5 @@\n-                    yield new EncryptedPrivateKeyInfo(decoder.decode(pem.content())).\n-                        getKey(password.getPassword());\n+                    byte[] p8 = Pem.decryptEncoding(\n+                        decoder.decode(pem.content()), password.getPassword());\n+                    DEREncodable d = Pem.toDEREncodable(p8, true, factory);\n+                    Arrays.fill(p8, (byte)0x0);\n+                    yield d;\n@@ -255,7 +268,6 @@\n-     * <p> This method returns a Java API cryptographic object,\n-     * such as a {@code PrivateKey}, if the PEM type is supported.\n-     * Any non-PEM data preceding the PEM header is ignored by the decoder.\n-     * Otherwise, a {@link PEMRecord} will be returned containing\n-     * the type identifier and Base64-encoded data.\n-     * Any non-PEM data preceding the PEM header will be stored in\n-     * {@code leadingData}.\n+     * <p> A {@code DEREncodable} will be returned that best represents the\n+     * decoded data.  If the PEM type is not supported, a {@link PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the DEREncodable object.\n@@ -270,1 +282,1 @@\n-     * @throws NullPointerException when {@code str} is null\n+     * @throws NullPointerException when {@code str} is {@code null}\n@@ -288,1 +300,1 @@\n-     * the PEM footer or the end of the stream. If an I\/O error occurs,\n+     * a PEM footer or the end of the stream. If an I\/O error occurs,\n@@ -293,7 +305,6 @@\n-     * <p> This method returns a Java API cryptographic object,\n-     * such as a {@code PrivateKey}, if the PEM type is supported.\n-     * Any non-PEM data preceding the PEM header is ignored by the decoder.\n-     * Otherwise, a {@link PEMRecord} will be returned containing\n-     * the type identifier and Base64-encoded data.\n-     * Any non-PEM data preceding the PEM header will be stored in\n-     * {@code leadingData}.\n+     * <p> A {@code DEREncodable} will be returned that best represents the\n+     * decoded data.  If the PEM type is not supported, a {@link PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the DEREncodable object.\n@@ -308,1 +319,2 @@\n-     * @throws EOFException at the end of the {@code InputStream}\n+     * @throws EOFException no PEM data found or unexpectedly reached the\n+     *   end of the {@code InputStream}\n@@ -310,1 +322,1 @@\n-     * @throws NullPointerException when {@code is} is null\n+     * @throws NullPointerException when {@code is} is {@code null}\n@@ -314,1 +326,1 @@\n-        PEMRecord pem = Pem.readPEM(is);\n+        PEM pem = Pem.readPEM(is);\n@@ -320,2 +332,2 @@\n-     * the given PEM string. {@code tClass} must extend {@link DEREncodable}\n-     * and be an appropriate class for the PEM type.\n+     * the given PEM string. {@code tClass} must be an appropriate class for\n+     * the PEM type.\n@@ -327,5 +339,5 @@\n-     * <p> If the class parameter is {@code PEMRecord.class},\n-     * a {@linkplain PEMRecord} is returned containing the\n-     * type identifier and Base64 encoding. Any non-PEM data preceding\n-     * the PEM header will be stored in {@code leadingData}.  Other\n-     * class parameters will not return preceding non-PEM data.\n+     * <p> If the class parameter is {@code PEM.class}, a {@link PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the DEREncodable object.\n@@ -338,1 +350,1 @@\n-     * @param tClass the returned object class that implements\n+     * @param tClass the returned object class that extends or implements\n@@ -343,2 +355,2 @@\n-     * @throws ClassCastException if {@code tClass} is invalid for the PEM type\n-     * @throws NullPointerException when any input values are null\n+     * @throws ClassCastException if {@code tClass} does not represent the PEM type\n+     * @throws NullPointerException when any input values are {@code null}\n@@ -358,3 +370,3 @@\n-     * Decodes and returns the specified class for the given\n-     * {@link InputStream}.  The class must extend {@link DEREncodable} and be\n-     * an appropriate class for the PEM type.\n+     * Decodes and returns a {@code DEREncodable} of the specified class for the\n+     * given {@link InputStream}. {@code tClass} must be an appropriate class\n+     * for the PEM type.\n@@ -363,1 +375,1 @@\n-     * the PEM footer or the end of the stream. If an I\/O error occurs,\n+     * a PEM footer or the end of the stream. If an I\/O error occurs,\n@@ -368,5 +380,5 @@\n-     * <p> If the class parameter is {@code PEMRecord.class},\n-     * a {@linkplain PEMRecord} is returned containing the\n-     * type identifier and Base64 encoding. Any non-PEM data preceding\n-     * the PEM header will be stored in {@code leadingData}.  Other\n-     * class parameters will not return preceding non-PEM data.\n+     * <p> If the class parameter is {@code PEM.class}, a {@link PEM} object is\n+     * returned containing the type identifier, Base64-encoded data, and any\n+     * leading data preceding the PEM header. For {@code DEREncodable} types\n+     * other than {@code PEM}, leading data is ignored and not returned as part\n+     * of the DEREncodable object.\n@@ -379,1 +391,1 @@\n-     * @param tClass the returned object class that implements\n+     * @param tClass the returned object class that extends or implements\n@@ -383,2 +395,3 @@\n-     * {@code InputStream} did not complete decoding.\n-     * @throws EOFException at the end of the {@code InputStream}\n+     *   {@code InputStream} did not complete decoding.\n+     * @throws EOFException no PEM data found or unexpectedly reached the\n+     *   end of the {@code InputStream}\n@@ -386,2 +399,2 @@\n-     * @throws ClassCastException if {@code tClass} is invalid for the PEM type\n-     * @throws NullPointerException when any input values are null\n+     * @throws ClassCastException if {@code tClass} does not represent the PEM type\n+     * @throws NullPointerException when any input values are {@code null}\n@@ -396,1 +409,1 @@\n-        PEMRecord pem = Pem.readPEM(is);\n+        PEM pem = Pem.readPEM(is);\n@@ -398,1 +411,1 @@\n-        if (tClass.isAssignableFrom(PEMRecord.class)) {\n+        if (tClass.isAssignableFrom(PEM.class)) {\n@@ -486,2 +499,2 @@\n-     * @return a new PEMEncoder instance configured to the {@code Provider}.\n-     * @throws NullPointerException if {@code provider} is null\n+     * @return a new PEMEncoder instance configured with the {@code Provider}.\n+     * @throws NullPointerException if {@code provider} is {@code null}\n@@ -497,1 +510,1 @@\n-     * Non-encrypted PEM can still be decoded from this instance.\n+     * Non-encrypted PEM can also be decoded from this instance.\n@@ -499,1 +512,1 @@\n-     * @param password the password to decrypt encrypted PEM data.  This array\n+     * @param password the password to decrypt the encrypted PEM data. This array\n@@ -501,2 +514,2 @@\n-     * @return a new PEMEncoder instance configured for decryption\n-     * @throws NullPointerException if {@code password} is null\n+     * @return a new PEMDecoder instance configured for decryption\n+     * @throws NullPointerException if {@code password} is {@code null}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":120,"deletions":107,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n@@ -33,1 +31,0 @@\n-import sun.security.x509.AlgorithmId;\n@@ -43,0 +40,1 @@\n+import java.util.Arrays;\n@@ -48,1 +46,1 @@\n- * data.  PEM is a textual encoding used to store and transfer security\n+ * data.  PEM is a textual encoding used to store and transfer cryptographic\n@@ -50,1 +48,1 @@\n- * lists (CRL).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n+ * lists (CRLs).  It is defined in RFC 1421 and RFC 7468.  PEM consists of a\n@@ -54,1 +52,1 @@\n- * <p> Encoding may be performed on Java API cryptographic objects that\n+ * <p> Encoding can be performed on cryptographic objects that\n@@ -60,1 +58,1 @@\n- * {@code PEMEncoder} with the {@linkplain #withEncryption(char[])} method,\n+ * {@code PEMEncoder} with the {@link #withEncryption(char[])} method,\n@@ -63,1 +61,1 @@\n- * private key encrypted as an {@code EncryptedKeyInfo} object can be encoded\n+ * private key encrypted as an {@link EncryptedPrivateKeyInfo} object can be encoded\n@@ -73,5 +71,4 @@\n- * <p> When encoding a {@link PEMRecord}, the API surrounds the\n- * {@linkplain PEMRecord#content()} with the PEM header and footer\n- * from {@linkplain PEMRecord#type()}. {@linkplain PEMRecord#leadingData()} is\n- * not included in the encoding.  {@code PEMRecord} will not perform\n- * validity checks on the data.\n+ * <p> When encoding a {@link PEM} object, the API surrounds\n+ * {@link PEM#content()} with a PEM header and footer based on\n+ * {@link PEM#type()}. The value returned by {@link PEM#leadingData()} is not\n+ * included in the output.\n@@ -79,2 +76,2 @@\n- * <p>The following lists the supported {@code DEREncodable} classes and\n- * the PEM types that each are encoded as:\n+ * <p> The following lists the supported {@code DEREncodable} classes and\n+ * the PEM types they encoded as:\n@@ -85,1 +82,1 @@\n- *  <li>{@code PublicKey}: PUBLIC KEY<\/li>\n+ *  <li>{@code PublicKey} : PUBLIC KEY<\/li>\n@@ -87,2 +84,2 @@\n- *  <li>{@code PrivateKey} (if configured with encryption):\n- *  ENCRYPTED PRIVATE KEY<\/li>\n+ *  <li>{@code PrivateKey} :\n+ *  ENCRYPTED PRIVATE KEY  (if configured with encryption)<\/li>\n@@ -91,0 +88,2 @@\n+ *  <li>{@code KeyPair} :\n+ *  ENCRYPTED PRIVATE KEY if configured with encryption)<\/li>\n@@ -93,1 +92,3 @@\n- *  <li>{@code PEMRecord} : {@code PEMRecord.type()}<\/li>\n+ *  <li>{@code PKCS8EncodedKeySpec} :\n+ *  ENCRYPTED PRIVATE KEY (if configured with encryption)<\/li>\n+ *  <li>{@code PEM} : {@code PEM.type()}<\/li>\n@@ -98,1 +99,1 @@\n- * <p> Here is an example of encoding a {@code PrivateKey} object:\n+ * <p> Example: encode a private key:\n@@ -104,2 +105,1 @@\n- * <p> Here is an example that encrypts and encodes a private key using the\n- * specified password:\n+ * <p> Example: encrypt and encode a private key using a password:\n@@ -111,2 +111,1 @@\n- * @implNote An implementation may support other PEM types and\n- * {@code DEREncodable} objects.\n+ * @implNote Implementations may support additional PEM types.\n@@ -116,1 +115,1 @@\n- * @see PEMRecord\n+ * @see PEM\n@@ -121,0 +120,2 @@\n+ * @spec https:\/\/www.rfc-editor.org\/info\/rfc5958\n+ *       RFC 5958: Asymmetric Key Packages\n@@ -161,1 +162,1 @@\n-     * Encodes the specified {@code DEREncodable} and returns a PEM encoded\n+     * Encodes the specified {@code DEREncodable} and returns a PEM-encoded\n@@ -165,1 +166,1 @@\n-     * @return a {@code String} containing the PEM encoded data\n+     * @return a {@code String} containing the PEM-encoded data\n@@ -174,2 +175,2 @@\n-            case PublicKey pu -> buildKey(null, pu.getEncoded());\n-            case PrivateKey pr -> buildKey(pr.getEncoded(), null);\n+            case PublicKey pu -> buildKey(pu.getEncoded(), null);\n+            case PrivateKey pr -> buildKey(null, pr.getEncoded());\n@@ -185,2 +186,2 @@\n-                yield buildKey(kp.getPrivate().getEncoded(),\n-                    kp.getPublic().getEncoded());\n+                yield buildKey(kp.getPublic().getEncoded(),\n+                    kp.getPrivate().getEncoded());\n@@ -189,1 +190,1 @@\n-                buildKey(null, x.getEncoded());\n+                buildKey(x.getEncoded(), null);\n@@ -191,1 +192,1 @@\n-                buildKey(p.getEncoded(), null);\n+                buildKey(null, p.getEncoded());\n@@ -222,1 +223,1 @@\n-            case PEMRecord rec -> {\n+            case PEM rec -> {\n@@ -224,1 +225,1 @@\n-                    throw new IllegalArgumentException(\"PEMRecord cannot be \" +\n+                    throw new IllegalArgumentException(\"PEM cannot be \" +\n@@ -236,2 +237,2 @@\n-     * Encodes the specified {@code DEREncodable} and returns the PEM encoding\n-     * in a byte array.\n+     * Encodes the specified {@code DEREncodable} and returns a PEM-encoded\n+     * byte array.\n@@ -240,1 +241,1 @@\n-     * @return a PEM encoded byte array\n+     * @return a PEM-encoded byte array\n@@ -251,2 +252,2 @@\n-     * Returns a new {@code PEMEncoder} instance configured for encryption\n-     * with the default algorithm and a given password.\n+     * Returns a copy of this PEMEncoder that encrypts and encodes\n+     * using the specified password and default encryption algorithm.\n@@ -254,1 +255,2 @@\n-     * <p> Only {@link PrivateKey} objects can be encrypted with this newly\n+     * <p> Only {@link PrivateKey}, {@link KeyPair}, and\n+     * {@link PKCS8EncodedKeySpec} objects can be encoded with this newly\n@@ -262,2 +264,3 @@\n-     * For greater flexibility with encryption options and parameters, use\n-     * {@link EncryptedPrivateKeyInfo#encryptKey(PrivateKey, Key,\n+     * To use non-default encryption parameters, or to encrypt with a different\n+     * encryption provider, use\n+     * {@link EncryptedPrivateKeyInfo#encrypt(DEREncodable, Key,\n@@ -280,0 +283,2 @@\n+     *\n+     * privateKeyEncoding will be zeroed when the method returns\n@@ -281,5 +286,2 @@\n-    private String buildKey(byte[] privateBytes, byte[] publicBytes) {\n-        DerOutputStream out = new DerOutputStream();\n-        Cipher cipher;\n-\n-        if (privateBytes == null && publicBytes == null) {\n+    private String buildKey(byte[] publicEncoding, byte[] privateEncoding) {\n+        if (publicEncoding == null && privateEncoding == null) {\n@@ -290,0 +292,5 @@\n+        if (publicEncoding != null && publicEncoding.length == 0) {\n+            throw new IllegalArgumentException(\"Public key has no \" +\n+                \"encoding\");\n+        }\n+\n@@ -317,3 +324,3 @@\n-            if (privateBytes == null || publicBytes != null) {\n-                throw new IllegalArgumentException(\"Can only encrypt a \" +\n-                    \"PrivateKey.\");\n+            if (privateEncoding == null) {\n+                throw new IllegalArgumentException(\"This DEREncodable cannot \" +\n+                    \"be encrypted.\");\n@@ -322,0 +329,1 @@\n+            byte[] encoding = null;\n@@ -323,16 +331,17 @@\n-                cipher = Cipher.getInstance(Pem.DEFAULT_ALGO);\n-                cipher.init(Cipher.ENCRYPT_MODE, key);\n-            } catch (GeneralSecurityException e) {\n-                throw new IllegalArgumentException(\"Security property \" +\n-                    \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n-                    \"valid algorithm.  Operation cannot be performed.\", e);\n-            }\n-\n-            try {\n-                new AlgorithmId(Pem.getPBEID(Pem.DEFAULT_ALGO),\n-                    cipher.getParameters()).encode(out);\n-                out.putOctetString(cipher.doFinal(privateBytes));\n-                return Pem.pemEncoded(Pem.ENCRYPTED_PRIVATE_KEY,\n-                    DerValue.wrap(DerValue.tag_Sequence, out).toByteArray());\n-            } catch (GeneralSecurityException e) {\n-                throw new IllegalArgumentException(e);\n+                if (publicEncoding == null) {\n+                    encoding = privateEncoding;\n+                } else {\n+                    encoding = PKCS8Key.getEncoded(publicEncoding,\n+                        privateEncoding);\n+                    \/\/ The public key is part of the private encoding.\n+                    publicEncoding = null;\n+                }\n+                privateEncoding = EncryptedPrivateKeyInfo.encrypt(\n+                    new PKCS8EncodedKeySpec(encoding), key, null, null, null,\n+                    null).getEncoded();\n+            } catch (IOException e) {\n+                throw new IllegalArgumentException(\"Error while encoding\", e);\n+            } finally {\n+                if (encoding != null) {\n+                    Arrays.fill(encoding, (byte) 0x0);\n+                }\n@@ -343,2 +352,2 @@\n-        if (publicBytes != null && privateBytes == null) {\n-            if (publicBytes.length == 0) {\n+        if (publicEncoding != null && privateEncoding == null) {\n+            if (publicEncoding.length == 0) {\n@@ -348,12 +357,1 @@\n-\n-            return Pem.pemEncoded(Pem.PUBLIC_KEY, publicBytes);\n-        }\n-\n-        \/\/ PKCS8 only\n-        if (publicBytes == null && privateBytes != null) {\n-            if (privateBytes.length == 0) {\n-                throw new IllegalArgumentException(\"No private key encoding \" +\n-                    \"given by the DEREncodable.\");\n-            }\n-\n-            return Pem.pemEncoded(Pem.PRIVATE_KEY, privateBytes);\n+            return Pem.pemEncoded(Pem.PUBLIC_KEY, publicEncoding);\n@@ -362,2 +360,1 @@\n-        \/\/ OneAsymmetricKey\n-        if (privateBytes.length == 0) {\n+        if (privateEncoding.length == 0) {\n@@ -368,4 +365,0 @@\n-        if (publicBytes.length == 0) {\n-            throw new IllegalArgumentException(\"No public key encoding \" +\n-                \"given by the DEREncodable.\");\n-        }\n@@ -373,4 +366,5 @@\n-            return Pem.pemEncoded(Pem.PRIVATE_KEY,\n-                PKCS8Key.getEncoded(publicBytes, privateBytes));\n-        } catch (IOException e) {\n-            throw new IllegalArgumentException(e);\n+            return Pem.pemEncoded(\n+                (key == null ? Pem.PRIVATE_KEY : Pem.ENCRYPTED_PRIVATE_KEY),\n+                privateEncoding);\n+        } finally {\n+            Arrays.fill(privateEncoding, (byte)0x0);\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":85,"deletions":91,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.security;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-import sun.security.util.Pem;\n-\n-import java.util.Objects;\n-\n-\/**\n- * {@code PEMRecord} is a {@link DEREncodable} that represents Privacy-Enhanced\n- * Mail (PEM) data by its type and Base64 form.  {@link PEMDecoder} and\n- * {@link PEMEncoder} use {@code PEMRecord} when representing the data as a\n- * cryptographic object is not desired or the type has no\n- * {@code DEREncodable}.\n- *\n- * <p> {@code type} and {@code content} may not be {@code null}.\n- * {@code leadingData} may be null if no non-PEM data preceded PEM header\n- * during decoding.  {@code leadingData} may be useful for reading metadata\n- * that accompanies PEM data.\n- *\n- * <p> No validation is performed during instantiation to ensure that\n- * {@code type} conforms to {@code RFC 7468}, that {@code content} is valid\n- * Base64, or that {@code content} matches the {@code type}.\n- * {@code leadingData} is not defensively copied and does not return a\n- * clone when {@linkplain #leadingData()} is called.\n- *\n- * @param type the type identifier in the PEM header without PEM syntax labels.\n- *           For a public key, {@code type} would be \"PUBLIC KEY\".\n- * @param content the Base64-encoded data, excluding the PEM header and footer\n- * @param leadingData any non-PEM data preceding the PEM header when decoding.\n- *\n- * @spec https:\/\/www.rfc-editor.org\/info\/rfc7468\n- *       RFC 7468: Textual Encodings of PKIX, PKCS, and CMS Structures\n- *\n- * @see PEMDecoder\n- * @see PEMEncoder\n- *\n- * @since 25\n- *\/\n-@PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n-public record PEMRecord(String type, String content, byte[] leadingData)\n-    implements DEREncodable {\n-\n-    \/**\n-     * Creates a {@code PEMRecord} instance with the given parameters.\n-     *\n-     * @param type the type identifier\n-     * @param content the Base64-encoded data, excluding the PEM header and\n-     *               footer\n-     * @param leadingData any non-PEM data read during the decoding process\n-     *                    before the PEM header.  This value maybe {@code null}.\n-     * @throws IllegalArgumentException if {@code type} is incorrectly\n-     * formatted.\n-     * @throws NullPointerException if {@code type} and\/or {@code content} are\n-     * {@code null}.\n-     *\/\n-    public PEMRecord {\n-        Objects.requireNonNull(type, \"\\\"type\\\" cannot be null.\");\n-        Objects.requireNonNull(content, \"\\\"content\\\" cannot be null.\");\n-\n-        \/\/ With no validity checking on `type`, the constructor accept anything\n-        \/\/ including lowercase.  The onus is on the caller.\n-        if (type.startsWith(\"-\") || type.startsWith(\"BEGIN \") ||\n-            type.startsWith(\"END \")) {\n-            throw new IllegalArgumentException(\"PEM syntax labels found.  \" +\n-                \"Only the PEM type identifier is allowed\");\n-        }\n-\n-    }\n-\n-    \/**\n-     * Creates a {@code PEMRecord} instance with a given {@code type} and\n-     * {@code content} data in String form.  {@code leadingData} is set to null.\n-     *\n-     * @param type the PEM type identifier\n-     * @param content the Base64-encoded data, excluding the PEM header and\n-     *               footer\n-     * @throws IllegalArgumentException if {@code type} is incorrectly\n-     * formatted.\n-     * @throws NullPointerException if {@code type} and\/or {@code content} are\n-     * {@code null}.\n-     *\/\n-    public PEMRecord(String type, String content) {\n-        this(type, content, null);\n-    }\n-\n-    \/**\n-     * Returns the type and Base64 encoding in PEM format.  {@code leadingData}\n-     * is not returned by this method.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return Pem.pemEncoded(this);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMRecord.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Arrays;\n@@ -136,1 +137,1 @@\n-     * {@code encryptedData} is {@code null}.\n+     * {@code encryptedData} are {@code null}.\n@@ -180,1 +181,1 @@\n-     * {@code encryptedData} is {@code null}.\n+     * {@code encryptedData} are {@code null}.\n@@ -280,1 +281,1 @@\n-     * is {@code null}.\n+     * are {@code null}.\n@@ -299,0 +300,15 @@\n+    \/\/ Return the decrypted encryptedData in this instance.\n+    private byte[] decryptData(Key decryptKey, Provider provider)\n+        throws GeneralSecurityException {\n+        Cipher c;\n+        if (provider == null) {\n+            \/\/ use the most preferred one\n+            c = Cipher.getInstance(getAlgName());\n+        } else {\n+            c = Cipher.getInstance(getAlgName(), provider);\n+        }\n+        c.init(Cipher.DECRYPT_MODE, decryptKey, getAlgParameters());\n+        return c.doFinal(encryptedData);\n+    }\n+\n+    \/\/ Wrap the decrypted encryptedData in a P8EKS for getKeySpec methods.\n@@ -302,2 +318,0 @@\n-        byte[] encoded;\n-        Cipher c;\n@@ -305,9 +319,1 @@\n-            if (provider == null) {\n-                \/\/ use the most preferred one\n-                c = Cipher.getInstance(getAlgName());\n-            } else {\n-                c = Cipher.getInstance(getAlgName(), provider);\n-            }\n-            c.init(Cipher.DECRYPT_MODE, decryptKey, getAlgParameters());\n-            encoded = c.doFinal(encryptedData);\n-            return pkcs8EncodingToSpec(encoded);\n+            return pkcs8EncodingToSpec(decryptData(decryptKey, provider));\n@@ -319,1 +325,1 @@\n-                    \"Cannot retrieve the PKCS8EncodedKeySpec\", ex);\n+                \"Cannot retrieve the PKCS8EncodedKeySpec\", ex);\n@@ -324,2 +330,2 @@\n-     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n-     * {@code PrivateKey}.  A valid password-based encryption (PBE) algorithm\n+     * Creates an {@code EncryptedPrivateKeyInfo} by encrypting the specified\n+     * {@code DEREncodable}.  A valid password-based encryption (PBE) algorithm\n@@ -328,1 +334,1 @@\n-     * <p> The PBE algorithm string format details can be found in the\n+     * <p>The format of the PBE algorithm string is described in the\n@@ -330,1 +336,1 @@\n-     * Cipher section<\/a> of the Java Security Standard Algorithm Names\n+     * Cipher Algorithms<\/a> section of the Java Security Standard Algorithm Names\n@@ -333,13 +339,12 @@\n-     * @param key the {@code PrivateKey} to be encrypted\n-     * @param password the password used in the PBE encryption.  This array\n-     *                 will be cloned before being used.\n-     * @param algorithm the PBE encryption algorithm.  The default algorithm\n-     *                  will be used if {@code null}.  However, {@code null} is\n-     *                  not allowed when {@code params} is non-null.\n-     * @param params the {@code AlgorithmParameterSpec} to be used with\n-     *               encryption.  The provider default will be used if\n-     *               {@code null}.\n-     * @param provider the {@code Provider} will be used for PBE\n-     *                 {@link SecretKeyFactory} generation and {@link Cipher}\n-     *                 encryption operations. The default provider list will be\n-     *                 used if {@code null}.\n+     * @param de the {@code DEREncodable} to encrypt. Supported types include\n+     *            {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     * @param password the password used for PBE encryption. This array is cloned\n+     *                 before use.\n+     * @param algorithm the PBE encryption algorithm. If {@code null}, the default\n+     *                  algorithm is used. However, {@code null} is not permitted\n+     *                  when {@code params} is non-null.\n+     * @param params the {@code AlgorithmParameterSpec} used for encryption. If\n+     *               {@code null}, the provider’s default parameters are applied.\n+     * @param provider the {@code Provider} for {@link SecretKeyFactory} and\n+     *                 {@link Cipher} operations. If {@code null}, provider\n+     *                 defaults are used\n@@ -347,5 +352,8 @@\n-     * @throws IllegalArgumentException on initialization errors based on the\n-     * arguments passed to the method\n-     * @throws RuntimeException on an encryption error\n-     * @throws NullPointerException if the key or password are {@code null}. If\n-     * {@code params} is non-null when {@code algorithm} is {@code null}.\n+     * @throws NullPointerException if {@code de} or {@code password} is\n+     *         {@code null}, or if {@code params} is non-null while\n+     *         {@code algorithm} is {@code null}\n+     * @throws IllegalArgumentException if {@code de} is an unsupported\n+     *         {@code DEREncodable}, if an error occurs while generating the\n+     *         PBE key, or if {@code algorithm} or {@code params} are\n+     *         unsupported by any provider\n+     * @throws RuntimeException if encryption of the encoding fails\n@@ -354,2 +362,2 @@\n-     * defines the default encryption algorithm and the\n-     * {@code AlgorithmParameterSpec} are the provider's algorithm defaults.\n+     * defines the default encryption algorithm. The {@code AlgorithmParameterSpec}\n+     * defaults are determined by the provider.\n@@ -360,1 +368,1 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+    public static EncryptedPrivateKeyInfo encrypt(DEREncodable de,\n@@ -364,2 +372,1 @@\n-        SecretKey skey;\n-        Objects.requireNonNull(key, \"key cannot be null\");\n+        Objects.requireNonNull(de, \"key cannot be null\");\n@@ -367,1 +374,0 @@\n-        PBEKeySpec keySpec = new PBEKeySpec(password);\n@@ -376,0 +382,1 @@\n+        char[] passwd = password.clone();\n@@ -377,9 +384,5 @@\n-            SecretKeyFactory factory;\n-            if (provider == null) {\n-                factory = SecretKeyFactory.getInstance(algorithm);\n-            } else {\n-                factory = SecretKeyFactory.getInstance(algorithm, provider);\n-            }\n-            skey = factory.generateSecret(keySpec);\n-        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n-            throw new IllegalArgumentException(e);\n+            return encryptImpl(getEncoding(de), algorithm,\n+                generateSecretKey(password, algorithm, provider), params,\n+                provider, null);\n+        } finally {\n+            Arrays.fill(passwd, (char)0x0);\n@@ -387,1 +390,0 @@\n-        return encryptKeyImpl(key, algorithm, skey, params, provider, null);\n@@ -389,1 +391,0 @@\n-\n@@ -391,3 +392,3 @@\n-     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from a given\n-     * {@code PrivateKey} and password.  Default algorithm and parameters are\n-     * used.\n+     * Creates an {@code EncryptedPrivateKeyInfo} by encrypting the specified\n+     * {@code DEREncodable} with the default password-based encryption (PBE)\n+     * algorithm and provider defaults.\n@@ -395,3 +396,4 @@\n-     * @param key the {@code PrivateKey} to be encrypted\n-     * @param password the password used in the PBE encryption.  This array\n-     *                 will be cloned before being used.\n+     * @param de the {@code DEREncodable} to encrypt. Supported types include\n+     *            {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     * @param password the password used for PBE encryption. This array is cloned\n+     *                 before use.\n@@ -399,5 +401,5 @@\n-     * @throws IllegalArgumentException on initialization errors based on the\n-     * arguments passed to the method\n-     * @throws RuntimeException on an encryption error\n-     * @throws NullPointerException when the {@code key} or {@code password}\n-     * is {@code null}\n+     * @throws NullPointerException if {@code de} or {@code password} is {@code null}\n+     * @throws IllegalArgumentException if {@code de} is an unsupported\n+     *         {@code DEREncodable}, if key generation fails, or if the\n+     *         default algorithm is misconfigured\n+     * @throws RuntimeException if encryption of the encoding fails\n@@ -406,2 +408,2 @@\n-     * defines the default encryption algorithm and the\n-     * {@code AlgorithmParameterSpec} are the provider's algorithm defaults.\n+     * defines the default encryption algorithm. The {@code AlgorithmParameterSpec}\n+     * defaults are determined by the provider.\n@@ -412,1 +414,1 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key,\n+    public static EncryptedPrivateKeyInfo encrypt(DEREncodable de,\n@@ -414,1 +416,2 @@\n-        return encryptKey(key, password, Pem.DEFAULT_ALGO, null, null);\n+        return encrypt(de, password, Pem.DEFAULT_ALGO, null,\n+            null);\n@@ -418,2 +421,2 @@\n-     * Creates and encrypts an {@code EncryptedPrivateKeyInfo} from the given\n-     * {@link PrivateKey} using the {@code encKey} and given parameters.\n+     * Creates an {@code EncryptedPrivateKeyInfo} by encrypting the specified\n+     * {@link DEREncodable} using the provided encryption key, and parameters.\n@@ -421,14 +424,13 @@\n-     * @param key the {@code PrivateKey} to be encrypted\n-     * @param encKey the password-based encryption (PBE) {@code Key} used to\n-     *              encrypt {@code key}.\n-     * @param algorithm the PBE encryption algorithm.  The default algorithm is\n-     *                 will be used if {@code null}; however, {@code null} is\n-     *                 not allowed when {@code params} is non-null.\n-     * @param params the {@code AlgorithmParameterSpec} to be used with\n-     *               encryption. The provider list default will be used if\n-     *               {@code null}.\n-     * @param random the {@code SecureRandom} instance used during\n-     *               encryption.  The default will be used if {@code null}.\n-     * @param provider the {@code Provider} is used for {@link Cipher}\n-     *                encryption operation.  The default provider list will be\n-     *                used if {@code null}.\n+     * @param de the {@code DEREncodable} to encrypt. Supported types include\n+     *            {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     * @param encryptKey the key used to encrypt the encoding.  Must not be null\n+     * @param algorithm the password-based encryption (PBE) algorithm.\n+     *                 If {@code null}, the default algorithm is used, but\n+     *                 {@code null} is not permitted when {@code params} is\n+     *                 non-null.\n+     * @param params the {@code AlgorithmParameterSpec} used for encryption. If\n+     *               {@code null}, the provider’s default parameters are used\n+     * @param random the {@code SecureRandom} instance used during encryption.\n+     *               If {@code null}, the default is used\n+     * @param provider the {@code Provider} used for {@link Cipher} operations.\n+     *                 If {@code null}, the default provider list is used\n@@ -436,6 +438,7 @@\n-     * @throws IllegalArgumentException on initialization errors based on the\n-     * arguments passed to the method\n-     * @throws RuntimeException on an encryption error\n-     * @throws NullPointerException if the {@code key} or {@code encKey} are\n-     * {@code null}. If {@code params} is non-null, {@code algorithm} cannot be\n-     * {@code null}.\n+     * @throws NullPointerException if {@code de} or {@code encryptKey} is\n+     *         {@code null}, or if {@code params} is non-null while\n+     *         {@code algorithm} is {@code null}\n+     * @throws IllegalArgumentException if {@code de} is an unsupported\n+     *         {@code DEREncodable}, if {@code encryptKey} is invalid, or if\n+     *         {@code algorithm} or {@code params} are unsupported by any provider\n+     * @throws RuntimeException if encryption of the encoding fails\n@@ -444,2 +447,2 @@\n-     * defines the default encryption algorithm and the\n-     * {@code AlgorithmParameterSpec} are the provider's algorithm defaults.\n+     * defines the default encryption algorithm. The {@code AlgorithmParameterSpec}\n+     * defaults are determined by the provider.\n@@ -450,3 +453,3 @@\n-    public static EncryptedPrivateKeyInfo encryptKey(PrivateKey key, Key encKey,\n-        String algorithm, AlgorithmParameterSpec params, Provider provider,\n-        SecureRandom random) {\n+    public static EncryptedPrivateKeyInfo encrypt(DEREncodable de,\n+        Key encryptKey, String algorithm, AlgorithmParameterSpec params,\n+        Provider provider, SecureRandom random) {\n@@ -454,2 +457,3 @@\n-        Objects.requireNonNull(key);\n-        Objects.requireNonNull(encKey);\n+        Objects.requireNonNull(de, \"key cannot be null\");\n+        Objects.requireNonNull(encryptKey, \"an encryption key must be\" +\n+            \"specified.\");\n@@ -463,1 +467,2 @@\n-        return encryptKeyImpl(key, algorithm, encKey, params, provider, random);\n+        return encryptImpl(getEncoding(de), algorithm, encryptKey,\n+            params, provider, random);\n@@ -466,1 +471,1 @@\n-    private static EncryptedPrivateKeyInfo encryptKeyImpl(PrivateKey key,\n+    private static EncryptedPrivateKeyInfo encryptImpl(byte[] encoded,\n@@ -484,1 +489,1 @@\n-            encryptedData = c.doFinal(key.getEncoded());\n+            encryptedData = c.doFinal(encoded);\n@@ -490,1 +495,1 @@\n-                 NoSuchPaddingException e) {\n+                 IllegalStateException | NoSuchPaddingException e) {\n@@ -495,0 +500,2 @@\n+        } finally {\n+            Arrays.fill(encoded, (byte) 0x0);\n@@ -502,2 +509,2 @@\n-     * Extract the enclosed {@code PrivateKey} object from the encrypted data\n-     * and return it.\n+     * Extracts and returns the enclosed {@code PrivateKey} using the\n+     * specified password.\n@@ -505,8 +512,8 @@\n-     * @param password the password used in the PBE encryption.  This array\n-     *                 will be cloned before being used.\n-     * @return a {@code PrivateKey}\n-     * @throws GeneralSecurityException if an error occurs parsing or\n-     * decrypting the encrypted data, or producing the key object.\n-     * @throws NullPointerException if {@code password} is null\n-     *\n-     * @since 25\n+     * @param password the password for PBE decryption. The array is cloned\n+     *                before use.\n+     * @return the decrypted {@code PrivateKey}\n+     * @throws NullPointerException if {@code password} is {@code null}\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if the encoded data does not contain both a\n+     * public and private key, or if an error occurs during parsing, decryption,\n+     * or key generation\n@@ -516,2 +523,0 @@\n-        SecretKeyFactory skf;\n-        PKCS8EncodedKeySpec p8KeySpec;\n@@ -519,5 +524,1 @@\n-        PBEKeySpec keySpec = new PBEKeySpec(password);\n-        skf = SecretKeyFactory.getInstance(getAlgName());\n-        p8KeySpec = getKeySpec(skf.generateSecret(keySpec));\n-\n-        return PKCS8Key.parseKey(p8KeySpec.getEncoded());\n+        return PKCS8Key.parseKey(Pem.decryptEncoding(this, password.clone()),null);\n@@ -527,2 +528,2 @@\n-     * Extract the enclosed {@code PrivateKey} object from the encrypted data\n-     * and return it.\n+     * Extracts and returns the enclosed {@code PrivateKey} using the specified\n+     * decryption key and provider.\n@@ -530,8 +531,10 @@\n-     * @param decryptKey the decryption key and cannot be {@code null}\n-     * @param provider the {@code Provider} used for Cipher decryption and\n-     *                 {@code PrivateKey} generation. A {@code null} value will\n-     *                 use the default provider configuration.\n-     * @return a {@code PrivateKey}\n-     * @throws GeneralSecurityException if an error occurs parsing or\n-     * decrypting the encrypted data, or producing the key object.\n-     * @throws NullPointerException if {@code decryptKey} is null\n+     * @param decryptKey the decryption key. Must not be {@code null}\n+     * @param provider the {@code Provider} used for {@link Cipher} decryption\n+     *                and {@link PrivateKey} generation. If {@code null}, the\n+     *                default provider configuration is used\n+     * @return the decrypted {@code PrivateKey}\n+     * @throws NullPointerException if {@code decryptKey} is {@code null}\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if the encoded data does not contain both a\n+     * public and private key, or if an error occurs while parsing, decryption,\n+     * or key generation\n@@ -545,12 +548,64 @@\n-        PKCS8EncodedKeySpec p = getKeySpecImpl(decryptKey, provider);\n-        try {\n-            if (provider == null) {\n-                return KeyFactory.getInstance(\n-                    KeyUtil.getAlgorithm(p.getEncoded())).\n-                    generatePrivate(p);\n-            }\n-            return KeyFactory.getInstance(KeyUtil.getAlgorithm(p.getEncoded()),\n-                provider).generatePrivate(p);\n-        } catch (IOException e) {\n-            throw new GeneralSecurityException(e);\n-        }\n+        return PKCS8Key.parseKey(decryptData(decryptKey, provider), null);\n+    }\n+\n+    \/**\n+     * Extracts and returns the enclosed {@code KeyPair} using the specified\n+     * password. If the encoded data does not contain both a public and private\n+     * key, an {@code InvalidKeyException} is thrown.\n+     *\n+     * @param password the password used for PBE encryption.  This array\n+     *                 will be cloned before being used.\n+     * @return a decrypted {@code KeyPair}\n+     * @throws NullPointerException if {@code password} is {@code null}\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if the encoded data lacks a public key or an\n+     *         error occurs during parsing, decryption, or key generation\n+     *\n+     * @since 26\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public KeyPair getKeyPair(char[] password) throws GeneralSecurityException {\n+        Objects.requireNonNull(password, \"password cannot be null\");\n+\n+        DEREncodable d = Pem.toDEREncodable(\n+            Pem.decryptEncoding(this, password.clone()), true, null);\n+        return switch (d) {\n+            case KeyPair kp -> kp;\n+            case PrivateKey ignored -> throw new InvalidKeyException(\n+                \"This encoding do not contain a public key.\");\n+            default -> throw new InvalidKeyException(\n+                \"Invalid class returned \" + d.getClass().getName());\n+        };\n+    }\n+\n+    \/**\n+     * Extracts and returns the enclosed {@code KeyPair} using the specified\n+     * decryption key and provider. If the encoded data does not contain both a\n+     * public and private key, an {@code InvalidKeyException} is thrown.\n+     *\n+     * @param decryptKey the decryption key; must not be {@code null}\n+     * @param provider the {@code Provider} used for (@link Cipher} decryption\n+     *                 and key generation. If {@code null} the default provider\n+     *                 configuration is used\n+     * @return a decrypted {@code KeyPair}\n+     * @throws NullPointerException if {@code decryptKey} is {@code null}\n+     * @throws NoSuchAlgorithmException if the decryption algorithm is unsupported\n+     * @throws InvalidKeyException if the encoded data lacks a public key or an\n+     *         error occurs during parsing, decryption, or key generation\n+     *\n+     * @since 26\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.PEM_API)\n+    public KeyPair getKeyPair(Key decryptKey, Provider provider)\n+        throws GeneralSecurityException {\n+        Objects.requireNonNull(decryptKey,\"decryptKey cannot be null.\");\n+\n+        DEREncodable d = Pem.toDEREncodable(\n+            decryptData(decryptKey, provider),true, provider);\n+        return switch (d) {\n+            case KeyPair kp -> kp;\n+            case PrivateKey ignored -> throw new InvalidKeyException(\n+                \"This encoding do not contain a public key.\");\n+            default -> throw new InvalidKeyException(\n+                \"Invalid class returned \" + d.getClass().getName());\n+        };\n@@ -588,1 +643,1 @@\n-     * @return the PKCS8EncodedKeySpec object.\n+     * @return the PKCS8EncodedKeySpec object\n@@ -590,1 +645,1 @@\n-     * or {@code providerName} is {@code null}.\n+     * or {@code providerName} are {@code null}.\n@@ -622,1 +677,1 @@\n-     * or {@code provider} is {@code null}.\n+     * or {@code provider} are {@code null}.\n@@ -673,8 +728,1 @@\n-    private static void checkTag(DerValue val, byte tag, String valName)\n-        throws IOException {\n-        if (val.getTag() != tag) {\n-            throw new IOException(\"invalid key encoding - wrong tag for \" +\n-                                  valName);\n-        }\n-    }\n-\n+    \/\/ Read the encodedKey and return a P8EKS with the algorithm specified\n@@ -686,0 +734,38 @@\n+\n+    \/\/ Return the PKCS#8 encoding from a DEREncodable\n+    private static byte[] getEncoding(DEREncodable d) {\n+        return switch (d) {\n+            case PrivateKey p -> p.getEncoded();\n+            case PKCS8EncodedKeySpec p8 -> p8.getEncoded();\n+            case KeyPair kp -> {\n+                try {\n+                    yield PKCS8Key.getEncoded(kp.getPublic().getEncoded(),\n+                        kp.getPrivate().getEncoded());\n+                } catch (IOException e) {\n+                    throw new IllegalArgumentException(e);\n+                }\n+            }\n+            default -> throw new IllegalArgumentException(\n+                d.getClass().getName() + \" not supported by this method\");\n+        };\n+    }\n+\n+    \/\/ Generate a SecretKey from the password.\n+    private static SecretKey generateSecretKey(char[] password, String algorithm,\n+        Provider provider) {\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+\n+        try {\n+            SecretKeyFactory factory;\n+            if (provider == null) {\n+                factory = SecretKeyFactory.getInstance(algorithm);\n+            } else {\n+                factory = SecretKeyFactory.getInstance(algorithm, provider);\n+            }\n+            return factory.generateSecret(keySpec);\n+        } catch (NoSuchAlgorithmException | InvalidKeySpecException e) {\n+            throw new IllegalArgumentException(e);\n+        } finally {\n+            keySpec.clearPassword();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":238,"deletions":152,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-        @JEP(number=470, title=\"PEM Encodings of Cryptographic Objects\", status=\"Preview\")\n+        @JEP(number=524, title=\"PEM Encodings of Cryptographic Objects\",\n+            status=\"Second Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    private final byte SEC1v2 = 1;\n@@ -95,28 +96,0 @@\n-        makeEncoding(s);\n-\n-    }\n-\n-    ECPrivateKeyImpl(byte[] s, ECParameterSpec params)\n-            throws InvalidKeyException {\n-        this.arrayS = s.clone();\n-        this.params = params;\n-        makeEncoding(s);\n-    }\n-\n-    private void makeEncoding(byte[] s) throws InvalidKeyException {\n-        algid = new AlgorithmId\n-                (AlgorithmId.EC_oid, ECParameters.getAlgorithmParameters(params));\n-        DerOutputStream out = new DerOutputStream();\n-        out.putInteger(1); \/\/ version 1\n-        byte[] privBytes = s.clone();\n-        ArrayUtil.reverse(privBytes);\n-        out.putOctetString(privBytes);\n-        Arrays.fill(privBytes, (byte) 0);\n-        DerValue val = DerValue.wrap(DerValue.tag_Sequence, out);\n-        privKeyMaterial = val.toByteArray();\n-        val.clear();\n-    }\n-\n-    private void makeEncoding(BigInteger s) throws InvalidKeyException {\n-        algid = new AlgorithmId(AlgorithmId.EC_oid,\n-                ECParameters.getAlgorithmParameters(params));\n@@ -132,0 +105,20 @@\n+        try {\n+            makeEncoding(sOctets);\n+        } finally {\n+            Arrays.fill(sOctets, (byte) 0);\n+        }\n+    }\n+\n+    ECPrivateKeyImpl(byte[] s, ECParameterSpec params)\n+            throws InvalidKeyException {\n+        this.arrayS = s.clone();\n+        this.params = params;\n+        byte[] privBytes = arrayS.clone();\n+        ArrayUtil.reverse(privBytes);\n+        try {\n+            makeEncoding(privBytes);\n+        } finally {\n+            Arrays.fill(privBytes, (byte) 0);\n+        }\n+\n+    }\n@@ -133,0 +126,3 @@\n+    private void makeEncoding(byte[] privBytes) throws InvalidKeyException {\n+        algid = new AlgorithmId(AlgorithmId.EC_oid,\n+            ECParameters.getAlgorithmParameters(params));\n@@ -135,2 +131,1 @@\n-        out.putOctetString(sOctets);\n-        Arrays.fill(sOctets, (byte) 0);\n+        out.putOctetString(privBytes);\n@@ -184,1 +179,1 @@\n-            if (version != V2) {\n+            if (version != SEC1v2) {\n@@ -256,0 +251,36 @@\n+\n+    \/\/ Parse the SEC1v2 encoding to extract public key, if available.\n+    public static BitArray parsePublicBits(byte[] privateBytes) {\n+        DerValue seq = null;\n+        try {\n+            seq = new DerValue(privateBytes);\n+            if (seq.tag == DerValue.tag_Sequence) {\n+                int version = seq.data.getInteger();\n+                if (version == 1) { \/\/ EC\n+                    seq.data.getDerValue();  \/\/ read pass the private key\n+                    if (seq.data.available() != 0) {\n+                        DerValue derValue = seq.data.getDerValue();\n+                        \/\/ check for optional [0] EC domain parameters\n+                        if (derValue.isContextSpecific((byte) 0)) {\n+                            if (seq.data.available() == 0) {\n+                                return null;\n+                            }\n+                            derValue = seq.data.getDerValue();\n+                        }\n+                        \/\/ [1] public key\n+                        if (derValue.isContextSpecific((byte) 1)) {\n+                            derValue = derValue.data.getDerValue();\n+                            return derValue.getUnalignedBitString();\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(e);\n+        } finally {\n+            if (seq != null) {\n+                seq.clear();\n+            }\n+        }\n+        return null;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ec\/ECPrivateKeyImpl.java","additions":62,"deletions":31,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.ec.ECPrivateKeyImpl;\n@@ -107,1 +108,8 @@\n-    private PKCS8Key(byte[] privEncoding, byte[] pubEncoding)\n+    \/**\n+     * Constructor that takes both public and private encodings.\n+     *\n+     * If the private key includes a public key encoding (like an EC key in\n+     * SEC1v2 format), and a specified public key matches it, the existing\n+     * encoding is reused rather than recreated.\n+     *\/\n+    public PKCS8Key(byte[] publicEncoding, byte[] privateEncoding)\n@@ -109,3 +117,14 @@\n-        this(privEncoding);\n-        pubKeyEncoded = pubEncoding;\n-        version = V2;\n+        this(privateEncoding);\n+        if (publicEncoding != null) {\n+            if (pubKeyEncoded != null) {\n+                if (!Arrays.equals(pubKeyEncoded, publicEncoding)) {\n+                    Arrays.fill(privKeyMaterial, (byte) 0x0);\n+                    throw new InvalidKeyException(\"PrivateKey \" +\n+                        \"encoding has a public key that does not match \" +\n+                        \"the given PublicKey\");\n+                }\n+            } else {\n+                pubKeyEncoded = publicEncoding;\n+                version = V2;\n+            }\n+        }\n@@ -140,0 +159,8 @@\n+            \/\/ Special check and parsing for ECDSA's SEC1v2 format\n+            if (algid.getOID().equals(AlgorithmId.EC_oid)) {\n+                var bits = ECPrivateKeyImpl.parsePublicBits(privKeyMaterial);\n+                if (bits != null) {\n+                    pubKeyEncoded = new X509Key(algid, bits).getEncoded();\n+                }\n+            }\n+\n@@ -274,1 +301,1 @@\n-     * @param pubKeyEncoded DER-encoded PublicKey\n+     * @param pubKeyEncoded DER-encoded PublicKey, this may be null.\n@@ -281,0 +308,1 @@\n+        PKCS8Key pkcs8Key;\n@@ -282,2 +310,1 @@\n-            return new PKCS8Key(privKeyEncoded, pubKeyEncoded).\n-                generateEncoding();\n+            pkcs8Key = new PKCS8Key(pubKeyEncoded, privKeyEncoded);\n@@ -287,0 +314,3 @@\n+        byte[] result = pkcs8Key.generateEncoding().clone();\n+        pkcs8Key.clear();\n+        return result;\n@@ -329,1 +359,0 @@\n-                \/\/ X509Key x = X509Key.parse(pubKeyEncoded);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS8Key.java","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.security.PEMRecord;\n+import java.security.PEM;\n@@ -562,1 +562,1 @@\n-                PEMRecord rec;\n+                PEM rec;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.pkcs.PKCS8Key;\n@@ -30,0 +32,3 @@\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n@@ -32,3 +37,4 @@\n-import java.security.NoSuchAlgorithmException;\n-import java.security.PEMRecord;\n-import java.security.Security;\n+import java.security.*;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n@@ -162,1 +168,1 @@\n-    public static PEMRecord readPEM(InputStream is, boolean shortHeader)\n+    public static PEM readPEM(InputStream is, boolean shortHeader)\n@@ -314,1 +320,1 @@\n-        return new PEMRecord(typeConverter(headerType), data, preData);\n+        return new PEM(typeConverter(headerType), data, preData);\n@@ -317,1 +323,1 @@\n-    public static PEMRecord readPEM(InputStream is) throws IOException {\n+    public static PEM readPEM(InputStream is) throws IOException {\n@@ -345,1 +351,1 @@\n-    public static String pemEncoded(PEMRecord pem) {\n+    public static String pemEncoded(PEM pem) {\n@@ -349,0 +355,106 @@\n+\n+    \/*\n+     * Get PKCS8 encoding from an encrypted private key encoding.\n+     *\/\n+    public static byte[] decryptEncoding(byte[] encoded, char[] password)\n+        throws GeneralSecurityException {\n+        EncryptedPrivateKeyInfo ekpi;\n+\n+        Objects.requireNonNull(password, \"password cannot be null\");\n+        try {\n+            ekpi = new EncryptedPrivateKeyInfo(encoded);\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+        return decryptEncoding(ekpi, password);\n+    }\n+\n+    public static byte[] decryptEncoding(EncryptedPrivateKeyInfo ekpi, char[] password)\n+        throws GeneralSecurityException {\n+\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        SecretKeyFactory skf = SecretKeyFactory.getInstance(ekpi.getAlgName());\n+        PKCS8EncodedKeySpec p8KeySpec =\n+            ekpi.getKeySpec(skf.generateSecret(keySpec));\n+        byte[] result = p8KeySpec.getEncoded();\n+            SharedSecrets.getJavaSecuritySpecAccess().\n+                clearEncodedKeySpec(p8KeySpec);\n+            keySpec.clearPassword();\n+        return result;\n+    }\n+\n+\n+    \/**\n+     * With a given PKCS8 encoding, construct a PrivateKey or KeyPair.  A\n+     * KeyPair is returned if requested and the encoding has a public key;\n+     * otherwise, a PrivateKey is returned.\n+     *\n+     * @param encoded PKCS8 encoding\n+     * @param pair set to true for returning a KeyPair, if possible. Otherwise,\n+     *             return a PrivateKey\n+     * @param provider KeyFactory provider\n+     *\/\n+    public static DEREncodable toDEREncodable(byte[] encoded, boolean pair,\n+        Provider provider) throws InvalidKeyException {\n+\n+        PrivateKey privKey;\n+        PublicKey pubKey = null;\n+        PKCS8EncodedKeySpec p8KeySpec;\n+        PKCS8Key p8key = new PKCS8Key(encoded);\n+        KeyFactory kf;\n+\n+        try {\n+            p8KeySpec = new PKCS8EncodedKeySpec(encoded);\n+        } catch (NullPointerException e) {\n+            throw new InvalidKeyException(\"No encoding found\", e);\n+        }\n+\n+        try {\n+            if (provider == null) {\n+                kf = KeyFactory.getInstance(p8key.getAlgorithm());\n+            } else {\n+                kf = KeyFactory.getInstance(p8key.getAlgorithm(), provider);\n+            }\n+        } catch (NoSuchAlgorithmException e) {\n+            p8key.clear();\n+            SharedSecrets.getJavaSecuritySpecAccess().\n+                clearEncodedKeySpec(p8KeySpec);\n+            throw new InvalidKeyException(\"Unable to find the algorithm: \" +\n+                p8key.getAlgorithm(), e);\n+        }\n+\n+        try {\n+            privKey = kf.generatePrivate(p8KeySpec);\n+\n+            \/\/ Only want the PrivateKey? then return it.\n+            if (!pair) {\n+                return privKey;\n+            }\n+\n+            if (p8key.hasPublicKey()) {\n+                \/\/ PKCS8Key.decode() has extracted the public key already\n+                pubKey = kf.generatePublic(\n+                    new X509EncodedKeySpec(p8key.getPubKeyEncoded()));\n+            } else {\n+                \/\/ In case decode() could not read the public key, the\n+                \/\/ KeyFactory can try.  Failure is ok as there may not\n+                \/\/ be a public key in the encoding.\n+                try {\n+                    pubKey = kf.generatePublic(p8KeySpec);\n+                } catch (InvalidKeySpecException e) {\n+                    \/\/ ignore\n+                }\n+            }\n+        } catch (InvalidKeySpecException e) {\n+            throw new InvalidKeyException(e);\n+        } finally {\n+            p8key.clear();\n+            SharedSecrets.getJavaSecuritySpecAccess().\n+                clearEncodedKeySpec(p8KeySpec);\n+        }\n+        if (pair && pubKey != null) {\n+            return new KeyPair(pubKey, privKey);\n+        }\n+        return privKey;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":119,"deletions":7,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.security.PEMRecord;\n+import java.security.PEM;\n@@ -51,0 +51,10 @@\n+    public static final Entry ecsecp256dom0 = new Entry(\"ecsecp256dom0\",\n+        \"\"\"\n+        -----BEGIN PRIVATE KEY-----\n+        MIGTAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBHkwdwIBAQQgkW3Jx561NlEgBnut\n+        KwDdi3cNwu7YYD\/QtJ+9+AEBdoqgCgYIKoZIzj0DAQehRANCAASL+REY4vvAI9M3\n+        gonaml5K3lRgHq5w+OO4oO0VNduC44gUN1nrk7\/wdNSpL+xXNEX52Dsff+2RD\/fo\n+        p224ANvB\n+        -----END PRIVATE KEY-----\n+        \"\"\", KeyPair.class, \"SunEC\");\n+\n@@ -152,1 +162,1 @@\n-    public static final Entry ec25519priv = new Entry(\"ed25519priv\",\n+    public static final Entry ed25519priv = new Entry(\"ed25519priv\",\n@@ -192,0 +202,1 @@\n+    \/\/ This is the public key contained in ecsecp256\n@@ -289,0 +300,13 @@\n+    static final Entry ecsecp256ekpi = new Entry(\"ecsecp256ekpi\",\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIH0MF8GCSqGSIb3DQEFDTBSMDEGCSqGSIb3DQEFDDAkBBDhqUj1Oadj1GZXUMXT\n+        b3QEAgIIADAMBggqhkiG9w0CCQUAMB0GCWCGSAFlAwQBAgQQitxCfcZcMtoNu+X+\n+        PQk+\/wSBkFL1NddKkUL2tRv6pNf1TR7eI7qJReGRgJexU\/6pDN+UQS5e5qSySa7E\n+        k1m2pUHgZlySUblXZj9nOzCsNFfq\/jxlL15ZpAviAM2fRINnNEJcvoB+qZTS5cRb\n+        Xs3wC7wymHW3EdIZ9sxfSHq9t7j9SnC1jGHjno0v1rKcdIvJtYloxsRYjsG\/Sxhz\n+        uNYnx8AMuQ==\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\", EncryptedPrivateKeyInfo.class, \"SunEC\", \"fish\".toCharArray());\n+\n+\n@@ -453,1 +477,1 @@\n-        \"\"\", PEMRecord.class, \"SunEC\");\n+        \"\"\", PEM.class, \"SunEC\");\n@@ -474,1 +498,1 @@\n-        \"\"\" + postData, PEMRecord.class, \"SunEC\");\n+        \"\"\" + postData, PEM.class, \"SunEC\");\n@@ -567,0 +591,1 @@\n+        privList.add(ecsecp256dom0);\n@@ -568,1 +593,1 @@\n-        privList.add(ec25519priv);\n+        privList.add(ed25519priv);\n","filename":"test\/jdk\/java\/security\/PEM\/PEMData.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -114,2 +114,2 @@\n-        DEREncodable result = PEMDecoder.of().decode(PEMData.ecCSRWithData.pem(), PEMRecord.class);\n-        if (result instanceof PEMRecord rec) {\n+        DEREncodable result = PEMDecoder.of().decode(PEMData.ecCSRWithData.pem(), PEM.class);\n+        if (result instanceof PEM rec) {\n@@ -131,2 +131,2 @@\n-        result = PEMDecoder.of().decode(PEMData.rsapub.pem(), PEMRecord.class);\n-        if (!(result instanceof PEMRecord)) {\n+        result = PEMDecoder.of().decode(PEMData.rsapub.pem(), PEM.class);\n+        if (!(result instanceof PEM)) {\n@@ -135,1 +135,1 @@\n-        if (((PEMRecord) result).type().compareTo(Pem.PUBLIC_KEY) != 0) {\n+        if (((PEM) result).type().compareTo(Pem.PUBLIC_KEY) != 0) {\n@@ -142,1 +142,1 @@\n-        testPEMRecord(PEMData.ec25519priv);\n+        testPEMRecord(PEMData.ed25519priv);\n@@ -147,1 +147,1 @@\n-        testPEMRecordDecode(PEMData.ec25519priv);\n+        testPEMRecordDecode(PEMData.ed25519priv);\n@@ -153,2 +153,2 @@\n-        String s = new PEMRecord(\"ONE\", \"1212\").toString()\n-            + new PEMRecord(\"TWO\", \"3434\").toString();\n+        String s = new PEM(\"ONE\", \"1212\").toString()\n+            + new PEM(\"TWO\", \"3434\").toString();\n@@ -156,1 +156,1 @@\n-        if (d.decode(ins, PEMRecord.class).leadingData() != null) {\n+        if (d.decode(ins, PEM.class).leadingData() != null) {\n@@ -159,1 +159,1 @@\n-        if (d.decode(ins, PEMRecord.class).leadingData() != null) {\n+        if (d.decode(ins, PEM.class).leadingData() != null) {\n@@ -176,2 +176,2 @@\n-        System.out.println(\"EncryptedPrivateKeyInfo.encryptKey with PBE: \");\n-        ekpi = EncryptedPrivateKeyInfo.encryptKey(privateKey,\n+        System.out.println(\"EncryptedPrivateKeyInfo.encrypt with PBE: \");\n+        ekpi = EncryptedPrivateKeyInfo.encrypt(privateKey,\n@@ -187,2 +187,2 @@\n-        System.out.println(\"EncryptedPrivateKeyInfo.encryptKey with default: \");\n-        ekpi = EncryptedPrivateKeyInfo.encryptKey(privateKey\n+        System.out.println(\"EncryptedPrivateKeyInfo.encrypt with default: \");\n+        ekpi = EncryptedPrivateKeyInfo.encrypt(privateKey\n@@ -214,1 +214,1 @@\n-        PEMRecord obj;\n+        PEM obj;\n@@ -217,1 +217,1 @@\n-            obj = PEMDecoder.of().decode(is, PEMRecord.class);\n+            obj = PEMDecoder.of().decode(is, PEM.class);\n@@ -228,1 +228,1 @@\n-            PEMDecoder.of().decode(is, PEMRecord.class);\n+            PEMDecoder.of().decode(is, PEM.class);\n@@ -237,1 +237,1 @@\n-                PEMDecoder.of().decode(is, PEMRecord.class));\n+                PEMDecoder.of().decode(is, PEM.class));\n@@ -268,1 +268,1 @@\n-        PEMRecord r = PEMDecoder.of().decode(entry.pem(), PEMRecord.class);\n+        PEM r = PEMDecoder.of().decode(entry.pem(), PEM.class);\n@@ -288,1 +288,1 @@\n-                entry.clazz().isAssignableFrom(PEMRecord.class);\n+                entry.clazz().isAssignableFrom(PEM.class);\n@@ -303,1 +303,1 @@\n-        PEMRecord r = PEMDecoder.of().decode(entry.pem(), PEMRecord.class);\n+        PEM r = PEMDecoder.of().decode(entry.pem(), PEM.class);\n@@ -314,1 +314,1 @@\n-            case \"CERTIFICATE REQUEST\" -> (de instanceof PEMRecord);\n+            case \"CERTIFICATE REQUEST\" -> (de instanceof PEM);\n","filename":"test\/jdk\/java\/security\/PEM\/PEMDecoderTest.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        keymap.keySet().stream().forEach(key -> test(key, encoder));\n+        keymap.keySet().forEach(key -> test(key, encoder));\n@@ -75,1 +75,1 @@\n-        keymap.keySet().stream().forEach(key -> test(key, PEMEncoder.of()));\n+        keymap.keySet().forEach(key -> test(key, PEMEncoder.of()));\n@@ -77,1 +77,1 @@\n-        keymap.keySet().stream().forEach(key -> testToString(key, encoder));\n+        keymap.keySet().forEach(key -> testToString(key, encoder));\n@@ -79,1 +79,1 @@\n-        keymap.keySet().stream().forEach(key -> testToString(key,\n+        keymap.keySet().forEach(key -> testToString(key,\n@@ -89,1 +89,1 @@\n-        keymap.keySet().stream().forEach(key -> testEncryptedMatch(key, encoder));\n+        keymap.keySet().forEach(key -> testEncryptedMatch(key, encoder));\n@@ -91,1 +91,1 @@\n-        keymap.keySet().stream().forEach(key -> testEncrypted(key, encoder));\n+        keymap.keySet().forEach(key -> testEncrypted(key, encoder));\n@@ -93,1 +93,1 @@\n-        keymap.keySet().stream().forEach(key -> testEncrypted(key, PEMEncoder.of()));\n+        keymap.keySet().forEach(key -> testEncrypted(key, PEMEncoder.of()));\n@@ -96,1 +96,1 @@\n-        keymap.keySet().stream().forEach(key -> testSameEncryptor(key, encEncoder));\n+        keymap.keySet().forEach(key -> testSameEncryptor(key, encEncoder));\n@@ -106,3 +106,3 @@\n-        PEMRecord pemRecord =\n-            d.decode(PEMData.ed25519ep8.pem(), PEMRecord.class);\n-        PEMData.checkResults(PEMData.ed25519ep8, pemRecord.toString());\n+        PEM pem =\n+            d.decode(PEMData.ed25519ep8.pem(), PEM.class);\n+        PEMData.checkResults(PEMData.ed25519ep8, pem.toString());\n@@ -110,1 +110,1 @@\n-        \/\/ test PemRecord is encapsulated with PEM header and footer on encoding\n+        \/\/ test PEM is encapsulated with PEM header and footer on encoding\n@@ -113,1 +113,1 @@\n-        PEMRecord pemR = new PEMRecord(\"ENCRYPTED PRIVATE KEY\", String.join(\"\\n\",\n+        PEM pemR = new PEM(\"ENCRYPTED PRIVATE KEY\", String.join(\"\\n\",\n@@ -116,0 +116,11 @@\n+\n+        \/\/ Verify the same private key bytes are returned with an ECDSA private\n+        \/\/ key PEM and an encrypted PEM.\n+        KeyPair kp = d.decode(PEMData.ecsecp256.pem(), KeyPair.class);\n+        var origPriv = kp.getPrivate();\n+        String s = encoder.withEncryption(PEMData.ecsecp256ekpi.password()).encodeToString(kp);\n+        kp = d.withDecryption(PEMData.ecsecp256ekpi.password()).decode(s, KeyPair.class);\n+        var newPriv = kp.getPrivate();\n+        if (!Arrays.equals(origPriv.getEncoded(), newPriv.getEncoded())) {\n+            throw new AssertionError(\"compare fails\");\n+        }\n@@ -218,1 +229,1 @@\n-                EncryptedPrivateKeyInfo.encryptKey(pkey, entry.password(),\n+                EncryptedPrivateKeyInfo.encrypt(pkey, entry.password(),\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ * @bug 8298420\n+ * @summary Testing encryptKey\n+ * @enablePreview\n+ *\/\n+\n+import sun.security.util.Pem;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.AlgorithmParameters;\n+import java.security.PEMDecoder;\n+import java.security.PrivateKey;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.Security;\n+import java.util.Arrays;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+public class Encrypt {\n+\n+    private static final String encEdECKey =\n+        \"\"\"\n+        -----BEGIN ENCRYPTED PRIVATE KEY-----\n+        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n+        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n+        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n+        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n+        -----END ENCRYPTED PRIVATE KEY-----\n+        \"\"\";\n+    private static final String passwdText = \"fish\";\n+    private static final char[] password = passwdText.toCharArray();\n+    private static final SecretKey key = new SecretKeySpec(\n+        passwdText.getBytes(), \"PBE\");\n+\n+    public static void main(String[] args) throws Exception {\n+        Provider p = Security.getProvider(System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+\n+        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(encEdECKey,\n+            EncryptedPrivateKeyInfo.class);\n+        PrivateKey priKey = PEMDecoder.of().withDecryption(password).\n+            decode(encEdECKey, PrivateKey.class);\n+        AlgorithmParameters ap = ekpi.getAlgParameters();\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ... )\n+        var e = EncryptedPrivateKeyInfo.encrypt(priKey, password,\n+            ekpi.getAlgName(), ap.getParameterSpec(PBEParameterSpec.class),\n+            null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, password, ekpi.getAlgName(),\n+                ap.getParameterSpec(PBEParameterSpec.class), p);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                    \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider and null algorithm\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, password, null, null,\n+                p);\n+        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...)\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, ekpi.getAlgName(),\n+            ap.getParameterSpec(PBEParameterSpec.class),null, null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null random\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, ekpi.getAlgName(),\n+                ap.getParameterSpec(PBEParameterSpec.class), p, null);\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                    \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and SecureRandom\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, ekpi.getAlgName(),\n+                ap.getParameterSpec(PBEParameterSpec.class), p, new SecureRandom());\n+        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n+            throw new AssertionError(\"encryptKey() didn't match\" +\n+                    \" with expected.\");\n+        }\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null algorithm\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, null, null,\n+                p, new SecureRandom());\n+        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/Encrypt.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @modules java.base\/sun.security.util\n- * @bug 8298420\n- * @summary Testing encryptKey\n- * @enablePreview\n- *\/\n-\n-import sun.security.util.Pem;\n-\n-import javax.crypto.EncryptedPrivateKeyInfo;\n-import javax.crypto.SecretKey;\n-import javax.crypto.spec.PBEParameterSpec;\n-import javax.crypto.spec.SecretKeySpec;\n-import java.security.AlgorithmParameters;\n-import java.security.PEMDecoder;\n-import java.security.PrivateKey;\n-import java.security.Provider;\n-import java.security.SecureRandom;\n-import java.security.Security;\n-import java.util.Arrays;\n-\n-import static jdk.test.lib.Asserts.assertEquals;\n-\n-public class EncryptKey {\n-\n-    private static final String encEdECKey =\n-        \"\"\"\n-        -----BEGIN ENCRYPTED PRIVATE KEY-----\n-        MIGqMGYGCSqGSIb3DQEFDTBZMDgGCSqGSIb3DQEFDDArBBRyYnoNyrcqvubzch00\n-        jyuAb5YizgICEAACARAwDAYIKoZIhvcNAgkFADAdBglghkgBZQMEAQIEEM8BgEgO\n-        vdMyi46+Dw7cOjwEQLtx5ME0NOOo7vlCGm3H\/4j+Tf5UXrMb1UrkPjqc8OiLbC0n\n-        IycFtI70ciPjgwDSjtCcPxR8fSxJPrm2yOJsRVo=\n-        -----END ENCRYPTED PRIVATE KEY-----\n-        \"\"\";\n-    private static final String passwdText = \"fish\";\n-    private static final char[] password = passwdText.toCharArray();\n-    private static final SecretKey key = new SecretKeySpec(\n-        passwdText.getBytes(), \"PBE\");\n-\n-    public static void main(String[] args) throws Exception {\n-        Provider p = Security.getProvider(System.getProperty(\"test.provider.name\", \"SunJCE\"));\n-\n-        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(encEdECKey,\n-            EncryptedPrivateKeyInfo.class);\n-        PrivateKey priKey = PEMDecoder.of().withDecryption(password).\n-            decode(encEdECKey, PrivateKey.class);\n-        AlgorithmParameters ap = ekpi.getAlgParameters();\n-\n-        \/\/ Test encryptKey(PrivateKey, char[], String, ... )\n-        var e = EncryptedPrivateKeyInfo.encryptKey(priKey, password,\n-            ekpi.getAlgName(), ap.getParameterSpec(PBEParameterSpec.class),\n-            null);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, password, ekpi.getAlgName(),\n-                ap.getParameterSpec(PBEParameterSpec.class), p);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                    \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, char[], String, ...) with provider and null algorithm\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, password, null, null,\n-                p);\n-        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...)\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n-            ap.getParameterSpec(PBEParameterSpec.class),null, null);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null random\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n-                ap.getParameterSpec(PBEParameterSpec.class), p, null);\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                    \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and SecureRandom\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, ekpi.getAlgName(),\n-                ap.getParameterSpec(PBEParameterSpec.class), p, new SecureRandom());\n-        if (!Arrays.equals(ekpi.getEncryptedData(), e.getEncryptedData())) {\n-            throw new AssertionError(\"encryptKey() didn't match\" +\n-                    \" with expected.\");\n-        }\n-\n-        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and null algorithm\n-        e = EncryptedPrivateKeyInfo.encryptKey(priKey, key, null, null,\n-                p, new SecureRandom());\n-        assertEquals(e.getAlgName(), Pem.DEFAULT_ALGO);\n-    }\n-}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/EncryptKey.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -74,1 +74,2 @@\n-        Provider p = Security.getProvider(System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+        Provider p = Security.getProvider(\n+            System.getProperty(\"test.provider.name\", \"SunJCE\"));\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetKey.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8360563\n+ * @library \/test\/lib\n+ * @summary Testing getKeyPair using ML-KEM\n+ * @enablePreview\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+\n+import javax.crypto.EncryptedPrivateKeyInfo;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.*;\n+\n+\/*\n+ * This generates an ML-KEM key pair and makes it into PEM data.  By using\n+ * PEM, it constructs a OneAsymmetricKey structure that combines\n+ * the public key into the private key encoding.  Decode the PEM data into\n+ * a KeyPair and an EKPI for verification.\n+ *\n+ * The original private key does not have the public key encapsulated, so it\n+ * cannot be used for verification.\n+ *\n+ * Verify the decoded PEM KeyPair and EKPI.getKeyPair() return matching public\n+ * and private keys encodings; as well as, verify the original public key\n+ * matches.\n+ *\/\n+\n+public class GetKeyPair {\n+    private static final String passwdText = \"fish\";\n+    private static final char[] password = passwdText.toCharArray();\n+    private static final SecretKey key = new SecretKeySpec(\n+        passwdText.getBytes(), \"PBE\");\n+\n+    public static void main(String[] args) throws Exception {\n+        Provider p = Security.getProvider(\n+            System.getProperty(\"test.provider.name\", \"SunJCE\"));\n+\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"ML-KEM\");\n+        KeyPair kpOrig = kpg.generateKeyPair();\n+        \/\/ Generate the PEM, constructing a OneAsymmetricKey (OAS) encoding\n+        String pem = PEMEncoder.of().withEncryption(password).\n+            encodeToString(kpOrig);\n+        \/\/ Extracted the KeyPair from the generated PEM for verification.\n+        KeyPair mlkemKP = PEMDecoder.of().withDecryption(password).\n+            decode(pem, KeyPair.class);\n+        \/\/ Extract the EncryptedPrivateKeyInfo.\n+        EncryptedPrivateKeyInfo ekpi = PEMDecoder.of().decode(pem,\n+            EncryptedPrivateKeyInfo.class);\n+\n+        KeyPairs kps = new KeyPairs(kpOrig, mlkemKP);\n+\n+        \/\/ Test getKey(password)\n+        System.out.println(\"Testing getKeyPair(char[]) \");\n+        KeyPair kp = ekpi.getKeyPair(password);\n+        arrayCheck(kps, kp);\n+\n+        \/\/ Test getKey(key, provider) provider null\n+        System.out.println(\"Testing getKeyPair(key, null)\");\n+        kp = ekpi.getKeyPair(key, null);\n+        arrayCheck(kps, kp);\n+\n+        \/\/ Test getKey(key, provider) provider SunJCE\n+        System.out.println(\"Testing getKeyPair(key, SunJCE)\");\n+        kp = ekpi.getKeyPair(key, p);\n+        arrayCheck(kps, kp);\n+    }\n+\n+    static void arrayCheck(KeyPairs kps, KeyPair actual) {\n+        byte[] actualPrivEncoding = actual.getPrivate().getEncoded();\n+        byte[] actualPubEncoding = actual.getPublic().getEncoded();\n+        Asserts.assertEqualsByteArray(kps.mlkemPrivEncoding, actualPrivEncoding,\n+            \"PrivateKey didn't match with expected.\");\n+        Asserts.assertEqualsByteArray(kps.mlkemPubEncoding, actualPubEncoding,\n+            \"PublicKey didn't match with decoded.\");\n+        Asserts.assertEqualsByteArray(kps.origPubEncoding, actualPubEncoding,\n+            \"PublicKey didn't match with decoded.\");\n+        System.out.println(\"Got KeyPair:  Pass\");\n+    }\n+\n+    record KeyPairs(byte[] origPubEncoding, byte[] mlkemPrivEncoding,\n+                    byte[] mlkemPubEncoding) {\n+         KeyPairs(KeyPair orig, KeyPair mlkem) {\n+             this(orig.getPublic().getEncoded(),\n+                 mlkem.getPrivate().getEncoded(),\n+                 mlkem.getPublic().getEncoded());\n+         }\n+    };\n+}\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetKeyPair.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}