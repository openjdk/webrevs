{"files":[{"patch":"@@ -38,1 +38,1 @@\n- * Mail (PEM) data by its type and Base64 content.\n+ * Mail (PEM) data by its type and Base64-encoded content.\n@@ -43,1 +43,1 @@\n- * If you need access to the leading data of a PEM text, or if you want to\n+ * If you need access to the leading data of a PEM text, or want to\n@@ -46,1 +46,1 @@\n- * {@link PEMDecoder#decode(InputStream, Class)} with {@code PEM.class} as a\n+ * {@link PEMDecoder#decode(InputStream, Class)} with {@code PEM.class} as an\n@@ -50,1 +50,1 @@\n- * {@link #toString()} or using the encode methods in {@link PEMEncoder}.\n+ * {@link #toString()} or by using the encode methods in {@link PEMEncoder}.\n@@ -57,1 +57,1 @@\n- * {@code content} is valid Base64, or that {@code content} matches the\n+ * {@code content} is valid Base64 data, or that {@code content} matches the\n@@ -62,1 +62,1 @@\n- * CMS, PRIVATE KEY, ENCRYPTED PRIVATE KEY, RSA PRIVATE KEY, or PUBLIC KEY.\n+ * CMS, PRIVATE KEY, ENCRYPTED PRIVATE KEY, and PUBLIC KEY.\n@@ -66,1 +66,1 @@\n- * metadata that accompanies the PEM data. This value was not defensively\n+ * metadata that accompanies the PEM data. This value is not defensively\n@@ -75,1 +75,1 @@\n- *                   decoding.  This value may be {@code null}.\n+ *                    decoding.  This value may be {@code null}.\n@@ -93,2 +93,1 @@\n-     * @param content the Base64-encoded data, excluding the PEM header and\n-     *               footer\n+     * @param content the Base64-encoded data, excluding the PEM header and footer\n@@ -96,5 +95,3 @@\n-     *                    before the PEM header.  This value may be {@code null}\n-     * @throws IllegalArgumentException if {@code type} is incorrectly\n-     * formatted\n-     * @throws NullPointerException if {@code type} or {@code content} is\n-     * {@code null}\n+     *                    before the PEM header.  This value may be {@code null}.\n+     * @throws IllegalArgumentException if {@code type} is incorrectly formatted\n+     * @throws NullPointerException if {@code type} or {@code content} is {@code null}\n@@ -110,2 +107,2 @@\n-            throw new IllegalArgumentException(\"PEM syntax labels found.  \" +\n-                \"Only the PEM type identifier is allowed\");\n+            throw new IllegalArgumentException(\"PEM syntax labels found. \" +\n+                \"Only the PEM type identifier is allowed.\");\n@@ -120,6 +117,3 @@\n-     * @param content the Base64-encoded data, excluding the PEM header and\n-     *               footer\n-     * @throws IllegalArgumentException if {@code type} is incorrectly\n-     * formatted\n-     * @throws NullPointerException if {@code type} or {@code content} is\n-     * {@code null}\n+     * @param content the Base64-encoded data, excluding the PEM header and footer\n+     * @throws IllegalArgumentException if {@code type} is incorrectly formatted\n+     * @throws NullPointerException if {@code type} or {@code content} is {@code null}\n@@ -146,2 +140,2 @@\n-     * @return a new decoded byte array of {@code content}\n-     * @throws IllegalArgumentException on a decoding fails\n+     * @return a decoded byte array\n+     * @throws IllegalArgumentException if decoding fails\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEM.java","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.ref.CleanerFactory;\n@@ -38,0 +39,1 @@\n+import java.lang.ref.Reference;\n@@ -41,1 +43,0 @@\n-import java.util.Arrays;\n@@ -47,1 +48,1 @@\n- * PEM is a textual encoding used to store and transfer security\n+ * PEM is a textual encoding used to store and transfer cryptographic\n@@ -50,1 +51,1 @@\n- * Base64-formatted binary encoding enclosed by a type-identifying header\n+ * Base64-encoded binary encoding enclosed by a type-identifying header\n@@ -58,1 +59,1 @@\n- * types that each are decoded as:\n+ * they decode as:\n@@ -61,3 +62,0 @@\n- *  <li>X509 CERTIFICATE : {@code X509Certificate}<\/li>\n- *  <li>X.509 CERTIFICATE : {@code X509Certificate}<\/li>\n- *  <li>CRL : {@code X509CRL}<\/li>\n@@ -66,1 +64,1 @@\n- *  <li>PUBLIC KEY : {@code X509EncodedKeySpec} (When passed as a {@code Class}\n+ *  <li>PUBLIC KEY : {@code X509EncodedKeySpec} (when passed as a {@code Class}\n@@ -69,1 +67,1 @@\n- *  <li>PRIVATE KEY : {@code PKCS8EncodedKeySpec} (When passed as a {@code Class}\n+ *  <li>PRIVATE KEY : {@code PKCS8EncodedKeySpec} (when passed as a {@code Class}\n@@ -71,1 +69,1 @@\n- *  <li>PRIVATE KEY : {@code PublicKey} (If the encoding contains a public key\n+ *  <li>PRIVATE KEY : {@code PublicKey} (if the encoding contains a public key\n@@ -73,1 +71,1 @@\n- *  <li>PRIVATE KEY : {@code KeyPair} (If the encoding contains a public key)\n+ *  <li>PRIVATE KEY : {@code KeyPair} (if the encoding contains a public key)\n@@ -76,1 +74,1 @@\n- *  <li>ENCRYPTED PRIVATE KEY : {@code PrivateKey} (If configured with\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PrivateKey} (if configured with\n@@ -78,1 +76,1 @@\n- *  <li>ENCRYPTED PRIVATE KEY : {@code KeyPair} (If configured with decryption)\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code KeyPair} (if configured with decryption)\n@@ -80,1 +78,1 @@\n- *  <li>ENCRYPTED PRIVATE KEY : {@code PKCS8EncodedKeySpec} (If configured with\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PKCS8EncodedKeySpec} (if configured with\n@@ -82,1 +80,1 @@\n- *  <li>ENCRYPTED PRIVATE KEY : {@code PublicKey} (If configured with\n+ *  <li>ENCRYPTED PRIVATE KEY : {@code PublicKey} (if configured with\n@@ -90,1 +88,1 @@\n- * {@code ECPublicKey} and {@code ECPrivateKey} for Elliptic Curve keys.\n+ * {@code ECPublicKey} or an {@code ECPrivateKey} for Elliptic Curve keys.\n@@ -97,1 +95,1 @@\n- * {@link #decode(InputStream, Class)} methods take a class parameter which\n+ * {@link #decode(InputStream, Class)} methods take a class parameter, which\n@@ -114,1 +112,1 @@\n- * {@link CertificateFactory}. The {@link #withDecryption(char[])} configures the\n+ * {@link CertificateFactory}. The {@link #withDecryption(char[])} method configures the\n@@ -119,1 +117,1 @@\n- * Decryption configured instances will decode unencrypted PEM.\n+ * A PEMDecoder configured for decryption will decode unencrypted PEM.\n@@ -136,2 +134,4 @@\n- * @implNote This implementation decodes PEM type {@code RSA PRIVATE KEY} as\n- * {@code PRIVATE KEY}. Other implementations may support additional types.\n+ * @implNote This implementation decodes {@code RSA PRIVATE KEY} as {@code PRIVATE KEY},\n+ * {@code X509 CERTIFICATE} and {@code X.509 CERTIFICATE} as {@code CERTIFICATE},\n+ * and {@code CRL} as {@code X509 CRL}. Other implementations may recognize\n+ * additional PEM types.\n@@ -156,1 +156,1 @@\n-    private final PBEKeySpec password;\n+    private final PBEKeySpec keySpec;\n@@ -168,1 +168,1 @@\n-        password = withPassword;\n+        keySpec = withPassword;\n@@ -170,0 +170,4 @@\n+        if (withPassword != null) {\n+            final var k = this.keySpec;\n+            CleanerFactory.cleaner().register(this, k::clearPassword);\n+        }\n@@ -199,5 +203,11 @@\n-                    PKCS8Key p8key = new PKCS8Key(decoder.decode(pem.content()));\n-                    String algo = p8key.getAlgorithm();\n-                    KeyFactory kf = getKeyFactory(algo);\n-                    DEREncodable d = kf.generatePrivate(\n-                        new PKCS8EncodedKeySpec(p8key.getEncoded(), algo));\n+                    DEREncodable d;\n+                    PKCS8Key p8key = null;\n+                    PKCS8EncodedKeySpec p8spec = null;\n+                    byte[] encoding = decoder.decode(pem.content());\n+\n+                    try {\n+                        p8key = new PKCS8Key(encoding);\n+                        String algo = p8key.getAlgorithm();\n+                        KeyFactory kf = getKeyFactory(algo);\n+                        p8spec = new PKCS8EncodedKeySpec(encoding, algo);\n+                        d = kf.generatePrivate(p8spec);\n@@ -205,7 +215,7 @@\n-                    \/\/ Look for a public key inside the pkcs8 encoding.\n-                    if (p8key.getPubKeyEncoded() != null) {\n-                        \/\/ Check if this is a OneAsymmetricKey encoding\n-                        X509EncodedKeySpec spec = new X509EncodedKeySpec(\n-                            p8key.getPubKeyEncoded(), algo);\n-                        yield new KeyPair(getKeyFactory(algo).\n-                            generatePublic(spec), (PrivateKey) d);\n+                        \/\/ Look for a public key inside the pkcs8 encoding.\n+                        if (p8key.getPubKeyEncoded() != null) {\n+                            \/\/ Check if this is a OneAsymmetricKey encoding\n+                            X509EncodedKeySpec spec = new X509EncodedKeySpec(\n+                                p8key.getPubKeyEncoded(), algo);\n+                            yield new KeyPair(getKeyFactory(algo).\n+                                generatePublic(spec), (PrivateKey) d);\n@@ -213,11 +223,14 @@\n-                    } else if (d instanceof PKCS8Key p8 &&\n-                        p8.getPubKeyEncoded() != null) {\n-                        \/\/ If the KeyFactory decoded an algorithm-specific\n-                        \/\/ encodings, look for the public key again.\n-                        X509EncodedKeySpec spec = new X509EncodedKeySpec(\n-                            p8.getPubKeyEncoded(), algo);\n-                        yield new KeyPair(getKeyFactory(algo).\n-                            generatePublic(spec), p8);\n-                    } else {\n-                        \/\/ No public key, return the private key.\n-                        yield d;\n+                        } else if (d instanceof PKCS8Key p8 &&\n+                            p8.getPubKeyEncoded() != null) {\n+                            \/\/ If the KeyFactory decoded an algorithm-specific\n+                            \/\/ encodings, look for the public key again.\n+                            X509EncodedKeySpec spec = new X509EncodedKeySpec(\n+                                p8.getPubKeyEncoded(), algo);\n+                            yield new KeyPair(getKeyFactory(algo).\n+                                generatePublic(spec), (PrivateKey) d);\n+                        } else {\n+                            \/\/ No public key, return the private key.\n+                            yield d;\n+                        }\n+                    } finally {\n+                        KeyUtil.clear(encoding, p8spec, p8key);\n@@ -227,3 +240,13 @@\n-                    if (password == null) {\n-                        yield new EncryptedPrivateKeyInfo(decoder.decode(\n-                            pem.content()));\n+                    byte[] p8 = null;\n+                    byte[] encoding = null;\n+                    try {\n+                        encoding = decoder.decode(pem.content());\n+                        var ekpi = new EncryptedPrivateKeyInfo(encoding);\n+                        if (keySpec == null) {\n+                            yield ekpi;\n+                        }\n+                        p8 = Pem.decryptEncoding(ekpi, keySpec);\n+                        yield Pem.toDEREncodable(p8, true, factory);\n+                    } finally {\n+                        Reference.reachabilityFence(this);\n+                        KeyUtil.clear(encoding, p8);\n@@ -231,5 +254,0 @@\n-                    byte[] p8 = Pem.decryptEncoding(\n-                        decoder.decode(pem.content()), password.getPassword());\n-                    DEREncodable d = Pem.toDEREncodable(p8, true, factory);\n-                    Arrays.fill(p8, (byte)0x0);\n-                    yield d;\n@@ -280,2 +298,1 @@\n-     * @throws IllegalArgumentException on error in decoding or no PEM data\n-     * found\n+     * @throws IllegalArgumentException on error in decoding or no PEM data found\n@@ -310,1 +327,1 @@\n-     * of the DEREncodable object.\n+     * of the {@code DEREncodable} object.\n@@ -312,2 +329,1 @@\n-     * <p> If no PEM data is found, an {@code IllegalArgumentException} is\n-     * thrown.\n+     * <p> If no PEM data is found, an {@code EOFException} is thrown.\n@@ -351,1 +367,1 @@\n-     * {@code DEREncodable}\n+     *   {@code DEREncodable}\n@@ -353,2 +369,1 @@\n-     * @throws IllegalArgumentException on error in decoding or no PEM data\n-     * found\n+     * @throws IllegalArgumentException on error in decoding or no PEM data found\n@@ -386,2 +401,1 @@\n-     * <p> If no PEM data is found, an {@code IllegalArgumentException} is\n-     * thrown.\n+     * <p> If no PEM data is found, an {@code EOFException} is thrown.\n@@ -499,1 +513,1 @@\n-     * @return a new PEMEncoder instance configured with the {@code Provider}.\n+     * @return a new PEMDecoder instance configured with the {@code Provider}\n@@ -504,1 +518,1 @@\n-        return new PEMDecoder(provider, password);\n+        return new PEMDecoder(provider, keySpec);\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMDecoder.java","additions":80,"deletions":66,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import sun.security.util.KeyUtil;\n@@ -40,1 +41,0 @@\n-import java.util.Arrays;\n@@ -42,1 +42,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -49,1 +48,1 @@\n- * Base64-formatted binary encoding enclosed by a type-identifying header\n+ * Base64-encoded binary encoding enclosed by a type-identifying header\n@@ -65,1 +64,1 @@\n- * <p> PKCS #8 2.0 defines the ASN.1 OneAsymmetricKey structure, which may\n+ * <p> PKCS #8 v2.0 defines the ASN.1 OneAsymmetricKey structure, which may\n@@ -77,2 +76,1 @@\n- * the PEM types they encoded as:\n- *\n+ * the PEM types they encode as:\n@@ -89,1 +87,1 @@\n- *  ENCRYPTED PRIVATE KEY if configured with encryption)<\/li>\n+ *  ENCRYPTED PRIVATE KEY (if configured with encryption)<\/li>\n@@ -132,8 +130,2 @@\n-\n-    \/\/ Stores the password for an encrypted encoder that isn't setup yet.\n-    private PBEKeySpec keySpec;\n-    \/\/ Stores the key after the encoder is ready to encrypt.  The prevents\n-    \/\/ repeated SecretKeyFactory calls if the encoder is used on multiple keys.\n-    private SecretKey key;\n-    \/\/ Makes SecretKeyFactory generation thread-safe.\n-    private final ReentrantLock lock;\n+    \/\/ PBE key for encryption\n+    private final Key key;\n@@ -142,3 +134,1 @@\n-     * Instantiate a {@code PEMEncoder} for Encrypted Private Keys.\n-     *\n-     * @param pbe contains the password spec used for encryption.\n+     * Create an encrypted {@code PEMEncoder} instance.\n@@ -146,4 +136,14 @@\n-    private PEMEncoder(PBEKeySpec pbe) {\n-        keySpec = pbe;\n-        key = null;\n-        lock = new ReentrantLock();\n+    private PEMEncoder(PBEKeySpec keySpec) {\n+        if (keySpec != null) {\n+            try {\n+                key = SecretKeyFactory.getInstance(Pem.DEFAULT_ALGO).\n+                    generateSecret(keySpec);\n+            } catch (GeneralSecurityException e) {\n+                throw new IllegalArgumentException(\"Operation failed: \" +\n+                    \"unable to generate key or locate a valid algorithm. \" +\n+                    \"Check the jdk.epkcs8.defaultAlgorithm security \" +\n+                    \"property for a valid configuration.\", e);\n+            }\n+        } else {\n+            key = null;\n+        }\n@@ -167,2 +167,1 @@\n-     * @throws IllegalArgumentException if the {@code DEREncodable} cannot be\n-     * encoded\n+     * @throws IllegalArgumentException if the {@code DEREncodable} cannot be encoded\n@@ -176,5 +175,6 @@\n-            case PrivateKey pr -> buildKey(null, pr.getEncoded());\n-            case KeyPair kp -> {\n-                if (kp.getPublic() == null) {\n-                    throw new IllegalArgumentException(\"KeyPair does not \" +\n-                        \"contain PublicKey.\");\n+            case PrivateKey pr -> {\n+                byte[] encoding = pr.getEncoded();\n+                try {\n+                    yield buildKey(null, encoding);\n+                } finally {\n+                    KeyUtil.clear(encoding);\n@@ -182,3 +182,16 @@\n-                if (kp.getPrivate() == null) {\n-                    throw new IllegalArgumentException(\"KeyPair does not \" +\n-                        \"contain PrivateKey.\");\n+            }\n+            case KeyPair kp -> {\n+                byte[] encoding = null;\n+                try {\n+                    if (kp.getPublic() == null) {\n+                        throw new IllegalArgumentException(\"KeyPair does not \" +\n+                            \"contain PublicKey.\");\n+                    }\n+                    if (kp.getPrivate() == null) {\n+                        throw new IllegalArgumentException(\"KeyPair does not \" +\n+                            \"contain PrivateKey.\");\n+                    }\n+                    encoding = kp.getPrivate().getEncoded();\n+                    yield buildKey(kp.getPublic().getEncoded(), encoding);\n+                } finally {\n+                    KeyUtil.clear(encoding);\n@@ -186,2 +199,0 @@\n-                yield buildKey(kp.getPublic().getEncoded(),\n-                    kp.getPrivate().getEncoded());\n@@ -194,0 +205,1 @@\n+                byte[] encoding = null;\n@@ -195,2 +207,2 @@\n-                    yield Pem.pemEncoded(Pem.ENCRYPTED_PRIVATE_KEY,\n-                        epki.getEncoded());\n+                    encoding = epki.getEncoded();\n+                    yield Pem.pemEncoded(Pem.ENCRYPTED_PRIVATE_KEY, encoding);\n@@ -199,0 +211,2 @@\n+                } finally {\n+                    KeyUtil.clear(encoding);\n@@ -203,1 +217,1 @@\n-                    if (isEncrypted()) {\n+                    if (key != null) {\n@@ -214,1 +228,1 @@\n-                    if (isEncrypted()) {\n+                    if (key != null) {\n@@ -224,1 +238,1 @@\n-                if (isEncrypted()) {\n+                if (key != null) {\n@@ -242,2 +256,1 @@\n-     * @throws IllegalArgumentException if the {@code DEREncodable} cannot be\n-     * encoded\n+     * @throws IllegalArgumentException if the {@code DEREncodable} cannot be encoded\n@@ -260,6 +273,4 @@\n-     * @implNote\n-     * The default password-based encryption algorithm is defined\n-     * by the {@code jdk.epkcs8.defaultAlgorithm} security property and\n-     * uses the default encryption parameters of the provider that is selected.\n-     * To use non-default encryption parameters, or to encrypt with a different\n-     * encryption provider, use\n+     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} security property\n+     * defines the default encryption algorithm. The {@code AlgorithmParameterSpec}\n+     * defaults are determined by the provider. To use non-default encryption\n+     * parameters, or to encrypt with a different encryption provider, use\n@@ -271,1 +282,1 @@\n-     *                stored in the new instance.\n+     *                 stored in the new instance.\n@@ -274,0 +285,1 @@\n+     * @throws ProviderException if generating the encryption key fails.\n@@ -276,1 +288,0 @@\n-        \/\/ PBEKeySpec clones the password\n@@ -278,1 +289,6 @@\n-        return new PEMEncoder(new PBEKeySpec(password));\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        try {\n+            return new PEMEncoder(keySpec);\n+        } finally {\n+            keySpec.clearPassword();\n+        }\n@@ -297,23 +313,3 @@\n-        \/\/ If `keySpec` is non-null, then `key` hasn't been established.\n-        \/\/ Setting a `key` prevents repeated key generation operations.\n-        \/\/ withEncryption() is a configuration method and cannot throw an\n-        \/\/ exception; therefore generation is delayed.\n-        if (keySpec != null) {\n-            \/\/ For thread safety\n-            lock.lock();\n-            if (key == null) {\n-                try {\n-                    key = SecretKeyFactory.getInstance(Pem.DEFAULT_ALGO).\n-                        generateSecret(keySpec);\n-                    keySpec.clearPassword();\n-                    keySpec = null;\n-                } catch (GeneralSecurityException e) {\n-                    throw new IllegalArgumentException(\"Security property \" +\n-                        \"\\\"jdk.epkcs8.defaultAlgorithm\\\" may not specify a \" +\n-                        \"valid algorithm.  Operation cannot be performed.\", e);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            } else {\n-                lock.unlock();\n-            }\n+        if (privateEncoding != null && privateEncoding.length == 0) {\n+            throw new IllegalArgumentException(\"Private key has no \" +\n+                \"encoding\");\n@@ -322,27 +318,3 @@\n-        \/\/ If `key` is non-null, this is an encoder ready to encrypt.\n-        if (key != null) {\n-            if (privateEncoding == null) {\n-                throw new IllegalArgumentException(\"This DEREncodable cannot \" +\n-                    \"be encrypted.\");\n-            }\n-\n-            byte[] encoding = null;\n-            try {\n-                if (publicEncoding == null) {\n-                    encoding = privateEncoding;\n-                } else {\n-                    encoding = PKCS8Key.getEncoded(publicEncoding,\n-                        privateEncoding);\n-                    \/\/ The public key is part of the private encoding.\n-                    publicEncoding = null;\n-                }\n-                privateEncoding = EncryptedPrivateKeyInfo.encrypt(\n-                    new PKCS8EncodedKeySpec(encoding), key, null, null, null,\n-                    null).getEncoded();\n-            } catch (IOException e) {\n-                throw new IllegalArgumentException(\"Error while encoding\", e);\n-            } finally {\n-                if (encoding != null) {\n-                    Arrays.fill(encoding, (byte) 0x0);\n-                }\n-            }\n+        if (key != null && privateEncoding == null) {\n+            throw new IllegalArgumentException(\"This DEREncodable cannot \" +\n+                \"be encrypted.\");\n@@ -353,4 +325,0 @@\n-            if (publicEncoding.length == 0) {\n-                throw new IllegalArgumentException(\"No public key encoding \" +\n-                    \"given by the DEREncodable.\");\n-            }\n@@ -360,5 +328,2 @@\n-        if (privateEncoding.length == 0) {\n-            throw new IllegalArgumentException(\"No private key encoding \" +\n-                \"given by the DEREncodable.\");\n-        }\n-\n+        byte[] encoding = null;\n+        PKCS8EncodedKeySpec p8KeySpec = null;\n@@ -366,0 +331,16 @@\n+            if (publicEncoding == null) {\n+                encoding = privateEncoding;\n+            } else {\n+                encoding = PKCS8Key.getEncoded(publicEncoding,\n+                    privateEncoding);\n+            }\n+            if (key != null) {\n+                p8KeySpec = new PKCS8EncodedKeySpec(encoding);\n+                encoding = EncryptedPrivateKeyInfo.encrypt(p8KeySpec, key,\n+                    Pem.DEFAULT_ALGO, null, null, null).\n+                    getEncoded();\n+            }\n+            if (encoding.length == 0) {\n+                throw new IllegalArgumentException(\"No private key encoding \" +\n+                    \"given by the DEREncodable.\");\n+            }\n@@ -368,1 +349,3 @@\n-                privateEncoding);\n+                encoding);\n+        } catch (IOException e) {\n+            throw new IllegalArgumentException(\"Error while encoding\", e);\n@@ -370,1 +353,1 @@\n-            Arrays.fill(privateEncoding, (byte)0x0);\n+            KeyUtil.clear(encoding, p8KeySpec);\n@@ -373,4 +356,0 @@\n-\n-    private boolean isEncrypted() {\n-        return (key != null || keySpec != null);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/security\/PEMEncoder.java","additions":94,"deletions":115,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.util.Arrays;\n@@ -137,1 +136,1 @@\n-     * {@code encryptedData} are {@code null}.\n+     * {@code encryptedData} is {@code null}.\n@@ -181,1 +180,1 @@\n-     * {@code encryptedData} are {@code null}.\n+     * {@code encryptedData} is {@code null}.\n@@ -280,2 +279,1 @@\n-     * @exception NullPointerException if {@code cipher}\n-     * are {@code null}.\n+     * @exception NullPointerException if {@code cipher} is {@code null}.\n@@ -302,1 +300,1 @@\n-        throws GeneralSecurityException {\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n@@ -304,5 +302,15 @@\n-        if (provider == null) {\n-            \/\/ use the most preferred one\n-            c = Cipher.getInstance(getAlgName());\n-        } else {\n-            c = Cipher.getInstance(getAlgName(), provider);\n+        try {\n+            if (provider == null) {\n+                \/\/ use the most preferred one\n+                c = Cipher.getInstance(getAlgName());\n+            } else {\n+                c = Cipher.getInstance(getAlgName(), provider);\n+            }\n+        } catch (NoSuchPaddingException e) {\n+            throw new NoSuchAlgorithmException(e);\n+        }\n+        try {\n+            c.init(Cipher.DECRYPT_MODE, decryptKey, getAlgParameters());\n+            return c.doFinal(encryptedData);\n+        } catch (GeneralSecurityException e) {\n+            throw new InvalidKeyException(e);\n@@ -310,2 +318,0 @@\n-        c.init(Cipher.DECRYPT_MODE, decryptKey, getAlgParameters());\n-        return c.doFinal(encryptedData);\n@@ -318,0 +324,1 @@\n+        byte[] encoding = null;\n@@ -319,1 +326,2 @@\n-            return pkcs8EncodingToSpec(decryptData(decryptKey, provider));\n+            encoding = decryptData(decryptKey, provider);\n+            return pkcs8EncodingToSpec(encoding);\n@@ -326,0 +334,2 @@\n+        } finally {\n+            KeyUtil.clear(encoding);\n@@ -340,1 +350,1 @@\n-     *            {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     *           {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n@@ -343,3 +353,1 @@\n-     * @param algorithm the PBE encryption algorithm. If {@code null}, the default\n-     *                  algorithm is used. However, {@code null} is not permitted\n-     *                  when {@code params} is non-null.\n+     * @param algorithm the PBE encryption algorithm.\n@@ -352,2 +360,1 @@\n-     * @throws NullPointerException if {@code de} or {@code password} is\n-     *         {@code null}, or if {@code params} is non-null while\n+     * @throws NullPointerException if {@code de}, {@code password}, or\n@@ -358,1 +365,1 @@\n-     *         unsupported by any provider\n+     *         not supported by any provider\n@@ -361,1 +368,1 @@\n-     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} Security Property\n+     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} security property\n@@ -372,10 +379,3 @@\n-        Objects.requireNonNull(de, \"key cannot be null\");\n-        Objects.requireNonNull(password, \"password cannot be null.\");\n-        if (algorithm == null) {\n-            if (params != null) {\n-                throw new NullPointerException(\"algorithm must be specified\" +\n-                    \" if params is non-null.\");\n-            }\n-            algorithm = Pem.DEFAULT_ALGO;\n-        }\n-\n+        Objects.requireNonNull(de, \"a key must be specified.\");\n+        Objects.requireNonNull(password, \"a password must be specified.\");\n+        Objects.requireNonNull(algorithm, \"an algorithm must be specified.\");\n@@ -383,0 +383,1 @@\n+        byte[] encoding = getEncoding(de);\n@@ -384,2 +385,2 @@\n-            return encryptImpl(getEncoding(de), algorithm,\n-                generateSecretKey(password, algorithm, provider), params,\n+            return encryptImpl(encoding, algorithm,\n+                generateSecretKey(passwd, algorithm, provider), params,\n@@ -388,1 +389,1 @@\n-            Arrays.fill(passwd, (char)0x0);\n+            KeyUtil.clear(passwd, encoding);\n@@ -397,1 +398,1 @@\n-     *            {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     *           {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n@@ -407,1 +408,1 @@\n-     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} Security Property\n+     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} security property\n@@ -425,6 +426,4 @@\n-     *            {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n-     * @param encryptKey the key used to encrypt the encoding.  Must not be null\n-     * @param algorithm the password-based encryption (PBE) algorithm.\n-     *                 If {@code null}, the default algorithm is used, but\n-     *                 {@code null} is not permitted when {@code params} is\n-     *                 non-null.\n+     *           {@link PrivateKey}, {@link KeyPair}, and {@link PKCS8EncodedKeySpec}.\n+     * @param encryptKey the key used to encrypt the encoding.\n+     * @param algorithm the encryption algorithm, such as a password-based\n+     *                  encryption (PBE) algorithm.\n@@ -438,2 +437,1 @@\n-     * @throws NullPointerException if {@code de} or {@code encryptKey} is\n-     *         {@code null}, or if {@code params} is non-null while\n+     * @throws NullPointerException if {@code de}, {@code encryptKey}, or\n@@ -443,1 +441,1 @@\n-     *         {@code algorithm} or {@code params} are unsupported by any provider\n+     *         {@code algorithm} or {@code params} are not supported by any provider\n@@ -446,1 +444,1 @@\n-     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} Security Property\n+     * @implNote The {@code jdk.epkcs8.defaultAlgorithm} security property\n@@ -457,10 +455,3 @@\n-        Objects.requireNonNull(de, \"key cannot be null\");\n-        Objects.requireNonNull(encryptKey, \"an encryption key must be\" +\n-            \"specified.\");\n-        if (algorithm == null) {\n-            if (params != null) {\n-                throw new NullPointerException(\"algorithm must be specified \" +\n-                    \"if params is non-null.\");\n-            }\n-            algorithm = Pem.DEFAULT_ALGO;\n-        }\n+        Objects.requireNonNull(de, \"a key must be specified.\");\n+        Objects.requireNonNull(encryptKey, \"an encryption key must be specified.\");\n+        Objects.requireNonNull(algorithm, \"an algorithm must be specified.\");\n@@ -490,1 +481,8 @@\n-            algId = new AlgorithmId(Pem.getPBEID(algorithm), c.getParameters());\n+            try {\n+                \/\/ Use shared PEM method for very likely case the algorithm is PBE.\n+                algId = new AlgorithmId(Pem.getPBEID(algorithm), c.getParameters());\n+            } catch (IllegalArgumentException e) {\n+                \/\/ For the unlikely case a non-PBE cipher is used, get the OID.\n+                algId = new AlgorithmId(AlgorithmId.get(algorithm).getOID(),\n+                    c.getParameters());\n+            }\n@@ -501,1 +499,1 @@\n-            Arrays.fill(encoded, (byte) 0x0);\n+            KeyUtil.clear(encoded);\n@@ -522,3 +520,9 @@\n-    public PrivateKey getKey(char[] password) throws GeneralSecurityException {\n-        Objects.requireNonNull(password, \"password cannot be null\");\n-        return PKCS8Key.parseKey(Pem.decryptEncoding(this, password.clone()),null);\n+    public PrivateKey getKey(char[] password)\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n+        Objects.requireNonNull(password, \"a password must be specified.\");\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        try {\n+            return PKCS8Key.parseKey(Pem.decryptEncoding(this, keySpec), null);\n+        } finally {\n+            keySpec.clearPassword();\n+        }\n@@ -546,3 +550,9 @@\n-        throws GeneralSecurityException {\n-        Objects.requireNonNull(decryptKey,\"decryptKey cannot be null.\");\n-        return PKCS8Key.parseKey(decryptData(decryptKey, provider), null);\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n+        Objects.requireNonNull(decryptKey,\"a decryptKey must be specified.\");\n+        byte[] encoding = null;\n+        try {\n+            encoding = decryptData(decryptKey, provider);\n+            return PKCS8Key.parseKey(encoding, null);\n+        } finally {\n+            KeyUtil.clear(encoding);\n+        }\n@@ -567,2 +577,3 @@\n-    public KeyPair getKeyPair(char[] password) throws GeneralSecurityException {\n-        Objects.requireNonNull(password, \"password cannot be null\");\n+    public KeyPair getKeyPair(char[] password)\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n+        Objects.requireNonNull(password, \"a password must be specified.\");\n@@ -570,2 +581,7 @@\n-        DEREncodable d = Pem.toDEREncodable(\n-            Pem.decryptEncoding(this, password.clone()), true, null);\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n+        DEREncodable d;\n+        try {\n+            d = Pem.toDEREncodable(Pem.decryptEncoding(this, keySpec), true, null);\n+        } finally {\n+            keySpec.clearPassword();\n+        }\n@@ -575,1 +591,1 @@\n-                \"This encoding do not contain a public key.\");\n+                \"This encoding does not contain a public key.\");\n@@ -587,1 +603,1 @@\n-     * @param provider the {@code Provider} used for (@link Cipher} decryption\n+     * @param provider the {@code Provider} used for {@link Cipher} decryption\n@@ -600,2 +616,2 @@\n-        throws GeneralSecurityException {\n-        Objects.requireNonNull(decryptKey,\"decryptKey cannot be null.\");\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n+        Objects.requireNonNull(decryptKey,\"a decryptKey must be specified.\");\n@@ -608,1 +624,1 @@\n-                \"This encoding do not contain a public key.\");\n+                \"This encoding does not contain a public key.\");\n@@ -645,1 +661,1 @@\n-     * or {@code providerName} are {@code null}.\n+     * or {@code providerName} is {@code null}.\n@@ -677,1 +693,1 @@\n-     * or {@code provider} are {@code null}.\n+     * or {@code provider} is {@code null}.\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/EncryptedPrivateKeyInfo.java","additions":92,"deletions":76,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import javax.crypto.spec.PBEKeySpec;\n@@ -44,0 +45,1 @@\n+import sun.security.pkcs.PKCS8Key;\n@@ -548,1 +550,17 @@\n-\n+    \/\/ Generic method for zeroing arrays and objects\n+    public static void clear(Object... list) {\n+        for (Object o: list) {\n+            switch (o) {\n+                case byte[] b -> Arrays.fill(b, (byte)0);\n+                case char[] c -> Arrays.fill(c, (char)0);\n+                case PKCS8Key p8 -> p8.clear();\n+                case PKCS8EncodedKeySpec p8 ->\n+                    SharedSecrets.getJavaSecuritySpecAccess().clearEncodedKeySpec(p8);\n+                case PBEKeySpec pbe -> pbe.clearPassword();\n+                case null -> {}\n+                default ->\n+                    throw new IllegalArgumentException(\n+                    o.getClass().getName() + \" not defined in KeyUtil.clear()\");\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KeyUtil.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.access.SharedSecrets;\n@@ -364,0 +363,1 @@\n+        PBEKeySpec keySpec = new PBEKeySpec(password);\n@@ -366,0 +366,1 @@\n+            return decryptEncoding(ekpi, keySpec);\n@@ -368,0 +369,2 @@\n+        } finally {\n+            keySpec.clearPassword();\n@@ -369,1 +372,0 @@\n-        return decryptEncoding(ekpi, password);\n@@ -372,2 +374,2 @@\n-    public static byte[] decryptEncoding(EncryptedPrivateKeyInfo ekpi, char[] password)\n-        throws GeneralSecurityException {\n+    public static byte[] decryptEncoding(EncryptedPrivateKeyInfo ekpi, PBEKeySpec keySpec)\n+        throws NoSuchAlgorithmException, InvalidKeyException {\n@@ -375,9 +377,10 @@\n-        PBEKeySpec keySpec = new PBEKeySpec(password);\n-        SecretKeyFactory skf = SecretKeyFactory.getInstance(ekpi.getAlgName());\n-        PKCS8EncodedKeySpec p8KeySpec =\n-            ekpi.getKeySpec(skf.generateSecret(keySpec));\n-        byte[] result = p8KeySpec.getEncoded();\n-            SharedSecrets.getJavaSecuritySpecAccess().\n-                clearEncodedKeySpec(p8KeySpec);\n-            keySpec.clearPassword();\n-        return result;\n+        PKCS8EncodedKeySpec p8KeySpec = null;\n+        try {\n+            SecretKeyFactory skf = SecretKeyFactory.getInstance(ekpi.getAlgName());\n+            p8KeySpec = ekpi.getKeySpec(skf.generateSecret(keySpec));\n+            return p8KeySpec.getEncoded();\n+        } catch (InvalidKeySpecException e) {\n+            throw new InvalidKeyException(e);\n+        } finally {\n+            KeyUtil.clear(p8KeySpec);\n+        }\n@@ -409,0 +412,1 @@\n+            p8key.clear();\n@@ -419,3 +423,1 @@\n-            p8key.clear();\n-            SharedSecrets.getJavaSecuritySpecAccess().\n-                clearEncodedKeySpec(p8KeySpec);\n+            KeyUtil.clear(p8KeySpec, p8key);\n@@ -451,3 +453,1 @@\n-            p8key.clear();\n-            SharedSecrets.getJavaSecuritySpecAccess().\n-                clearEncodedKeySpec(p8KeySpec);\n+            KeyUtil.clear(p8KeySpec, p8key);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Pem.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -127,0 +127,9 @@\n+\n+        \/\/ Encoded non-encrypted Keypair\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"XDH\");\n+        kp = kpg.generateKeyPair();\n+        s = PEMEncoder.of().encodeToString(kp);\n+        DEREncodable der = d.decode(s);\n+        if (!(der instanceof KeyPair)) {\n+            throw new AssertionError(\"returned Private key instead of KeyPair\");\n+        }\n","filename":"test\/jdk\/java\/security\/PEM\/PEMEncoderTest.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-                ap.getParameterSpec(PBEParameterSpec.class), p);\n+            ap.getParameterSpec(PBEParameterSpec.class), p);\n@@ -90,1 +90,1 @@\n-                    \" with expected.\");\n+                \" with expected.\");\n@@ -94,2 +94,1 @@\n-        e = EncryptedPrivateKeyInfo.encrypt(priKey, password, null, null,\n-                p);\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, password, Pem.DEFAULT_ALGO, null, p);\n@@ -100,1 +99,1 @@\n-            ap.getParameterSpec(PBEParameterSpec.class),null, null);\n+            ap.getParameterSpec(PBEParameterSpec.class), null, null);\n@@ -108,1 +107,1 @@\n-                ap.getParameterSpec(PBEParameterSpec.class), p, null);\n+            ap.getParameterSpec(PBEParameterSpec.class), p, null);\n@@ -111,1 +110,1 @@\n-                    \" with expected.\");\n+                \" with expected.\");\n@@ -116,1 +115,1 @@\n-                ap.getParameterSpec(PBEParameterSpec.class), p, new SecureRandom());\n+            ap.getParameterSpec(PBEParameterSpec.class), p, new SecureRandom());\n@@ -119,1 +118,1 @@\n-                    \" with expected.\");\n+                \" with expected.\");\n@@ -123,2 +122,2 @@\n-        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, null, null,\n-                p, new SecureRandom());\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key, Pem.DEFAULT_ALGO, null,\n+            p, new SecureRandom());\n@@ -126,0 +125,9 @@\n+\n+\n+        SecretKey key2 = new SecretKeySpec(\"1234567890123456\".getBytes(), \"AES\");\n+\n+        \/\/ Test encryptKey(PrivateKey, Key, String, ...) with provider and SecureRandom\n+        e = EncryptedPrivateKeyInfo.encrypt(priKey, key2, \"AES_128\/GCM\/NoPadding\",\n+            null, p, new SecureRandom());\n+        PrivateKey key3 = e.getKey(key2, null);\n+        assertEquals(key3, priKey, \"AES encryption failed\");\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/Encrypt.java","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @modules java.base\/sun.security.util\n@@ -35,1 +36,1 @@\n-\n+import sun.security.util.DerValue;\n@@ -60,0 +61,1 @@\n+    static byte[] keyOrigPub, keyOrigPriv;\n@@ -67,1 +69,4 @@\n-        \/\/ Generate the PEM, constructing a OneAsymmetricKey (OAS) encoding\n+        keyOrigPub = kpOrig.getPublic().getEncoded();\n+        keyOrigPriv = getPrivateKey(kpOrig.getPrivate());\n+\n+        \/\/ Encode the KeyPair into PEM, constructing an OneAsymmetricKey encoding\n@@ -70,1 +75,1 @@\n-        \/\/ Extracted the KeyPair from the generated PEM for verification.\n+        \/\/ Decode to a KeyPair from the generated PEM for verification.\n@@ -73,1 +78,9 @@\n-        \/\/ Extract the EncryptedPrivateKeyInfo.\n+\n+        \/\/ Check decoded public key pair with original.\n+        Asserts.assertEqualsByteArray(mlkemKP.getPublic().getEncoded(),\n+            keyOrigPub, \"Initial PublicKey compare didn't match.\");\n+        byte[] priv = getPrivateKey(mlkemKP.getPrivate());\n+        Asserts.assertEqualsByteArray(priv, keyOrigPriv,\n+            \"Initial PrivateKey compare didn't match\");\n+\n+        \/\/ Decode to a EncryptedPrivateKeyInfo.\n@@ -77,6 +90,3 @@\n-        KeyPairs kps = new KeyPairs(kpOrig, mlkemKP);\n-\n-        \/\/ Test getKey(password)\n-        System.out.println(\"Testing getKeyPair(char[]) \");\n-        KeyPair kp = ekpi.getKeyPair(password);\n-        arrayCheck(kps, kp);\n+        \/\/ Test getKeyPair(password)\n+        System.out.print(\"Testing getKeyPair(char[]): \");\n+        arrayCheck(ekpi.getKeyPair(password));\n@@ -84,4 +94,3 @@\n-        \/\/ Test getKey(key, provider) provider null\n-        System.out.println(\"Testing getKeyPair(key, null)\");\n-        kp = ekpi.getKeyPair(key, null);\n-        arrayCheck(kps, kp);\n+        \/\/ Test getKeyPair(key, provider) provider null\n+        System.out.print(\"Testing getKeyPair(key, null): \");\n+        arrayCheck(ekpi.getKeyPair(key, null));\n@@ -89,4 +98,3 @@\n-        \/\/ Test getKey(key, provider) provider SunJCE\n-        System.out.println(\"Testing getKeyPair(key, SunJCE)\");\n-        kp = ekpi.getKeyPair(key, p);\n-        arrayCheck(kps, kp);\n+        \/\/ Test getKeyPair(key, provider) provider SunJCE\n+        System.out.print(\"Testing getKeyPair(key, SunJCE): \");\n+        arrayCheck(ekpi.getKeyPair(key, p));\n@@ -95,4 +103,2 @@\n-    static void arrayCheck(KeyPairs kps, KeyPair actual) {\n-        byte[] actualPrivEncoding = actual.getPrivate().getEncoded();\n-        byte[] actualPubEncoding = actual.getPublic().getEncoded();\n-        Asserts.assertEqualsByteArray(kps.mlkemPrivEncoding, actualPrivEncoding,\n+    static void arrayCheck(KeyPair kp) throws Exception {\n+        Asserts.assertEqualsByteArray(getPrivateKey(kp.getPrivate()), keyOrigPriv,\n@@ -100,5 +106,3 @@\n-        Asserts.assertEqualsByteArray(kps.mlkemPubEncoding, actualPubEncoding,\n-            \"PublicKey didn't match with decoded.\");\n-        Asserts.assertEqualsByteArray(kps.origPubEncoding, actualPubEncoding,\n-            \"PublicKey didn't match with decoded.\");\n-        System.out.println(\"Got KeyPair:  Pass\");\n+        Asserts.assertEqualsByteArray(kp.getPublic().getEncoded(), keyOrigPub,\n+            \"PublicKey didn't match with expected.\");\n+        System.out.println(\"PASS\");\n@@ -107,8 +111,9 @@\n-    record KeyPairs(byte[] origPubEncoding, byte[] mlkemPrivEncoding,\n-                    byte[] mlkemPubEncoding) {\n-         KeyPairs(KeyPair orig, KeyPair mlkem) {\n-             this(orig.getPublic().getEncoded(),\n-                 mlkem.getPrivate().getEncoded(),\n-                 mlkem.getPublic().getEncoded());\n-         }\n-    };\n+    static byte[] getPrivateKey(PrivateKey p) throws Exception{\n+        var val = new DerValue(p.getEncoded());\n+        \/\/ Get version\n+        val.data.getInteger();\n+        \/\/ Get AlgorithmID\n+        val.data.getDerValue();\n+        \/\/ Return PrivateKey\n+        return val.data.getOctetString();\n+    }\n","filename":"test\/jdk\/javax\/crypto\/EncryptedPrivateKeyInfo\/GetKeyPair.java","additions":40,"deletions":35,"binary":false,"changes":75,"status":"modified"}]}