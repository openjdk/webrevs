{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,1 +173,1 @@\n-               ? new PrimitiveClassDescImpl(descriptor)\n+               ? Wrapper.forBasicType(descriptor.charAt(0)).primitiveClassDescriptor()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-    public static final ClassDesc CD_int = ClassDesc.ofDescriptor(\"I\");\n+    public static final ClassDesc CD_int = new PrimitiveClassDescImpl(\"I\");\n@@ -242,1 +242,1 @@\n-    public static final ClassDesc CD_long = ClassDesc.ofDescriptor(\"J\");\n+    public static final ClassDesc CD_long = new PrimitiveClassDescImpl(\"J\");\n@@ -245,1 +245,1 @@\n-    public static final ClassDesc CD_float = ClassDesc.ofDescriptor(\"F\");\n+    public static final ClassDesc CD_float = new PrimitiveClassDescImpl(\"F\");\n@@ -248,1 +248,1 @@\n-    public static final ClassDesc CD_double = ClassDesc.ofDescriptor(\"D\");\n+    public static final ClassDesc CD_double = new PrimitiveClassDescImpl(\"D\");\n@@ -251,1 +251,1 @@\n-    public static final ClassDesc CD_short = ClassDesc.ofDescriptor(\"S\");\n+    public static final ClassDesc CD_short = new PrimitiveClassDescImpl(\"S\");\n@@ -254,1 +254,1 @@\n-    public static final ClassDesc CD_byte = ClassDesc.ofDescriptor(\"B\");\n+    public static final ClassDesc CD_byte = new PrimitiveClassDescImpl(\"B\");\n@@ -257,1 +257,1 @@\n-    public static final ClassDesc CD_char = ClassDesc.ofDescriptor(\"C\");\n+    public static final ClassDesc CD_char = new PrimitiveClassDescImpl(\"C\");\n@@ -260,1 +260,1 @@\n-    public static final ClassDesc CD_boolean = ClassDesc.ofDescriptor(\"Z\");\n+    public static final ClassDesc CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n@@ -263,1 +263,1 @@\n-    public static final ClassDesc CD_void = ClassDesc.ofDescriptor(\"V\");\n+    public static final ClassDesc CD_void = new PrimitiveClassDescImpl(\"V\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import sun.invoke.util.Wrapper;\n+\n@@ -198,1 +200,1 @@\n-    static List<String> parseMethodDescriptor(String descriptor) {\n+    static List<ClassDesc> parseMethodDescriptor(String descriptor) {\n@@ -200,2 +202,2 @@\n-        ArrayList<String> ptypes = new ArrayList<>();\n-        ptypes.add(null); \/\/placeholder for return type\n+        ArrayList<ClassDesc> ptypes = new ArrayList<>();\n+        ptypes.add(null); \/\/ placeholder for return type\n@@ -211,1 +213,1 @@\n-            ptypes.add(descriptor.substring(cur, cur + len));\n+            ptypes.add(resolveClassDesc(descriptor, cur, len));\n@@ -221,1 +223,1 @@\n-        ptypes.set(0, descriptor.substring(cur, cur + rLen));\n+        ptypes.set(0, resolveClassDesc(descriptor, cur, rLen));\n@@ -225,0 +227,7 @@\n+    private static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n+        if (len == 1) {\n+            return Wrapper.forBasicType(descriptor.charAt(start)).primitiveClassDescriptor();\n+        }\n+        return ClassDesc.ofDescriptor(descriptor.substring(start, start + len));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantUtils.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.invoke.util.Wrapper;\n@@ -33,0 +34,1 @@\n+import java.util.ArrayList;\n@@ -91,1 +93,6 @@\n-        requireNonNull(descriptor);\n+        \/\/ Implicit null-check of descriptor\n+        List<ClassDesc> ptypes = ConstantUtils.parseMethodDescriptor(descriptor);\n+        int args = ptypes.size() - 1;\n+        ClassDesc[] paramTypes = args > 0\n+                ? ptypes.subList(1, args + 1).toArray(new ClassDesc[0])\n+                : ConstantUtils.EMPTY_CLASSDESC;\n@@ -93,9 +100,1 @@\n-        List<String> types = ConstantUtils.parseMethodDescriptor(descriptor);\n-\n-        int paramCount = types.size() - 1;\n-        var paramTypes = paramCount > 0 ? new ClassDesc[paramCount] : ConstantUtils.EMPTY_CLASSDESC;\n-        for (int i = 0; i < paramCount; i++) {\n-            paramTypes[i] = ClassDesc.ofDescriptor(types.get(i + 1));\n-        }\n-\n-        MethodTypeDescImpl result = ofTrusted(ClassDesc.ofDescriptor(types.getFirst()), paramTypes);\n+        MethodTypeDescImpl result = ofTrusted(ptypes.get(0), paramTypes);\n@@ -106,0 +105,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDescImpl.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Map;\n@@ -32,0 +31,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+\n@@ -34,1 +36,1 @@\n-    BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0], Format.unsigned( 1), 0, 0),\n+    BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0], Format.unsigned( 1), 0, 0, ConstantDescs.CD_boolean),\n@@ -37,8 +39,8 @@\n-    BYTE   (     Byte.class,      \"Byte\",    byte.class,    \"byte\", 'B', new    byte[0], Format.signed(   8), BYTE_CLASS, BYTE_SUPERCLASSES),\n-    SHORT  (    Short.class,     \"Short\",   short.class,   \"short\", 'S', new   short[0], Format.signed(  16), SHORT_CLASS, SHORT_SUPERCLASSES),\n-    CHAR   (Character.class, \"Character\",    char.class,    \"char\", 'C', new    char[0], Format.unsigned(16), CHAR_CLASS, CHAR_SUPERCLASSES),\n-    INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0], Format.signed(  32), INT_CLASS, INT_SUPERCLASSES),\n-    LONG   (     Long.class,      \"Long\",    long.class,    \"long\", 'J', new    long[0], Format.signed(  64), LONG_CLASS, LONG_SUPERCLASSES),\n-    FLOAT  (    Float.class,     \"Float\",   float.class,   \"float\", 'F', new   float[0], Format.floating(32), FLOAT_CLASS, FLOAT_SUPERCLASSES),\n-    DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0], Format.floating(64), DOUBLE_CLASS, DOUBLE_CLASS),\n-    OBJECT (   Object.class,    \"Object\",  Object.class,  \"Object\", 'L', new  Object[0], Format.other(    1), 0, 0),\n+    BYTE   (     Byte.class,      \"Byte\",    byte.class,    \"byte\", 'B', new    byte[0], Format.signed(   8), BYTE_CLASS, BYTE_SUPERCLASSES, ConstantDescs.CD_byte),\n+    SHORT  (    Short.class,     \"Short\",   short.class,   \"short\", 'S', new   short[0], Format.signed(  16), SHORT_CLASS, SHORT_SUPERCLASSES, ConstantDescs.CD_short),\n+    CHAR   (Character.class, \"Character\",    char.class,    \"char\", 'C', new    char[0], Format.unsigned(16), CHAR_CLASS, CHAR_SUPERCLASSES, ConstantDescs.CD_char),\n+    INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0], Format.signed(  32), INT_CLASS, INT_SUPERCLASSES, ConstantDescs.CD_int),\n+    LONG   (     Long.class,      \"Long\",    long.class,    \"long\", 'J', new    long[0], Format.signed(  64), LONG_CLASS, LONG_SUPERCLASSES, ConstantDescs.CD_long),\n+    FLOAT  (    Float.class,     \"Float\",   float.class,   \"float\", 'F', new   float[0], Format.floating(32), FLOAT_CLASS, FLOAT_SUPERCLASSES, ConstantDescs.CD_float),\n+    DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0], Format.floating(64), DOUBLE_CLASS, DOUBLE_CLASS, ConstantDescs.CD_double),\n+    OBJECT (   Object.class,    \"Object\",  Object.class,  \"Object\", 'L', new  Object[0], Format.other(    1), 0, 0, ConstantDescs.CD_Object),\n@@ -46,1 +48,1 @@\n-    VOID   (     Void.class,      \"Void\",    void.class,    \"void\", 'V',           null, Format.other(    0), 0, 0),\n+    VOID   (     Void.class,      \"Void\",    void.class,    \"void\", 'V',           null, Format.other(    0), 0, 0, ConstantDescs.CD_void),\n@@ -61,0 +63,1 @@\n+    private final ClassDesc primitiveTypeDesc;\n@@ -62,1 +65,1 @@\n-    private Wrapper(Class<?> wtype, String wtypeName, Class<?> ptype, String ptypeName, char tchar, Object emptyArray, int format, int numericClass, int superClasses) {\n+    private Wrapper(Class<?> wtype, String wtypeName, Class<?> ptype, String ptypeName, char tchar, Object emptyArray, int format, int numericClass, int superClasses, ClassDesc primitiveTypeDesc) {\n@@ -73,0 +76,1 @@\n+        this.primitiveTypeDesc = primitiveTypeDesc;\n@@ -379,0 +383,3 @@\n+    \/** A nominal descriptor of the primitive type *\/\n+    public ClassDesc primitiveClassDescriptor() { return primitiveTypeDesc; }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.constant;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.constant.ClassDesc;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Performance of conversion from and to method type descriptor symbols with\n+ * descriptor strings and class descriptor symbols\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 2)\n+@Measurement(iterations = 6, time = 1)\n+@Fork(1)\n+@State(Scope.Thread)\n+public class ClassDescFactories {\n+\n+    @Param({\n+            \"Ljava\/lang\/Object;\",\n+            \"V\",\n+            \"I\"\n+    })\n+    public String descString;\n+\n+    @Benchmark\n+    public ClassDesc ofDescriptor() {\n+        return ClassDesc.ofDescriptor(descString);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/ClassDescFactories.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"}]}