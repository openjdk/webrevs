{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n@@ -62,0 +64,1 @@\n+    @SuppressWarnings(\"restricted\")\n@@ -144,0 +147,1 @@\n+        MethodHandles.Lookup.ClassOption.class.getEnumConstants();\n@@ -163,0 +167,3 @@\n+        \/\/ record run-time methods\n+        o.equals(new B(5));\n+        o.hashCode();\n@@ -170,0 +177,4 @@\n+\n+        \/\/ Initialize FFM linkers\n+        var signature = FunctionDescriptor.ofVoid();\n+        Linker.nativeLinker().downcallHandle(signature);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/classlist\/HelloClasslist.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -862,1 +862,1 @@\n-            Set<CapturableState> set = Stream.of(Objects.requireNonNull(capturedState))\n+            int set = Stream.of(Objects.requireNonNull(capturedState))\n@@ -865,1 +865,2 @@\n-                    .collect(Collectors.toSet());\n+                    .mapToInt(state -> 1 << state.ordinal())\n+                    .sum();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -74,1 +74,14 @@\n-    private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {}\n+    private record LinkRequest(FunctionDescriptor descriptor, LinkerOptions options) {\n+        \/\/ Overrides for boot performance\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof LinkRequest other &&\n+                    other.descriptor.equals(descriptor) &&\n+                    other.options.equals(options);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return descriptor.hashCode() * 1237 + options.hashCode();\n+        }\n+    }\n@@ -311,3 +324,7 @@\n-            case AddressLayout al -> al.targetLayout()\n-                    .map(tl -> al.withoutName().withTargetLayout(stripNames(tl))) \/\/ restricted\n-                    .orElseGet(al::withoutName);\n+            case AddressLayout al -> {\n+                var stripped = al.withoutName();\n+                var target = al.targetLayout();\n+                if (target.isPresent())\n+                    stripped = stripped.withTargetLayout(stripNames(target.get()));\n+                yield stripped;\n+            }\n@@ -319,3 +336,5 @@\n-        return layouts.stream()\n-                .map(AbstractLinker::stripNames)\n-                .toArray(MemoryLayout[]::new);\n+        var ret = new MemoryLayout[layouts.size()];\n+        for (int i = 0; i < ret.length; i++) {\n+            ret[i] = stripNames(layouts.get(i));\n+        }\n+        return ret;\n@@ -325,3 +344,5 @@\n-        return function.returnLayout()\n-                .map(rl -> FunctionDescriptor.of(stripNames(rl), stripNames(function.argumentLayouts())))\n-                .orElseGet(() -> FunctionDescriptor.ofVoid(stripNames(function.argumentLayouts())));\n+        var retLayout = function.returnLayout();\n+        if (retLayout.isEmpty()) {\n+            return FunctionDescriptor.ofVoid(stripNames(function.argumentLayouts()));\n+        }\n+        return FunctionDescriptor.of(stripNames(retLayout.get()), stripNames(function.argumentLayouts()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.List;\n@@ -45,0 +46,5 @@\n+    public static final List<CapturableState> BY_ORDINAL = List.of(values());\n+\n+    static {\n+        assert (BY_ORDINAL.size() < Integer.SIZE); \/\/ Update LinkerOptions.CaptureCallState\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/CapturableState.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.EnumSet;\n@@ -140,0 +141,10 @@\n+\n+        @Override\n+        public int hashCode() {\n+            return index;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof FirstVariadicArg that && index == that.index;\n+        }\n@@ -142,1 +153,1 @@\n-    public record CaptureCallState(Set<CapturableState> saved) implements LinkerOptionImpl {\n+    public record CaptureCallState(int compact) implements LinkerOptionImpl {\n@@ -147,0 +158,25 @@\n+\n+        public Set<CapturableState> saved() {\n+            var set = EnumSet.noneOf(CapturableState.class);\n+            int mask = compact;\n+            int i = 0;\n+            while (mask != 0) {\n+                if ((mask & 1) == 1) {\n+                    set.add(CapturableState.BY_ORDINAL.get(i));\n+                }\n+                mask >>= 1;\n+                i++;\n+            }\n+            return set;\n+        }\n+\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof CaptureCallState that && compact == that.compact;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return compact;\n+        }\n@@ -149,3 +185,7 @@\n-    public record Critical(boolean allowHeapAccess) implements LinkerOptionImpl {\n-        public static Critical ALLOW_HEAP = new Critical(true);\n-        public static Critical DONT_ALLOW_HEAP = new Critical(false);\n+    public enum Critical implements LinkerOptionImpl {\n+        ALLOW_HEAP,\n+        DONT_ALLOW_HEAP;\n+\n+        public boolean allowHeapAccess() {\n+            return ordinal() == 0; \/\/ this == ALLOW_HEAP\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -51,1 +51,23 @@\n-                            boolean needsTransition) {}\n+                            boolean needsTransition) {\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof CacheKey other)) return false;\n+\n+            return methodType == other.methodType && abi == other.abi && capturedStateMask == other.capturedStateMask\n+                    && needsTransition == other.needsTransition && needsReturnBuffer == other.needsReturnBuffer\n+                    && argMoves.equals(other.argMoves) && retMoves.equals(other.retMoves);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int result = System.identityHashCode(methodType);\n+            result = 31 * result + abi.hashCode();\n+            result = 31 * result + argMoves.hashCode();\n+            result = 31 * result + retMoves.hashCode();\n+            result = 31 * result + Boolean.hashCode(needsReturnBuffer);\n+            result = 31 * result + capturedStateMask;\n+            result = 31 * result + Boolean.hashCode(needsTransition);\n+            return result;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/NativeEntryPoint.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Objects;\n+\n@@ -35,1 +37,1 @@\n- * @param debugName         the debug name\n+ * @param debugName         the debug name, mostly derived from type\n@@ -46,0 +48,10 @@\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(type, segmentMaskOrSize, indexOrOffset);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj instanceof VMStorage that &&\n+                type == that.type && segmentMaskOrSize == that.segmentMaskOrSize && indexOrOffset == that.indexOrOffset;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/VMStorage.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}