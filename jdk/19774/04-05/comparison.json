{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import java.util.ArrayList;\n@@ -36,0 +35,2 @@\n+import java.util.Optional;\n+import java.util.function.Function;\n@@ -64,1 +65,1 @@\n-        out.println(\"jnativescan \" + Runtime.version());\n+        out.println(System.getProperty(\"java.version\"));\n@@ -100,1 +101,1 @@\n-        OptionSpec<String> classPathOpt = parser.accepts(\n+        OptionSpec<Path> classPathOpt = parser.accepts(\n@@ -103,2 +104,4 @@\n-                .withRequiredArg();\n-        OptionSpec<String> modulePathOpt = parser.accepts(\n+                .withRequiredArg()\n+                .withValuesSeparatedBy(File.pathSeparatorChar)\n+                .withValuesConvertedBy(PARSE_PATH);\n+        OptionSpec<Path> modulePathOpt = parser.accepts(\n@@ -107,2 +110,4 @@\n-                .withRequiredArg();\n-        OptionSpec<String> releaseOpt = parser.accepts(\n+                .withRequiredArg()\n+                .withValuesSeparatedBy(File.pathSeparatorChar)\n+                .withValuesConvertedBy(PARSE_PATH);\n+        OptionSpec<Runtime.Version> releaseOpt = parser.accepts(\n@@ -111,1 +116,2 @@\n-                .withRequiredArg();\n+                .withRequiredArg()\n+                .withValuesConvertedBy(PARSE_VERSION);\n@@ -115,1 +121,3 @@\n-                .withRequiredArg();\n+                .requiredIf(modulePathOpt)\n+                .withRequiredArg()\n+                .withValuesSeparatedBy(',');\n@@ -119,1 +127,1 @@\n-                        \"ALL-UNNAMED is used to indicate unnamed modules.\");\n+                        \" ALL-UNNAMED is used to indicate unnamed modules.\");\n@@ -128,0 +136,4 @@\n+        if (optionSet.nonOptionArguments().size() != 0) {\n+            throw new JNativeScanFatalError(\"jnativescan does not accept positional arguments\");\n+        }\n+\n@@ -146,12 +158,4 @@\n-        List<Path> classPathJars = parsePath(optionSet, classPathOpt);\n-        List<Path> modulePaths = parsePath(optionSet, modulePathOpt);\n-\n-        Runtime.Version version = Runtime.version();\n-        if (optionSet.has(releaseOpt)) {\n-            String release = optionSet.valueOf(releaseOpt);\n-            try {\n-                version = Runtime.Version.parse(release);\n-            } catch (IllegalArgumentException e) {\n-                throw new JNativeScanFatalError(\"Invalid release: \" + release + \": \" + e.getMessage());\n-            }\n-        }\n+        List<Path> classPathJars = optionSet.valuesOf(classPathOpt);\n+        List<Path> modulePaths = optionSet.valuesOf(modulePathOpt);\n+        List<String> rootModules = optionSet.valuesOf(addModulesOpt);\n+        Runtime.Version version = Optional.ofNullable(optionSet.valueOf(releaseOpt)).orElse(Runtime.version());\n@@ -164,5 +168,0 @@\n-        List<String> rootModules = List.of();\n-        if (optionSet.has(addModulesOpt)) {\n-            rootModules = List.of(optionSet.valueOf(addModulesOpt).split(\",\"));\n-        }\n-\n@@ -172,12 +171,0 @@\n-    private static List<Path> parsePath(OptionSet optionSet, OptionSpec<String> opt) throws JNativeScanFatalError {\n-        List<Path> paths = new ArrayList<>();\n-        if (optionSet.has(opt)) {\n-            String[] parts = optionSet.valueOf(opt).split(File.pathSeparator);\n-            for (String part : parts) {\n-                Path path = Path.of(part);\n-                paths.add(path);\n-            }\n-        }\n-        return paths;\n-    }\n-\n@@ -208,0 +195,39 @@\n+\n+    \/\/ where\n+    private static final ValueConverter<Path> PARSE_PATH = new ValueConverter<>() {\n+        @Override\n+        public Path convert(String value) {\n+            return Path.of(value);\n+        }\n+\n+        @Override\n+        public Class<? extends Path> valueType() {\n+            return Path.class;\n+        }\n+\n+        @Override\n+        public String valuePattern() {\n+            return \"Path\";\n+        }\n+    };\n+\n+    private static final ValueConverter<Runtime.Version> PARSE_VERSION = new ValueConverter<>() {\n+        @Override\n+        public Runtime.Version convert(String value) {\n+            try {\n+                return Runtime.Version.parse(value);\n+            } catch (IllegalArgumentException e) {\n+                throw new JNativeScanFatalError(\"Invalid release: \" + value + \": \" + e.getMessage());\n+            }\n+        }\n+\n+        @Override\n+        public Class<? extends Runtime.Version> valueType() {\n+            return Runtime.Version.class;\n+        }\n+\n+        @Override\n+        public String valuePattern() {\n+            return \"Version\";\n+        }\n+    };\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/Main.java","additions":65,"deletions":39,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -201,0 +201,7 @@\n+\n+    @Test\n+    public void testPositionalArguments() {\n+        assertFailure(jnativescan(\"foo\"))\n+                .stdoutShouldBeEmpty()\n+                .stderrShouldContain(\"jnativescan does not accept positional arguments\");\n+    }\n","filename":"test\/langtools\/tools\/jnativescan\/TestJNativeScan.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}