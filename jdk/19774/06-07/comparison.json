{"files":[{"patch":"@@ -87,1 +87,1 @@\n-        if (Source.lookup(platformName) == null) {\n+        if (!SUPPORTED_JAVA_PLATFORM_VERSIONS.contains(platformName)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/platform\/JDKPlatformProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.jar.JarFile;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipFile;\n+\n+sealed interface ClassFileSource {\n+    String moduleName();\n+    Path path();\n+\n+    Stream<byte[]> classFiles(Runtime.Version version) throws IOException;\n+\n+    record Module(ModuleReference reference) implements ClassFileSource {\n+        @Override\n+        public String moduleName() {\n+            return reference.descriptor().name();\n+        }\n+\n+        @Override\n+        public Path path() {\n+            URI location = reference.location().orElseThrow();\n+            return Path.of(location);\n+        }\n+\n+        @Override\n+        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+            ModuleReader reader = reference().open();\n+            return reader.list()\n+                .filter(resourceName -> resourceName.endsWith(\".class\"))\n+                .map(resourceName -> {\n+                    try (InputStream stream = reader.open(resourceName).orElseThrow()) {\n+                        return stream.readAllBytes();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }).onClose(() -> {\n+                    try {\n+                        reader.close();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+        }\n+    }\n+\n+    record ClassPathJar(Path path) implements ClassFileSource {\n+        @Override\n+        public String moduleName() {\n+            return \"ALL-UNNAMED\";\n+        }\n+\n+        @Override\n+        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+            JarFile jf = new JarFile(path().toFile(), false, ZipFile.OPEN_READ, version);\n+            return jf.versionedStream()\n+                .filter(je -> je.getName().endsWith(\".class\"))\n+                .map(je -> {\n+                    try (InputStream stream = jf.getInputStream(je)){\n+                        return stream.readAllBytes();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                }).onClose(() -> {\n+                    try {\n+                        jf.close();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+        }\n+    }\n+\n+    record ClassPathDirectory(Path path) implements ClassFileSource {\n+        @Override\n+        public String moduleName() {\n+            return \"ALL-UNNAMED\";\n+        }\n+\n+        @Override\n+        public Stream<byte[]> classFiles(Runtime.Version version) throws IOException {\n+            return Files.walk(path)\n+                .filter(file -> Files.isRegularFile(file) && file.toString().endsWith(\".class\"))\n+                .map(file -> {\n+                    try (InputStream stream = Files.newInputStream(file)){\n+                        return stream.readAllBytes();\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+        }\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ClassFileSource.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -38,1 +38,0 @@\n-import java.nio.file.Path;\n@@ -41,2 +40,1 @@\n-import java.util.jar.JarFile;\n-import java.util.zip.ZipFile;\n+import java.util.stream.Stream;\n@@ -46,2 +44,1 @@\n-    static ClassResolver forScannedModules(List<ScannedModule> modules, Runtime.Version version) throws IOException {\n-        List<JarFile> loaded = new ArrayList<>();\n+    static ClassResolver forClassFileSources(List<ClassFileSource> sources, Runtime.Version version) throws IOException {\n@@ -49,12 +46,8 @@\n-        for (ScannedModule m : modules) {\n-            JarFile jf = new JarFile(m.path().toFile(), false, ZipFile.OPEN_READ, version);\n-            loaded.add(jf);\n-            jf.versionedStream().filter(je -> je.getName().endsWith(\".class\")).forEach(je -> {\n-                try {\n-                    ClassModel model = ClassFile.of().parse(jf.getInputStream(je).readAllBytes());\n-                    ClassDesc desc =  model.thisClass().asSymbol();\n-                    classMap.put(desc, new Info(m.moduleName(), m.path(), model));\n-                } catch (IOException e) {\n-                    throw new RuntimeException(e);\n-                }\n-            });\n+        for (ClassFileSource source : sources) {\n+            try (Stream<byte[]> classFiles = source.classFiles(version)) {\n+                classFiles.forEach(bytes -> {\n+                    ClassModel model = ClassFile.of().parse(bytes);\n+                    ClassDesc desc = model.thisClass().asSymbol();\n+                    classMap.put(desc, new Info(source, model));\n+                });\n+            }\n@@ -62,1 +55,1 @@\n-        return new ScannedModuleClassResolver(loaded, classMap);\n+        return new SimpleClassResolver(classMap);\n@@ -78,1 +71,1 @@\n-    record Info(String moduleName, Path jarPath, ClassModel model) {}\n+    record Info(ClassFileSource source, ClassModel model) {}\n@@ -86,1 +79,1 @@\n-    private static class ScannedModuleClassResolver extends ClassResolver {\n+    private static class SimpleClassResolver extends ClassResolver {\n@@ -88,1 +81,0 @@\n-        private final List<JarFile> jars;\n@@ -91,2 +83,1 @@\n-        public ScannedModuleClassResolver(List<JarFile> jars, Map<ClassDesc, Info> classMap) {\n-            this.jars = jars;\n+        public SimpleClassResolver(Map<ClassDesc, Info> classMap) {\n@@ -105,5 +96,1 @@\n-        public void close() throws IOException {\n-            for (JarFile jarFile : jars) {\n-                jarFile.close();\n-            }\n-        }\n+        public void close() {}\n@@ -162,1 +149,1 @@\n-                        return new Info(moduleName, null, model);\n+                        return new Info(null, model);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ClassResolver.java","additions":16,"deletions":29,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.net.URI;\n@@ -40,1 +39,0 @@\n-import java.util.stream.Stream;\n@@ -63,2 +61,1 @@\n-        List<ScannedModule> modulesToScan = new ArrayList<>();\n-        findAllClassPathJars().forEach(modulesToScan::add);\n+        List<ClassFileSource> toScan = new ArrayList<>(findAllClassPathJars());\n@@ -74,4 +71,1 @@\n-            URI location = m.reference().location().orElseThrow();\n-            Path path = Path.of(location);\n-            checkRegularJar(path);\n-            modulesToScan.add(new ScannedModule(path, m.name()));\n+            toScan.add(new ClassFileSource.Module(m.reference()));\n@@ -80,3 +74,3 @@\n-        Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> allRestrictedMethods;\n-        try(ClassResolver classesToScan = ClassResolver.forScannedModules(modulesToScan, version);\n-                ClassResolver systemClassResolver = ClassResolver.forSystemModules(version)) {\n+        SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods;\n+        try(ClassResolver classesToScan = ClassResolver.forClassFileSources(toScan, version);\n+            ClassResolver systemClassResolver = ClassResolver.forSystemModules(version)) {\n@@ -95,19 +89,25 @@\n-    \/\/ recursively look for all class path jars, starting at the root jars\n-    \/\/ in this.classPaths, and recursively following all Class-Path manifest\n-    \/\/ attributes\n-    private Stream<ScannedModule> findAllClassPathJars() throws JNativeScanFatalError {\n-        Stream.Builder<ScannedModule> builder = Stream.builder();\n-        Deque<Path> classPathJars = new ArrayDeque<>(classPaths);\n-        while (!classPathJars.isEmpty()) {\n-            Path jar = classPathJars.poll();\n-            checkRegularJar(jar);\n-            String[] classPathAttribute = classPathAttribute(jar);\n-            Path parentDir = jar.getParent();\n-            for (String classPathEntry : classPathAttribute) {\n-                Path otherJar = parentDir != null\n-                        ? parentDir.resolve(classPathEntry)\n-                        : Path.of(classPathEntry);\n-                if (Files.exists(otherJar)) {\n-                    \/\/ Class-Path attribute specifies that jars that\n-                    \/\/ are not found are simply ignored. Do the same here\n-                    classPathJars.offer(otherJar);\n+    private List<ClassFileSource> findAllClassPathJars() throws JNativeScanFatalError {\n+        List<ClassFileSource> result = new ArrayList<>();\n+        for (Path path : classPaths) {\n+            if (isJarFile(path)) {\n+                Deque<Path> jarsToScan  = new ArrayDeque<>();\n+                jarsToScan.offer(path);\n+\n+                \/\/ recursively look for all class path jars, starting at the root jars\n+                \/\/ in this.classPaths, and recursively following all Class-Path manifest\n+                \/\/ attributes\n+                while (!jarsToScan.isEmpty()) {\n+                    Path jar = jarsToScan.poll();\n+                    String[] classPathAttribute = classPathAttribute(jar);\n+                    Path parentDir = jar.getParent();\n+                    for (String classPathEntry : classPathAttribute) {\n+                        Path otherJar = parentDir != null\n+                                ? parentDir.resolve(classPathEntry)\n+                                : Path.of(classPathEntry);\n+                        if (Files.exists(otherJar)) {\n+                            \/\/ Class-Path attribute specifies that jars that\n+                            \/\/ are not found are simply ignored. Do the same here\n+                            jarsToScan.offer(otherJar);\n+                        }\n+                    }\n+                    result.add(new ClassFileSource.ClassPathJar(jar));\n@@ -115,0 +115,5 @@\n+            } else if (Files.isDirectory(path)) {\n+                result.add(new ClassFileSource.ClassPathDirectory(path));\n+            } else {\n+                throw new JNativeScanFatalError(\n+                    \"Path does not appear to be a jar file, or directory containing classes: \" + path);\n@@ -116,1 +121,0 @@\n-            builder.add(new ScannedModule(jar, \"ALL-UNNAMED\"));\n@@ -118,1 +122,1 @@\n-        return builder.build();\n+        return result;\n@@ -147,1 +151,1 @@\n-    private void printNativeAccess(Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> allRestrictedMethods) {\n+    private void printNativeAccess(SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods) {\n@@ -149,1 +153,1 @@\n-                .map(ScannedModule::moduleName)\n+                .map(ClassFileSource::moduleName)\n@@ -155,1 +159,1 @@\n-    private void dumpAll(Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> allRestrictedMethods) {\n+    private void dumpAll(SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> allRestrictedMethods) {\n@@ -178,4 +182,2 @@\n-    private static void checkRegularJar(Path path) throws JNativeScanFatalError {\n-        if (!(Files.exists(path) && Files.isRegularFile(path) && path.toString().endsWith(\".jar\"))) {\n-            throw new JNativeScanFatalError(\"File does not exist, or does not appear to be a regular jar file: \" + path);\n-        }\n+    private static boolean isJarFile(Path path) throws JNativeScanFatalError {\n+        return Files.exists(path) && Files.isRegularFile(path) && path.toString().endsWith(\".jar\");\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/JNativeScanTask.java","additions":41,"deletions":39,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-import java.lang.classfile.constantpool.InterfaceMethodRefEntry;\n-import java.lang.classfile.constantpool.MemberRefEntry;\n-import java.lang.classfile.constantpool.MethodRefEntry;\n@@ -49,1 +46,1 @@\n-    private final Map<MethodRef, Boolean> CACHE = new HashMap<>();\n+    private final Map<MethodRef, Boolean> cache = new HashMap<>();\n@@ -62,2 +59,3 @@\n-    public Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> findAll() throws JNativeScanFatalError {\n-        Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> restrictedMethods = new HashMap<>();\n+    public SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> findAll() throws JNativeScanFatalError {\n+        SortedMap<ClassFileSource, SortedMap<ClassDesc, List<RestrictedUse>>> restrictedMethods\n+                = new TreeMap<>(Comparator.comparing(ClassFileSource::moduleName));\n@@ -71,1 +69,1 @@\n-                    Set<MethodRef> perMethod = new HashSet<>();\n+                    SortedSet<MethodRef> perMethod = new TreeSet<>(Comparator.comparing(MethodRef::toString));\n@@ -92,2 +90,1 @@\n-                        perClass.add(new RestrictedMethodRefs(MethodRef.ofModel(methodModel),\n-                                Set.copyOf(perMethod)));\n+                        perClass.add(new RestrictedMethodRefs(MethodRef.ofModel(methodModel), perMethod));\n@@ -98,2 +95,2 @@\n-                ScannedModule scannedModule = new ScannedModule(info.jarPath(), info.moduleName());\n-                restrictedMethods.computeIfAbsent(scannedModule, _ -> new HashMap<>())\n+                restrictedMethods.computeIfAbsent(info.source(),\n+                                _ -> new TreeMap<>(Comparator.comparing(JNativeScanTask::qualName)))\n@@ -107,1 +104,1 @@\n-        return CACHE.computeIfAbsent(ref, methodRef -> {\n+        return cache.computeIfAbsent(ref, methodRef -> {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/NativeMethodFinder.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import java.util.Set;\n+import java.util.SortedSet;\n@@ -30,1 +30,1 @@\n-    record RestrictedMethodRefs(MethodRef referent, Set<MethodRef> referees) implements RestrictedUse {}\n+    record RestrictedMethodRefs(MethodRef referent, SortedSet<MethodRef> referees) implements RestrictedUse {}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/RestrictedUse.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tools.jnativescan;\n-\n-import java.nio.file.Path;\n-\n-record ScannedModule(Path path, String moduleName) {\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ScannedModule.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -158,1 +158,1 @@\n-                .stderrShouldContain(\"File does not exist, or does not appear to be a regular jar file\");\n+                .stderrShouldContain(\"Path does not appear to be a jar file, or directory containing classes\");\n@@ -164,1 +164,1 @@\n-        assertFailure(jnativescan(\"--module-path\", modulePath,\n+        assertSuccess(jnativescan(\"--module-path\", modulePath,\n@@ -166,1 +166,4 @@\n-                .stderrShouldContain(\"File does not exist, or does not appear to be a regular jar file\");\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(\"lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n@@ -174,3 +177,1 @@\n-                .stdoutShouldContain(\"org.singlejar\")\n-                .stdoutShouldContain(\"org.lib\")\n-                .stdoutShouldContain(\"org.service\");\n+                .stdoutShouldMatch(\"org.lib,org.service,org.singlejar\");\n@@ -215,0 +216,17 @@\n+\n+    @Test\n+    public void testClassPathDirectory() {\n+        assertSuccess(jnativescan(\"--class-path\", testClasses.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"UnnamedPackage\")\n+                .stdoutShouldContain(\"UnnamedPackage::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"UnnamedPackage::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"main.Main\")\n+                .stdoutShouldContain(\"main.Main::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"main.Main::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(\"lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n","filename":"test\/langtools\/tools\/jnativescan\/TestJNativeScan.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"}]}