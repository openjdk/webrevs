{"files":[{"patch":"@@ -54,0 +54,9 @@\n+\n+################################################################################\n+## Build jnativescan\n+################################################################################\n+\n+$(eval $(call SetupBuildLauncher, jnativescan, \\\n+    MAIN_CLASS := com.sun.tools.jnativescan.Main, \\\n+    CFLAGS := -DEXPAND_CLASSPATH_WILDCARDS, \\\n+))\n","filename":"make\/modules\/jdk.jdeps\/Launcher.gmk","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,8 @@\n-    public PlatformDescription getPlatform(String platformName, String options) {\n+    public PlatformDescription getPlatform(String platformName, String options) throws PlatformNotSupported {\n+        if (Source.lookup(platformName) == null) {\n+            throw new PlatformNotSupported();\n+        }\n+        return getPlatformTrusted(platformName);\n+    }\n+\n+    public PlatformDescription getPlatformTrusted(String platformName) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/platform\/JDKPlatformProvider.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,2 @@\n-        jdk.jshell;\n+        jdk.jshell,\n+        jdk.jdeps;\n@@ -40,1 +41,2 @@\n-        jdk.jpackage;\n+        jdk.jpackage,\n+        jdk.jdeps;\n","filename":"src\/jdk.internal.opt\/share\/classes\/module-info.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -417,1 +417,1 @@\n-            JavaFileManager fm = pp.getPlatform(release, \"\").getFileManager();\n+            JavaFileManager fm = pp.getPlatformTrusted(release).getFileManager();\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeprscan\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import com.sun.tools.javac.platform.PlatformDescription;\n+import com.sun.tools.javac.platform.PlatformProvider;\n+\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardLocation;\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.constant.ClassDesc;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.function.BiConsumer;\n+import java.util.jar.JarFile;\n+import java.util.zip.ZipFile;\n+\n+abstract class ClassResolver implements AutoCloseable {\n+\n+    static ClassResolver forScannedModules(List<ScannedModule> modules, Runtime.Version version) throws IOException {\n+        List<JarFile> loaded = new ArrayList<>();\n+        Map<ClassDesc, Info> classMap = new HashMap<>();\n+        for (ScannedModule m : modules) {\n+            JarFile jf = new JarFile(m.path().toFile(), false, ZipFile.OPEN_READ, version);\n+            loaded.add(jf);\n+            jf.versionedStream().filter(je -> je.getName().endsWith(\".class\")).forEach(je -> {\n+                try {\n+                    ClassModel model = ClassFile.of().parse(jf.getInputStream(je).readAllBytes());\n+                    ClassDesc desc =  model.thisClass().asSymbol();\n+                    classMap.put(desc, new Info(m.moduleName(), m.path(), model));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+        return new ScannedModuleClassResolver(loaded, classMap);\n+    }\n+\n+    static ClassResolver forSystemModules(Runtime.Version version) {\n+        String platformName = String.valueOf(version.feature());\n+        PlatformProvider platformProvider = ServiceLoader.load(PlatformProvider.class).findFirst().orElseThrow();\n+        PlatformDescription platform;\n+        try {\n+            platform = platformProvider.getPlatform(platformName, null);\n+        } catch (PlatformProvider.PlatformNotSupported e) {\n+            throw new JNativeScanFatalError(\"Release: \" + platformName + \" not supported\", e);\n+        }\n+        JavaFileManager fm = platform.getFileManager();\n+        return new SystemModuleClassResolver(fm);\n+    }\n+\n+    record Info(String moduleName, Path jarPath, ClassModel model) {}\n+\n+    public abstract void forEach(BiConsumer<ClassDesc, ClassResolver.Info> action);\n+    public abstract Optional<ClassResolver.Info> lookup(ClassDesc desc);\n+\n+    @Override\n+    public abstract void close() throws IOException;\n+\n+    private static class ScannedModuleClassResolver extends ClassResolver {\n+\n+        private final List<JarFile> jars;\n+        private final Map<ClassDesc, ClassResolver.Info> classMap;\n+\n+        public ScannedModuleClassResolver(List<JarFile> jars, Map<ClassDesc, Info> classMap) {\n+            this.jars = jars;\n+            this.classMap = classMap;\n+        }\n+\n+        public void forEach(BiConsumer<ClassDesc, ClassResolver.Info> action) {\n+            classMap.forEach(action);\n+        }\n+\n+        public Optional<ClassResolver.Info> lookup(ClassDesc desc) {\n+            return Optional.ofNullable(classMap.get(desc));\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            for (JarFile jarFile : jars) {\n+                jarFile.close();\n+            }\n+        }\n+    }\n+\n+    private static class SystemModuleClassResolver extends ClassResolver {\n+\n+        private final JavaFileManager platformFileManager;\n+        private final Map<String, String> packageToSystemModule;\n+        private final Map<ClassDesc, Info> cache = new HashMap<>();\n+\n+        public SystemModuleClassResolver(JavaFileManager platformFileManager) {\n+            this.platformFileManager = platformFileManager;\n+            this.packageToSystemModule = packageToSystemModule();\n+        }\n+\n+        private static Map<String, String> packageToSystemModule() {\n+            List<ModuleDescriptor> descriptors = ModuleFinder.ofSystem()\n+                    .findAll()\n+                    .stream()\n+                    .map(ModuleReference::descriptor)\n+                    .toList();\n+            Map<String, String> result = new HashMap<>();\n+            for (ModuleDescriptor descriptor : descriptors) {\n+                for (ModuleDescriptor.Exports export : descriptor.exports()) {\n+                    if (!export.isQualified()) {\n+                        result.put(export.source(), descriptor.name());\n+                    }\n+                }\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public void forEach(BiConsumer<ClassDesc, Info> action) {\n+            throw new UnsupportedOperationException(\"NYI\");\n+        }\n+\n+        @Override\n+        public Optional<Info> lookup(ClassDesc desc) {\n+            return Optional.ofNullable(cache.computeIfAbsent(desc, _ -> {\n+                String qualName = JNativeScanTask.qualName(desc);\n+                String moduleName = packageToSystemModule.get(desc.packageName());\n+                if (moduleName != null) {\n+                    try {\n+                        JavaFileManager.Location loc = platformFileManager.getLocationForModule(StandardLocation.SYSTEM_MODULES, moduleName);\n+                        JavaFileObject jfo = platformFileManager.getJavaFileForInput(loc, qualName, JavaFileObject.Kind.CLASS);\n+                        ClassModel model = ClassFile.of().parse(jfo.openInputStream().readAllBytes());\n+                        return new Info(moduleName, null, model);\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+                return null;\n+            }));\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            platformFileManager.close();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ClassResolver.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.io.Serial;\n+\n+\/\/ Exception used in case of fatal error that is reasonably expected and handled.\n+public class JNativeScanFatalError extends RuntimeException {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    public JNativeScanFatalError(String message) {\n+        super(message);\n+    }\n+\n+    public JNativeScanFatalError(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public JNativeScanFatalError(Throwable cause) {\n+        super(cause);\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/JNativeScanFatalError.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.lang.constant.ClassDesc;\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ResolvedModule;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.jar.JarFile;\n+import java.util.jar.Manifest;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipFile;\n+\n+class JNativeScanTask {\n+\n+    private final PrintWriter out;\n+    private final List<Path> classPaths;\n+    private final List<Path> modulePaths;\n+    private final List<String> cmdRootModules;\n+    private final Runtime.Version version;\n+    private final Action action;\n+\n+    public JNativeScanTask(PrintWriter out, List<Path> classPaths, List<Path> modulePaths,\n+                           List<String> cmdRootModules, Runtime.Version version, Action action) {\n+        this.out = out;\n+        this.classPaths = classPaths;\n+        this.modulePaths = modulePaths;\n+        this.version = version;\n+        this.action = action;\n+        this.cmdRootModules = cmdRootModules;\n+    }\n+\n+    public void run() throws JNativeScanFatalError {\n+        List<ScannedModule> modulesToScan = new ArrayList<>();\n+        findAllClassPathJars().forEach(modulesToScan::add);\n+\n+        ModuleFinder moduleFinder = ModuleFinder.of(modulePaths.toArray(Path[]::new));\n+        List<String> rootModules = cmdRootModules;\n+        if (rootModules.contains(\"ALL-MODULE-PATH\")) {\n+            rootModules = allModuleNames(moduleFinder);\n+        }\n+        Configuration config = Configuration.resolveAndBind(moduleFinder, List.of(systemConfiguration()),\n+                ModuleFinder.of(), rootModules);\n+        for (ResolvedModule m : config.modules()) {\n+            URI location = m.reference().location().orElseThrow();\n+            Path path = Path.of(location);\n+            checkRegularJar(path);\n+            modulesToScan.add(new ScannedModule(path, m.name()));\n+        }\n+\n+        Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> allRestrictedMethods;\n+        try(ClassResolver classesToScan = ClassResolver.forScannedModules(modulesToScan, version);\n+                ClassResolver systemClassResolver = ClassResolver.forSystemModules(version)) {\n+            RestrictedMethodFinder finder = RestrictedMethodFinder.create(classesToScan, systemClassResolver);\n+            allRestrictedMethods = finder.findAll();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        switch (action) {\n+            case PRINT -> printNativeAccess(allRestrictedMethods);\n+            case DUMP_ALL -> dumpAll(allRestrictedMethods);\n+        }\n+    }\n+\n+    \/\/ recursively look for all class path jars, starting at the root jars\n+    \/\/ in this.classPaths, and recursively following all Class-Path manifest\n+    \/\/ attributes\n+    private Stream<ScannedModule> findAllClassPathJars() throws JNativeScanFatalError {\n+        Stream.Builder<ScannedModule> builder = Stream.builder();\n+        Deque<Path> classPathJars = new ArrayDeque<>(classPaths);\n+        while (!classPathJars.isEmpty()) {\n+            Path jar = classPathJars.poll();\n+            checkRegularJar(jar);\n+            String[] classPathAttribute = classPathAttribute(jar);\n+            Path parentDir = jar.getParent();\n+            for (String classPathEntry : classPathAttribute) {\n+                Path otherJar = parentDir != null\n+                        ? parentDir.resolve(classPathEntry)\n+                        : Path.of(classPathEntry);\n+                if (Files.exists(otherJar)) {\n+                    \/\/ Class-Path attribute specifies that jars that\n+                    \/\/ are not found are simply ignored. Do the same here\n+                    classPathJars.offer(otherJar);\n+                }\n+            }\n+            builder.add(new ScannedModule(jar, \"ALL-UNNAMED\"));\n+        }\n+        return builder.build();\n+    }\n+\n+    private String[] classPathAttribute(Path jar) {\n+        try (JarFile jf = new JarFile(jar.toFile(), false, ZipFile.OPEN_READ, version)) {\n+           Manifest manifest = jf.getManifest();\n+           if (manifest != null) {\n+               String attrib = manifest.getMainAttributes().getValue(\"Class-Path\");\n+               if (attrib != null) {\n+                   return attrib.split(\"\\\\s+\");\n+               }\n+           }\n+           return new String[0];\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private Configuration systemConfiguration() {\n+        ModuleFinder systemFinder = ModuleFinder.ofSystem();\n+        Configuration system = Configuration.resolve(systemFinder, List.of(Configuration.empty()), ModuleFinder.of(),\n+                allModuleNames(systemFinder)); \/\/ resolve all of them\n+        return system;\n+    }\n+\n+    private List<String> allModuleNames(ModuleFinder finder) {\n+        return finder.findAll().stream().map(mr -> mr.descriptor().name()).toList();\n+    }\n+\n+    private void printNativeAccess(Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> allRestrictedMethods) {\n+        String nativeAccess = allRestrictedMethods.keySet().stream()\n+                .map(ScannedModule::moduleName)\n+                .distinct()\n+                .collect(Collectors.joining(\",\"));\n+        out.println(nativeAccess);\n+    }\n+\n+    private void dumpAll(Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> allRestrictedMethods) {\n+        if (allRestrictedMethods.isEmpty()) {\n+            out.println(\"  <no restricted methods>\");\n+        } else {\n+            allRestrictedMethods.forEach((module, perClass) -> {\n+                out.println(module.path() + \" (\" + module.moduleName() + \"):\");\n+                perClass.forEach((classDesc, restrictedUses) -> {\n+                    out.println(\"  \" + qualName(classDesc) + \":\");\n+                    restrictedUses.forEach(use -> {\n+                        switch (use) {\n+                            case RestrictedUse.NativeMethodDecl(MethodRef nmd) ->\n+                                out.println(\"    \" + nmd + \" is a native method declaration\");\n+                            case RestrictedUse.RestrictedMethodRefs(MethodRef referent, Set<MethodRef> referees) -> {\n+                                out.println(\"    \" + referent + \" references restricted methods:\");\n+                                referees.forEach(referee -> out.println(\"      \" + referee));\n+                            }\n+                        }\n+                    });\n+                });\n+            });\n+        }\n+    }\n+\n+    private static void checkRegularJar(Path path) throws JNativeScanFatalError {\n+        if (!(Files.exists(path) && Files.isRegularFile(path) && path.toString().endsWith(\".jar\"))) {\n+            throw new JNativeScanFatalError(\"File does not exist, or does not appear to be a regular jar file: \" + path);\n+        }\n+    }\n+\n+    public enum Action {\n+        DUMP_ALL,\n+        PRINT\n+    }\n+\n+    public static String qualName(ClassDesc desc) {\n+        String packagePrefix = desc.packageName().isEmpty() ? \"\" : desc.packageName() + \".\";\n+        return packagePrefix + desc.displayName();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/JNativeScanTask.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import jdk.internal.joptsimple.*;\n+import jdk.internal.opt.CommandLine;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+\n+public class Main {\n+\n+    private static boolean DEBUG = Boolean.getBoolean(\"com.sun.tools.jnativescan.DEBUG\");\n+\n+    private static final int SUCCESS_CODE = 0;\n+    private static final int FATAL_ERROR_CODE = 1;\n+\n+    private final PrintWriter out;\n+    private final PrintWriter err;\n+\n+    private Main(PrintWriter out, PrintWriter err) {\n+        this.out = out;\n+        this.err = err;\n+    }\n+\n+    private void printError(String message) {\n+        err.println(\"ERROR: \" + message);\n+    }\n+\n+    private void printUsage()  {\n+        out.print(\"\"\"\n+            Use 'jnativescan --help' for help\n+            \"\"\");\n+    }\n+\n+    private void printVersion() {\n+        out.println(\"jnativescan \" + Runtime.version());\n+    }\n+\n+    public int run(String[] args) {\n+        if (args.length < 1) {\n+            printUsage();\n+            return FATAL_ERROR_CODE;\n+        }\n+\n+        try {\n+            String[] expandedArgs = expandArgFiles(args);\n+            parseOptionsAndRun(expandedArgs);\n+        } catch (JNativeScanFatalError fatalError) {\n+            printError(fatalError.getMessage());\n+            if (DEBUG) {\n+                fatalError.printStackTrace(err);\n+            }\n+            return FATAL_ERROR_CODE;\n+        } catch (Throwable e) {\n+            printError(\"Unexpected exception encountered\");\n+            e.printStackTrace(err);\n+            return FATAL_ERROR_CODE;\n+        }\n+\n+        return SUCCESS_CODE;\n+    }\n+\n+    private void parseOptionsAndRun(String[] expandedArgs) throws JNativeScanFatalError {\n+        OptionParser parser = new OptionParser(false);\n+        OptionSpec<Void> helpOpt = parser.acceptsAll(List.of(\"?\", \"h\", \"help\"), \"help\").forHelp();\n+        OptionSpec<Void> versionOpt = parser.accepts(\"version\", \"Print version information and exit\");\n+        OptionSpec<String> classPathOpt = parser.accepts(\n+                \"class-path\",\n+                \"The class path as used at runtime\")\n+                .withRequiredArg();\n+        OptionSpec<String> modulePathOpt = parser.accepts(\n+                \"module-path\",\n+                \"The module path as used at runtime\")\n+                .withRequiredArg();\n+        OptionSpec<String> releaseOpt = parser.accepts(\n+                \"release\",\n+                \"The runtime version that will run the application\")\n+                .withRequiredArg();\n+        OptionSpec<String> addModulesOpt = parser.accepts(\n+                \"add-modules\",\n+                \"List of root modules to scan\")\n+                .withRequiredArg();\n+        OptionSpec<Void> printNativeAccessOpt = parser.accepts(\n+                \"print-native-access\",\n+                \"print a comma separated list of modules that may perform native access operations.\" +\n+                        \"ALL-UNNAMED is used to indicate unnamed modules.\");\n+\n+        OptionSet optionSet;\n+        try {\n+            optionSet = parser.parse(expandedArgs);\n+        } catch (OptionException oe) {\n+            throw new JNativeScanFatalError(\"Parsing options failed: \" + oe.getMessage(), oe);\n+        }\n+\n+        if (optionSet.has(helpOpt)) {\n+            out.println(\"\"\"\n+                The jnativescan tool can be used to find methods that may access native functionality when\n+                run. This includes methods that call restricted methods, and 'native' method declarations.\n+                \"\"\");\n+            try {\n+                parser.printHelpOn(out);\n+                return;\n+            } catch (IOException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+\n+        if (optionSet.has(versionOpt)) {\n+            printVersion();\n+            return;\n+        }\n+\n+        List<Path> classPathJars = parsePath(optionSet, classPathOpt);\n+        List<Path> modulePaths = parsePath(optionSet, modulePathOpt);\n+\n+        Runtime.Version version = Runtime.version();\n+        if (optionSet.has(releaseOpt)) {\n+            String release = optionSet.valueOf(releaseOpt);\n+            try {\n+                version = Runtime.Version.parse(release);\n+            } catch (IllegalArgumentException e) {\n+                throw new JNativeScanFatalError(\"Invalid release: \" + release + \": \" + e.getMessage());\n+            }\n+        }\n+\n+        JNativeScanTask.Action action = JNativeScanTask.Action.DUMP_ALL;\n+        if (optionSet.has(printNativeAccessOpt)) {\n+            action = JNativeScanTask.Action.PRINT;\n+        }\n+\n+        List<String> rootModules = List.of();\n+        if (optionSet.has(addModulesOpt)) {\n+            rootModules = List.of(optionSet.valueOf(addModulesOpt).split(\",\"));\n+        }\n+\n+        new JNativeScanTask(out, classPathJars, modulePaths, rootModules, version, action).run();\n+    }\n+\n+    private static List<Path> parsePath(OptionSet optionSet, OptionSpec<String> opt) throws JNativeScanFatalError {\n+        List<Path> paths = new ArrayList<>();\n+        if (optionSet.has(opt)) {\n+            String[] parts = optionSet.valueOf(opt).split(File.pathSeparator);\n+            for (String part : parts) {\n+                Path path = Path.of(part);\n+                paths.add(path);\n+            }\n+        }\n+        return paths;\n+    }\n+\n+    private static String[] expandArgFiles(String[] args) throws JNativeScanFatalError {\n+        try {\n+            return CommandLine.parse(args);\n+        } catch (IOException e) { \/\/ file not found\n+            throw new JNativeScanFatalError(e.getMessage(), e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.exit(new Main.Provider().run(System.out, System.err, args));\n+    }\n+\n+    public static class Provider implements ToolProvider {\n+\n+        @Override\n+        public String name() {\n+            return \"jnativescan\";\n+        }\n+\n+        @Override\n+        public int run(PrintWriter out, PrintWriter err, String... args) {\n+            return new Main(out, err).run(args);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/Main.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.InterfaceMethodRefEntry;\n+import java.lang.classfile.constantpool.MemberRefEntry;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+\n+record MethodRef(ClassDesc owner, String name, MethodTypeDesc type) {\n+    public static MethodRef ofModel(MethodModel model) {\n+        return new MethodRef(model.parent().orElseThrow().thisClass().asSymbol(),\n+                model.methodName().stringValue(), model.methodTypeSymbol());\n+    }\n+\n+    public static MethodRef ofMethodRefEntry(MemberRefEntry method) {\n+        return new MethodRef(method.owner().asSymbol(),\n+                method.name().stringValue(), MethodTypeDesc.ofDescriptor(method.type().stringValue()));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return JNativeScanTask.qualName(owner) + \"::\" + name + type.displayDescriptor();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/MethodRef.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import com.sun.tools.jnativescan.RestrictedUse.NativeMethodDecl;\n+import com.sun.tools.jnativescan.RestrictedUse.RestrictedMethodRefs;\n+\n+import java.io.IOException;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.constantpool.InterfaceMethodRefEntry;\n+import java.lang.classfile.constantpool.MemberRefEntry;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.*;\n+\n+class RestrictedMethodFinder {\n+\n+    \/\/ ct.sym uses this fake name for the restricted annotation instead\n+    \/\/ see make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java\n+    private static final String RESTRICTED_NAME = \"Ljdk\/internal\/javac\/Restricted+Annotation;\";\n+    private static final List<String> RESTRICTED_MODULES = List.of(\"java.base\");\n+\n+    private final Map<MethodRef, Boolean> CACHE = new HashMap<>();\n+    private final ClassResolver classesToScan;\n+    private final ClassResolver systemClassResolver;\n+\n+    private RestrictedMethodFinder(ClassResolver classesToScan, ClassResolver systemClassResolver) {\n+        this.classesToScan = classesToScan;\n+        this.systemClassResolver = systemClassResolver;\n+    }\n+\n+    public static RestrictedMethodFinder create(ClassResolver classesToScan, ClassResolver systemClassResolver) throws JNativeScanFatalError, IOException {\n+        return new RestrictedMethodFinder(classesToScan, systemClassResolver);\n+    }\n+\n+    public Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> findAll() throws JNativeScanFatalError {\n+        Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> restrictedMethods = new HashMap<>();\n+        classesToScan.forEach((_, info) -> {\n+            ClassModel classModel = info.model();\n+            List<RestrictedUse> perClass = new ArrayList<>();\n+            classModel.methods().forEach(methodModel -> {\n+                if (methodModel.flags().has(AccessFlag.NATIVE)) {\n+                    perClass.add(new NativeMethodDecl(MethodRef.ofModel(methodModel)));\n+                } else {\n+                    Set<MethodRef> perMethod = new HashSet<>();\n+                    methodModel.code()\n+                        .ifPresent(code -> {\n+                            code.forEach(e -> {\n+                                switch (e) {\n+                                    case InvokeInstruction invoke -> {\n+                                        if (isRestrictedMethod(invoke.method())) {\n+                                            perMethod.add(MethodRef.ofMethodRefEntry(invoke.method()));\n+                                        }\n+                                    }\n+                                    default -> {\n+                                    }\n+                                }\n+                            });\n+                        });\n+                    if (!perMethod.isEmpty()) {\n+                        perClass.add(new RestrictedMethodRefs(MethodRef.ofModel(methodModel),\n+                                Set.copyOf(perMethod)));\n+                    }\n+                }\n+            });\n+            if (!perClass.isEmpty()) {\n+                ScannedModule scannedModule = new ScannedModule(info.jarPath(), info.moduleName());\n+                restrictedMethods.computeIfAbsent(scannedModule, _ -> new HashMap<>())\n+                        .put(classModel.thisClass().asSymbol(), perClass);\n+            }\n+        });\n+        return restrictedMethods;\n+    }\n+\n+    private boolean isRestrictedMethod(MemberRefEntry method) throws JNativeScanFatalError {\n+        return switch (method) {\n+            case MethodRefEntry mre ->\n+                    isRestrictedMethod(mre.owner().asSymbol(), mre.name().stringValue(), mre.typeSymbol());\n+            case InterfaceMethodRefEntry mre ->\n+                    isRestrictedMethod(mre.owner().asSymbol(), mre.name().stringValue(), mre.typeSymbol());\n+            default -> throw new IllegalStateException(\"Unexpected type: \" + method);\n+        };\n+    }\n+\n+    private boolean isRestrictedMethod(ClassDesc owner, String name, MethodTypeDesc type) throws JNativeScanFatalError {\n+        return CACHE.computeIfAbsent(new MethodRef(owner, name, type), methodRef -> {\n+            if (methodRef.owner().isArray()) {\n+                \/\/ no restricted methods in arrays atm, and we can't look them up since they have no class file\n+                return false;\n+            }\n+            Optional<ClassResolver.Info> info = systemClassResolver.lookup(methodRef.owner());\n+            if (!info.isPresent()) {\n+                return false;\n+            }\n+            ClassModel classModel = info.get().model();\n+            Optional<MethodModel> methodModel = findMethod(classModel, methodRef.name(), methodRef.type());\n+            if (!methodModel.isPresent()) {\n+                \/\/ If we are here, the method was referenced through a subclass of the class containing the actual\n+                \/\/ method declaration. We could implement a method resolver (that needs to be version aware\n+                \/\/ as well) to find the method model of the declaration, but it's not really worth it.\n+                \/\/ None of the restricted methods (atm) are exposed through more than 1 public type, so it's not\n+                \/\/ possible for user code to reference them through a subclass.\n+                return false;\n+            }\n+\n+            return hasRestrictedAnnotation(methodModel.get());\n+        });\n+    }\n+\n+    private static boolean hasRestrictedAnnotation(MethodModel method) {\n+        return method.findAttribute(Attributes.runtimeVisibleAnnotations())\n+                .map(rva -> rva.annotations().stream().anyMatch(ann ->\n+                        ann.className().stringValue().equals(RESTRICTED_NAME)))\n+                .orElse(false);\n+    }\n+\n+    private static Optional<MethodModel> findMethod(ClassModel classModel, String name, MethodTypeDesc type) {\n+        return classModel.methods().stream()\n+                .filter(m -> m.methodName().stringValue().equals(name)\n+                        && m.methodType().stringValue().equals(type.descriptorString()))\n+                .findFirst();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/RestrictedMethodFinder.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.util.Set;\n+\n+sealed interface RestrictedUse {\n+    record RestrictedMethodRefs(MethodRef referent, Set<MethodRef> referees) implements RestrictedUse {}\n+    record NativeMethodDecl(MethodRef decl) implements RestrictedUse {}\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/RestrictedUse.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import java.nio.file.Path;\n+\n+record ScannedModule(Path path, String moduleName) {\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ScannedModule.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+    requires jdk.internal.opt;\n+\n+    uses com.sun.tools.javac.platform.PlatformProvider;\n@@ -71,1 +74,2 @@\n-        com.sun.tools.jdeps.Main.JDepsToolProvider;\n+        com.sun.tools.jdeps.Main.JDepsToolProvider,\n+        com.sun.tools.jnativescan.Main.Provider;\n","filename":"src\/jdk.jdeps\/share\/classes\/module-info.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+        new ToolHelpSpec(\"jnativescan\", 1,   1,   1,   0,         1,    0,     1),     \/\/ -?, -h, --help, -help accepted but not documented.\n","filename":"test\/jdk\/tools\/launcher\/HelpFlagsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,4 @@\n+langtools_jnativescan = \\\n+    tools\/all \\\n+    tools\/jnativescan\n+\n","filename":"test\/langtools\/TEST.groups","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+\n+import java.io.StringWriter;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+public class JNativeScanTestBase {\n+\n+    public static final String MODULE_PATH = \"mods\";\n+\n+    private static final ToolProvider JNATIVESCAN_TOOL = ToolProvider.findFirst(\"jnativescan\")\n+            .orElseThrow(() -> new RuntimeException(\"jnativescan tool not found\"));\n+\n+    public static OutputAnalyzer jnativescan(String... args) {\n+        return run(JNATIVESCAN_TOOL, args);\n+    }\n+\n+    private static OutputAnalyzer run(ToolProvider tp, String[] commands) {\n+        int rc;\n+        StringWriter sw = new StringWriter();\n+        StringWriter esw = new StringWriter();\n+\n+        try (PrintWriter pw = new PrintWriter(sw);\n+             PrintWriter epw = new PrintWriter(esw)) {\n+            System.out.println(\"Running \" + tp.name() + \", Command: \" + Arrays.toString(commands));\n+            rc = tp.run(pw, epw, commands);\n+        }\n+        OutputAnalyzer output = new OutputAnalyzer(sw.toString(), esw.toString(), rc);\n+        output.outputTo(System.out);\n+        output.errorTo(System.err);\n+        return output;\n+    }\n+\n+    public static Path makeModularJar(String moduleName) throws IOException {\n+        Path jarPath = Path.of(MODULE_PATH, moduleName + \".jar\");\n+        Path moduleRoot = moduleRoot(moduleName);\n+        JarUtils.createJarFile(jarPath, moduleRoot);\n+        return jarPath;\n+    }\n+\n+    public static Path moduleRoot(String name) {\n+        return Path.of(System.getProperty(\"test.module.path\")).resolve(name);\n+    }\n+\n+    public static OutputAnalyzer assertSuccess(OutputAnalyzer output) {\n+        if (output.getExitValue() != 0) {\n+            throw new IllegalStateException(\"tool run failed\");\n+        }\n+        return output;\n+    }\n+\n+    public static OutputAnalyzer assertFailure(OutputAnalyzer output) {\n+        if (output.getExitValue() == 0) {\n+            throw new IllegalStateException(\"tool run succeeded\");\n+        }\n+        return output;\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/JNativeScanTestBase.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ *     cases.classpath.arrayref.App\n+ * @run testng TestArrayTypeRefs\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class TestArrayTypeRefs extends JNativeScanTestBase {\n+\n+    Path arrayRef;\n+\n+    @BeforeClass\n+    public void before() throws IOException {\n+        arrayRef = Path.of(\"arrayref.jar\");\n+        Path testClasses = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(arrayRef, testClasses, Path.of(\"arrayref\", \"App.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertSuccess(jnativescan(\"--class-path\", arrayRef.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"<no restricted methods>\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestArrayTypeRefs.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ *     org.singlejar\/* org.lib\/* org.myapp\/* org.service\/*\n+ *     cases.classpath.singlejar.main.Main\n+ *     cases.classpath.lib.Lib\n+ *     cases.classpath.app.App\n+ *     cases.classpath.unnamed_package.UnnamedPackage\n+ * @run testng TestJNativeScan\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+class TestJNativeScan extends JNativeScanTestBase {\n+\n+    Path testClasses;\n+\n+    Path classPathApp;\n+    Path singleJarClassPath;\n+    Path singleJarModular;\n+    Path orgMyapp;\n+    Path orgLib;\n+    Path unnamedPackageJar;\n+\n+    @BeforeClass\n+    public void before() throws IOException {\n+        singleJarClassPath = Path.of(\"singleJar.jar\");\n+        testClasses = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(singleJarClassPath, testClasses, Path.of(\"main\", \"Main.class\"));\n+\n+        JarUtils.createJarFile(Path.of(\"lib.jar\"), testClasses, Path.of(\"lib\", \"Lib.class\"));\n+        Manifest manifest = new Manifest();\n+        Attributes mainAttrs = manifest.getMainAttributes();\n+        mainAttrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\"); \/\/ need version or other attributes will be ignored\n+        mainAttrs.putValue(\"Class-Path\", \"lib.jar non-existent.jar\");\n+        classPathApp = Path.of(\"app.jar\");\n+        JarUtils.createJarFile(classPathApp, manifest, testClasses, Path.of(\"app\", \"App.class\"));\n+\n+        singleJarModular = makeModularJar(\"org.singlejar\");\n+        orgMyapp = makeModularJar(\"org.myapp\");\n+        orgLib = makeModularJar(\"org.lib\");\n+        makeModularJar(\"org.service\");\n+\n+        unnamedPackageJar = Path.of(\"unnamed_package.jar\");\n+        JarUtils.createJarFile(unnamedPackageJar, manifest, testClasses, Path.of(\"UnnamedPackage.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertSuccess(jnativescan(\"--class-path\", singleJarClassPath.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"main.Main\")\n+                .stdoutShouldContain(\"main.Main::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"main.Main::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testSingleJarModulePath() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"org.singlejar\"))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"org.singlejar\")\n+                .stdoutShouldContain(\"org.singlejar.main.Main\")\n+                .stdoutShouldContain(\"org.singlejar.main.Main::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"org.singlejar.main.Main::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testWithDepModule() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"org.myapp\"))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"org.lib\")\n+                .stdoutShouldContain(\"org.lib.Lib\")\n+                .stdoutShouldContain(\"org.lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"org.lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\")\n+                .stdoutShouldContain(\"org.service\")\n+                .stdoutShouldContain(\"org.service.ServiceImpl\")\n+                .stdoutShouldContain(\"org.service.ServiceImpl::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"org.service.ServiceImpl::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testAllModulePath() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"ALL-MODULE-PATH\"))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"org.singlejar\")\n+                .stdoutShouldContain(\"org.lib\")\n+                .stdoutShouldContain(\"org.service\");\n+    }\n+\n+    @Test\n+    public void testClassPathAttribute() {\n+        assertSuccess(jnativescan(\"--class-path\", classPathApp.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldContain(\"lib.Lib\")\n+                .stdoutShouldContain(\"lib.Lib::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"lib.Lib::doIt()void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+\n+    @Test\n+    public void testInvalidRelease() {\n+        assertFailure(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"ALL-MODULE-PATH\", \"--release\", \"asdf\"))\n+                .stderrShouldContain(\"Invalid release\");\n+    }\n+\n+    @Test\n+    public void testReleaseNotSupported() {\n+        assertFailure(jnativescan(\"--module-path\", MODULE_PATH, \"--add-modules\", \"ALL-MODULE-PATH\", \"--release\", \"9999999\"))\n+                .stderrShouldContain(\"Release: 9999999 not supported\");\n+    }\n+\n+    @Test\n+    public void testFileDoesNotExist() {\n+        assertFailure(jnativescan(\"--class-path\", \"non-existent.jar\"))\n+                .stderrShouldContain(\"File does not exist, or does not appear to be a regular jar file\");\n+    }\n+\n+    @Test\n+    public void testModuleNotAJarFile() {\n+        String modulePath = moduleRoot(\"org.myapp\").toString() + File.pathSeparator + orgLib.toString();\n+        assertFailure(jnativescan(\"--module-path\", modulePath,\n+                        \"--add-modules\", \"ALL-MODULE-PATH\"))\n+                .stderrShouldContain(\"File does not exist, or does not appear to be a regular jar file\");\n+    }\n+\n+    @Test\n+    public void testPrintNativeAccess() {\n+        assertSuccess(jnativescan(\"--module-path\", MODULE_PATH,\n+                                  \"-add-modules\", \"org.singlejar,org.myapp\",\n+                                  \"--print-native-access\"))\n+                .stdoutShouldContain(\"org.singlejar\")\n+                .stdoutShouldContain(\"org.lib\")\n+                .stdoutShouldContain(\"org.service\");\n+    }\n+\n+    @Test\n+    public void testNoDuplicateNames() {\n+        String classPath = singleJarClassPath + File.pathSeparator + classPathApp;\n+        OutputAnalyzer output = assertSuccess(jnativescan(\"--class-path\", classPath, \"--print-native-access\"));\n+        String[] moduleNames = output.getStdout().split(\",\");\n+        Set<String> names = new HashSet<>();\n+        for (String name : moduleNames) {\n+            assertTrue(names.add(name.strip()));\n+        }\n+    }\n+\n+    @Test\n+    public void testUnnamedPackage() {\n+        assertSuccess(jnativescan(\"--class-path\", unnamedPackageJar.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"ALL-UNNAMED\")\n+                .stdoutShouldNotContain(\".UnnamedPackage\")\n+                .stdoutShouldContain(\"UnnamedPackage\")\n+                .stdoutShouldContain(\"UnnamedPackage::m()void is a native method declaration\")\n+                .stdoutShouldContain(\"UnnamedPackage::main(String[])void references restricted methods\")\n+                .stdoutShouldContain(\"java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestJNativeScan.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ *     cases.classpath.subclassref.App\n+ * @run testng TestSubclassRefs\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class TestSubclassRefs extends JNativeScanTestBase {\n+\n+    Path subclassRef;\n+\n+    @BeforeClass\n+    public void before() throws IOException {\n+        subclassRef = Path.of(\"subclassref.jar\");\n+        Path testClasses = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(subclassRef, testClasses, Path.of(\"subclassref\", \"App.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertSuccess(jnativescan(\"--class-path\", subclassRef.toString()))\n+                .stderrShouldBeEmpty()\n+                .stdoutShouldContain(\"<no restricted methods>\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestSubclassRefs.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package app;\n+\n+import lib.Lib;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        Lib.doIt();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/app\/App.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package arrayref;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        \/\/ reference an array method to see that\n+        \/\/ RestrictedMethodFinder correctly handles\n+        \/\/ references to array methods\n+        args.clone();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/arrayref\/App.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package lib;\n+\n+import java.lang.foreign.MemorySegment;\n+\n+public class Lib {\n+    public static void doIt() {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/lib\/Lib.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package main;\n+\n+import java.lang.foreign.*;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/singlejar\/main\/Main.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package subclassref;\n+\n+import java.util.List;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        List<String> l = List.of(args);\n+        l.stream(); \/\/ List does not declare stream()\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/subclassref\/App.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.foreign.*;\n+\n+public class UnnamedPackage {\n+    public static void main(String[] args) {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/unnamed_package\/UnnamedPackage.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module org.lib {\n+    exports org.lib;\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.lib\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.lib;\n+\n+import java.lang.foreign.*;\n+\n+public class Lib {\n+    public static void doIt() {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.lib\/org\/lib\/Lib.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.lib;\n+\n+public interface Service {\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.lib\/org\/lib\/Service.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module org.myapp {\n+    requires org.lib;\n+\n+    uses org.lib.Service;\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.myapp\/module-info.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.myapp.main;\n+\n+import org.lib.Lib;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        Lib.doIt();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.myapp\/org\/myapp\/main\/Main.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module org.service {\n+    requires org.lib;\n+\n+    provides org.lib.Service with org.service.ServiceImpl;\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.service\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.service;\n+\n+import org.lib.Service;\n+\n+import java.lang.foreign.MemorySegment;\n+\n+public class ServiceImpl implements Service {\n+    public void doIt() {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.service\/org\/service\/ServiceImpl.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module org.singlejar {\n+\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.singlejar\/module-info.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.singlejar.main;\n+\n+import java.lang.foreign.*;\n+\n+public class Main {\n+    public static void main(String[] args) {\n+        MemorySegment.ofAddress(1234).reinterpret(10);\n+    }\n+\n+    private static native void m();\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/modules\/org.singlejar\/org\/singlejar\/main\/Main.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}