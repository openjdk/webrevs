{"files":[{"patch":"@@ -38,2 +38,0 @@\n-import java.lang.module.ModuleFinder;\n-import java.lang.module.ModuleReference;\n@@ -122,1 +120,1 @@\n-            this.packageToSystemModule = packageToSystemModule();\n+            this.packageToSystemModule = packageToSystemModule(platformFileManager);\n@@ -125,11 +123,13 @@\n-        private static Map<String, String> packageToSystemModule() {\n-            List<ModuleDescriptor> descriptors = ModuleFinder.ofSystem()\n-                    .findAll()\n-                    .stream()\n-                    .map(ModuleReference::descriptor)\n-                    .toList();\n-            Map<String, String> result = new HashMap<>();\n-            for (ModuleDescriptor descriptor : descriptors) {\n-                for (ModuleDescriptor.Exports export : descriptor.exports()) {\n-                    if (!export.isQualified()) {\n-                        result.put(export.source(), descriptor.name());\n+        private static Map<String, String> packageToSystemModule(JavaFileManager platformFileManager) {\n+            try {\n+                Set<JavaFileManager.Location> locations = platformFileManager.listLocationsForModules(\n+                        StandardLocation.SYSTEM_MODULES).iterator().next();\n+\n+                Map<String, String> result = new HashMap<>();\n+                for (JavaFileManager.Location loc : locations) {\n+                    JavaFileObject jfo = platformFileManager.getJavaFileForInput(loc, \"module-info\", JavaFileObject.Kind.CLASS);\n+                    ModuleDescriptor descriptor = ModuleDescriptor.read(jfo.openInputStream());\n+                    for (ModuleDescriptor.Exports export : descriptor.exports()) {\n+                        if (!export.isQualified()) {\n+                            result.put(export.source(), descriptor.name());\n+                        }\n@@ -138,0 +138,3 @@\n+                return result;\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n@@ -139,1 +142,0 @@\n-            return result;\n@@ -156,0 +158,3 @@\n+                        if (jfo == null) {\n+                            throw new JNativeScanFatalError(\"System class can not be found: \" + qualName);\n+                        }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/ClassResolver.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-            RestrictedMethodFinder finder = RestrictedMethodFinder.create(classesToScan, systemClassResolver);\n+            NativeMethodFinder finder = NativeMethodFinder.create(classesToScan, systemClassResolver);\n@@ -85,1 +85,1 @@\n-        } catch (Exception e) {\n+        } catch (IOException e) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/JNativeScanTask.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,0 +78,5 @@\n+            for (Throwable cause = fatalError.getCause();\n+                     cause instanceof JNativeScanFatalError jNativeScanFatalError;\n+                     cause = jNativeScanFatalError.getCause()) {\n+                err.println(\"CAUSED BY: \" + jNativeScanFatalError.getMessage());\n+            }\n@@ -125,2 +130,2 @@\n-                The jnativescan tool can be used to find methods that may access native functionalities when\n-                run. This includes methods that call restricted methods, and 'native' method declarations.\n+                The jnativescan tool can be used to find methods that may access native functionality when\n+                run. This includes restricted method calls and 'native' method declarations.\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/Main.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.classfile.constantpool.ClassEntry;\n-import java.lang.classfile.constantpool.InterfaceMethodRefEntry;\n@@ -40,1 +38,1 @@\n-    public static MethodRef ofMethodRefEntry(MemberRefEntry method) {\n+    public static MethodRef ofMemberRefEntry(MemberRefEntry method) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/MethodRef.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.tools.jnativescan;\n+\n+import com.sun.tools.jnativescan.RestrictedUse.NativeMethodDecl;\n+import com.sun.tools.jnativescan.RestrictedUse.RestrictedMethodRefs;\n+\n+import java.io.IOException;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.constantpool.InterfaceMethodRefEntry;\n+import java.lang.classfile.constantpool.MemberRefEntry;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.*;\n+\n+class NativeMethodFinder {\n+\n+    \/\/ ct.sym uses this fake name for the restricted annotation instead\n+    \/\/ see make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java\n+    private static final String RESTRICTED_NAME = \"Ljdk\/internal\/javac\/Restricted+Annotation;\";\n+\n+    private final Map<MethodRef, Boolean> CACHE = new HashMap<>();\n+    private final ClassResolver classesToScan;\n+    private final ClassResolver systemClassResolver;\n+\n+    private NativeMethodFinder(ClassResolver classesToScan, ClassResolver systemClassResolver) {\n+        this.classesToScan = classesToScan;\n+        this.systemClassResolver = systemClassResolver;\n+    }\n+\n+    public static NativeMethodFinder create(ClassResolver classesToScan, ClassResolver systemClassResolver) throws JNativeScanFatalError, IOException {\n+        return new NativeMethodFinder(classesToScan, systemClassResolver);\n+    }\n+\n+    public Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> findAll() throws JNativeScanFatalError {\n+        Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> restrictedMethods = new HashMap<>();\n+        classesToScan.forEach((_, info) -> {\n+            ClassModel classModel = info.model();\n+            List<RestrictedUse> perClass = new ArrayList<>();\n+            classModel.methods().forEach(methodModel -> {\n+                if (methodModel.flags().has(AccessFlag.NATIVE)) {\n+                    perClass.add(new NativeMethodDecl(MethodRef.ofModel(methodModel)));\n+                } else {\n+                    Set<MethodRef> perMethod = new HashSet<>();\n+                    methodModel.code().ifPresent(code -> {\n+                         try {\n+                             code.forEach(e -> {\n+                                 switch (e) {\n+                                     case InvokeInstruction invoke -> {\n+                                         MethodRef ref = MethodRef.ofMemberRefEntry(invoke.method());\n+                                         if (isRestrictedMethod(ref)) {\n+                                             perMethod.add(ref);\n+                                         }\n+                                     }\n+                                     default -> {\n+                                     }\n+                                 }\n+                             });\n+                         } catch (JNativeScanFatalError e) {\n+                             throw new JNativeScanFatalError(\"Error while processing method: \" +\n+                                     MethodRef.ofModel(methodModel), e);\n+                         }\n+                    });\n+                    if (!perMethod.isEmpty()) {\n+                        perClass.add(new RestrictedMethodRefs(MethodRef.ofModel(methodModel),\n+                                Set.copyOf(perMethod)));\n+                    }\n+                }\n+            });\n+            if (!perClass.isEmpty()) {\n+                ScannedModule scannedModule = new ScannedModule(info.jarPath(), info.moduleName());\n+                restrictedMethods.computeIfAbsent(scannedModule, _ -> new HashMap<>())\n+                        .put(classModel.thisClass().asSymbol(), perClass);\n+            }\n+        });\n+        return restrictedMethods;\n+    }\n+\n+    private boolean isRestrictedMethod(MethodRef ref) throws JNativeScanFatalError {\n+        return CACHE.computeIfAbsent(ref, methodRef -> {\n+            if (methodRef.owner().isArray()) {\n+                \/\/ no restricted methods in arrays atm, and we can't look them up since they have no class file\n+                return false;\n+            }\n+            Optional<ClassResolver.Info> info = systemClassResolver.lookup(methodRef.owner());\n+            if (!info.isPresent()) {\n+                return false;\n+            }\n+            ClassModel classModel = info.get().model();\n+            Optional<MethodModel> methodModel = findMethod(classModel, methodRef.name(), methodRef.type());\n+            if (!methodModel.isPresent()) {\n+                \/\/ If we are here, the method was referenced through a subclass of the class containing the actual\n+                \/\/ method declaration. We could implement a method resolver (that needs to be version aware\n+                \/\/ as well) to find the method model of the declaration, but it's not really worth it.\n+                \/\/ None of the restricted methods (atm) are exposed through more than 1 public type, so it's not\n+                \/\/ possible for user code to reference them through a subclass.\n+                return false;\n+            }\n+\n+            return hasRestrictedAnnotation(methodModel.get());\n+        });\n+    }\n+\n+    private static boolean hasRestrictedAnnotation(MethodModel method) {\n+        return method.findAttribute(Attributes.runtimeVisibleAnnotations())\n+                .map(rva -> rva.annotations().stream().anyMatch(ann ->\n+                        ann.className().stringValue().equals(RESTRICTED_NAME)))\n+                .orElse(false);\n+    }\n+\n+    private static Optional<MethodModel> findMethod(ClassModel classModel, String name, MethodTypeDesc type) {\n+        return classModel.methods().stream()\n+                .filter(m -> m.methodName().stringValue().equals(name)\n+                        && m.methodType().stringValue().equals(type.descriptorString()))\n+                .findFirst();\n+    }\n+}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/NativeMethodFinder.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.tools.jnativescan;\n-\n-import com.sun.tools.jnativescan.RestrictedUse.NativeMethodDecl;\n-import com.sun.tools.jnativescan.RestrictedUse.RestrictedMethodRefs;\n-\n-import java.io.IOException;\n-import java.lang.classfile.Attributes;\n-import java.lang.classfile.ClassModel;\n-import java.lang.classfile.MethodModel;\n-import java.lang.classfile.constantpool.InterfaceMethodRefEntry;\n-import java.lang.classfile.constantpool.MemberRefEntry;\n-import java.lang.classfile.constantpool.MethodRefEntry;\n-import java.lang.classfile.instruction.InvokeInstruction;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.reflect.AccessFlag;\n-import java.util.*;\n-\n-class RestrictedMethodFinder {\n-\n-    \/\/ ct.sym uses this fake name for the restricted annotation instead\n-    \/\/ see make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java\n-    private static final String RESTRICTED_NAME = \"Ljdk\/internal\/javac\/Restricted+Annotation;\";\n-    private static final List<String> RESTRICTED_MODULES = List.of(\"java.base\");\n-\n-    private final Map<MethodRef, Boolean> CACHE = new HashMap<>();\n-    private final ClassResolver classesToScan;\n-    private final ClassResolver systemClassResolver;\n-\n-    private RestrictedMethodFinder(ClassResolver classesToScan, ClassResolver systemClassResolver) {\n-        this.classesToScan = classesToScan;\n-        this.systemClassResolver = systemClassResolver;\n-    }\n-\n-    public static RestrictedMethodFinder create(ClassResolver classesToScan, ClassResolver systemClassResolver) throws JNativeScanFatalError, IOException {\n-        return new RestrictedMethodFinder(classesToScan, systemClassResolver);\n-    }\n-\n-    public Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> findAll() throws JNativeScanFatalError {\n-        Map<ScannedModule, Map<ClassDesc, List<RestrictedUse>>> restrictedMethods = new HashMap<>();\n-        classesToScan.forEach((_, info) -> {\n-            ClassModel classModel = info.model();\n-            List<RestrictedUse> perClass = new ArrayList<>();\n-            classModel.methods().forEach(methodModel -> {\n-                if (methodModel.flags().has(AccessFlag.NATIVE)) {\n-                    perClass.add(new NativeMethodDecl(MethodRef.ofModel(methodModel)));\n-                } else {\n-                    Set<MethodRef> perMethod = new HashSet<>();\n-                    methodModel.code()\n-                        .ifPresent(code -> {\n-                            code.forEach(e -> {\n-                                switch (e) {\n-                                    case InvokeInstruction invoke -> {\n-                                        if (isRestrictedMethod(invoke.method())) {\n-                                            perMethod.add(MethodRef.ofMethodRefEntry(invoke.method()));\n-                                        }\n-                                    }\n-                                    default -> {\n-                                    }\n-                                }\n-                            });\n-                        });\n-                    if (!perMethod.isEmpty()) {\n-                        perClass.add(new RestrictedMethodRefs(MethodRef.ofModel(methodModel),\n-                                Set.copyOf(perMethod)));\n-                    }\n-                }\n-            });\n-            if (!perClass.isEmpty()) {\n-                ScannedModule scannedModule = new ScannedModule(info.jarPath(), info.moduleName());\n-                restrictedMethods.computeIfAbsent(scannedModule, _ -> new HashMap<>())\n-                        .put(classModel.thisClass().asSymbol(), perClass);\n-            }\n-        });\n-        return restrictedMethods;\n-    }\n-\n-    private boolean isRestrictedMethod(MemberRefEntry method) throws JNativeScanFatalError {\n-        return switch (method) {\n-            case MethodRefEntry mre ->\n-                    isRestrictedMethod(mre.owner().asSymbol(), mre.name().stringValue(), mre.typeSymbol());\n-            case InterfaceMethodRefEntry mre ->\n-                    isRestrictedMethod(mre.owner().asSymbol(), mre.name().stringValue(), mre.typeSymbol());\n-            default -> throw new IllegalStateException(\"Unexpected type: \" + method);\n-        };\n-    }\n-\n-    private boolean isRestrictedMethod(ClassDesc owner, String name, MethodTypeDesc type) throws JNativeScanFatalError {\n-        return CACHE.computeIfAbsent(new MethodRef(owner, name, type), methodRef -> {\n-            if (methodRef.owner().isArray()) {\n-                \/\/ no restricted methods in arrays atm, and we can't look them up since they have no class file\n-                return false;\n-            }\n-            Optional<ClassResolver.Info> info = systemClassResolver.lookup(methodRef.owner());\n-            if (!info.isPresent()) {\n-                return false;\n-            }\n-            ClassModel classModel = info.get().model();\n-            Optional<MethodModel> methodModel = findMethod(classModel, methodRef.name(), methodRef.type());\n-            if (!methodModel.isPresent()) {\n-                \/\/ If we are here, the method was referenced through a subclass of the class containing the actual\n-                \/\/ method declaration. We could implement a method resolver (that needs to be version aware\n-                \/\/ as well) to find the method model of the declaration, but it's not really worth it.\n-                \/\/ None of the restricted methods (atm) are exposed through more than 1 public type, so it's not\n-                \/\/ possible for user code to reference them through a subclass.\n-                return false;\n-            }\n-\n-            return hasRestrictedAnnotation(methodModel.get());\n-        });\n-    }\n-\n-    private static boolean hasRestrictedAnnotation(MethodModel method) {\n-        return method.findAttribute(Attributes.runtimeVisibleAnnotations())\n-                .map(rva -> rva.annotations().stream().anyMatch(ann ->\n-                        ann.className().stringValue().equals(RESTRICTED_NAME)))\n-                .orElse(false);\n-    }\n-\n-    private static Optional<MethodModel> findMethod(ClassModel classModel, String name, MethodTypeDesc type) {\n-        return classModel.methods().stream()\n-                .filter(m -> m.methodName().stringValue().equals(name)\n-                        && m.methodType().stringValue().equals(type.descriptorString()))\n-                .findFirst();\n-    }\n-}\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jnativescan\/RestrictedMethodFinder.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -31,2 +31,3 @@\n- * <em>{@index javap javap tool}<\/em>, and\n- * <em>{@index jdeprscan jdeprscan tool}<\/em> tools.\n+ * <em>{@index javap javap tool}<\/em>,\n+ * <em>{@index jdeprscan jdeprscan tool}<\/em>, and\n+ * <em>{@index jnativescan jnativescan tool}<\/em> tools.\n@@ -36,1 +37,1 @@\n- * <em>javap<\/em> and <em>jdeps<\/em> tools via the\n+ * <em>javap<\/em>, <em>jdeps<\/em>, and <em>jnativescan<\/em> tools via the\n@@ -52,0 +53,1 @@\n+ * @toolGuide jnativescan\n@@ -54,2 +56,3 @@\n- *     Use {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"javap\")}\n- *     or {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"jdeps\")}\n+ *     Use {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"javap\")},\n+ *     {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"jdeps\")},\n+ *     or {@link java.util.spi.ToolProvider#findFirst ToolProvider.findFirst(\"jnativescan\")}\n@@ -57,1 +60,1 @@\n- *     of command-line access to the {@code javap} or {@code jdeps} tool.\n+ *     of command-line access to the {@code javap}, {@code jdeps}, {@code jnativescan} tool.\n","filename":"src\/jdk.jdeps\/share\/classes\/module-info.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+.\\\" Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+.\\\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+.\\\"\n+.\\\" This code is free software; you can redistribute it and\/or modify it\n+.\\\" under the terms of the GNU General Public License version 2 only, as\n+.\\\" published by the Free Software Foundation.\n+.\\\"\n+.\\\" This code is distributed in the hope that it will be useful, but WITHOUT\n+.\\\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+.\\\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+.\\\" version 2 for more details (a copy is included in the LICENSE file that\n+.\\\" accompanied this code).\n+.\\\"\n+.\\\" You should have received a copy of the GNU General Public License version\n+.\\\" 2 along with this work; if not, write to the Free Software Foundation,\n+.\\\" Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+.\\\"\n+.\\\" Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+.\\\" or visit www.oracle.com if you need additional information or have any\n+.\\\" questions.\n+.\\\"\n+.\\\" Automatically generated by Pandoc 2.19.2\n+.\\\"\n+.\\\" Define V font for inline verbatim, using C font in formats\n+.\\\" that render this, and otherwise B font.\n+.ie \"\\f[CB]x\\f[R]\"x\" \\{\\\n+. ftr V B\n+. ftr VI BI\n+. ftr VB B\n+. ftr VBI BI\n+.\\}\n+.el \\{\\\n+. ftr V CR\n+. ftr VI CI\n+. ftr VB CB\n+. ftr VBI CBI\n+.\\}\n+.TH \"JNATIVESCAN\" \"1\" \"2024\" \"JDK 24-internal\" \"JDK Commands\"\n+.hy\n+.SH NAME\n+.PP\n+jnativescan - static analysis tool that scans one or more jar files for\n+uses of native functionality, such as restricted methods or\n+\\f[V]native\\f[R] method declarations.\n+.SH SYNOPSIS\n+.PP\n+\\f[V]jnativescan\\f[R] [\\f[I]options\\f[R]]\n+.TP\n+\\f[I]options\\f[R]\n+See \\f[B]Options for the jnativescan Command\\f[R]\n+.SH DESCRIPTION\n+.PP\n+The \\f[V]jnative\\f[R] tool is a static analysis tool provided by the JDK\n+that scans a JAR file for uses of native functionality, such as\n+restricted methods or \\f[V]native\\f[R] method declarations.\n+.PP\n+\\f[V]jnativescan\\f[R] accepts a runtime class path and module path\n+configuration, as well as a set of root modules, and a target release.\n+It scans the jars on the class and module paths, and reports uses of\n+native functionality either in a tree like structure, which also\n+identifies that calling classes and methods, or as a list of module\n+names when the \\f[V]--print-native-access\\f[R] flag is specified.\n+.SH OPTIONS FOR THE JNATIVESCAN COMMAND\n+.PP\n+The following options are available:\n+.TP\n+\\f[V]--class-path\\f[R] \\f[I]path\\f[R]\n+Used to specify a path list of class path jar files to be scanned.\n+All jar files specified through this path will be scanned.\n+If a jar file contains a \\f[V]Class-Path\\f[R] attribute in its manifest,\n+jar files listed there will be scanned as well.\n+Jar files listed in the \\f[V]Class-Path\\f[R] manifest attribute that can\n+not be found are ignored.\n+.TP\n+\\f[V]--module-path\\f[R] \\f[I]path\\f[R]\n+Used to specify a path list of jar files or directories containing\n+module path jar files.\n+The list jar files that will be scanned depends on the\n+\\f[V]--add-modules\\f[R] option.\n+.RS\n+.PP\n+For both the \\f[V]--class-path\\f[R] and \\f[V]--module-path\\f[R] options,\n+\\f[I]path\\f[R] should be a search path that consists of one or more jar\n+files, separated by the system-specific path separator.\n+For example:\n+.IP \\[bu] 2\n+\\f[B]Linux and macOS:\\f[R]\n+.RS 2\n+.RS\n+.PP\n+\\f[V]--class-path \/some\/foo.jar:\/another\/different\/bar.jar\\f[R]\n+.RE\n+.RE\n+.PP\n+\\f[B]Note:\\f[R]\n+.PP\n+On Windows, use a semicolon (\\f[V];\\f[R]) as the separator instead of a\n+colon (\\f[V]:\\f[R]).\n+.IP \\[bu] 2\n+\\f[B]Windows:\\f[R]\n+.RS 2\n+.RS\n+.PP\n+\\f[V]--class-path C:\\[rs]some\\[rs]foo.jar;C:\\[rs]another\\[rs]different\\[rs]bar.jar\\f[R]\n+.RE\n+.RE\n+.RE\n+.TP\n+\\f[V]--add-modules\\f[R] \\f[I]module[,module...]\\f[R]\n+Used to specifiy a comma-separated list of module names that indicate\n+the root modules to scan.\n+All the modules in the root set will be scanned, as well as any modules\n+that they depend on.\n+This includes dependencies on service implementations specified through\n+the \\f[V]uses\\f[R] directive in a module\\[aq]s \\f[V]module-info\\f[R]\n+file.\n+All modules found on the module path that provide an implementation of\n+such a service will be scanned as well.\n+.TP\n+\\f[V]--release\\f[R] \\f[I]version\\f[R]\n+Used to specify the Java SE release that specifies the set of restricted\n+methods to scan for.\n+For multi-release jar files, this option also indicates the version of\n+class file that should be loaded from the jar.\n+This option should be set to the version of the runtime under which the\n+application is eventually intended to be run.\n+If this flag is omitted, the version of \\f[V]jnativescan\\f[R] is used as\n+release version.\n+.TP\n+\\f[V]--print-native-access\\f[R]\n+Print a comma-separated list of module names that use native\n+functionalities, instead of the default tree structure.\n+.TP\n+\\f[V]--help\\f[R] or \\f[V]-h\\f[R]\n+Prints out a full help message.\n+.TP\n+\\f[V]--version\\f[R]\n+Prints out the abbreviated version string of the tool.\n+.SH EXAMPLE OF \\f[V]jnativescan\\f[R] USE\n+.PP\n+\\f[V]jnativescan\\f[R] accepts a runtime configuration in the form of a\n+class path, module path, set of root modules, and a target release\n+version.\n+For the class path, the tool will scan all jar files, including those\n+found recursively through the \\f[V]Class-Path\\f[R] manifest attribute.\n+For the module path, the tool scans all modules in the root module set\n+specified through \\f[V]--add-modules\\f[R], and any (transitive)\n+dependence module of the root set, including any modules that contain\n+service implementations that are used by a scanned module.\n+.PP\n+By default, the tool prints out which jars, classes, and methods use\n+native functionalities, in a tree-like structure.\n+The following is an example output:\n+.IP\n+.nf\n+\\f[CB]\n+$ jnativescan --class-path app.jar\n+app.jar (ALL-UNNAMED):\n+  foo.Main:\n+    foo.Main::main(String[])void references restricted methods:\n+      java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\n+    foo.Main::nativeMethod()void is a native method declaration\n+\\f[R]\n+.fi\n+.PP\n+\\f[V]app.jar (ALL-UNNAMED)\\f[R] is the path to the jar file, with the\n+module name in parentheses behind it.\n+Since in this case the jar file appears on the class path,\n+\\f[V]ALL-UNNAMED\\f[R] is printed to indicate the unnamed module.\n+The second line of the output, \\f[V]foo.Main\\f[R], indicates that\n+methods using native functionalities were found in the\n+\\f[V]foo.Main\\f[R] class.\n+The next line:\n+.IP\n+.nf\n+\\f[CB]\n+    foo.Main::main(String[])void references restricted methods:\n+\\f[R]\n+.fi\n+.PP\n+Indicates that the \\f[V]main(String[])\\f[R] method in the\n+\\f[V]foo.Main\\f[R] class references a restricted method, which is listed\n+on the following line as:\n+.IP\n+.nf\n+\\f[CB]\n+java.lang.foreign.MemorySegment::reinterpret(long)MemorySegment\n+\\f[R]\n+.fi\n+.PP\n+Lastly, the text:\n+.IP\n+.nf\n+\\f[CB]\n+foo.Main::nativeMethod()void is a native method declaration\n+\\f[R]\n+.fi\n+.PP\n+Indicates that the \\f[V]foo.Main\\f[R] class contains a declaration of a\n+\\f[V]native\\f[R] method named \\f[V]nativeMethod\\f[R].\n+.PP\n+If we add \\f[V]--print-native-access\\f[R] to the example command line,\n+we instead get a list of the names of modules that contain accesses to\n+native functionalities:\n+.IP\n+.nf\n+\\f[CB]\n+$ jnativescan --class-path app.jar --print-native-access\n+ALL-UNNAMED\n+\\f[R]\n+.fi\n+.PP\n+In this case the output consists of just \\f[V]ALL-UNNAMED\\f[R], which\n+indicates a jar file on the class path, that is, in the unnamed module,\n+contains an access to native functionality.\n","filename":"src\/jdk.jdeps\/share\/man\/jnativescan.1","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib .. .\/cases\/modules\n+ * @build JNativeScanTestBase\n+ * @compile --release 20 cases\/classpath\/missingsystem\/App.java\n+ * @run testng TestMissingSystemClass\n+ *\/\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class TestMissingSystemClass extends JNativeScanTestBase {\n+\n+    Path missingsystem;\n+\n+    @BeforeClass\n+    public void before() throws IOException {\n+        missingsystem = Path.of(\"missingsystem.jar\");\n+        Path testClasses = Path.of(System.getProperty(\"test.classes\", \"\"));\n+        JarUtils.createJarFile(missingsystem, testClasses, Path.of(\"missingsystem\", \"App.class\"));\n+    }\n+\n+    @Test\n+    public void testSingleJarClassPath() {\n+        assertFailure(jnativescan(\"--class-path\", missingsystem.toString(), \"--release\", \"21\"))\n+                .stdoutShouldBeEmpty()\n+                .stderrShouldContain(\"Error while processing method\")\n+                .stderrShouldContain(\"missingsystem.App::main(String[])void\")\n+                .stderrShouldContain(\"CAUSED BY:\")\n+                .stderrShouldContain(\"System class can not be found\")\n+                .stderrShouldContain(\"java.lang.Compiler\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/TestMissingSystemClass.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package missingsystem;\n+\n+public class App {\n+    public static void main(String[] args) {\n+        \/\/ this class was present in Java 20, but removed in 21\n+        \/\/ if we compile with --release 20, but run jnativescan\n+        \/\/ with --release 21, we should get an error\n+        java.lang.Compiler.enable();\n+    }\n+}\n","filename":"test\/langtools\/tools\/jnativescan\/cases\/classpath\/missingsystem\/App.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"}]}