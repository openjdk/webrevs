{"files":[{"patch":"@@ -210,1 +210,0 @@\n-    private final DeferredCompletionFailureHandler dcfh;\n@@ -335,1 +334,0 @@\n-        dcfh = DeferredCompletionFailureHandler.instance(context);\n@@ -696,1 +694,1 @@\n-                (constants == null || !isExhaustive(tree.selector.type, constants))) {\n+                (constants == null || !isExhaustive(tree.selector.pos(), tree.selector.type, constants))) {\n@@ -731,1 +729,1 @@\n-                !isExhaustive(tree.selector.type, constants)) {\n+                !isExhaustive(tree.selector.pos(), tree.selector.type, constants)) {\n@@ -754,1 +752,1 @@\n-        private void transitiveCovers(Type seltype, Set<Symbol> covered) {\n+        private void transitiveCovers(DiagnosticPosition pos, Type seltype, Set<Symbol> covered) {\n@@ -776,1 +774,1 @@\n-                                if (isTransitivelyCovered(seltype, sup.tsym, covered) &&\n+                                if (isTransitivelyCovered(pos, seltype, sup.tsym, covered) &&\n@@ -787,3 +785,2 @@\n-        private boolean isTransitivelyCovered(Type seltype, Symbol sealed, Set<Symbol> covered) {\n-            DeferredCompletionFailureHandler.Handler prevHandler =\n-                    dcfh.setHandler(dcfh.speculativeCodeHandler);\n+        private boolean isTransitivelyCovered(DiagnosticPosition pos, Type seltype,\n+                                              Symbol sealed, Set<Symbol> covered) {\n@@ -799,1 +796,1 @@\n-                                                 .allMatch(s -> isTransitivelyCovered(seltype, s, covered));\n+                                                 .allMatch(s -> isTransitivelyCovered(pos, seltype, s, covered));\n@@ -803,4 +800,2 @@\n-                \/\/safe to ignore, the symbol will be un-completed when the speculative handler is removed.\n-                return false;\n-            } finally {\n-                dcfh.setHandler(prevHandler);\n+                chk.completionError(pos, cf);\n+                return true;\n@@ -810,2 +805,2 @@\n-        private boolean isExhaustive(Type seltype, Set<Symbol> covered) {\n-            transitiveCovers(seltype, covered);\n+        private boolean isExhaustive(DiagnosticPosition pos, Type seltype, Set<Symbol> covered) {\n+            transitiveCovers(pos, seltype, covered);\n@@ -816,1 +811,3 @@\n-                            yield ((Type.IntersectionClassType) seltype).getComponents().stream().anyMatch(t -> isExhaustive(t, covered));\n+                            yield ((Type.IntersectionClassType) seltype).getComponents()\n+                                                                        .stream()\n+                                                                        .anyMatch(t -> isExhaustive(pos, t, covered));\n@@ -822,1 +819,1 @@\n-                case TYPEVAR -> isExhaustive(((TypeVar) seltype).getUpperBound(), covered);\n+                case TYPEVAR -> isExhaustive(pos, ((TypeVar) seltype).getUpperBound(), covered);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -372,96 +372,0 @@\n-    @Test\n-    public void testInaccessiblePermitted(Path base) throws IOException {\n-        Path current = base.resolve(\".\");\n-        Path libSrc = current.resolve(\"lib-src\");\n-\n-        tb.writeJavaFiles(libSrc,\n-                           \"\"\"\n-                           package lib;\n-                           public sealed interface S permits A, B {}\n-                           \"\"\",\n-                           \"\"\"\n-                           package lib;\n-                           public final class A implements S {}\n-                           \"\"\",\n-                           \"\"\"\n-                           package lib;\n-                           final class B implements S {}\n-                           \"\"\");\n-\n-        Path libClasses = current.resolve(\"libClasses\");\n-\n-        Files.createDirectories(libClasses);\n-\n-        new JavacTask(tb)\n-                .options(\"--enable-preview\",\n-                         \"-source\", JAVA_VERSION)\n-                .outdir(libClasses)\n-                .files(tb.findJavaFiles(libSrc))\n-                .run();\n-\n-        Path src = current.resolve(\"src\");\n-        tb.writeJavaFiles(src,\n-                           \"\"\"\n-                           package test;\n-                           import lib.*;\n-                           public class Test {\n-                               private int test(S obj) {\n-                                   return switch (obj) {\n-                                       case A a -> 0;\n-                                   };\n-                               }\n-                           }\n-                           \"\"\");\n-\n-        Path classes = current.resolve(\"libClasses\");\n-\n-        Files.createDirectories(libClasses);\n-\n-        var log =\n-                new JavacTask(tb)\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION,\n-                             \"-XDrawDiagnostics\",\n-                             \"-Xlint:-preview\",\n-                             \"--class-path\", libClasses.toString())\n-                    .outdir(classes)\n-                    .files(tb.findJavaFiles(src))\n-                    .run(Task.Expect.FAIL)\n-                    .writeAll()\n-                    .getOutputLines(Task.OutputKind.DIRECT);\n-\n-        List<String> expectedErrors = List.of(\n-               \"Test.java:5:16: compiler.err.not.exhaustive\",\n-               \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n-               \"- compiler.note.preview.recompile\",\n-               \"1 error\");\n-\n-        if (!expectedErrors.equals(log)) {\n-            throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n-                                      \", actual: \" + log);\n-        }\n-\n-        Path bClass = libClasses.resolve(\"lib\").resolve(\"B.class\");\n-\n-        Files.delete(bClass);\n-\n-        var log2 =\n-                new JavacTask(tb)\n-                    .options(\"--enable-preview\",\n-                             \"-source\", JAVA_VERSION,\n-                             \"-XDrawDiagnostics\",\n-                             \"-Xlint:-preview\",\n-                             \"--class-path\", libClasses.toString())\n-                    .outdir(classes)\n-                    .files(tb.findJavaFiles(src))\n-                    .run(Task.Expect.FAIL)\n-                    .writeAll()\n-                    .getOutputLines(Task.OutputKind.DIRECT);\n-\n-        if (!expectedErrors.equals(log2)) {\n-            throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n-                                      \", actual: \" + log2);\n-        }\n-\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8277105\n+ * @summary Verify missing permitted subtype is handled properly for both casts and pattern switches.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main MissingPermittedSubtypes\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class MissingPermittedSubtypes extends TestRunner {\n+\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new MissingPermittedSubtypes().runTests();\n+    }\n+\n+    MissingPermittedSubtypes() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testInaccessiblePermitted(Path base) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libSrc = current.resolve(\"lib-src\");\n+\n+        tb.writeJavaFiles(libSrc,\n+                           \"\"\"\n+                           package lib;\n+                           public sealed interface S permits A, B1, B2 {}\n+                           \"\"\",\n+                           \"\"\"\n+                           package lib;\n+                           public final class A implements S {}\n+                           \"\"\",\n+                           \"\"\"\n+                           package lib;\n+                           final class B1 implements S {}\n+                           \"\"\",\n+                           \"\"\"\n+                           package lib;\n+                           final class B2 implements S, Runnable {\n+                               public void run() {}\n+                           }\n+                           \"\"\");\n+\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        new JavacTask(tb)\n+                .options(\"--enable-preview\",\n+                         \"-source\", JAVA_VERSION)\n+                .outdir(libClasses)\n+                .files(tb.findJavaFiles(libSrc))\n+                .run();\n+\n+        Path b1Class = libClasses.resolve(\"lib\").resolve(\"B1.class\");\n+\n+        Files.delete(b1Class);\n+\n+        Path b2Class = libClasses.resolve(\"lib\").resolve(\"B2.class\");\n+\n+        Files.delete(b2Class);\n+\n+        {\n+            Path src1 = current.resolve(\"src1\");\n+            tb.writeJavaFiles(src1,\n+                               \"\"\"\n+                               package test;\n+                               import lib.*;\n+                               public class Test1 {\n+                                   private void test(S obj) {\n+                                       int i = switch (obj) {\n+                                           case A a -> 0;\n+                                       };\n+                                       Runnable r = () -> {obj = null;};\n+                                   }\n+                               }\n+                               \"\"\");\n+\n+            Path classes1 = current.resolve(\"classes1\");\n+\n+            Files.createDirectories(classes1);\n+\n+            var log =\n+                    new JavacTask(tb)\n+                        .options(\"--enable-preview\",\n+                                 \"-source\", JAVA_VERSION,\n+                                 \"-XDrawDiagnostics\",\n+                                 \"-Xlint:-preview\",\n+                                 \"--class-path\", libClasses.toString())\n+                        .outdir(classes1)\n+                        .files(tb.findJavaFiles(src1))\n+                        .run(Task.Expect.FAIL)\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+\n+            List<String> expectedErrors = List.of(\n+                   \"Test1.java:5:24: compiler.err.cant.access: lib.B1, (compiler.misc.class.file.not.found: lib.B1)\",\n+                   \"Test1.java:8:29: compiler.err.cant.ref.non.effectively.final.var: obj, (compiler.misc.lambda)\",\n+                   \"- compiler.note.preview.filename: Test1.java, DEFAULT\",\n+                   \"- compiler.note.preview.recompile\",\n+                   \"2 errors\");\n+\n+            if (!expectedErrors.equals(log)) {\n+                throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n+                                          \", actual: \" + log);\n+            }\n+        }\n+\n+        {\n+            Path src2 = current.resolve(\"src2\");\n+            tb.writeJavaFiles(src2,\n+                               \"\"\"\n+                               package test;\n+                               import lib.*;\n+                               public class Test1 {\n+                                   private void test(S obj) {\n+                                    Runnable r = (Runnable) obj;\n+                                    String s = (String) obj;\n+                                   }\n+                               }\n+                               \"\"\");\n+\n+            Path classes2 = current.resolve(\"classes2\");\n+\n+            Files.createDirectories(classes2);\n+\n+            var log =\n+                    new JavacTask(tb)\n+                        .options(\"--enable-preview\",\n+                                 \"-source\", JAVA_VERSION,\n+                                 \"-XDrawDiagnostics\",\n+                                 \"-Xlint:-preview\",\n+                                 \"--class-path\", libClasses.toString())\n+                        .outdir(classes2)\n+                        .files(tb.findJavaFiles(src2))\n+                        .run(Task.Expect.FAIL)\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+\n+            List<String> expectedErrors = List.of(\n+                   \"Test1.java:5:19: compiler.err.cant.access: lib.B1, (compiler.misc.class.file.not.found: lib.B1)\",\n+                   \"Test1.java:6:26: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: lib.S, java.lang.String)\",\n+                   \"2 errors\");\n+\n+            if (!expectedErrors.equals(log)) {\n+                throw new AssertionError(\"Incorrect errors, expected: \" + expectedErrors +\n+                                          \", actual: \" + log);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/sealed\/MissingPermittedSubtypes.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"}]}