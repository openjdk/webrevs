{"files":[{"patch":"@@ -538,2 +538,1 @@\n-  NativeType new_lo = max_jint;\n-  NativeType new_hi = min_jint;\n+\n@@ -549,2 +548,31 @@\n-  if (i1->_lo == min_val && i2_hi == -1) {\n-    new_lo = i1->_lo;\n+  if (i1->_lo == min_val) {\n+    \/\/ Special case possible, check carefully\n+    NativeType new_lo;\n+    NativeType new_hi;\n+    if (i2_hi == -1) {\n+      \/\/ special overflow case as defined above\n+      new_lo = min_val;\n+      if (!i1->is_con()) {\n+        \/\/ Also compute the \"next\" division result for a non‑constant range.\n+        new_hi = i1->_lo + 1 \/ i2_hi;\n+      } else {\n+        new_hi = min_val;\n+      }\n+    } else {\n+      \/\/ Normal corner: (i1->_lo, i2->_hi)\n+      NativeType result = i1->_lo \/ i2_hi;\n+      new_lo = result;\n+      new_hi = result;\n+    }\n+\n+    \/\/ If the divisor range is wider than a singleton, include (i1->_lo, i2->_lo).\n+    \/\/ We cannot use is_con here, as a range of [-1, 0] will also result in i2_lo and i2_hi being -1\n+    if (i2_lo != i2_hi) {\n+      assert(i2_lo != -1, \"Special case not possible here, as i2_lo has to be < i2_hi\");\n+      NativeType result = i1->_lo \/ i2_lo;\n+      new_lo = MIN2(new_lo, result);\n+      new_hi = MAX2(new_hi, result);\n+    }\n+\n+    \/\/ If i1 is not a single constant, include the two corners with i1->_hi:\n+    \/\/   (i1->_hi, i2->_lo) and (i1->_hi, i2->_hi)\n@@ -552,2 +580,5 @@\n-      \/\/ Also compute the \"next\" division result for a non‑constant range.\n-      new_hi = MAX2(new_hi, i1->_lo + 1 \/ i2_hi);\n+      assert(i2_hi > min_val, \"Special case not possible here, as i1->_hi has to be > min\");\n+      NativeType result1 = i1->_hi \/ i2_lo;\n+      NativeType result2 = i1->_hi \/ i2_hi;\n+      new_lo = MIN3(new_lo, result1, result2);\n+      new_hi = MAX3(new_hi, result1, result2);\n@@ -555,6 +586,0 @@\n-  } else {\n-    \/\/ Normal corner: (i1->_lo, i2->_hi)\n-    NativeType result = i1->_lo \/ i2_hi;\n-    new_lo = MIN2(new_lo, result);\n-    new_hi = MAX2(new_hi, result);\n-  }\n@@ -562,8 +587,1 @@\n-  \/\/ If the divisor range is wider than a singleton, include (i1->_lo, i2->_lo).\n-  \/\/ We cannot use is_con here, as a range of [-1, 0] will also result in i2_lo and i2_hi being -1\n-  if (i2_lo != i2_hi) {\n-    \/\/ special case not possible here, _lo mus\n-    assert(i2_lo != -1, \"Special case not possible here\");\n-    NativeType result = i1->_lo \/ i2_lo;\n-    new_lo = MIN2(new_lo, result);\n-    new_hi = MAX2(new_hi, result);\n+    return IntegerType::make(new_lo, new_hi, widen);\n@@ -572,13 +590,9 @@\n-  \/\/ If i1 is not a single constant, include the two corners with i1->_hi:\n-  \/\/   (i1->_hi, i2->_lo) and (i1->_hi, i2->_hi)\n-  if (!i1->is_con()) {\n-    \/\/ Special case not possible here, as i1->_hi has to be > min\n-    assert(i2_hi > min_val, \"Special case not possible here\");\n-    NativeType result1 = i1->_hi \/ i2_lo;\n-    NativeType result2 = i1->_hi \/ i2_hi;\n-    new_lo = MIN2(new_lo, result1);\n-    new_lo = MIN2(new_lo, result2);\n-    new_hi = MAX2(new_hi, result1);\n-    new_hi = MAX2(new_hi, result2);\n-  }\n-  assert(new_hi >= new_lo, \"sanity\");\n+  \/\/ Special case not possible here, calculate all corners normally\n+  assert(i1->_lo != min_val && i1->_hi != min_val, \"Special has should have been filtered out\");\n+  NativeType corner1 = i1->_lo \/ i2_lo;\n+  NativeType corner2 = i1->_lo \/ i2_hi;\n+  NativeType corner3 = i1->_hi \/ i2_lo;\n+  NativeType corner4 = i1->_hi \/ i2_hi;\n+\n+  NativeType new_lo = MIN4(corner1, corner2, corner3, corner4);\n+  NativeType new_hi = MAX4(corner1, corner2, corner3, corner4);\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":47,"deletions":33,"binary":false,"changes":80,"status":"modified"}]}