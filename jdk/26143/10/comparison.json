{"files":[{"patch":"@@ -507,0 +507,96 @@\n+template<typename IntegerType>\n+static const IntegerType* compute_signed_div_type(const IntegerType* i1, const IntegerType* i2) {\n+  typedef typename IntegerType::NativeType NativeType;\n+  assert(!i2->is_con() || i2->get_con() != 0, \"Can't handle zero constant divisor\");\n+  int widen = MAX2(i1->_widen, i2->_widen);\n+\n+  \/\/ Case A: divisor range spans zero (i2->_lo < 0 < i2->_hi)\n+  \/\/ We split into two subproblems to avoid division by 0:\n+  \/\/   - negative part: [i2->_lo, −1]\n+  \/\/   - positive part: [1, i2->_hi]\n+  \/\/ Then we union the results by taking the min of all lower‐bounds and\n+  \/\/ the max of all upper‐bounds from the two halves.\n+  if (i2->_lo < 0 && i2->_hi > 0) {\n+    \/\/ Handle negative part of the divisor range\n+    const IntegerType* neg_part = compute_signed_div_type(i1, IntegerType::make(i2->_lo, -1, widen));\n+    \/\/ Handle positive part of the divisor range\n+    const IntegerType* pos_part = compute_signed_div_type(i1, IntegerType::make(1, i2->_hi, widen));\n+    \/\/ Merge results\n+    NativeType new_lo = MIN2(neg_part->_lo, pos_part->_lo);\n+    NativeType new_hi = MAX2(neg_part->_hi, pos_part->_hi);\n+    assert(new_hi >= new_lo, \"sanity\");\n+    return IntegerType::make(new_lo, new_hi, widen);\n+  }\n+\n+  \/\/ Case B: divisor range does NOT span zero.\n+  \/\/ Here i2 is entirely negative or entirely positive.\n+  \/\/ Then i1\/i2 is monotonic in i1 and i2 (when i2 keeps the same sign).\n+  \/\/ Therefore the extrema occur at the four “corners”:\n+  \/\/   (i1->_lo, i2->_hi), (i1->_lo, i2->_lo), (i1->_hi, i2->_lo), (i1->_hi, i2->_hi).\n+  \/\/ We compute all four and take the min and max.\n+  \/\/ A special case handles overflow when dividing the most‐negative value by −1.\n+\n+  \/\/ adjust i2 bounds to not include zero, as zero always throws\n+  NativeType i2_lo = i2->_lo == 0 ? 1 : i2->_lo;\n+  NativeType i2_hi = i2->_hi == 0 ? -1 : i2->_hi;\n+  constexpr NativeType min_val = std::numeric_limits<NativeType>::min();\n+  static_assert(min_val == min_jint || min_val == min_jlong, \"min has to be either min_jint or min_jlong\");\n+  constexpr NativeType max_val = std::numeric_limits<NativeType>::max();\n+  static_assert(max_val == max_jint || max_val == max_jlong, \"max has to be either max_jint or max_jlong\");\n+\n+  \/\/ Special overflow case: min_val \/ (-1) == min_val (cf. JVMS§6.5 idiv\/ldiv)\n+  \/\/ We need to be careful that we never run min_val \/ (-1) in C++ code, as this overflow is UB there\n+  if (i1->_lo == min_val && i2_hi == -1) {\n+    NativeType new_lo = min_val;\n+    NativeType new_hi;\n+    \/\/ compute new_hi depending on whether divisor or dividend is non-constant.\n+    \/\/ i2 is purely in the negative domain here (as i2_hi is -1)\n+    \/\/ which means the maximum value this division can yield is either\n+    if (!i1->is_con()) {\n+      \/\/ a) non-constant dividend: i1 could be min_val + 1.\n+      \/\/ -> i1 \/ i2 = (min_val + 1) \/ -1 = max_val is possible.\n+      new_hi = max_val;\n+      assert((min_val + 1) \/ -1 == new_hi, \"new_hi should be max_val\");\n+    } else if (i2_lo != i2_hi) {\n+      \/\/ b) i1 is constant min_val, i2 is non-constant.\n+      \/\/    if i2 = -1 -> i1 \/ i2 =  min_val \/ -1 = min_val\n+      \/\/    if i2 < -1 -> i1 \/ i2 <= min_val \/ -2 = (max_val \/ 2) + 1\n+      new_hi = (max_val \/ 2) + 1;\n+      assert(min_val \/ -2 == new_hi, \"new_hi should be (max_val \/ 2) + 1)\");\n+    } else {\n+      \/\/ c) i1 is constant min_val, i2 is constant -1.\n+      \/\/    -> i1 \/ i2 = min_val \/ -1 = min_val\n+      new_hi = min_val;\n+    }\n+\n+#ifdef ASSERT\n+    \/\/ validate new_hi for non-constant divisor\n+    if (i2_lo != i2_hi) {\n+      assert(i2_lo != -1, \"Special case not possible here, as i2_lo has to be < i2_hi\");\n+      NativeType result = i1->_lo \/ i2_lo;\n+      assert(new_hi >= result, \"computed wrong value for new_hi\");\n+    }\n+\n+    \/\/ validate new_hi for non-constant dividend\n+    if (!i1->is_con()) {\n+      assert(i2_hi > min_val, \"Special case not possible here, as i1->_hi has to be > min\");\n+      NativeType result1 = i1->_hi \/ i2_lo;\n+      NativeType result2 = i1->_hi \/ i2_hi;\n+      assert(new_hi >= result1 && new_hi >= result2, \"computed wrong value for new_hi\");\n+    }\n+#endif\n+\n+    return IntegerType::make(new_lo, new_hi, widen);\n+  }\n+  assert((i1->_lo != min_val && i1->_hi != min_val) || (i2_hi != -1 && i2_lo != -1), \"should have filtered out before\");\n+\n+  \/\/ Special case not possible here, calculate all corners normally\n+  NativeType corner1 = i1->_lo \/ i2_lo;\n+  NativeType corner2 = i1->_lo \/ i2_hi;\n+  NativeType corner3 = i1->_hi \/ i2_lo;\n+  NativeType corner4 = i1->_hi \/ i2_hi;\n+\n+  NativeType new_lo = MIN4(corner1, corner2, corner3, corner4);\n+  NativeType new_hi = MAX4(corner1, corner2, corner3, corner4);\n+  return IntegerType::make(new_lo, new_hi, widen);\n+}\n@@ -552,4 +648,10 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  if (t2 == TypeInt::ZERO) {\n+    \/\/ this division will always throw an exception\n+    return Type::TOP;\n+  }\n@@ -562,11 +664,2 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  \/\/ Divide the two numbers.  We approximate.\n-  \/\/ If divisor is a constant and not zero\n-  const TypeInt *i1 = t1->is_int();\n-  const TypeInt *i2 = t2->is_int();\n-  int widen = MAX2(i1->_widen, i2->_widen);\n+  const TypeInt* i1 = t1->is_int();\n+  const TypeInt* i2 = t2->is_int();\n@@ -574,37 +667,1 @@\n-  if( i2->is_con() && i2->get_con() != 0 ) {\n-    int32_t d = i2->get_con(); \/\/ Divisor\n-    jint lo, hi;\n-    if( d >= 0 ) {\n-      lo = i1->_lo\/d;\n-      hi = i1->_hi\/d;\n-    } else {\n-      if( d == -1 && i1->_lo == min_jint ) {\n-        \/\/ 'min_jint\/-1' throws arithmetic exception during compilation\n-        lo = min_jint;\n-        \/\/ do not support holes, 'hi' must go to either min_jint or max_jint:\n-        \/\/ [min_jint, -10]\/[-1,-1] ==> [min_jint] UNION [10,max_jint]\n-        hi = i1->_hi == min_jint ? min_jint : max_jint;\n-      } else {\n-        lo = i1->_hi\/d;\n-        hi = i1->_lo\/d;\n-      }\n-    }\n-    return TypeInt::make(lo, hi, widen);\n-  }\n-\n-  \/\/ If the dividend is a constant\n-  if( i1->is_con() ) {\n-    int32_t d = i1->get_con();\n-    if( d < 0 ) {\n-      if( d == min_jint ) {\n-        \/\/  (-min_jint) == min_jint == (min_jint \/ -1)\n-        return TypeInt::make(min_jint, max_jint\/2 + 1, widen);\n-      } else {\n-        return TypeInt::make(d, -d, widen);\n-      }\n-    }\n-    return TypeInt::make(-d, d, widen);\n-  }\n-\n-  \/\/ Otherwise we give up all hope\n-  return TypeInt::INT;\n+  return compute_signed_div_type<TypeInt>(i1, i2);\n@@ -658,4 +715,10 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  if (t2 == TypeLong::ZERO) {\n+    \/\/ this division will always throw an exception\n+    return Type::TOP;\n+  }\n@@ -668,46 +731,2 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  \/\/ Divide the two numbers.  We approximate.\n-  \/\/ If divisor is a constant and not zero\n-  const TypeLong *i1 = t1->is_long();\n-  const TypeLong *i2 = t2->is_long();\n-  int widen = MAX2(i1->_widen, i2->_widen);\n-\n-  if( i2->is_con() && i2->get_con() != 0 ) {\n-    jlong d = i2->get_con();    \/\/ Divisor\n-    jlong lo, hi;\n-    if( d >= 0 ) {\n-      lo = i1->_lo\/d;\n-      hi = i1->_hi\/d;\n-    } else {\n-      if( d == CONST64(-1) && i1->_lo == min_jlong ) {\n-        \/\/ 'min_jlong\/-1' throws arithmetic exception during compilation\n-        lo = min_jlong;\n-        \/\/ do not support holes, 'hi' must go to either min_jlong or max_jlong:\n-        \/\/ [min_jlong, -10]\/[-1,-1] ==> [min_jlong] UNION [10,max_jlong]\n-        hi = i1->_hi == min_jlong ? min_jlong : max_jlong;\n-      } else {\n-        lo = i1->_hi\/d;\n-        hi = i1->_lo\/d;\n-      }\n-    }\n-    return TypeLong::make(lo, hi, widen);\n-  }\n-\n-  \/\/ If the dividend is a constant\n-  if( i1->is_con() ) {\n-    jlong d = i1->get_con();\n-    if( d < 0 ) {\n-      if( d == min_jlong ) {\n-        \/\/  (-min_jlong) == min_jlong == (min_jlong \/ -1)\n-        return TypeLong::make(min_jlong, max_jlong\/2 + 1, widen);\n-      } else {\n-        return TypeLong::make(d, -d, widen);\n-      }\n-    }\n-    return TypeLong::make(-d, d, widen);\n-  }\n+  const TypeLong* i1 = t1->is_long();\n+  const TypeLong* i2 = t2->is_long();\n@@ -715,2 +734,1 @@\n-  \/\/ Otherwise we give up all hope\n-  return TypeLong::LONG;\n+  return compute_signed_div_type<TypeLong>(i1, i2);\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":122,"deletions":104,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -0,0 +1,505 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.igvn;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8364766\n+ * @summary Test value method of DivINode and DivLNode\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.igvn.IntegerDivValueTests\n+ *\/\n+public class IntegerDivValueTests {\n+    private static final RestrictableGenerator<Integer> INTS = Generators.G.ints();\n+    private static final RestrictableGenerator<Long> LONGS = Generators.G.longs();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @ForceInline\n+    private int getIntConstant(int value) {\n+        \/\/ Simply return the given value to avoid javac already optimizing the operation away\n+        return value;\n+    }\n+\n+    private static final int INT_CONST_1 = INTS.next();\n+    private static final int INT_CONST_2 = INTS.next();\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public int testIntConstantFolding() {\n+        \/\/ All constants available during parsing\n+        return INT_CONST_1 \/ INT_CONST_2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public int testIntConstantFoldingSpecialCase() {\n+        \/\/ All constants available during parsing\n+        return getIntConstant(Integer.MIN_VALUE) \/ getIntConstant(-1);\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public int testIntRange(int in) {\n+        int a = (in & 7) + 16;\n+        return a \/ 12; \/\/ [16, 23] \/ 12 is constant 1\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public boolean testIntRange2(int in) {\n+        int a = (in & 7) + 16;\n+        return a \/ 4 > 3; \/\/ [16, 23] \/ 4 => [4, 5]\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_I, \"1\"})\n+    public boolean testIntRange3(int in, int in2) {\n+        int a = (in & 31) + 16;\n+        int b = (in2 & 3) + 5;\n+        return a \/ b > 4; \/\/ [16, 47] \/ [5, 8] => [2, 9]\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public boolean testIntRange4(int in, int in2) {\n+        int a = (in & 15); \/\/ [0, 15]\n+        int b = (in2 & 3) + 1; \/\/ [1, 4]\n+        return a \/ b >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public boolean testIntRange5(int in, int in2) {\n+        int a = (in & 15) + 5; \/\/ [5, 20]\n+        int b = (in2 & 3) + 1; \/\/ [1, 4]\n+        return a \/ b > 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public boolean testIntRange6(int in, int in2) {\n+        int a = (in & 15) + 5; \/\/ [5, 20]\n+        int b = (in2 & 7) - 1; \/\/ [-1, 5]\n+        if (b == 0) return false;\n+        return a \/ b < -20;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_I, \"1\"})\n+    public boolean testIntRange7(int in, int in2) {\n+        int a = (in & 15) + 5; \/\/ [5, 20]\n+        int b = (in2 & 7) - 1; \/\/ [-1, 5]\n+        if (b == 0) return false;\n+        return a \/ b > 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public int testIntRange8(int in, int in2) {\n+        int a = (in & 31) + 128; \/\/ [128, 159]\n+        int b = (in2 & 15) + 100; \/\/ [100, 115]\n+        return a \/ b; \/\/ [1, 1] -> can be constant\n+    }\n+\n+    private static final int INT_LIMIT_1 = INTS.next();\n+    private static final int INT_LIMIT_2 = INTS.next();\n+    private static final int INT_LIMIT_3 = INTS.next();\n+    private static final int INT_LIMIT_4 = INTS.next();\n+    private static final int INT_LIMIT_5 = INTS.next();\n+    private static final int INT_LIMIT_6 = INTS.next();\n+    private static final int INT_LIMIT_7 = INTS.next();\n+    private static final int INT_LIMIT_8 = INTS.next();\n+    private static final int INT_RANGE_LIMIT_X_LO;\n+    private static final int INT_RANGE_LIMIT_X_HI;\n+    private static final int INT_RANGE_LIMIT_Y_LO;\n+    private static final int INT_RANGE_LIMIT_Y_HI;\n+\n+    static {\n+        int limit1 = INTS.next();\n+        int limit2 = INTS.next();\n+        if (limit2 > limit1) {\n+            INT_RANGE_LIMIT_X_LO = limit1;\n+            INT_RANGE_LIMIT_X_HI = limit2;\n+        } else {\n+            INT_RANGE_LIMIT_X_LO = limit2;\n+            INT_RANGE_LIMIT_X_HI = limit1;\n+        }\n+\n+        int limit3 = INTS.next();\n+        int limit4 = INTS.next();\n+        if (limit4 > limit3) {\n+            INT_RANGE_LIMIT_Y_LO = limit3;\n+            INT_RANGE_LIMIT_Y_HI = limit4;\n+        } else {\n+            INT_RANGE_LIMIT_Y_LO = limit4;\n+            INT_RANGE_LIMIT_Y_HI = limit3;\n+        }\n+    }\n+\n+    @ForceInline\n+    private int clampInt(int val, int lo, int hi) {\n+        return Math.min(hi, Math.max(val, lo));\n+    }\n+\n+    @ForceInline\n+    private int calculateIntSum(int z) {\n+        int sum = 0;\n+        if (z < INT_LIMIT_1) sum += 1;\n+        if (z < INT_LIMIT_2) sum += 2;\n+        if (z < INT_LIMIT_3) sum += 4;\n+        if (z < INT_LIMIT_4) sum += 8;\n+        if (z > INT_LIMIT_5) sum += 16;\n+        if (z > INT_LIMIT_6) sum += 32;\n+        if (z > INT_LIMIT_7) sum += 64;\n+        if (z > INT_LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    @Test\n+    public int testIntRandomLimits(int x, int y) {\n+        x = clampInt(x, INT_RANGE_LIMIT_X_LO, INT_RANGE_LIMIT_X_HI);\n+        y = clampInt(y, INT_RANGE_LIMIT_Y_LO, INT_RANGE_LIMIT_Y_HI);\n+        int z = x \/ y;\n+\n+        return calculateIntSum(z);\n+    }\n+\n+    @DontCompile\n+    public int testIntRandomLimitsInterpreted(int x, int y) {\n+        x = clampInt(x, INT_RANGE_LIMIT_X_LO, INT_RANGE_LIMIT_X_HI);\n+        y = clampInt(y, INT_RANGE_LIMIT_Y_LO, INT_RANGE_LIMIT_Y_HI);\n+        int z = x \/ y;\n+\n+        return calculateIntSum(z);\n+    }\n+\n+    @Run(test = {\"testIntConstantFolding\", \"testIntConstantFoldingSpecialCase\"})\n+    public void checkIntConstants(RunInfo info) {\n+        Asserts.assertEquals(INT_CONST_1 \/ INT_CONST_2, testIntConstantFolding());\n+        Asserts.assertEquals(Integer.MIN_VALUE, testIntConstantFoldingSpecialCase());\n+    }\n+\n+    @Run(test = {\"testIntRange\", \"testIntRange2\", \"testIntRange3\", \"testIntRange4\", \"testIntRange5\", \"testIntRange6\", \"testIntRange7\", \"testIntRange8\", \"testIntRandomLimits\"})\n+    public void checkIntRanges(RunInfo info) {\n+        for (int j = 0; j < 20; j++) {\n+            int i1 = INTS.next();\n+            int i2 = INTS.next();\n+            checkInt(i1, i2);\n+        }\n+    }\n+\n+    @DontCompile\n+    public void checkInt(int in, int in2) {\n+        int a;\n+        int b;\n+        a = (in & 7) + 16;\n+        Asserts.assertEquals(a \/ 12, testIntRange(in));\n+\n+        a = (in & 7) + 16;\n+        Asserts.assertEquals(a \/ 4 > 3, testIntRange2(in));\n+\n+        a = (in & 31) + 16;\n+        b = (in2 & 3) + 5;\n+        Asserts.assertEquals(a \/ b > 4, testIntRange3(in, in2));\n+\n+        a = (in & 15);\n+        b = (in2 & 3) + 1;\n+        Asserts.assertEquals(a \/ b >= 0, testIntRange4(in, in2));\n+\n+        a = (in & 15) + 5;\n+        b = (in2 & 3) + 1;\n+        Asserts.assertEquals(a \/ b > 0, testIntRange5(in, in2));\n+\n+        a = (in & 15) + 5;\n+        b = (in2 & 7) - 1;\n+        Asserts.assertEquals(b == 0 ? false : a \/ b < -20, testIntRange6(in, in2));\n+\n+        a = (in & 15) + 5;\n+        b = (in2 & 7) - 1;\n+        Asserts.assertEquals(b == 0 ? false : a \/ b > 0, testIntRange7(in, in2));\n+\n+        a = (in & 31) + 128;\n+        b = (in2 & 15) + 100;\n+        Asserts.assertEquals(a \/ b, testIntRange8(in, in2));\n+\n+        int res;\n+        try {\n+            res = testIntRandomLimitsInterpreted(a, b);\n+        } catch (ArithmeticException _) {\n+            try {\n+                testIntRandomLimits(a, b);\n+                Asserts.fail(\"Expected ArithmeticException\");\n+                return; \/\/ unreachable\n+            } catch (ArithmeticException _) {\n+                return; \/\/ test succeeded, no result to assert\n+            }\n+        }\n+        Asserts.assertEQ(res, testIntRandomLimits(a, b));\n+    }\n+\n+    \/\/ Long variants\n+\n+    @ForceInline\n+    private long getLongConstant(long value) {\n+        \/\/ Simply return the given value to avoid javac already optimizing the operation away\n+        return value;\n+    }\n+\n+    private static final long LONG_CONST_1 = LONGS.next();\n+    private static final long LONG_CONST_2 = LONGS.next();\n+\n+    @Test\n+    \/\/@IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    \/\/ This results in a series of nodes due to DivLNode::Ideal and in particular transform_long_divide, which operates on non-constant divisors.\n+    \/\/ transform_long_divide splits up the division into multiple other nodes, such as MulHiLNode, which does not have a good Value() implemantion.\n+    \/\/ When JDK-8366815 is fixed, these rules should be reenabled\n+    \/\/ Alternatively, a better MulHiLNode::Value() implemantion should also lead to constant folding\n+    public long testLongConstantFolding() {\n+        \/\/ All constants available during parsing\n+        return LONG_CONST_1 \/ LONG_CONST_2;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public long testLongConstantFoldingSpecialCase() {\n+        \/\/ All constants available during parsing\n+        return getLongConstant(Long.MIN_VALUE) \/ getLongConstant(-1L);\n+    }\n+\n+    @Test\n+    \/\/@IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    \/\/ This results in a series of nodes due to DivLNode::Ideal and in particular transform_long_divide, which operates on non-constant divisors.\n+    \/\/ transform_long_divide splits up the division into multiple other nodes, such as MulHiLNode, which does not have a good Value() implemantion.\n+    \/\/ When JDK-8366815 is fixed, these rules should be reenabled\n+    \/\/ Alternatively, a better MulHiLNode::Value() implemantion should also lead to constant folding\n+    @IR(counts = {IRNode.RSHIFT_L, \"> 0\", IRNode.ADD_L, \"> 0\", IRNode.AND_L, \"> 0\"}, failOn = {IRNode.DIV})\n+    public long testLongRange(long in) {\n+        long a = (in & 7L) + 16L;\n+        return a \/ 12L; \/\/ [16, 23] \/ 12 is constant 1\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public boolean testLongRange2(long in) {\n+        long a = (in & 7L) + 16L;\n+        return a \/ 4L > 3L; \/\/ [16, 23] \/ 4 => [4, 5]\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_L, \"1\"})\n+    public boolean testLongRange3(long in, long in2) {\n+        long a = (in & 31L) + 16L;\n+        long b = (in2 & 3L) + 5L;\n+        return a \/ b > 4L; \/\/ [16, 47] \/ [5, 8] => [2, 9]\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+\n+    public boolean testLongRange4(long in, long in2) {\n+        long a = (in & 15L); \/\/ [0, 15]\n+        long b = (in2 & 3L) + 1L; \/\/ [1, 4]\n+        return a \/ b >= 0L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public boolean testLongRange5(long in, long in2) {\n+        long a = (in & 15L) + 5L; \/\/ [5, 20]\n+        long b = (in2 & 3L) + 1L; \/\/ [1, 4]\n+        return a \/ b > 0L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public boolean testLongRange6(long in, long in2) {\n+        long a = (in & 15L) + 5L; \/\/ [5, 20]\n+        long b = (in2 & 7L) - 1L; \/\/ [-1, 5]\n+        if (b == 0L) return false;\n+        return a \/ b < -20L;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_L, \"1\"})\n+    public boolean testLongRange7(long in, long in2) {\n+        long a = (in & 15L) + 5L; \/\/ [5, 20]\n+        long b = (in2 & 7L) - 1L; \/\/ [-1, 5]\n+        if (b == 0L) return false;\n+        return a \/ b > 0L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV, IRNode.URSHIFT, IRNode.RSHIFT, IRNode.MUL, IRNode.ADD, IRNode.SUB, IRNode.AND})\n+    public long testLongRange8(long in, long in2) {\n+        long a = (in & 31L) + 128L; \/\/ [128, 159]\n+        long b = (in2 & 15L) + 100L; \/\/ [100, 115]\n+        return a \/ b; \/\/ [1, 1] -> can be constant\n+    }\n+\n+\n+    private static final long LONG_LIMIT_1 = LONGS.next();\n+    private static final long LONG_LIMIT_2 = LONGS.next();\n+    private static final long LONG_LIMIT_3 = LONGS.next();\n+    private static final long LONG_LIMIT_4 = LONGS.next();\n+    private static final long LONG_LIMIT_5 = LONGS.next();\n+    private static final long LONG_LIMIT_6 = LONGS.next();\n+    private static final long LONG_LIMIT_7 = LONGS.next();\n+    private static final long LONG_LIMIT_8 = LONGS.next();\n+    private static final long LONG_RANGE_LIMIT_X_LO;\n+    private static final long LONG_RANGE_LIMIT_X_HI;\n+    private static final long LONG_RANGE_LIMIT_Y_LO;\n+    private static final long LONG_RANGE_LIMIT_Y_HI;\n+\n+    static {\n+        long limit1 = LONGS.next();\n+        long limit2 = LONGS.next();\n+        if (limit2 > limit1) {\n+            LONG_RANGE_LIMIT_X_LO = limit1;\n+            LONG_RANGE_LIMIT_X_HI = limit2;\n+        } else {\n+            LONG_RANGE_LIMIT_X_LO = limit2;\n+            LONG_RANGE_LIMIT_X_HI = limit1;\n+        }\n+\n+        long limit3 = LONGS.next();\n+        long limit4 = LONGS.next();\n+        if (limit4 > limit3) {\n+            LONG_RANGE_LIMIT_Y_LO = limit3;\n+            LONG_RANGE_LIMIT_Y_HI = limit4;\n+        } else {\n+            LONG_RANGE_LIMIT_Y_LO = limit4;\n+            LONG_RANGE_LIMIT_Y_HI = limit3;\n+        }\n+    }\n+\n+    @ForceInline\n+    private long clampLong(long val, long lo, long hi) {\n+        return Math.min(hi, Math.max(val, lo));\n+    }\n+\n+    @ForceInline\n+    private int calculateLongSum(long z) {\n+        int sum = 0;\n+        if (z < LONG_LIMIT_1) sum += 1;\n+        if (z < LONG_LIMIT_2) sum += 2;\n+        if (z < LONG_LIMIT_3) sum += 4;\n+        if (z < LONG_LIMIT_4) sum += 8;\n+        if (z > LONG_LIMIT_5) sum += 16;\n+        if (z > LONG_LIMIT_6) sum += 32;\n+        if (z > LONG_LIMIT_7) sum += 64;\n+        if (z > LONG_LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    @Test\n+    public int testLongRandomLimits(long x, long y) {\n+        x = clampLong(x, LONG_RANGE_LIMIT_X_LO, LONG_RANGE_LIMIT_X_HI);\n+        y = clampLong(y, LONG_RANGE_LIMIT_Y_LO, LONG_RANGE_LIMIT_Y_HI);\n+        long z = x \/ y;\n+\n+        return calculateLongSum(z);\n+    }\n+\n+    @DontCompile\n+    public int testLongRandomLimitsInterpreted(long x, long y) {\n+        x = clampLong(x, LONG_RANGE_LIMIT_X_LO, LONG_RANGE_LIMIT_X_HI);\n+        y = clampLong(y, LONG_RANGE_LIMIT_Y_LO, LONG_RANGE_LIMIT_Y_HI);\n+        long z = x \/ y;\n+\n+        return calculateLongSum(z);\n+    }\n+\n+    @Run(test = {\"testLongConstantFolding\", \"testLongConstantFoldingSpecialCase\"})\n+    public void checkLongConstants(RunInfo infoLong) {\n+        Asserts.assertEquals(LONG_CONST_1 \/ LONG_CONST_2, testLongConstantFolding());\n+        Asserts.assertEquals(Long.MIN_VALUE, testLongConstantFoldingSpecialCase());\n+    }\n+\n+    @Run(test = {\"testLongRange\", \"testLongRange2\", \"testLongRange3\", \"testLongRange4\", \"testLongRange5\", \"testLongRange6\", \"testLongRange7\", \"testLongRange8\", \"testLongRandomLimits\"})\n+    public void checkLongRanges(RunInfo info) {\n+        for (int j = 0; j < 20; j++) {\n+            long l1 = LONGS.next();\n+            long l2 = LONGS.next();\n+            checkLong(l1, l2);\n+        }\n+    }\n+\n+    @DontCompile\n+    public void checkLong(long in, long in2) {\n+        long a;\n+        long b;\n+        a = (in & 7L) + 16L;\n+        Asserts.assertEquals(a \/ 12L, testLongRange(in));\n+\n+        a = (in & 7L) + 16L;\n+        Asserts.assertEquals(a \/ 4L > 3L, testLongRange2(in));\n+\n+        a = (in & 31L) + 16L;\n+        b = (in2 & 3L) + 5L;\n+        Asserts.assertEquals(a \/ b > 4L, testLongRange3(in, in2));\n+\n+        a = (in & 15L);\n+        b = (in2 & 3L) + 1L;\n+        Asserts.assertEquals(a \/ b >= 0L, testLongRange4(in, in2));\n+\n+        a = (in & 15L) + 5L;\n+        b = (in2 & 3L) + 1L;\n+        Asserts.assertEquals(a \/ b > 0L, testLongRange5(in, in2));\n+\n+        a = (in & 15L) + 5L;\n+        b = (in2 & 7L) - 1L;\n+        Asserts.assertEquals(b == 0 ? false : a \/ b < -20L, testLongRange6(in, in2));\n+\n+        a = (in & 15L) + 5L;\n+        b = (in2 & 7L) - 1L;\n+        Asserts.assertEquals(b == 0 ? false : a \/ b > 0L, testLongRange7(in, in2));\n+\n+        a = (in & 31L) + 128L;\n+        b = (in2 & 15L) + 100L;\n+        Asserts.assertEquals(a \/ b, testLongRange8(in, in2));\n+\n+        int res;\n+        try {\n+            res = testLongRandomLimitsInterpreted(a, b);\n+        } catch (ArithmeticException _) {\n+            try {\n+                testLongRandomLimits(a, b);\n+                Asserts.fail(\"Expected ArithmeticException\");\n+                return; \/\/ unreachable\n+            } catch (ArithmeticException _) {\n+                return; \/\/ test succeeded, no result to assert\n+            }\n+        }\n+        Asserts.assertEQ(res, testLongRandomLimits(a, b));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/IntegerDivValueTests.java","additions":505,"deletions":0,"binary":false,"changes":505,"status":"added"}]}