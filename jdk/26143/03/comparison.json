{"files":[{"patch":"@@ -507,0 +507,87 @@\n+template<typename IntegerType>\n+static const IntegerType* compute_generic_div_type(const IntegerType* i1, const IntegerType* i2, int widen) {\n+  typedef typename IntegerType::NativeType NativeType;\n+  assert(!i2->is_con() || i2->get_con() != 0, \"Can't handle zero constant divisor\");\n+\n+  \/\/ Case A: divisor range spans zero (i2->_lo < 0 < i2->_hi)\n+  \/\/ We split into two subproblems to avoid division by 0:\n+  \/\/   - negative part: [i2->_lo, −1]\n+  \/\/   - positive part: [1, i2->_hi]\n+  \/\/ Then we union the results by taking the min of all lower‐bounds and\n+  \/\/ the max of all upper‐bounds from the two halves.\n+  if (i2->_lo < 0 && i2->_hi > 0) {\n+    \/\/ Handle negative part of the divisor range\n+    const IntegerType* neg_part = compute_generic_div_type(i1, IntegerType::make(i2->_lo, -1, widen), widen);\n+    \/\/ Handle positive part of the divisor range\n+    const IntegerType* pos_part = compute_generic_div_type(i1, IntegerType::make(1, i2->_hi, widen), widen);\n+    \/\/ Merge results\n+    NativeType new_lo = MIN2(neg_part->_lo, pos_part->_lo);\n+    NativeType new_hi = MAX2(neg_part->_hi, pos_part->_hi);\n+    assert(new_hi >= new_lo, \"sanity\");\n+    return IntegerType::make(new_lo, new_hi, widen);\n+  }\n+\n+  \/\/ Case B: divisor range does NOT span zero.\n+  \/\/ Here i2 is entirely negative or entirely positive.\n+  \/\/ Let d_min and d_max be the nonzero endpoints of i2.\n+  \/\/ Then a\/b is monotonic in a and in b (when b keeps the same sign).\n+  \/\/ Therefore the extrema occur at the four “corners”:\n+  \/\/   (i1->_lo, i2->_hi), (i1->_lo, i2->_lo), (i1->_hi, i2->_lo), (i1->_hi, i2->_hi).\n+  \/\/ We compute all four and take the min and max.\n+  \/\/ A special case handles overflow when dividing the most‐negative value by −1.\n+\n+  \/\/ adjust i2 bounds to not include zero, as zero always throws\n+  NativeType i2_lo = i2->_lo == 0 ? 1 : i2->_lo;\n+  NativeType i2_hi = i2->_hi == 0 ? -1 : i2->_hi;\n+  NativeType min_val = std::numeric_limits<NativeType>::min();\n+  assert(min_val == min_jint || min_val == min_jlong, \"min has to be either min_jint or min_jlong\");\n+\n+  \/\/ Special overflow case: min_val \/ (-1) == min_val (cf. JVMS§6.5 idiv\/ldiv)\n+  \/\/ We need to be careful that we never run min_val \/ (-1) in C++ code, as this overflow is UB there\n+  \/\/ We also must include min_val in the output if i1->_lo == min_val and i2->_hi.\n+  if (i1->_lo == min_val && i2_hi == min_val) {\n+    \/\/ special overflow case as defined above, and as min_val is the lowest possible value, this is our lower bound\n+    NativeType new_lo = min_val;\n+    NativeType new_hi;\n+    \/\/ compute new_hi for non-constant divisor and\/or dividend.\n+    \/\/ i2 is purely in the negative domain here, which means the maximum value this division can yield is either\n+    \/\/ a) (min_val + 1) \/ -1 for non-constant dividend or\n+    \/\/ b) (min_val)     \/ -2 for non-constant divisor\n+    if (!i1->is_con()) {\n+      new_hi = (min_val + 1) \/ -1;\n+    } else if (i2_lo != i2_hi) {\n+      new_hi = min_val \/ -2;\n+    } else {\n+      new_hi = min_val;\n+    }\n+#ifdef ASSERT\n+    \/\/ validate new_hi for non-constant divisor\n+    if (i2_lo != i2_hi) {\n+      assert(i2_lo != -1, \"Special case not possible here, as i2_lo has to be < i2_hi\");\n+      NativeType result = i1->_lo \/ i2_lo;\n+      assert(new_hi >= result, \"computed wrong value for new_hi\");\n+    }\n+\n+    \/\/ validate new_hi for non-constant dividend\n+    if (!i1->is_con()) {\n+      assert(i2_hi > min_val, \"Special case not possible here, as i1->_hi has to be > min\");\n+      NativeType result1 = i1->_hi \/ i2_lo;\n+      NativeType result2 = i1->_hi \/ i2_hi;\n+      assert(new_hi >= result1 && new_hi >= result2, \"computed wrong value for new_hi\");\n+    }\n+#endif\n+\n+    return IntegerType::make(new_lo, new_hi, widen);\n+  }\n+\n+  \/\/ Special case not possible here, calculate all corners normally\n+  assert(i1->_lo != min_val && i1->_hi != min_val, \"Special has should have been filtered out\");\n+  NativeType corner1 = i1->_lo \/ i2_lo;\n+  NativeType corner2 = i1->_lo \/ i2_hi;\n+  NativeType corner3 = i1->_hi \/ i2_lo;\n+  NativeType corner4 = i1->_hi \/ i2_hi;\n+\n+  NativeType new_lo = MIN4(corner1, corner2, corner3, corner4);\n+  NativeType new_hi = MAX4(corner1, corner2, corner3, corner4);\n+  return IntegerType::make(new_lo, new_hi, widen);\n+}\n@@ -573,32 +660,5 @@\n-\n-  if( i2->is_con() && i2->get_con() != 0 ) {\n-    int32_t d = i2->get_con(); \/\/ Divisor\n-    jint lo, hi;\n-    if( d >= 0 ) {\n-      lo = i1->_lo\/d;\n-      hi = i1->_hi\/d;\n-    } else {\n-      if( d == -1 && i1->_lo == min_jint ) {\n-        \/\/ 'min_jint\/-1' throws arithmetic exception during compilation\n-        lo = min_jint;\n-        \/\/ do not support holes, 'hi' must go to either min_jint or max_jint:\n-        \/\/ [min_jint, -10]\/[-1,-1] ==> [min_jint] UNION [10,max_jint]\n-        hi = i1->_hi == min_jint ? min_jint : max_jint;\n-      } else {\n-        lo = i1->_hi\/d;\n-        hi = i1->_lo\/d;\n-      }\n-    }\n-    return TypeInt::make(lo, hi, widen);\n-  }\n-\n-  \/\/ If the dividend is a constant\n-  if( i1->is_con() ) {\n-    int32_t d = i1->get_con();\n-    if( d < 0 ) {\n-      if( d == min_jint ) {\n-        \/\/  (-min_jint) == min_jint == (min_jint \/ -1)\n-        return TypeInt::make(min_jint, max_jint\/2 + 1, widen);\n-      } else {\n-        return TypeInt::make(d, -d, widen);\n-      }\n+  if (i2->is_con()) {\n+    jint d = i2->get_con();    \/\/ Divisor\n+    if (d == 0) {\n+      \/\/ this division will always throw an exception\n+      return Type::TOP;\n@@ -606,1 +666,0 @@\n-    return TypeInt::make(-d, d, widen);\n@@ -609,2 +668,1 @@\n-  \/\/ Otherwise we give up all hope\n-  return TypeInt::INT;\n+  return compute_generic_div_type<TypeInt>(i1, i2, widen);\n@@ -679,2 +737,1 @@\n-\n-  if( i2->is_con() && i2->get_con() != 0 ) {\n+  if (i2->is_con()) {\n@@ -682,29 +739,3 @@\n-    jlong lo, hi;\n-    if( d >= 0 ) {\n-      lo = i1->_lo\/d;\n-      hi = i1->_hi\/d;\n-    } else {\n-      if( d == CONST64(-1) && i1->_lo == min_jlong ) {\n-        \/\/ 'min_jlong\/-1' throws arithmetic exception during compilation\n-        lo = min_jlong;\n-        \/\/ do not support holes, 'hi' must go to either min_jlong or max_jlong:\n-        \/\/ [min_jlong, -10]\/[-1,-1] ==> [min_jlong] UNION [10,max_jlong]\n-        hi = i1->_hi == min_jlong ? min_jlong : max_jlong;\n-      } else {\n-        lo = i1->_hi\/d;\n-        hi = i1->_lo\/d;\n-      }\n-    }\n-    return TypeLong::make(lo, hi, widen);\n-  }\n-\n-  \/\/ If the dividend is a constant\n-  if( i1->is_con() ) {\n-    jlong d = i1->get_con();\n-    if( d < 0 ) {\n-      if( d == min_jlong ) {\n-        \/\/  (-min_jlong) == min_jlong == (min_jlong \/ -1)\n-        return TypeLong::make(min_jlong, max_jlong\/2 + 1, widen);\n-      } else {\n-        return TypeLong::make(d, -d, widen);\n-      }\n+    if (d == 0) {\n+      \/\/ this division will always throw an exception\n+      return Type::TOP;\n@@ -712,1 +743,0 @@\n-    return TypeLong::make(-d, d, widen);\n@@ -715,2 +745,1 @@\n-  \/\/ Otherwise we give up all hope\n-  return TypeLong::LONG;\n+  return compute_generic_div_type<TypeLong>(i1, i2, widen);\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":98,"deletions":69,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.gvn;\n+\n+import compiler.lib.generators.*;\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8364766\n+ * @summary Test value method of DivINode and DivLNode\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.IntegerDivValueTests\n+ *\/\n+public class IntegerDivValueTests {\n+    private static final RestrictableGenerator<Integer> INTS = Generators.G.ints();\n+    private static final RestrictableGenerator<Long> LONGS = Generators.G.longs();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public int testIntConstantFolding() {\n+        \/\/ All constants available during parsing\n+        return 50 \/ 25;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public int testIntConstantFoldingSpecialCase() {\n+        \/\/ All constants available during parsing\n+        return Integer.MIN_VALUE \/ -1;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public int testIntRange(int in) {\n+        int a = (in & 7) + 16;\n+        return a \/ 12; \/\/ [16, 23] \/ 12 is constant 1\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public boolean testIntRange2(int in) {\n+        int a = (in & 7) + 16;\n+        return a \/ 4 > 3; \/\/ [16, 23] \/ 4 => [4, 5]\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_I, \"1\"})\n+    public boolean testIntRange3(int in, int in2) {\n+        int a = (in & 31) + 16;\n+        int b = (in2 & 3) + 5;\n+        return a \/ b > 4; \/\/ [16, 47] \/ [5, 8] => [2, 9]\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public boolean testIntRange4(int in, int in2) {\n+        int a = (in & 15); \/\/ [0, 15]\n+        int b = (in2 & 3) + 1; \/\/ [1, 4]\n+        return a \/ b >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public boolean testIntRange5(int in, int in2) {\n+        int a = (in & 15) + 5; \/\/ [5, 20]\n+        int b = (in2 & 3) + 1; \/\/ [1, 4]\n+        return a \/ b > 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public boolean testIntRange6(int in, int in2) {\n+        int a = (in & 15) + 5; \/\/ [5, 20]\n+        int b = (in2 & 7) - 1; \/\/ [-1, 5]\n+        if (b == 0) return false;\n+        return a \/ b >= -20;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_I, \"1\"})\n+    public boolean testIntRange7(int in, int in2) {\n+        int a = (in & 15) + 5; \/\/ [5, 20]\n+        int b = (in2 & 7) - 1; \/\/ [-1, 5]\n+        if (b == 0) return false;\n+        return a \/ b > 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public int testIntRange8(int in, int in2) {\n+        int a = (in & 31) + 128; \/\/ [128, 159]\n+        int b = (in2 & 15) + 100; \/\/ [100, 115]\n+        return a \/ b; \/\/ [1, 1] -> can be constant\n+    }\n+\n+    @Run(test = {\"testIntConstantFolding\", \"testIntConstantFoldingSpecialCase\"})\n+    public void checkIntConstants(RunInfo info) {\n+        Asserts.assertEquals(2, testIntConstantFolding());\n+        Asserts.assertEquals(Integer.MIN_VALUE, testIntConstantFoldingSpecialCase());\n+    }\n+\n+    @Run(test = {\"testIntRange\", \"testIntRange2\", \"testIntRange3\", \"testIntRange4\", \"testIntRange5\", \"testIntRange6\", \"testIntRange7\", \"testIntRange8\"})\n+    public void checkIntRanges(RunInfo info) {\n+        for (int j = 0; j < 20; j++) {\n+            int i1 = INTS.next();\n+            int i2 = INTS.next();\n+            checkInt(i1, i2);\n+        }\n+    }\n+\n+    @DontCompile\n+    public void checkInt(int in, int in2) {\n+        int a;\n+        int b;\n+        a = (in & 7) + 16;\n+        Asserts.assertEquals(a \/ 12, testIntRange(in));\n+\n+        a = (in & 7) + 16;\n+        Asserts.assertEquals(a \/ 4 > 3, testIntRange2(in));\n+\n+        a = (in & 31) + 16;\n+        b = (in2 & 3) + 5;\n+        Asserts.assertEquals(a \/ b > 4, testIntRange3(in, in2));\n+\n+        a = (in & 15);\n+        b = (in2 & 3) + 1;\n+        Asserts.assertEquals(a \/ b >= 0, testIntRange4(in, in2));\n+\n+        a = (in & 15) + 5;\n+        b = (in2 & 3) + 1;\n+        Asserts.assertEquals(a \/ b > 0, testIntRange5(in, in2));\n+\n+        a = (in & 15) + 5;\n+        b = (in2 & 7) - 1;\n+        Asserts.assertEquals(b == 0 ? false : a \/ b >= -20, testIntRange6(in, in2));\n+\n+        a = (in & 15) + 5;\n+        b = (in2 & 7) - 1;\n+        Asserts.assertEquals(b == 0 ? false : a \/ b > 0, testIntRange7(in, in2));\n+\n+        a = (in & 31) + 128;\n+        b = (in2 & 15) + 100;\n+        Asserts.assertEquals(a \/ b, testIntRange8(in, in2));\n+    }\n+\n+    \/\/ Long variants\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public long testLongConstantFolding() {\n+        \/\/ All constants available during parsing\n+        return 50L \/ 25L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public long testLongConstantFoldingSpecialCase() {\n+        \/\/ All constants available during parsing\n+        return Long.MIN_VALUE \/ -1L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public long testLongRange(long in) {\n+        long a = (in & 7L) + 16L;\n+        return a \/ 12L; \/\/ [16, 23] \/ 12 is constant 1\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public boolean testLongRange2(long in) {\n+        long a = (in & 7L) + 16L;\n+        return a \/ 4L > 3L; \/\/ [16, 23] \/ 4 => [4, 5]\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_L, \"1\"})\n+    public boolean testLongRange3(long in, long in2) {\n+        long a = (in & 31L) + 16L;\n+        long b = (in2 & 3L) + 5L;\n+        return a \/ b > 4L; \/\/ [16, 47] \/ [5, 8] => [2, 9]\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public boolean testLongRange4(long in, long in2) {\n+        long a = (in & 15L); \/\/ [0, 15]\n+        long b = (in2 & 3L) + 1L; \/\/ [1, 4]\n+        return a \/ b >= 0L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public boolean testLongRange5(long in, long in2) {\n+        long a = (in & 15L) + 5L; \/\/ [5, 20]\n+        long b = (in2 & 3L) + 1L; \/\/ [1, 4]\n+        return a \/ b > 0L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public boolean testLongRange6(long in, long in2) {\n+        long a = (in & 15L) + 5L; \/\/ [5, 20]\n+        long b = (in2 & 7L) - 1L; \/\/ [-1, 5]\n+        if (b == 0L) return false;\n+        return a \/ b >= -20L;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.DIV_L, \"1\"})\n+    public boolean testLongRange7(long in, long in2) {\n+        long a = (in & 15L) + 5L; \/\/ [5, 20]\n+        long b = (in2 & 7L) - 1L; \/\/ [-1, 5]\n+        if (b == 0L) return false;\n+        return a \/ b > 0L;\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    public long testLongRange8(long in, long in2) {\n+        long a = (in & 31L) + 128L; \/\/ [128, 159]\n+        long b = (in2 & 15L) + 100L; \/\/ [100, 115]\n+        return a \/ b; \/\/ [1, 1] -> can be constant\n+    }\n+\n+    @Run(test = {\"testLongConstantFolding\", \"testLongConstantFoldingSpecialCase\"})\n+    public void checkLongConstants(RunInfo info) {\n+        Asserts.assertEquals(2L, testLongConstantFolding());\n+        Asserts.assertEquals(Long.MIN_VALUE, testLongConstantFoldingSpecialCase());\n+    }\n+\n+    @Run(test = {\"testLongRange\", \"testLongRange2\", \"testLongRange3\", \"testLongRange4\", \"testLongRange5\", \"testLongRange6\", \"testLongRange7\", \"testLongRange8\"})\n+    public void checkLongRanges(RunInfo info) {\n+        for (int j = 0; j < 20; j++) {\n+            long l1 = LONGS.next();\n+            long l2 = LONGS.next();\n+            checkLong(l1, l2);\n+        }\n+    }\n+\n+    @DontCompile\n+    public void checkLong(long in, long in2) {\n+        long a;\n+        long b;\n+        a = (in & 7L) + 16L;\n+        Asserts.assertEquals(a \/ 12L, testLongRange(in));\n+\n+        a = (in & 7L) + 16L;\n+        Asserts.assertEquals(a \/ 4L > 3L, testLongRange2(in));\n+\n+        a = (in & 31L) + 16L;\n+        b = (in2 & 3L) + 5L;\n+        Asserts.assertEquals(a \/ b > 4L, testLongRange3(in, in2));\n+\n+        a = (in & 15L);\n+        b = (in2 & 3L) + 1L;\n+        Asserts.assertEquals(a \/ b >= 0L, testLongRange4(in, in2));\n+\n+        a = (in & 15L) + 5L;\n+        b = (in2 & 3L) + 1L;\n+        Asserts.assertEquals(a \/ b > 0L, testLongRange5(in, in2));\n+\n+        a = (in & 15L) + 5L;\n+        b = (in2 & 7L) - 1L;\n+        Asserts.assertEquals(b == 0 ? false : a \/ b >= -20L, testLongRange6(in, in2));\n+\n+        a = (in & 15L) + 5L;\n+        b = (in2 & 7L) - 1L;\n+        Asserts.assertEquals(b == 0 ? false : a \/ b > 0L, testLongRange7(in, in2));\n+\n+        a = (in & 31L) + 128L;\n+        b = (in2 & 15L) + 100L;\n+        Asserts.assertEquals(a \/ b, testLongRange8(in, in2));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/IntegerDivValueTests.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"}]}