{"files":[{"patch":"@@ -508,1 +508,1 @@\n-static const IntegerType* compute_generic_div_type(const IntegerType* i1, const IntegerType* i2, int widen) {\n+static const IntegerType* compute_signed_div_type(const IntegerType* i1, const IntegerType* i2, int widen) {\n@@ -520,1 +520,1 @@\n-    const IntegerType* neg_part = compute_generic_div_type(i1, IntegerType::make(i2->_lo, -1, widen), widen);\n+    const IntegerType* neg_part = compute_signed_div_type(i1, IntegerType::make(i2->_lo, -1, widen), widen);\n@@ -522,1 +522,1 @@\n-    const IntegerType* pos_part = compute_generic_div_type(i1, IntegerType::make(1, i2->_hi, widen), widen);\n+    const IntegerType* pos_part = compute_signed_div_type(i1, IntegerType::make(1, i2->_hi, widen), widen);\n@@ -532,2 +532,1 @@\n-  \/\/ Let d_min and d_max be the nonzero endpoints of i2.\n-  \/\/ Then a\/b is monotonic in a and in b (when b keeps the same sign).\n+  \/\/ Then i1\/i2 is monotonic in i1 and i2 (when i2 keeps the same sign).\n@@ -542,2 +541,2 @@\n-  NativeType min_val = std::numeric_limits<NativeType>::min();\n-  assert(min_val == min_jint || min_val == min_jlong, \"min has to be either min_jint or min_jlong\");\n+  constexpr NativeType min_val = std::numeric_limits<NativeType>::min();\n+  static_assert(min_val == min_jint || min_val == min_jlong, \"min has to be either min_jint or min_jlong\");\n@@ -547,1 +546,0 @@\n-  \/\/ We also must include min_val in the output if i1->_lo == min_val and i2->_hi.\n@@ -549,1 +547,0 @@\n-    \/\/ special overflow case as defined above, and as min_val is the lowest possible value, this is our lower bound\n@@ -552,4 +549,6 @@\n-    \/\/ compute new_hi for non-constant divisor and\/or dividend.\n-    \/\/ i2 is purely in the negative domain here, which means the maximum value this division can yield is either\n-    \/\/ a) (min_val + 1) \/ -1 for non-constant dividend or\n-    \/\/ b) (min_val)     \/ -2 for non-constant divisor\n+    \/\/ compute new_hi depending on whether divisor or dividend is non-constant.\n+    \/\/ i2 is purely in the negative domain here (as i2_hi is -1)\n+    \/\/ which means the maximum value this division can yield is either\n+    \/\/ a) (min_val + 1) \/ -1 (which is the same as max_val) for non-constant dividend or\n+    \/\/ b) (min_val)     \/ -2 for constant dividend and non-constant divisor or\n+    \/\/ c) min_val            for constant dividend and constant divisor\n@@ -667,1 +666,1 @@\n-  return compute_generic_div_type<TypeInt>(i1, i2, widen);\n+  return compute_signed_div_type<TypeInt>(i1, i2, widen);\n@@ -744,1 +743,1 @@\n-  return compute_generic_div_type<TypeLong>(i1, i2, widen);\n+  return compute_signed_div_type<TypeLong>(i1, i2, widen);\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -45,0 +45,5 @@\n+    @ForceInline\n+    private int getIntConstant(int value) {\n+        return value;\n+    }\n+\n@@ -49,1 +54,1 @@\n-        return 50 \/ 25;\n+        return getIntConstant(50) \/ getIntConstant(25);\n@@ -56,1 +61,1 @@\n-        return Integer.MIN_VALUE \/ -1;\n+        return getIntConstant(Integer.MIN_VALUE) \/ getIntConstant(-1);\n@@ -123,0 +128,73 @@\n+    private static final int INT_LIMIT_1 = INTS.next();\n+    private static final int INT_LIMIT_2 = INTS.next();\n+    private static final int INT_LIMIT_3 = INTS.next();\n+    private static final int INT_LIMIT_4 = INTS.next();\n+    private static final int INT_LIMIT_5 = INTS.next();\n+    private static final int INT_LIMIT_6 = INTS.next();\n+    private static final int INT_LIMIT_7 = INTS.next();\n+    private static final int INT_LIMIT_8 = INTS.next();\n+    private static final int INT_RANGE_LIMIT_X_LO;\n+    private static final int INT_RANGE_LIMIT_X_HI;\n+    private static final int INT_RANGE_LIMIT_Y_LO;\n+    private static final int INT_RANGE_LIMIT_Y_HI;\n+\n+    static {\n+        int limit1 = INTS.next();\n+        int limit2 = INTS.next();\n+        if (limit2 > limit1) {\n+            INT_RANGE_LIMIT_X_LO = limit1;\n+            INT_RANGE_LIMIT_X_HI = limit2;\n+        } else {\n+            INT_RANGE_LIMIT_X_LO = limit2;\n+            INT_RANGE_LIMIT_X_HI = limit1;\n+        }\n+\n+        int limit3 = INTS.next();\n+        int limit4 = INTS.next();\n+        if (limit4 > limit3) {\n+            INT_RANGE_LIMIT_Y_LO = limit3;\n+            INT_RANGE_LIMIT_Y_HI = limit4;\n+        } else {\n+            INT_RANGE_LIMIT_Y_LO = limit4;\n+            INT_RANGE_LIMIT_Y_HI = limit3;\n+        }\n+    }\n+\n+    @ForceInline\n+    private int clampInt(int val, int lo, int hi) {\n+        return Math.min(hi, Math.max(val, lo));\n+    }\n+\n+    @ForceInline\n+    private int calculateIntSum(int z) {\n+        int sum = 0;\n+        if (z < INT_LIMIT_1) sum += 1;\n+        if (z < INT_LIMIT_2) sum += 2;\n+        if (z < INT_LIMIT_3) sum += 4;\n+        if (z < INT_LIMIT_4) sum += 8;\n+        if (z > INT_LIMIT_5) sum += 16;\n+        if (z > INT_LIMIT_6) sum += 32;\n+        if (z > INT_LIMIT_7) sum += 64;\n+        if (z > INT_LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    @Test\n+    public int testIntRandomLimits(int x, int y) {\n+        x = clampInt(x, INT_RANGE_LIMIT_X_LO, INT_RANGE_LIMIT_X_HI);\n+        y = clampInt(y, INT_RANGE_LIMIT_Y_LO, INT_RANGE_LIMIT_Y_HI);\n+        int z = x \/ y;\n+\n+        return calculateIntSum(z);\n+    }\n+\n+    @DontCompile\n+    public int testIntRandomLimitsInterpreted(int x, int y) {\n+        x = clampInt(x, INT_RANGE_LIMIT_X_LO, INT_RANGE_LIMIT_X_HI);\n+        y = clampInt(y, INT_RANGE_LIMIT_Y_LO, INT_RANGE_LIMIT_Y_HI);\n+        int z = x \/ y;\n+\n+        return calculateIntSum(z);\n+    }\n+\n@@ -129,1 +207,1 @@\n-    @Run(test = {\"testIntRange\", \"testIntRange2\", \"testIntRange3\", \"testIntRange4\", \"testIntRange5\", \"testIntRange6\", \"testIntRange7\", \"testIntRange8\"})\n+    @Run(test = {\"testIntRange\", \"testIntRange2\", \"testIntRange3\", \"testIntRange4\", \"testIntRange5\", \"testIntRange6\", \"testIntRange7\", \"testIntRange8\", \"testIntRandomLimits\"})\n@@ -171,0 +249,14 @@\n+\n+        int res;\n+        try {\n+            res = testIntRandomLimitsInterpreted(a, b);\n+        } catch (ArithmeticException _) {\n+            try {\n+                testIntRandomLimits(a, b);\n+                Asserts.fail(\"Expected ArithmeticException\");\n+                return; \/\/ unreachable\n+            } catch (ArithmeticException _) {\n+                return; \/\/ test succeeded, no result to assert\n+            }\n+        }\n+        Asserts.assertEQ(res, testIntRandomLimits(a, b));\n@@ -175,0 +267,5 @@\n+    @ForceInline\n+    private long getLongConstant(long value) {\n+        return value;\n+    }\n+\n@@ -179,1 +276,1 @@\n-        return 50L \/ 25L;\n+        return getLongConstant(50L) \/ getLongConstant(25L);\n@@ -186,1 +283,1 @@\n-        return Long.MIN_VALUE \/ -1L;\n+        return getLongConstant(Long.MIN_VALUE) \/ getLongConstant(-1L);\n@@ -253,0 +350,74 @@\n+\n+    private static final long LONG_LIMIT_1 = LONGS.next();\n+    private static final long LONG_LIMIT_2 = LONGS.next();\n+    private static final long LONG_LIMIT_3 = LONGS.next();\n+    private static final long LONG_LIMIT_4 = LONGS.next();\n+    private static final long LONG_LIMIT_5 = LONGS.next();\n+    private static final long LONG_LIMIT_6 = LONGS.next();\n+    private static final long LONG_LIMIT_7 = LONGS.next();\n+    private static final long LONG_LIMIT_8 = LONGS.next();\n+    private static final long LONG_RANGE_LIMIT_X_LO;\n+    private static final long LONG_RANGE_LIMIT_X_HI;\n+    private static final long LONG_RANGE_LIMIT_Y_LO;\n+    private static final long LONG_RANGE_LIMIT_Y_HI;\n+\n+    static {\n+        long limit1 = LONGS.next();\n+        long limit2 = LONGS.next();\n+        if (limit2 > limit1) {\n+            LONG_RANGE_LIMIT_X_LO = limit1;\n+            LONG_RANGE_LIMIT_X_HI = limit2;\n+        } else {\n+            LONG_RANGE_LIMIT_X_LO = limit2;\n+            LONG_RANGE_LIMIT_X_HI = limit1;\n+        }\n+\n+        long limit3 = LONGS.next();\n+        long limit4 = LONGS.next();\n+        if (limit4 > limit3) {\n+            LONG_RANGE_LIMIT_Y_LO = limit3;\n+            LONG_RANGE_LIMIT_Y_HI = limit4;\n+        } else {\n+            LONG_RANGE_LIMIT_Y_LO = limit4;\n+            LONG_RANGE_LIMIT_Y_HI = limit3;\n+        }\n+    }\n+\n+    @ForceInline\n+    private long clampLong(long val, long lo, long hi) {\n+        return Math.min(hi, Math.max(val, lo));\n+    }\n+\n+    @ForceInline\n+    private int calculateLongSum(long z) {\n+        int sum = 0;\n+        if (z < LONG_LIMIT_1) sum += 1;\n+        if (z < LONG_LIMIT_2) sum += 2;\n+        if (z < LONG_LIMIT_3) sum += 4;\n+        if (z < LONG_LIMIT_4) sum += 8;\n+        if (z > LONG_LIMIT_5) sum += 16;\n+        if (z > LONG_LIMIT_6) sum += 32;\n+        if (z > LONG_LIMIT_7) sum += 64;\n+        if (z > LONG_LIMIT_8) sum += 128;\n+\n+        return sum;\n+    }\n+\n+    @Test\n+    public int testLongRandomLimits(long x, long y) {\n+        x = clampLong(x, LONG_RANGE_LIMIT_X_LO, LONG_RANGE_LIMIT_X_HI);\n+        y = clampLong(y, LONG_RANGE_LIMIT_Y_LO, LONG_RANGE_LIMIT_Y_HI);\n+        long z = x \/ y;\n+\n+        return calculateLongSum(z);\n+    }\n+\n+    @DontCompile\n+    public int testLongRandomLimitsInterpreted(long x, long y) {\n+        x = clampLong(x, LONG_RANGE_LIMIT_X_LO, LONG_RANGE_LIMIT_X_HI);\n+        y = clampLong(y, LONG_RANGE_LIMIT_Y_LO, LONG_RANGE_LIMIT_Y_HI);\n+        long z = x \/ y;\n+\n+        return calculateLongSum(z);\n+    }\n+\n@@ -254,1 +425,1 @@\n-    public void checkLongConstants(RunInfo info) {\n+    public void checkLongConstants(RunInfo infoLong) {\n@@ -259,1 +430,1 @@\n-    @Run(test = {\"testLongRange\", \"testLongRange2\", \"testLongRange3\", \"testLongRange4\", \"testLongRange5\", \"testLongRange6\", \"testLongRange7\", \"testLongRange8\"})\n+    @Run(test = {\"testLongRange\", \"testLongRange2\", \"testLongRange3\", \"testLongRange4\", \"testLongRange5\", \"testLongRange6\", \"testLongRange7\", \"testLongRange8\", \"testLongRandomLimits\"})\n@@ -301,0 +472,14 @@\n+\n+        int res;\n+        try {\n+            res = testLongRandomLimitsInterpreted(a, b);\n+        } catch (ArithmeticException _) {\n+            try {\n+                testLongRandomLimits(a, b);\n+                Asserts.fail(\"Expected ArithmeticException\");\n+                return; \/\/ unreachable\n+            } catch (ArithmeticException _) {\n+                return; \/\/ test succeeded, no result to assert\n+            }\n+        }\n+        Asserts.assertEQ(res, testLongRandomLimits(a, b));\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/IntegerDivValueTests.java","additions":192,"deletions":7,"binary":false,"changes":199,"status":"modified"}]}