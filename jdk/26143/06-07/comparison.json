{"files":[{"patch":"@@ -508,1 +508,1 @@\n-static const IntegerType* compute_signed_div_type(const IntegerType* i1, const IntegerType* i2, int widen) {\n+static const IntegerType* compute_signed_div_type(const IntegerType* i1, const IntegerType* i2) {\n@@ -511,0 +511,1 @@\n+  int widen = MAX2(i1->_widen, i2->_widen);\n@@ -520,1 +521,1 @@\n-    const IntegerType* neg_part = compute_signed_div_type(i1, IntegerType::make(i2->_lo, -1, widen), widen);\n+    const IntegerType* neg_part = compute_signed_div_type(i1, IntegerType::make(i2->_lo, -1, widen));\n@@ -522,1 +523,1 @@\n-    const IntegerType* pos_part = compute_signed_div_type(i1, IntegerType::make(1, i2->_hi, widen), widen);\n+    const IntegerType* pos_part = compute_signed_div_type(i1, IntegerType::make(1, i2->_hi, widen));\n@@ -637,4 +638,10 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  if (t2 == TypeInt::ZERO) {\n+    \/\/ this division will always throw an exception\n+    return Type::TOP;\n+  }\n@@ -647,18 +654,2 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  \/\/ Divide the two numbers.  We approximate.\n-  \/\/ If divisor is a constant and not zero\n-  const TypeInt *i1 = t1->is_int();\n-  const TypeInt *i2 = t2->is_int();\n-  int widen = MAX2(i1->_widen, i2->_widen);\n-  if (i2->is_con()) {\n-    jint d = i2->get_con();    \/\/ Divisor\n-    if (d == 0) {\n-      \/\/ this division will always throw an exception\n-      return Type::TOP;\n-    }\n-  }\n+  const TypeInt* i1 = t1->is_int();\n+  const TypeInt* i2 = t2->is_int();\n@@ -666,1 +657,1 @@\n-  return compute_signed_div_type<TypeInt>(i1, i2, widen);\n+  return compute_signed_div_type<TypeInt>(i1, i2);\n@@ -714,4 +705,10 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n-  if( t1 == Type::TOP ) return Type::TOP;\n-  if( t2 == Type::TOP ) return Type::TOP;\n+  const Type* t1 = phase->type(in(1));\n+  const Type* t2 = phase->type(in(2));\n+  if (t1 == Type::TOP || t2 == Type::TOP) {\n+    return Type::TOP;\n+  }\n+\n+  if (t2 == TypeLong::ZERO) {\n+    \/\/ this division will always throw an exception\n+    return Type::TOP;\n+  }\n@@ -724,18 +721,2 @@\n-  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n-  const Type *bot = bottom_type();\n-  if( (t1 == bot) || (t2 == bot) ||\n-      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n-    return bot;\n-\n-  \/\/ Divide the two numbers.  We approximate.\n-  \/\/ If divisor is a constant and not zero\n-  const TypeLong *i1 = t1->is_long();\n-  const TypeLong *i2 = t2->is_long();\n-  int widen = MAX2(i1->_widen, i2->_widen);\n-  if (i2->is_con()) {\n-    jlong d = i2->get_con();    \/\/ Divisor\n-    if (d == 0) {\n-      \/\/ this division will always throw an exception\n-      return Type::TOP;\n-    }\n-  }\n+  const TypeLong* i1 = t1->is_long();\n+  const TypeLong* i2 = t2->is_long();\n@@ -743,1 +724,1 @@\n-  return compute_signed_div_type<TypeLong>(i1, i2, widen);\n+  return compute_signed_div_type<TypeLong>(i1, i2);\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":30,"deletions":49,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+        \/\/ Simply return the given value to avoid javac already optimizing the operation away\n@@ -50,0 +51,3 @@\n+    private static final int INT_CONST_1 = INTS.next();\n+    private static final int INT_CONST_2 = INTS.next();\n+\n@@ -51,1 +55,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -54,1 +58,1 @@\n-        return getIntConstant(50) \/ getIntConstant(25);\n+        return INT_CONST_1 \/ INT_CONST_2;\n@@ -58,1 +62,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -65,1 +69,2 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n+\n@@ -72,1 +77,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -87,1 +92,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -95,1 +100,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -103,1 +108,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -108,1 +113,1 @@\n-        return a \/ b >= -20;\n+        return a \/ b < -20;\n@@ -121,1 +126,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -203,1 +208,1 @@\n-        Asserts.assertEquals(2, testIntConstantFolding());\n+        Asserts.assertEquals(INT_CONST_1 \/ INT_CONST_2, testIntConstantFolding());\n@@ -240,1 +245,1 @@\n-        Asserts.assertEquals(b == 0 ? false : a \/ b >= -20, testIntRange6(in, in2));\n+        Asserts.assertEquals(b == 0 ? false : a \/ b < -20, testIntRange6(in, in2));\n@@ -269,0 +274,1 @@\n+        \/\/ Simply return the given value to avoid javac already optimizing the operation away\n@@ -272,0 +278,3 @@\n+    private static final long LONG_CONST_1 = LONGS.next();\n+    private static final long LONG_CONST_2 = LONGS.next();\n+\n@@ -273,1 +282,5 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    \/\/@IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n+    \/\/ This results in a series of nodes due to DivLNode::Ideal and in particular transform_long_divide, which operates on non-constant divisors.\n+    \/\/ transform_long_divide splits up the division into multiple other nodes, such as MulHiLNode, which does not have a good Value() implemantion.\n+    \/\/ When JDK-8366815 is fixed, these rules should be reenabled\n+    \/\/ Alternatively, a better MulHiLNode::Value() implemantion should also lead to constant folding\n@@ -276,1 +289,1 @@\n-        return getLongConstant(50L) \/ getLongConstant(25L);\n+        return LONG_CONST_1 \/ LONG_CONST_2;\n@@ -280,1 +293,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -287,1 +300,5 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    \/\/@IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n+    \/\/ This results in a series of nodes due to DivLNode::Ideal and in particular transform_long_divide, which operates on non-constant divisors.\n+    \/\/ transform_long_divide splits up the division into multiple other nodes, such as MulHiLNode, which does not have a good Value() implemantion.\n+    \/\/ When JDK-8366815 is fixed, these rules should be reenabled\n+    \/\/ Alternatively, a better MulHiLNode::Value() implemantion should also lead to constant folding\n@@ -294,1 +311,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -309,1 +326,2 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n+\n@@ -317,1 +335,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -325,1 +343,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -330,1 +348,1 @@\n-        return a \/ b >= -20L;\n+        return a \/ b < -20L;\n@@ -343,1 +361,1 @@\n-    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L})\n+    @IR(failOn = {IRNode.DIV_I, IRNode.DIV_L, IRNode.URSHIFT_I, IRNode.URSHIFT_L, IRNode.RSHIFT_I, IRNode.RSHIFT_L, IRNode.MUL_I, IRNode.MUL_L, IRNode.ADD_I, IRNode.ADD_L, IRNode.SUB_I, IRNode.SUB_L, IRNode.AND_I, IRNode.AND_L})\n@@ -426,1 +444,1 @@\n-        Asserts.assertEquals(2L, testLongConstantFolding());\n+        Asserts.assertEquals(LONG_CONST_1 \/ LONG_CONST_2, testLongConstantFolding());\n@@ -463,1 +481,1 @@\n-        Asserts.assertEquals(b == 0 ? false : a \/ b >= -20L, testLongRange6(in, in2));\n+        Asserts.assertEquals(b == 0 ? false : a \/ b < -20L, testLongRange6(in, in2));\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/IntegerDivValueTests.java","additions":42,"deletions":24,"binary":false,"changes":66,"status":"modified"}]}