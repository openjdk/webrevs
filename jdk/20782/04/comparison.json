{"files":[{"patch":"@@ -35,2 +35,2 @@\n-\/\/ The AttachListener thread services a queue of operations. It blocks in the dequeue\n-\/\/ function until an operation is enqueued. A client enqueues an operation by creating\n+\/\/ The AttachListener thread services a queue of operation requests. It blocks in the dequeue\n+\/\/ function until a request is enqueued. A client enqueues a request by creating\n@@ -39,2 +39,2 @@\n-\/\/ JVM_EnqueueOperation function which checks the operation parameters and enqueues\n-\/\/ the operation to the queue serviced by the attach listener. The thread created by\n+\/\/ JVM_EnqueueOperation or JVM_EnqueueOperation_v2 function which checks the operation parameters\n+\/\/ and enqueues the operation request to the queue. The thread created by\n@@ -42,2 +42,2 @@\n-\/\/ it simple operations are pre-allocated at initialization time. An enqueue thus\n-\/\/ takes a preallocated operation, populates the operation parameters, adds it to\n+\/\/ it simple operation requests are pre-allocated at initialization time. An enqueue thus\n+\/\/ takes a preallocated request, populates the operation parameters, adds it to\n@@ -46,0 +46,7 @@\n+\/\/ Differences between Attach API v1 and v2:\n+\/\/ In v1 (jdk6+) client calls JVM_EnqueueOperation function and passes all operation parameters\n+\/\/ as arguments of the function.\n+\/\/ In v2 (jdk24+) client calls JVM_EnqueueOperation_v2 function and passes only pipe name.\n+\/\/ Attach listeners connects to the pipe (in read\/write mode) and reads all operation parameters\n+\/\/ (the same way as other platform implementations read them using sockets).\n+\/\/\n@@ -58,2 +65,148 @@\n-\/\/ forward reference\n-class Win32AttachOperation;\n+class PipeChannel : public AttachOperation::RequestReader, public AttachOperation::ReplyWriter {\n+private:\n+  HANDLE _hPipe;\n+public:\n+  PipeChannel() : _hPipe(INVALID_HANDLE_VALUE) {}\n+  ~PipeChannel() {\n+    close();\n+  }\n+\n+  bool opened() const {\n+    return _hPipe != INVALID_HANDLE_VALUE;\n+  }\n+\n+  bool open(const char* pipe, bool write_only) {\n+    _hPipe = ::CreateFile(pipe,\n+                          GENERIC_WRITE | (write_only ? 0 : GENERIC_READ),\n+                          0,              \/\/ no sharing\n+                          nullptr,        \/\/ default security attributes\n+                          OPEN_EXISTING,  \/\/ opens existing pipe\n+                          0,              \/\/ default attributes\n+                          nullptr);       \/\/ no template file\n+    if (_hPipe == INVALID_HANDLE_VALUE) {\n+      log_error(attach)(\"could not open (%d) pipe %s\", GetLastError(), pipe);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  void close() {\n+    if (opened()) {\n+      CloseHandle(_hPipe);\n+      _hPipe = INVALID_HANDLE_VALUE;\n+    }\n+  }\n+\n+  \/\/ RequestReader\n+  int read(void* buffer, int size) override {\n+    assert(opened(), \"must be\");\n+    DWORD nread;\n+    BOOL fSuccess = ReadFile(_hPipe,\n+                             buffer,\n+                             (DWORD)size,\n+                             &nread,\n+                             nullptr);   \/\/ not overlapped\n+    return fSuccess ? (int)nread : -1;\n+  }\n+\n+  \/\/ ReplyWriter\n+  int write(const void* buffer, int size) override {\n+    assert(opened(), \"must be\");\n+    DWORD written;\n+    BOOL fSuccess = WriteFile(_hPipe,\n+                              buffer,\n+                              (DWORD)size,\n+                              &written,\n+                              nullptr);  \/\/ not overlapped\n+    return fSuccess ? (int)written : -1;\n+  }\n+\n+  void flush() override {\n+    assert(opened(), \"must be\");\n+    FlushFileBuffers(_hPipe);\n+  }\n+};\n+\n+class Win32AttachOperation: public AttachOperation {\n+public:\n+  enum {\n+    pipe_name_max = 256             \/\/ maximum pipe name\n+  };\n+\n+private:\n+  PipeChannel _pipe;\n+\n+public:\n+  \/\/ for v1 pipe must be write-only\n+  void open_pipe(const char* pipe_name, bool write_only) {\n+    _pipe.open(pipe_name, write_only);\n+  }\n+\n+  bool read_request() {\n+      return AttachOperation::read_request(&_pipe);\n+  }\n+\n+public:\n+  void complete(jint result, bufferedStream* result_stream) override;\n+};\n+\n+\n+\/\/ Win32AttachOperationRequest is an element of AttachOperation request list.\n+class Win32AttachOperationRequest {\n+private:\n+  AttachAPIVersion _ver;\n+  char _name[AttachOperation::name_length_max + 1];\n+  char _arg[AttachOperation::arg_count_max][AttachOperation::arg_length_max + 1];\n+  char _pipe[Win32AttachOperation::pipe_name_max + 1];\n+\n+  Win32AttachOperationRequest* _next;\n+\n+  void set_value(char* dst, const char* str, size_t dst_size) {\n+    if (str != nullptr) {\n+        assert(strlen(str) < dst_size, \"exceeds maximum length\");\n+        strncpy(dst, str, dst_size - 1);\n+        dst[dst_size - 1] = '\\0';\n+    } else {\n+      strcpy(dst, \"\");\n+    }\n+  }\n+\n+public:\n+  void set(AttachAPIVersion ver, const char* pipename,\n+           const char* cmd = nullptr,\n+           const char* arg0 = nullptr,\n+           const char* arg1 = nullptr,\n+           const char* arg2 = nullptr) {\n+      _ver = ver;\n+      set_value(_name, cmd, sizeof(_name));\n+      set_value(_arg[0], arg0, sizeof(_arg[0]));\n+      set_value(_arg[1], arg1, sizeof(_arg[1]));\n+      set_value(_arg[2], arg2, sizeof(_arg[2]));\n+      set_value(_pipe, pipename, sizeof(_pipe));\n+  }\n+  AttachAPIVersion ver() const {\n+    return _ver;\n+  }\n+  const char* cmd() const {\n+    return _name;\n+  }\n+  const char* arg(int i) const {\n+    return (i >= 0 && i < AttachOperation::arg_count_max) ? _arg[i] : nullptr;\n+  }\n+  const char* pipe() const {\n+    return _pipe;\n+  }\n+\n+  Win32AttachOperationRequest* next() const {\n+    return _next;\n+  }\n+  void set_next(Win32AttachOperationRequest* next) {\n+    _next = next;\n+  }\n+\n+  \/\/ noarg constructor as operation is preallocated\n+  Win32AttachOperationRequest() {\n+    set(ATTACH_API_V1, \"<nopipe>\");\n+    set_next(nullptr);\n+  }\n+};\n@@ -72,1 +225,1 @@\n-  static Win32AttachOperation* _avail;\n+  static Win32AttachOperationRequest* _avail;\n@@ -75,2 +228,2 @@\n-  static Win32AttachOperation* _head;\n-  static Win32AttachOperation* _tail;\n+  static Win32AttachOperationRequest* _head;\n+  static Win32AttachOperationRequest* _tail;\n@@ -79,2 +232,2 @@\n-  static Win32AttachOperation* head()                       { return _head; }\n-  static void set_head(Win32AttachOperation* head)          { _head = head; }\n+  static Win32AttachOperationRequest* head()                       { return _head; }\n+  static void set_head(Win32AttachOperationRequest* head)          { _head = head; }\n@@ -82,2 +235,2 @@\n-  static Win32AttachOperation* tail()                       { return _tail; }\n-  static void set_tail(Win32AttachOperation* tail)          { _tail = tail; }\n+  static Win32AttachOperationRequest* tail()                       { return _tail; }\n+  static void set_tail(Win32AttachOperationRequest* tail)          { _tail = tail; }\n@@ -104,2 +257,2 @@\n-  static Win32AttachOperation* available()                  { return _avail; }\n-  static void set_available(Win32AttachOperation* avail)    { _avail = avail; }\n+  static Win32AttachOperationRequest* available()                  { return _avail; }\n+  static void set_available(Win32AttachOperationRequest* avail)    { _avail = avail; }\n@@ -108,1 +261,2 @@\n-  static int enqueue(char* cmd, char* arg1, char* arg2, char* arg3, char* pipename);\n+  static int enqueue(AttachAPIVersion ver, const char* cmd,\n+      const char* arg1, const char* arg2, const char* arg3, const char* pipename);\n@@ -117,42 +271,3 @@\n-Win32AttachOperation* Win32AttachListener::_avail;\n-Win32AttachOperation* Win32AttachListener::_head;\n-Win32AttachOperation* Win32AttachListener::_tail;\n-\n-\n-\/\/ Win32AttachOperation is an AttachOperation that additionally encapsulates the name\n-\/\/ of a pipe which is used to send the operation reply\/output to the client.\n-\/\/ Win32AttachOperation can also be linked in a list.\n-\n-class Win32AttachOperation: public AttachOperation {\n- private:\n-  friend class Win32AttachListener;\n-\n-  enum {\n-    pipe_name_max = 256             \/\/ maximum pipe name\n-  };\n-\n-  char _pipe[pipe_name_max + 1];\n-\n-  const char* pipe() const                              { return _pipe; }\n-  void set_pipe(const char* pipe) {\n-    assert(strlen(pipe) <= pipe_name_max, \"exceeds maximum length of pipe name\");\n-    os::snprintf(_pipe, sizeof(_pipe), \"%s\", pipe);\n-  }\n-\n-  HANDLE open_pipe();\n-  static BOOL write_pipe(HANDLE hPipe, char* buf, int len);\n-\n-  Win32AttachOperation* _next;\n-\n-  Win32AttachOperation* next() const                    { return _next; }\n-  void set_next(Win32AttachOperation* next)             { _next = next; }\n-\n-  \/\/ noarg constructor as operation is preallocated\n-  Win32AttachOperation() : AttachOperation(\"<noname>\") {\n-    set_pipe(\"<nopipe>\");\n-    set_next(nullptr);\n-  }\n-\n- public:\n-  void complete(jint result, bufferedStream* result_stream);\n-};\n+Win32AttachOperationRequest* Win32AttachListener::_avail;\n+Win32AttachOperationRequest* Win32AttachListener::_head;\n+Win32AttachOperationRequest* Win32AttachListener::_tail;\n@@ -174,1 +289,1 @@\n-    Win32AttachOperation* op = new Win32AttachOperation();\n+    Win32AttachOperationRequest* op = new Win32AttachOperationRequest();\n@@ -179,0 +294,2 @@\n+  AttachListener::set_supported_version(ATTACH_API_V2);\n+\n@@ -185,1 +302,5 @@\n-int Win32AttachListener::enqueue(char* cmd, char* arg0, char* arg1, char* arg2, char* pipename) {\n+int Win32AttachListener::enqueue(AttachAPIVersion ver, const char* cmd,\n+    const char* arg0, const char* arg1, const char* arg2, const char* pipename) {\n+\n+  log_debug(attach)(\"AttachListener::enqueue, ver = %d, cmd = %s\", (int)ver, cmd);\n+\n@@ -213,1 +334,1 @@\n-  Win32AttachOperation* op = available();\n+  Win32AttachOperationRequest* op = available();\n@@ -226,5 +347,1 @@\n-    op->set_name(cmd);\n-    op->set_arg(0, arg0);\n-    op->set_arg(1, arg1);\n-    op->set_arg(2, arg2);\n-    op->set_pipe(pipename);\n+    op->set(ver, pipename, cmd, arg0, arg1, arg2);\n@@ -239,0 +356,1 @@\n+\n@@ -258,0 +376,4 @@\n+    Win32AttachOperation* op = nullptr;\n+    Win32AttachOperationRequest* request = head();\n+    if (request != nullptr) {\n+      log_debug(attach)(\"AttachListener::dequeue, got request, ver = %d, cmd = %s\", request->ver(), request->cmd());\n@@ -259,3 +381,1 @@\n-    Win32AttachOperation* op = head();\n-    if (op != nullptr) {\n-      set_head(op->next());\n+      set_head(request->next());\n@@ -265,0 +385,23 @@\n+\n+      switch (request->ver()) {\n+      case ATTACH_API_V1:\n+        op = new Win32AttachOperation();\n+        op->set_name(request->cmd());\n+        for (int i = 0; i < AttachOperation::arg_count_max; i++) {\n+          op->append_arg(request->arg(i));\n+        }\n+        op->open_pipe(request->pipe(), true\/*write-only*\/);\n+        break;\n+      case ATTACH_API_V2:\n+        op = new Win32AttachOperation();\n+        op->open_pipe(request->pipe(), false\/*write-only*\/);\n+        if (!op->read_request()) {\n+          log_error(attach)(\"AttachListener::dequeue, reading request ERROR\");\n+          delete op;\n+          op = nullptr;\n+        }\n+        break;\n+      default:\n+        log_error(attach)(\"AttachListener::dequeue, unsupported version: %d\", request->ver(), request->cmd());\n+        break;\n+      }\n@@ -266,0 +409,4 @@\n+    \/\/ put the operation back on the available list\n+    request->set_next(Win32AttachListener::available());\n+    Win32AttachListener::set_available(request);\n+\n@@ -269,0 +416,1 @@\n+      log_debug(attach)(\"AttachListener::dequeue, return op: %s\", op->name());\n@@ -274,37 +422,0 @@\n-\n-\/\/ open the pipe to the client\n-HANDLE Win32AttachOperation::open_pipe() {\n-  HANDLE hPipe = ::CreateFile( pipe(),  \/\/ pipe name\n-                        GENERIC_WRITE,   \/\/ write only\n-                        0,              \/\/ no sharing\n-                        nullptr,           \/\/ default security attributes\n-                        OPEN_EXISTING,  \/\/ opens existing pipe\n-                        0,              \/\/ default attributes\n-                        nullptr);          \/\/ no template file\n-  return hPipe;\n-}\n-\n-\/\/ write to the pipe\n-BOOL Win32AttachOperation::write_pipe(HANDLE hPipe, char* buf, int len) {\n-  do {\n-    DWORD nwrote;\n-\n-    BOOL fSuccess = WriteFile(  hPipe,                  \/\/ pipe handle\n-                                (LPCVOID)buf,           \/\/ message\n-                                (DWORD)len,             \/\/ message length\n-                                &nwrote,                \/\/ bytes written\n-                                nullptr);                  \/\/ not overlapped\n-    if (!fSuccess) {\n-      return fSuccess;\n-    }\n-    buf += nwrote;\n-    len -= nwrote;\n-  } while (len > 0);\n-  return TRUE;\n-}\n-\n-\/\/ Complete the operation:\n-\/\/   - open the pipe to the client\n-\/\/   - write the operation result (a jint)\n-\/\/   - write the operation output (the result stream)\n-\/\/\n@@ -315,18 +426,1 @@\n-  HANDLE hPipe = open_pipe();\n-  int lastError = (int)::GetLastError();\n-  if (hPipe != INVALID_HANDLE_VALUE) {\n-    BOOL fSuccess;\n-\n-    char msg[32];\n-    os::snprintf(msg, sizeof(msg), \"%d\\n\", result);\n-    msg[sizeof(msg) - 1] = '\\0';\n-\n-    fSuccess = write_pipe(hPipe, msg, (int)strlen(msg));\n-    if (fSuccess) {\n-      fSuccess = write_pipe(hPipe, (char*)result_stream->base(), (int)(result_stream->size()));\n-    }\n-    lastError = (int)::GetLastError();\n-\n-    \/\/ Need to flush buffers\n-    FlushFileBuffers(hPipe);\n-    CloseHandle(hPipe);\n+  write_reply(&_pipe, result, result_stream);\n@@ -334,21 +428,1 @@\n-    if (fSuccess) {\n-      log_debug(attach)(\"wrote result of attach operation %s to pipe %s\", name(), pipe());\n-    } else {\n-      log_error(attach)(\"failure (%d) writing result of operation %s to pipe %s\", lastError, name(), pipe());\n-    }\n-  } else {\n-    log_error(attach)(\"could not open (%d) pipe %s to send result of operation %s\", lastError, pipe(), name());\n-  }\n-\n-  DWORD res = ::WaitForSingleObject(Win32AttachListener::mutex(), INFINITE);\n-  assert(res != WAIT_FAILED,   \"WaitForSingleObject failed with error code: %lu\", GetLastError());\n-  assert(res == WAIT_OBJECT_0, \"WaitForSingleObject failed with return value: %lu\", res);\n-\n-  if (res == WAIT_OBJECT_0) {\n-\n-    \/\/ put the operation back on the available list\n-    set_next(Win32AttachListener::available());\n-    Win32AttachListener::set_available(this);\n-\n-    ::ReleaseMutex(Win32AttachListener::mutex());\n-  }\n+  delete this;\n@@ -358,1 +432,1 @@\n-\/\/ AttachOperation functions\n+\/\/ AttachListener functions\n@@ -407,3 +481,3 @@\n-    JVM_EnqueueOperation(char* cmd, char* arg0, char* arg1, char* arg2, char* pipename) {\n-      return (jint)Win32AttachListener::enqueue(cmd, arg0, arg1, arg2, pipename);\n-    }\n+  JVM_EnqueueOperation(char* cmd, char* arg0, char* arg1, char* arg2, char* pipename) {\n+    return (jint)Win32AttachListener::enqueue(ATTACH_API_V1, cmd, arg0, arg1, arg2, pipename);\n+  }\n@@ -411,0 +485,4 @@\n+  JNIEXPORT jint JNICALL\n+  JVM_EnqueueOperation_v2(char* pipename) {\n+    return (jint)Win32AttachListener::enqueue(ATTACH_API_V2, \"\", \"\", \"\", \"\", pipename);\n+  }\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":229,"deletions":151,"binary":false,"changes":380,"status":"modified"},{"patch":"@@ -53,0 +53,32 @@\n+AttachAPIVersion AttachListener::_supported_version = ATTACH_API_V1;\n+\n+static bool get_bool_sys_prop(const char* name, bool default_value, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+\n+  \/\/ setup the arguments to getProperty\n+  Handle key_str = java_lang_String::create_from_str(name, CHECK_(default_value));\n+  \/\/ return value\n+  JavaValue result(T_OBJECT);\n+  \/\/ public static String getProperty(String key, String def);\n+  JavaCalls::call_static(&result,\n+                         vmClasses::System_klass(),\n+                         vmSymbols::getProperty_name(),\n+                         vmSymbols::string_string_signature(),\n+                         key_str,\n+                         CHECK_(default_value));\n+  oop value_oop = result.get_oop();\n+  if (value_oop != nullptr) {\n+    \/\/ convert Java String to utf8 string\n+    char* value = java_lang_String::as_utf8_string(value_oop);\n+    if (strcasecmp(value, \"true\") == 0) {\n+        return true;\n+    }\n+    if (strcasecmp(value, \"false\") == 0) {\n+        return false;\n+    }\n+  }\n+  return default_value;\n+}\n+\n+\n@@ -354,0 +386,6 @@\n+\/\/ Implementation of \"getversion\" command\n+static jint get_version(AttachOperation* op, outputStream* out) {\n+  out->print(\"%d\", (int)AttachListener::get_supported_version());\n+  return JNI_OK;\n+}\n+\n@@ -368,0 +406,1 @@\n+  { \"getversion\",       get_version },\n@@ -475,0 +514,172 @@\n+\n+void AttachListener::set_supported_version(AttachAPIVersion version) {\n+\/\/  _supported_version = version;\n+  const char* prop_name = \"jdk.attach.compat\";\n+  if (!get_bool_sys_prop(prop_name, false, JavaThread::current())) {\n+    _supported_version = version;\n+  }\n+}\n+\n+AttachAPIVersion AttachListener::get_supported_version() {\n+  return _supported_version;\n+}\n+\n+\n+int AttachOperation::RequestReader::read_uint() {\n+  const int MAX_VALUE = INT_MAX \/ 20;\n+  char ch;\n+  int value = 0;\n+  while (true) {\n+    int n = read(&ch, 1);\n+    if (n != 1) {\n+      \/\/ IO errors (n < 0) are logged by read().\n+      if (n == 0) { \/\/ EOF\n+        log_error(attach)(\"Failed to read int value: EOF\");\n+      }\n+      return -1;\n+    }\n+    if (ch == '\\0') {\n+      return value;\n+    }\n+    if (ch < '0' || ch > '9') {\n+      log_error(attach)(\"Failed to read int value: unexpected symbol: %c\", ch);\n+      return -1;\n+    }\n+    \/\/ Ensure there is no integer overflow.\n+    if (value >= MAX_VALUE) {\n+      log_error(attach)(\"Failed to read int value: too big\");\n+      return -1;\n+    }\n+    value = value * 10 + (ch - '0');\n+  }\n+}\n+\n+\/\/ Reads operation name and arguments.\n+\/\/ buffer_size: maximum data size;\n+\/\/ min_str_count: minimum number of strings in the request (name + arguments);\n+\/\/ min_read_size: minimum data size.\n+bool AttachOperation::read_request_data(AttachOperation::RequestReader* reader,\n+                                        int buffer_size, int min_str_count, int min_read_size) {\n+  char* buffer = (char*)os::malloc(buffer_size, mtServiceability);\n+  int str_count = 0;\n+  int off = 0;\n+  int left = buffer_size;\n+\n+  \/\/ Read until all (expected) strings or expected bytes have been read, the buffer is full, or EOF.\n+  do {\n+    int n = reader->read(buffer + off, left);\n+    if (n < 0) {\n+      os::free(buffer);\n+      return false;\n+    }\n+    if (n == 0) { \/\/ EOF\n+      break;\n+    }\n+    if (min_str_count > 0) { \/\/ need to count arguments\n+      for (int i = 0; i < n; i++) {\n+        if (buffer[off + i] == '\\0') {\n+          str_count++;\n+        }\n+      }\n+    }\n+    off += n;\n+    left -= n;\n+  } while (left > 0 && (off < min_read_size || str_count < min_str_count));\n+\n+  if (off < min_read_size || str_count < min_str_count) { \/\/ unexpected EOF\n+    log_error(attach)(\"Failed to read request: incomplete request\");\n+    os::free(buffer);\n+    return false;\n+  }\n+  \/\/ Request must ends with '\\0'.\n+  if (buffer[off - 1] != '\\0') {\n+    log_error(attach)(\"Failed to read request: not terminated\");\n+    os::free(buffer);\n+    return false;\n+  }\n+\n+  \/\/ Parse request.\n+  \/\/ Command name is the 1st string.\n+  set_name(buffer);\n+  log_debug(attach)(\"read request: cmd = %s\", buffer);\n+\n+  \/\/ Arguments.\n+  char* end = buffer + off;\n+  for (char* cur = strchr(buffer, '\\0') + 1; cur < end; cur = strchr(cur, '\\0') + 1) {\n+    log_debug(attach)(\"read request: arg = %s\", cur);\n+    append_arg(cur);\n+  }\n+\n+  os::free(buffer);\n+\n+  return true;\n+}\n+\n+bool AttachOperation::read_request(RequestReader* reader) {\n+  uint ver = reader->read_uint();\n+  int buffer_size = 0;\n+  \/\/ Read conditions:\n+  int min_str_count = 0; \/\/ expected number of strings in the request\n+  int min_read_size = 1; \/\/ expected size of the request data (by default 1 symbol for terminating '\\0')\n+  switch (ver) {\n+  case ATTACH_API_V1: \/\/ <ver>0<cmd>0<arg>0<arg>0<arg>0\n+    \/\/ Always contain a command (up to name_length_max chars)\n+    \/\/ and arg_count_max(3) arguments (each up to arg_length_max chars).\n+    buffer_size = (name_length_max + 1) + arg_count_max * (arg_length_max + 1);\n+    min_str_count = 1 \/*name*\/ + arg_count_max;\n+    break;\n+  case ATTACH_API_V2: \/\/ <ver>0<size>0<cmd>0<arg>0<arg>0<arg>0\n+    if (AttachListener::get_supported_version() < 2) {\n+        log_error(attach)(\"Failed to read request: v2 is unsupported ot disabled\");\n+        return false;\n+    }\n+\n+    \/\/ read size of the data\n+    buffer_size = reader->read_uint();\n+    if (buffer_size < 0) {\n+      return false;\n+    }\n+    log_debug(attach)(\"v2 request, data size = %d\", buffer_size);\n+\n+    \/\/ Sanity check: max request size is 256K.\n+    if (buffer_size > 256 * 1024) {\n+      log_error(attach)(\"Failed to read request: too big\");\n+      return false;\n+    }\n+    \/\/ Must contain exact 'buffer_size' bytes.\n+    min_read_size = buffer_size;\n+    break;\n+  default:\n+    log_error(attach)(\"Failed to read request: unknown version (%d)\", ver);\n+    return false;\n+  }\n+\n+  return read_request_data(reader, buffer_size, min_str_count, min_read_size);\n+}\n+\n+bool AttachOperation::ReplyWriter::write_fully(const void* buffer, int size) {\n+  const char* buf = (const char*)buffer;\n+  do {\n+    int n = write(buf, size);\n+    if (n < 0) {\n+      return false;\n+    }\n+    buf += n;\n+    size -= n;\n+  } while (size > 0);\n+  return true;\n+}\n+\n+bool AttachOperation::write_reply(ReplyWriter* writer, jint result, bufferedStream* result_stream) {\n+  char msg[32];\n+  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n+  if (!writer->write_fully(msg, (int)strlen(msg))) {\n+    return false;\n+  }\n+  if (!writer->write_fully(result_stream->base(), (int)result_stream->size())) {\n+    return false;\n+  }\n+  writer->flush();\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":211,"deletions":0,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -62,0 +63,14 @@\n+\/*\n+Version 1 (since jdk6): attach operations always have 3 (AttachOperation::arg_count_max)\n+  arguments, each up to 1024 (AttachOperation::arg_length_max) chars.\n+Version 2 (since jdk24): attach operations may have any number of arguments of any length;\n+  for safety default implementation restricts attach operation request size by 256KB.\n+  To detect if target VM supports version 2, client sends \"getversion\" command.\n+  Old VM reports \"Operation not recognized\" error, newer VM reports version supported by the implementation.\n+  If the target VM does not support version 2, client uses version 1 to enqueue operations.\n+*\/\n+enum AttachAPIVersion: int {\n+    ATTACH_API_V1 = 1,\n+    ATTACH_API_V2 = 2\n+};\n+\n@@ -96,0 +111,2 @@\n+  static AttachAPIVersion _supported_version;\n+\n@@ -97,0 +114,3 @@\n+  static void set_supported_version(AttachAPIVersion version);\n+  static AttachAPIVersion get_supported_version();\n+\n@@ -139,2 +159,3 @@\n-class AttachOperation: public CHeapObj<mtInternal> {\n- public:\n+class AttachOperation: public CHeapObj<mtServiceability> {\n+public:\n+  \/\/ v1 constants\n@@ -151,3 +172,3 @@\n- private:\n-  char _name[name_length_max+1];\n-  char _arg[arg_count_max][arg_length_max+1];\n+private:\n+  char* _name;\n+  GrowableArrayCHeap<char*, mtServiceability> _args;\n@@ -155,2 +176,6 @@\n- public:\n-  const char* name() const                      { return _name; }\n+  static char* copy_str(const char* value) {\n+    return value == nullptr ? nullptr : os::strdup(value, mtServiceability);\n+  }\n+\n+public:\n+  const char* name() const { return _name; }\n@@ -160,4 +185,6 @@\n-    assert(strlen(name) <= name_length_max, \"exceeds maximum name length\");\n-    size_t len = MIN2(strlen(name), (size_t)name_length_max);\n-    memcpy(_name, name, len);\n-    _name[len] = '\\0';\n+    os::free(_name);\n+    _name = copy_str(name);\n+  }\n+\n+  int arg_count() const {\n+    return _args.length();\n@@ -168,2 +195,11 @@\n-    assert(i>=0 && i<arg_count_max, \"invalid argument index\");\n-    return _arg[i];\n+    \/\/ Historically clients expect empty string for absent or null arguments.\n+    if (i >= _args.length() || _args.at(i) == nullptr) {\n+      static char empty_str[] = \"\";\n+      return empty_str;\n+    }\n+    return _args.at(i);\n+  }\n+\n+  \/\/ appends an argument\n+  void append_arg(const char* arg) {\n+    _args.append(copy_str(arg));\n@@ -173,10 +209,2 @@\n-  void set_arg(int i, char* arg) {\n-    assert(i>=0 && i<arg_count_max, \"invalid argument index\");\n-    if (arg == nullptr) {\n-      _arg[i][0] = '\\0';\n-    } else {\n-      assert(strlen(arg) <= arg_length_max, \"exceeds maximum argument length\");\n-      size_t len = MIN2(strlen(arg), (size_t)arg_length_max);\n-      memcpy(_arg[i], arg, len);\n-      _arg[i][len] = '\\0';\n-    }\n+  void set_arg(int i, const char* arg) {\n+    _args.at_put_grow(i, copy_str(arg), nullptr);\n@@ -185,2 +213,2 @@\n-  \/\/ create an operation of a given name\n-  AttachOperation(const char* name) {\n+  \/\/ create an v1 operation of a given name (for compatibility, deprecated)\n+  AttachOperation(const char* name) : _name(nullptr) {\n@@ -188,1 +216,1 @@\n-    for (int i=0; i<arg_count_max; i++) {\n+    for (int i = 0; i < arg_count_max; i++) {\n@@ -193,0 +221,10 @@\n+  AttachOperation() : _name(nullptr) {\n+  }\n+\n+  virtual ~AttachOperation() {\n+    os::free(_name);\n+    for (GrowableArrayIterator<char*> it = _args.begin(); it != _args.end(); ++it) {\n+      os::free(*it);\n+    }\n+  }\n+\n@@ -195,0 +233,31 @@\n+\n+  \/\/ Helper classes\/methods for platform-specific implementations.\n+  class RequestReader {\n+  public:\n+    \/\/ Returns number of bytes read,\n+    \/\/ 0 on EOF, negative value on error.\n+    virtual int read(void* buffer, int size) = 0;\n+\n+    \/\/ Reads unsigned value, returns -1 on error.\n+    int read_uint();\n+  };\n+\n+  \/\/ Reads standard operation request (v1 or v2).\n+  bool read_request(RequestReader* reader);\n+\n+  class ReplyWriter {\n+  public:\n+    \/\/ Returns number of bytes written, negative value on error.\n+    virtual int write(const void* buffer, int size) = 0;\n+\n+    virtual void flush() {}\n+\n+    bool write_fully(const void* buffer, int size);\n+  };\n+\n+  \/\/ Writes standard operation reply (to be called from 'complete' method).\n+  bool write_reply(ReplyWriter* writer, jint result, bufferedStream* result_stream);\n+\n+private:\n+  bool read_request_data(AttachOperation::RequestReader* reader, int buffer_size, int min_str_count, int min_read_size);\n+\n@@ -196,0 +265,1 @@\n+\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":97,"deletions":27,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import java.nio.charset.StandardCharsets;\n+\n@@ -105,1 +107,1 @@\n-            String result = readErrorMessage(in);\n+            String result = readMessage(in);\n@@ -330,0 +332,39 @@\n+    \/\/ Attach API version support\n+    protected static final int VERSION_1 = 1;\n+    protected static final int VERSION_2 = 2;\n+\n+    \/*\n+     * Detects Attach API version supported by target VM.\n+     *\/\n+    protected int detectVersion() throws IOException {\n+        try {\n+            InputStream reply = execute(\"getversion\");\n+            String message = readMessage(reply);\n+            reply.close();\n+            try {\n+                int supportedVersion = Integer.parseUnsignedInt(message);\n+                \/\/ we expect only VERSION_2\n+                if (supportedVersion == VERSION_2) {\n+                    return VERSION_2;\n+                }\n+            } catch (NumberFormatException nfe) {\n+                \/\/ bad reply - fallback to VERSION_1\n+            }\n+        } catch (AttachOperationFailedException | AgentLoadException ex) {\n+            \/\/ the command is not supported, the VM supports VERSION_1 only\n+        }\n+        return VERSION_1;\n+    }\n+\n+    \/*\n+     * For testing purposes Attach API v2 may be disabled.\n+     *\/\n+    protected boolean isAPIv2Enabled() {\n+        \/\/ if \"jdk.attach.compat\" property is set, only v1 is enabled.\n+        try {\n+            String value = System.getProperty(\"jdk.attach.compat\");\n+            return !(\"true\".equalsIgnoreCase(value));\n+        } catch (SecurityException se) {\n+        }\n+        return true;\n+    }\n@@ -370,1 +411,1 @@\n-    String readErrorMessage(InputStream in) throws IOException {\n+    String readMessage(InputStream in) throws IOException {\n@@ -403,1 +444,1 @@\n-            String message = readErrorMessage(sis);\n+            String message = readMessage(sis);\n@@ -420,0 +461,45 @@\n+    \/*\n+     * Helper writer interface to send commands to the target VM.\n+     *\/\n+    public static interface AttachOutputStream {\n+        abstract void write(byte[] buffer, int offset, int length) throws IOException;\n+    }\n+\n+    private int dataSize(Object obj) {\n+        return (obj == null ? 0 : obj.toString().getBytes(StandardCharsets.UTF_8).length) + 1;\n+    }\n+\n+    \/*\n+     * Writes object (usually String or Integer) to the attach writer.\n+     *\/\n+    private void writeString(AttachOutputStream writer, Object obj) throws IOException {\n+        if (obj != null) {\n+            String s = obj.toString();\n+            if (s.length() > 0) {\n+                byte[] b = s.getBytes(StandardCharsets.UTF_8);\n+                writer.write(b, 0, b.length);\n+            }\n+        }\n+        byte b[] = new byte[1];\n+        b[0] = 0;\n+        writer.write(b, 0, 1);\n+    }\n+\n+    protected void writeCommand(AttachOutputStream writer, int ver, String cmd, Object ... args) throws IOException {\n+        writeString(writer, ver);\n+        if (ver == VERSION_2) {\n+            \/\/ for v2 write size of the data\n+            int size = dataSize(cmd);\n+            for (Object arg: args) {\n+                size += dataSize(arg);\n+            }\n+            writeString(writer, size);\n+        }\n+        writeString(writer, cmd);\n+        \/\/ v1 commands always write 3 arguments\n+        int argNumber = ver == VERSION_1 ? 3 : args.length;\n+        for (int i = 0; i < argNumber; i++) {\n+            writeString(writer, i < args.length ? args[i] : null);\n+        }\n+    }\n+\n","filename":"src\/jdk.attach\/share\/classes\/sun\/tools\/attach\/HotSpotVirtualMachine.java","additions":89,"deletions":3,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.attach.AttachOperationFailedException;\n@@ -45,0 +46,1 @@\n+    private int ver = VERSION_1;        \/\/ updated in ctor depending on detectVersion result\n@@ -54,3 +56,0 @@\n-        \/\/ The target VM might be a pre-6.0 VM so we enqueue a \"null\" command\n-        \/\/ which minimally tests that the enqueue function exists in the target\n-        \/\/ VM.\n@@ -58,1 +57,8 @@\n-            enqueue(hProcess, stub, null, null);\n+            if (isAPIv2Enabled()) {\n+                ver = detectVersion();\n+            } else {\n+                \/\/ The target VM might be a pre-6.0 VM so we enqueue a \"null\" command\n+                \/\/ which minimally tests that the enqueue function exists in the target\n+                \/\/ VM.\n+                enqueue(hProcess, stub, VERSION_1, null, null);\n+            }\n@@ -76,1 +82,0 @@\n-        assert args.length <= 3;        \/\/ includes null\n@@ -86,1 +91,1 @@\n-            hPipe = createPipe(pipename);\n+            hPipe = createPipe(ver, pipename);\n@@ -91,1 +96,1 @@\n-            hPipe = createPipe(pipename);\n+            hPipe = createPipe(ver, pipename);\n@@ -102,2 +107,7 @@\n-            \/\/ enqueue the command to the process\n-            enqueue(hProcess, stub, cmd, pipename, args);\n+            \/\/ enqueue the command to the process.\n+            if (ver == VERSION_1) {\n+                enqueue(hProcess, stub, ver, cmd, pipename, args);\n+            } else {\n+                \/\/ for v2 operations request contains only pipe name.\n+                enqueue(hProcess, stub, ver, null, pipename);\n+            }\n@@ -105,2 +115,1 @@\n-            \/\/ wait for command to complete - process will connect with the\n-            \/\/ completion status\n+            \/\/ wait for the target VM to connect to the pipe.\n@@ -109,0 +118,12 @@\n+            IOException ioe = null;\n+\n+            if (ver == VERSION_2) {\n+                PipeOutputStream writer = new PipeOutputStream(hPipe);\n+\n+                try {\n+                    writeCommand(writer, ver, cmd, args);\n+                } catch (IOException x) {\n+                    ioe = x;\n+                }\n+            }\n+\n@@ -113,1 +134,1 @@\n-            processCompletionStatus(null, cmd, in);\n+            processCompletionStatus(ioe, cmd, in);\n@@ -124,0 +145,11 @@\n+    private static class PipeOutputStream implements AttachOutputStream {\n+        private long hPipe;\n+        public PipeOutputStream(long hPipe) {\n+            this.hPipe = hPipe;\n+        }\n+        @Override\n+        public void write(byte[] buffer, int offset, int length) throws IOException {\n+            VirtualMachineImpl.writePipe(hPipe, buffer, offset, length);\n+        }\n+    }\n+\n@@ -152,1 +184,1 @@\n-    static native long createPipe(String name) throws IOException;\n+    static native long createPipe(int ver, String name) throws IOException;\n@@ -160,1 +192,3 @@\n-    static native void enqueue(long hProcess, byte[] stub,\n+    static native void writePipe(long hPipe, byte buf[], int off, int buflen) throws IOException;\n+\n+    static native void enqueue(long hProcess, byte[] stub, int ver,\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":48,"deletions":14,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-\/* exported function in target VM *\/\n+\/* exported functions in target VM *\/\n@@ -52,0 +52,2 @@\n+typedef jint (WINAPI* EnqueueOperationFunc_v2)\n+    (const char* pipename);\n@@ -73,0 +75,1 @@\n+   jint version;\n@@ -78,0 +81,1 @@\n+   char func_v2[MAX_FUNC_LENGTH];\n@@ -105,1 +109,0 @@\n-    EnqueueOperationFunc addr;\n@@ -112,5 +115,21 @@\n-    addr = (EnqueueOperationFunc)(pData->_GetProcAddress(h, pData->func1));\n-    if (addr == NULL) {\n-        addr = (EnqueueOperationFunc)(pData->_GetProcAddress(h, pData->func2));\n-    }\n-    if (addr == NULL) {\n+    if (pData->version == 1) {\n+        EnqueueOperationFunc addr = (EnqueueOperationFunc)(pData->_GetProcAddress(h, pData->func1));\n+        if (addr == NULL) {\n+            addr = (EnqueueOperationFunc)(pData->_GetProcAddress(h, pData->func2));\n+        }\n+        if (addr == NULL) {\n+            return ERR_GET_ENQUEUE_FUNC_FAIL;\n+        }\n+        \/* \"null\" command - does nothing in the target VM *\/\n+        if (pData->cmd[0] == '\\0') {\n+            return 0;\n+        } else {\n+            return (*addr)(pData->cmd, pData->arg[0], pData->arg[1], pData->arg[2], pData->pipename);\n+        }\n+    } else if (pData->version == 2) {\n+        EnqueueOperationFunc_v2 addr = (EnqueueOperationFunc_v2)(pData->_GetProcAddress(h, pData->func_v2));\n+        if (addr == NULL) {\n+            return ERR_GET_ENQUEUE_FUNC_FAIL;\n+        }\n+        return (*addr)(pData->pipename);\n+    } else {\n@@ -120,6 +139,0 @@\n-    \/* \"null\" command - does nothing in the target VM *\/\n-    if (pData->cmd[0] == '\\0') {\n-        return 0;\n-    } else {\n-        return (*addr)(pData->cmd, pData->arg[0], pData->arg[1], pData->arg[2], pData->pipename);\n-    }\n@@ -264,1 +277,1 @@\n-  (JNIEnv *env, jclass cls, jstring pipename)\n+  (JNIEnv *env, jclass cls, jint ver, jstring pipename)\n@@ -292,1 +305,2 @@\n-          PIPE_ACCESS_INBOUND,          \/\/ read access\n+          ver == 1 ? PIPE_ACCESS_INBOUND  \/\/ read access\n+                   : PIPE_ACCESS_DUPLEX,  \/\/ read-write access\n@@ -380,0 +394,32 @@\n+\/*\n+ * Class:     sun_tools_attach_VirtualMachineImpl\n+ * Method:    writePipe\n+ * Signature: (J[BII)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_tools_attach_VirtualMachineImpl_writePipe\n+  (JNIEnv *env, jclass cls, jlong hPipe, jbyteArray buffer, jint offset, jint length)\n+{\n+    jsize remaining = length;\n+    do {\n+        jbyte buf[128];\n+        jsize len = sizeof(buf);\n+        DWORD written;\n+\n+        if (len > remaining) {\n+            len = remaining;\n+        }\n+        (*env)->GetByteArrayRegion(env, buffer, offset, len, buf);\n+\n+        BOOL fSuccess = WriteFile((HANDLE)hPipe, buf, len, &written, NULL);\n+\n+        if (!fSuccess) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"WriteFile\");\n+            return;\n+        }\n+\n+        offset += written;\n+        remaining -= written;\n+\n+    } while (remaining > 0);\n+}\n+\n@@ -386,2 +432,2 @@\n-  (JNIEnv *env, jclass cls, jlong handle, jbyteArray stub, jstring cmd,\n-   jstring pipename, jobjectArray args)\n+  (JNIEnv *env, jclass cls, jlong handle, jbyteArray stub, jint ver,\n+   jstring cmd, jstring pipename, jobjectArray args)\n@@ -402,0 +448,2 @@\n+    data.version = ver;\n+\n@@ -408,0 +456,1 @@\n+    strcpy(data.func_v2, \"JVM_EnqueueOperation_v2\");\n","filename":"src\/jdk.attach\/windows\/native\/libattach\/VirtualMachineImpl.c","additions":66,"deletions":17,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic compatibility test for Attach API v2\n+ * @bug 8219896\n+ * @library \/test\/lib\n+ * @modules jdk.attach\/sun.tools.attach\n+ *\n+ * @run main\/othervm -Xlog:attach=trace CompatTest\n+ * @run main\/othervm -Xlog:attach=trace -Djdk.attach.compat=true CompatTest\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import sun.tools.attach.HotSpotVirtualMachine;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class CompatTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ if the test (client part) in the \"compat\" mode\n+        boolean clientCompat = \"true\".equals(System.getProperty(\"jdk.attach.compat\"));\n+        System.out.println(\"Client is in compat mode: \" + clientCompat);\n+        LingeredApp app = null;\n+        try {\n+            app = LingeredApp.startApp(\"-Xlog:attach=trace\");\n+            test(app, clientCompat);\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+\n+        try {\n+            app = LingeredApp.startApp(\"-Xlog:attach=trace\", \"-Djdk.attach.compat=true\");\n+            \/\/ target VM in \"compat\" mode, always expect failure\n+            test(app, true);\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+\n+    }\n+\n+    \/\/ The test uses HotSpotVirtualMachine.setFlag method with long flag value.\n+    \/\/ For attach API v1 an exception is expected to be thrown (argument cannot be longer than 1024 characters).\n+    private static String flagName = \"HeapDumpPath\";\n+    \/\/ long for v1\n+    private static String flagValue = \"X\" + \"A\".repeat(1024) + \"X\";\n+\n+    private static void test(LingeredApp app, boolean expectFailure) throws Exception {\n+        System.out.println(\"======== Start ========\");\n+\n+        HotSpotVirtualMachine vm = (HotSpotVirtualMachine)VirtualMachine.attach(String.valueOf(app.getPid()));\n+\n+        BufferedReader replyReader = null;\n+        try {\n+            replyReader = new BufferedReader(new InputStreamReader(\n+                vm.setFlag(flagName, flagValue)));\n+\n+            if (expectFailure) {\n+                throw new RuntimeException(\"No expected exception is thrown\");\n+            }\n+\n+            String line;\n+            while ((line = replyReader.readLine()) != null) {\n+                System.out.println(\"setFlag reply: \" + line);\n+            }\n+            replyReader.close();\n+\n+        } catch (IOException ex) {\n+            System.out.println(\"OK: setFlag thrown expected exception:\");\n+            ex.printStackTrace(System.out);\n+        } finally {\n+            vm.detach();\n+        }\n+\n+        System.out.println(\"======== End ========\");\n+        System.out.println();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/AttachAPIv2\/CompatTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}