{"files":[{"patch":"@@ -26,0 +26,1 @@\n+ * @modules java.base\/java.util.concurrent:open\n@@ -30,0 +31,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -31,0 +34,1 @@\n+import java.util.concurrent.LinkedTransferQueue;\n@@ -37,1 +41,2 @@\n-                                     final BlockingQueue<Integer> q)\n+                                     final SynchronousQueue<Integer> q,\n+                                     final VarHandle underlyingHandle)\n@@ -40,0 +45,3 @@\n+        final LinkedTransferQueue<Integer> underlying =\n+            (LinkedTransferQueue<Integer>)underlyingHandle.get(q);\n+\n@@ -56,2 +64,2 @@\n-            \/\/ Probably unnecessary, but should be bullet-proof\n-            while (t.getState() == Thread.State.RUNNABLE)\n+            \/\/ Wait until previous put:ing thread is provably parked\n+            while (underlying.size() < (i + 1))\n@@ -59,0 +67,3 @@\n+\n+            if (underlying.size() > (i + 1))\n+                throw new Error(\"Unexpected number of waiting producers: \" + i);\n@@ -71,3 +82,9 @@\n-        testFairness(false, new SynchronousQueue<Integer>());\n-        testFairness(false, new SynchronousQueue<Integer>(false));\n-        testFairness(true,  new SynchronousQueue<Integer>(true));\n+        var klazz = SynchronousQueue.class;\n+        var underlyingKlazz = Class.forName(klazz.getName() + \"$Transferer\");\n+        var underlying =\n+            MethodHandles.privateLookupIn(klazz, MethodHandles.lookup())\n+                         .findVarHandle(klazz, \"transferer\", underlyingKlazz);\n+\n+        testFairness(false, new SynchronousQueue(),      underlying);\n+        testFairness(false, new SynchronousQueue(false), underlying);\n+        testFairness(true,  new SynchronousQueue(true),  underlying);\n","filename":"test\/jdk\/java\/util\/concurrent\/SynchronousQueue\/Fairness.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"}]}