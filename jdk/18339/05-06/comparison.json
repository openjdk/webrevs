{"files":[{"patch":"@@ -41,3 +41,0 @@\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-import sun.util.locale.provider.ResourceBundleBasedAdapter;\n-\n@@ -57,0 +54,3 @@\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+import sun.util.locale.provider.ResourceBundleBasedAdapter;\n+\n@@ -2655,0 +2655,1 @@\n+        assert !parseStrict : \"Grouping violations should only occur when strict\";\n@@ -2663,1 +2664,3 @@\n-    \/\/ Calculation is determined whether it was an under or over violation\n+    \/\/ Violation can be over or under the grouping size\n+    \/\/ under - Current group has a grouping size of less than the expected\n+    \/\/ over - Current group has a grouping size of more than the expected\n@@ -2665,4 +2668,7 @@\n-        return Math.min(\n-                pos, \/\/ ex: \"1,23,4\" OR \"1,,2\". When under, violating char is grouping\n-                \/\/ ex: \"1,2345,6. When over, violating char is digit\n-                prevGroupingPos + groupingSize + 1);\n+        \/\/ Both examples assume grouping size of 3 and 0 indexed\n+        \/\/ under ex: \"1,23,4\". (4) OR \"1,,2\". (2) When under, violating char is grouping symbol\n+        \/\/ over ex: \"1,2345,6. (5) When over, violating char is the excess digit\n+        \/\/ This method is only evaluated when a grouping symbol is found, thus\n+        \/\/ we can take the minimum of either the current pos, or where we expect\n+        \/\/ the current group to have ended\n+        return Math.min(pos, prevGroupingPos + groupingSize + 1);\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-import sun.util.locale.provider.LocaleServiceProviderPool;\n-\n@@ -59,0 +56,3 @@\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+import sun.util.locale.provider.LocaleServiceProviderPool;\n+\n@@ -493,1 +493,2 @@\n-        throw new UnsupportedOperationException();\n+        throw new UnsupportedOperationException(\"Subclasses should override this \" +\n+                \"method when implementing strict parsing\");\n@@ -512,1 +513,2 @@\n-        throw new UnsupportedOperationException();\n+        throw new UnsupportedOperationException(\"Subclasses should override this \" +\n+                \"method when implementing strict parsing\");\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8177552 8222756\n+ * @bug 8177552 8222756 8327640\n@@ -134,0 +134,12 @@\n+        \/\/ Changing the parseBigDecimal of second object; objects must be equal\n+        cnf2.setParseBigDecimal(true);\n+        checkEquals(cnf1, cnf2, true, \"9th\", \"\");\n+\n+        \/\/ Changing the strict parsing value of first object; objects must not be equal\n+        cnf1.setStrict(true);\n+        checkEquals(cnf1, cnf2, false, \"10th\", \"different strict parsing\");\n+\n+        \/\/ Changing the strict parsing value of second object; objects must be equal\n+        cnf2.setStrict(true);\n+        checkEquals(cnf1, cnf2, true, \"11th\", \"\");\n+\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestEquality.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8177552\n+ * @bug 8177552 8327640\n@@ -74,0 +74,1 @@\n+        FORMAT_FR_FR.setStrict(true);\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/serialization\/TestSerialization.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Check parseStrict correctness for DecimalFormat.equals()\n+ * @run junit EqualityTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.DecimalFormat;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+\n+public class EqualityTest {\n+\n+    private static final DecimalFormat fmt1 = new DecimalFormat();\n+    private static final DecimalFormat fmt2 = new DecimalFormat();\n+\n+    \/\/ Ensure that parseStrict is reflected correctly for DecimalFormat.equals()\n+    @Test\n+    public void checkStrictTest() {\n+        \/\/ parseStrict is false by default\n+        assertEquals(fmt1, fmt2);\n+        fmt1.setStrict(true);\n+        assertNotEquals(fmt1, fmt2);\n+        fmt2.setStrict(true);\n+        assertEquals(fmt1, fmt2);\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/EqualityTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Check parseStrict correctness for DecimalFormat serialization\n+ * @run junit\/othervm SerializationTest\n+ *\/\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class SerializationTest {\n+\n+    private static final NumberFormat FORMAT = NumberFormat.getInstance();\n+\n+    @BeforeAll\n+    public static void mutateFormat() {\n+        FORMAT.setStrict(true);\n+    }\n+\n+    @Test\n+    public void testSerialization() throws IOException, ClassNotFoundException {\n+        \/\/ Serialize\n+        serialize(\"fmt.ser\", FORMAT);\n+        \/\/ Deserialize\n+        deserialize(\"fmt.ser\", FORMAT);\n+    }\n+\n+    private void serialize(String fileName, NumberFormat... formats)\n+            throws IOException {\n+        try (ObjectOutputStream os = new ObjectOutputStream(\n+                new FileOutputStream(fileName))) {\n+            for (NumberFormat fmt : formats) {\n+                os.writeObject(fmt);\n+            }\n+        }\n+    }\n+\n+    private static void deserialize(String fileName, NumberFormat... formats)\n+            throws IOException, ClassNotFoundException {\n+        try (ObjectInputStream os = new ObjectInputStream(\n+                new FileInputStream(fileName))) {\n+            for (NumberFormat fmt : formats) {\n+                NumberFormat obj = (NumberFormat) os.readObject();\n+                assertEquals(fmt, obj, \"Serialized and deserialized\"\n+                        + \" objects do not match\");\n+\n+                String badNumber = \"fooofooo23foo\";\n+                assertThrows(ParseException.class, () -> fmt.parse(badNumber));\n+                assertThrows(ParseException.class, () -> obj.parse(badNumber));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/SerializationTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Unit test for the isStrict() and setStrict() parsing related methods\n+ * @run junit StrictMethodsTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class StrictMethodsTest {\n+\n+    \/\/ Check that DecimalFormat implements isStrict()\/setStrict()\n+    \/\/ Ensure that the default value is false, and can be set to true via API\n+    @Test\n+    public void decimalFormatTest() {\n+        DecimalFormat dFmt = (DecimalFormat) NumberFormat.getInstance();\n+        assertFalse(dFmt.isStrict());\n+        dFmt.setStrict(true);\n+        assertTrue(dFmt.isStrict());\n+    }\n+\n+    \/\/ Check that CompactNumberFormat implements isStrict()\/setStrict()\n+    \/\/ Ensure that the default value is false, and can be set to true via API\n+    @Test\n+    public void compactFormatTest() {\n+        CompactNumberFormat cFmt = (CompactNumberFormat) NumberFormat.getCompactNumberInstance();\n+        assertFalse(cFmt.isStrict());\n+        cFmt.setStrict(true);\n+        assertTrue(cFmt.isStrict());\n+    }\n+\n+    \/\/ Check that NumberFormat throws exception for isStrict()\/setStrict()\n+    \/\/ when subclass does not implement said methods\n+    @Test\n+    public void numberFormatTest() {\n+        FooFormat fmt = new FooFormat();\n+        assertThrows(UnsupportedOperationException.class, fmt::isStrict);\n+        assertThrows(UnsupportedOperationException.class, () -> fmt.setStrict(false));\n+    }\n+\n+    \/\/ Dummy NumberFormat class to check that isStrict() and setStrict()\n+    \/\/ are not implemented by default\n+    private static class FooFormat extends NumberFormat {\n+\n+        \/\/ Provide overrides for abstract methods\n+        @Override\n+        public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Number parse(String source, ParsePosition parsePosition) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictMethodsTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}