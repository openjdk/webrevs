{"files":[{"patch":"@@ -588,0 +588,12 @@\n+\n+    @Override\n+    public boolean isStrict() {\n+        throw new UnsupportedOperationException(\n+                \"ChoiceFormat does not utilize leniency when parsing\");\n+    }\n+\n+    @Override\n+    public void setStrict(boolean strict) {\n+        throw new UnsupportedOperationException(\n+                \"ChoiceFormat does not utilize leniency when parsing\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -351,0 +351,9 @@\n+    \/**\n+     * True if this {@code CompactNumberFormat} will parse numbers with strict\n+     * leniency.\n+     *\n+     * @serial\n+     * @since 23\n+     *\/\n+    private boolean parseStrict = false;\n+\n@@ -1501,1 +1510,1 @@\n-     * Parses a compact number from a string to produce a {@code Number}.\n+     * {@inheritDoc NumberFormat}\n@@ -1503,12 +1512,1 @@\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and {@code null} is returned.\n-     * <p>\n-     * The value is the numeric part in the given text multiplied\n+     * The returned value is the numeric part in the given text multiplied\n@@ -1517,0 +1515,29 @@\n+     * <p>\n+     * A {@code CompactNumberFormat} can match\n+     * the default prefix\/suffix to a compact prefix\/suffix interchangeably.\n+     * <p>\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n+     * <p>\n+     * Parsing fails when <b>lenient<\/b>, if the prefix and\/or suffix are non-empty\n+     * and cannot be found due to parsing ending early, or the first character\n+     * after the prefix cannot be parsed.\n+     * <p>\n+     * Parsing fails when <b>strict<\/b>, if in {@code text},\n+     * <ul>\n+     *   <li> The default or a compact prefix is not found. For example, the {@code\n+     *   Locale.US} currency format prefix: \"{@code $}\"\n+     *   <li> The default or a compact suffix is not found. For example, a {@code Locale.US}\n+     *   {@link NumberFormat.Style#SHORT} compact suffix: \"{@code K}\"\n+     *   <li> {@link #isGroupingUsed()} returns {@code false}, and the grouping\n+     *   symbol is found\n+     *   <li> {@link #isGroupingUsed()} returns {@code true}, and {@link\n+     *   #getGroupingSize()} is not adhered to\n+     *   <li> {@link #isParseIntegerOnly()} returns {@code true}, and the decimal\n+     *   separator is found\n+     *   <li> {@link #isGroupingUsed()} returns {@code true} and {@link\n+     *   #isParseIntegerOnly()} returns {@code false}, and the grouping\n+     *   symbol occurs after the decimal separator\n+     *   <li> Any other characters are found, that are not the expected symbols,\n+     *   and are not digits that occur within the numerical portion\n+     * <\/ul>\n+     * <p>\n@@ -1556,1 +1583,0 @@\n-     *\n@@ -1664,0 +1690,7 @@\n+        } else {\n+            \/\/ Neither prefix match, should fail now (strict or lenient), before\n+            \/\/ position is incremented by subparseNumber(). Otherwise, an empty\n+            \/\/ prefix could pass through here, position gets incremented by the\n+            \/\/ numerical portion, and return a faulty errorIndex and index later.\n+            pos.errorIndex = position;\n+            return null;\n@@ -1708,0 +1741,5 @@\n+            if (parseStrict) {\n+                \/\/ When strict, if -1L was returned, index should be\n+                \/\/ reset to the original index to ensure failure\n+                pos.index = oldStart;\n+            }\n@@ -1889,1 +1927,4 @@\n-            return matchAffix(text, position, suffix, defaultSuffix, matchedSuffix);\n+            \/\/ Suffix must match exactly when strict\n+            return parseStrict ? matchAffix(text, position, suffix, defaultSuffix, matchedSuffix)\n+                    && text.length() == position + suffix.length()\n+                    : matchAffix(text, position, suffix, defaultSuffix, matchedSuffix);\n@@ -1927,1 +1968,1 @@\n-            \/\/ Do not break if a match occur; there is a possibility that the\n+            \/\/ When lenient, do not break if a match occurs; there is a possibility that the\n@@ -1929,2 +1970,3 @@\n-            \/\/ string.\n-            \/\/ For example, matching \"3Mdx\" with \"M\", \"Md\" should match with \"Md\"\n+            \/\/ string. For example, matching \"3Mdx\" with \"M\", \"Md\" should match\n+            \/\/ with \"Md\". However, when strict, break as the match should be exact,\n+            \/\/ and thus no need to check for a longer suffix.\n@@ -1938,0 +1980,4 @@\n+                if (parseStrict) {\n+                    \/\/ when strict, exit early with exact match, same for negative\n+                    break;\n+                }\n@@ -1947,0 +1993,3 @@\n+                if (parseStrict) {\n+                    break;\n+                }\n@@ -1952,0 +2001,1 @@\n+        \/\/ When strict, text must end with the default suffix\n@@ -1955,2 +2005,5 @@\n-            if (text.regionMatches(position, positiveSuffix, 0,\n-                    positiveSuffix.length())) {\n+            boolean containsPosSuffix = text.regionMatches(position,\n+                    positiveSuffix, 0, positiveSuffix.length());\n+            boolean endsWithPosSuffix = containsPosSuffix && text.length() ==\n+                    position + positiveSuffix.length();\n+            if (parseStrict ? endsWithPosSuffix : containsPosSuffix) {\n@@ -1961,2 +2014,5 @@\n-            if (text.regionMatches(position, negativeSuffix, 0,\n-                    negativeSuffix.length())) {\n+            boolean containsNegSuffix = text.regionMatches(position,\n+                    negativeSuffix, 0, negativeSuffix.length());\n+            boolean endsWithNegSuffix = containsNegSuffix && text.length() ==\n+                    position + negativeSuffix.length();\n+            if (parseStrict ? endsWithNegSuffix : containsNegSuffix) {\n@@ -1969,1 +2025,1 @@\n-        \/\/ If both matches, take the longest one\n+        \/\/ If both match, take the longest one\n@@ -2080,0 +2136,1 @@\n+        decimalFormat.setStrict(parseStrict);\n@@ -2319,0 +2376,25 @@\n+    \/**\n+     * {@inheritDoc NumberFormat}\n+     *\n+     * @see #setStrict(boolean)\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public boolean isStrict() {\n+        return parseStrict;\n+    }\n+\n+    \/**\n+     * {@inheritDoc NumberFormat}\n+     *\n+     * @see #isStrict()\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public void setStrict(boolean strict) {\n+        decimalFormat.setStrict(strict);\n+        parseStrict = strict; \/\/ don't call super, default is UOE\n+    }\n+\n@@ -2376,1 +2458,2 @@\n-                && parseBigDecimal == other.parseBigDecimal;\n+                && parseBigDecimal == other.parseBigDecimal\n+                && parseStrict == other.parseStrict;\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":107,"deletions":24,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+\n@@ -2143,1 +2144,7 @@\n-     * Parses text from a string to produce a {@code Number}.\n+     * {@inheritDoc NumberFormat}\n+     * <p>\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n+     * <p>\n+     * Parsing fails when <b>lenient<\/b>, if the prefix and\/or suffix are non-empty\n+     * and cannot be found due to parsing ending early, or the first character\n+     * after the prefix cannot be parsed.\n@@ -2145,10 +2152,18 @@\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and null is returned.\n+     * Parsing fails when <b>strict<\/b>, if in {@code text},\n+     * <ul>\n+     *   <li> The prefix is not found. For example, a {@code Locale.US} currency\n+     *   format prefix: \"{@code $}\"\n+     *   <li> The suffix is not found. For example, a {@code Locale.US} percent\n+     *   format suffix: \"{@code %}\"\n+     *   <li> {@link #isGroupingUsed()} returns {@code true}, and {@link\n+     *   #getGroupingSize()} is not adhered to\n+     *   <li> {@link #isGroupingUsed()} returns {@code false}, and the grouping\n+     *   symbol is found\n+     *   <li> {@link #isParseIntegerOnly()} returns {@code true}, and the decimal\n+     *   separator is found\n+     *   <li> {@link #isGroupingUsed()} returns {@code true} and {@link\n+     *   #isParseIntegerOnly()} returns {@code false}, and the grouping\n+     *   symbol occurs after the decimal separator\n+     *   <li> Any other characters are found, that are not the expected symbols,\n+     *   and are not digits that occur within the numerical portion\n+     * <\/ul>\n@@ -2374,0 +2389,2 @@\n+        \/\/ position will serve as new index when success, otherwise it will\n+        \/\/ serve as errorIndex when failure\n@@ -2375,0 +2392,3 @@\n+\n+        \/\/ First character after the prefix was un-parseable, should\n+        \/\/ fail regardless if lenient or strict.\n@@ -2381,1 +2401,2 @@\n-        \/\/ Check for suffix\n+        \/\/ When strict, text should end with the suffix.\n+        \/\/ When lenient, text only needs to contain the suffix.\n@@ -2384,2 +2405,5 @@\n-                gotPositive = text.regionMatches(position,positiveSuffix,0,\n-                        positiveSuffix.length());\n+                boolean containsPosSuffix =\n+                        text.regionMatches(position, positiveSuffix, 0, positiveSuffix.length());\n+                boolean endsWithPosSuffix =\n+                        containsPosSuffix && text.length() == position + positiveSuffix.length();\n+                gotPositive = parseStrict ? endsWithPosSuffix : containsPosSuffix;\n@@ -2388,2 +2412,5 @@\n-                gotNegative = text.regionMatches(position,negativeSuffix,0,\n-                        negativeSuffix.length());\n+                boolean containsNegSuffix =\n+                        text.regionMatches(position, negativeSuffix, 0, negativeSuffix.length());\n+                boolean endsWithNegSuffix =\n+                        containsNegSuffix && text.length() == position + negativeSuffix.length();\n+                gotNegative = parseStrict ? endsWithNegSuffix : containsNegSuffix;\n@@ -2407,0 +2434,1 @@\n+            \/\/ No failures, thus increment the index by the suffix\n@@ -2408,1 +2436,1 @@\n-                    (gotPositive ? positiveSuffix.length() : negativeSuffix.length()); \/\/ mark success!\n+                    (gotPositive ? positiveSuffix.length() : negativeSuffix.length());\n@@ -2423,1 +2451,1 @@\n-     * beginning at position, until an unparseable character is seen.\n+     * beginning at {@code position}, until an unparseable character is seen.\n@@ -2441,1 +2469,1 @@\n-        if (!isExponent && text.regionMatches(position,symbols.getInfinity(),0,\n+        if (!isExponent && text.regionMatches(position, symbols.getInfinity(), 0,\n@@ -2470,0 +2498,2 @@\n+            int prevSeparatorIndex = -groupingSize;\n+            int startPos = position; \/\/ Rely on startPos as index after prefix\n@@ -2491,0 +2521,7 @@\n+                \/\/ Enforce the grouping size on the first group\n+                if (parseStrict && isGroupingUsed() && position == startPos + groupingSize\n+                        && prevSeparatorIndex == -groupingSize && !sawDecimal\n+                        && digit >= 0 && digit <= 9) {\n+                    return position;\n+                }\n+\n@@ -2520,0 +2557,4 @@\n+                    \/\/ Check grouping size on decimal separator\n+                    if (parseStrict && isGroupingViolation(position, prevSeparatorIndex)) {\n+                        return groupingViolationIndex(position, prevSeparatorIndex);\n+                    }\n@@ -2528,2 +2569,17 @@\n-                    if (sawDecimal) {\n-                        break;\n+                    if (parseStrict) {\n+                        \/\/ text should not start with grouping when strict\n+                        if (position == startPos) {\n+                            return startPos;\n+                        }\n+                        \/\/ when strict, fail if grouping occurs after decimal OR\n+                        \/\/ current group violates grouping size\n+                        if (sawDecimal || (isGroupingViolation(position, prevSeparatorIndex))) {\n+                            return groupingViolationIndex(position, prevSeparatorIndex);\n+                        }\n+                        prevSeparatorIndex = position; \/\/ track previous\n+                    } else {\n+                        \/\/ when lenient, only exit if grouping occurs after decimal\n+                        \/\/ subsequent grouping symbols are allowed when lenient\n+                        if (sawDecimal) {\n+                            break;\n+                        }\n@@ -2557,0 +2613,17 @@\n+            \/\/ (When strict), within the loop we enforce grouping when encountering\n+            \/\/ decimal\/grouping symbols. Once outside loop, we need to check\n+            \/\/ the final grouping, ex: \"1,234\". Only check the final grouping\n+            \/\/ if we have not seen a decimal separator, to prevent a non needed check,\n+            \/\/ for ex: \"1,234.\", \"1,234.12\"\n+            if (parseStrict) {\n+                if (!sawDecimal && isGroupingViolation(position, prevSeparatorIndex)) {\n+                    \/\/ -1, since position is incremented by one too many when loop is finished\n+                    \/\/ \"1,234%\" and \"1,234\" both end with pos = 5, since '%' breaks\n+                    \/\/ the loop before incrementing position. In both cases, check\n+                    \/\/ should be done at pos = 4\n+                    return groupingViolationIndex(position - 1, prevSeparatorIndex);\n+                }\n+            }\n+\n+            \/\/ If a grouping symbol is not followed by a digit, it must be\n+            \/\/ backed up to either exit early or fail depending on leniency\n@@ -2578,0 +2651,1 @@\n+    }\n@@ -2579,0 +2653,22 @@\n+    \/\/ Checks to make sure grouping size is not violated. Used when strict.\n+    private boolean isGroupingViolation(int pos, int prevGroupingPos) {\n+        assert !parseStrict : \"Grouping violations should only occur when strict\";\n+        return isGroupingUsed() && \/\/ Only violates if using grouping\n+                \/\/ Checks if a previous grouping symbol was seen.\n+                prevGroupingPos != -groupingSize &&\n+                \/\/ The check itself, - 1 to account for grouping\/decimal symbol\n+                pos - 1 != prevGroupingPos + groupingSize;\n+    }\n+\n+    \/\/ Calculates the index that violated the grouping size\n+    \/\/ Violation can be over or under the grouping size\n+    \/\/ under - Current group has a grouping size of less than the expected\n+    \/\/ over - Current group has a grouping size of more than the expected\n+    private int groupingViolationIndex(int pos, int prevGroupingPos) {\n+        \/\/ Both examples assume grouping size of 3 and 0 indexed\n+        \/\/ under ex: \"1,23,4\". (4) OR \"1,,2\". (2) When under, violating char is grouping symbol\n+        \/\/ over ex: \"1,2345,6. (5) When over, violating char is the excess digit\n+        \/\/ This method is only evaluated when a grouping symbol is found, thus\n+        \/\/ we can take the minimum of either the current pos, or where we expect\n+        \/\/ the current group to have ended\n+        return Math.min(pos, prevGroupingPos + groupingSize + 1);\n@@ -2891,0 +2987,24 @@\n+    \/**\n+     * {@inheritDoc NumberFormat}\n+     *\n+     * @see #setStrict(boolean)\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public boolean isStrict() {\n+        return parseStrict;\n+    }\n+\n+    \/**\n+     * {@inheritDoc NumberFormat}\n+     *\n+     * @see #isStrict()\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public void setStrict(boolean strict) {\n+        parseStrict = strict;\n+    }\n+\n@@ -2994,1 +3114,2 @@\n-            && symbols.equals(other.symbols);\n+            && symbols.equals(other.symbols)\n+            && parseStrict == other.parseStrict;\n@@ -4179,0 +4300,9 @@\n+    \/**\n+     * True if this {@code DecimalFormat} will parse numbers with strict\n+     * leniency.\n+     *\n+     * @serial\n+     * @since 23\n+     *\/\n+    private boolean parseStrict = false;\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":152,"deletions":22,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -109,0 +109,3 @@\n+ * <p> Subclasses may also consider implementing leniency when parsing.\n+ * The definition of leniency should be delegated to the subclass.\n+ *\n@@ -213,1 +216,1 @@\n-     * Parses text from a string to produce an object.\n+     * Parses text from the given string to produce an object.\n@@ -215,3 +218,2 @@\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n+     * This method attempts to parse text starting at the index given by\n+     * {@code pos}. If parsing succeeds, then the index of {@code pos} is updated\n@@ -224,1 +226,1 @@\n-     * the character where the error occurred, and null is returned.\n+     * the character where the error occurred, and {@code null} is returned.\n@@ -226,1 +228,1 @@\n-     * @param source A {@code String}, part of which should be parsed.\n+     * @param source the {@code String} to parse\n@@ -230,2 +232,3 @@\n-     *         error, returns null.\n-     * @throws NullPointerException if {@code source} or {@code pos} is null.\n+     *         error, returns {@code null}.\n+     * @throws NullPointerException if {@code source} or {@code pos} is\n+     *         {@code null}.\n@@ -237,1 +240,1 @@\n-     * The method may not use the entire text of the given string.\n+     * This method may not use the entire text of the given string.\n@@ -239,1 +242,1 @@\n-     * @param source A {@code String} whose beginning should be parsed.\n+     * @param source A {@code String}, to be parsed from the beginning.\n@@ -241,3 +244,2 @@\n-     * @throws    ParseException if the beginning of the specified string\n-     *            cannot be parsed.\n-     * @throws NullPointerException if {@code source} is null.\n+     * @throws ParseException if parsing fails\n+     * @throws NullPointerException if {@code source} is {@code null}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.io.InvalidObjectException;\n@@ -43,0 +42,1 @@\n+import java.io.InvalidObjectException;\n@@ -55,0 +55,1 @@\n+\n@@ -150,1 +151,0 @@\n- *\n@@ -178,2 +178,10 @@\n- * <h2><a id=\"synchronization\">Synchronization<\/a><\/h2>\n- *\n+ * <h2><a id=\"leniency\">Leniency<\/a><\/h2>\n+ * {@code NumberFormat} by default, parses leniently. Subclasses may consider\n+ * implementing strict parsing and as such, overriding and providing\n+ * implementations for the optional {@link #isStrict()} and {@link\n+ * #setStrict(boolean)} methods.\n+ * <p>\n+ * Lenient parsing should be used when attempting to parse a number\n+ * out of a String that contains non-numerical or non-format related values.\n+ * For example, using a {@link Locale#US} currency format to parse the number\n+ * {@code 1000} out of the String \"$1,000.00 was paid\".\n@@ -181,0 +189,6 @@\n+ * Strict parsing should be used when attempting to ensure a String adheres exactly\n+ * to a locale's conventions, and can thus serve to validate input. For example, successfully\n+ * parsing the number {@code 1000.55} out of the String \"1.000,55\" confirms the String\n+ * exactly adhered to the {@link Locale#GERMANY} numerical conventions.\n+ *\n+ * <h2><a id=\"synchronization\">Synchronization<\/a><\/h2>\n@@ -288,15 +302,1 @@\n-     * Parses text from a string to produce a {@code Number}.\n-     * <p>\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and null is returned.\n-     * <p>\n-     * See the {@link #parse(String, ParsePosition)} method for more information\n-     * on number parsing.\n+     * {@inheritDoc Format}\n@@ -304,1 +304,3 @@\n-     * @param source A {@code String}, part of which should be parsed.\n+     * @implSpec This implementation is equivalent to calling {@code parse(source,\n+     *           pos)}.\n+     * @param source the {@code String} to parse\n@@ -402,1 +404,14 @@\n-     * Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,\n+     * Parses text from the beginning of the given string to produce a {@code Number}.\n+     * <p>\n+     * This method attempts to parse text starting at the index given by the\n+     * {@code ParsePosition}. If parsing succeeds, then the index of the {@code\n+     * ParsePosition} is updated to the index after the last character used\n+     * (parsing does not necessarily use all characters up to the end of the\n+     * string), and the parsed number is returned. The updated {@code\n+     * ParsePosition} can be used to indicate the starting\n+     * point for the next call to this method. If an error occurs, then the\n+     * index of the {@code ParsePosition} is not changed, the error index of the\n+     * {@code ParsePosition} is set to the index of the character where the error\n+     * occurred, and {@code null} is returned.\n+     * <p>\n+     * This method will return a Long if possible (e.g., within the range [Long.MIN_VALUE,\n@@ -404,11 +419,9 @@\n-     * If IntegerOnly is set, will stop at a decimal\n-     * point (or equivalent; e.g., for rational numbers \"1 2\/3\", will stop\n-     * after the 1).\n-     * Does not throw an exception; if no object can be parsed, index is\n-     * unchanged!\n-     *\n-     * @param source the String to parse\n-     * @param parsePosition the parse position\n-     * @return the parsed value\n-     * @see java.text.NumberFormat#isParseIntegerOnly\n-     * @see java.text.Format#parseObject\n+     *\n+     * @param source the {@code String} to parse\n+     * @param parsePosition A {@code ParsePosition} object with index and error\n+     *            index information as described above.\n+     * @return A {@code Number} parsed from the string. In case of\n+     *         failure, returns {@code null}.\n+     * @throws NullPointerException if {@code source} or {@code ParsePosition}\n+     *         is {@code null}.\n+     * @see #isStrict()\n@@ -419,2 +432,1 @@\n-     * Parses text from the beginning of the given string to produce a number.\n-     * The method may not use the entire text of the given string.\n+     * Parses text from the beginning of the given string to produce a {@code Number}.\n@@ -422,2 +434,2 @@\n-     * See the {@link #parse(String, ParsePosition)} method for more information\n-     * on number parsing.\n+     * This method will return a Long if possible (e.g., within the range [Long.MIN_VALUE,\n+     * Long.MAX_VALUE] and with no decimals), otherwise a Double.\n@@ -425,1 +437,1 @@\n-     * @param source A {@code String} whose beginning should be parsed.\n+     * @param source A {@code String}, to be parsed from the beginning.\n@@ -427,2 +439,3 @@\n-     * @throws    ParseException if the beginning of the specified string\n-     *            cannot be parsed.\n+     * @throws ParseException if parsing fails\n+     * @throws NullPointerException if {@code source} is {@code null}.\n+     * @see #isStrict()\n@@ -466,0 +479,38 @@\n+    \/**\n+     * {@return {@code true} if this format will parse numbers strictly;\n+     * {@code false} otherwise}\n+     *\n+     * @implSpec The default implementation always throws {@code\n+     * UnsupportedOperationException}. Subclasses should override this method\n+     * when implementing strict parsing.\n+     * @throws    UnsupportedOperationException if the implementation of this\n+     *            method does not support this operation\n+     * @see ##leniency Leniency Section\n+     * @see #setStrict(boolean)\n+     * @since 23\n+     *\/\n+    public boolean isStrict() {\n+        throw new UnsupportedOperationException(\"Subclasses should override this \" +\n+                \"method when implementing strict parsing\");\n+    }\n+\n+    \/**\n+     * Change the leniency value for parsing. Parsing can either be strict or lenient,\n+     * by default it is lenient.\n+     *\n+     * @implSpec The default implementation always throws {@code\n+     * UnsupportedOperationException}. Subclasses should override this method\n+     * when implementing strict parsing.\n+     * @param strict {@code true} if parsing should be done strictly;\n+     *               {@code false} otherwise\n+     * @throws    UnsupportedOperationException if the implementation of this\n+     *            method does not support this operation\n+     * @see ##leniency Leniency Section\n+     * @see #isStrict()\n+     * @since 23\n+     *\/\n+    public void setStrict(boolean strict) {\n+        throw new UnsupportedOperationException(\"Subclasses should override this \" +\n+                \"method when implementing strict parsing\");\n+    }\n+\n@@ -762,1 +813,1 @@\n-        return (maximumIntegerDigits == other.maximumIntegerDigits\n+        return maximumIntegerDigits == other.maximumIntegerDigits\n@@ -767,1 +818,1 @@\n-            && parseIntegerOnly == other.parseIntegerOnly);\n+            && parseIntegerOnly == other.parseIntegerOnly;\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":92,"deletions":41,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8177552 8222756\n+ * @bug 8177552 8222756 8327640\n@@ -134,0 +134,12 @@\n+        \/\/ Changing the parseBigDecimal of second object; objects must be equal\n+        cnf2.setParseBigDecimal(true);\n+        checkEquals(cnf1, cnf2, true, \"9th\", \"\");\n+\n+        \/\/ Changing the strict parsing value of first object; objects must not be equal\n+        cnf1.setStrict(true);\n+        checkEquals(cnf1, cnf2, false, \"10th\", \"different strict parsing\");\n+\n+        \/\/ Changing the strict parsing value of second object; objects must be equal\n+        cnf2.setStrict(true);\n+        checkEquals(cnf1, cnf2, true, \"11th\", \"\");\n+\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestEquality.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 8177552\n+ * @bug 8177552 8327640\n@@ -74,0 +74,1 @@\n+        FORMAT_FR_FR.setStrict(true);\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/serialization\/TestSerialization.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Check parseStrict correctness for DecimalFormat.equals()\n+ * @run junit EqualityTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.DecimalFormat;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+\n+public class EqualityTest {\n+\n+    private static final DecimalFormat fmt1 = new DecimalFormat();\n+    private static final DecimalFormat fmt2 = new DecimalFormat();\n+\n+    \/\/ Ensure that parseStrict is reflected correctly for DecimalFormat.equals()\n+    @Test\n+    public void checkStrictTest() {\n+        \/\/ parseStrict is false by default\n+        assertEquals(fmt1, fmt2);\n+        fmt1.setStrict(true);\n+        assertNotEquals(fmt1, fmt2);\n+        fmt2.setStrict(true);\n+        assertEquals(fmt1, fmt2);\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/EqualityTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Check parseStrict correctness for DecimalFormat serialization\n+ * @run junit\/othervm SerializationTest\n+ *\/\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class SerializationTest {\n+\n+    private static final NumberFormat FORMAT = NumberFormat.getInstance();\n+\n+    @BeforeAll\n+    public static void mutateFormat() {\n+        FORMAT.setStrict(true);\n+    }\n+\n+    @Test\n+    public void testSerialization() throws IOException, ClassNotFoundException {\n+        \/\/ Serialize\n+        serialize(\"fmt.ser\", FORMAT);\n+        \/\/ Deserialize\n+        deserialize(\"fmt.ser\", FORMAT);\n+    }\n+\n+    private void serialize(String fileName, NumberFormat... formats)\n+            throws IOException {\n+        try (ObjectOutputStream os = new ObjectOutputStream(\n+                new FileOutputStream(fileName))) {\n+            for (NumberFormat fmt : formats) {\n+                os.writeObject(fmt);\n+            }\n+        }\n+    }\n+\n+    private static void deserialize(String fileName, NumberFormat... formats)\n+            throws IOException, ClassNotFoundException {\n+        try (ObjectInputStream os = new ObjectInputStream(\n+                new FileInputStream(fileName))) {\n+            for (NumberFormat fmt : formats) {\n+                NumberFormat obj = (NumberFormat) os.readObject();\n+                assertEquals(fmt, obj, \"Serialized and deserialized\"\n+                        + \" objects do not match\");\n+\n+                String badNumber = \"fooofooo23foo\";\n+                assertThrows(ParseException.class, () -> fmt.parse(badNumber));\n+                assertThrows(ParseException.class, () -> obj.parse(badNumber));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/SerializationTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,417 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Test suite for NumberFormat parsing when lenient.\n+ * @run junit\/othervm -Duser.language=en -Duser.country=US LenientParseTest\n+ * @run junit\/othervm -Duser.language=ja -Duser.country=JP LenientParseTest\n+ * @run junit\/othervm -Duser.language=zh -Duser.country=CN LenientParseTest\n+ * @run junit\/othervm -Duser.language=tr -Duser.country=TR LenientParseTest\n+ * @run junit\/othervm -Duser.language=de -Duser.country=DE LenientParseTest\n+ * @run junit\/othervm -Duser.language=fr -Duser.country=FR LenientParseTest\n+ * @run junit\/othervm -Duser.language=ar -Duser.country=AR LenientParseTest\n+ *\/\n+\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/\/ Tests lenient parsing, this is done by testing the NumberFormat factory instances\n+\/\/ against a number of locales with different formatting conventions. The locales\n+\/\/ used all use a grouping size of 3. When lenient, parsing only fails\n+\/\/ if the prefix and\/or suffix are not found, or the first character after the\n+\/\/ prefix is un-parseable. The tested locales all use groupingSize of 3.\n+public class LenientParseTest {\n+\n+    \/\/ Used to retrieve the locale's expected symbols\n+    private static final DecimalFormatSymbols dfs =\n+            new DecimalFormatSymbols(Locale.getDefault());\n+    private static final DecimalFormat dFmt = (DecimalFormat)\n+            NumberFormat.getNumberInstance(Locale.getDefault());\n+    private static final DecimalFormat cFmt =\n+            (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.getDefault());\n+    private static final DecimalFormat pFmt =\n+            (DecimalFormat) NumberFormat.getPercentInstance(Locale.getDefault());\n+    private static final CompactNumberFormat cmpctFmt =\n+            (CompactNumberFormat) NumberFormat.getCompactNumberInstance(Locale.getDefault(),\n+                    NumberFormat.Style.SHORT);\n+\n+    \/\/ All NumberFormats should parse leniently (which is the default)\n+    static {\n+        \/\/ To effectively test compactNumberFormat, these should be set accordingly\n+        cmpctFmt.setParseIntegerOnly(false);\n+        cmpctFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ ---- NumberFormat tests ----\n+    \/\/ Test prefix\/suffix behavior with a predefined DecimalFormat\n+    \/\/ Non-localized, only run once\n+    @ParameterizedTest\n+    @MethodSource(\"badParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void numFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        \/\/ Format with grouping size = 3, prefix = a, suffix = b\n+        DecimalFormat nonLocalizedDFmt = new DecimalFormat(\"a#,#00.00b\");\n+        failParse(nonLocalizedDFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    \/\/ All input Strings should parse fully and return the expected value.\n+    \/\/ Expected index should be the length of the parse string, since it parses fully\n+    @ParameterizedTest\n+    @MethodSource(\"validFullParseStrings\")\n+    public void numFmtSuccessFullParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ All input Strings should parse partially and return expected value\n+    \/\/ with the expected final index\n+    @ParameterizedTest\n+    @MethodSource(\"validPartialParseStrings\")\n+    public void numFmtSuccessPartialParseTest(String toParse, double expectedValue,\n+                                              int expectedIndex) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+    }\n+\n+    \/\/ Parse partially due to no grouping\n+    @ParameterizedTest\n+    @MethodSource(\"noGroupingParseStrings\")\n+    public void numFmtStrictGroupingNotUsed(String toParse, double expectedValue, int expectedIndex) {\n+        dFmt.setGroupingUsed(false);\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+        dFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ Parse partially due to integer only\n+    @ParameterizedTest\n+    @MethodSource(\"integerOnlyParseStrings\")\n+    public void numFmtStrictIntegerOnlyUsed(String toParse, int expectedValue, int expectedIndex) {\n+        dFmt.setParseIntegerOnly(true);\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+        dFmt.setParseIntegerOnly(false);\n+    }\n+\n+    \/\/ ---- CurrencyFormat tests ----\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidFullParseStrings\")\n+    public void currFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ Strings may parse partially or fail. This is because the mapped\n+    \/\/ data may cause the error to occur before the suffix can be found, (if the locale\n+    \/\/ uses a suffix).\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidPartialParseStrings\")\n+    public void currFmtParseTest(String toParse, double expectedValue,\n+                                 int expectedIndex) {\n+        if (cFmt.getPositiveSuffix().length() > 0) {\n+            \/\/ Since the error will occur before suffix is found, exception is thrown.\n+            failParse(cFmt, toParse, expectedIndex);\n+        } else {\n+            \/\/ Empty suffix, thus even if the error occurs, we have already found the\n+            \/\/ prefix, and simply parse partially\n+            assertEquals(expectedValue, successParse(cFmt, toParse, expectedIndex));\n+        }\n+    }\n+\n+    \/\/ ---- PercentFormat tests ----\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidFullParseStrings\")\n+    public void percentFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(pFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ Strings may parse partially or fail. This is because the mapped\n+    \/\/ data may cause the error to occur before the suffix can be found, (if the locale\n+    \/\/ uses a suffix).\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidPartialParseStrings\")\n+    public void percentFmtParseTest(String toParse, double expectedValue,\n+                                 int expectedIndex) {\n+        if (pFmt.getPositiveSuffix().length() > 0) {\n+            \/\/ Since the error will occur before suffix is found, exception is thrown.\n+            failParse(pFmt, toParse, expectedIndex);\n+        } else {\n+            \/\/ Empty suffix, thus even if the error occurs, we have already found the\n+            \/\/ prefix, and simply parse partially\n+            assertEquals(expectedValue, successParse(pFmt, toParse, expectedIndex));\n+        }\n+    }\n+\n+    \/\/ ---- CompactNumberFormat tests ----\n+    \/\/ Can match to both the decimalFormat patterns and the compact patterns\n+    \/\/ Unlike the other tests, this test is only ran against the US Locale and\n+    \/\/ tests against data built with the thousands format (K).\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidPartialParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtFailParseTest(String toParse, double expectedValue, int expectedErrorIndex) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, expectedErrorIndex));\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidFullParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ ---- Helper test methods ----\n+\n+    \/\/ Method is used when a String should parse successfully. This does not indicate\n+    \/\/ that the entire String was used, however. The index and errorIndex values\n+    \/\/ should be as expected.\n+    private double successParse(NumberFormat fmt, String toParse, int expectedIndex) {\n+        Number parsedValue = assertDoesNotThrow(() -> fmt.parse(toParse));\n+        ParsePosition pp = new ParsePosition(0);\n+        assertDoesNotThrow(() -> fmt.parse(toParse, pp));\n+        assertEquals(-1, pp.getErrorIndex(),\n+                \"ParsePosition ErrorIndex is not in correct location\");\n+        assertEquals(expectedIndex, pp.getIndex(),\n+                \"ParsePosition Index is not in correct location\");\n+        return parsedValue.doubleValue();\n+    }\n+\n+    \/\/ Method is used when a String should fail parsing. Indicated by either a thrown\n+    \/\/ ParseException, or null is returned depending on which parse method is invoked.\n+    \/\/ errorIndex should be as expected.\n+    private void failParse(NumberFormat fmt, String toParse, int expectedErrorIndex) {\n+        ParsePosition pp = new ParsePosition(0);\n+        assertThrows(ParseException.class, () -> fmt.parse(toParse));\n+        assertNull(fmt.parse(toParse, pp));\n+        assertEquals(expectedErrorIndex, pp.getErrorIndex());\n+    }\n+\n+    \/\/ ---- Data Providers ----\n+\n+    \/\/ Strings that should fail when parsed leniently.\n+    \/\/ Given as Arguments<String, expectedErrorIndex>\n+    \/\/ Non-localized data. For reference, the pattern of nonLocalizedDFmt is\n+    \/\/ \"a#,#00.00b\"\n+    private static Stream<Arguments> badParseStrings() {\n+        return Stream.of(\n+                \/\/ No prefix\n+                Arguments.of(\"1,1b\", 0),\n+                \/\/ No suffix\n+                Arguments.of(\"a1,11\", 5),\n+                \/\/ Digit does not follow the last grouping separator\n+                \/\/ Current behavior fails on the grouping separator\n+                Arguments.of(\"a1,11,z\", 5),\n+                \/\/ No suffix after grouping\n+                Arguments.of(\"a1,11,\", 5),\n+                \/\/ No prefix and suffix\n+                Arguments.of(\"1,11\", 0),\n+                \/\/ First character after prefix is un-parseable\n+                \/\/ Behavior is to expect error index at 0, not 1\n+                Arguments.of(\"ac1,11\", 0));\n+    }\n+\n+    \/\/ These data providers use US locale grouping and decimal separators\n+    \/\/ for readability, however, the data is tested against multiple locales\n+    \/\/ and is converted appropriately at runtime.\n+\n+    \/\/ Strings that should parse successfully, and consume the entire String\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber)\n+    private static Stream<Arguments> validFullParseStrings() {\n+        return Stream.of(\n+                \/\/ Many subsequent grouping symbols\n+                Arguments.of(\"1,,,1\", 11d),\n+                Arguments.of(\"11,,,11,,,11\", 111111d),\n+                \/\/ Bad grouping size (with decimal)\n+                Arguments.of(\"1,1.\", 11d),\n+                Arguments.of(\"11,111,11.\", 1111111d),\n+                \/\/ Improper grouping size (with decimal and digits after)\n+                Arguments.of(\"1,1.1\", 11.1d),\n+                Arguments.of(\"1,11.1\", 111.1d),\n+                Arguments.of(\"1,1111.1\", 11111.1d),\n+                Arguments.of(\"11,111,11.1\", 1111111.1d),\n+                \/\/ Starts with grouping symbol\n+                Arguments.of(\",111,,1,1\", 11111d),\n+                Arguments.of(\",1\", 1d),\n+                Arguments.of(\",,1\", 1d),\n+                \/\/ Leading Zeros (not digits)\n+                Arguments.of(\"000,1,1\", 11d),\n+                Arguments.of(\"000,111,11,,1\", 111111d),\n+                Arguments.of(\"0,000,1,,1,1\", 111d),\n+                Arguments.of(\"1,234.00\", 1234d),\n+                Arguments.of(\"1,234.0\", 1234d),\n+                Arguments.of(\"1,234.\", 1234d),\n+                Arguments.of(\"1,234.00123\", 1234.00123d),\n+                Arguments.of(\"1,234.012\", 1234.012d),\n+                Arguments.of(\"1,234.224\", 1234.224d),\n+                Arguments.of(\"1\", 1d),\n+                Arguments.of(\"10\", 10d),\n+                Arguments.of(\"100\", 100d),\n+                Arguments.of(\"1000\", 1000d),\n+                Arguments.of(\"1,000\", 1000d),\n+                Arguments.of(\"10,000\", 10000d),\n+                Arguments.of(\"10000\", 10000d),\n+                Arguments.of(\"100,000\", 100000d),\n+                Arguments.of(\"1,000,000\", 1000000d),\n+                Arguments.of(\"10,000,000\", 10000000d))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n+    }\n+\n+    \/\/ Strings that should parse successfully, but do not use the entire String\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> validPartialParseStrings() {\n+        return Stream.of(\n+                \/\/ End with grouping symbol\n+                Arguments.of(\"11,\", 11d, 2),\n+                Arguments.of(\"11,,\", 11d, 3),\n+                Arguments.of(\"11,,,\", 11d, 4),\n+                \/\/ Random chars that aren't the expected symbols\n+                Arguments.of(\"1,1P111\", 11d, 3),\n+                Arguments.of(\"1.1P111\", 1.1d, 3),\n+                Arguments.of(\"1P,1111\", 1d, 1),\n+                Arguments.of(\"1P.1111\", 1d, 1),\n+                Arguments.of(\"1,1111P\", 11111d, 6),\n+                \/\/ Grouping occurs after decimal separator)\n+                Arguments.of(\"1.11,11\", 1.11d, 4),\n+                Arguments.of(\"1.,11,11\", 1d, 2))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Test data input for when parse integer only is true\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> integerOnlyParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"1234.1234\", 1234, 4),\n+                Arguments.of(\"1234.12\", 1234, 4),\n+                Arguments.of(\"1234.1a\", 1234, 4),\n+                Arguments.of(\"1234.\", 1234, 4))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Test data input for when no grouping is true\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> noGroupingParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"12,34\", 12d, 2),\n+                Arguments.of(\"1234,\", 1234d, 4),\n+                Arguments.of(\"123,456.789\", 123d, 3))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Mappers for respective data providers to adjust values accordingly\n+    \/\/ Localized percent prefix\/suffix is added, with appropriate expected values\n+    \/\/ adjusted. Expected parsed number should be divided by 100.\n+    private static Stream<Arguments> percentValidPartialParseStrings() {\n+        return validPartialParseStrings().map(args ->\n+                Arguments.of(pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                        (double) args.get()[1] \/ 100, (int) args.get()[2] + pFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> percentValidFullParseStrings() {\n+        return validFullParseStrings().map(args -> Arguments.of(\n+                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                (double) args.get()[1] \/ 100)\n+        );\n+    }\n+\n+    \/\/ Mappers for respective data providers to adjust values accordingly\n+    \/\/ Localized percent prefix\/suffix is added, with appropriate expected values\n+    \/\/ adjusted. Separators replaced for monetary versions.\n+    private static Stream<Arguments> currencyValidPartialParseStrings() {\n+        return validPartialParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1], (int) args.get()[2] + cFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> currencyValidFullParseStrings() {\n+        return validFullParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1])\n+        );\n+    }\n+\n+    \/\/ Compact Pattern Data Provider provides test input for both DecimalFormat patterns\n+    \/\/ and the compact patterns. As there is no method to retrieve compact patterns,\n+    \/\/ thus test only against US English locale, and use a hard coded K - 1000\n+    private static Stream<Arguments> compactValidPartialParseStrings() {\n+        return Stream.concat(validPartialParseStrings().map(args -> Arguments.of(args.get()[0],\n+                args.get()[1], args.get()[2])), validPartialParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\",\n+                args.get()[1], args.get()[2]))\n+        );\n+    }\n+\n+    private static Stream<Arguments> compactValidFullParseStrings() {\n+        return Stream.concat(validFullParseStrings().map(args -> Arguments.of(args.get()[0],\n+                args.get()[1])), validFullParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\",\n+                (double)args.get()[1] * 1000.0))\n+        );\n+    }\n+\n+    \/\/ Replace the grouping and decimal separators with localized variants\n+    \/\/ Used during localization of data\n+    private static String localizeText(String text) {\n+        \/\/ As this is a single pass conversion, this is safe for multiple replacement,\n+        \/\/ even if a ',' could be a decimal separator for a locale.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < text.length(); i++) {\n+            char c = text.charAt(i);\n+            if (c == ',') {\n+                sb.append(dfs.getGroupingSeparator());\n+            } else if (c == '.') {\n+                sb.append(dfs.getDecimalSeparator());\n+            } else if (c == '0') {\n+                sb.append(dfs.getZeroDigit());\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientParseTest.java","additions":417,"deletions":0,"binary":false,"changes":417,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Unit test for the isStrict() and setStrict() parsing related methods\n+ * @run junit StrictMethodsTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class StrictMethodsTest {\n+\n+    \/\/ Check that DecimalFormat implements isStrict()\/setStrict()\n+    \/\/ Ensure that the default value is false, and can be set to true via API\n+    @Test\n+    public void decimalFormatTest() {\n+        DecimalFormat dFmt = (DecimalFormat) NumberFormat.getInstance();\n+        assertFalse(dFmt.isStrict());\n+        dFmt.setStrict(true);\n+        assertTrue(dFmt.isStrict());\n+    }\n+\n+    \/\/ Check that CompactNumberFormat implements isStrict()\/setStrict()\n+    \/\/ Ensure that the default value is false, and can be set to true via API\n+    @Test\n+    public void compactFormatTest() {\n+        CompactNumberFormat cFmt = (CompactNumberFormat) NumberFormat.getCompactNumberInstance();\n+        assertFalse(cFmt.isStrict());\n+        cFmt.setStrict(true);\n+        assertTrue(cFmt.isStrict());\n+    }\n+\n+    \/\/ Check that NumberFormat throws exception for isStrict()\/setStrict()\n+    \/\/ when subclass does not implement said methods\n+    @Test\n+    public void numberFormatTest() {\n+        FooFormat fmt = new FooFormat();\n+        assertThrows(UnsupportedOperationException.class, fmt::isStrict);\n+        assertThrows(UnsupportedOperationException.class, () -> fmt.setStrict(false));\n+    }\n+\n+    \/\/ Dummy NumberFormat class to check that isStrict() and setStrict()\n+    \/\/ are not implemented by default\n+    private static class FooFormat extends NumberFormat {\n+\n+        \/\/ Provide overrides for abstract methods\n+        @Override\n+        public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Number parse(String source, ParsePosition parsePosition) {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictMethodsTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,525 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Test suite for NumberFormat parsing with strict leniency\n+ * @run junit\/othervm -Duser.language=en -Duser.country=US StrictParseTest\n+ * @run junit\/othervm -Duser.language=ja -Duser.country=JP StrictParseTest\n+ * @run junit\/othervm -Duser.language=zh -Duser.country=CN StrictParseTest\n+ * @run junit\/othervm -Duser.language=tr -Duser.country=TR StrictParseTest\n+ * @run junit\/othervm -Duser.language=de -Duser.country=DE StrictParseTest\n+ * @run junit\/othervm -Duser.language=fr -Duser.country=FR StrictParseTest\n+ * @run junit\/othervm -Duser.language=ar -Duser.country=AR StrictParseTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/\/ Tests strict parsing, this is done by testing the NumberFormat factory instances\n+\/\/ against a number of locales with different formatting conventions. The locales\n+\/\/ used all use a grouping size of 3.\n+public class StrictParseTest {\n+\n+    \/\/ Used to retrieve the locale's expected symbols\n+    private static final DecimalFormatSymbols dfs =\n+            new DecimalFormatSymbols(Locale.getDefault());\n+    \/\/ We re-use these formats for the respective factory tests\n+    private static final DecimalFormat dFmt =\n+            (DecimalFormat) NumberFormat.getNumberInstance(Locale.getDefault());\n+    private static final DecimalFormat cFmt =\n+            (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.getDefault());\n+    private static final DecimalFormat pFmt =\n+            (DecimalFormat) NumberFormat.getPercentInstance(Locale.getDefault());\n+    private static final CompactNumberFormat cmpctFmt =\n+            (CompactNumberFormat) NumberFormat.getCompactNumberInstance(Locale.getDefault(),\n+                    NumberFormat.Style.SHORT);\n+\n+\n+    \/\/ All NumberFormats should parse strictly\n+    static {\n+        dFmt.setStrict(true);\n+        pFmt.setStrict(true);\n+        cFmt.setStrict(true);\n+        cmpctFmt.setStrict(true);\n+        \/\/ To effectively test strict compactNumberFormat parsing\n+        cmpctFmt.setParseIntegerOnly(false);\n+        cmpctFmt.setGroupingUsed(true);\n+        cmpctFmt.setGroupingSize(3);\n+    }\n+\n+    \/\/ ---- NumberFormat tests ----\n+\n+    \/\/ Guarantee some edge case test input\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void uniqueCaseNumberFormatTest() {\n+        \/\/ Format with grouping size = 3, prefix = a, suffix = b\n+        DecimalFormat nonLocalizedDFmt = new DecimalFormat(\"a#,#00.00b\");\n+        nonLocalizedDFmt.setStrict(true);\n+        \/\/ Text after suffix\n+        failParse(nonLocalizedDFmt, \"a12bfoo\", 3);\n+        failParse(nonLocalizedDFmt, \"a123,456.00bc\", 11);\n+        \/\/ Text after prefix\n+        failParse(nonLocalizedDFmt, \"ac123\", 0);\n+        \/\/ Missing suffix\n+        failParse(nonLocalizedDFmt, \"a123\", 4);\n+        \/\/ Prefix contains a decimal separator\n+        failParse(nonLocalizedDFmt, \".a123\", 0);\n+        \/\/ Test non grouping size of 3\n+        nonLocalizedDFmt.setGroupingSize(1);\n+        successParse(nonLocalizedDFmt, \"a1,2,3,4b\");\n+        failParse(nonLocalizedDFmt, \"a1,2,3,45,6b\", 8);\n+        nonLocalizedDFmt.setGroupingSize(5);\n+        successParse(nonLocalizedDFmt, \"a12345,67890b\");\n+        successParse(nonLocalizedDFmt, \"a1234,67890b\");\n+        failParse(nonLocalizedDFmt, \"a123456,7890b\", 6);\n+\n+    }\n+\n+    \/\/ All input Strings should fail\n+    @ParameterizedTest\n+    @MethodSource(\"badParseStrings\")\n+    public void numFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(dFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"validParseStrings\")\n+    public void numFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse));\n+    }\n+\n+    \/\/ All input Strings should fail\n+    @ParameterizedTest\n+    @MethodSource(\"negativeBadParseStrings\")\n+    public void negNumFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(dFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"negativeValidParseStrings\")\n+    public void negNumFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse));\n+    }\n+\n+    \/\/ Exception should be thrown if grouping separator occurs anywhere\n+    \/\/ Don't pass badParseStrings as a data source, since they may fail for other reasons\n+    @ParameterizedTest\n+    @MethodSource({\"validParseStrings\", \"noGroupingParseStrings\"})\n+    public void numFmtStrictGroupingNotUsed(String toParse) {\n+        \/\/ When grouping is not used, if a grouping separator is found,\n+        \/\/ a failure should occur\n+        dFmt.setGroupingUsed(false);\n+        int failIndex = toParse.indexOf(\n+                dFmt.getDecimalFormatSymbols().getGroupingSeparator());\n+        if (failIndex > -1) {\n+            failParse(dFmt, toParse, failIndex);\n+        } else {\n+            successParse(dFmt, toParse);\n+        }\n+        dFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ Exception should be thrown if decimal separator occurs anywhere\n+    \/\/ Don't pass badParseStrings for same reason as previous method.\n+    @ParameterizedTest\n+    @MethodSource({\"validParseStrings\", \"integerOnlyParseStrings\"})\n+    public void numFmtStrictIntegerOnlyUsed(String toParse) {\n+        \/\/ When integer only is true, if a decimal separator is found,\n+        \/\/ a failure should occur\n+        dFmt.setParseIntegerOnly(true);\n+        int failIndex = toParse.indexOf(dfs.getDecimalSeparator());\n+        if (failIndex > -1) {\n+            failParse(dFmt, toParse, failIndex);\n+        } else {\n+            successParse(dFmt, toParse);\n+        }\n+        dFmt.setParseIntegerOnly(false);\n+    }\n+\n+    \/\/ ---- CurrencyFormat tests ----\n+    @ParameterizedTest\n+    @MethodSource(\"currencyBadParseStrings\")\n+    public void currFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(cFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidParseStrings\")\n+    public void currFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cFmt, toParse));\n+    }\n+\n+    \/\/ ---- PercentFormat tests ----\n+    @ParameterizedTest\n+    @MethodSource(\"percentBadParseStrings\")\n+    public void percentFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(pFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidParseStrings\")\n+    public void percentFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(pFmt, toParse));\n+    }\n+\n+    \/\/ ---- CompactNumberFormat tests ----\n+    \/\/ Can match to both the decimalFormat patterns and the compact patterns\n+    \/\/ Thus we test leniency for both. Unlike the other tests, this test\n+    \/\/ is only ran against the US Locale and tests against data built with the\n+    \/\/ thousands format (K).\n+    @ParameterizedTest\n+    @MethodSource(\"compactBadParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(cmpctFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse));\n+    }\n+\n+    \/\/ Checks some odd leniency edge cases between matching of default pattern\n+    \/\/ and compact pattern.\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtEdgeParseTest() {\n+        \/\/ Uses a compact format with unique and non-empty prefix\/suffix for both\n+        \/\/ default and compact patterns\n+        CompactNumberFormat cnf = new CompactNumberFormat(\"a##0.0#b\", DecimalFormatSymbols\n+                .getInstance(Locale.US), new String[]{\"\", \"c0d\"});\n+        cnf.setStrict(true);\n+\n+        \/\/ Existing behavior of failed prefix parsing has errorIndex return\n+        \/\/ the beginning of prefix, even if the error occurred later in the prefix.\n+        \/\/ Prefix empty\n+        failParse(cnf, \"12345d\", 0);\n+        failParse(cnf, \"1b\", 0);\n+        \/\/ Prefix bad\n+        failParse(cnf, \"aa1d\", 0);\n+        failParse(cnf, \"cc1d\", 0);\n+        failParse(cnf, \"aa1b\", 0);\n+        failParse(cnf, \"cc1b\", 0);\n+\n+        \/\/ Suffix error index is always the start of the failed suffix\n+        \/\/ not necessarily where the error occurred in the suffix. This is\n+        \/\/ consistent with the prefix error index behavior.\n+        \/\/ Suffix empty\n+        failParse(cnf, \"a1\", 2);\n+        failParse(cnf, \"c1\", 2);\n+        \/\/ Suffix bad\n+        failParse(cnf, \"a1dd\", 2);\n+        failParse(cnf, \"c1dd\", 2);\n+        failParse(cnf, \"a1bb\", 2);\n+        failParse(cnf, \"c1bb\", 2);\n+    }\n+\n+    \/\/ Ensure that on failure, the original index of the PP remains the same\n+    @Test\n+    public void parsePositionIndexTest() {\n+        failParse(dFmt, localizeText(\"123,456,,789.00\"), 8, 4);\n+    }\n+\n+    \/\/ ---- Helper test methods ----\n+\n+    \/\/ Should parse entire String successfully, and return correctly parsed value.\n+    private double successParse(NumberFormat fmt, String toParse) {\n+        \/\/ For Strings that don't have grouping separators, we test them with\n+        \/\/ grouping off so that they do not fail under the expectation that\n+        \/\/ grouping symbols should occur\n+        if (!toParse.contains(String.valueOf(dfs.getGroupingSeparator())) &&\n+                !toParse.contains(String.valueOf(dfs.getMonetaryGroupingSeparator()))) {\n+            fmt.setGroupingUsed(false);\n+        }\n+        Number parsedValue = assertDoesNotThrow(() -> fmt.parse(toParse));\n+        ParsePosition pp = new ParsePosition(0);\n+        assertDoesNotThrow(() -> fmt.parse(toParse, pp));\n+        assertEquals(-1, pp.getErrorIndex(),\n+                \"ParsePosition ErrorIndex is not in correct location\");\n+        assertEquals(toParse.length(), pp.getIndex(),\n+                \"ParsePosition Index is not in correct location\");\n+        fmt.setGroupingUsed(true);\n+        return parsedValue.doubleValue();\n+    }\n+\n+    \/\/ Method which tests a parsing failure. Either a ParseException is thrown,\n+    \/\/ or null is returned depending on which parse method is invoked. When failing,\n+    \/\/ index should remain the initial index set to the ParsePosition while\n+    \/\/ errorIndex is the index of failure.\n+    private void failParse(NumberFormat fmt, String toParse, int expectedErrorIndex) {\n+        failParse(fmt, toParse, expectedErrorIndex, 0);\n+    }\n+\n+    \/\/ Variant to check non 0 initial parse index\n+    private void failParse(NumberFormat fmt, String toParse,\n+                           int expectedErrorIndex, int initialParseIndex) {\n+        ParsePosition pp = new ParsePosition(initialParseIndex);\n+        assertThrows(ParseException.class, () -> fmt.parse(toParse));\n+        assertNull(fmt.parse(toParse, pp));\n+        assertEquals(expectedErrorIndex, pp.getErrorIndex());\n+        assertEquals(initialParseIndex, pp.getIndex());\n+    }\n+\n+    \/\/ ---- Data Providers ----\n+    \/\/ These data providers use US locale grouping and decimal separators\n+    \/\/ for readability, however, the data is tested against multiple locales\n+    \/\/ and is converted appropriately at runtime.\n+\n+    \/\/ Strings that should fail when parsed with strict leniency.\n+    \/\/ Given as Arguments<String, expectedErrorIndex>\n+    private static Stream<Arguments> badParseStrings() {\n+        return Stream.of(\n+                \/\/ Grouping symbol focus\n+                \/\/ Grouping symbol right before decimal\n+                Arguments.of(\"1,.\", 2),\n+                Arguments.of(\"1,.1\", 2),\n+                \/\/ Does not end with proper grouping size\n+                Arguments.of(\"1,1\", 2),\n+                Arguments.of(\"1,11\", 3),\n+                Arguments.of(\"1,1111\", 5),\n+                Arguments.of(\"11,111,11\", 8),\n+                \/\/ Does not end with proper grouping size (with decimal)\n+                Arguments.of(\"1,1.\", 3),\n+                Arguments.of(\"1,11.\", 4),\n+                Arguments.of(\"1,1111.\", 5),\n+                Arguments.of(\"11,111,11.\", 9),\n+                \/\/ Ends on a grouping symbol\n+                \/\/ Suffix matches correctly, so failure is on the \",\"\n+                Arguments.of(\"11,111,\", 6),\n+                Arguments.of(\"11,\", 2),\n+                Arguments.of(\"11,,\", 3),\n+                \/\/ Ends with grouping symbol. Failure should occur on grouping,\n+                \/\/ even if non recognized char after\n+                Arguments.of(\"11,a\", 2),\n+                \/\/ Improper grouping size (with decimal and digits after)\n+                Arguments.of(\"1,1.1\", 3),\n+                Arguments.of(\"1,11.1\", 4),\n+                Arguments.of(\"1,1111.1\", 5),\n+                Arguments.of(\"11,111,11.1\", 9),\n+                \/\/ Subsequent grouping symbols\n+                Arguments.of(\"1,,1\", 2),\n+                Arguments.of(\"1,1,,1\", 3),\n+                Arguments.of(\"1,,1,1\", 2),\n+                \/\/ Invalid grouping sizes\n+                Arguments.of(\"1,11,111\", 4),\n+                Arguments.of(\"11,11,111\", 5),\n+                Arguments.of(\"111,11,11\", 6),\n+                \/\/ First group is too large\n+                Arguments.of(\"1111,11,111\", 3),\n+                Arguments.of(\"00000,11,111\", 3),\n+                Arguments.of(\"111,1111111111\", 7),\n+                Arguments.of(\"111,11\", 5),\n+                Arguments.of(\"111,1111111111.\", 7),\n+                Arguments.of(\"111,11.\", 6),\n+                Arguments.of(\"111,1111111111.\", 7),\n+                \/\/ Starts with grouping symbol\n+                Arguments.of(\",111,,1,1\", 0),\n+                Arguments.of(\",1\", 0),\n+                Arguments.of(\",,1\", 0),\n+                \/\/ Leading Zeros (not digits)\n+                Arguments.of(\"000,1,1\", 5),\n+                Arguments.of(\"000,111,11,,1\", 10),\n+                Arguments.of(\"0,000,1,,1,1\", 7),\n+                \/\/ Bad suffix\n+                Arguments.of(\"1a\", 1),\n+                \/\/ Bad chars in numerical portion\n+                Arguments.of(\"123a4\", 3),\n+                Arguments.of(\"123.4a5\", 5),\n+                \/\/ Variety of edge cases\n+                Arguments.of(\"123,456.77a\", 10),\n+                Arguments.of(\"1,234a\", 5),\n+                Arguments.of(\"1,.a\", 2),\n+                Arguments.of(\"1.a\", 2),\n+                Arguments.of(\".22a\", 3),\n+                Arguments.of(\".1a1\", 2),\n+                Arguments.of(\"1,234,a\", 5))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n+    }\n+\n+    \/\/ Strings that should parse fully. (Both in lenient and strict)\n+    \/\/ Given as Arguments<String, expectedParsedNumber>\n+    private static Stream<Arguments> validParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"1,234.00\", 1234d),\n+                Arguments.of(\"1,234.0\", 1234d),\n+                Arguments.of(\"1,234.\", 1234d),\n+                Arguments.of(\"1\", 1d),\n+                Arguments.of(\"10\", 10d),\n+                Arguments.of(\"100\", 100d),\n+                Arguments.of(\"1000\", 1000d),\n+                Arguments.of(\"1,000\", 1000d),\n+                Arguments.of(\"10,000\", 10000d),\n+                Arguments.of(\"10000\", 10000d),\n+                Arguments.of(\"100,000\", 100000d),\n+                Arguments.of(\"1,000,000\", 1000000d),\n+                Arguments.of(\"10,000,000\", 10000000d))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n+    }\n+\n+    \/\/ Separate test data set for integer only. Can not use \"badParseStrings\", as\n+    \/\/ there is test data where the failure may occur from some other issue,\n+    \/\/ not related to grouping\n+    private static Stream<Arguments> integerOnlyParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"234.a\"),\n+                Arguments.of(\"234.a1\"),\n+                Arguments.of(\"234.1\"),\n+                Arguments.of(\"234.1a\"),\n+                Arguments.of(\"234.\"))\n+                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0]))));\n+    }\n+\n+    \/\/ Separate test data set for no grouping. Can not use \"badParseStrings\", as\n+    \/\/ there is test data where the failure may occur from some other issue,\n+    \/\/ not related to grouping\n+    private static Stream<Arguments> noGroupingParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"12,34.a\"),\n+                Arguments.of(\"123,.a1\"),\n+                Arguments.of(\",1234\"),\n+                Arguments.of(\"123,\"))\n+                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0]))));\n+    }\n+\n+    \/\/ Negative variant of a numerical format\n+    private static Stream<Arguments> negativeBadParseStrings() {\n+        return badParseStrings().map(args -> Arguments.of(\n+                dFmt.getNegativePrefix() + args.get()[0] + dFmt.getNegativeSuffix(),\n+                (int)args.get()[1] + dFmt.getNegativePrefix().length())\n+        );\n+    }\n+\n+    \/\/ Negative variant of a numerical format\n+    private static Stream<Arguments> negativeValidParseStrings() {\n+        return validParseStrings().map(args -> Arguments.of(\n+                dFmt.getNegativePrefix() + args.get()[0] + dFmt.getNegativeSuffix(),\n+                (double) args.get()[1] * -1)\n+        );\n+    }\n+\n+    \/\/ Same as original with a percent prefix\/suffix.\n+    \/\/ Additionally, increment expected error index if a prefix is added\n+    private static Stream<Arguments> percentBadParseStrings() {\n+        return badParseStrings().map(args -> Arguments.of(\n+                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                        (int)args.get()[1] + pFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    \/\/ Expected parsed value should be \/ 100 as it is a percent format.\n+    private static Stream<Arguments> percentValidParseStrings() {\n+        return validParseStrings().map(args -> Arguments.of(\n+                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                (double)args.get()[1] \/ 100.0)\n+        );\n+    }\n+\n+    \/\/ Same as original with a currency prefix\/suffix, but replace separators\n+    \/\/ with monetary variants. Additionally, increment expected error index\n+    \/\/ if a prefix is added\n+    private static Stream<Arguments> currencyBadParseStrings() {\n+        return badParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                (int)args.get()[1] + cFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> currencyValidParseStrings() {\n+        return validParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1])\n+        );\n+    }\n+\n+    \/\/ Compact Pattern Data Provider provides test input for both DecimalFormat patterns\n+    \/\/ and the compact patterns. As there is no method to retrieve compact patterns,\n+    \/\/ thus test only against US English locale, and use a hard coded K - 1000\n+    private static Stream<Arguments> compactBadParseStrings() {\n+        return Stream.concat(\n+                badParseStrings().map(args -> Arguments.of(args.get()[0], args.get()[1])),\n+                badParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\", args.get()[1]))\n+        );\n+    }\n+\n+    private static Stream<Arguments> compactValidParseStrings() {\n+        return Stream.concat(\n+                validParseStrings().map(args -> Arguments.of(\n+                        args.get()[0], args.get()[1])),\n+                validParseStrings().map(args -> Arguments.of(\n+                        args.get()[0] + \"K\", (double) args.get()[1] * 1000))\n+        );\n+    }\n+\n+    \/\/ Replace the grouping and decimal separators with localized variants\n+    \/\/ Used during localization of data\n+    private static String localizeText(String text) {\n+        \/\/ As this is a single pass conversion, this is safe for multiple replacement,\n+        \/\/ even if a ',' could be a decimal separator for a locale.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < text.length(); i++) {\n+            char c = text.charAt(i);\n+            if (c == ',') {\n+                sb.append(dfs.getGroupingSeparator());\n+            } else if (c == '.') {\n+                sb.append(dfs.getDecimalSeparator());\n+            } else if (c == '0') {\n+                sb.append(dfs.getZeroDigit());\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictParseTest.java","additions":525,"deletions":0,"binary":false,"changes":525,"status":"added"}]}