{"files":[{"patch":"@@ -585,1 +585,7 @@\n-    public void setLenient(boolean lenient) {\n+    public boolean isStrict() {\n+        throw new UnsupportedOperationException(\n+                \"ChoiceFormat does not utilize leniency when parsing\");\n+    }\n+\n+    @Override\n+    public void setStrict(boolean strict) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1583,1 +1583,1 @@\n-     * @see #setLenient(boolean)\n+     * @see #setStrict(boolean)\n@@ -1742,1 +1742,1 @@\n-            if (parseStrict) {\n+            if (isStrict()) {\n@@ -1929,1 +1929,1 @@\n-            return parseStrict ? matchAffix(text, position, suffix, defaultSuffix, matchedSuffix)\n+            return isStrict() ? matchAffix(text, position, suffix, defaultSuffix, matchedSuffix)\n@@ -1981,1 +1981,1 @@\n-                if (parseStrict) {\n+                if (isStrict()) {\n@@ -1994,1 +1994,1 @@\n-                if (parseStrict) {\n+                if (isStrict()) {\n@@ -2010,1 +2010,1 @@\n-            if (parseStrict ? endsWithPosSuffix : containsPosSuffix) {\n+            if (isStrict() ? endsWithPosSuffix : containsPosSuffix) {\n@@ -2019,1 +2019,1 @@\n-            if (parseStrict ? endsWithNegSuffix : containsNegSuffix) {\n+            if (isStrict() ? endsWithNegSuffix : containsNegSuffix) {\n@@ -2137,1 +2137,1 @@\n-        decimalFormat.setLenient(!parseStrict);\n+        decimalFormat.setStrict(isStrict());\n@@ -2378,3 +2378,3 @@\n-    public void setLenient(boolean lenient) {\n-        decimalFormat.setLenient(lenient);\n-        super.setLenient(lenient);\n+    public void setStrict(boolean strict) {\n+        decimalFormat.setStrict(strict);\n+        super.setStrict(strict);\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+import sun.util.locale.provider.ResourceBundleBasedAdapter;\n+\n@@ -53,2 +56,0 @@\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-import sun.util.locale.provider.ResourceBundleBasedAdapter;\n@@ -2223,1 +2224,1 @@\n-     * @see #setLenient(boolean)\n+     * @see #setStrict(boolean)\n@@ -2421,1 +2422,1 @@\n-                gotPositive = parseStrict ? endsWithPosSuffix : containsPosSuffix;\n+                gotPositive = isStrict() ? endsWithPosSuffix : containsPosSuffix;\n@@ -2428,1 +2429,1 @@\n-                gotNegative = parseStrict ? endsWithNegSuffix : containsNegSuffix;\n+                gotNegative = isStrict() ? endsWithNegSuffix : containsNegSuffix;\n@@ -2534,1 +2535,1 @@\n-                if (parseStrict && isGroupingUsed() && position == startPos + groupingSize\n+                if (isStrict() && isGroupingUsed() && position == startPos + groupingSize\n@@ -2570,1 +2571,1 @@\n-                    if (parseStrict && isGroupingViolation(position, prevSeparatorIndex)) {\n+                    if (isStrict() && isGroupingViolation(position, prevSeparatorIndex)) {\n@@ -2581,1 +2582,1 @@\n-                    if (parseStrict) {\n+                    if (isStrict()) {\n@@ -2630,1 +2631,1 @@\n-            if (parseStrict) {\n+            if (isStrict()) {\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+import sun.util.locale.provider.LocaleServiceProviderPool;\n+\n@@ -55,2 +58,0 @@\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-import sun.util.locale.provider.LocaleServiceProviderPool;\n@@ -61,2 +62,5 @@\n- * numbers. {@code NumberFormat} also provides methods for determining\n- * which locales have number formats, and what their names are.\n+ * numbers in a localized manner. This enables code that can be completely\n+ * independent of the locale conventions for decimal points, thousands-separators,\n+ * whether the number format is even decimal, or even the particular decimal\n+ * digits used. For example, this class could be used to format a number\n+ * according to French numerical conventions.\n@@ -64,5 +68,16 @@\n- * <p>\n- * {@code NumberFormat} helps you to format and parse numbers for any locale.\n- * Your code can be completely independent of the locale conventions for\n- * decimal points, thousands-separators, or even the particular decimal\n- * digits used, or whether the number format is even decimal.\n+ * <h2>Getting a Format<\/h2>\n+ * To format a number for the default Locale, use one of the static factory class methods.\n+ * The following examples all format the {@code Number} \"2000.50\" with the {@link\n+ * java.util.Locale#US US} locale as the default.\n+ * <ul>\n+ * <li> Use {@link #getInstance()} or {@link #getNumberInstance()} to get\n+ * a number format. For example, {@code \"2,000.5\"}.\n+ * <li> Use {@link #getIntegerInstance()} to get an integer number format.\n+ * For example, {@code \"2,000\"}.\n+ * <li> Use {@link #getCurrencyInstance} to get a currency number format.\n+ * For example, {@code \"$2,000.50\"}.\n+ * <li> Use {@link #getCompactNumberInstance} to get a compact number format\n+ * to format a number in shorter form. For example, {@code \"2K\"}.\n+ * <li> Use {@link #getPercentInstance} to get a format for displaying percentages.\n+ * For example, {@code \"200,050%\"}.\n+ * <\/ul>\n@@ -70,27 +85,4 @@\n- * <p>\n- * To format a number for the current Locale, use one of the factory\n- * class methods:\n- * <blockquote>\n- * {@snippet lang=java :\n- * myString = NumberFormat.getInstance().format(myNumber);\n- * }\n- * <\/blockquote>\n- * If you are formatting multiple numbers, it is\n- * more efficient to get the format and use it multiple times so that\n- * the system doesn't have to fetch the information about the local\n- * language and country conventions multiple times.\n- * <blockquote>\n- * {@snippet lang=java :\n- * NumberFormat nf = NumberFormat.getInstance();\n- * for (var myNumber : numbers) {\n- *     output.println(nf.format(myNumber) + \"; \");\n- * }\n- * }\n- * <\/blockquote>\n- * To format a number for a different Locale, specify it in the\n- * call to {@code getInstance}.\n- * <blockquote>\n- * {@snippet lang=java :\n- * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);\n- * }\n- * <\/blockquote>\n+ * Alternatively, if a number format for a different locale is required, use\n+ * one of the factory class method variants that take {@code locale} as a parameter,\n+ * for example, {@link #getIntegerInstance(Locale)}. Use {@link #getAvailableLocales()}\n+ * to determine which locales support number formats,\n@@ -98,1 +90,2 @@\n- * <p>If the locale contains \"nu\" (numbers) and\/or \"rg\" (region override)\n+ * <h3>Locale Extensions<\/h3>\n+ * <p>If the locale used for formatting contains \"nu\" (numbers) and\/or \"rg\" (region override)\n@@ -104,26 +97,17 @@\n- * <p>You can also use a {@code NumberFormat} to parse numbers:\n- * <blockquote>\n- * {@snippet lang=java :\n- * myNumber = nf.parse(myString);\n- * }\n- * <\/blockquote>\n- * Use {@code getInstance} or {@code getNumberInstance} to get the\n- * normal number format. Use {@code getIntegerInstance} to get an\n- * integer number format. Use {@code getCurrencyInstance} to get the\n- * currency number format. Use {@code getCompactNumberInstance} to get the\n- * compact number format to format a number in shorter form. For example,\n- * {@code 2000} can be formatted as {@code \"2K\"} in\n- * {@link java.util.Locale#US US locale}. Use {@code getPercentInstance}\n- * to get a format for displaying percentages. With this format, a fraction\n- * like 0.53 is displayed as 53%.\n- *\n- * <p>\n- * You can also control the display of numbers with such methods as\n- * {@code setMinimumFractionDigits}.\n- * If you want even more control over the format or parsing,\n- * or want to give your users more control,\n- * you can try casting the {@code NumberFormat} you get from the factory methods\n- * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on\n- * the factory method used. This will work for the vast majority of locales;\n- * just remember to put it in a {@code try} block in case you encounter\n- * an unusual one.\n+ * <h2>Customizing Formatting and Parsing<\/h2>\n+ * {@code NumberFormat} provides formatting through the {@code format},\n+ * and parsing through the {@code parse} methods. For further customization\n+ * of formatting and parsing behavior, use any of the following instance methods.\n+ * <ul>\n+ * <li> {@link #setParseIntegerOnly(boolean)}; when true, will only return the\n+ * integer portion of the number parsed from the String.\n+ * <li> {@link #setStrict(boolean)}; when true, parsing will be done strictly.\n+ * See the {@link ##leniency Leniency Section}\n+ * <li> {@link #setMinimumFractionDigits}; Use to adjust the expected digits when\n+ * formatting. Use any of the other minimum\/maximum or fraction\/integer setter methods\n+ * in the same manner.\n+ * <li> {@link #setGroupingUsed}; when true, formatted numbers will be displayed\n+ * with grouping separators. Additionally, when false, parsing will not expect\n+ * grouping separators in the parsed String, and may exit early or fail depending\n+ * on leniency.\n+ * <\/ul>\n@@ -132,19 +116,7 @@\n- * NumberFormat and DecimalFormat are designed such that some controls\n- * work for formatting and others work for parsing.  The following is\n- * the detailed description for each these control methods,\n- * <p>\n- * setParseIntegerOnly : only affects parsing, e.g.\n- * if true,  \"3456.78\" &rarr; 3456 (and leaves the parse position just after index 6)\n- * if false, \"3456.78\" &rarr; 3456.78 (and leaves the parse position just after index 8)\n- * This is independent of formatting.  If you want to not show a decimal point\n- * where there might be no digits after the decimal point, use\n- * setDecimalSeparatorAlwaysShown.\n- * <p>\n- * setDecimalSeparatorAlwaysShown : only affects formatting, and only where\n- * there might be no digits after the decimal point, such as with a pattern\n- * like \"#,##0.##\", e.g.,\n- * if true,  3456.00 &rarr; \"3,456.\"\n- * if false, 3456.00 &rarr; \"3456\"\n- * This is independent of parsing.  If you want parsing to stop at the decimal\n- * point, use setParseIntegerOnly.\n- *\n+ * To provide more control over the format or parsing, cast the {@code\n+ * NumberFormat} you get from the factory methods to a {@code DecimalFormat} or\n+ * {@code CompactNumberFormat} depending on the factory method used. For example,\n+ * cast to {@code DecimalFormat} to call {@link DecimalFormat#setGroupingSize(int)}\n+ * to change the desired digits between grouping separators.\n+ * While this will work for the vast majority of locales; a {@code\n+ * try} block should be used in case a non-supported locale is encountered.\n@@ -178,1 +150,12 @@\n- * <h2><a id=\"synchronization\">Synchronization<\/a><\/h2>\n+ * <h2><a id=\"leniency\">Leniency<\/a><\/h2>\n+ * {@code NumberFormat} can parse both strictly and leniently. By default, parsing\n+ * is lenient, and leniency can be adjusted using {@link #setStrict(boolean)}. Lenient\n+ * parsing should be used when attempting to parse a number out of a String\n+ * that contains non-expected values. For example, parsing the number {@code 1000}\n+ * out of the String \"1,000 people\". Strict parsing should be used when\n+ * attempting to ensure a String adheres exactly to the locale's conventions, and\n+ * can thus serve to validate input. For example, successfully parsing the number\n+ * {@code 1000.55} out of the String \"1.000,55\" confirms the String\n+ * adhered to the {@link Locale#GERMAN German} numerical conventions. See the\n+ * {@link #parse(String, ParsePosition)} method for further details on behavioral\n+ * differences between leniency modes.\n@@ -180,2 +163,2 @@\n- * <p>\n- * Number formats are generally not synchronized.\n+ * <h3><a id=\"synchronization\">Synchronization<\/a><\/h3>\n+ * {@code NumberFormat} is not synchronized.\n@@ -186,1 +169,3 @@\n- * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},\n+ * @implSpec\n+ * <h4>Null Parameter Handling<\/h4>\n+ * The {@link #format(double, StringBuffer, FieldPosition)},\n@@ -193,1 +178,1 @@\n- * <p>\n+ * <h4>Default RoundingMode<\/h4>\n@@ -204,0 +189,7 @@\n+ * <h4>Unsupported Methods in Subclasses<\/h4>\n+ * A subclass could override the methods that affect formatting and parsing and\n+ * throw an {@code UnsupportedOperationException} if they are not utilized in their\n+ * own implementations. For example, {@code ChoiceFormat} does not utilize leniency,\n+ * and throws an {@code UnsupportedOperationException} for {@link #setStrict(boolean)}\n+ * and {@link #isStrict()}.\n+ *\n@@ -409,0 +401,15 @@\n+     * When <b>lenient<\/b>, if parsing succeeds, then the index of {@code pos} is updated\n+     * to the index after the last character used (parsing does not necessarily\n+     * use all characters up to the end of the string), and the parsed\n+     * number is returned. The updated {@code pos} can be used to\n+     * indicate the starting point for the next call to this method.\n+     * If an error occurs, then the index of {@code pos} is not\n+     * changed, the error index of {@code pos} is set to the index of\n+     * the character where the error occurred, and {@code null} is returned.\n+     * When lenient, parsing will fail if the prefix and\/or suffix are non-empty,\n+     * and cannot be found due to parsing ending early, or the first character\n+     * after the prefix cannot be parsed.\n+     * <p>\n+     * When <b>strict<\/b>, this method will return {@code null} if not every\n+     * character is parsed, indicating a failure.\n+     * <p>\n@@ -416,1 +423,1 @@\n-     * @see #setLenient(boolean)\n+     * @see #isStrict()\n@@ -428,1 +435,1 @@\n-     * on number parsing.\n+     * on number parsing and the behavioral differences when lenient or strict.\n@@ -433,1 +440,0 @@\n-     * @see #setLenient(boolean)\n@@ -471,0 +477,12 @@\n+    \/**\n+     * {@return {@code true} if this format will parse numbers strictly;\n+     * {@code false} otherwise}\n+     *\n+     * @see ##leniency Leniency Section\n+     * @see #setStrict(boolean)\n+     * @since 23\n+     *\/\n+    public boolean isStrict() {\n+        return parseStrict;\n+    }\n+\n@@ -475,7 +493,4 @@\n-     * @implSpec A subclass could override this method and throw a {@code\n-     * UnsupportedOperationException} if leniency is not utilized when parsing,\n-     * or there is only one leniency mode.\n-     * @param lenient {@code true} if parsing should be done leniently;\n-     *                {@code false} otherwise\n-     * @throws    UnsupportedOperationException if the implementation of this\n-     *            method does not support this operation\n+     * @param strict {@code true} if parsing should be done strictly;\n+     *               {@code false} otherwise\n+     * @see ##leniency Leniency Section\n+     * @see #isStrict()\n@@ -484,2 +499,3 @@\n-    public void setLenient(boolean lenient) {\n-        this.parseStrict = !lenient;\n+    public void setStrict(boolean strict) {\n+        \/\/ setStrict method over setLenient, as the default behavior is lenient\n+        parseStrict = strict;\n@@ -1209,3 +1225,1 @@\n-     * True if this format will parse numbers with strict leniency.\n-     * Protected visibility, so that subclasses can utilize this value in their own\n-     * implementations without needing a isLenient() method.\n+     * True if this {@code NumberFormat} will parse numbers with strict leniency.\n@@ -1213,0 +1227,1 @@\n+     * @serial\n@@ -1214,1 +1229,2 @@\n-     * @see #setLenient(boolean)\n+     * @see #setStrict(boolean)\n+     * @see #isStrict()\n@@ -1216,1 +1232,1 @@\n-    protected boolean parseStrict = false;\n+    private boolean parseStrict = false;\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":120,"deletions":104,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -79,4 +79,4 @@\n-        dFmt.setLenient(false);\n-        pFmt.setLenient(false);\n-        cFmt.setLenient(false);\n-        cmpctFmt.setLenient(false);\n+        dFmt.setStrict(true);\n+        pFmt.setStrict(true);\n+        cFmt.setStrict(true);\n+        cmpctFmt.setStrict(true);\n@@ -97,1 +97,1 @@\n-        nonLocalizedDFmt.setLenient(false);\n+        nonLocalizedDFmt.setStrict(true);\n@@ -235,1 +235,1 @@\n-        cnf.setLenient(false);\n+        cnf.setStrict(true);\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictParseTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}