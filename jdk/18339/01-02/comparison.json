{"files":[{"patch":"@@ -1501,3 +1501,1 @@\n-     * Parses a compact number from a string to produce a {@code Number}.\n-     * Parsing can be done in either a strict or lenient manner, by default\n-     * it is lenient.\n+     * {@inheritDoc}\n@@ -1505,2 +1503,1 @@\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}. The returned value is the numeric part in the given text multiplied\n+     * The returned value is the numeric part in the given text multiplied\n@@ -1510,11 +1507,1 @@\n-     * When <b>lenient<\/b>, if parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and {@code null} is returned.\n-     * When lenient, parsing will fail if the prefix and\/or suffix are non-empty,\n-     * and cannot be found due to parsing ending early, or the first character\n-     * after the prefix cannot be parsed. A {@code CompactNumberFormat} can match\n+     * A {@code CompactNumberFormat} can match\n@@ -1523,5 +1510,5 @@\n-     * When <b>strict<\/b>, this method will return {@code null} and {@link #parse(String)}\n-     * will throw a {@code ParseException} if not every character is parsed, indicating a failure.\n-     * {@code pos} can be used to obtain the cause of the failure by calling\n-     * {@link ParsePosition#getErrorIndex()}. When strict, a failure will occur,\n-     * if in {@code text},\n+     * Parsing fails when <b>lenient<\/b>, if the prefix and\/or suffix are non-empty\n+     * and cannot be found due to parsing ending early, or the first character\n+     * after the prefix cannot be parsed.\n+     * <p>\n+     * Parsing fails when <b>strict<\/b>, if in {@code text},\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":8,"deletions":21,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2144,2 +2144,1 @@\n-     * Parses text from a string to produce a {@code Number}. Parsing can be done\n-     * in either a strict or lenient manner, by default it is lenient.\n+     * {@inheritDoc}\n@@ -2147,12 +2146,1 @@\n-     * This method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * <p>\n-     * When <b>lenient<\/b>, if parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and {@code null} is returned.\n-     * When lenient, parsing will fail if the prefix and\/or suffix are non-empty,\n+     * Parsing fails when <b>lenient<\/b>, if the prefix and\/or suffix are non-empty\n@@ -2162,5 +2150,1 @@\n-     * When <b>strict<\/b>, this method will return {@code null} and {@link #parse(String)}\n-     * will throw a {@code ParseException} if not every character is parsed, indicating a failure.\n-     * {@code pos} can be used to obtain the cause of the failure by calling\n-     * {@link ParsePosition#getErrorIndex()}. When strict, a failure will occur,\n-     * if in {@code text},\n+     * Parsing fails when <b>strict<\/b>, if in {@code text},\n@@ -2419,1 +2403,1 @@\n-                        text.regionMatches(position, positiveSuffix,0, positiveSuffix.length());\n+                        text.regionMatches(position, positiveSuffix, 0, positiveSuffix.length());\n@@ -2426,1 +2410,1 @@\n-                        text.regionMatches(position, negativeSuffix,0, negativeSuffix.length());\n+                        text.regionMatches(position, negativeSuffix, 0, negativeSuffix.length());\n@@ -2428,1 +2412,1 @@\n-                        containsNegSuffix && text.length() == position  + negativeSuffix.length();\n+                        containsNegSuffix && text.length() == position + negativeSuffix.length();\n@@ -2482,1 +2466,1 @@\n-        if (!isExponent && text.regionMatches(position, symbols.getInfinity(),0,\n+        if (!isExponent && text.regionMatches(position, symbols.getInfinity(), 0,\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-     * Parses text from a string to produce an object.\n+     * Parses text from the given string to produce an object.\n@@ -215,3 +215,2 @@\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n+     * This method attempts to parse text starting at the index given by\n+     * {@code pos}. If parsing succeeds, then the index of {@code pos} is updated\n@@ -224,1 +223,1 @@\n-     * the character where the error occurred, and null is returned.\n+     * the character where the error occurred, and {@code null} is returned.\n@@ -226,1 +225,3 @@\n-     * @param source A {@code String}, part of which should be parsed.\n+     * @apiNote Subclasses may consider implementing leniency when parsing.\n+     *          The definition of leniency should be delegated to the subclass.\n+     * @param source the {@code String} to parse\n@@ -230,2 +231,3 @@\n-     *         error, returns null.\n-     * @throws NullPointerException if {@code source} or {@code pos} is null.\n+     *         error, returns {@code null}.\n+     * @throws NullPointerException if {@code source} or {@code pos} is\n+     *         {@code null}.\n@@ -237,1 +239,0 @@\n-     * The method may not use the entire text of the given string.\n@@ -239,1 +240,4 @@\n-     * @param source A {@code String} whose beginning should be parsed.\n+     * @implNote This implementation is equivalent to calling {@code parseObject(source,\n+     * new ParsePosition(0)} and throwing a {@code ParseException} if parsing fails,\n+     * instead of returning {@code null}.\n+     * @param source A {@code String}, to be parsed from the beginning.\n@@ -241,3 +245,2 @@\n-     * @throws    ParseException if the beginning of the specified string\n-     *            cannot be parsed.\n-     * @throws NullPointerException if {@code source} is null.\n+     * @throws ParseException if parsing fails\n+     * @throws NullPointerException if {@code source} is {@code null}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -189,7 +189,0 @@\n- * <h4>Unsupported Methods in Subclasses<\/h4>\n- * A subclass could override the methods that affect formatting and parsing and\n- * throw an {@code UnsupportedOperationException} if they are not utilized in their\n- * own implementations. For example, {@code ChoiceFormat} does not utilize leniency,\n- * and throws an {@code UnsupportedOperationException} for {@link #setStrict(boolean)}\n- * and {@link #isStrict()}.\n- *\n@@ -280,12 +273,1 @@\n-     * Parses text from a string to produce a {@code Number}.\n-     * <p>\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and null is returned.\n+     * {@inheritDoc}\n@@ -293,2 +275,1 @@\n-     * See the {@link #parse(String, ParsePosition)} method for more information\n-     * on number parsing.\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n@@ -296,1 +277,3 @@\n-     * @param source A {@code String}, part of which should be parsed.\n+     * @implSpec This implementation is equivalent to calling {@code parse(source,\n+     *           pos)}.\n+     * @param source the {@code String} to parse\n@@ -395,5 +378,0 @@\n-     * The method may not use the entire text of the given string. Parsing can\n-     * be done in either a strict or lenient manner, by default it is lenient.\n-     * This method does not throw an exception if parsing fails, and returns\n-     * {@code null} instead. Upon failure, index remains unchanged and {@code parsePosition}\n-     * can be used to retrieve the error index of where the parse failed.\n@@ -401,1 +379,2 @@\n-     * When <b>lenient<\/b>, if parsing succeeds, then the index of {@code pos} is updated\n+     * This method attempts to parse text starting at the index given by\n+     * {@code pos}. If parsing succeeds, then the index of {@code parsePosition} is updated\n@@ -403,12 +382,6 @@\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and {@code null} is returned.\n-     * When lenient, parsing will fail if the prefix and\/or suffix are non-empty,\n-     * and cannot be found due to parsing ending early, or the first character\n-     * after the prefix cannot be parsed.\n-     * <p>\n-     * When <b>strict<\/b>, this method will return {@code null} if not every\n-     * character is parsed, indicating a failure.\n+     * use all characters up to the end of the string), and the parsed number is\n+     * returned. The updated {@code parsePosition} can be used to indicate the starting\n+     * point for the next call to this method. If an error occurs, then the\n+     * index of {@code parsePosition} is not changed, the error index of {@code\n+     * parsePosition} is set to the index of the character where the error\n+     * occurred, and {@code null} is returned.\n@@ -418,0 +391,1 @@\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n@@ -419,4 +393,7 @@\n-     * @param source the String to parse\n-     * @param parsePosition the parse position\n-     * @return the parsed value\n-     * @see java.text.Format#parseObject\n+     * @param source the {@code String} to parse\n+     * @param parsePosition A {@code ParsePosition} object with index and error\n+     *            index information as described above.\n+     * @return A {@code Number} parsed from the string. In case of\n+     *         failure, returns {@code null}.\n+     * @throws NullPointerException if {@code source} or {@code ParsePosition}\n+     *         is {@code null}.\n@@ -431,2 +408,0 @@\n-     * The method may not use the entire text of the given string. Parsing can\n-     * be done in either a strict or lenient manner, by default it is lenient.\n@@ -434,2 +409,3 @@\n-     * See the {@link #parse(String, ParsePosition)} method for more information\n-     * on number parsing and the behavioral differences when lenient or strict.\n+     * This method will return a Long if possible (e.g., within the range [Long.MIN_VALUE,\n+     * Long.MAX_VALUE] and with no decimals), otherwise a Double.\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n@@ -437,1 +413,4 @@\n-     * @param source A {@code String} whose beginning should be parsed.\n+     * @implNote This is equivalent to calling {@code parse(source,\n+     * new ParsePosition(0)} and throwing a {@code ParseException} if parsing fails,\n+     * instead of returning {@code null}.\n+     * @param source A {@code String}, to be parsed from the beginning.\n@@ -439,1 +418,5 @@\n-     * @throws    ParseException if parsing fails\n+     * @throws ParseException if parsing fails\n+     * @throws NullPointerException if {@code source} is {@code null}.\n+     * @see #isStrict()\n+     * @see #isParseIntegerOnly()\n+     * @see #isGroupingUsed()\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":33,"deletions":50,"binary":false,"changes":83,"status":"modified"}]}