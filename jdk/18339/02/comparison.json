{"files":[{"patch":"@@ -583,0 +583,12 @@\n+\n+    @Override\n+    public boolean isStrict() {\n+        throw new UnsupportedOperationException(\n+                \"ChoiceFormat does not utilize leniency when parsing\");\n+    }\n+\n+    @Override\n+    public void setStrict(boolean strict) {\n+        throw new UnsupportedOperationException(\n+                \"ChoiceFormat does not utilize leniency when parsing\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/text\/ChoiceFormat.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1501,1 +1501,1 @@\n-     * Parses a compact number from a string to produce a {@code Number}.\n+     * {@inheritDoc}\n@@ -1503,12 +1503,1 @@\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and {@code null} is returned.\n-     * <p>\n-     * The value is the numeric part in the given text multiplied\n+     * The returned value is the numeric part in the given text multiplied\n@@ -1517,0 +1506,25 @@\n+     * <p>\n+     * A {@code CompactNumberFormat} can match\n+     * the default prefix\/suffix to a compact prefix\/suffix interchangeably.\n+     * <p>\n+     * Parsing fails when <b>lenient<\/b>, if the prefix and\/or suffix are non-empty\n+     * and cannot be found due to parsing ending early, or the first character\n+     * after the prefix cannot be parsed.\n+     * <p>\n+     * Parsing fails when <b>strict<\/b>, if in {@code text},\n+     * <ul>\n+     *   <li> The default or a compact prefix is not found, for example: \"{@code $}\"\n+     *   <li> The default or a compact suffix is not found, for example: \"{@code K}\"\n+     *   <li> {@link #isGroupingUsed()} returns {@code false}, and the grouping\n+     *   symbol is found\n+     *   <li> {@link #isGroupingUsed()} returns {@code true}, and {@link\n+     *   #getGroupingSize()} is not adhered to\n+     *   <li> {@link #isParseIntegerOnly()} returns {@code true}, and the decimal\n+     *   separator is found\n+     *   <li> {@link #isGroupingUsed()} returns {@code true} and {@link\n+     *   #isParseIntegerOnly()} returns {@code false}, and the grouping\n+     *   symbol occurs after the decimal separator\n+     *   <li> Any other characters are found, that are not the expected symbols,\n+     *   and are not digits that occur within the numerical portion\n+     * <\/ul>\n+     * <p>\n@@ -1556,1 +1570,1 @@\n-     *\n+     * @see #setStrict(boolean)\n@@ -1664,0 +1678,7 @@\n+        } else {\n+            \/\/ Neither prefix match, should fail now (strict or lenient), before\n+            \/\/ position is incremented by subparseNumber(). Otherwise, an empty\n+            \/\/ prefix could pass through here, position gets incremented by the\n+            \/\/ numerical portion, and return a faulty errorIndex and index later.\n+            pos.errorIndex = position;\n+            return null;\n@@ -1708,0 +1729,5 @@\n+            if (isStrict()) {\n+                \/\/ When strict, if -1L was returned, index should be\n+                \/\/ reset to the original index to ensure failure\n+                pos.index = oldStart;\n+            }\n@@ -1889,1 +1915,4 @@\n-            return matchAffix(text, position, suffix, defaultSuffix, matchedSuffix);\n+            \/\/ Suffix must match exactly when strict\n+            return isStrict() ? matchAffix(text, position, suffix, defaultSuffix, matchedSuffix)\n+                    && text.length() == position + suffix.length()\n+                    : matchAffix(text, position, suffix, defaultSuffix, matchedSuffix);\n@@ -1927,1 +1956,1 @@\n-            \/\/ Do not break if a match occur; there is a possibility that the\n+            \/\/ When lenient, do not break if a match occurs; there is a possibility that the\n@@ -1929,2 +1958,3 @@\n-            \/\/ string.\n-            \/\/ For example, matching \"3Mdx\" with \"M\", \"Md\" should match with \"Md\"\n+            \/\/ string. For example, matching \"3Mdx\" with \"M\", \"Md\" should match\n+            \/\/ with \"Md\". However, when strict, break as the match should be exact,\n+            \/\/ and thus no need to check for a longer suffix.\n@@ -1938,0 +1968,4 @@\n+                if (isStrict()) {\n+                    \/\/ when strict, exit early with exact match, same for negative\n+                    break;\n+                }\n@@ -1947,0 +1981,3 @@\n+                if (isStrict()) {\n+                    break;\n+                }\n@@ -1952,0 +1989,1 @@\n+        \/\/ When strict, text must end with the default suffix\n@@ -1955,2 +1993,5 @@\n-            if (text.regionMatches(position, positiveSuffix, 0,\n-                    positiveSuffix.length())) {\n+            boolean containsPosSuffix = text.regionMatches(position,\n+                    positiveSuffix, 0, positiveSuffix.length());\n+            boolean endsWithPosSuffix = containsPosSuffix && text.length() ==\n+                    position + positiveSuffix.length();\n+            if (isStrict() ? endsWithPosSuffix : containsPosSuffix) {\n@@ -1961,2 +2002,5 @@\n-            if (text.regionMatches(position, negativeSuffix, 0,\n-                    negativeSuffix.length())) {\n+            boolean containsNegSuffix = text.regionMatches(position,\n+                    negativeSuffix, 0, negativeSuffix.length());\n+            boolean endsWithNegSuffix = containsNegSuffix && text.length() ==\n+                    position + negativeSuffix.length();\n+            if (isStrict() ? endsWithNegSuffix : containsNegSuffix) {\n@@ -1969,1 +2013,1 @@\n-        \/\/ If both matches, take the longest one\n+        \/\/ If both match, take the longest one\n@@ -2080,0 +2124,1 @@\n+        decimalFormat.setStrict(isStrict());\n@@ -2319,0 +2364,6 @@\n+    @Override\n+    public void setStrict(boolean strict) {\n+        decimalFormat.setStrict(strict);\n+        super.setStrict(strict);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":74,"deletions":23,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+import sun.util.locale.provider.ResourceBundleBasedAdapter;\n+\n@@ -53,2 +56,0 @@\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-import sun.util.locale.provider.ResourceBundleBasedAdapter;\n@@ -2143,1 +2144,5 @@\n-     * Parses text from a string to produce a {@code Number}.\n+     * {@inheritDoc}\n+     * <p>\n+     * Parsing fails when <b>lenient<\/b>, if the prefix and\/or suffix are non-empty\n+     * and cannot be found due to parsing ending early, or the first character\n+     * after the prefix cannot be parsed.\n@@ -2145,10 +2150,16 @@\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and null is returned.\n+     * Parsing fails when <b>strict<\/b>, if in {@code text},\n+     * <ul>\n+     *   <li> The prefix is not found, for example: \"{@code $}\"\n+     *   <li> The suffix is not found, for example: \"{@code %}\"\n+     *   <li> {@link #isGroupingUsed()} returns {@code true}, and {@link\n+     *   #getGroupingSize()} is not adhered to\n+     *   <li> {@link #isGroupingUsed()} returns {@code false}, and the grouping\n+     *   symbol is found\n+     *   <li> {@link #isParseIntegerOnly()} returns {@code true}, and the decimal\n+     *   separator is found\n+     *   <li> {@link #isGroupingUsed()} returns {@code true} and {@link\n+     *   #isParseIntegerOnly()} returns {@code false}, and the grouping\n+     *   symbol occurs after the decimal separator\n+     *   <li> Any other characters are found, that are not the expected symbols,\n+     *   and are not digits that occur within the numerical portion\n+     * <\/ul>\n@@ -2197,0 +2208,1 @@\n+     * @see #setStrict(boolean)\n@@ -2374,0 +2386,2 @@\n+        \/\/ position will serve as new index when success, otherwise it will\n+        \/\/ serve as errorIndex when failure\n@@ -2375,0 +2389,3 @@\n+\n+        \/\/ First character after the prefix was un-parseable, should\n+        \/\/ fail regardless if lenient or strict.\n@@ -2381,1 +2398,2 @@\n-        \/\/ Check for suffix\n+        \/\/ When strict, text should end with the suffix.\n+        \/\/ When lenient, text only needs to contain the suffix.\n@@ -2384,2 +2402,5 @@\n-                gotPositive = text.regionMatches(position,positiveSuffix,0,\n-                        positiveSuffix.length());\n+                boolean containsPosSuffix =\n+                        text.regionMatches(position, positiveSuffix, 0, positiveSuffix.length());\n+                boolean endsWithPosSuffix =\n+                        containsPosSuffix && text.length() == position + positiveSuffix.length();\n+                gotPositive = isStrict() ? endsWithPosSuffix : containsPosSuffix;\n@@ -2388,2 +2409,5 @@\n-                gotNegative = text.regionMatches(position,negativeSuffix,0,\n-                        negativeSuffix.length());\n+                boolean containsNegSuffix =\n+                        text.regionMatches(position, negativeSuffix, 0, negativeSuffix.length());\n+                boolean endsWithNegSuffix =\n+                        containsNegSuffix && text.length() == position + negativeSuffix.length();\n+                gotNegative = isStrict() ? endsWithNegSuffix : containsNegSuffix;\n@@ -2407,0 +2431,1 @@\n+            \/\/ No failures, thus increment the index by the suffix\n@@ -2408,1 +2433,1 @@\n-                    (gotPositive ? positiveSuffix.length() : negativeSuffix.length()); \/\/ mark success!\n+                    (gotPositive ? positiveSuffix.length() : negativeSuffix.length());\n@@ -2423,1 +2448,1 @@\n-     * beginning at position, until an unparseable character is seen.\n+     * beginning at {@code position}, until an unparseable character is seen.\n@@ -2441,1 +2466,1 @@\n-        if (!isExponent && text.regionMatches(position,symbols.getInfinity(),0,\n+        if (!isExponent && text.regionMatches(position, symbols.getInfinity(), 0,\n@@ -2470,0 +2495,2 @@\n+            int prevSeparatorIndex = -groupingSize;\n+            int startPos = position; \/\/ Rely on startPos as index after prefix\n@@ -2491,0 +2518,7 @@\n+                \/\/ Enforce the grouping size on the first group\n+                if (isStrict() && isGroupingUsed() && position == startPos + groupingSize\n+                        && prevSeparatorIndex == -groupingSize && !sawDecimal\n+                        && digit >= 0 && digit <= 9) {\n+                    return position;\n+                }\n+\n@@ -2520,0 +2554,4 @@\n+                    \/\/ Check grouping size on decimal separator\n+                    if (isStrict() && isGroupingViolation(position, prevSeparatorIndex)) {\n+                        return groupingViolationIndex(position, prevSeparatorIndex);\n+                    }\n@@ -2528,2 +2566,17 @@\n-                    if (sawDecimal) {\n-                        break;\n+                    if (isStrict()) {\n+                        \/\/ text should not start with grouping when strict\n+                        if (position == startPos) {\n+                            return startPos;\n+                        }\n+                        \/\/ when strict, fail if grouping occurs after decimal OR\n+                        \/\/ current group violates grouping size\n+                        if (sawDecimal || (isGroupingViolation(position, prevSeparatorIndex))) {\n+                            return groupingViolationIndex(position, prevSeparatorIndex);\n+                        }\n+                        prevSeparatorIndex = position; \/\/ track previous\n+                    } else {\n+                        \/\/ when lenient, only exit if grouping occurs after decimal\n+                        \/\/ subsequent grouping symbols are allowed when lenient\n+                        if (sawDecimal) {\n+                            break;\n+                        }\n@@ -2557,0 +2610,17 @@\n+            \/\/ (When strict), within the loop we enforce grouping when encountering\n+            \/\/ decimal\/grouping symbols. Once outside loop, we need to check\n+            \/\/ the final grouping, ex: \"1,234\". Only check the final grouping\n+            \/\/ if we have not seen a decimal separator, to prevent a non needed check,\n+            \/\/ for ex: \"1,234.\", \"1,234.12\"\n+            if (isStrict()) {\n+                if (!sawDecimal && isGroupingViolation(position, prevSeparatorIndex)) {\n+                    \/\/ -1, since position is incremented by one too many when loop is finished\n+                    \/\/ \"1,234%\" and \"1,234\" both end with pos = 5, since '%' breaks\n+                    \/\/ the loop before incrementing position. In both cases, check\n+                    \/\/ should be done at pos = 4\n+                    return groupingViolationIndex(position - 1, prevSeparatorIndex);\n+                }\n+            }\n+\n+            \/\/ If a grouping symbol is not followed by a digit, it must be\n+            \/\/ backed up to either exit early or fail depending on leniency\n@@ -2578,0 +2648,10 @@\n+    }\n+\n+    \/\/ Checks to make sure grouping size is not violated. Used when strict.\n+    private boolean isGroupingViolation(int pos, int prevGroupingPos) {\n+        return isGroupingUsed() && \/\/ Only violates if using grouping\n+                \/\/ Checks if a previous grouping symbol was seen.\n+                prevGroupingPos != -groupingSize &&\n+                \/\/ The check itself, - 1 to account for grouping\/decimal symbol\n+                pos - 1 != prevGroupingPos + groupingSize;\n+    }\n@@ -2579,0 +2659,7 @@\n+    \/\/ Calculates the index that violated the grouping size\n+    \/\/ Calculation is determined whether it was an under or over violation\n+    private int groupingViolationIndex(int pos, int prevGroupingPos) {\n+        return Math.min(\n+                pos, \/\/ ex: \"1,23,4\" OR \"1,,2\". When under, violating char is grouping\n+                \/\/ ex: \"1,2345,6. When over, violating char is digit\n+                prevGroupingPos + groupingSize + 1);\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":110,"deletions":23,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-     * Parses text from a string to produce an object.\n+     * Parses text from the given string to produce an object.\n@@ -215,3 +215,2 @@\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n+     * This method attempts to parse text starting at the index given by\n+     * {@code pos}. If parsing succeeds, then the index of {@code pos} is updated\n@@ -224,1 +223,1 @@\n-     * the character where the error occurred, and null is returned.\n+     * the character where the error occurred, and {@code null} is returned.\n@@ -226,1 +225,3 @@\n-     * @param source A {@code String}, part of which should be parsed.\n+     * @apiNote Subclasses may consider implementing leniency when parsing.\n+     *          The definition of leniency should be delegated to the subclass.\n+     * @param source the {@code String} to parse\n@@ -230,2 +231,3 @@\n-     *         error, returns null.\n-     * @throws NullPointerException if {@code source} or {@code pos} is null.\n+     *         error, returns {@code null}.\n+     * @throws NullPointerException if {@code source} or {@code pos} is\n+     *         {@code null}.\n@@ -237,1 +239,0 @@\n-     * The method may not use the entire text of the given string.\n@@ -239,1 +240,4 @@\n-     * @param source A {@code String} whose beginning should be parsed.\n+     * @implNote This implementation is equivalent to calling {@code parseObject(source,\n+     * new ParsePosition(0)} and throwing a {@code ParseException} if parsing fails,\n+     * instead of returning {@code null}.\n+     * @param source A {@code String}, to be parsed from the beginning.\n@@ -241,3 +245,2 @@\n-     * @throws    ParseException if the beginning of the specified string\n-     *            cannot be parsed.\n-     * @throws NullPointerException if {@code source} is null.\n+     * @throws ParseException if parsing fails\n+     * @throws NullPointerException if {@code source} is {@code null}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -41,1 +41,3 @@\n-import java.io.InvalidObjectException;\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+import sun.util.locale.provider.LocaleServiceProviderPool;\n+\n@@ -43,0 +45,1 @@\n+import java.io.InvalidObjectException;\n@@ -55,2 +58,0 @@\n-import sun.util.locale.provider.LocaleProviderAdapter;\n-import sun.util.locale.provider.LocaleServiceProviderPool;\n@@ -61,2 +62,5 @@\n- * numbers. {@code NumberFormat} also provides methods for determining\n- * which locales have number formats, and what their names are.\n+ * numbers in a localized manner. This enables code that can be completely\n+ * independent of the locale conventions for decimal points, thousands-separators,\n+ * whether the number format is even decimal, or even the particular decimal\n+ * digits used. For example, this class could be used to format a number\n+ * according to French numerical conventions.\n@@ -64,5 +68,16 @@\n- * <p>\n- * {@code NumberFormat} helps you to format and parse numbers for any locale.\n- * Your code can be completely independent of the locale conventions for\n- * decimal points, thousands-separators, or even the particular decimal\n- * digits used, or whether the number format is even decimal.\n+ * <h2>Getting a Format<\/h2>\n+ * To format a number for the default Locale, use one of the static factory class methods.\n+ * The following examples all format the {@code Number} \"2000.50\" with the {@link\n+ * java.util.Locale#US US} locale as the default.\n+ * <ul>\n+ * <li> Use {@link #getInstance()} or {@link #getNumberInstance()} to get\n+ * a number format. For example, {@code \"2,000.5\"}.\n+ * <li> Use {@link #getIntegerInstance()} to get an integer number format.\n+ * For example, {@code \"2,000\"}.\n+ * <li> Use {@link #getCurrencyInstance} to get a currency number format.\n+ * For example, {@code \"$2,000.50\"}.\n+ * <li> Use {@link #getCompactNumberInstance} to get a compact number format\n+ * to format a number in shorter form. For example, {@code \"2K\"}.\n+ * <li> Use {@link #getPercentInstance} to get a format for displaying percentages.\n+ * For example, {@code \"200,050%\"}.\n+ * <\/ul>\n@@ -70,27 +85,4 @@\n- * <p>\n- * To format a number for the current Locale, use one of the factory\n- * class methods:\n- * <blockquote>\n- * {@snippet lang=java :\n- * myString = NumberFormat.getInstance().format(myNumber);\n- * }\n- * <\/blockquote>\n- * If you are formatting multiple numbers, it is\n- * more efficient to get the format and use it multiple times so that\n- * the system doesn't have to fetch the information about the local\n- * language and country conventions multiple times.\n- * <blockquote>\n- * {@snippet lang=java :\n- * NumberFormat nf = NumberFormat.getInstance();\n- * for (var myNumber : numbers) {\n- *     output.println(nf.format(myNumber) + \"; \");\n- * }\n- * }\n- * <\/blockquote>\n- * To format a number for a different Locale, specify it in the\n- * call to {@code getInstance}.\n- * <blockquote>\n- * {@snippet lang=java :\n- * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);\n- * }\n- * <\/blockquote>\n+ * Alternatively, if a number format for a different locale is required, use\n+ * one of the factory class method variants that take {@code locale} as a parameter,\n+ * for example, {@link #getIntegerInstance(Locale)}. Use {@link #getAvailableLocales()}\n+ * to determine which locales support number formats,\n@@ -98,1 +90,2 @@\n- * <p>If the locale contains \"nu\" (numbers) and\/or \"rg\" (region override)\n+ * <h3>Locale Extensions<\/h3>\n+ * <p>If the locale used for formatting contains \"nu\" (numbers) and\/or \"rg\" (region override)\n@@ -104,26 +97,17 @@\n- * <p>You can also use a {@code NumberFormat} to parse numbers:\n- * <blockquote>\n- * {@snippet lang=java :\n- * myNumber = nf.parse(myString);\n- * }\n- * <\/blockquote>\n- * Use {@code getInstance} or {@code getNumberInstance} to get the\n- * normal number format. Use {@code getIntegerInstance} to get an\n- * integer number format. Use {@code getCurrencyInstance} to get the\n- * currency number format. Use {@code getCompactNumberInstance} to get the\n- * compact number format to format a number in shorter form. For example,\n- * {@code 2000} can be formatted as {@code \"2K\"} in\n- * {@link java.util.Locale#US US locale}. Use {@code getPercentInstance}\n- * to get a format for displaying percentages. With this format, a fraction\n- * like 0.53 is displayed as 53%.\n- *\n- * <p>\n- * You can also control the display of numbers with such methods as\n- * {@code setMinimumFractionDigits}.\n- * If you want even more control over the format or parsing,\n- * or want to give your users more control,\n- * you can try casting the {@code NumberFormat} you get from the factory methods\n- * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on\n- * the factory method used. This will work for the vast majority of locales;\n- * just remember to put it in a {@code try} block in case you encounter\n- * an unusual one.\n+ * <h2>Customizing Formatting and Parsing<\/h2>\n+ * {@code NumberFormat} provides formatting through the {@code format},\n+ * and parsing through the {@code parse} methods. For further customization\n+ * of formatting and parsing behavior, use any of the following instance methods.\n+ * <ul>\n+ * <li> {@link #setParseIntegerOnly(boolean)}; when true, will only return the\n+ * integer portion of the number parsed from the String.\n+ * <li> {@link #setStrict(boolean)}; when true, parsing will be done strictly.\n+ * See the {@link ##leniency Leniency Section}\n+ * <li> {@link #setMinimumFractionDigits}; Use to adjust the expected digits when\n+ * formatting. Use any of the other minimum\/maximum or fraction\/integer setter methods\n+ * in the same manner.\n+ * <li> {@link #setGroupingUsed}; when true, formatted numbers will be displayed\n+ * with grouping separators. Additionally, when false, parsing will not expect\n+ * grouping separators in the parsed String, and may exit early or fail depending\n+ * on leniency.\n+ * <\/ul>\n@@ -132,19 +116,7 @@\n- * NumberFormat and DecimalFormat are designed such that some controls\n- * work for formatting and others work for parsing.  The following is\n- * the detailed description for each these control methods,\n- * <p>\n- * setParseIntegerOnly : only affects parsing, e.g.\n- * if true,  \"3456.78\" &rarr; 3456 (and leaves the parse position just after index 6)\n- * if false, \"3456.78\" &rarr; 3456.78 (and leaves the parse position just after index 8)\n- * This is independent of formatting.  If you want to not show a decimal point\n- * where there might be no digits after the decimal point, use\n- * setDecimalSeparatorAlwaysShown.\n- * <p>\n- * setDecimalSeparatorAlwaysShown : only affects formatting, and only where\n- * there might be no digits after the decimal point, such as with a pattern\n- * like \"#,##0.##\", e.g.,\n- * if true,  3456.00 &rarr; \"3,456.\"\n- * if false, 3456.00 &rarr; \"3456\"\n- * This is independent of parsing.  If you want parsing to stop at the decimal\n- * point, use setParseIntegerOnly.\n- *\n+ * To provide more control over the format or parsing, cast the {@code\n+ * NumberFormat} you get from the factory methods to a {@code DecimalFormat} or\n+ * {@code CompactNumberFormat} depending on the factory method used. For example,\n+ * cast to {@code DecimalFormat} to call {@link DecimalFormat#setGroupingSize(int)}\n+ * to change the desired digits between grouping separators.\n+ * While this will work for the vast majority of locales; a {@code\n+ * try} block should be used in case a non-supported locale is encountered.\n@@ -178,1 +150,12 @@\n- * <h2><a id=\"synchronization\">Synchronization<\/a><\/h2>\n+ * <h2><a id=\"leniency\">Leniency<\/a><\/h2>\n+ * {@code NumberFormat} can parse both strictly and leniently. By default, parsing\n+ * is lenient, and leniency can be adjusted using {@link #setStrict(boolean)}. Lenient\n+ * parsing should be used when attempting to parse a number out of a String\n+ * that contains non-expected values. For example, parsing the number {@code 1000}\n+ * out of the String \"1,000 people\". Strict parsing should be used when\n+ * attempting to ensure a String adheres exactly to the locale's conventions, and\n+ * can thus serve to validate input. For example, successfully parsing the number\n+ * {@code 1000.55} out of the String \"1.000,55\" confirms the String\n+ * adhered to the {@link Locale#GERMAN German} numerical conventions. See the\n+ * {@link #parse(String, ParsePosition)} method for further details on behavioral\n+ * differences between leniency modes.\n@@ -180,2 +163,2 @@\n- * <p>\n- * Number formats are generally not synchronized.\n+ * <h3><a id=\"synchronization\">Synchronization<\/a><\/h3>\n+ * {@code NumberFormat} is not synchronized.\n@@ -186,1 +169,3 @@\n- * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},\n+ * @implSpec\n+ * <h4>Null Parameter Handling<\/h4>\n+ * The {@link #format(double, StringBuffer, FieldPosition)},\n@@ -193,1 +178,1 @@\n- * <p>\n+ * <h4>Default RoundingMode<\/h4>\n@@ -288,12 +273,1 @@\n-     * Parses text from a string to produce a {@code Number}.\n-     * <p>\n-     * The method attempts to parse text starting at the index given by\n-     * {@code pos}.\n-     * If parsing succeeds, then the index of {@code pos} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed\n-     * number is returned. The updated {@code pos} can be used to\n-     * indicate the starting point for the next call to this method.\n-     * If an error occurs, then the index of {@code pos} is not\n-     * changed, the error index of {@code pos} is set to the index of\n-     * the character where the error occurred, and null is returned.\n+     * {@inheritDoc}\n@@ -301,2 +275,1 @@\n-     * See the {@link #parse(String, ParsePosition)} method for more information\n-     * on number parsing.\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n@@ -304,1 +277,3 @@\n-     * @param source A {@code String}, part of which should be parsed.\n+     * @implSpec This implementation is equivalent to calling {@code parse(source,\n+     *           pos)}.\n+     * @param source the {@code String} to parse\n@@ -402,1 +377,13 @@\n-     * Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,\n+     * Parses text from the beginning of the given string to produce a {@code Number}.\n+     * <p>\n+     * This method attempts to parse text starting at the index given by\n+     * {@code pos}. If parsing succeeds, then the index of {@code parsePosition} is updated\n+     * to the index after the last character used (parsing does not necessarily\n+     * use all characters up to the end of the string), and the parsed number is\n+     * returned. The updated {@code parsePosition} can be used to indicate the starting\n+     * point for the next call to this method. If an error occurs, then the\n+     * index of {@code parsePosition} is not changed, the error index of {@code\n+     * parsePosition} is set to the index of the character where the error\n+     * occurred, and {@code null} is returned.\n+     * <p>\n+     * This method will return a Long if possible (e.g., within the range [Long.MIN_VALUE,\n@@ -404,5 +391,1 @@\n-     * If IntegerOnly is set, will stop at a decimal\n-     * point (or equivalent; e.g., for rational numbers \"1 2\/3\", will stop\n-     * after the 1).\n-     * Does not throw an exception; if no object can be parsed, index is\n-     * unchanged!\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n@@ -410,5 +393,10 @@\n-     * @param source the String to parse\n-     * @param parsePosition the parse position\n-     * @return the parsed value\n-     * @see java.text.NumberFormat#isParseIntegerOnly\n-     * @see java.text.Format#parseObject\n+     * @param source the {@code String} to parse\n+     * @param parsePosition A {@code ParsePosition} object with index and error\n+     *            index information as described above.\n+     * @return A {@code Number} parsed from the string. In case of\n+     *         failure, returns {@code null}.\n+     * @throws NullPointerException if {@code source} or {@code ParsePosition}\n+     *         is {@code null}.\n+     * @see #isStrict()\n+     * @see #isParseIntegerOnly()\n+     * @see #isGroupingUsed()\n@@ -419,2 +407,1 @@\n-     * Parses text from the beginning of the given string to produce a number.\n-     * The method may not use the entire text of the given string.\n+     * Parses text from the beginning of the given string to produce a {@code Number}.\n@@ -422,2 +409,3 @@\n-     * See the {@link #parse(String, ParsePosition)} method for more information\n-     * on number parsing.\n+     * This method will return a Long if possible (e.g., within the range [Long.MIN_VALUE,\n+     * Long.MAX_VALUE] and with no decimals), otherwise a Double.\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n@@ -425,1 +413,4 @@\n-     * @param source A {@code String} whose beginning should be parsed.\n+     * @implNote This is equivalent to calling {@code parse(source,\n+     * new ParsePosition(0)} and throwing a {@code ParseException} if parsing fails,\n+     * instead of returning {@code null}.\n+     * @param source A {@code String}, to be parsed from the beginning.\n@@ -427,2 +418,5 @@\n-     * @throws    ParseException if the beginning of the specified string\n-     *            cannot be parsed.\n+     * @throws ParseException if parsing fails\n+     * @throws NullPointerException if {@code source} is {@code null}.\n+     * @see #isStrict()\n+     * @see #isParseIntegerOnly()\n+     * @see #isGroupingUsed()\n@@ -466,0 +460,27 @@\n+    \/**\n+     * {@return {@code true} if this format will parse numbers strictly;\n+     * {@code false} otherwise}\n+     *\n+     * @see ##leniency Leniency Section\n+     * @see #setStrict(boolean)\n+     * @since 23\n+     *\/\n+    public boolean isStrict() {\n+        return parseStrict;\n+    }\n+\n+    \/**\n+     * Change the leniency value for parsing. Parsing can either be strict or lenient,\n+     * by default it is lenient.\n+     *\n+     * @param strict {@code true} if parsing should be done strictly;\n+     *               {@code false} otherwise\n+     * @see ##leniency Leniency Section\n+     * @see #isStrict()\n+     * @since 23\n+     *\/\n+    public void setStrict(boolean strict) {\n+        \/\/ setStrict method over setLenient, as the default behavior is lenient\n+        parseStrict = strict;\n+    }\n+\n@@ -767,1 +788,2 @@\n-            && parseIntegerOnly == other.parseIntegerOnly);\n+            && parseIntegerOnly == other.parseIntegerOnly\n+            && parseStrict == other.parseStrict);\n@@ -1184,0 +1206,10 @@\n+\n+    \/**\n+     * True if this {@code NumberFormat} will parse numbers with strict leniency.\n+     *\n+     * @serial\n+     * @since 23\n+     * @see #setStrict(boolean)\n+     * @see #isStrict()\n+     *\/\n+    private boolean parseStrict = false;\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":154,"deletions":122,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -0,0 +1,417 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Test suite for NumberFormat parsing when lenient.\n+ * @run junit\/othervm -Duser.language=en -Duser.country=US LenientParseTest\n+ * @run junit\/othervm -Duser.language=ja -Duser.country=JP LenientParseTest\n+ * @run junit\/othervm -Duser.language=zh -Duser.country=CN LenientParseTest\n+ * @run junit\/othervm -Duser.language=tr -Duser.country=TR LenientParseTest\n+ * @run junit\/othervm -Duser.language=de -Duser.country=DE LenientParseTest\n+ * @run junit\/othervm -Duser.language=fr -Duser.country=FR LenientParseTest\n+ * @run junit\/othervm -Duser.language=ar -Duser.country=AR LenientParseTest\n+ *\/\n+\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/\/ Tests lenient parsing, this is done by testing the NumberFormat factory instances\n+\/\/ against a number of locales with different formatting conventions. The locales\n+\/\/ used all use a grouping size of 3. When lenient, parsing only fails\n+\/\/ if the prefix and\/or suffix are not found, or the first character after the\n+\/\/ prefix is un-parseable. The tested locales all use groupingSize of 3.\n+public class LenientParseTest {\n+\n+    \/\/ Used to retrieve the locale's expected symbols\n+    private static final DecimalFormatSymbols dfs =\n+            new DecimalFormatSymbols(Locale.getDefault());\n+    private static final DecimalFormat dFmt = (DecimalFormat)\n+            NumberFormat.getNumberInstance(Locale.getDefault());\n+    private static final DecimalFormat cFmt =\n+            (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.getDefault());\n+    private static final DecimalFormat pFmt =\n+            (DecimalFormat) NumberFormat.getPercentInstance(Locale.getDefault());\n+    private static final CompactNumberFormat cmpctFmt =\n+            (CompactNumberFormat) NumberFormat.getCompactNumberInstance(Locale.getDefault(),\n+                    NumberFormat.Style.SHORT);\n+\n+    \/\/ All NumberFormats should parse leniently (which is the default)\n+    static {\n+        \/\/ To effectively test compactNumberFormat, these should be set accordingly\n+        cmpctFmt.setParseIntegerOnly(false);\n+        cmpctFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ ---- NumberFormat tests ----\n+    \/\/ Test prefix\/suffix behavior with a predefined DecimalFormat\n+    \/\/ Non-localized, only run once\n+    @ParameterizedTest\n+    @MethodSource(\"badParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void numFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        \/\/ Format with grouping size = 3, prefix = a, suffix = b\n+        DecimalFormat nonLocalizedDFmt = new DecimalFormat(\"a#,#00.00b\");\n+        failParse(nonLocalizedDFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    \/\/ All input Strings should parse fully and return the expected value.\n+    \/\/ Expected index should be the length of the parse string, since it parses fully\n+    @ParameterizedTest\n+    @MethodSource(\"validFullParseStrings\")\n+    public void numFmtSuccessFullParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ All input Strings should parse partially and return expected value\n+    \/\/ with the expected final index\n+    @ParameterizedTest\n+    @MethodSource(\"validPartialParseStrings\")\n+    public void numFmtSuccessPartialParseTest(String toParse, double expectedValue,\n+                                              int expectedIndex) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+    }\n+\n+    \/\/ Parse partially due to no grouping\n+    @ParameterizedTest\n+    @MethodSource(\"noGroupingParseStrings\")\n+    public void numFmtStrictGroupingNotUsed(String toParse, double expectedValue, int expectedIndex) {\n+        dFmt.setGroupingUsed(false);\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+        dFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ Parse partially due to integer only\n+    @ParameterizedTest\n+    @MethodSource(\"integerOnlyParseStrings\")\n+    public void numFmtStrictIntegerOnlyUsed(String toParse, int expectedValue, int expectedIndex) {\n+        dFmt.setParseIntegerOnly(true);\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+        dFmt.setParseIntegerOnly(false);\n+    }\n+\n+    \/\/ ---- CurrencyFormat tests ----\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidFullParseStrings\")\n+    public void currFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ Strings may parse partially or fail. This is because the mapped\n+    \/\/ data may cause the error to occur before the suffix can be found, (if the locale\n+    \/\/ uses a suffix).\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidPartialParseStrings\")\n+    public void currFmtParseTest(String toParse, double expectedValue,\n+                                 int expectedIndex) {\n+        if (cFmt.getPositiveSuffix().length() > 0) {\n+            \/\/ Since the error will occur before suffix is found, exception is thrown.\n+            failParse(cFmt, toParse, expectedIndex);\n+        } else {\n+            \/\/ Empty suffix, thus even if the error occurs, we have already found the\n+            \/\/ prefix, and simply parse partially\n+            assertEquals(expectedValue, successParse(cFmt, toParse, expectedIndex));\n+        }\n+    }\n+\n+    \/\/ ---- PercentFormat tests ----\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidFullParseStrings\")\n+    public void percentFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(pFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ Strings may parse partially or fail. This is because the mapped\n+    \/\/ data may cause the error to occur before the suffix can be found, (if the locale\n+    \/\/ uses a suffix).\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidPartialParseStrings\")\n+    public void percentFmtParseTest(String toParse, double expectedValue,\n+                                 int expectedIndex) {\n+        if (pFmt.getPositiveSuffix().length() > 0) {\n+            \/\/ Since the error will occur before suffix is found, exception is thrown.\n+            failParse(pFmt, toParse, expectedIndex);\n+        } else {\n+            \/\/ Empty suffix, thus even if the error occurs, we have already found the\n+            \/\/ prefix, and simply parse partially\n+            assertEquals(expectedValue, successParse(pFmt, toParse, expectedIndex));\n+        }\n+    }\n+\n+    \/\/ ---- CompactNumberFormat tests ----\n+    \/\/ Can match to both the decimalFormat patterns and the compact patterns\n+    \/\/ Unlike the other tests, this test is only ran against the US Locale and\n+    \/\/ tests against data built with the thousands format (K).\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidPartialParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtFailParseTest(String toParse, double expectedValue, int expectedErrorIndex) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, expectedErrorIndex));\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidFullParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ ---- Helper test methods ----\n+\n+    \/\/ Method is used when a String should parse successfully. This does not indicate\n+    \/\/ that the entire String was used, however. The index and errorIndex values\n+    \/\/ should be as expected.\n+    private double successParse(NumberFormat fmt, String toParse, int expectedIndex) {\n+        Number parsedValue = assertDoesNotThrow(() -> fmt.parse(toParse));\n+        ParsePosition pp = new ParsePosition(0);\n+        assertDoesNotThrow(() -> fmt.parse(toParse, pp));\n+        assertEquals(-1, pp.getErrorIndex(),\n+                \"ParsePosition ErrorIndex is not in correct location\");\n+        assertEquals(expectedIndex, pp.getIndex(),\n+                \"ParsePosition Index is not in correct location\");\n+        return parsedValue.doubleValue();\n+    }\n+\n+    \/\/ Method is used when a String should fail parsing. Indicated by either a thrown\n+    \/\/ ParseException, or null is returned depending on which parse method is invoked.\n+    \/\/ errorIndex should be as expected.\n+    private void failParse(NumberFormat fmt, String toParse, int expectedErrorIndex) {\n+        ParsePosition pp = new ParsePosition(0);\n+        assertThrows(ParseException.class, () -> fmt.parse(toParse));\n+        assertNull(fmt.parse(toParse, pp));\n+        assertEquals(expectedErrorIndex, pp.getErrorIndex());\n+    }\n+\n+    \/\/ ---- Data Providers ----\n+\n+    \/\/ Strings that should fail when parsed leniently.\n+    \/\/ Given as Arguments<String, expectedErrorIndex>\n+    \/\/ Non-localized data. For reference, the pattern of nonLocalizedDFmt is\n+    \/\/ \"a#,#00.00b\"\n+    private static Stream<Arguments> badParseStrings() {\n+        return Stream.of(\n+                \/\/ No prefix\n+                Arguments.of(\"1,1b\", 0),\n+                \/\/ No suffix\n+                Arguments.of(\"a1,11\", 5),\n+                \/\/ Digit does not follow the last grouping separator\n+                \/\/ Current behavior fails on the grouping separator\n+                Arguments.of(\"a1,11,z\", 5),\n+                \/\/ No suffix after grouping\n+                Arguments.of(\"a1,11,\", 5),\n+                \/\/ No prefix and suffix\n+                Arguments.of(\"1,11\", 0),\n+                \/\/ First character after prefix is un-parseable\n+                \/\/ Behavior is to expect error index at 0, not 1\n+                Arguments.of(\"ac1,11\", 0));\n+    }\n+\n+    \/\/ These data providers use US locale grouping and decimal separators\n+    \/\/ for readability, however, the data is tested against multiple locales\n+    \/\/ and is converted appropriately at runtime.\n+\n+    \/\/ Strings that should parse successfully, and consume the entire String\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber)\n+    private static Stream<Arguments> validFullParseStrings() {\n+        return Stream.of(\n+                \/\/ Many subsequent grouping symbols\n+                Arguments.of(\"1,,,1\", 11d),\n+                Arguments.of(\"11,,,11,,,11\", 111111d),\n+                \/\/ Bad grouping size (with decimal)\n+                Arguments.of(\"1,1.\", 11d),\n+                Arguments.of(\"11,111,11.\", 1111111d),\n+                \/\/ Improper grouping size (with decimal and digits after)\n+                Arguments.of(\"1,1.1\", 11.1d),\n+                Arguments.of(\"1,11.1\", 111.1d),\n+                Arguments.of(\"1,1111.1\", 11111.1d),\n+                Arguments.of(\"11,111,11.1\", 1111111.1d),\n+                \/\/ Starts with grouping symbol\n+                Arguments.of(\",111,,1,1\", 11111d),\n+                Arguments.of(\",1\", 1d),\n+                Arguments.of(\",,1\", 1d),\n+                \/\/ Leading Zeros (not digits)\n+                Arguments.of(\"000,1,1\", 11d),\n+                Arguments.of(\"000,111,11,,1\", 111111d),\n+                Arguments.of(\"0,000,1,,1,1\", 111d),\n+                Arguments.of(\"1,234.00\", 1234d),\n+                Arguments.of(\"1,234.0\", 1234d),\n+                Arguments.of(\"1,234.\", 1234d),\n+                Arguments.of(\"1,234.00123\", 1234.00123d),\n+                Arguments.of(\"1,234.012\", 1234.012d),\n+                Arguments.of(\"1,234.224\", 1234.224d),\n+                Arguments.of(\"1\", 1d),\n+                Arguments.of(\"10\", 10d),\n+                Arguments.of(\"100\", 100d),\n+                Arguments.of(\"1000\", 1000d),\n+                Arguments.of(\"1,000\", 1000d),\n+                Arguments.of(\"10,000\", 10000d),\n+                Arguments.of(\"10000\", 10000d),\n+                Arguments.of(\"100,000\", 100000d),\n+                Arguments.of(\"1,000,000\", 1000000d),\n+                Arguments.of(\"10,000,000\", 10000000d))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n+    }\n+\n+    \/\/ Strings that should parse successfully, but do not use the entire String\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> validPartialParseStrings() {\n+        return Stream.of(\n+                \/\/ End with grouping symbol\n+                Arguments.of(\"11,\", 11d, 2),\n+                Arguments.of(\"11,,\", 11d, 3),\n+                Arguments.of(\"11,,,\", 11d, 4),\n+                \/\/ Random chars that aren't the expected symbols\n+                Arguments.of(\"1,1P111\", 11d, 3),\n+                Arguments.of(\"1.1P111\", 1.1d, 3),\n+                Arguments.of(\"1P,1111\", 1d, 1),\n+                Arguments.of(\"1P.1111\", 1d, 1),\n+                Arguments.of(\"1,1111P\", 11111d, 6),\n+                \/\/ Grouping occurs after decimal separator)\n+                Arguments.of(\"1.11,11\", 1.11d, 4),\n+                Arguments.of(\"1.,11,11\", 1d, 2))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Test data input for when parse integer only is true\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> integerOnlyParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"1234.1234\", 1234, 4),\n+                Arguments.of(\"1234.12\", 1234, 4),\n+                Arguments.of(\"1234.1a\", 1234, 4),\n+                Arguments.of(\"1234.\", 1234, 4))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Test data input for when no grouping is true\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> noGroupingParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"12,34\", 12d, 2),\n+                Arguments.of(\"1234,\", 1234d, 4),\n+                Arguments.of(\"123,456.789\", 123d, 3))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Mappers for respective data providers to adjust values accordingly\n+    \/\/ Localized percent prefix\/suffix is added, with appropriate expected values\n+    \/\/ adjusted. Expected parsed number should be divided by 100.\n+    private static Stream<Arguments> percentValidPartialParseStrings() {\n+        return validPartialParseStrings().map(args ->\n+                Arguments.of(pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                        (double) args.get()[1] \/ 100, (int) args.get()[2] + pFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> percentValidFullParseStrings() {\n+        return validFullParseStrings().map(args -> Arguments.of(\n+                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                (double) args.get()[1] \/ 100)\n+        );\n+    }\n+\n+    \/\/ Mappers for respective data providers to adjust values accordingly\n+    \/\/ Localized percent prefix\/suffix is added, with appropriate expected values\n+    \/\/ adjusted. Separators replaced for monetary versions.\n+    private static Stream<Arguments> currencyValidPartialParseStrings() {\n+        return validPartialParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1], (int) args.get()[2] + cFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> currencyValidFullParseStrings() {\n+        return validFullParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1])\n+        );\n+    }\n+\n+    \/\/ Compact Pattern Data Provider provides test input for both DecimalFormat patterns\n+    \/\/ and the compact patterns. As there is no method to retrieve compact patterns,\n+    \/\/ thus test only against US English locale, and use a hard coded K - 1000\n+    private static Stream<Arguments> compactValidPartialParseStrings() {\n+        return Stream.concat(validPartialParseStrings().map(args -> Arguments.of(args.get()[0],\n+                args.get()[1], args.get()[2])), validPartialParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\",\n+                args.get()[1], args.get()[2]))\n+        );\n+    }\n+\n+    private static Stream<Arguments> compactValidFullParseStrings() {\n+        return Stream.concat(validFullParseStrings().map(args -> Arguments.of(args.get()[0],\n+                args.get()[1])), validFullParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\",\n+                (double)args.get()[1] * 1000.0))\n+        );\n+    }\n+\n+    \/\/ Replace the grouping and decimal separators with localized variants\n+    \/\/ Used during localization of data\n+    private static String localizeText(String text) {\n+        \/\/ As this is a single pass conversion, this is safe for multiple replacement,\n+        \/\/ even if a ',' could be a decimal separator for a locale.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < text.length(); i++) {\n+            char c = text.charAt(i);\n+            if (c == ',') {\n+                sb.append(dfs.getGroupingSeparator());\n+            } else if (c == '.') {\n+                sb.append(dfs.getDecimalSeparator());\n+            } else if (c == '0') {\n+                sb.append(dfs.getZeroDigit());\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientParseTest.java","additions":417,"deletions":0,"binary":false,"changes":417,"status":"added"},{"patch":"@@ -0,0 +1,525 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640\n+ * @summary Test suite for NumberFormat parsing with strict leniency\n+ * @run junit\/othervm -Duser.language=en -Duser.country=US StrictParseTest\n+ * @run junit\/othervm -Duser.language=ja -Duser.country=JP StrictParseTest\n+ * @run junit\/othervm -Duser.language=zh -Duser.country=CN StrictParseTest\n+ * @run junit\/othervm -Duser.language=tr -Duser.country=TR StrictParseTest\n+ * @run junit\/othervm -Duser.language=de -Duser.country=DE StrictParseTest\n+ * @run junit\/othervm -Duser.language=fr -Duser.country=FR StrictParseTest\n+ * @run junit\/othervm -Duser.language=ar -Duser.country=AR StrictParseTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/\/ Tests strict parsing, this is done by testing the NumberFormat factory instances\n+\/\/ against a number of locales with different formatting conventions. The locales\n+\/\/ used all use a grouping size of 3.\n+public class StrictParseTest {\n+\n+    \/\/ Used to retrieve the locale's expected symbols\n+    private static final DecimalFormatSymbols dfs =\n+            new DecimalFormatSymbols(Locale.getDefault());\n+    \/\/ We re-use these formats for the respective factory tests\n+    private static final DecimalFormat dFmt =\n+            (DecimalFormat) NumberFormat.getNumberInstance(Locale.getDefault());\n+    private static final DecimalFormat cFmt =\n+            (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.getDefault());\n+    private static final DecimalFormat pFmt =\n+            (DecimalFormat) NumberFormat.getPercentInstance(Locale.getDefault());\n+    private static final CompactNumberFormat cmpctFmt =\n+            (CompactNumberFormat) NumberFormat.getCompactNumberInstance(Locale.getDefault(),\n+                    NumberFormat.Style.SHORT);\n+\n+\n+    \/\/ All NumberFormats should parse strictly\n+    static {\n+        dFmt.setStrict(true);\n+        pFmt.setStrict(true);\n+        cFmt.setStrict(true);\n+        cmpctFmt.setStrict(true);\n+        \/\/ To effectively test strict compactNumberFormat parsing\n+        cmpctFmt.setParseIntegerOnly(false);\n+        cmpctFmt.setGroupingUsed(true);\n+        cmpctFmt.setGroupingSize(3);\n+    }\n+\n+    \/\/ ---- NumberFormat tests ----\n+\n+    \/\/ Guarantee some edge case test input\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void uniqueCaseNumberFormatTest() {\n+        \/\/ Format with grouping size = 3, prefix = a, suffix = b\n+        DecimalFormat nonLocalizedDFmt = new DecimalFormat(\"a#,#00.00b\");\n+        nonLocalizedDFmt.setStrict(true);\n+        \/\/ Text after suffix\n+        failParse(nonLocalizedDFmt, \"a12bfoo\", 3);\n+        failParse(nonLocalizedDFmt, \"a123,456.00bc\", 11);\n+        \/\/ Text after prefix\n+        failParse(nonLocalizedDFmt, \"ac123\", 0);\n+        \/\/ Missing suffix\n+        failParse(nonLocalizedDFmt, \"a123\", 4);\n+        \/\/ Prefix contains a decimal separator\n+        failParse(nonLocalizedDFmt, \".a123\", 0);\n+        \/\/ Test non grouping size of 3\n+        nonLocalizedDFmt.setGroupingSize(1);\n+        successParse(nonLocalizedDFmt, \"a1,2,3,4b\");\n+        failParse(nonLocalizedDFmt, \"a1,2,3,45,6b\", 8);\n+        nonLocalizedDFmt.setGroupingSize(5);\n+        successParse(nonLocalizedDFmt, \"a12345,67890b\");\n+        successParse(nonLocalizedDFmt, \"a1234,67890b\");\n+        failParse(nonLocalizedDFmt, \"a123456,7890b\", 6);\n+\n+    }\n+\n+    \/\/ All input Strings should fail\n+    @ParameterizedTest\n+    @MethodSource(\"badParseStrings\")\n+    public void numFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(dFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"validParseStrings\")\n+    public void numFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse));\n+    }\n+\n+    \/\/ All input Strings should fail\n+    @ParameterizedTest\n+    @MethodSource(\"negativeBadParseStrings\")\n+    public void negNumFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(dFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"negativeValidParseStrings\")\n+    public void negNumFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse));\n+    }\n+\n+    \/\/ Exception should be thrown if grouping separator occurs anywhere\n+    \/\/ Don't pass badParseStrings as a data source, since they may fail for other reasons\n+    @ParameterizedTest\n+    @MethodSource({\"validParseStrings\", \"noGroupingParseStrings\"})\n+    public void numFmtStrictGroupingNotUsed(String toParse) {\n+        \/\/ When grouping is not used, if a grouping separator is found,\n+        \/\/ a failure should occur\n+        dFmt.setGroupingUsed(false);\n+        int failIndex = toParse.indexOf(\n+                dFmt.getDecimalFormatSymbols().getGroupingSeparator());\n+        if (failIndex > -1) {\n+            failParse(dFmt, toParse, failIndex);\n+        } else {\n+            successParse(dFmt, toParse);\n+        }\n+        dFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ Exception should be thrown if decimal separator occurs anywhere\n+    \/\/ Don't pass badParseStrings for same reason as previous method.\n+    @ParameterizedTest\n+    @MethodSource({\"validParseStrings\", \"integerOnlyParseStrings\"})\n+    public void numFmtStrictIntegerOnlyUsed(String toParse) {\n+        \/\/ When integer only is true, if a decimal separator is found,\n+        \/\/ a failure should occur\n+        dFmt.setParseIntegerOnly(true);\n+        int failIndex = toParse.indexOf(dfs.getDecimalSeparator());\n+        if (failIndex > -1) {\n+            failParse(dFmt, toParse, failIndex);\n+        } else {\n+            successParse(dFmt, toParse);\n+        }\n+        dFmt.setParseIntegerOnly(false);\n+    }\n+\n+    \/\/ ---- CurrencyFormat tests ----\n+    @ParameterizedTest\n+    @MethodSource(\"currencyBadParseStrings\")\n+    public void currFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(cFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidParseStrings\")\n+    public void currFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cFmt, toParse));\n+    }\n+\n+    \/\/ ---- PercentFormat tests ----\n+    @ParameterizedTest\n+    @MethodSource(\"percentBadParseStrings\")\n+    public void percentFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(pFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidParseStrings\")\n+    public void percentFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(pFmt, toParse));\n+    }\n+\n+    \/\/ ---- CompactNumberFormat tests ----\n+    \/\/ Can match to both the decimalFormat patterns and the compact patterns\n+    \/\/ Thus we test leniency for both. Unlike the other tests, this test\n+    \/\/ is only ran against the US Locale and tests against data built with the\n+    \/\/ thousands format (K).\n+    @ParameterizedTest\n+    @MethodSource(\"compactBadParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        failParse(cmpctFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse));\n+    }\n+\n+    \/\/ Checks some odd leniency edge cases between matching of default pattern\n+    \/\/ and compact pattern.\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtEdgeParseTest() {\n+        \/\/ Uses a compact format with unique and non-empty prefix\/suffix for both\n+        \/\/ default and compact patterns\n+        CompactNumberFormat cnf = new CompactNumberFormat(\"a##0.0#b\", DecimalFormatSymbols\n+                .getInstance(Locale.US), new String[]{\"\", \"c0d\"});\n+        cnf.setStrict(true);\n+\n+        \/\/ Existing behavior of failed prefix parsing has errorIndex return\n+        \/\/ the beginning of prefix, even if the error occurred later in the prefix.\n+        \/\/ Prefix empty\n+        failParse(cnf, \"12345d\", 0);\n+        failParse(cnf, \"1b\", 0);\n+        \/\/ Prefix bad\n+        failParse(cnf, \"aa1d\", 0);\n+        failParse(cnf, \"cc1d\", 0);\n+        failParse(cnf, \"aa1b\", 0);\n+        failParse(cnf, \"cc1b\", 0);\n+\n+        \/\/ Suffix error index is always the start of the failed suffix\n+        \/\/ not necessarily where the error occurred in the suffix. This is\n+        \/\/ consistent with the prefix error index behavior.\n+        \/\/ Suffix empty\n+        failParse(cnf, \"a1\", 2);\n+        failParse(cnf, \"c1\", 2);\n+        \/\/ Suffix bad\n+        failParse(cnf, \"a1dd\", 2);\n+        failParse(cnf, \"c1dd\", 2);\n+        failParse(cnf, \"a1bb\", 2);\n+        failParse(cnf, \"c1bb\", 2);\n+    }\n+\n+    \/\/ Ensure that on failure, the original index of the PP remains the same\n+    @Test\n+    public void parsePositionIndexTest() {\n+        failParse(dFmt, localizeText(\"123,456,,789.00\"), 8, 4);\n+    }\n+\n+    \/\/ ---- Helper test methods ----\n+\n+    \/\/ Should parse entire String successfully, and return correctly parsed value.\n+    private double successParse(NumberFormat fmt, String toParse) {\n+        \/\/ For Strings that don't have grouping separators, we test them with\n+        \/\/ grouping off so that they do not fail under the expectation that\n+        \/\/ grouping symbols should occur\n+        if (!toParse.contains(String.valueOf(dfs.getGroupingSeparator())) &&\n+                !toParse.contains(String.valueOf(dfs.getMonetaryGroupingSeparator()))) {\n+            fmt.setGroupingUsed(false);\n+        }\n+        Number parsedValue = assertDoesNotThrow(() -> fmt.parse(toParse));\n+        ParsePosition pp = new ParsePosition(0);\n+        assertDoesNotThrow(() -> fmt.parse(toParse, pp));\n+        assertEquals(-1, pp.getErrorIndex(),\n+                \"ParsePosition ErrorIndex is not in correct location\");\n+        assertEquals(toParse.length(), pp.getIndex(),\n+                \"ParsePosition Index is not in correct location\");\n+        fmt.setGroupingUsed(true);\n+        return parsedValue.doubleValue();\n+    }\n+\n+    \/\/ Method which tests a parsing failure. Either a ParseException is thrown,\n+    \/\/ or null is returned depending on which parse method is invoked. When failing,\n+    \/\/ index should remain the initial index set to the ParsePosition while\n+    \/\/ errorIndex is the index of failure.\n+    private void failParse(NumberFormat fmt, String toParse, int expectedErrorIndex) {\n+        failParse(fmt, toParse, expectedErrorIndex, 0);\n+    }\n+\n+    \/\/ Variant to check non 0 initial parse index\n+    private void failParse(NumberFormat fmt, String toParse,\n+                           int expectedErrorIndex, int initialParseIndex) {\n+        ParsePosition pp = new ParsePosition(initialParseIndex);\n+        assertThrows(ParseException.class, () -> fmt.parse(toParse));\n+        assertNull(fmt.parse(toParse, pp));\n+        assertEquals(expectedErrorIndex, pp.getErrorIndex());\n+        assertEquals(initialParseIndex, pp.getIndex());\n+    }\n+\n+    \/\/ ---- Data Providers ----\n+    \/\/ These data providers use US locale grouping and decimal separators\n+    \/\/ for readability, however, the data is tested against multiple locales\n+    \/\/ and is converted appropriately at runtime.\n+\n+    \/\/ Strings that should fail when parsed with strict leniency.\n+    \/\/ Given as Arguments<String, expectedErrorIndex>\n+    private static Stream<Arguments> badParseStrings() {\n+        return Stream.of(\n+                \/\/ Grouping symbol focus\n+                \/\/ Grouping symbol right before decimal\n+                Arguments.of(\"1,.\", 2),\n+                Arguments.of(\"1,.1\", 2),\n+                \/\/ Does not end with proper grouping size\n+                Arguments.of(\"1,1\", 2),\n+                Arguments.of(\"1,11\", 3),\n+                Arguments.of(\"1,1111\", 5),\n+                Arguments.of(\"11,111,11\", 8),\n+                \/\/ Does not end with proper grouping size (with decimal)\n+                Arguments.of(\"1,1.\", 3),\n+                Arguments.of(\"1,11.\", 4),\n+                Arguments.of(\"1,1111.\", 5),\n+                Arguments.of(\"11,111,11.\", 9),\n+                \/\/ Ends on a grouping symbol\n+                \/\/ Suffix matches correctly, so failure is on the \",\"\n+                Arguments.of(\"11,111,\", 6),\n+                Arguments.of(\"11,\", 2),\n+                Arguments.of(\"11,,\", 3),\n+                \/\/ Ends with grouping symbol. Failure should occur on grouping,\n+                \/\/ even if non recognized char after\n+                Arguments.of(\"11,a\", 2),\n+                \/\/ Improper grouping size (with decimal and digits after)\n+                Arguments.of(\"1,1.1\", 3),\n+                Arguments.of(\"1,11.1\", 4),\n+                Arguments.of(\"1,1111.1\", 5),\n+                Arguments.of(\"11,111,11.1\", 9),\n+                \/\/ Subsequent grouping symbols\n+                Arguments.of(\"1,,1\", 2),\n+                Arguments.of(\"1,1,,1\", 3),\n+                Arguments.of(\"1,,1,1\", 2),\n+                \/\/ Invalid grouping sizes\n+                Arguments.of(\"1,11,111\", 4),\n+                Arguments.of(\"11,11,111\", 5),\n+                Arguments.of(\"111,11,11\", 6),\n+                \/\/ First group is too large\n+                Arguments.of(\"1111,11,111\", 3),\n+                Arguments.of(\"00000,11,111\", 3),\n+                Arguments.of(\"111,1111111111\", 7),\n+                Arguments.of(\"111,11\", 5),\n+                Arguments.of(\"111,1111111111.\", 7),\n+                Arguments.of(\"111,11.\", 6),\n+                Arguments.of(\"111,1111111111.\", 7),\n+                \/\/ Starts with grouping symbol\n+                Arguments.of(\",111,,1,1\", 0),\n+                Arguments.of(\",1\", 0),\n+                Arguments.of(\",,1\", 0),\n+                \/\/ Leading Zeros (not digits)\n+                Arguments.of(\"000,1,1\", 5),\n+                Arguments.of(\"000,111,11,,1\", 10),\n+                Arguments.of(\"0,000,1,,1,1\", 7),\n+                \/\/ Bad suffix\n+                Arguments.of(\"1a\", 1),\n+                \/\/ Bad chars in numerical portion\n+                Arguments.of(\"123a4\", 3),\n+                Arguments.of(\"123.4a5\", 5),\n+                \/\/ Variety of edge cases\n+                Arguments.of(\"123,456.77a\", 10),\n+                Arguments.of(\"1,234a\", 5),\n+                Arguments.of(\"1,.a\", 2),\n+                Arguments.of(\"1.a\", 2),\n+                Arguments.of(\".22a\", 3),\n+                Arguments.of(\".1a1\", 2),\n+                Arguments.of(\"1,234,a\", 5))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n+    }\n+\n+    \/\/ Strings that should parse fully. (Both in lenient and strict)\n+    \/\/ Given as Arguments<String, expectedParsedNumber>\n+    private static Stream<Arguments> validParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"1,234.00\", 1234d),\n+                Arguments.of(\"1,234.0\", 1234d),\n+                Arguments.of(\"1,234.\", 1234d),\n+                Arguments.of(\"1\", 1d),\n+                Arguments.of(\"10\", 10d),\n+                Arguments.of(\"100\", 100d),\n+                Arguments.of(\"1000\", 1000d),\n+                Arguments.of(\"1,000\", 1000d),\n+                Arguments.of(\"10,000\", 10000d),\n+                Arguments.of(\"10000\", 10000d),\n+                Arguments.of(\"100,000\", 100000d),\n+                Arguments.of(\"1,000,000\", 1000000d),\n+                Arguments.of(\"10,000,000\", 10000000d))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n+    }\n+\n+    \/\/ Separate test data set for integer only. Can not use \"badParseStrings\", as\n+    \/\/ there is test data where the failure may occur from some other issue,\n+    \/\/ not related to grouping\n+    private static Stream<Arguments> integerOnlyParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"234.a\"),\n+                Arguments.of(\"234.a1\"),\n+                Arguments.of(\"234.1\"),\n+                Arguments.of(\"234.1a\"),\n+                Arguments.of(\"234.\"))\n+                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0]))));\n+    }\n+\n+    \/\/ Separate test data set for no grouping. Can not use \"badParseStrings\", as\n+    \/\/ there is test data where the failure may occur from some other issue,\n+    \/\/ not related to grouping\n+    private static Stream<Arguments> noGroupingParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"12,34.a\"),\n+                Arguments.of(\"123,.a1\"),\n+                Arguments.of(\",1234\"),\n+                Arguments.of(\"123,\"))\n+                .map(args -> Arguments.of(localizeText(String.valueOf(args.get()[0]))));\n+    }\n+\n+    \/\/ Negative variant of a numerical format\n+    private static Stream<Arguments> negativeBadParseStrings() {\n+        return badParseStrings().map(args -> Arguments.of(\n+                dFmt.getNegativePrefix() + args.get()[0] + dFmt.getNegativeSuffix(),\n+                (int)args.get()[1] + dFmt.getNegativePrefix().length())\n+        );\n+    }\n+\n+    \/\/ Negative variant of a numerical format\n+    private static Stream<Arguments> negativeValidParseStrings() {\n+        return validParseStrings().map(args -> Arguments.of(\n+                dFmt.getNegativePrefix() + args.get()[0] + dFmt.getNegativeSuffix(),\n+                (double) args.get()[1] * -1)\n+        );\n+    }\n+\n+    \/\/ Same as original with a percent prefix\/suffix.\n+    \/\/ Additionally, increment expected error index if a prefix is added\n+    private static Stream<Arguments> percentBadParseStrings() {\n+        return badParseStrings().map(args -> Arguments.of(\n+                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                        (int)args.get()[1] + pFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    \/\/ Expected parsed value should be \/ 100 as it is a percent format.\n+    private static Stream<Arguments> percentValidParseStrings() {\n+        return validParseStrings().map(args -> Arguments.of(\n+                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                (double)args.get()[1] \/ 100.0)\n+        );\n+    }\n+\n+    \/\/ Same as original with a currency prefix\/suffix, but replace separators\n+    \/\/ with monetary variants. Additionally, increment expected error index\n+    \/\/ if a prefix is added\n+    private static Stream<Arguments> currencyBadParseStrings() {\n+        return badParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                (int)args.get()[1] + cFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> currencyValidParseStrings() {\n+        return validParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1])\n+        );\n+    }\n+\n+    \/\/ Compact Pattern Data Provider provides test input for both DecimalFormat patterns\n+    \/\/ and the compact patterns. As there is no method to retrieve compact patterns,\n+    \/\/ thus test only against US English locale, and use a hard coded K - 1000\n+    private static Stream<Arguments> compactBadParseStrings() {\n+        return Stream.concat(\n+                badParseStrings().map(args -> Arguments.of(args.get()[0], args.get()[1])),\n+                badParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\", args.get()[1]))\n+        );\n+    }\n+\n+    private static Stream<Arguments> compactValidParseStrings() {\n+        return Stream.concat(\n+                validParseStrings().map(args -> Arguments.of(\n+                        args.get()[0], args.get()[1])),\n+                validParseStrings().map(args -> Arguments.of(\n+                        args.get()[0] + \"K\", (double) args.get()[1] * 1000))\n+        );\n+    }\n+\n+    \/\/ Replace the grouping and decimal separators with localized variants\n+    \/\/ Used during localization of data\n+    private static String localizeText(String text) {\n+        \/\/ As this is a single pass conversion, this is safe for multiple replacement,\n+        \/\/ even if a ',' could be a decimal separator for a locale.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < text.length(); i++) {\n+            char c = text.charAt(i);\n+            if (c == ',') {\n+                sb.append(dfs.getGroupingSeparator());\n+            } else if (c == '.') {\n+                sb.append(dfs.getDecimalSeparator());\n+            } else if (c == '0') {\n+                sb.append(dfs.getZeroDigit());\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictParseTest.java","additions":525,"deletions":0,"binary":false,"changes":525,"status":"added"}]}