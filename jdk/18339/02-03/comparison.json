{"files":[{"patch":"@@ -351,0 +351,9 @@\n+    \/**\n+     * True if this {@code CompactNumberFormat} will parse numbers with strict\n+     * leniency.\n+     *\n+     * @serial\n+     * @since 23\n+     *\/\n+    private boolean parseStrict = false;\n+\n@@ -1510,0 +1519,2 @@\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n+     * <p>\n@@ -1516,2 +1527,4 @@\n-     *   <li> The default or a compact prefix is not found, for example: \"{@code $}\"\n-     *   <li> The default or a compact suffix is not found, for example: \"{@code K}\"\n+     *   <li> The default or a compact prefix is not found. For example, the {@code\n+     *   Locale.US} currency format prefix: \"{@code $}\"\n+     *   <li> The default or a compact suffix is not found. For example, a {@code Locale.US}\n+     *   {@link NumberFormat.Style#SHORT} compact suffix: \"{@code K}\"\n@@ -1729,1 +1742,1 @@\n-            if (isStrict()) {\n+            if (parseStrict) {\n@@ -1916,1 +1929,1 @@\n-            return isStrict() ? matchAffix(text, position, suffix, defaultSuffix, matchedSuffix)\n+            return parseStrict ? matchAffix(text, position, suffix, defaultSuffix, matchedSuffix)\n@@ -1968,1 +1981,1 @@\n-                if (isStrict()) {\n+                if (parseStrict) {\n@@ -1981,1 +1994,1 @@\n-                if (isStrict()) {\n+                if (parseStrict) {\n@@ -1997,1 +2010,1 @@\n-            if (isStrict() ? endsWithPosSuffix : containsPosSuffix) {\n+            if (parseStrict ? endsWithPosSuffix : containsPosSuffix) {\n@@ -2006,1 +2019,1 @@\n-            if (isStrict() ? endsWithNegSuffix : containsNegSuffix) {\n+            if (parseStrict ? endsWithNegSuffix : containsNegSuffix) {\n@@ -2124,1 +2137,1 @@\n-        decimalFormat.setStrict(isStrict());\n+        decimalFormat.setStrict(parseStrict);\n@@ -2364,0 +2377,19 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @see #setStrict(boolean)\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public boolean isStrict() {\n+        return parseStrict;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @see #setStrict(boolean)\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n@@ -2367,1 +2399,1 @@\n-        super.setStrict(strict);\n+        parseStrict = strict; \/\/ don't call super, default is UOE\n@@ -2427,1 +2459,2 @@\n-                && parseBigDecimal == other.parseBigDecimal;\n+                && parseBigDecimal == other.parseBigDecimal\n+                && parseStrict == other.parseStrict;\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":44,"deletions":11,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2146,0 +2146,2 @@\n+     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n+     * <p>\n@@ -2152,2 +2154,4 @@\n-     *   <li> The prefix is not found, for example: \"{@code $}\"\n-     *   <li> The suffix is not found, for example: \"{@code %}\"\n+     *   <li> The prefix is not found. For example, a {@code Locale.US} currency\n+     *   format prefix: \"{@code $}\"\n+     *   <li> The suffix is not found. For example, a {@code Locale.US} percent\n+     *   format suffix: \"{@code %}\"\n@@ -2406,1 +2410,1 @@\n-                gotPositive = isStrict() ? endsWithPosSuffix : containsPosSuffix;\n+                gotPositive = parseStrict ? endsWithPosSuffix : containsPosSuffix;\n@@ -2413,1 +2417,1 @@\n-                gotNegative = isStrict() ? endsWithNegSuffix : containsNegSuffix;\n+                gotNegative = parseStrict ? endsWithNegSuffix : containsNegSuffix;\n@@ -2519,1 +2523,1 @@\n-                if (isStrict() && isGroupingUsed() && position == startPos + groupingSize\n+                if (parseStrict && isGroupingUsed() && position == startPos + groupingSize\n@@ -2555,1 +2559,1 @@\n-                    if (isStrict() && isGroupingViolation(position, prevSeparatorIndex)) {\n+                    if (parseStrict && isGroupingViolation(position, prevSeparatorIndex)) {\n@@ -2566,1 +2570,1 @@\n-                    if (isStrict()) {\n+                    if (parseStrict) {\n@@ -2615,1 +2619,1 @@\n-            if (isStrict()) {\n+            if (parseStrict) {\n@@ -2978,0 +2982,24 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @see #setStrict(boolean)\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public boolean isStrict() {\n+        return parseStrict;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @see #setStrict(boolean)\n+     * @see #parse(String, ParsePosition)\n+     * @since 23\n+     *\/\n+    @Override\n+    public void setStrict(boolean strict) {\n+        parseStrict = strict;\n+    }\n+\n@@ -3081,1 +3109,2 @@\n-            && symbols.equals(other.symbols);\n+            && symbols.equals(other.symbols)\n+            && parseStrict == other.parseStrict;\n@@ -4266,0 +4295,9 @@\n+    \/**\n+     * True if this {@code DecimalFormat} will parse numbers with strict\n+     * leniency.\n+     *\n+     * @serial\n+     * @since 23\n+     *\/\n+    private boolean parseStrict = false;\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":47,"deletions":9,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -109,0 +109,3 @@\n+ * <p> Subclasses may also consider implementing leniency when parsing.\n+ * The definition of leniency should be delegated to the subclass.\n+ *\n@@ -225,2 +228,0 @@\n-     * @apiNote Subclasses may consider implementing leniency when parsing.\n-     *          The definition of leniency should be delegated to the subclass.\n@@ -240,3 +241,0 @@\n-     * @implNote This implementation is equivalent to calling {@code parseObject(source,\n-     * new ParsePosition(0)} and throwing a {@code ParseException} if parsing fails,\n-     * instead of returning {@code null}.\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -104,2 +104,2 @@\n- * <li> {@link #setStrict(boolean)}; when true, parsing will be done strictly.\n- * See the {@link ##leniency Leniency Section}\n+ * <li> {@link #setStrict(boolean)}, (only if overriden and implemented); when\n+ * true, parsing will be done strictly. See the {@link ##leniency Leniency Section}\n@@ -151,11 +151,14 @@\n- * {@code NumberFormat} can parse both strictly and leniently. By default, parsing\n- * is lenient, and leniency can be adjusted using {@link #setStrict(boolean)}. Lenient\n- * parsing should be used when attempting to parse a number out of a String\n- * that contains non-expected values. For example, parsing the number {@code 1000}\n- * out of the String \"1,000 people\". Strict parsing should be used when\n- * attempting to ensure a String adheres exactly to the locale's conventions, and\n- * can thus serve to validate input. For example, successfully parsing the number\n- * {@code 1000.55} out of the String \"1.000,55\" confirms the String\n- * adhered to the {@link Locale#GERMAN German} numerical conventions. See the\n- * {@link #parse(String, ParsePosition)} method for further details on behavioral\n- * differences between leniency modes.\n+ * {@code NumberFormat} by default, parses leniently. Subclasses may consider\n+ * implementing strict parsing and as such, overriding and providing\n+ * implementations for the optional {@link #isStrict()} and {@link\n+ * #setStrict(boolean)} methods.\n+ * <p>\n+ * Lenient parsing should be used when attempting to parse a number\n+ * out of a String that contains non-numerical or non-format related values.\n+ * For example, using a {@link Locale#US} currency format to parse the number\n+ * {@code 1000} out of the String \"$1000 was paid\".\n+ * <p>\n+ * Strict parsing should be used when attempting to ensure a String adheres exactly\n+ * to a locale's conventions, and can thus serve to validate input. For example, successfully\n+ * parsing the number {@code 1000.55} out of the String \"1.000,55\" confirms the String\n+ * exactly adhered to the {@link Locale#GERMANY} numerical conventions.\n@@ -274,2 +277,0 @@\n-     * <p>\n-     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n@@ -391,1 +392,0 @@\n-     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n@@ -411,1 +411,0 @@\n-     * Parsing can be done in either a strict or lenient manner, by default it is lenient.\n@@ -413,3 +412,0 @@\n-     * @implNote This is equivalent to calling {@code parse(source,\n-     * new ParsePosition(0)} and throwing a {@code ParseException} if parsing fails,\n-     * instead of returning {@code null}.\n@@ -464,0 +460,5 @@\n+     * @implSpec The default implementation always throws {@code\n+     * UnsupportedOperationException}. Subclasses should override this method\n+     * when implementing strict parsing.\n+     * @throws    UnsupportedOperationException if the implementation of this\n+     *            method does not support this operation\n@@ -469,1 +470,1 @@\n-        return parseStrict;\n+        throw new UnsupportedOperationException();\n@@ -476,0 +477,3 @@\n+     * @implSpec The default implementation always throws {@code\n+     * UnsupportedOperationException}. Subclasses should override this method\n+     * when implementing strict parsing.\n@@ -478,0 +482,2 @@\n+     * @throws    UnsupportedOperationException if the implementation of this\n+     *            method does not support this operation\n@@ -483,2 +489,1 @@\n-        \/\/ setStrict method over setLenient, as the default behavior is lenient\n-        parseStrict = strict;\n+        throw new UnsupportedOperationException();\n@@ -783,1 +788,1 @@\n-        return (maximumIntegerDigits == other.maximumIntegerDigits\n+        return maximumIntegerDigits == other.maximumIntegerDigits\n@@ -788,2 +793,1 @@\n-            && parseIntegerOnly == other.parseIntegerOnly\n-            && parseStrict == other.parseStrict);\n+            && parseIntegerOnly == other.parseIntegerOnly;\n@@ -1206,10 +1210,0 @@\n-\n-    \/**\n-     * True if this {@code NumberFormat} will parse numbers with strict leniency.\n-     *\n-     * @serial\n-     * @since 23\n-     * @see #setStrict(boolean)\n-     * @see #isStrict()\n-     *\/\n-    private boolean parseStrict = false;\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":30,"deletions":36,"binary":false,"changes":66,"status":"modified"}]}