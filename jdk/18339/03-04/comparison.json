{"files":[{"patch":"@@ -1510,1 +1510,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc NumberFormat}\n@@ -1583,1 +1583,0 @@\n-     * @see #setStrict(boolean)\n@@ -2378,1 +2377,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc NumberFormat}\n@@ -2390,1 +2389,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc NumberFormat}\n@@ -2392,1 +2391,1 @@\n-     * @see #setStrict(boolean)\n+     * @see #isStrict()\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2144,1 +2144,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc NumberFormat}\n@@ -2212,1 +2212,0 @@\n-     * @see #setStrict(boolean)\n@@ -2983,1 +2982,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc NumberFormat}\n@@ -2995,1 +2994,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc NumberFormat}\n@@ -2997,1 +2996,1 @@\n-     * @see #setStrict(boolean)\n+     * @see #isStrict()\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -240,0 +240,1 @@\n+     * This method may not use the entire text of the given string.\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,5 +62,2 @@\n- * numbers in a localized manner. This enables code that can be completely\n- * independent of the locale conventions for decimal points, thousands-separators,\n- * whether the number format is even decimal, or even the particular decimal\n- * digits used. For example, this class could be used to format a number\n- * according to French numerical conventions.\n+ * numbers. {@code NumberFormat} also provides methods for determining\n+ * which locales have number formats, and what their names are.\n@@ -68,16 +65,5 @@\n- * <h2>Getting a Format<\/h2>\n- * To format a number for the default Locale, use one of the static factory class methods.\n- * The following examples all format the {@code Number} \"2000.50\" with the {@link\n- * java.util.Locale#US US} locale as the default.\n- * <ul>\n- * <li> Use {@link #getInstance()} or {@link #getNumberInstance()} to get\n- * a number format. For example, {@code \"2,000.5\"}.\n- * <li> Use {@link #getIntegerInstance()} to get an integer number format.\n- * For example, {@code \"2,000\"}.\n- * <li> Use {@link #getCurrencyInstance} to get a currency number format.\n- * For example, {@code \"$2,000.50\"}.\n- * <li> Use {@link #getCompactNumberInstance} to get a compact number format\n- * to format a number in shorter form. For example, {@code \"2K\"}.\n- * <li> Use {@link #getPercentInstance} to get a format for displaying percentages.\n- * For example, {@code \"200,050%\"}.\n- * <\/ul>\n+ * <p>\n+ * {@code NumberFormat} helps you to format and parse numbers for any locale.\n+ * Your code can be completely independent of the locale conventions for\n+ * decimal points, thousands-separators, or even the particular decimal\n+ * digits used, or whether the number format is even decimal.\n@@ -85,4 +71,27 @@\n- * Alternatively, if a number format for a different locale is required, use\n- * one of the factory class method variants that take {@code locale} as a parameter,\n- * for example, {@link #getIntegerInstance(Locale)}. Use {@link #getAvailableLocales()}\n- * to determine which locales support number formats,\n+ * <p>\n+ * To format a number for the current Locale, use one of the factory\n+ * class methods:\n+ * <blockquote>\n+ * {@snippet lang=java :\n+ * myString = NumberFormat.getInstance().format(myNumber);\n+ * }\n+ * <\/blockquote>\n+ * If you are formatting multiple numbers, it is\n+ * more efficient to get the format and use it multiple times so that\n+ * the system doesn't have to fetch the information about the local\n+ * language and country conventions multiple times.\n+ * <blockquote>\n+ * {@snippet lang=java :\n+ * NumberFormat nf = NumberFormat.getInstance();\n+ * for (var myNumber : numbers) {\n+ *     output.println(nf.format(myNumber) + \"; \");\n+ * }\n+ * }\n+ * <\/blockquote>\n+ * To format a number for a different Locale, specify it in the\n+ * call to {@code getInstance}.\n+ * <blockquote>\n+ * {@snippet lang=java :\n+ * NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);\n+ * }\n+ * <\/blockquote>\n@@ -90,2 +99,1 @@\n- * <h3>Locale Extensions<\/h3>\n- * <p>If the locale used for formatting contains \"nu\" (numbers) and\/or \"rg\" (region override)\n+ * <p>If the locale contains \"nu\" (numbers) and\/or \"rg\" (region override)\n@@ -97,17 +105,15 @@\n- * <h2>Customizing Formatting and Parsing<\/h2>\n- * {@code NumberFormat} provides formatting through the {@code format},\n- * and parsing through the {@code parse} methods. For further customization\n- * of formatting and parsing behavior, use any of the following instance methods.\n- * <ul>\n- * <li> {@link #setParseIntegerOnly(boolean)}; when true, will only return the\n- * integer portion of the number parsed from the String.\n- * <li> {@link #setStrict(boolean)}, (only if overriden and implemented); when\n- * true, parsing will be done strictly. See the {@link ##leniency Leniency Section}\n- * <li> {@link #setMinimumFractionDigits}; Use to adjust the expected digits when\n- * formatting. Use any of the other minimum\/maximum or fraction\/integer setter methods\n- * in the same manner.\n- * <li> {@link #setGroupingUsed}; when true, formatted numbers will be displayed\n- * with grouping separators. Additionally, when false, parsing will not expect\n- * grouping separators in the parsed String, and may exit early or fail depending\n- * on leniency.\n- * <\/ul>\n+ * <p>You can also use a {@code NumberFormat} to parse numbers:\n+ * <blockquote>\n+ * {@snippet lang=java :\n+ * myNumber = nf.parse(myString);\n+ * }\n+ * <\/blockquote>\n+ * Use {@code getInstance} or {@code getNumberInstance} to get the\n+ * normal number format. Use {@code getIntegerInstance} to get an\n+ * integer number format. Use {@code getCurrencyInstance} to get the\n+ * currency number format. Use {@code getCompactNumberInstance} to get the\n+ * compact number format to format a number in shorter form. For example,\n+ * {@code 2000} can be formatted as {@code \"2K\"} in\n+ * {@link java.util.Locale#US US locale}. Use {@code getPercentInstance}\n+ * to get a format for displaying percentages. With this format, a fraction\n+ * like 0.53 is displayed as 53%.\n@@ -116,7 +122,29 @@\n- * To provide more control over the format or parsing, cast the {@code\n- * NumberFormat} you get from the factory methods to a {@code DecimalFormat} or\n- * {@code CompactNumberFormat} depending on the factory method used. For example,\n- * cast to {@code DecimalFormat} to call {@link DecimalFormat#setGroupingSize(int)}\n- * to change the desired digits between grouping separators.\n- * While this will work for the vast majority of locales; a {@code\n- * try} block should be used in case a non-supported locale is encountered.\n+ * You can also control the display of numbers with such methods as\n+ * {@code setMinimumFractionDigits}.\n+ * If you want even more control over the format or parsing,\n+ * or want to give your users more control,\n+ * you can try casting the {@code NumberFormat} you get from the factory methods\n+ * to a {@code DecimalFormat} or {@code CompactNumberFormat} depending on\n+ * the factory method used. This will work for the vast majority of locales;\n+ * just remember to put it in a {@code try} block in case you encounter\n+ * an unusual one.\n+ *\n+ * <p>\n+ * NumberFormat and DecimalFormat are designed such that some controls\n+ * work for formatting and others work for parsing.  The following is\n+ * the detailed description for each these control methods,\n+ * <p>\n+ * setParseIntegerOnly : only affects parsing, e.g.\n+ * if true,  \"3456.78\" &rarr; 3456 (and leaves the parse position just after index 6)\n+ * if false, \"3456.78\" &rarr; 3456.78 (and leaves the parse position just after index 8)\n+ * This is independent of formatting.  If you want to not show a decimal point\n+ * where there might be no digits after the decimal point, use\n+ * setDecimalSeparatorAlwaysShown.\n+ * <p>\n+ * setDecimalSeparatorAlwaysShown : only affects formatting, and only where\n+ * there might be no digits after the decimal point, such as with a pattern\n+ * like \"#,##0.##\", e.g.,\n+ * if true,  3456.00 &rarr; \"3,456.\"\n+ * if false, 3456.00 &rarr; \"3456\"\n+ * This is independent of parsing.  If you want parsing to stop at the decimal\n+ * point, use setParseIntegerOnly.\n@@ -159,1 +187,1 @@\n- * {@code 1000} out of the String \"$1000 was paid\".\n+ * {@code 1000} out of the String \"$1,000.00 was paid\".\n@@ -166,2 +194,2 @@\n- * <h3><a id=\"synchronization\">Synchronization<\/a><\/h3>\n- * {@code NumberFormat} is not synchronized.\n+ * <h2><a id=\"synchronization\">Synchronization<\/a><\/h2>\n+ * Number formats are generally not synchronized.\n@@ -172,3 +200,1 @@\n- * @implSpec\n- * <h4>Null Parameter Handling<\/h4>\n- * The {@link #format(double, StringBuffer, FieldPosition)},\n+ * @implSpec The {@link #format(double, StringBuffer, FieldPosition)},\n@@ -181,1 +207,1 @@\n- * <h4>Default RoundingMode<\/h4>\n+ * <p>\n@@ -276,1 +302,1 @@\n-     * {@inheritDoc}\n+     * {@inheritDoc Format}\n@@ -380,5 +406,6 @@\n-     * This method attempts to parse text starting at the index given by\n-     * {@code pos}. If parsing succeeds, then the index of {@code parsePosition} is updated\n-     * to the index after the last character used (parsing does not necessarily\n-     * use all characters up to the end of the string), and the parsed number is\n-     * returned. The updated {@code parsePosition} can be used to indicate the starting\n+     * This method attempts to parse text starting at the index given by the\n+     * {@code ParsePosition}. If parsing succeeds, then the index of the {@code\n+     * ParsePosition} is updated to the index after the last character used\n+     * (parsing does not necessarily use all characters up to the end of the\n+     * string), and the parsed number is returned. The updated {@code\n+     * ParsePosition} can be used to indicate the starting\n@@ -386,2 +413,2 @@\n-     * index of {@code parsePosition} is not changed, the error index of {@code\n-     * parsePosition} is set to the index of the character where the error\n+     * index of the {@code ParsePosition} is not changed, the error index of the\n+     * {@code ParsePosition} is set to the index of the character where the error\n@@ -401,2 +428,0 @@\n-     * @see #isParseIntegerOnly()\n-     * @see #isGroupingUsed()\n@@ -417,2 +442,0 @@\n-     * @see #isParseIntegerOnly()\n-     * @see #isGroupingUsed()\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":93,"deletions":70,"binary":false,"changes":163,"status":"modified"}]}