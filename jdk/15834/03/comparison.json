{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.function.BiConsumer;\n@@ -36,0 +37,1 @@\n+import java.util.function.Consumer;\n@@ -659,0 +661,18 @@\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public void forEach(Consumer<? super E> action) {\n+            action.accept(e0); \/\/ implicit null check\n+            if (e1 != EMPTY) {\n+                action.accept((E) e1);\n+            }\n+        }\n+\n+        @Override\n+        public Spliterator<E> spliterator() {\n+            if (e1 == EMPTY) {\n+                return Collections.singletonSpliterator(e0);\n+            } else {\n+                return super.spliterator();\n+            }\n+        }\n@@ -898,0 +918,20 @@\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public void forEach(Consumer<? super E> action) {\n+            if (e1 == EMPTY) {\n+                action.accept(e0); \/\/ implicit null check\n+            } else {\n+                action.accept(REVERSE ? (E)e1 : e0); \/\/ implicit null check\n+                action.accept(REVERSE ? e0 : (E)e1);\n+            }\n+        }\n+\n+        @Override\n+        public Spliterator<E> spliterator() {\n+            if (e1 == EMPTY) {\n+                return Collections.singletonSpliterator(e0);\n+            } else {\n+                return super.spliterator();\n+            }\n+        }\n@@ -1161,0 +1201,5 @@\n+\n+        @Override\n+        public void forEach(BiConsumer<? super K, ? super V> action) {\n+            action.accept(k0, v0); \/\/ implicit null check\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- *          4802647 7123424 8024709 8193128\n+ *          4802647 7123424 8024709 8193128 8327858\n@@ -482,0 +482,2 @@\n+        testForEachMatch(c);\n+        testSpliteratorMatch(c);\n@@ -543,0 +545,33 @@\n+    \/\/ Ensures forEach supplies in the same order as the iterator\n+    private static <T> void testForEachMatch(Collection<T> c) {\n+        var itr = c.iterator();\n+        int[] index = {0};\n+        c.forEach(item -> {\n+            T itrNext = null;\n+            if (!itr.hasNext() || !Objects.equals(itrNext = itr.next(), item)) {\n+                fail(\"forEach and iterator mismatch at \" + index[0] + \" forEach: \" + item + \", itr: \" + itrNext);\n+            }\n+            index[0]++;\n+        });\n+        if (itr.hasNext()) {\n+            fail(\"forEach and iterator mismatch at tail, extras in itr\");\n+        }\n+    }\n+\n+    \/\/ Ensures spliterator returns in the same order as the iterator\n+    private static <T> void testSpliteratorMatch(Collection<T> c) {\n+        var itr = c.iterator();\n+        var split = c.spliterator();\n+        int[] index = {0};\n+        split.forEachRemaining(item -> {\n+            T itrNext = null;\n+            if (!itr.hasNext() || !Objects.equals(itrNext = itr.next(), item)) {\n+                fail(\"iterator and spliterator mismatch at \" + index[0] + \" spliterator: \" + item + \", itr: \" + itrNext);\n+            }\n+            index[0]++;\n+        });\n+        if (itr.hasNext()) {\n+            fail(\"iterator and spliterator mismatch at tail, extra item in itr\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/Collection\/MOAT.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -300,0 +300,44 @@\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void forEachOverSet(Blackhole bh) {\n+        forEachSet(bh, fs4);\n+        forEachSet(bh, s1);\n+        forEachSet(bh, s3);\n+        forEachSet(bh, fs2);\n+        forEachSet(bh, s0);\n+    }\n+\n+    public void forEachSet(Blackhole bh, Set<String> coll) {\n+        coll.forEach(bh::consume);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void iterateOverList(Blackhole bh) {\n+        iterateList(bh, fl4);\n+        iterateList(bh, fl1);\n+        iterateList(bh, l3);\n+        iterateList(bh, l0);\n+        iterateList(bh, fl2);\n+    }\n+\n+    public void iterateList(Blackhole bh, List<String> coll) {\n+        for (String s : coll) {\n+            bh.consume(s);\n+        }\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void forEachOverList(Blackhole bh) {\n+        forEachList(bh, fl4);\n+        forEachList(bh, fl1);\n+        forEachList(bh, l3);\n+        forEachList(bh, l0);\n+        forEachList(bh, fl2);\n+    }\n+\n+    public void forEachList(Blackhole bh, List<String> coll) {\n+        coll.forEach(bh::consume);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ImmutableColls.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"}]}