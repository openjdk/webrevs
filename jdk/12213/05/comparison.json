{"files":[{"patch":"@@ -201,0 +201,1 @@\n+bool current_log_asynchronous();\n","filename":"src\/hotspot\/share\/logging\/log.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -212,0 +212,4 @@\n+bool current_log_asynchronous() {\n+  return AsyncLogWriter::instance() != nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,12 +72,1 @@\n-  struct RemoveAll {\n-    bool do_entry(const JvmtiTagMapKey& entry, const jlong& tag) {\n-      return true;\n-    }\n-  } remove_all;\n-  \/\/ The unlink method of ResourceHashTable gets a pointer to a type whose 'do_entry(K,V)' method is callled\n-  \/\/ while iterating over all the elements of the table. If the do_entry() method returns true the element\n-  \/\/ will be removed.\n-  \/\/ In this case, we always return true from do_entry to clear all the elements.\n-  _table.unlink(&remove_all);\n-\n-  assert(_table.number_of_entries() == 0, \"should have removed all entries\");\n+  _table.unlink_all();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"logging\/log.hpp\"\n@@ -99,0 +100,37 @@\n+  \/\/ internal template function(Node* node, Node**& ptr) -> bool\n+  \/\/ If it returns true, node is deleted.\n+  template<typename Function>\n+  void unlink_impl(Function function) {\n+    const unsigned sz = table_size();\n+    const int entries = _number_of_entries;\n+    int cnt = _number_of_entries;\n+    unsigned int index = 0;\n+\n+    for (; cnt > 0 && index < sz; index++) {\n+      Node** ptr = bucket_at(index);\n+      Node* node = *ptr;\n+\n+      while (node != nullptr) {\n+        bool clean = function(node, ptr);\n+\n+        if (clean) {\n+          Node* prev = node;\n+          node = node->_next;\n+          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+            delete prev;\n+          }\n+          _number_of_entries--;\n+        } else {\n+          node = node->_next;\n+        }\n+\n+        --cnt;\n+        assert(cnt > 0 || node == nullptr, \"sanity check\");\n+      }\n+    }\n+    if (!current_log_asynchronous()) {\n+      log_debug(hashtables)(\"ResourceHashtableBase table_size = %d, break at %d, removed %d out of %d\",\n+                            sz, index, (entries - _number_of_entries), entries);\n+    }\n+  }\n+\n@@ -107,11 +145,4 @@\n-      Node* const* bucket = table();\n-      const unsigned sz = table_size();\n-      while (bucket < bucket_at(sz)) {\n-        Node* node = *bucket;\n-        while (node != nullptr) {\n-          Node* cur = node;\n-          node = node->_next;\n-          delete cur;\n-        }\n-        ++bucket;\n-      }\n+      auto wrapper = [&](Node* const node, Node** ptr) {\n+        return true;\n+      };\n+      unlink_impl(wrapper);\n@@ -266,16 +297,6 @@\n-    const unsigned sz = table_size();\n-    for (unsigned index = 0; index < sz; index++) {\n-      Node** ptr = bucket_at(index);\n-      while (*ptr != nullptr) {\n-        Node* node = *ptr;\n-        \/\/ do_entry must clean up the key and value in Node.\n-        bool clean = iter->do_entry(node->_key, node->_value);\n-        if (clean) {\n-          *ptr = node->_next;\n-          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-            delete node;\n-          }\n-          _number_of_entries --;\n-        } else {\n-          ptr = &(node->_next);\n-        }\n+    auto wrapper = [&](Node* const node, Node**& ptr) {\n+      bool clean = iter->do_entry(node->_key, node->_value);\n+      if (clean) {\n+        *ptr = node->_next;\n+      } else {\n+        ptr = &(node->_next);\n@@ -283,1 +304,35 @@\n-    }\n+      return clean;\n+    };\n+\n+    unlink_impl(wrapper);\n+  }\n+\n+  \/\/ function is a callable(lambda or functor) with the same signature of ITER::do_entry() above.\n+  template <class Function>\n+  void unlink(Function function) { \/\/ lambda enabled API\n+    auto wrapper = [&](Node* const node, Node**& ptr) {\n+      bool clean = function(node->_key, node->_value);\n+      if (clean) {\n+        *ptr = node->_next;\n+      } else {\n+        ptr = &(node->_next);\n+      }\n+      return clean;\n+    };\n+\n+    unlink_impl(wrapper);\n+  }\n+\n+  \/\/ unlink_all() is a specialized version of unlink() when we decide to remove all elements.\n+  \/\/ It can not replace unlink(ITER* iter) if user-provided iter releases key\/value\n+  void unlink_all() {\n+    auto wrapper = [&](Node* const node, Node** ptr) {\n+      if (node->_next == nullptr) {\n+        \/\/ nullify the bucket when reach the end of linked list.\n+        *ptr = nullptr;\n+      }\n+\n+      return true;\n+    };\n+    unlink_impl(wrapper);\n+    assert(_number_of_entries == 0, \"sanity check\");\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":83,"deletions":28,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,1 @@\n-\n+      rh.unlink_all();\n@@ -262,0 +262,12 @@\n+\n+      rh.unlink([&](K const& key, V const& val) {\n+        return ((uintptr_t)key % 2) == 0; \/\/ delete all even keys\n+      });\n+      ASSERT_FALSE(rh.get(as_K(6)));\n+      ASSERT_TRUE(rh.get(as_K(7)));\n+\n+      rh.unlink_all();\n+      for (uintptr_t i = 10; i > 0; --i) {\n+        uintptr_t index = i - 1;\n+        ASSERT_FALSE(rh.get(as_K(index)));\n+      }\n@@ -333,0 +345,23 @@\n+TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_delete_lambda) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 66);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  _simple_test_table.unlink([&](SymbolHandle& key, int value) { return true; });\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n+TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_unlink_all) {\n+  TempNewSymbol t = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  Symbol* s = t;\n+  int s_orig_count = s->refcount();\n+  _simple_test_table.put(s, 66);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Use unlink_all to remove the matching (or all) values from the table.\n+  _simple_test_table.unlink_all();\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n@@ -415,0 +450,15 @@\n+TEST_VM_F(ResourceHashtableDeleteTest, value_unlink_all) {\n+  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n+  int d_orig_count = d->refcount();\n+  {\n+    TestValue tv(d);\n+    \/\/ Same as above, but the do_entry does nothing because the value is deleted when the\n+    \/\/ hashtable node is deleted.\n+    _test_table.put(d, tv);\n+    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented in table\";\n+  _test_table.unlink_all();\n+  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n+}\n+\n@@ -435,0 +485,20 @@\n+TEST_VM_F(ResourceHashtableDeleteTest, check_delete_ptr_lambda) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_ptr\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue* tv = new TestValue(s);\n+    \/\/ Again since TestValue contains the pointer to the key Symbol, it will\n+    \/\/ handle the refcounting.\n+    _ptr_test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented by allocation\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n+\n+  _ptr_test_table.unlink([&](auto key, auto value) {\n+    delete value;\n+    return true;\n+  });\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":72,"deletions":2,"binary":false,"changes":74,"status":"modified"}]}