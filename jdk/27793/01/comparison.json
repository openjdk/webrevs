{"files":[{"patch":"@@ -942,2 +942,7 @@\n-     * connection would be notified about such exchanges when it receives a GOAWAY frame with\n-     * a stream id that tells which exchanges have been unprocessed.\n+     * connection would be notified about such exchanges in either of the following 2 ways:\n+     * <ul>\n+     *  <li> when it receives a GOAWAY frame with a stream id that tells which\n+     *    exchanges have been unprocessed.\n+     *  <li> or when a particular request's stream is reset with the H3_REQUEST_REJECTED error code.\n+     * <\/ul>\n+     * <p>\n@@ -945,2 +950,1 @@\n-     * will arrange for the request, corresponding to this exchange, to be retried afresh on a\n-     * new connection.\n+     * will arrange for the request, corresponding to this exchange, to be retried afresh.\n@@ -1338,1 +1342,9 @@\n-        if (!requestSent || !responseReceived) {\n+        if (debug.on()) {\n+            debug.log(\"Stream %s reset by peer [%s]: \", streamId(), resetReason);\n+        }\n+        \/\/ if the error is H3_REQUEST_REJECTED then it implies\n+        \/\/ the request wasn't processed and the client is allowed to reissue\n+        \/\/ that request afresh\n+        if (resetError == Http3Error.H3_REQUEST_REJECTED) {\n+            closeAsUnprocessed();\n+        } else if (!requestSent || !responseReceived) {\n@@ -1344,2 +1356,1 @@\n-            debug.log(\"Stream %s reset by peer [%s]: Stopping scheduler\",\n-                    streamId(), resetReason);\n+            debug.log(\"stopping scheduler for stream %s\", streamId());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http3ExchangeImpl.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.http3.Http3Error;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_3;\n+import static java.net.http.HttpOption.H3_DISCOVERY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @summary verify that when the server sends a request reset with H3_REQUEST_REJECTED as the\n+ *          error code, then the HttpClient rightly reissues that request afresh\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit ${test.main.class}\n+ *\/\n+class H3RequestRejectedTest {\n+\n+    private static final String HANDLER_PATH = \"\/foo\";\n+\n+    private static HttpTestServer server;\n+    private static SSLContext sslContext;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        assertNotNull(sslContext, \"SSLContext could not be constructed\");\n+        server = HttpTestServer.create(HTTP_3_URI_ONLY, sslContext);\n+        server.addHandler(new Handler(), HANDLER_PATH);\n+        server.start();\n+        System.err.println(\"server started at \" + server.getAddress());\n+    }\n+\n+    @AfterAll\n+    static void afterAll() throws Exception {\n+        if (server != null) {\n+            System.err.println(\"stopping server: \" + server.getAddress());\n+            server.close();\n+        }\n+    }\n+\n+    \/*\n+     * Issues a HTTP\/3 request to a server which is expected to respond with a\n+     * reset stream with error code H3_REQUEST_REJECTED for the request, every single time.\n+     * The HTTP\/3 specification allows for such requests to be retried by the client,\n+     * afresh (if necessary on a new connection). This test verifies that the application\n+     * receives an IOException, due to the server always rejecting the request.\n+     *\/\n+    @Test\n+    void testAlwaysRejected() throws Exception {\n+        try (final HttpClient client = HttpClient.newBuilder()\n+                .sslContext(sslContext).proxy(NO_PROXY).version(HTTP_3)\n+                .build()) {\n+\n+            final URI reqURI = URIBuilder.newBuilder()\n+                    .scheme(\"https\")\n+                    .host(server.getAddress().getAddress())\n+                    .port(server.getAddress().getPort())\n+                    .path(HANDLER_PATH)\n+                    .query(\"always-reject\")\n+                    .build();\n+            final HttpRequest req = HttpRequest.newBuilder()\n+                    .uri(reqURI)\n+                    .setOption(H3_DISCOVERY, HTTP_3_URI_ONLY).build();\n+            System.err.println(\"issuing request \" + req);\n+            final IOException thrown = assertThrows(IOException.class,\n+                    () -> client.send(req, BodyHandlers.ofString(US_ASCII)));\n+            if (!\"request not processed by peer\".equals(thrown.getMessage())) {\n+                \/\/ propagate original exception\n+                fail(\"missing exception message in IOException\", thrown);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Issues several HTTP\/3 requests to a server which is expected to respond with a\n+     * reset stream with error code H3_REQUEST_REJECTED for some of those requests.\n+     * The HTTP\/3 specification allows for such requests to be retried by the client,\n+     * afresh (if necessary on a new connection). This test verifies that the HttpClient\n+     * implementation internally retries such requests and thus the application receives\n+     * a successful response.\n+     *\/\n+    @Test\n+    void testRejectedRequest() throws Exception {\n+        try (final HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n+                .proxy(NO_PROXY).version(HTTP_3)\n+                .build()) {\n+\n+            final URI reqURI = URIBuilder.newBuilder()\n+                    .scheme(\"https\")\n+                    .host(server.getAddress().getAddress())\n+                    .port(server.getAddress().getPort())\n+                    .path(HANDLER_PATH)\n+                    .build();\n+            for (int i = 1; i <= 5; i++) {\n+                final HttpRequest req = HttpRequest.newBuilder()\n+                        .setOption(H3_DISCOVERY, HTTP_3_URI_ONLY)\n+                        .uri(new URI(reqURI.toString() + \"?iteration=\" + i))\n+                        .build();\n+                System.err.println(\"iteration \" + i + \" issuing request \" + req);\n+                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString(US_ASCII));\n+                assertEquals(200, resp.statusCode(), \"unexpected response status\");\n+                assertEquals(Handler.RESP_BODY, resp.body(), \"unexpected response body\");\n+            }\n+            \/\/ verify that some requests were indeed rejected (and reissued internally by the client)\n+            final Set<URI> rejectedOnes = Handler.rejectedRequests;\n+            System.err.println(\"server side handler (intentionally) rejected following \"\n+                    + rejectedOnes.size() + \" requests:\");\n+            System.err.println(rejectedOnes);\n+            assertFalse(rejectedOnes.stream()\n+                            .filter((uri) -> uri.toString().contains(\"iteration\"))\n+                            .findAny()\n+                            .isEmpty(),\n+                    \"server was expected to reject at least one request, but it didn't\");\n+        }\n+    }\n+\n+    private static final class Handler implements HttpTestHandler {\n+        private static final String RESP_BODY = \"done\";\n+        private static final Set<URI> rejectedRequests = Collections.synchronizedSet(new HashSet<>());\n+        private static final AtomicInteger reqsCounter = new AtomicInteger();\n+\n+        @Override\n+        public void handle(final HttpTestExchange exch) throws IOException {\n+            final URI reqURI = exch.getRequestURI();\n+            final String reqQuery = reqURI.getQuery();\n+            System.err.println(\"handling request \" + reqURI + \" \" + reqQuery);\n+            final int currentReqNum = reqsCounter.incrementAndGet();\n+            if (currentReqNum % 2 == 0\n+                    || (reqQuery != null && reqQuery.contains(\"always-reject\"))) {\n+                \/\/ reject it\n+                rejectedRequests.add(reqURI);\n+                System.err.println(\"resetting request with H3_REQUEST_REJECTED code for \" + reqURI);\n+                exch.resetStream(Http3Error.H3_REQUEST_REJECTED.code());\n+                return;\n+            }\n+            \/\/ send 200 response\n+            final byte[] body = RESP_BODY.getBytes(US_ASCII);\n+            exch.sendResponseHeaders(200, body.length);\n+            try (final OutputStream os = exch.getResponseBody()) {\n+                os.write(body);\n+            }\n+            System.err.println(\"responded with 200 status code for \" + reqURI);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http3\/H3RequestRejectedTest.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"}]}