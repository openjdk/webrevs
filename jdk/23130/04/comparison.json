{"files":[{"patch":"@@ -555,18 +555,0 @@\n-#define INSN(NAME, op, funct3)                                                                     \\\n-  void NAME(FloatRegister Rd, Register Rs, const int32_t offset) {                                 \\\n-    guarantee(is_simm12(offset), \"offset is invalid.\");                                            \\\n-    unsigned insn = 0;                                                                             \\\n-    uint32_t val = offset & 0xfff;                                                                 \\\n-    patch((address)&insn, 6, 0, op);                                                               \\\n-    patch((address)&insn, 14, 12, funct3);                                                         \\\n-    patch_reg((address)&insn, 15, Rs);                                                             \\\n-    patch_reg((address)&insn, 7, Rd);                                                              \\\n-    patch((address)&insn, 31, 20, val);                                                            \\\n-    emit(insn);                                                                                    \\\n-  }\n-\n-  INSN(flw,  0b0000111, 0b010);\n-  INSN(_fld, 0b0000111, 0b011);\n-\n-#undef INSN\n-\n@@ -816,20 +798,0 @@\n-#define INSN(NAME, op, funct5, funct7)                                                      \\\n-  void NAME(FloatRegister Rd, FloatRegister Rs1, RoundingMode rm = rne) {                   \\\n-    unsigned insn = 0;                                                                      \\\n-    patch((address)&insn, 6, 0, op);                                                        \\\n-    patch((address)&insn, 14, 12, rm);                                                      \\\n-    patch((address)&insn, 24, 20, funct5);                                                  \\\n-    patch((address)&insn, 31, 25, funct7);                                                  \\\n-    patch_reg((address)&insn, 7, Rd);                                                       \\\n-    patch_reg((address)&insn, 15, Rs1);                                                     \\\n-    emit(insn);                                                                             \\\n-  }\n-\n-  INSN(fsqrt_s,  0b1010011, 0b00000, 0b0101100);\n-  INSN(fsqrt_d,  0b1010011, 0b00000, 0b0101101);\n-  INSN(fcvt_s_h, 0b1010011, 0b00010, 0b0100000);\n-  INSN(fcvt_h_s, 0b1010011, 0b00000, 0b0100010);\n-  INSN(fcvt_s_d, 0b1010011, 0b00001, 0b0100000);\n-  INSN(fcvt_d_s, 0b1010011, 0b00000, 0b0100001);\n-#undef INSN\n-\n@@ -931,62 +893,30 @@\n-\/\/ Float and Double Rigster Instruction\n-#define INSN(NAME, op, funct2)                                                                                     \\\n-  void NAME(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne) {    \\\n-    unsigned insn = 0;                                                                                             \\\n-    patch((address)&insn, 6, 0, op);                                                                               \\\n-    patch((address)&insn, 14, 12, rm);                                                                             \\\n-    patch((address)&insn, 26, 25, funct2);                                                                         \\\n-    patch_reg((address)&insn, 7, Rd);                                                                              \\\n-    patch_reg((address)&insn, 15, Rs1);                                                                            \\\n-    patch_reg((address)&insn, 20, Rs2);                                                                            \\\n-    patch_reg((address)&insn, 27, Rs3);                                                                            \\\n-    emit(insn);                                                                                                    \\\n-  }\n-\n-  INSN(fmadd_s,   0b1000011,  0b00);\n-  INSN(fmsub_s,   0b1000111,  0b00);\n-  INSN(fnmsub_s,  0b1001011,  0b00);\n-  INSN(fnmadd_s,  0b1001111,  0b00);\n-  INSN(fmadd_d,   0b1000011,  0b01);\n-  INSN(fmsub_d,   0b1000111,  0b01);\n-  INSN(fnmsub_d,  0b1001011,  0b01);\n-  INSN(fnmadd_d,  0b1001111,  0b01);\n-\n-#undef INSN\n-\n-\/\/ Float and Double Rigster Instruction\n-#define INSN(NAME, op, funct3, funct7)                                        \\\n-  void NAME(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {         \\\n-    unsigned insn = 0;                                                        \\\n-    patch((address)&insn, 6, 0, op);                                          \\\n-    patch((address)&insn, 14, 12, funct3);                                    \\\n-    patch((address)&insn, 31, 25, funct7);                                    \\\n-    patch_reg((address)&insn, 7, Rd);                                         \\\n-    patch_reg((address)&insn, 15, Rs1);                                       \\\n-    patch_reg((address)&insn, 20, Rs2);                                       \\\n-    emit(insn);                                                               \\\n-  }\n-\n-  INSN(fsgnj_s,  0b1010011, 0b000, 0b0010000);\n-  INSN(fsgnjn_s, 0b1010011, 0b001, 0b0010000);\n-  INSN(fsgnjx_s, 0b1010011, 0b010, 0b0010000);\n-  INSN(fmin_s,   0b1010011, 0b000, 0b0010100);\n-  INSN(fmax_s,   0b1010011, 0b001, 0b0010100);\n-  INSN(fsgnj_d,  0b1010011, 0b000, 0b0010001);\n-  INSN(fsgnjn_d, 0b1010011, 0b001, 0b0010001);\n-  INSN(fsgnjx_d, 0b1010011, 0b010, 0b0010001);\n-  INSN(fmin_d,   0b1010011, 0b000, 0b0010101);\n-  INSN(fmax_d,   0b1010011, 0b001, 0b0010101);\n-\n-#undef INSN\n-\n-\/\/ Float and Double Rigster Arith Instruction\n-#define INSN(NAME, op, funct3, funct7)                                    \\\n-  void NAME(Register Rd, FloatRegister Rs1, FloatRegister Rs2) {          \\\n-    unsigned insn = 0;                                                    \\\n-    patch((address)&insn, 6, 0, op);                                      \\\n-    patch((address)&insn, 14, 12, funct3);                                \\\n-    patch((address)&insn, 31, 25, funct7);                                \\\n-    patch_reg((address)&insn, 7, Rd);                                     \\\n-    patch_reg((address)&insn, 15, Rs1);                                   \\\n-    patch_reg((address)&insn, 20, Rs2);                                   \\\n-    emit(insn);                                                           \\\n+\/\/ ==========================\n+\/\/ Floating Point Instructions\n+\/\/ ==========================\n+  static constexpr uint32_t OP_FP_MAJOR = 0b1010011;\n+\n+  enum FmtPrecision : uint8_t {\n+    S_32_sp  = 0b00,\n+    D_64_dp  = 0b01,\n+    H_16_hp  = 0b10,\n+    Q_128_qp = 0b11\n+  };\n+\n+ private:\n+\n+  template <FmtPrecision Fmt, uint8_t funct5>\n+  void fp_base(uint8_t Rd, uint8_t Rs1, uint8_t Rs2, RoundingMode rm) {\n+    assert(Fmt != H_16_hp || UseZfh || UseZfhmin, \"No half precision enabled\");\n+    assert_cond(Fmt != Q_128_qp);\n+    guarantee(is_uimm3(rm), \"Rounding mode is out of validity\");\n+    guarantee(is_uimm2(Fmt), \"FMT is out of validity\");\n+    guarantee(is_uimm5(funct5), \"Funct5 is out of validity\");\n+    uint32_t insn = 0;\n+    patch((address)&insn,   6, 0, OP_FP_MAJOR);\n+    patch((address)&insn, 11,  7, Rd);\n+    patch((address)&insn, 14, 12, rm);\n+    patch((address)&insn, 19, 15, Rs1);\n+    patch((address)&insn, 24, 20, Rs2);\n+    patch((address)&insn, 26, 25, Fmt);\n+    patch((address)&insn, 31, 27, funct5);\n+    emit(insn);\n@@ -995,7 +925,4 @@\n-  INSN(feq_s,    0b1010011, 0b010, 0b1010000);\n-  INSN(flt_s,    0b1010011, 0b001, 0b1010000);\n-  INSN(fle_s,    0b1010011, 0b000, 0b1010000);\n-  INSN(feq_d,    0b1010011, 0b010, 0b1010001);\n-  INSN(fle_d,    0b1010011, 0b000, 0b1010001);\n-  INSN(flt_d,    0b1010011, 0b001, 0b1010001);\n-#undef INSN\n+  template <FmtPrecision Fmt, uint8_t funct5>\n+  void fp_base(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm) {\n+    fp_base<Fmt, funct5>(Rd->raw_encoding(), Rs1->raw_encoding(), Rs2->raw_encoding(), rm);\n+  }\n@@ -1003,11 +930,3 @@\n-\/\/ Float and Double Arith Instruction\n-#define INSN(NAME, op, funct7)                                                                  \\\n-  void NAME(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {    \\\n-    unsigned insn = 0;                                                                          \\\n-    patch((address)&insn, 6, 0, op);                                                            \\\n-    patch((address)&insn, 14, 12, rm);                                                          \\\n-    patch((address)&insn, 31, 25, funct7);                                                      \\\n-    patch_reg((address)&insn, 7, Rd);                                                           \\\n-    patch_reg((address)&insn, 15, Rs1);                                                         \\\n-    patch_reg((address)&insn, 20, Rs2);                                                         \\\n-    emit(insn);                                                                                 \\\n+  template <FmtPrecision Fmt, uint8_t funct5>\n+  void fp_base(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, int8_t rm) {\n+    fp_base<Fmt, funct5>(Rd->raw_encoding(), Rs1->raw_encoding(), Rs2->raw_encoding(), (RoundingMode)rm);\n@@ -1016,8 +935,4 @@\n-  INSN(fadd_s,   0b1010011, 0b0000000);\n-  INSN(fsub_s,   0b1010011, 0b0000100);\n-  INSN(fmul_s,   0b1010011, 0b0001000);\n-  INSN(fdiv_s,   0b1010011, 0b0001100);\n-  INSN(fadd_d,   0b1010011, 0b0000001);\n-  INSN(fsub_d,   0b1010011, 0b0000101);\n-  INSN(fmul_d,   0b1010011, 0b0001001);\n-  INSN(fdiv_d,   0b1010011, 0b0001101);\n+  template <FmtPrecision Fmt, uint8_t funct5>\n+  void fp_base(Register Rd, FloatRegister Rs1, FloatRegister Rs2, int8_t rm) {\n+    fp_base<Fmt, funct5>(Rd->raw_encoding(), Rs1->raw_encoding(), Rs2->raw_encoding(), (RoundingMode)rm);\n+  }\n@@ -1025,1 +940,5 @@\n-#undef INSN\n+  template <FmtPrecision Fmt, uint8_t funct5>\n+  void fp_base(FloatRegister Rd, FloatRegister Rs1, int8_t Rs2, int8_t rm) {\n+    guarantee(is_uimm5(Rs2), \"Rs2 is out of validity\");\n+    fp_base<Fmt, funct5>(Rd->raw_encoding(), Rs1->raw_encoding(), Rs2, (RoundingMode)rm);\n+  }\n@@ -1027,11 +946,3 @@\n-\/\/ Whole Float and Double Conversion Instruction\n-#define INSN(NAME, op, funct5, funct7)                                  \\\n-  void NAME(FloatRegister Rd, Register Rs1, RoundingMode rm = rne) {    \\\n-    unsigned insn = 0;                                                  \\\n-    patch((address)&insn, 6, 0, op);                                    \\\n-    patch((address)&insn, 14, 12, rm);                                  \\\n-    patch((address)&insn, 24, 20, funct5);                              \\\n-    patch((address)&insn, 31, 25, funct7);                              \\\n-    patch_reg((address)&insn, 7, Rd);                                   \\\n-    patch_reg((address)&insn, 15, Rs1);                                 \\\n-    emit(insn);                                                         \\\n+  template <FmtPrecision Fmt, uint8_t funct5>\n+  void fp_base(FloatRegister Rd, Register Rs1, FloatRegister Rs2, RoundingMode rm) {\n+    fp_base<Fmt, funct5>(Rd->raw_encoding(), Rs1->raw_encoding(), Rs2->raw_encoding(), rm);\n@@ -1040,8 +951,5 @@\n-  INSN(fcvt_s_w,   0b1010011, 0b00000, 0b1101000);\n-  INSN(fcvt_s_wu,  0b1010011, 0b00001, 0b1101000);\n-  INSN(fcvt_s_l,   0b1010011, 0b00010, 0b1101000);\n-  INSN(fcvt_s_lu,  0b1010011, 0b00011, 0b1101000);\n-  INSN(fcvt_d_w,   0b1010011, 0b00000, 0b1101001);\n-  INSN(fcvt_d_wu,  0b1010011, 0b00001, 0b1101001);\n-  INSN(fcvt_d_l,   0b1010011, 0b00010, 0b1101001);\n-  INSN(fcvt_d_lu,  0b1010011, 0b00011, 0b1101001);\n+  template <FmtPrecision Fmt, uint8_t funct5>\n+  void fp_base(Register Rd, FloatRegister Rs1, uint8_t Rs2, RoundingMode rm) {\n+    guarantee(is_uimm5(Rs2), \"Rs2 is out of validity\");\n+    fp_base<Fmt, funct5>(Rd->raw_encoding(), Rs1->raw_encoding(), Rs2, rm);\n+  }\n@@ -1049,1 +957,5 @@\n-#undef INSN\n+  template <FmtPrecision Fmt, uint8_t funct5>\n+  void fp_base(Register Rd, FloatRegister Rs1, uint8_t Rs2, uint8_t rm) {\n+    guarantee(is_uimm5(Rs2), \"Rs2 is out of validity\");\n+    fp_base<Fmt, funct5>(Rd->raw_encoding(), Rs1->raw_encoding(), Rs2, (RoundingMode)rm);\n+  }\n@@ -1051,11 +963,4 @@\n-\/\/ Float and Double Conversion Instruction\n-#define INSN(NAME, op, funct5, funct7)                                  \\\n-  void NAME(Register Rd, FloatRegister Rs1, RoundingMode rm = rtz) {    \\\n-    unsigned insn = 0;                                                  \\\n-    patch((address)&insn, 6, 0, op);                                    \\\n-    patch((address)&insn, 14, 12, rm);                                  \\\n-    patch((address)&insn, 24, 20, funct5);                              \\\n-    patch((address)&insn, 31, 25, funct7);                              \\\n-    patch_reg((address)&insn, 7, Rd);                                   \\\n-    patch_reg((address)&insn, 15, Rs1);                                 \\\n-    emit(insn);                                                         \\\n+  template <FmtPrecision Fmt, uint8_t funct5>\n+  void fp_base(FloatRegister Rd, Register Rs1, uint8_t Rs2, RoundingMode rm) {\n+    guarantee(is_uimm5(Rs2), \"Rs2 is out of validity\");\n+    fp_base<Fmt, funct5>(Rd->raw_encoding(), Rs1->raw_encoding(), Rs2, rm);\n@@ -1064,48 +969,30 @@\n-  INSN(fcvt_w_s,   0b1010011, 0b00000, 0b1100000);\n-  INSN(fcvt_l_s,   0b1010011, 0b00010, 0b1100000);\n-  INSN(fcvt_wu_s,  0b1010011, 0b00001, 0b1100000);\n-  INSN(fcvt_lu_s,  0b1010011, 0b00011, 0b1100000);\n-  INSN(fcvt_w_d,   0b1010011, 0b00000, 0b1100001);\n-  INSN(fcvt_wu_d,  0b1010011, 0b00001, 0b1100001);\n-  INSN(fcvt_l_d,   0b1010011, 0b00010, 0b1100001);\n-  INSN(fcvt_lu_d,  0b1010011, 0b00011, 0b1100001);\n-\n-#undef INSN\n-\n-\/\/ Float and Double Move Instruction\n-#define INSN(NAME, op, funct3, funct5, funct7)       \\\n-  void NAME(FloatRegister Rd, Register Rs1) {        \\\n-    unsigned insn = 0;                               \\\n-    patch((address)&insn, 6, 0, op);                 \\\n-    patch((address)&insn, 14, 12, funct3);           \\\n-    patch((address)&insn, 20, funct5);               \\\n-    patch((address)&insn, 31, 25, funct7);           \\\n-    patch_reg((address)&insn, 7, Rd);                \\\n-    patch_reg((address)&insn, 15, Rs1);              \\\n-    emit(insn);                                      \\\n-  }\n-\n-  INSN(fmv_h_x,  0b1010011, 0b000, 0b00000, 0b1111010);\n-  INSN(fmv_w_x,  0b1010011, 0b000, 0b00000, 0b1111000);\n-  INSN(fmv_d_x,  0b1010011, 0b000, 0b00000, 0b1111001);\n-\n-#undef INSN\n-\n-enum fclass_mask {\n-  minf       = 1 << 0,   \/\/ negative infinite\n-  mnorm      = 1 << 1,   \/\/ negative normal number\n-  msubnorm   = 1 << 2,   \/\/ negative subnormal number\n-  mzero      = 1 << 3,   \/\/ negative zero\n-  pzero      = 1 << 4,   \/\/ positive zero\n-  psubnorm   = 1 << 5,   \/\/ positive subnormal number\n-  pnorm      = 1 << 6,   \/\/ positive normal number\n-  pinf       = 1 << 7,   \/\/ positive infinite\n-  snan       = 1 << 8,   \/\/ signaling NaN\n-  qnan       = 1 << 9,   \/\/ quiet NaN\n-  zero       = mzero    | pzero,\n-  subnorm    = msubnorm | psubnorm,\n-  norm       = mnorm    | pnorm,\n-  inf        = minf     | pinf,\n-  nan        = snan     | qnan,\n-  finite     = zero     | subnorm   | norm,\n-};\n+  template <FmtPrecision Fmt, uint8_t funct5>\n+  void fp_base(FloatRegister Rd, Register Rs1, uint8_t Rs2, int8_t rm) {\n+    guarantee(is_uimm5(Rs2), \"Rs2 is out of validity\");\n+    fp_base<Fmt, funct5>(Rd->raw_encoding(), Rs1->raw_encoding(), Rs2, (RoundingMode)rm);\n+  }\n+\n+ public:\n+\n+  enum FClassBits {\n+    minf       = 1 << 0,   \/\/ negative infinite\n+    mnorm      = 1 << 1,   \/\/ negative normal number\n+    msubnorm   = 1 << 2,   \/\/ negative subnormal number\n+    mzero      = 1 << 3,   \/\/ negative zero\n+    pzero      = 1 << 4,   \/\/ positive zero\n+    psubnorm   = 1 << 5,   \/\/ positive subnormal number\n+    pnorm      = 1 << 6,   \/\/ positive normal number\n+    pinf       = 1 << 7,   \/\/ positive infinite\n+    snan       = 1 << 8,   \/\/ signaling NaN\n+    qnan       = 1 << 9,   \/\/ quiet NaN\n+    zero       = mzero    | pzero,\n+    subnorm    = msubnorm | psubnorm,\n+    norm       = mnorm    | pnorm,\n+    inf        = minf     | pinf,\n+    nan        = snan     | qnan,\n+    finite     = zero     | subnorm   | norm,\n+  };\n+\n+  void fsqrt_s(FloatRegister Rd, FloatRegister Rs1, RoundingMode rm = rne) {\n+    fp_base<S_32_sp, 0b01011>(Rd, Rs1, 0b00000, rm);\n+  }\n@@ -1113,11 +1000,2 @@\n-\/\/ Float and Double Conversion\/Classify Instruction\n-#define INSN(NAME, op, funct3, funct5, funct7)            \\\n-  void NAME(Register Rd, FloatRegister Rs1) {             \\\n-    unsigned insn = 0;                                    \\\n-    patch((address)&insn, 6, 0, op);                      \\\n-    patch((address)&insn, 14, 12, funct3);                \\\n-    patch((address)&insn, 20, funct5);                    \\\n-    patch((address)&insn, 31, 25, funct7);                \\\n-    patch_reg((address)&insn, 7, Rd);                     \\\n-    patch_reg((address)&insn, 15, Rs1);                   \\\n-    emit(insn);                                           \\\n+  void fsqrt_d(FloatRegister Rd, FloatRegister Rs1, RoundingMode rm = rne) {\n+    fp_base<D_64_dp, 0b01011>(Rd, Rs1, 0b00000, rm);\n@@ -1126,6 +1004,3 @@\n-  INSN(fclass_h, 0b1010011, 0b001, 0b00000, 0b1110010);\n-  INSN(fclass_s, 0b1010011, 0b001, 0b00000, 0b1110000);\n-  INSN(fclass_d, 0b1010011, 0b001, 0b00000, 0b1110001);\n-  INSN(fmv_x_h,  0b1010011, 0b000, 0b00000, 0b1110010);\n-  INSN(fmv_x_w,  0b1010011, 0b000, 0b00000, 0b1110000);\n-  INSN(fmv_x_d,  0b1010011, 0b000, 0b00000, 0b1110001);\n+  void fcvt_s_d(FloatRegister Rd, FloatRegister Rs1, RoundingMode rm = rne) {\n+    fp_base<S_32_sp, 0b01000>(Rd, Rs1, 0b00001, rm);\n+  }\n@@ -1133,1 +1008,287 @@\n-#undef INSN\n+  void fcvt_d_s(FloatRegister Rd, FloatRegister Rs1, RoundingMode rm = rne) {\n+    fp_base<D_64_dp, 0b01000>(Rd, Rs1, 0b00000, rm);\n+  }\n+\n+  void fsgnj_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<S_32_sp, 0b00100>(Rd, Rs1, Rs2, 0b000);\n+  }\n+\n+  void fsgnjn_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<S_32_sp, 0b00100>(Rd, Rs1, Rs2, 0b001);\n+  }\n+\n+  void fsgnjx_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<S_32_sp, 0b00100>(Rd, Rs1, Rs2, 0b010);\n+  }\n+\n+  void fmin_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<S_32_sp, 0b00101>(Rd, Rs1, Rs2, 0b000);\n+  }\n+\n+  void fmax_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<S_32_sp, 0b00101>(Rd, Rs1, Rs2, 0b001);\n+  }\n+\n+  void fsgnj_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<D_64_dp, 0b00100>(Rd, Rs1, Rs2, 0b000);\n+  }\n+\n+  void fsgnjn_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<D_64_dp, 0b00100>(Rd, Rs1, Rs2, 0b001);\n+  }\n+\n+  void fsgnjx_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<D_64_dp, 0b00100>(Rd, Rs1, Rs2, 0b010);\n+  }\n+\n+  void fmin_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<D_64_dp, 0b00101>(Rd, Rs1, Rs2, 0b000);\n+  }\n+\n+  void fmax_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<D_64_dp, 0b00101>(Rd, Rs1, Rs2, 0b001);\n+  }\n+\n+  void feq_s(Register Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<S_32_sp, 0b10100>(Rd, Rs1, Rs2, 0b010);\n+  }\n+\n+  void flt_s(Register Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<S_32_sp, 0b10100>(Rd, Rs1, Rs2, 0b001);\n+  }\n+\n+  void fle_s(Register Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<S_32_sp, 0b10100>(Rd, Rs1, Rs2, 0b000);\n+  }\n+\n+  void feq_d(Register Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<D_64_dp, 0b10100>(Rd, Rs1, Rs2, 0b010);\n+  }\n+\n+  void fle_d(Register Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<D_64_dp, 0b10100>(Rd, Rs1, Rs2, 0b000);\n+  }\n+\n+  void flt_d(Register Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    fp_base<D_64_dp, 0b10100>(Rd, Rs1, Rs2, 0b001);\n+  }\n+\n+  void fadd_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    fp_base<S_32_sp, 0b00000>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fsub_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    fp_base<S_32_sp, 0b00001>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fmul_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    fp_base<S_32_sp, 0b00010>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fdiv_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    fp_base<S_32_sp, 0b00011>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fadd_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    fp_base<D_64_dp, 0b00000>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fsub_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    fp_base<D_64_dp, 0b00001>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fmul_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    fp_base<D_64_dp, 0b00010>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fdiv_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    fp_base<D_64_dp, 0b00011>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fcvt_s_w(FloatRegister Rd, Register Rs1, RoundingMode rm = rne) {\n+    fp_base<S_32_sp, 0b11010>(Rd, Rs1, 0b00000, rm);\n+  }\n+\n+  void fcvt_s_wu(FloatRegister Rd, Register Rs1, RoundingMode rm = rne) {\n+    fp_base<S_32_sp, 0b11010>(Rd, Rs1, 0b00001, rm);\n+  }\n+\n+  void fcvt_s_l(FloatRegister Rd, Register Rs1, RoundingMode rm = rne) {\n+    fp_base<S_32_sp, 0b11010>(Rd, Rs1, 0b00010, rm);\n+  }\n+\n+  void fcvt_s_lu(FloatRegister Rd, Register Rs1, RoundingMode rm = rne) {\n+    fp_base<S_32_sp, 0b11010>(Rd, Rs1, 0b00011, rm);\n+  }\n+\n+  void fcvt_d_w(FloatRegister Rd, Register Rs1, RoundingMode rm = rne) {\n+    fp_base<D_64_dp, 0b11010>(Rd, Rs1, 0b00000, rm);\n+  }\n+\n+  void fcvt_d_wu(FloatRegister Rd, Register Rs1, RoundingMode rm = rne) {\n+    fp_base<D_64_dp, 0b11010>(Rd, Rs1, 0b00001, rm);\n+  }\n+\n+  void fcvt_d_l(FloatRegister Rd, Register Rs1, RoundingMode rm = rne) {\n+    fp_base<D_64_dp, 0b11010>(Rd, Rs1, 0b00010, rm);\n+  }\n+\n+  void fcvt_d_lu(FloatRegister Rd, Register Rs1, RoundingMode rm = rne) {\n+    fp_base<D_64_dp, 0b11010>(Rd, Rs1, 0b00011, rm);\n+  }\n+\n+  void fcvt_w_s(Register Rd, FloatRegister Rs1, RoundingMode rm = rtz) {\n+    fp_base<S_32_sp, 0b11000>(Rd, Rs1, 0b00000, rm);\n+  }\n+\n+  void fcvt_l_s(Register Rd, FloatRegister Rs1, RoundingMode rm = rtz) {\n+    fp_base<S_32_sp, 0b11000>(Rd, Rs1, 0b00010, rm);\n+  }\n+\n+  void fcvt_wu_s(Register Rd, FloatRegister Rs1, RoundingMode rm = rtz) {\n+    fp_base<S_32_sp, 0b11000>(Rd, Rs1, 0b00001, rm);\n+  }\n+\n+  void fcvt_lu_s(Register Rd, FloatRegister Rs1, RoundingMode rm = rtz) {\n+    fp_base<S_32_sp, 0b11000>(Rd, Rs1, 0b00011, rm);\n+  }\n+\n+  void fcvt_w_d(Register Rd, FloatRegister Rs1, RoundingMode rm = rtz) {\n+    fp_base<D_64_dp, 0b11000>(Rd, Rs1, 0b00000, rm);\n+  }\n+\n+  void fcvt_wu_d(Register Rd, FloatRegister Rs1, RoundingMode rm = rtz) {\n+    fp_base<D_64_dp, 0b11000>(Rd, Rs1, 0b00001, rm);\n+  }\n+\n+  void fcvt_l_d(Register Rd, FloatRegister Rs1, RoundingMode rm = rtz) {\n+    fp_base<D_64_dp, 0b11000>(Rd, Rs1, 0b00010, rm);\n+  }\n+\n+  void fcvt_lu_d(Register Rd, FloatRegister Rs1, RoundingMode rm = rtz) {\n+    fp_base<D_64_dp, 0b11000>(Rd, Rs1, 0b00011, rm);\n+  }\n+\n+  void fmv_w_x(FloatRegister Rd, Register Rs1) {\n+    fp_base<S_32_sp, 0b11110>(Rd, Rs1, 0b00000, 0b000);\n+  }\n+\n+  void fmv_d_x(FloatRegister Rd, Register Rs1) {\n+    fp_base<D_64_dp, 0b11110>(Rd, Rs1, 0b00000, 0b000);\n+  }\n+\n+  void fclass_s(Register Rd, FloatRegister Rs1) {\n+    fp_base<S_32_sp, 0b11100>(Rd, Rs1, 0b00000, 0b001);\n+  }\n+\n+  void fclass_d(Register Rd, FloatRegister Rs1) {\n+    fp_base<D_64_dp, 0b11100>(Rd, Rs1, 0b00000, 0b001);\n+  }\n+\n+  void fmv_x_w(Register Rd, FloatRegister Rs1) {\n+    fp_base<S_32_sp, 0b11100>(Rd, Rs1, 0b00000, 0b000);\n+  }\n+\n+  void fmv_x_d(Register Rd, FloatRegister Rs1) {\n+    fp_base<D_64_dp, 0b11100>(Rd, Rs1, 0b00000, 0b000);\n+  }\n+\n+ private:\n+  static constexpr unsigned int OP_LOAD_FP = 0b0000111;\n+\n+  template <int8_t FpWidth>\n+  void fp_load(FloatRegister Rd, Register Rs, const int32_t offset) {\n+    guarantee(is_uimm3(FpWidth), \"Rounding mode is out of validity\");\n+    guarantee(is_simm12(offset), \"offset is invalid.\");\n+    unsigned insn = 0;\n+    uint32_t val = offset & 0xfff;\n+    patch((address)&insn,   6, 0, OP_LOAD_FP);\n+    patch_reg((address)&insn,  7, Rd);\n+    patch((address)&insn, 14, 12, FpWidth);\n+    patch_reg((address)&insn, 15, Rs);\n+    patch((address)&insn, 31, 20, val);\n+    emit(insn);\n+  }\n+\n+ public:\n+\n+  void  flw(FloatRegister Rd, Register Rs, const int32_t offset) { fp_load<0b010>(Rd, Rs, offset); }\n+  void _fld(FloatRegister Rd, Register Rs, const int32_t offset) { fp_load<0b011>(Rd, Rs, offset); }\n+\n+ private:\n+  template <FmtPrecision Fmt, uint8_t OpVal>\n+  void fp_fm(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm) {\n+    assert_cond(Fmt != Q_128_qp);\n+    guarantee(is_uimm3(rm), \"Rounding mode is out of validity\");\n+    guarantee(is_uimm2(Fmt), \"FMT is out of validity\");\n+    unsigned insn = 0;\n+    patch((address)&insn,   6, 0, OpVal);\n+    patch_reg((address)&insn,  7, Rd);\n+    patch((address)&insn, 14, 12, rm);\n+    patch_reg((address)&insn, 15, Rs1);\n+    patch_reg((address)&insn, 20, Rs2);\n+    patch((address)&insn, 26, 25, Fmt);\n+    patch_reg((address)&insn, 27, Rs3);\n+    emit(insn);\n+  }\n+\n+ public:\n+  void fmadd_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne)  {\n+    fp_fm<S_32_sp, 0b1000011>(Rd, Rs1, Rs2, Rs3, rm);\n+  }\n+\n+  void fmsub_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne)  {\n+    fp_fm<S_32_sp, 0b1000111>(Rd, Rs1, Rs2, Rs3, rm);\n+  }\n+\n+  void fnmsub_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne) {\n+    fp_fm<S_32_sp, 0b1001011>(Rd, Rs1, Rs2, Rs3, rm);\n+  }\n+\n+  void fnmadd_s(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne) {\n+    fp_fm<S_32_sp, 0b1001111>(Rd, Rs1, Rs2, Rs3, rm);\n+  }\n+\n+  void fmadd_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne)  {\n+    fp_fm<D_64_dp, 0b1000011>(Rd, Rs1, Rs2, Rs3, rm);\n+  }\n+\n+  void fmsub_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne)  {\n+    fp_fm<D_64_dp, 0b1000111>(Rd, Rs1, Rs2, Rs3, rm);\n+  }\n+\n+  void fnmsub_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne) {\n+    fp_fm<D_64_dp, 0b1001011>(Rd, Rs1, Rs2, Rs3, rm);\n+  }\n+\n+  void fnmadd_d(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne) {\n+    fp_fm<D_64_dp, 0b1001111>(Rd, Rs1, Rs2, Rs3, rm);\n+  }\n+\n+\/\/ --------------  ZFH Instruction Definitions  --------------\n+\/\/ Zfh Standard Extensions for Half-Precision Floating-Point\n+  void fclass_h(Register Rd, FloatRegister Rs1) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b11100>(Rd, Rs1, 0b00000, 0b001);\n+  }\n+\n+\/\/ Zfh and Zfhmin Half-Precision Floating-Point\n+  void fcvt_s_h(FloatRegister Rd, FloatRegister Rs1, RoundingMode rm = rne) {\n+    assert_cond(UseZfh || UseZfhmin);\n+    fp_base<S_32_sp, 0b01000>(Rd, Rs1, 0b00010, rm);\n+  }\n+\n+  void fcvt_h_s(FloatRegister Rd, FloatRegister Rs1, RoundingMode rm = rne) {\n+    assert_cond(UseZfh || UseZfhmin);\n+    fp_base<H_16_hp, 0b01000>(Rd, Rs1, 0b00000, rm);\n+  }\n+\n+  void fmv_h_x(FloatRegister Rd, Register Rs1) {\n+    assert_cond(UseZfh || UseZfhmin);\n+    fp_base<H_16_hp, 0b11110>(Rd, Rs1, 0b00000, 0b000);\n+  }\n+\n+  void fmv_x_h(Register Rd, FloatRegister Rs1) {\n+    assert_cond(UseZfh || UseZfhmin);\n+    fp_base<H_16_hp, 0b11100>(Rd, Rs1, 0b00000, 0b000);\n+  }\n@@ -3405,0 +3566,1 @@\n+  static bool is_uimm2(uint64_t x);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":386,"deletions":224,"binary":false,"changes":610,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+inline bool Assembler::is_uimm2(uint64_t x) { return is_uimm(x, 2); }\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2062,1 +2062,1 @@\n-  andi(t0, t0, fclass_mask::nan); \/\/ if src1 or src2 is quiet or signaling NaN then return NaN\n+  andi(t0, t0, FClassBits::nan); \/\/ if src1 or src2 is quiet or signaling NaN then return NaN\n@@ -2156,1 +2156,1 @@\n-  andi(t0, t0, fclass_mask::zero | fclass_mask::nan);\n+  andi(t0, t0, FClassBits::zero | FClassBits::nan);\n@@ -2372,1 +2372,1 @@\n-  mv(t0, fclass_mask::zero | fclass_mask::nan);\n+  mv(t0, FClassBits::zero | FClassBits::nan);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  product(bool, UseZfhmin, false, DIAGNOSTIC, \"Use Zfhmin instructions\")         \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5890,1 +5890,1 @@\n-  andi(tmp, tmp, fclass_mask::nan);                                                       \\\n+  andi(tmp, tmp, FClassBits::nan);                                                        \\\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1921,1 +1921,1 @@\n-      return UseZfh;\n+      return UseZfh || UseZfhmin;\n@@ -7351,1 +7351,1 @@\n-    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::fclass_mask::inf);\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::FClassBits::inf);\n@@ -7366,1 +7366,1 @@\n-    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::fclass_mask::inf);\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::FClassBits::inf);\n@@ -7381,1 +7381,1 @@\n-    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::fclass_mask::finite);\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::FClassBits::finite);\n@@ -7396,1 +7396,1 @@\n-    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::fclass_mask::finite);\n+    __ andi(as_Register($dst$$reg), as_Register($dst$$reg), Assembler::FClassBits::finite);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+  \/\/ Zfhmin Minimal Half-Precision Floating-Point instructions\n@@ -160,0 +161,1 @@\n+  decl(ext_Zfhmin      , \"Zfhmin\"      , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZfhmin))      \\\n@@ -227,0 +229,1 @@\n+    RV_ENABLE_EXTENSION(UseZfhmin)                  \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -181,0 +181,3 @@\n+  if (is_set(RISCV_HWPROBE_KEY_IMA_EXT_0, RISCV_HWPROBE_EXT_ZFHMIN)) {\n+    VM_Version::ext_Zfhmin.enable_feature();\n+  }\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/riscv_hwprobe.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}