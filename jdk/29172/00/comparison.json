{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import java.util.function.Consumer;\n@@ -112,9 +113,0 @@\n-    public Executor setWinRunWithEnglishOutput(boolean value) {\n-        if (!TKit.isWindows()) {\n-            throw new UnsupportedOperationException(\n-                    \"setWinRunWithEnglishOutput is only valid on Windows platform\");\n-        }\n-        winEnglishOutput = value;\n-        return this;\n-    }\n-\n@@ -198,0 +190,5 @@\n+    public Executor processListener(Consumer<Process> v) {\n+        commandOutputControl.processListener(v);\n+        return this;\n+    }\n+\n@@ -313,5 +310,0 @@\n-        if (toolProvider != null && winEnglishOutput) {\n-            throw new IllegalArgumentException(\n-                    \"Can't change locale when using tool provider\");\n-        }\n-\n@@ -437,8 +429,0 @@\n-    private List<String> prefixCommandLineArgs() {\n-        if (winEnglishOutput) {\n-            return List.of(\"cmd.exe\", \"\/c\", \"chcp\", \"437\", \">nul\", \"2>&1\", \"&&\");\n-        } else {\n-            return List.of();\n-        }\n-    }\n-\n@@ -447,1 +431,0 @@\n-        command.addAll(prefixCommandLineArgs());\n@@ -525,2 +508,1 @@\n-        var cmdline = Stream.of(prefixCommandLineArgs(), List.of(exec), args).flatMap(\n-                List::stream).toList();\n+        var cmdline = Stream.of(List.of(exec), args).flatMap(List::stream).toList();\n@@ -562,1 +544,0 @@\n-    private boolean winEnglishOutput;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":7,"deletions":26,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.function.Consumer;\n@@ -318,2 +319,1 @@\n-        AppOutputVerifier av = assertMainLauncher(cmd, args);\n-        if (av != null) {\n+        assertMainLauncher(cmd, args).ifPresent(av -> {\n@@ -321,1 +321,1 @@\n-        }\n+        });\n@@ -326,2 +326,1 @@\n-        AppOutputVerifier av = assertMainLauncher(cmd, args);\n-        if (av != null) {\n+        return assertMainLauncher(cmd, args).map(av -> {\n@@ -329,3 +328,1 @@\n-        } else {\n-            return null;\n-        }\n+        }).orElseThrow();\n@@ -334,1 +331,1 @@\n-    public static AppOutputVerifier assertMainLauncher(JPackageCommand cmd,\n+    public static Optional<AppOutputVerifier> assertMainLauncher(JPackageCommand cmd,\n@@ -339,1 +336,1 @@\n-            return null;\n+            return Optional.empty();\n@@ -342,1 +339,1 @@\n-        return assertApp(launcherPath)\n+        return Optional.of(assertApp(launcherPath)\n@@ -348,1 +345,1 @@\n-                .orElseGet(() -> new String[0]));\n+                .orElseGet(() -> new String[0])));\n@@ -429,0 +426,5 @@\n+        public AppOutputVerifier processListener(Consumer<Process> v) {\n+            processListener = v;\n+            return this;\n+        }\n+\n@@ -482,0 +484,1 @@\n+                    .processListener(processListener)\n@@ -496,0 +499,1 @@\n+        private Consumer<Process> processListener;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -309,85 +307,0 @@\n-    public static void killProcess(long pid) {\n-        Executor.of(\"taskkill\", \"\/F\", \"\/PID\", Long.toString(pid)).dumpOutput(true).execute();\n-    }\n-\n-    public static void killAppLauncherProcess(JPackageCommand cmd,\n-            String launcherName, int expectedCount) {\n-        var pids = findAppLauncherPIDs(cmd, launcherName);\n-        try {\n-            TKit.assertEquals(expectedCount, pids.length, String.format(\n-                    \"Check [%d] %s app launcher processes found running\",\n-                    expectedCount, Optional.ofNullable(launcherName).map(\n-                            str -> \"[\" + str + \"]\").orElse(\"<main>\")));\n-        } finally {\n-            if (pids.length != 0) {\n-                killProcess(pids[0]);\n-            }\n-        }\n-    }\n-\n-    private static long[] findAppLauncherPIDs(JPackageCommand cmd, String launcherName) {\n-        \/\/ Get the list of PIDs and PPIDs of app launcher processes. Run setWinRunWithEnglishOutput(true) for JDK-8344275.\n-        \/\/ powershell -NoLogo -NoProfile -NonInteractive -Command\n-        \/\/   \"Get-CimInstance Win32_Process -Filter \\\"Name = 'foo.exe'\\\" | select ProcessID,ParentProcessID\"\n-        String command = \"Get-CimInstance Win32_Process -Filter \\\\\\\"Name = '\"\n-                + cmd.appLauncherPath(launcherName).getFileName().toString()\n-                + \"'\\\\\\\" | select ProcessID,ParentProcessID\";\n-        List<String> output = Executor.of(\"powershell\", \"-NoLogo\", \"-NoProfile\", \"-NonInteractive\", \"-Command\", command)\n-                .dumpOutput(true).saveOutput().setWinRunWithEnglishOutput(true).executeAndGetOutput();\n-\n-        if (output.size() < 1) {\n-            return new long[0];\n-        }\n-\n-        String[] headers = Stream.of(output.get(1).split(\"\\\\s+\", 2)).map(\n-                String::trim).map(String::toLowerCase).toArray(String[]::new);\n-        Pattern pattern;\n-        if (headers[0].equals(\"parentprocessid\") && headers[1].equals(\n-                \"processid\")) {\n-            pattern = Pattern.compile(\"^\\\\s+(?<ppid>\\\\d+)\\\\s+(?<pid>\\\\d+)$\");\n-        } else if (headers[1].equals(\"parentprocessid\") && headers[0].equals(\n-                \"processid\")) {\n-            pattern = Pattern.compile(\"^\\\\s+(?<pid>\\\\d+)\\\\s+(?<ppid>\\\\d+)$\");\n-        } else {\n-            throw new RuntimeException(\n-                    \"Unrecognizable output of \\'Get-CimInstance Win32_Process\\' command\");\n-        }\n-\n-        List<long[]> processes = output.stream().skip(3).map(line -> {\n-            Matcher m = pattern.matcher(line);\n-            long[] pids = null;\n-            if (m.matches()) {\n-                pids = new long[]{Long.parseLong(m.group(\"pid\")), Long.\n-                    parseLong(m.group(\"ppid\"))};\n-            }\n-            return pids;\n-        }).filter(Objects::nonNull).toList();\n-\n-        switch (processes.size()) {\n-            case 2 -> {\n-                final long parentPID;\n-                final long childPID;\n-                if (processes.get(0)[0] == processes.get(1)[1]) {\n-                    parentPID = processes.get(0)[0];\n-                    childPID = processes.get(1)[0];\n-                } else if (processes.get(1)[0] == processes.get(0)[1]) {\n-                    parentPID = processes.get(1)[0];\n-                    childPID = processes.get(0)[0];\n-                } else {\n-                    TKit.assertUnexpected(\"App launcher processes unrelated\");\n-                    return null; \/\/ Unreachable\n-                }\n-                return new long[]{parentPID, childPID};\n-            }\n-            case 1 -> {\n-                return new long[]{processes.get(0)[0]};\n-            }\n-            default -> {\n-                TKit.assertUnexpected(String.format(\n-                        \"Unexpected number of running processes [%d]\",\n-                        processes.size()));\n-                return null; \/\/ Unreachable\n-            }\n-        }\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,1 @@\n-        var appVerifier = HelloApp.assertMainLauncher(cmd);\n-        if (appVerifier != null) {\n+        HelloApp.assertMainLauncher(cmd).ifPresent(appVerifier -> {\n@@ -56,1 +55,1 @@\n-        }\n+        });\n@@ -64,2 +63,1 @@\n-        var appVerifier = HelloApp.assertMainLauncher(cmd);\n-        if (appVerifier != null) {\n+        HelloApp.assertMainLauncher(cmd).ifPresent(appVerifier -> {\n@@ -68,1 +66,1 @@\n-        }\n+        });\n","filename":"test\/jdk\/tools\/jpackage\/macosx\/ArgumentsFilteringTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,2 +243,1 @@\n-            var appVerifier = HelloApp.assertMainLauncher(cmd);\n-            if (appVerifier != null) {\n+            HelloApp.assertMainLauncher(cmd).ifPresent(appVerifier -> {\n@@ -252,1 +251,1 @@\n-            }\n+            });\n","filename":"test\/jdk\/tools\/jpackage\/share\/MainClassTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n-\n@@ -27,0 +25,3 @@\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n@@ -30,0 +31,1 @@\n+import jdk.jpackage.test.TKit;\n@@ -49,1 +51,1 @@\n-    public void test() throws InterruptedException {\n+    public void test() throws InterruptedException, ExecutionException {\n@@ -57,0 +59,2 @@\n+        var f = new CompletableFuture<Process>();\n+\n@@ -59,1 +63,1 @@\n-            HelloApp.executeLauncher(cmd);\n+            HelloApp.assertMainLauncher(cmd).get().processListener(f::complete).execute();\n@@ -62,2 +66,13 @@\n-        \/\/ Wait a bit to let the app start\n-        Thread.sleep(Duration.ofSeconds(10));\n+        var mainLauncherProcess = f.get();\n+\n+        Optional<ProcessHandle> childProcess = Optional.empty();\n+\n+        try {\n+            \/\/ Wait a bit to let the app start\n+            Thread.sleep(Duration.ofSeconds(10));\n+\n+            try (var children = mainLauncherProcess.children()) {\n+                childProcess = children.filter(p -> {\n+                    return mainLauncherProcess.info().command().equals(p.info().command());\n+                }).findFirst();\n+            }\n@@ -65,2 +80,6 @@\n-        \/\/ Find the main app launcher process and kill it\n-        killAppLauncherProcess(cmd, null, 2);\n+            TKit.assertTrue(childProcess.isPresent(),\n+                    String.format(\"Check the main launcher process with PID=%d restarted\", mainLauncherProcess.pid()));\n+        } finally {\n+            \/\/ Kill the main app launcher process\n+            TKit.trace(\"About to kill the main launcher process...\");\n+            mainLauncherProcess.destroyForcibly();\n@@ -68,2 +87,2 @@\n-        \/\/ Wait a bit and check if child app launcher process is still running (it must NOT)\n-        Thread.sleep(Duration.ofSeconds(5));\n+            \/\/ Wait a bit and check if child app launcher process is still running (it must NOT)\n+            Thread.sleep(Duration.ofSeconds(5));\n@@ -71,1 +90,5 @@\n-        killAppLauncherProcess(cmd, null, 0);\n+            childProcess.ifPresent(p -> {\n+                TKit.assertTrue(!p.isAlive(), String.format(\n+                        \"Check restarted main launcher process with PID=%d is not alive\", p.pid()));\n+            });\n+        }\n","filename":"test\/jdk\/tools\/jpackage\/windows\/Win8301247Test.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-import static jdk.jpackage.test.WindowsHelper.killProcess;\n@@ -55,1 +54,1 @@\n-        long childPid = 0;\n+        Optional<ProcessHandle> child = Optional.empty();\n@@ -72,1 +71,1 @@\n-            childPid = Long.parseLong(pidStr.split(\"=\", 2)[1]);\n+            var childPid = Long.parseLong(pidStr.split(\"=\", 2)[1]);\n@@ -78,4 +77,3 @@\n-            Optional<ProcessHandle> processHandle = ProcessHandle.of(childPid);\n-            boolean isAlive = processHandle.isPresent()\n-                    && processHandle.get().isAlive();\n-            TKit.assertTrue(isAlive, \"Check child process is alive\");\n+            child = ProcessHandle.of(childPid);\n+            boolean isAlive = child.map(ProcessHandle::isAlive).orElse(false);\n+            TKit.assertTrue(isAlive, String.format(\"Check child process with PID=%d is alive\", childPid));\n@@ -83,4 +81,2 @@\n-            if (childPid != 0) {\n-                \/\/ Kill only a specific child instance\n-                killProcess(childPid);\n-            }\n+            TKit.trace(\"About to kill the child process...\");\n+            child.ifPresent(ProcessHandle::destroyForcibly);\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinChildProcessTest.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import static jdk.jpackage.test.WindowsHelper.killAppLauncherProcess;\n@@ -29,0 +28,3 @@\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n@@ -33,0 +35,1 @@\n+import jdk.jpackage.test.TKit;\n@@ -50,1 +53,1 @@\n-    public static void test() throws InterruptedException, IOException {\n+    public static void test() throws InterruptedException, IOException, ExecutionException {\n@@ -80,1 +83,1 @@\n-        void apply(JPackageCommand cmd, CfgFile origCfgFile) throws InterruptedException {\n+        void apply(JPackageCommand cmd, CfgFile origCfgFile) throws InterruptedException, ExecutionException {\n@@ -95,0 +98,2 @@\n+            var f = new CompletableFuture<Process>();\n+\n@@ -97,1 +102,1 @@\n-                HelloApp.executeLauncher(cmd);\n+                HelloApp.assertMainLauncher(cmd).get().processListener(f::complete).execute();\n@@ -100,5 +105,27 @@\n-            \/\/ Wait a bit to let the app start\n-            Thread.sleep(Duration.ofSeconds(10));\n-\n-            \/\/ Find the main app launcher process and kill it\n-            killAppLauncherProcess(cmd, null, expectedNoRestarted ? 1 : 2);\n+            var mainLauncherProcess = f.get();\n+\n+            try {\n+                \/\/ Wait a bit to let the app start\n+                Thread.sleep(Duration.ofSeconds(10));\n+\n+                try (var children = mainLauncherProcess.children()) {\n+                    Optional<String> childPid = children.filter(p -> {\n+                        return mainLauncherProcess.info().command().equals(p.info().command());\n+                    }).map(ProcessHandle::pid).map(Object::toString).findFirst();\n+\n+                    Optional<String> expectedChildPid;\n+                    if (expectedNoRestarted) {\n+                        expectedChildPid = Optional.empty();\n+                    } else {\n+                        expectedChildPid = childPid.or(() -> {\n+                            return Optional.of(\"<some>\");\n+                        });\n+                    }\n+                    TKit.assertEquals(expectedChildPid, childPid, String.format(\n+                            \"Check the main launcher process with PID=%d restarted\",\n+                            mainLauncherProcess.pid()));\n+                }\n+            } finally {\n+                TKit.trace(\"About to kill the main launcher process...\");\n+                mainLauncherProcess.destroyForcibly();\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinNoRestartTest.java","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"}]}