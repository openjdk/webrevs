{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -234,0 +235,2 @@\n+  DEBUG_ONLY(volatile bool _out_of_stack_walking_enabled;)\n+  DEBUG_ONLY(volatile u8 _out_of_stack_walking_iterations;)\n@@ -279,0 +282,10 @@\n+\n+  #ifdef ASSERT\n+  void set_out_of_stack_walking_enabled(bool runnable) {\n+    Atomic::release_store(&_out_of_stack_walking_enabled, runnable);\n+  }\n+\n+  u8 out_of_stack_walking_iterations() const {\n+    return Atomic::load(&_out_of_stack_walking_iterations);\n+  }\n+  #endif\n@@ -383,4 +396,6 @@\n-\n-    if (Atomic::cmpxchg(&_is_async_processing_of_cpu_time_jfr_requests_triggered, true, false)) {\n-      stackwalk_threads_in_native();\n-    }\n+    DEBUG_ONLY(if (Atomic::load_acquire(&_out_of_stack_walking_enabled)) {)\n+      if (Atomic::cmpxchg(&_is_async_processing_of_cpu_time_jfr_requests_triggered, true, false)) {\n+        DEBUG_ONLY(Atomic::inc(&_out_of_stack_walking_iterations);)\n+        stackwalk_threads_in_native();\n+      }\n+    DEBUG_ONLY(})\n@@ -576,0 +591,15 @@\n+#ifdef ASSERT\n+void JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(bool runnable) {\n+  if (_instance != nullptr && _instance->_sampler != nullptr) {\n+    _instance->_sampler->set_out_of_stack_walking_enabled(runnable);\n+  }\n+}\n+\n+u8 JfrCPUTimeThreadSampling::out_of_stack_walking_iterations() {\n+  if (_instance != nullptr && _instance->_sampler != nullptr) {\n+    return _instance->_sampler->out_of_stack_walking_iterations();\n+  }\n+  return 0;\n+}\n+#endif\n+\n@@ -839,0 +869,6 @@\n+#ifdef ASSERT\n+static void set_out_of_stack_walking_enabled(bool runnable) {\n+  warn();\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":40,"deletions":4,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -141,0 +142,4 @@\n+\n+  DEBUG_ONLY(static void set_out_of_stack_walking_enabled(bool runnable);)\n+\n+  DEBUG_ONLY(static u8 out_of_stack_walking_iterations();)\n@@ -161,0 +166,2 @@\n+  DEBUG_ONLY(static void set_out_of_stack_walking_enabled(bool runnable));\n+  DEBUG_ONLY(static u8 out_of_stack_walking_iterations();)\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2669,0 +2669,17 @@\n+WB_ENTRY(jboolean, WB_CPUSamplerSetOutOfStackWalking(JNIEnv* env, jobject wb, jboolean enable))\n+  #ifdef ASSERT\n+    JfrCPUTimeThreadSampling::set_out_of_stack_walking_enabled(enable == JNI_TRUE);\n+    return JNI_TRUE;\n+  #else\n+    return JNI_FALSE;\n+  #endif\n+WB_END\n+\n+WB_ENTRY(jlong, WB_CPUSamplerOutOfStackWalkingIterations(JNIEnv* env, jobject wb))\n+  #ifdef ASSERT\n+    return (jlong)JfrCPUTimeThreadSampling::out_of_stack_walking_iterations();\n+  #else\n+    return 0;\n+  #endif\n+WB_END\n+\n@@ -3023,0 +3040,2 @@\n+  {CC\"cpuSamplerSetOutOfStackWalking\", CC\"(Z)Z\",      (void*)&WB_CPUSamplerSetOutOfStackWalking},\n+  {CC\"cpuSamplerOutOfStackWalkingIterations\", CC\"()J\",(void*)&WB_CPUSamplerOutOfStackWalkingIterations},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2766,1 +2766,1 @@\n-#ifdef DEBUG\n+#ifdef ASSERT\n","filename":"src\/java.base\/share\/native\/libverify\/check_code.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @requires vm.hasJFR & os.family == \"linux\"\n+ * @requires vm.hasJFR & os.family == \"linux\" & vm.debug\n@@ -116,0 +116,1 @@\n+            WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n@@ -117,2 +118,2 @@\n-            \/\/ launch first burst\n-            Thread burstThread = new Thread(() -> runInBursts(10, 1000));\n+            \/\/ this thread runs all along\n+            Thread burstThread = new Thread(() -> WHITE_BOX.busyWait(11000));\n@@ -121,3 +122,16 @@\n-            \/\/ keep the out-of-start-sampler busy\n-            runMiscThreads(11000);\n-            burstThread.join();\n+            \/\/ now we toggle out-of-stack-walking off, wait 1 second and then turn it on for 500ms a few times\n+            for (int i = 0; i < 5; i++) {\n+                boolean supported = WHITE_BOX.cpuSamplerSetOutOfStackWalking(false);\n+                if (!supported) {\n+                    System.out.println(\"Out-of-stack-walking not supported, skipping test\");\n+                    Asserts.assertFalse(true);\n+                    return;\n+                }\n+                Thread.sleep(700);\n+                long iterations = WHITE_BOX.cpuSamplerOutOfStackWalkingIterations();\n+                WHITE_BOX.cpuSamplerSetOutOfStackWalking(true);\n+                Thread.sleep(300);\n+                while (WHITE_BOX.cpuSamplerOutOfStackWalkingIterations() == iterations) {\n+                    Thread.sleep(50); \/\/ just to make sure the stack walking really ran\n+                }\n+            }\n@@ -136,1 +150,1 @@\n-        \/\/ check that the second to last interval has fewer lost samples than the first\n+        \/\/ check that the second to last interval has far fewer lost samples than the first\n@@ -138,20 +152,1 @@\n-                           intervalLosses.get(0).lostSamples);\n-    }\n-\n-\n-\n-    static void runMiscThreads(int timeMs) throws Exception {\n-        Thread[] threads = new Thread[Runtime.getRuntime().availableProcessors() - 1];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new Thread(() -> WHITE_BOX.busyWait(timeMs));\n-            threads[i].start();\n-        }\n-        for (Thread thread : threads) {\n-            thread.join();\n-        }\n-    }\n-\n-    static void runInBursts(int count, int burstMs) {\n-        for (int i = 0; i < count; i++) {\n-            WHITE_BOX.busyWait(burstMs);\n-        }\n+                           intervalLosses.get(0).lostSamples \/ 2);\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleQueueAutoSizes.java","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -846,0 +846,5 @@\n+  \/\/ returns true if supported, false if not\n+  public native boolean cpuSamplerSetOutOfStackWalking(boolean enable);\n+\n+  public native long cpuSamplerOutOfStackWalkingIterations();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}