{"files":[{"patch":"@@ -70,1 +70,1 @@\n-   _data(nullptr), _capacity(capacity), _head(0), _lost_samples(0) {\n+   _data(nullptr), _capacity(capacity), _head(0), _lost_samples(0), _lost_samples_due_to_queue_full(0) {\n@@ -113,1 +113,1 @@\n-  return _capacity;\n+  return Atomic::load_acquire(&_capacity);\n@@ -117,0 +117,3 @@\n+  if (capacity == Atomic::load(&_capacity)) {\n+    return;\n+  }\n@@ -127,1 +130,1 @@\n-  _capacity = capacity;\n+  Atomic::release_store(&_capacity, capacity);\n@@ -143,0 +146,4 @@\n+void JfrCPUTimeTraceQueue::increment_lost_samples_due_to_queue_full() {\n+  Atomic::inc(&_lost_samples_due_to_queue_full);\n+}\n+\n@@ -147,4 +154,2 @@\n-void JfrCPUTimeTraceQueue::resize(u4 capacity) {\n-  if (capacity != _capacity) {\n-    set_capacity(capacity);\n-  }\n+u4 JfrCPUTimeTraceQueue::get_and_reset_lost_samples_due_to_queue_full() {\n+  return Atomic::xchg(&_lost_samples_due_to_queue_full, (u4)0);\n@@ -153,6 +158,2 @@\n-void JfrCPUTimeTraceQueue::resize_for_period(u4 period_millis) {\n-  u4 capacity = CPU_TIME_QUEUE_CAPACITY;\n-  if (period_millis > 0 && period_millis < 10) {\n-    capacity = (u4) ((double) capacity * 10 \/ period_millis);\n-  }\n-  resize(capacity);\n+void JfrCPUTimeTraceQueue::init() {\n+  set_capacity(JfrCPUTimeTraceQueue::CPU_TIME_QUEUE_INITIAL_CAPACITY);\n@@ -165,0 +166,25 @@\n+void JfrCPUTimeTraceQueue::resize_if_needed() {\n+  u4 lost_samples_due_to_queue_full = get_and_reset_lost_samples_due_to_queue_full();\n+  if (lost_samples_due_to_queue_full == 0) {\n+    return;\n+  }\n+  u4 capacity = Atomic::load(&_capacity);\n+  if (capacity < CPU_TIME_QUEUE_MAX_CAPACITY) {\n+    float ratio = (float)lost_samples_due_to_queue_full \/ (float)capacity;\n+    int factor = 1;\n+    if (ratio > 8) { \/\/ idea is to quickly scale the queue in the worst case\n+      factor = ratio;\n+    } else if (ratio > 2) {\n+      factor = 8;\n+    } else if (ratio > 0.5) {\n+      factor = 4;\n+    } else if (ratio > 0.01) {\n+      factor = 2;\n+    }\n+    if (factor > 1) {\n+      u4 new_capacity = _capacity * factor > CPU_TIME_QUEUE_MAX_CAPACITY ? CPU_TIME_QUEUE_MAX_CAPACITY : capacity * factor;\n+      set_capacity(new_capacity);\n+    }\n+  }\n+}\n+\n@@ -278,1 +304,1 @@\n-  tl->cpu_time_jfr_queue().resize_for_period(_current_sampling_period_ns \/ 1000000);\n+  tl->cpu_time_jfr_queue().init();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":40,"deletions":14,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  u4 _capacity;\n+  volatile u4 _capacity;\n@@ -58,0 +58,1 @@\n+  volatile u4 _lost_samples_due_to_queue_full;\n@@ -59,0 +60,2 @@\n+  static const u4 CPU_TIME_QUEUE_INITIAL_CAPACITY = 20;\n+  static const u4 CPU_TIME_QUEUE_MAX_CAPACITY     = 2000;\n@@ -84,0 +87,2 @@\n+  void increment_lost_samples_due_to_queue_full();\n+\n@@ -87,1 +92,3 @@\n-  void resize(u4 capacity);\n+  u4 get_and_reset_lost_samples_due_to_queue_full();\n+\n+  void resize_if_needed();\n@@ -89,1 +96,2 @@\n-  void resize_for_period(u4 period_millis);\n+  \/\/ init the queue capacity\n+  void init();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+    queue.resize_if_needed();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampling.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -659,1 +659,1 @@\n-  cpu_time_jfr_queue().resize(0);\n+  cpu_time_jfr_queue().set_capacity(0);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}