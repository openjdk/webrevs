{"files":[{"patch":"@@ -53,1 +53,1 @@\n-volatile intx JVMCI::_fatal_log_init_thread = -1;\n+volatile intx JVMCI::_first_error_tid = -1;\n@@ -357,1 +357,1 @@\n-  if (_fatal_log_init_thread == invalid_id && Atomic::cmpxchg(&_fatal_log_init_thread, invalid_id, current_thread_id) == invalid_id) {\n+  if (_first_error_tid == invalid_id && Atomic::cmpxchg(&_first_error_tid, invalid_id, current_thread_id) == invalid_id) {\n@@ -378,8 +378,7 @@\n-  } else {\n-    \/\/ Another thread won the race to initialize the stream. Give it time\n-    \/\/ to complete initialization. VM locks cannot be used as the current\n-    \/\/ thread might not be attached to the VM (e.g. a native thread started\n-    \/\/ within libjvmci).\n-    while (_fatal_log_fd == -1) {\n-      os::naked_short_sleep(50);\n-    }\n+  } else if (_first_error_tid != current_thread_id) {\n+    \/\/ This is not the first thread reporting a libjvmci error\n+    tty->print_cr(\"[thread \" INTX_FORMAT \" also had an error in the JVMCI native library]\",\n+                    current_thread_id);\n+\n+    \/\/ Fatal error reporting is single threaded so just block this thread.\n+    os::infinite_sleep();\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-  \/\/ Native thread id of thread that will initialize _fatal_log_fd.\n-  static volatile intx _fatal_log_init_thread;\n+  \/\/ Thread id of the first thread reporting a libjvmci error.\n+  static volatile intx _first_error_tid;\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}