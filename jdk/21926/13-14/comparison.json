{"files":[{"patch":"@@ -227,1 +227,1 @@\n-    switch(n->Opcode()) {\n+    switch (n->Opcode()) {\n@@ -273,5 +273,2 @@\n-  if (holder_symbol != vmSymbols::jdk_internal_foreign_NativeMemorySegmentImpl() ||\n-      field_symbol != vmSymbols::min_name()) {\n-    return false;\n-  }\n-  return true;\n+  return holder_symbol == vmSymbols::jdk_internal_foreign_NativeMemorySegmentImpl() &&\n+         field_symbol == vmSymbols::min_name();\n@@ -607,1 +604,1 @@\n-  \/\/   distance <= -other.size    ||  this.size <= distance\n+  \/\/   distance <= -other.size         ||  this.size <= distance\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-\/\/     assume that such base addresses are aligned (need to add this speculative check in  JDK-8323582).\n+\/\/     assume that such base addresses are aligned (TODO: need to add this speculative check in JDK-8323582).\n@@ -243,1 +243,1 @@\n-\/\/          This would be preferrable over CastX2P, because it holds the address() of a native\n+\/\/          This would be preferable over CastX2P, because it holds the address() of a native\n@@ -610,3 +610,3 @@\n-    Node* object()           const { assert(is_object(), \"\"); return _base; }\n-    Node* native()           const { assert(is_native(), \"\"); return _base; }\n-    Node* object_or_native() const { assert(is_known(),  \"\"); return _base; }\n+    Node* object()           const { assert(is_object(), \"unexpected kind\"); return _base; }\n+    Node* native()           const { assert(is_native(), \"unexpected kind\"); return _base; }\n+    Node* object_or_native() const { assert(is_known(),  \"unexpected kind\"); return _base; }\n@@ -678,1 +678,1 @@\n-    \/\/ Put the base in in the 0th summand.\n+    \/\/ Put the base in the 0th summand.\n@@ -763,1 +763,1 @@\n-      assert(false, \"unknonw base case is not answered optimally\");\n+      assert(false, \"unknown base case is not answered optimally\");\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -483,2 +483,2 @@\n-  \/\/      Note: we have been assuming that this also holds for native memory base\n-  \/\/            addresses. This is incorrect, see JDK-8323582.\n+  \/\/      TODO: Note: we have been assuming that this also holds for native memory base\n+  \/\/                  addresses. This is incorrect, see JDK-8323582.\n@@ -525,1 +525,1 @@\n-  \/\/ Note: the following assumption is incorrect for native memory bases, see JDK-8323582.\n+  \/\/ TODO: Note: the following assumption is incorrect for native memory bases, see JDK-8323582.\n@@ -883,1 +883,1 @@\n-  \/\/        Note: this assumption is incorrect for native memory bases, see JDK-8323582.\n+  \/\/        TODO: Note: this assumption is incorrect for native memory bases, see JDK-8323582.\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-\/\/ It wraps a VPointer. The VPointer have an iv_offset applied, which\n+\/\/ It wraps a VPointer. The VPointer has an iv_offset applied, which\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}