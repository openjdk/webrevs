{"files":[{"patch":"@@ -541,0 +541,15 @@\n+\/\/ Examples:\n+\/\/   p1 = MemPointer[size=1, base + i + 16]\n+\/\/   p2 = MemPointer[size=1, base + i + 17]\n+\/\/   -> Always at distance 1\n+\/\/   -> p1 always adjacent and before p2 -> return true\n+\/\/\n+\/\/   p1 = MemPointer[size=4, x + y + z + 4L * i + 16]\n+\/\/   p2 = MemPointer[size=4, x + y + z + 4L * i + 20]\n+\/\/   -> Always at distance 4\n+\/\/   -> p1 always adjacent and before p2 -> return true\n+\/\/\n+\/\/   p1 = MemPointer[size=4, base1 + 4L * i1 + 16]\n+\/\/   p2 = MemPointer[size=4, base2 + 4L * i2 + 20]\n+\/\/   -> Have differing summands, distance is unknown\n+\/\/   -> Unknown if adjacent at runtime -> return false\n@@ -557,0 +572,25 @@\n+\/\/ Examples:\n+\/\/   p1 = MemPointer[size=1, base + i + 16]\n+\/\/   p2 = MemPointer[size=1, base + i + 17]\n+\/\/   -> Always at distance 1\n+\/\/   -> Can never overlap -> return true\n+\/\/\n+\/\/   p1 = MemPointer[size=1, base + i + 16]\n+\/\/   p2 = MemPointer[size=1, base + i + 16]\n+\/\/   -> Always at distance 0\n+\/\/   -> Always have exact overlap -> return false\n+\/\/\n+\/\/   p1 = MemPointer[size=4, x + y + z + 4L * i + 16]\n+\/\/   p2 = MemPointer[size=4, x + y + z + 4L * i + 56]\n+\/\/   -> Always at distance 40\n+\/\/   -> Can never overlap -> return true\n+\/\/\n+\/\/   p1 = MemPointer[size=8, x + y + z + 4L * i + 16]\n+\/\/   p2 = MemPointer[size=8, x + y + z + 4L * i + 20]\n+\/\/   -> Always at distance 4\n+\/\/   -> Always have partial overlap -> return false\n+\/\/\n+\/\/   p1 = MemPointer[size=4, base1 + 4L * i1 + 16]\n+\/\/   p2 = MemPointer[size=4, base2 + 4L * i2 + 20]\n+\/\/   -> Have differing summands, distance is unknown\n+\/\/   -> Unknown if overlap at runtime -> return false\n","filename":"src\/hotspot\/share\/opto\/mempointer.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -561,1 +561,6 @@\n-\/\/ Decomposed form of the pointer sub-expression of \"pointer\".\n+\/\/ A MemPointer points to a region in memory, starting at a \"pointer\", and extending\n+\/\/ for \"size\" bytes:\n+\/\/\n+\/\/   [pointer, pointer + size)\n+\/\/\n+\/\/ Where the \"pointer\" is decomposed into the following form:\n@@ -564,0 +569,3 @@\n+\/\/   pointer = SUM(scale_i * variable_i) + con\n+\/\/\n+\/\/ Where SUM() adds all \"scale_i * variable_i\" for each i together.\n@@ -568,0 +576,4 @@\n+\/\/\n+\/\/   pointer = scale_0 * variable_0 + scale_1 * scale_1 + ... + con\n+\/\/   pointer =       1 * base       + scale_1 * scale_1 + ... + con\n+\/\/\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -846,2 +846,2 @@\n-  \/\/ between 1 and ObjectAlignmentInBytes. If the invar is empty,\n-  \/\/ i.e. there is no summand in invar_summands, we return 0.\n+  \/\/ between (inclusive) 1 and ObjectAlignmentInBytes. If the invar\n+  \/\/ is empty, i.e. there is no summand in invar_summands, we return 0.\n@@ -868,0 +868,2 @@\n+  \/\/ If we have the same invar_summands, and the same iv summand with the same iv_scale,\n+  \/\/ then all summands except the base must be the same.\n@@ -869,2 +871,0 @@\n-    \/\/ If we have the same invar_summands, and the same iv summand with the same iv_scale,\n-    \/\/ then all summands except the base must be the same.\n@@ -874,0 +874,3 @@\n+\n+  \/\/ Delegate to MemPointer::is_adjacent_to_and_before, but guard for invalid cases\n+  \/\/ where we must return a conservative answer: unknown adjacency, return false.\n@@ -886,0 +889,2 @@\n+  \/\/ Delegate to MemPointer::never_overlaps_with, but guard for invalid cases\n+  \/\/ where we must return a conservative answer: unknown overlap, return false.\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"}]}