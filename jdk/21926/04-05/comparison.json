{"files":[{"patch":"@@ -104,0 +104,6 @@\n+  \/\/ This \"cmp\" is used for sort only.\n+  \/\/ Note: the NaN semantics are different from floating arithmetic NaNs!\n+  \/\/ - Smaller non-NaN are before larger non-NaN.\n+  \/\/ - Any non-NaN are before NaN.\n+  \/\/ - NaN is equal to NaN.\n+  \/\/ Note: NaN indicate overflow, uninitialized, etc.\n@@ -105,1 +111,0 @@\n-    \/\/ Order NaN (overflow, uninitialized, etc) after non-NaN.\n","filename":"src\/hotspot\/share\/opto\/noOverflowInt.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -648,5 +648,0 @@\n-    \/\/ @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n-    \/\/               IRNode.ADD_VB,        \"= 0\",\n-    \/\/               IRNode.STORE_VECTOR,  \"= 0\"},\n-    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n-    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -655,1 +650,1 @@\n-    \/\/ Interestingly, it now passes for native, but not for objects.\n+    \/\/ Interestingly, it now vectorizes for native, but not for arrays.\n@@ -667,5 +662,0 @@\n-    \/\/ @IR(counts = {IRNode.LOAD_VECTOR_B, \"= 0\",\n-    \/\/               IRNode.ADD_VB,        \"= 0\",\n-    \/\/               IRNode.STORE_VECTOR,  \"= 0\"},\n-    \/\/     applyIfPlatform = {\"64-bit\", \"true\"},\n-    \/\/     applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n@@ -674,1 +664,1 @@\n-    \/\/ Interestingly, it now passes for native, but not for objects.\n+    \/\/ Interestingly, it now vectorizes for native, but not for arrays.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"}]}