{"files":[{"patch":"@@ -510,1 +510,2 @@\n-    } else if (p2.variable() == nullptr) {\n+    }\n+    if (p2.variable() == nullptr) {\n@@ -513,1 +514,0 @@\n-\n@@ -829,0 +829,5 @@\n+\/\/ Utility class.\n+\/\/ MemPointerParser::parse takes a MemNode (load or store) and computes its MemPointer.\n+\/\/ It temporarily allocates dynamic data structures (GrowableArray) in the resource\n+\/\/ area. This way, the computed MemPointer does not have to have any dynamic data\n+\/\/ structures and can be copied freely by value.\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -98,0 +98,3 @@\n+\/\/ SuperWord unrolling analysis does:\n+\/\/ - Determine if the loop is a candidate for auto vectorization (SuperWord).\n+\/\/ - Find a good unrolling factor, to ensure full vector width utilization once we vectorize.\n@@ -559,1 +562,1 @@\n-void SuperWord::collect_valid_memops(GrowableArray<MemOp>& memops) {\n+void SuperWord::collect_valid_memops(GrowableArray<MemOp>& memops) const {\n@@ -2837,1 +2840,0 @@\n-  bool is_base_native = p.mem_pointer().base().is_native();\n@@ -2930,0 +2932,1 @@\n+  bool is_base_native = p.mem_pointer().base().is_native();\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -597,1 +597,1 @@\n-  void collect_valid_memops(GrowableArray<MemOp>& memops);\n+  void collect_valid_memops(GrowableArray<MemOp>& memops) const;\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,2 +185,2 @@\n-  uint bytes2 = _vpointers_length * sizeof(VPointer);\n-  _vpointers = (VPointer*)_arena->Amalloc(bytes2);\n+  uint bytes = _vpointers_length * sizeof(VPointer);\n+  _vpointers = (VPointer*)_arena->Amalloc(bytes);\n@@ -962,1 +962,1 @@\n-    tty->print(\" + con(%d) + invar + iv_scale(%d) * iv\", _vpointer.con(), iv_scale());\n+    tty->print(\" + invar + iv_scale(%d) * iv + con(%d)\", iv_scale(), _vpointer.con());\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @bug 8343685 8330274\n+ * @bug 8343685 8331659\n@@ -887,1 +887,1 @@\n-    \/\/ FAILS: should be ok to vectorize, but does not. Investigate in JDK-8330274.\n+    \/\/ FAILS: should be ok to vectorize, but does not. Investigate in JDK-8331659.\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEquivalentInvariants.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -649,1 +649,1 @@\n-    \/\/ See: JDK-8330274\n+    \/\/ See: JDK-8331659\n@@ -663,1 +663,1 @@\n-    \/\/ See: JDK-8330274\n+    \/\/ See: JDK-8331659\n@@ -750,1 +750,1 @@\n-    \/\/ See: JDK-8330274\n+    \/\/ See: JDK-8331659\n@@ -768,1 +768,1 @@\n-    \/\/ See: JDK-8330274\n+    \/\/ See: JDK-8331659\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}