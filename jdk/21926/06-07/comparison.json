{"files":[{"patch":"@@ -576,0 +576,5 @@\n+  \/\/ A base can be:\n+  \/\/ - Known:\n+  \/\/   - On-heap: Object\n+  \/\/   - Off-heap: Native\n+  \/\/ - Unknown\n","filename":"src\/hotspot\/share\/opto\/mempointer.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -701,1 +701,1 @@\n-\/\/ VPointer wraps the MemPointer for the use in a loop:\n+\/\/ Reminder: MemPointer have the form:\n@@ -705,2 +705,6 @@\n-\/\/ We define invar_summands as all summands, except those where the variable is\n-\/\/ the base or the loop iv. We can thus write:\n+\/\/ Where every summand in summands has the form:\n+\/\/\n+\/\/   summand = scale * variable\n+\/\/\n+\/\/ The VPointer wraps a MemPointer for the use in loops. A \"valid\" VPointer has\n+\/\/ the form:\n@@ -712,2 +716,2 @@\n-\/\/ We have the following components:\n-\/\/   - base:\n+\/\/ Where:\n+\/\/   - base: is the known base of the MemPointer.\n@@ -715,4 +719,1 @@\n-\/\/   - invar_summands:\n-\/\/       pre-loop invariant. This is important when we need to memory align a\n-\/\/       pointer using the pre-loop limit.\n-\/\/   - iv and iv_scale:\n+\/\/   - iv and iv_scale: i.e. the iv_summand = iv * iv_scale.\n@@ -723,0 +724,23 @@\n+\/\/   - invar_summands: all other summands except base and iv_summand.\n+\/\/       All variables must be pre-loop invariant. This is important when we need\n+\/\/       to memory align a pointer using the pre-loop limit.\n+\/\/\n+\/\/ A VPointer can be marked \"invalid\", if some of these conditions are not met, or\n+\/\/ it is unknown if they are met. If a VPointer is marked \"invalid\", it always\n+\/\/ returns conservative answers to aliasing queries, which means that we do not\n+\/\/ optimize in these cases. For example:\n+\/\/    - is_adjacent_to_and_before: returning true would allow optimizations such as\n+\/\/                                 packing into vectors. So for \"invalid\" VPointers\n+\/\/                                 we always return false (i.e. unknown).\n+\/\/    - never_overlaps_with: returning true would allow optimizations such as\n+\/\/                           swapping the order of memops. So for \"invalid\" VPointers\n+\/\/                           we always return false (i.e. unknown).\n+\/\/\n+\/\/ These are examples where a VPointer becomes \"invalid\":\n+\/\/    - If the MemPointer does not have the required form for VPointer,\n+\/\/      i.e. if one of these conditions is not met (see init_is_valid):\n+\/\/      - Base must be known.\n+\/\/      - All summands except the iv-summand must be pre-loop invariant.\n+\/\/      - Some restrictions on iv_scale and iv_stride, to avoid overflow in\n+\/\/        alignment computations.\n+\/\/    - If the new con computed in make_with_iv_offset overflows.\n@@ -742,0 +766,4 @@\n+  VPointer make_invalid() const {\n+    return VPointer(_vloop, mem_pointer(), true \/* must be invalid*\/);\n+  }\n+\n@@ -798,4 +826,0 @@\n-  VPointer make_invalid() const {\n-    return VPointer(_vloop, mem_pointer(), true \/* must be invalid*\/);\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":37,"deletions":13,"binary":false,"changes":50,"status":"modified"}]}