{"files":[{"patch":"@@ -918,1 +918,1 @@\n-  \/\/ Check that all variables are either the iv, or else invariants.\n+  \/\/ Check the conditions for a \"valid\" VPointer.\n@@ -920,4 +920,11 @@\n-    if (!_mem_pointer.base().is_known()) {\n-      \/\/ VPointer needs to know if it is native (off-heap) or object (on-heap).\n-      \/\/ We may for example have failed to fully decompose the MemPointer, possibly\n-      \/\/ because such a decomposition is not considered safe.\n+    return init_is_base_known() &&\n+           init_are_non_iv_summands_pre_loop_invariant() &&\n+           init_are_scale_and_stride_not_too_large();\n+  }\n+\n+  \/\/ VPointer needs to know if it is native (off-heap) or object (on-heap).\n+  \/\/ We may for example have failed to fully decompose the MemPointer, possibly\n+  \/\/ because such a decomposition is not considered safe.\n+  bool init_is_base_known() const {\n+    if (_mem_pointer.base().is_known()) { return true; }\n+\n@@ -925,5 +932,2 @@\n-      if (_vloop.mptrace().is_trace_parsing()) {\n-        tty->print_cr(\"VPointer::init_is_valid: base not known.\");\n-      }\n-#endif\n-      return false;\n+    if (_vloop.mptrace().is_trace_parsing()) {\n+      tty->print_cr(\"VPointer::init_is_valid: base not known.\");\n@@ -931,0 +935,3 @@\n+#endif\n+    return false;\n+  }\n@@ -932,3 +939,4 @@\n-    \/\/ All summands, except the iv-summand must be pre-loop invariant. This is necessary\n-    \/\/ so that we can use the variables in checks inside or before the pre-loop, e.g. for\n-    \/\/ alignment.\n+  \/\/ All summands, except the iv-summand must be pre-loop invariant. This is necessary\n+  \/\/ so that we can use the variables in checks inside or before the pre-loop, e.g. for\n+  \/\/ alignment.\n+  bool init_are_non_iv_summands_pre_loop_invariant() const {\n@@ -949,0 +957,2 @@\n+    return true;\n+  }\n@@ -950,9 +960,10 @@\n-    \/\/ In the pointer analysis, and especially the AlignVector analysis, we assume that\n-    \/\/ stride and scale are not too large. For example, we multiply \"iv_scale * iv_stride\",\n-    \/\/ and assume that this does not overflow the int range. We also take \"abs(iv_scale)\"\n-    \/\/ and \"abs(iv_stride)\", which would overflow for min_int = -(2^31). Still, we want\n-    \/\/ to at least allow small and moderately large stride and scale. Therefore, we\n-    \/\/ allow values up to 2^30, which is only a factor 2 smaller than the max\/min int.\n-    \/\/ Normal performance relevant code will have much lower values. And the restriction\n-    \/\/ allows us to keep the rest of the autovectorization code much simpler, since we\n-    \/\/ do not have to deal with overflows.\n+  \/\/ In the pointer analysis, and especially the AlignVector analysis, we assume that\n+  \/\/ stride and scale are not too large. For example, we multiply \"iv_scale * iv_stride\",\n+  \/\/ and assume that this does not overflow the int range. We also take \"abs(iv_scale)\"\n+  \/\/ and \"abs(iv_stride)\", which would overflow for min_int = -(2^31). Still, we want\n+  \/\/ to at least allow small and moderately large stride and scale. Therefore, we\n+  \/\/ allow values up to 2^30, which is only a factor 2 smaller than the max\/min int.\n+  \/\/ Normal performance relevant code will have much lower values. And the restriction\n+  \/\/ allows us to keep the rest of the autovectorization code much simpler, since we\n+  \/\/ do not have to deal with overflows.\n+  bool init_are_scale_and_stride_not_too_large() const {\n@@ -972,1 +983,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":33,"deletions":23,"binary":false,"changes":56,"status":"modified"}]}