[{"commit":{"message":"Merge master"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp"}],"sha":"ccb23e2d6eac322ec3a2b0d94daa570235458a10"},{"commit":{"message":"8303161: [vectorapi] VectorMask.cast narrow operation returns incorrect value with SVE\n\nThe cast operation for VectorMask from wider type to narrow type returns\nincorrect result for trueCount() method invocation for the resultant\nmask with SVE (on some SVE machines toLong() also results in incorrect\nvalues). An example narrow operation which results in incorrect toLong()\nand trueCount() values is shown below for a 128-bit -> 64-bit conversion\nand this can be extended to other narrow operations where the source\nmask in bytes is either 4x or 8x the size of the result mask in\nbytes -\n\npublic class TestMaskCast {\n\n    static final boolean [] mask_arr = {true, true, false, true};\n\n    public static long narrow_long() {\n        VectorMask<Long> lmask128 = VectorMask.fromArray(LongVector.SPECIES_128, mask_arr, 0);\n        return lmask128.cast(IntVector.SPECIES_64).toLong();\n    }\n\n    public static void main(String[] args) {\n        long r = 0L;\n        for (int ic = 0; ic < 50000; ic++) {\n            r = narrow_long();\n        }\n        System.out.println(\"toLong() :  \" + r);\n    }\n}\n\nC2 compilation result :\njava --add-modules jdk.incubator.vector TestMaskCast\ntoLong():  15\n\nInterpreter result (for verification) :\njava --add-modules jdk.incubator.vector -Xint TestMaskCast\ntoLong():  3\n\nThe incorrect results with toLong() have been observed only on the\n128-bit and 256-bit SVE machines but they are not reproducible on a\n512-bit machine. However, trueCount() returns incorrect values too\nand they are reproducible on all the SVE machines and thus is more\nreliable to use trueCount() to bring out the drawbacks of the current\nimplementation of mask cast narrow operation for SVE.\n\nReplacing the call to toLong() by trueCount() in the above example -\npublic class TestMaskCast {\n\n    static final boolean [] mask_arr = {true, true, false, true};\n\n    public static int narrow_long() {\n        VectorMask<Long> lmask128 = VectorMask.fromArray(LongVector.SPECIES_128, mask_arr, 0);\n        return lmask128.cast(IntVector.SPECIES_64).trueCount();\n    }\n\n    public static void main(String[] args) {\n        int r = 0;\n        for (int ic = 0; ic < 50000; ic++) {\n            r = narrow_long();\n        }\n        System.out.println(\"trueCount() :  \" + r);\n    }\n}\n\nC2 compilation result:\njava --add-modules jdk.incubator.vector TestMaskCast\ntrueCount() :  4\n\nInterpreter result:\njava --add-modules jdk.incubator.vector -Xint TestMaskCast\ntrueCount() :  2\n\nSince in this example, the source mask size in bytes is 2x that of the\nresult mask, trueCount() returns 2x the number of true elements in the\nsource mask. It would return 4x\/8x the number of true elements in the\nsource mask if the size of the source mask is 4x\/8x that of result mask.\n\nThe returned values are incorrect because of the higher order bits in\nthe result not being cleared (since the result is narrowed down) and\ntrueCount() or toLong() tend to consider the higher order bits in the\nvector register as well which results in incorrect value.\nFor the 128-bit to 64-bit conversion with a mask - \"TT\" passed, the\ncurrent implementation for mask cast narrow operation returns the same\nmask in the lower and upper half of the 128-bit register that is -\n\"TTTT\" which results in a long value of 15 (instead of 3 - \"FFTT\" for\nthe 64-bit Integer mask) and number of true elements to be 4 (instead of\n2).\n\nThis patch proposes a fix for this problem. An already existing JTREG IR\ntest - \"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastTest.java\"\nhas also been modified to call the trueCount() method as well since the\ntoString() method alone cannot be used to reproduce the incorrect values\nin this bug. This test passes successfully on 128-bit, 256-bit and\n512-bit SVE machines. Since the IR test has been changed, it has been\ntested successfully on other platforms like x86 and aarch64 Neon\nmachines as well to ensure the changes have not introduced any new\nerrors."},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp"},{"filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastTest.java"}],"sha":"639281ed766170205969f8480c55e5a383817993"}]