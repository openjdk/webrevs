{"files":[{"patch":"@@ -93,1 +93,1 @@\n-    \/\/ a double precise float point is composed of 3 parts: sign\/e(exponent)\/f(signicant)\n+    \/\/ a double precise float point is composed of 3 parts: sign\/e(exponent)\/f(signicand)\n@@ -100,1 +100,1 @@\n-    final long fBound = 1 << fWidth;\n+    final long fBound = 1L << fWidth;\n@@ -107,1 +107,1 @@\n-      fis[fidx] = 1 << fidx;\n+      fis[fidx] = 1L << fidx;\n@@ -112,1 +112,1 @@\n-    fis[rand.nextInt(fidx)] = 0;\n+    fis[rand.nextInt(fNum)] = 0;\n@@ -115,0 +115,2 @@\n+\n+    \/\/ generate input arrays by combining different parts\n@@ -122,2 +124,6 @@\n-      for (int ei = eStart; ei < eBound; ei += eStep) {\n-        int eiIdx = ei\/eStep;\n+      \/\/ Here, we could have iterated the whole range of exponent values, but it would\n+      \/\/ take more time to run the test, so just randomly choose some of exponent values.\n+      int ei = eStart;\n+      int eiIdx = 0;\n+      for (; ei < eBound; ei += eStep) {\n+        eiIdx = ei\/eStep;\n@@ -125,1 +131,1 @@\n-        long bits = (ei << eShift) + fi;\n+        long bits = ((long)ei << eShift) + fi;\n@@ -130,1 +136,1 @@\n-        bits = bits | (1 << 63);\n+        bits = bits | (1L << 63);\n@@ -133,0 +139,9 @@\n+      \/\/ add specific test cases where it looks like in binary format:\n+      \/\/   s111 1111 1111 xxxx xxxx xxxx xxxx xxxx ...\n+      \/\/ these are for the NaN and Inf.\n+      eiIdx = eiIdx*2+2;\n+      long bits = (1L << eWidth) - 1L;\n+      bits <<= eShift;\n+      input[eiIdx++] = Double.longBitsToDouble(bits);\n+      bits = bits | (1L << 63);\n+      input[eiIdx] = Double.longBitsToDouble(bits);\n@@ -138,2 +153,3 @@\n-      for (int ei = eStart; ei < eBound; ei += eStep) {\n-        int eiIdx = ei\/eStep;\n+      ei = eStart;\n+      eiIdx = ei\/eStep;\n+      for (; ei < eBound; ei += eStep) {\n@@ -142,1 +158,1 @@\n-          if (res[idx] != Math.round(input[idx])) {\n+          if (res[idx] != golden_round(input[idx])) {\n@@ -145,1 +161,1 @@\n-                               \", res: \" + res[idx] + \"expected: \" + Math.round(input[idx]) +\n+                               \", res: \" + res[idx] + \"expected: \" + golden_round(input[idx]) +\n@@ -152,0 +168,21 @@\n+\n+    \/\/ generate pure random input arrays, which does not depend on significand\/exponent values\n+    for(int i = 0; i < 128; i++) {\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = rand.nextDouble();\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Double.doubleToLongBits(input[j]));\n+        }\n+      }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorDoubleRandom.java","additions":49,"deletions":12,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    \/\/ a single precise float point is composed of 3 parts: sign\/e(exponent)\/f(signicant)\n+    \/\/ a single precise float point is composed of 3 parts: sign\/e(exponent)\/f(signicand)\n@@ -115,1 +115,1 @@\n-    fis[rand.nextInt(fidx)] = 0;\n+    fis[rand.nextInt(fNum)] = 0;\n@@ -118,0 +118,2 @@\n+\n+    \/\/ generate input arrays by combining different parts\n@@ -141,1 +143,1 @@\n-          if (res[idx] != Math.round(input[idx])) {\n+          if (res[idx] != golden_round(input[idx])) {\n@@ -144,1 +146,1 @@\n-                               \", res: \" + res[idx] + \"expected: \" + Math.round(input[idx]) +\n+                               \", res: \" + res[idx] + \"expected: \" + golden_round(input[idx]) +\n@@ -151,0 +153,22 @@\n+\n+    \/\/ generate pure random input arrays, which does not depend on significand\/exponent values\n+    for(int i = 0; i < 128; i++) {\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = rand.nextFloat();\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Float.floatToIntBits(input[j]));\n+        }\n+      }\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatRandom.java","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"}]}