{"files":[{"patch":"@@ -31,1 +31,3 @@\n- * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:+PrintIdeal -XX:CompileCommand=compileonly,compiler.floatingpoint.TestRoundFloatAll::test* -XX:-UseSuperWord compiler.floatingpoint.TestRoundFloatAll\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch -XX:CompileThresholdScaling=0.3 -XX:-UseSuperWord\n+ *      -XX:CompileCommand=compileonly,compiler.floatingpoint.TestRoundFloatAll::test*\n+ *      compiler.floatingpoint.TestRoundFloatAll\n@@ -34,1 +36,1 @@\n- package compiler.floatingpoint;\n+package compiler.floatingpoint;\n@@ -36,2 +38,1 @@\n-import jdk.internal.math.FloatConsts;\n-import compiler.lib.ir_framework.TestFramework;\n+import static compiler.lib.golden.GoldenRound.golden_round;\n@@ -45,32 +46,0 @@\n-  static int golden_round(float a) {\n-    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n-    \/\/  public static int round(float a) { ... }\n-\n-    int intBits = Float.floatToRawIntBits(a);\n-    int biasedExp = (intBits & FloatConsts.EXP_BIT_MASK)\n-            >> (FloatConsts.SIGNIFICAND_WIDTH - 1);\n-    int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2\n-            + FloatConsts.EXP_BIAS) - biasedExp;\n-    if ((shift & -32) == 0) { \/\/ shift >= 0 && shift < 32\n-        \/\/ a is a finite number such that pow(2,-32) <= ulp(a) < 1\n-        int r = ((intBits & FloatConsts.SIGNIF_BIT_MASK)\n-                | (FloatConsts.SIGNIF_BIT_MASK + 1));\n-        if (intBits < 0) {\n-            r = -r;\n-        }\n-        \/\/ In the comments below each Java expression evaluates to the value\n-        \/\/ the corresponding mathematical expression:\n-        \/\/ (r) evaluates to a \/ ulp(a)\n-        \/\/ (r >> shift) evaluates to floor(a * 2)\n-        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n-        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n-        return ((r >> shift) + 1) >> 1;\n-    } else {\n-        \/\/ a is either\n-        \/\/ - a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1\/2\n-        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n-        \/\/ - an infinity or NaN\n-        return (int) a;\n-    }\n-  }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestRoundFloatAll.java","additions":5,"deletions":36,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.golden;\n+\n+import jdk.internal.math.DoubleConsts;\n+import jdk.internal.math.FloatConsts;\n+\n+public class GoldenRound {\n+  public static int golden_round(float a) {\n+    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n+    \/\/  public static int round(float a) { ... }\n+\n+    int intBits = Float.floatToRawIntBits(a);\n+    int biasedExp = (intBits & FloatConsts.EXP_BIT_MASK)\n+            >> (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+    int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2\n+            + FloatConsts.EXP_BIAS) - biasedExp;\n+    if ((shift & -32) == 0) { \/\/ shift >= 0 && shift < 32\n+        \/\/ a is a finite number such that pow(2,-32) <= ulp(a) < 1\n+        int r = ((intBits & FloatConsts.SIGNIF_BIT_MASK)\n+                | (FloatConsts.SIGNIF_BIT_MASK + 1));\n+        if (intBits < 0) {\n+            r = -r;\n+        }\n+        \/\/ In the comments below each Java expression evaluates to the value\n+        \/\/ the corresponding mathematical expression:\n+        \/\/ (r) evaluates to a \/ ulp(a)\n+        \/\/ (r >> shift) evaluates to floor(a * 2)\n+        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n+        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n+        return ((r >> shift) + 1) >> 1;\n+    } else {\n+        \/\/ a is either\n+        \/\/ - a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1\/2\n+        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n+        \/\/ - an infinity or NaN\n+        return (int) a;\n+    }\n+  }\n+\n+\n+  public static long golden_round(double a) {\n+    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n+    \/\/  public static int round(double a) { ... }\n+\n+    long longBits = Double.doubleToRawLongBits(a);\n+    long biasedExp = (longBits & DoubleConsts.EXP_BIT_MASK)\n+            >> (DoubleConsts.SIGNIFICAND_WIDTH - 1);\n+    long shift = (DoubleConsts.SIGNIFICAND_WIDTH - 2\n+            + DoubleConsts.EXP_BIAS) - biasedExp;\n+    if ((shift & -64) == 0) { \/\/ shift >= 0 && shift < 64\n+        \/\/ a is a finite number such that pow(2,-64) <= ulp(a) < 1\n+        long r = ((longBits & DoubleConsts.SIGNIF_BIT_MASK)\n+                | (DoubleConsts.SIGNIF_BIT_MASK + 1));\n+        if (longBits < 0) {\n+            r = -r;\n+        }\n+        \/\/ In the comments below each Java expression evaluates to the value\n+        \/\/ the corresponding mathematical expression:\n+        \/\/ (r) evaluates to a \/ ulp(a)\n+        \/\/ (r >> shift) evaluates to floor(a * 2)\n+        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n+        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n+        return ((r >> shift) + 1) >> 1;\n+    } else {\n+        \/\/ a is either\n+        \/\/ - a finite number with abs(a) < exp(2,DoubleConsts.SIGNIFICAND_WIDTH-64) < 1\/2\n+        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n+        \/\/ - an infinity or NaN\n+        return (long) a;\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/golden\/GoldenRound.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.internal.math.DoubleConsts;\n+import static compiler.lib.golden.GoldenRound.golden_round;\n@@ -48,0 +48,2 @@\n+  private static final Random rand = new Random();\n+\n@@ -49,1 +51,1 @@\n-  private static final int ARRLEN = 997;\n+  private static final int ARRLEN = rand.nextInt(4096-997) + 997;\n@@ -54,1 +56,0 @@\n-  private static final Random rand = new Random();\n@@ -63,32 +64,0 @@\n-  static long golden_round(double a) {\n-    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n-    \/\/  public static int round(double a) { ... }\n-\n-    long longBits = Double.doubleToRawLongBits(a);\n-    long biasedExp = (longBits & DoubleConsts.EXP_BIT_MASK)\n-            >> (DoubleConsts.SIGNIFICAND_WIDTH - 1);\n-    long shift = (DoubleConsts.SIGNIFICAND_WIDTH - 2\n-            + DoubleConsts.EXP_BIAS) - biasedExp;\n-    if ((shift & -64) == 0) { \/\/ shift >= 0 && shift < 64\n-        \/\/ a is a finite number such that pow(2,-64) <= ulp(a) < 1\n-        long r = ((longBits & DoubleConsts.SIGNIF_BIT_MASK)\n-                | (DoubleConsts.SIGNIF_BIT_MASK + 1));\n-        if (longBits < 0) {\n-            r = -r;\n-        }\n-        \/\/ In the comments below each Java expression evaluates to the value\n-        \/\/ the corresponding mathematical expression:\n-        \/\/ (r) evaluates to a \/ ulp(a)\n-        \/\/ (r >> shift) evaluates to floor(a * 2)\n-        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n-        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n-        return ((r >> shift) + 1) >> 1;\n-    } else {\n-        \/\/ a is either\n-        \/\/ - a finite number with abs(a) < exp(2,DoubleConsts.SIGNIFICAND_WIDTH-64) < 1\/2\n-        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n-        \/\/ - an infinity or NaN\n-        return (long) a;\n-    }\n-  }\n-\n@@ -224,0 +193,2 @@\n+        +0.0,\n+        -0.0,\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorDoubleRandom.java","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -31,4 +31,4 @@\n- * @run main\/othervm -XX:+PrintIdeal -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n- * @run main\/othervm -XX:+PrintIdeal -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=8 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n- * @run main\/othervm -XX:+PrintIdeal -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=16 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n- * @run main\/othervm -XX:+PrintIdeal -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=32 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=8 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=16 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=32 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n@@ -39,1 +39,2 @@\n-import jdk.internal.math.FloatConsts;\n+import java.util.Random;\n+import static compiler.lib.golden.GoldenRound.golden_round;\n@@ -42,0 +43,2 @@\n+  private static final Random rand = new Random();\n+\n@@ -43,1 +46,1 @@\n-  private static final int ARRLEN = 997;\n+  private static final int ARRLEN = rand.nextInt(4096-997) + 997;\n@@ -50,32 +53,0 @@\n-  static int golden_round(float a) {\n-    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n-    \/\/  public static int round(float a) { ... }\n-\n-    int intBits = Float.floatToRawIntBits(a);\n-    int biasedExp = (intBits & FloatConsts.EXP_BIT_MASK)\n-            >> (FloatConsts.SIGNIFICAND_WIDTH - 1);\n-    int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2\n-            + FloatConsts.EXP_BIAS) - biasedExp;\n-    if ((shift & -32) == 0) { \/\/ shift >= 0 && shift < 32\n-        \/\/ a is a finite number such that pow(2,-32) <= ulp(a) < 1\n-        int r = ((intBits & FloatConsts.SIGNIF_BIT_MASK)\n-                | (FloatConsts.SIGNIF_BIT_MASK + 1));\n-        if (intBits < 0) {\n-            r = -r;\n-        }\n-        \/\/ In the comments below each Java expression evaluates to the value\n-        \/\/ the corresponding mathematical expression:\n-        \/\/ (r) evaluates to a \/ ulp(a)\n-        \/\/ (r >> shift) evaluates to floor(a * 2)\n-        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n-        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n-        return ((r >> shift) + 1) >> 1;\n-    } else {\n-        \/\/ a is either\n-        \/\/ - a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1\/2\n-        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n-        \/\/ - an infinity or NaN\n-        return (int) a;\n-    }\n-  }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatAll.java","additions":9,"deletions":38,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.internal.math.FloatConsts;\n+import static compiler.lib.golden.GoldenRound.golden_round;\n@@ -48,0 +48,2 @@\n+  private static final Random rand = new Random();\n+\n@@ -49,1 +51,1 @@\n-  private static final int ARRLEN = 997;\n+  private static final int ARRLEN = rand.nextInt(4096-997) + 997;\n@@ -54,1 +56,0 @@\n-  private static final Random rand = new Random();\n@@ -63,32 +64,0 @@\n-  static int golden_round(float a) {\n-    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n-    \/\/  public static int round(float a) { ... }\n-\n-    int intBits = Float.floatToRawIntBits(a);\n-    int biasedExp = (intBits & FloatConsts.EXP_BIT_MASK)\n-            >> (FloatConsts.SIGNIFICAND_WIDTH - 1);\n-    int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2\n-            + FloatConsts.EXP_BIAS) - biasedExp;\n-    if ((shift & -32) == 0) { \/\/ shift >= 0 && shift < 32\n-        \/\/ a is a finite number such that pow(2,-32) <= ulp(a) < 1\n-        int r = ((intBits & FloatConsts.SIGNIF_BIT_MASK)\n-                | (FloatConsts.SIGNIF_BIT_MASK + 1));\n-        if (intBits < 0) {\n-            r = -r;\n-        }\n-        \/\/ In the comments below each Java expression evaluates to the value\n-        \/\/ the corresponding mathematical expression:\n-        \/\/ (r) evaluates to a \/ ulp(a)\n-        \/\/ (r >> shift) evaluates to floor(a * 2)\n-        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n-        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n-        return ((r >> shift) + 1) >> 1;\n-    } else {\n-        \/\/ a is either\n-        \/\/ - a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1\/2\n-        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n-        \/\/ - an infinity or NaN\n-        return (int) a;\n-    }\n-  }\n-\n@@ -205,0 +174,2 @@\n+        +0.0f,\n+        -0.0f,\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatRandom.java","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"}]}