{"files":[{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8321011\n+ * @summary Test vector intrinsic for Math.round(double) in full 64 bits range.\n+ *          This is an extension of test cases in TestDoubleVect\n+ *\n+ * @run main\/manual\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic compiler.c2.cr6340864.TestDoubleVectManual\n+ * @run main\/manual\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=8 compiler.c2.cr6340864.TestDoubleVectManual\n+ * @run main\/manual\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=16 compiler.c2.cr6340864.TestDoubleVectManual\n+ * @run main\/manual\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=32 compiler.c2.cr6340864.TestDoubleVectManual\n+ *\/\n+\n+package compiler.c2.cr6340864;\n+\n+public class TestDoubleVectManual {\n+  private static final int ARRLEN = 997;\n+  private static final int ITERS  = 11000;\n+  private static final double ADD_INIT = -7500.;\n+\n+  public static void main(String args[]) {\n+    System.out.println(\"Testing Double vectors\");\n+    int errn = test();\n+    if (errn > 0) {\n+      System.err.println(\"FAILED: \" + errn + \" errors\");\n+      System.exit(97);\n+    }\n+    System.out.println(\"PASSED\");\n+  }\n+\n+  static int test() {\n+    double[] input = new double[ARRLEN];\n+    long  [] res = new long[ARRLEN];\n+\n+    double[] a1 = new double[ARRLEN];\n+    \/\/ Initialize\n+    for (int i=0; i<ARRLEN; i++) {\n+      double val = ADD_INIT+(double)i;\n+      a1[i] = val;\n+    }\n+\n+    \/\/ Warmup\n+    System.out.println(\"Warmup\");\n+    for (int i=0; i<ITERS; i++) {\n+      test_round(res, a1);\n+    }\n+\n+    \/\/ Test and verify results\n+    System.out.println(\"Verification\");\n+    int errn = 0;\n+\n+    final int e_start = 0;\n+    final int e_shift = 52;\n+    final int e_width = 11;\n+    final int e_max = (1 << e_width) - 1;\n+    final long f_start = 0;\n+    final long f_max = (1 << e_shift) - 1;\n+    final int group = 448;\n+\n+    for (long fi = f_start; fi <= f_max; fi++) {\n+      for (int eg = e_start; eg <= e_max; eg+=group) {\n+        for (int ei = 0; ei < group; ei++) {\n+          int e = eg + ei;\n+          long bits = (e << e_shift) + fi;\n+          input[ei*2] = Double.longBitsToDouble(bits);\n+          bits = bits | (1 << 31);\n+          input[ei*2+1] = Double.longBitsToDouble(bits);\n+        }\n+\n+        \/\/ run tests\n+        test_round(res, input);\n+\n+        \/\/ verify results\n+        for (int ei = 0; ei <= group; ei++) {\n+          int e = eg + ei;\n+          for (int sign = 0; sign < 2; sign++) {\n+            int idx = ei*2+sign;\n+            if (res[idx] != Math.round(input[idx])) {\n+              errn++;\n+              System.err.println(\"round error, input: \" + input[idx] +\n+                                \", res: \" + res[idx] + \"expected: \" + Math.round(input[idx]) +\n+                                \", input hex: \" + Double.doubleToLongBits(input[idx]) +\n+                                \", fi: \" + fi + \", ei: \" + ei + \", e: \" + e + \", sign: \" + sign);\n+            }\n+            if (errn > 100) {\n+              return errn;\n+            }\n+          }\n+        }\n+      }\n+    }\n+    return errn;\n+  }\n+\n+  static void test_round(long[] a0, double[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestDoubleVectManual.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8321010\n+ * @summary Test vector intrinsic for Math.round(float) in full 32 bits range\n+ *          This is an extension of test cases in TestFloatVect\n+ *\n+ * @run main\/manual\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic compiler.c2.cr6340864.TestFloatVectManual\n+ * @run main\/manual\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=8 compiler.c2.cr6340864.TestFloatVectManual\n+ * @run main\/manual\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=16 compiler.c2.cr6340864.TestFloatVectManual\n+ * @run main\/manual\/othervm -Xbatch -XX:CompileCommand=exclude,*::test() -Xmx128m -XX:+UnlockDiagnosticVMOptions -XX:+UseSignumIntrinsic -XX:MaxVectorSize=32 compiler.c2.cr6340864.TestFloatVectManual\n+ *\/\n+\n+package compiler.c2.cr6340864;\n+\n+public class TestFloatVectManual {\n+  private static final int ARRLEN = 997;\n+  private static final int ITERS  = 11000;\n+  private static final float ADD_INIT = -7500.f;\n+\n+  public static void main(String args[]) {\n+    System.out.println(\"Testing Float vectors\");\n+    int errn = test();\n+    if (errn > 0) {\n+      System.err.println(\"FAILED: \" + errn + \" errors\");\n+      System.exit(97);\n+    }\n+    System.out.println(\"PASSED\");\n+  }\n+\n+  static int test() {\n+    int[] res = new int[ARRLEN];\n+    float[] input = new float[ARRLEN];\n+\n+    \/\/ Initialize\n+    for (int i=0; i<ARRLEN; i++) {\n+      float val = ADD_INIT+(float)i;\n+      input[i] = val;\n+    }\n+\n+    \/\/ Warmup\n+    System.out.println(\"Warmup\");\n+    for (int i=0; i<ITERS; i++) {\n+      test_round(res, input);\n+    }\n+\n+    \/\/ Test and verify results\n+    System.out.println(\"Verification\");\n+    int errn = 0;\n+\n+    final int e_start = 0;\n+    final int e_shift = 23;\n+    final int e_width = 8;\n+    final int e_max = (1 << e_width) - 1;\n+    final int f_start = 0;\n+    final int f_max = (1 << e_shift) - 1;\n+\n+    for (int fi = f_start; fi <= f_max; fi++) {\n+      for (int ei = e_start; ei <= e_max; ei++) {\n+        int bits = (ei << e_shift) + fi;\n+        input[ei*2] = Float.intBitsToFloat(bits);\n+        bits = bits | (1 << 31);\n+        input[ei*2+1] = Float.intBitsToFloat(bits);\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int ei = e_start; ei <= e_max; ei++) {\n+        for (int sign = 0; sign < 2; sign++) {\n+          int idx = ei*2+sign;\n+          if (res[idx] != Math.round(input[idx])) {\n+            errn++;\n+            System.err.println(\"round error, input: \" + input[idx] +\n+                               \", res: \" + res[idx] + \"expected: \" + Math.round(input[idx]) +\n+                               \", input hex: \" + Float.floatToIntBits(input[idx]) +\n+                               \", fi: \" + fi + \", ei: \" + ei + \", sign: \" + sign);\n+          }\n+          if (errn > 100) {\n+            return errn;\n+          }\n+        }\n+      }\n+    }\n+    return errn;\n+  }\n+\n+  static void test_round(int[] a0, float[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestFloatVectManual.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"}]}