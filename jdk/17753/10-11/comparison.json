{"files":[{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8321010\n+ * @summary Test intrinsic for Math.round(float) in full 32 bits range\n+ *\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.math\n+ * @run main compiler.vectorization.TestRoundVectorFloatRandom -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3\n+ *\/\n+\n+ package compiler.floatingpoint;\n+\n+import jdk.internal.math.FloatConsts;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+public class TestRoundFloatAll {\n+\n+  public static void main(String args[]) {\n+    test();\n+  }\n+\n+  static int golden_round(float a) {\n+    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n+    \/\/  public static int round(float a) { ... }\n+\n+    int intBits = Float.floatToRawIntBits(a);\n+    int biasedExp = (intBits & FloatConsts.EXP_BIT_MASK)\n+            >> (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+    int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2\n+            + FloatConsts.EXP_BIAS) - biasedExp;\n+    if ((shift & -32) == 0) { \/\/ shift >= 0 && shift < 32\n+        \/\/ a is a finite number such that pow(2,-32) <= ulp(a) < 1\n+        int r = ((intBits & FloatConsts.SIGNIF_BIT_MASK)\n+                | (FloatConsts.SIGNIF_BIT_MASK + 1));\n+        if (intBits < 0) {\n+            r = -r;\n+        }\n+        \/\/ In the comments below each Java expression evaluates to the value\n+        \/\/ the corresponding mathematical expression:\n+        \/\/ (r) evaluates to a \/ ulp(a)\n+        \/\/ (r >> shift) evaluates to floor(a * 2)\n+        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n+        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n+        return ((r >> shift) + 1) >> 1;\n+    } else {\n+        \/\/ a is either\n+        \/\/ - a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1\/2\n+        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n+        \/\/ - an infinity or NaN\n+        return (int) a;\n+    }\n+  }\n+\n+  \/\/ return true when test fails\n+  static boolean test(int n, float f) {\n+    int actual = Math.round(f);\n+    int expected = golden_round(f);\n+    if (actual != expected) {\n+      System.err.println(\"round error, input: \" + f + \", res: \" + actual + \"expected: \" + expected + \", input hex: \" + n);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static int test() {\n+    final int ITERS = 11000;\n+    boolean fail = false;\n+\n+    \/\/ Warmup\n+    System.out.println(\"Warmup\");\n+    for (int i=0; i<ITERS; i++) {\n+      float f = Float.intBitsToFloat(i);\n+      fail |= test(i, f);\n+    }\n+    if (fail) {\n+      throw new RuntimeException(\"Warmup failed\");\n+    }\n+\n+    \/\/ Test and verify results\n+    System.out.println(\"Verification\");\n+    int testInt = 0;\n+    do {\n+      float testFloat = Float.intBitsToFloat(testInt);\n+      fail |= test(testInt, testFloat);\n+    } while (++testInt != 0);\n+    if (fail) {\n+      throw new RuntimeException(\"Test failed\");\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestRoundFloatAll.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @summary Test vector intrinsic for Math.round(double) in full 64 bits range.\n+ * @summary Test vector intrinsic for Math.round(double) with random input in 64 bits range, verify IR at the same time.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorDoubleRandom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8321010\n+ * @summary Test vector intrinsic for Math.round(float) in full 32 bits range\n+ *\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.math\n+ * @run main compiler.vectorization.TestRoundVectorFloatRandom -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3\n+ * @run main compiler.vectorization.TestRoundVectorFloatRandom -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=8\n+ * @run main compiler.vectorization.TestRoundVectorFloatRandom -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=16\n+ * @run main compiler.vectorization.TestRoundVectorFloatRandom -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=32\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import jdk.internal.math.FloatConsts;\n+\n+public class TestRoundVectorFloatAll {\n+  private static final int ITERS  = 11000;\n+  private static final int ARRLEN = 997;\n+  private static final float ADD_INIT = -7500.f;\n+\n+  public static void main(String args[]) {\n+    test();\n+  }\n+\n+  static int golden_round(float a) {\n+    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n+    \/\/  public static int round(float a) { ... }\n+\n+    int intBits = Float.floatToRawIntBits(a);\n+    int biasedExp = (intBits & FloatConsts.EXP_BIT_MASK)\n+            >> (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+    int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2\n+            + FloatConsts.EXP_BIAS) - biasedExp;\n+    if ((shift & -32) == 0) { \/\/ shift >= 0 && shift < 32\n+        \/\/ a is a finite number such that pow(2,-32) <= ulp(a) < 1\n+        int r = ((intBits & FloatConsts.SIGNIF_BIT_MASK)\n+                | (FloatConsts.SIGNIF_BIT_MASK + 1));\n+        if (intBits < 0) {\n+            r = -r;\n+        }\n+        \/\/ In the comments below each Java expression evaluates to the value\n+        \/\/ the corresponding mathematical expression:\n+        \/\/ (r) evaluates to a \/ ulp(a)\n+        \/\/ (r >> shift) evaluates to floor(a * 2)\n+        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n+        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n+        return ((r >> shift) + 1) >> 1;\n+    } else {\n+        \/\/ a is either\n+        \/\/ - a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1\/2\n+        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n+        \/\/ - an infinity or NaN\n+        return (int) a;\n+    }\n+  }\n+\n+  static int test() {\n+    float[] input = new float[ARRLEN];\n+    int [] res = new int[ARRLEN];\n+\n+    for (int i=0; i<ARRLEN; i++) {\n+      float val = ADD_INIT+(float)i;\n+      input[i] = val;\n+    }\n+    \/\/ Warmup\n+    System.out.println(\"Warmup\");\n+    for (int i=0; i<ITERS; i++) {\n+      test_round(res, input);\n+    }\n+\n+    \/\/ Test and verify results\n+    System.out.println(\"Verification\");\n+    int errn = 0;\n+    for (long l = Integer.MIN_VALUE; l <= Integer.MAX_VALUE; l+=ARRLEN) {\n+      for (int i = 0; i < ARRLEN; i++) {\n+        input[i] = (int)(l+i);\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Float.floatToIntBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    if (errn > 0) {\n+      throw new RuntimeException(\"There are some round error detected!\");\n+    }\n+  }\n+\n+  static void test_round(int[] a0, float[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatAll.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @summary Test vector intrinsic for Math.round(float) in full 32 bits range\n+ * @summary Test vector intrinsic for Math.round(float) with random input in 32 bits range, verify IR at the same time.\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatRandom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}