{"files":[{"patch":"@@ -31,2 +31,0 @@\n- * @requires (vm.cpu.features ~= \".*avx512dq.*\" & os.simpleArch == \"x64\") |\n- *           os.simpleArch == \"aarch64\"\n@@ -35,1 +33,1 @@\n- * @run driver compiler.vectorization.TestRoundVectorDoubleRandom\n+ * @run main compiler.vectorization.TestRoundVectorDoubleRandom\n@@ -41,1 +39,0 @@\n-import java.util.concurrent.ThreadLocalRandom;\n@@ -73,1 +70,5 @@\n-  @IR(counts = {IRNode.ROUND_VD, \"> 0\"})\n+  @IR(counts = {IRNode.ROUND_VD, \"> 0\"},\n+      applyIfPlatform = {\"x64\", \"true\"},\n+      applyIfCPUFeature = {\"avx512dq\", \"true\"})\n+  @IR(counts = {IRNode.ROUND_VD, \"> 0\"},\n+      applyIfPlatform = {\"aarch64\", \"true\"})\n@@ -96,6 +97,6 @@\n-    final int e_shift = 52;\n-    final int e_width = 11;\n-    final int e_bound = 1 << e_width;\n-    final int f_width = e_shift;\n-    final long f_bound = 1 << f_width;\n-    final int f_num = 256;\n+    final int eShift = 52;\n+    final int eWidth = 11;\n+    final int eBound = 1 << eWidth;\n+    final int fWidth = eShift;\n+    final long fBound = 1 << fWidth;\n+    final int fNum = 256;\n@@ -104,1 +105,1 @@\n-    long fis[] = new long[f_num];\n+    long fis[] = new long[fNum];\n@@ -106,1 +107,1 @@\n-    for (; fidx < f_width; fidx++) {\n+    for (; fidx < fWidth; fidx++) {\n@@ -110,2 +111,2 @@\n-    for (; fidx < f_num; fidx++) {\n-      fis[fidx] = ThreadLocalRandom.current().nextLong(f_bound);\n+    for (; fidx < fNum; fidx++) {\n+      fis[fidx] = rand.nextLong(fBound);\n@@ -116,6 +117,6 @@\n-      final int e_start = rand.nextInt(9);\n-      final int e_step = (1 << 3) + rand.nextInt(3);\n-      for (int ei = e_start; ei < e_bound; ei += e_step) {\n-        int ei_idx = ei\/e_step;\n-        long bits = (ei << e_shift) + fi;\n-        input[ei_idx*2] = Double.longBitsToDouble(bits);\n+      final int eStart = rand.nextInt(9);\n+      final int eStep = (1 << 3) + rand.nextInt(3);\n+      for (int ei = eStart; ei < eBound; ei += eStep) {\n+        int eiIdx = ei\/eStep;\n+        long bits = (ei << eShift) + fi;\n+        input[eiIdx*2] = Double.longBitsToDouble(bits);\n@@ -123,1 +124,1 @@\n-        input[ei_idx*2+1] = Double.longBitsToDouble(bits);\n+        input[eiIdx*2+1] = Double.longBitsToDouble(bits);\n@@ -130,2 +131,2 @@\n-      for (int ei = e_start; ei < e_bound; ei += e_step) {\n-        int ei_idx = ei\/e_step;\n+      for (int ei = eStart; ei < eBound; ei += eStep) {\n+        int eiIdx = ei\/eStep;\n@@ -133,1 +134,1 @@\n-          int idx = ei_idx * 2 + sign;\n+          int idx = eiIdx * 2 + sign;\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorDoubleRandom.java","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n- * @requires (vm.cpu.features ~= \".*avx.*\" & os.simpleArch == \"x64\") |\n- *           os.simpleArch == \"aarch64\"\n@@ -35,1 +33,1 @@\n- * @run driver compiler.vectorization.TestRoundVectorFloatRandom\n+ * @run main compiler.vectorization.TestRoundVectorFloatRandom\n@@ -72,1 +70,5 @@\n-  @IR(counts = {IRNode.ROUND_VF, \"> 0\"})\n+  @IR(counts = {IRNode.ROUND_VF, \"> 0\"},\n+      applyIfPlatform = {\"x64\", \"true\"},\n+      applyIfCPUFeature = {\"avx\", \"true\"})\n+  @IR(counts = {IRNode.ROUND_VF, \"> 0\"},\n+      applyIfPlatform = {\"aarch64\", \"true\"})\n@@ -95,7 +97,7 @@\n-    final int e_start = 0;\n-    final int e_shift = 23;\n-    final int e_width = 8;\n-    final int e_bound = 1 << e_width;\n-    final int f_width = e_shift;\n-    final int f_bound = 1 << f_width;\n-    final int f_num = 128;\n+    final int eStart = 0;\n+    final int eShift = 23;\n+    final int eWidth = 8;\n+    final int eBound = 1 << eWidth;\n+    final int fWidth = eShift;\n+    final int fBound = 1 << fWidth;\n+    final int fNum = 128;\n@@ -104,1 +106,1 @@\n-    int fis[] = new int[f_num];\n+    int fis[] = new int[fNum];\n@@ -106,1 +108,1 @@\n-    for (; fidx < f_width; fidx++) {\n+    for (; fidx < fWidth; fidx++) {\n@@ -110,2 +112,2 @@\n-    for (; fidx < f_num; fidx++) {\n-      fis[fidx] = rand.nextInt(f_bound);\n+    for (; fidx < fNum; fidx++) {\n+      fis[fidx] = rand.nextInt(fBound);\n@@ -116,2 +118,2 @@\n-      for (int ei = e_start; ei < e_bound; ei++) {\n-        int bits = (ei << e_shift) + fi;\n+      for (int ei = eStart; ei < eBound; ei++) {\n+        int bits = (ei << eShift) + fi;\n@@ -127,1 +129,1 @@\n-      for (int ei = e_start; ei < e_bound; ei++) {\n+      for (int ei = eStart; ei < eBound; ei++) {\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatRandom.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"}]}