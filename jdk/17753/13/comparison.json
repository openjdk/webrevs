{"files":[{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8321010\n+ * @summary Test intrinsic for Math.round(float) in full 32 bits range\n+ *\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.math\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch -XX:CompileThresholdScaling=0.3 -XX:-UseSuperWord\n+ *      -XX:CompileCommand=compileonly,compiler.floatingpoint.TestRoundFloatAll::test*\n+ *      compiler.floatingpoint.TestRoundFloatAll\n+ *\/\n+\n+package compiler.floatingpoint;\n+\n+import static compiler.lib.golden.GoldenRound.golden_round;\n+\n+public class TestRoundFloatAll {\n+\n+  public static void main(String args[]) {\n+    test();\n+  }\n+\n+  \/\/ return true when test fails\n+  static boolean test(int n, float f) {\n+    int actual = Math.round(f);\n+    int expected = golden_round(f);\n+    if (actual != expected) {\n+      System.err.println(\"round error, input: \" + f + \", res: \" + actual + \"expected: \" + expected + \", input hex: \" + n);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static void test() {\n+    final int ITERS = 11000;\n+    boolean fail = false;\n+\n+    \/\/ Warmup\n+    System.out.println(\"Warmup\");\n+    for (int i=0; i<ITERS; i++) {\n+      float f = Float.intBitsToFloat(i);\n+      fail |= test(i, f);\n+    }\n+    if (fail) {\n+      throw new RuntimeException(\"Warmup failed\");\n+    }\n+\n+    \/\/ Test and verify results\n+    System.out.println(\"Verification\");\n+    int testInt = 0;\n+    do {\n+      float testFloat = Float.intBitsToFloat(testInt);\n+      fail |= test(testInt, testFloat);\n+    } while (++testInt != 0);\n+    if (fail) {\n+      throw new RuntimeException(\"Test failed\");\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/floatingpoint\/TestRoundFloatAll.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.golden;\n+\n+import jdk.internal.math.DoubleConsts;\n+import jdk.internal.math.FloatConsts;\n+\n+public class GoldenRound {\n+  public static int golden_round(float a) {\n+    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n+    \/\/  public static int round(float a) { ... }\n+\n+    int intBits = Float.floatToRawIntBits(a);\n+    int biasedExp = (intBits & FloatConsts.EXP_BIT_MASK)\n+            >> (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+    int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2\n+            + FloatConsts.EXP_BIAS) - biasedExp;\n+    if ((shift & -32) == 0) { \/\/ shift >= 0 && shift < 32\n+        \/\/ a is a finite number such that pow(2,-32) <= ulp(a) < 1\n+        int r = ((intBits & FloatConsts.SIGNIF_BIT_MASK)\n+                | (FloatConsts.SIGNIF_BIT_MASK + 1));\n+        if (intBits < 0) {\n+            r = -r;\n+        }\n+        \/\/ In the comments below each Java expression evaluates to the value\n+        \/\/ the corresponding mathematical expression:\n+        \/\/ (r) evaluates to a \/ ulp(a)\n+        \/\/ (r >> shift) evaluates to floor(a * 2)\n+        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n+        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n+        return ((r >> shift) + 1) >> 1;\n+    } else {\n+        \/\/ a is either\n+        \/\/ - a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1\/2\n+        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n+        \/\/ - an infinity or NaN\n+        return (int) a;\n+    }\n+  }\n+\n+\n+  public static long golden_round(double a) {\n+    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n+    \/\/  public static int round(double a) { ... }\n+\n+    long longBits = Double.doubleToRawLongBits(a);\n+    long biasedExp = (longBits & DoubleConsts.EXP_BIT_MASK)\n+            >> (DoubleConsts.SIGNIFICAND_WIDTH - 1);\n+    long shift = (DoubleConsts.SIGNIFICAND_WIDTH - 2\n+            + DoubleConsts.EXP_BIAS) - biasedExp;\n+    if ((shift & -64) == 0) { \/\/ shift >= 0 && shift < 64\n+        \/\/ a is a finite number such that pow(2,-64) <= ulp(a) < 1\n+        long r = ((longBits & DoubleConsts.SIGNIF_BIT_MASK)\n+                | (DoubleConsts.SIGNIF_BIT_MASK + 1));\n+        if (longBits < 0) {\n+            r = -r;\n+        }\n+        \/\/ In the comments below each Java expression evaluates to the value\n+        \/\/ the corresponding mathematical expression:\n+        \/\/ (r) evaluates to a \/ ulp(a)\n+        \/\/ (r >> shift) evaluates to floor(a * 2)\n+        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n+        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n+        return ((r >> shift) + 1) >> 1;\n+    } else {\n+        \/\/ a is either\n+        \/\/ - a finite number with abs(a) < exp(2,DoubleConsts.SIGNIFICAND_WIDTH-64) < 1\/2\n+        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n+        \/\/ - an infinity or NaN\n+        return (long) a;\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/golden\/GoldenRound.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @bug 8321011\n+ * @summary Test vector intrinsic for Math.round(double) with random input in 64 bits range, verify IR at the same time.\n+ *\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.math\n+ * @run main compiler.vectorization.TestRoundVectorDoubleRandom\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.Random;\n+import static compiler.lib.golden.GoldenRound.golden_round;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.RunInfo;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.Warmup;\n+\n+public class TestRoundVectorDoubleRandom {\n+  private static final Random rand = new Random();\n+\n+  private static final int ITERS  = 11000;\n+  private static final int ARRLEN = rand.nextInt(4096-997) + 997;\n+  private static final double ADD_INIT = -7500.;\n+\n+  private static final double[] input = new double[ARRLEN];\n+  private static final long [] res = new long[ARRLEN];\n+\n+  public static void main(String args[]) {\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=8\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=16\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=32\");\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.ROUND_VD, \"> 0\"},\n+      applyIfPlatform = {\"x64\", \"true\"},\n+      applyIfCPUFeature = {\"avx512dq\", \"true\"},\n+      applyIf = {\"MaxVectorSize\", \">= 16\"})\n+  @IR(counts = {IRNode.ROUND_VD, \"> 0\"},\n+      applyIfPlatform = {\"aarch64\", \"true\"},\n+      applyIf = {\"MaxVectorSize\", \">= 16\"})\n+  static void test_round(long[] a0, double[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+\n+  @Run(test = \"test_round\")\n+  @Warmup(ITERS)\n+  static void test_rounds(RunInfo runInfo) {\n+    \/\/ Initialize\n+    for (int i = 0; i < ARRLEN; i++) {\n+      double val = ADD_INIT+(double)i;\n+      input[i] = val;\n+    }\n+\n+    test_round(res, input);\n+    \/\/ skip test\/verify when warming up\n+    if (runInfo.isWarmUp()) {\n+      return;\n+    }\n+\n+    int errn = 0;\n+    \/\/ a double precise float point is composed of 3 parts: sign\/exponent\/signicand\n+    \/\/ exponent part of a float value\n+    final int exponentShift = 52;\n+    final int exponentWidth = 11;\n+    final int exponentBound = 1 << exponentWidth;\n+    \/\/ significant part of a float value\n+    final int signicandWidth = exponentShift;\n+    final long signicandBound = 1L << signicandWidth;\n+    final int signicandNum = 256;\n+\n+    \/\/ prepare for data of significand part\n+    long signicandValues[] = new long[signicandNum];\n+    int signicandIdx = 0;\n+    for (; signicandIdx < signicandWidth; signicandIdx++) {\n+      signicandValues[signicandIdx] = 1L << signicandIdx;\n+    }\n+    for (; signicandIdx < signicandNum; signicandIdx++) {\n+      signicandValues[signicandIdx] = rand.nextLong(signicandBound);\n+    }\n+    signicandValues[rand.nextInt(signicandNum)] = 0;\n+\n+    \/\/ generate input arrays for testing, then run tests & verify results\n+\n+    \/\/ generate input arrays by combining different parts\n+    for (long sv : signicandValues) {\n+      \/\/ generate test input by combining different parts:\n+      \/\/   previously generated significand values,\n+      \/\/   random value in exponent range,\n+      \/\/   both positive and negative of previous combined values (exponent+significand)\n+      final int exponentStart = rand.nextInt(9);\n+      final int exponentStep = (1 << 3) + rand.nextInt(3);\n+      \/\/ Here, we could have iterated the whole range of exponent values, but it would\n+      \/\/ take more time to run the test, so just randomly choose some of exponent values.\n+      int ev = exponentStart;\n+      int inputIdx = 0;\n+      for (; ev < exponentBound; ev += exponentStep) {\n+        inputIdx = ev\/exponentStep;\n+        \/\/ combine exponent and significand\n+        long bits = ((long)ev << exponentShift) + sv;\n+        \/\/ combine sign(+\/-) with exponent and significand\n+        \/\/ positive values\n+        input[inputIdx*2] = Double.longBitsToDouble(bits);\n+        \/\/ negative values\n+        bits = bits | (1L << 63);\n+        input[inputIdx*2+1] = Double.longBitsToDouble(bits);\n+      }\n+      \/\/ add specific test cases where it looks like in binary format:\n+      \/\/   s111 1111 1111 xxxx xxxx xxxx xxxx xxxx ...\n+      \/\/ these are for the NaN and Inf.\n+      inputIdx = inputIdx*2+2;\n+      long bits = (1L << exponentWidth) - 1L;\n+      bits <<= exponentShift;\n+      input[inputIdx++] = Double.longBitsToDouble(bits);\n+      bits = bits | (1L << 63);\n+      input[inputIdx] = Double.longBitsToDouble(bits);\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      ev = exponentStart;\n+      inputIdx = ev\/exponentStep;\n+      for (; ev < exponentBound; ev += exponentStep) {\n+        for (int sign = 0; sign < 2; sign++) {\n+          int idx = inputIdx * 2 + sign;\n+          if (res[idx] != golden_round(input[idx])) {\n+            errn++;\n+            System.err.println(\"round error, input: \" + input[idx] +\n+                               \", res: \" + res[idx] + \"expected: \" + golden_round(input[idx]) +\n+                               \", input hex: \" + Double.doubleToLongBits(input[idx]) +\n+                               \", fi: \" + sv + \", ei: \" + ev + \", sign: \" + sign);\n+          }\n+        }\n+      }\n+    }\n+\n+    \/\/ generate pure random input arrays, which does not depend on significand\/exponent values\n+    for(int i = 0; i < 128; i++) {\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = rand.nextDouble();\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Double.doubleToLongBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    \/\/ test cases for NaN, Inf, subnormal, and so on\n+    {\n+      Double[] dv = new Double[] {\n+        +0.0,\n+        -0.0,\n+        Double.MAX_VALUE,\n+        Double.MIN_VALUE,\n+        Double.NEGATIVE_INFINITY,\n+        Double.POSITIVE_INFINITY,\n+        Double.NaN,\n+        Double.longBitsToDouble(0x7ff0000000000001L), \/\/ another NaN\n+        Double.MIN_NORMAL,\n+        0x0.fffffffffffffp-1022,   \/\/ Maximum Subnormal Value\n+        1.5,\n+        100.5,\n+        10000.5,\n+        -1.5,\n+        -100.5,\n+        -10000.5\n+      };\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = dv[rand.nextInt(dv.length)];\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Double.doubleToLongBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    if (errn > 0) {\n+      throw new RuntimeException(\"There are some round error detected!\");\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorDoubleRandom.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8321010\n+ * @summary Test vector intrinsic for Math.round(float) in full 32 bits range\n+ *\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.math\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=8 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=16 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileThresholdScaling=0.3 -XX:MaxVectorSize=32 -XX:+UseSuperWord -XX:CompileCommand=compileonly,compiler.vectorization.TestRoundVectorFloatAll::test* compiler.vectorization.TestRoundVectorFloatAll\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.Random;\n+import static compiler.lib.golden.GoldenRound.golden_round;\n+\n+public class TestRoundVectorFloatAll {\n+  private static final Random rand = new Random();\n+\n+  private static final int ITERS  = 11000;\n+  private static final int ARRLEN = rand.nextInt(4096-997) + 997;\n+  private static final float ADD_INIT = -7500.f;\n+\n+  public static void main(String args[]) {\n+    test();\n+  }\n+\n+  static void test() {\n+    float[] input = new float[ARRLEN];\n+    int [] res = new int[ARRLEN];\n+\n+    \/\/ Warmup\n+    System.out.println(\"Warmup\");\n+    for (int i=0; i<ITERS; i++) {\n+      test_round(res, input);\n+    }\n+\n+    \/\/ Test and verify results\n+    System.out.println(\"Verification\");\n+    int errn = 0;\n+    for (long l = Integer.MIN_VALUE; l <= Integer.MAX_VALUE; l+=ARRLEN) {\n+      for (int i = 0; i < ARRLEN; i++) {\n+        input[i] = Float.intBitsToFloat((int)(i+l));\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Float.floatToIntBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    if (errn > 0) {\n+      throw new RuntimeException(\"There are some round error detected!\");\n+    }\n+  }\n+\n+  static void test_round(int[] a0, float[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatAll.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key randomness\n+ * @bug 8321010\n+ * @summary Test vector intrinsic for Math.round(float) with random input in 32 bits range, verify IR at the same time.\n+ *\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.math\n+ * @run main compiler.vectorization.TestRoundVectorFloatRandom\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import java.util.Random;\n+import static compiler.lib.golden.GoldenRound.golden_round;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.RunInfo;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.Warmup;\n+\n+public class TestRoundVectorFloatRandom {\n+  private static final Random rand = new Random();\n+\n+  private static final int ITERS  = 11000;\n+  private static final int ARRLEN = rand.nextInt(4096-997) + 997;\n+  private static final float ADD_INIT = -7500.f;\n+\n+  private static final float[] input = new float[ARRLEN];\n+  private static final int[] res = new int[ARRLEN];\n+\n+  public static void main(String args[]) {\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=8\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=16\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=32\");\n+  }\n+\n+  @Test\n+  @IR(counts = {IRNode.ROUND_VF, \"> 0\"},\n+      applyIfPlatform = {\"x64\", \"true\"},\n+      applyIfCPUFeature = {\"avx\", \"true\"})\n+  @IR(counts = {IRNode.ROUND_VF, \"> 0\"},\n+      applyIfPlatform = {\"aarch64\", \"true\"})\n+  static void test_round(int[] a0, float[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = Math.round(a1[i]);\n+    }\n+  }\n+\n+  @Run(test = \"test_round\")\n+  @Warmup(ITERS)\n+  static void test_rounds(RunInfo runInfo) {\n+    \/\/ Initialize\n+    for (int i = 0; i < ARRLEN; i++) {\n+      float val = ADD_INIT+(float)i;\n+      input[i] = val;\n+    }\n+\n+    test_round(res, input);\n+    \/\/ skip test\/verify when warming up\n+    if (runInfo.isWarmUp()) {\n+      return;\n+    }\n+\n+    int errn = 0;\n+    \/\/ a single precise float point is composed of 3 parts: sign\/exponent\/signicand\n+    \/\/ exponent part of a float value\n+    final int exponentStart = 0;\n+    final int exponentShift = 23;\n+    final int exponentWidth = 8;\n+    final int exponentBound = 1 << exponentWidth;\n+    \/\/ significant part of a float value\n+    final int signicandWidth = exponentShift;\n+    final int signicandBound = 1 << signicandWidth;\n+    final int signicandNum = 128;\n+\n+    \/\/ prepare for data of significand part\n+    int signicandValues[] = new int[signicandNum];\n+    int signicandIdx = 0;\n+    for (; signicandIdx < signicandWidth; signicandIdx++) {\n+      signicandValues[signicandIdx] = 1 << signicandIdx;\n+    }\n+    for (; signicandIdx < signicandNum; signicandIdx++) {\n+      signicandValues[signicandIdx] = rand.nextInt(signicandBound);\n+    }\n+    signicandValues[rand.nextInt(signicandNum)] = 0;\n+\n+    \/\/ generate input arrays for testing, then run tests & verify results\n+\n+    \/\/ generate input arrays by combining different parts\n+    for (int sv : signicandValues) {\n+      \/\/ generate test input by combining different parts:\n+      \/\/   previously generated significand values,\n+      \/\/   all values in exponent range,\n+      \/\/   both positive and negative of previous combined values (exponent+significand)\n+      for (int ev = exponentStart; ev < exponentBound; ev++) {\n+        \/\/ combine exponent and significand\n+        int bits = (ev << exponentShift) + sv;\n+        \/\/ combine sign(+\/-) with exponent and significand\n+        \/\/ positive values\n+        input[ev*2] = Float.intBitsToFloat(bits);\n+        \/\/ negative values\n+        bits = bits | (1 << 31);\n+        input[ev*2+1] = Float.intBitsToFloat(bits);\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int ev = exponentStart; ev < exponentBound; ev++) {\n+        for (int sign = 0; sign < 2; sign++) {\n+          int idx = ev * 2 + sign;\n+          if (res[idx] != golden_round(input[idx])) {\n+            errn++;\n+            System.err.println(\"round error, input: \" + input[idx] +\n+                               \", res: \" + res[idx] + \"expected: \" + golden_round(input[idx]) +\n+                               \", input hex: \" + Float.floatToIntBits(input[idx]) +\n+                               \", fi: \" + sv + \", ei: \" + ev + \", sign: \" + sign);\n+          }\n+        }\n+      }\n+    }\n+\n+    \/\/ generate pure random input arrays, which does not depend on significand\/exponent values\n+    for(int i = 0; i < 128; i++) {\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = rand.nextFloat();\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Float.floatToIntBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    \/\/ test cases for NaN, Inf, subnormal, and so on\n+    {\n+      Float[] dv = new Float[] {\n+        +0.0f,\n+        -0.0f,\n+        Float.MAX_VALUE,\n+        Float.MIN_VALUE,\n+        Float.NEGATIVE_INFINITY,\n+        Float.POSITIVE_INFINITY,\n+        Float.NaN,\n+        Float.intBitsToFloat(0x7f800001), \/\/ another NaN\n+        Float.MIN_NORMAL,\n+        0x0.fffffep-126f,   \/\/ Maximum Subnormal Value\n+        1.5f,\n+        100.5f,\n+        10000.5f,\n+        -1.5f,\n+        -100.5f,\n+        -10000.5f\n+      };\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = dv[rand.nextInt(dv.length)];\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Float.floatToIntBits(input[j]));\n+        }\n+      }\n+    }\n+\n+    if (errn > 0) {\n+      throw new RuntimeException(\"There are some round error detected!\");\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatRandom.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"}]}