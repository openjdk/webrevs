{"files":[{"patch":"@@ -56,0 +56,2 @@\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\");\n+    TestFramework.runWithFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\", \"-XX:MaxVectorSize=8\");\n@@ -68,1 +70,2 @@\n-      applyIfCPUFeature = {\"avx512dq\", \"true\"})\n+      applyIfCPUFeature = {\"avx512dq\", \"true\"},\n+      applyIf = {\"MaxVectorSize\", \">= 16\"})\n@@ -70,1 +73,2 @@\n-      applyIfPlatform = {\"aarch64\", \"true\"})\n+      applyIfPlatform = {\"aarch64\", \"true\"},\n+      applyIf = {\"MaxVectorSize\", \">= 16\"})\n@@ -189,0 +193,36 @@\n+    \/\/ test cases for NaN, Inf, subnormal, and so on\n+    {\n+      Double[] dv = new Double[] {\n+        Double.MAX_VALUE,\n+        Double.MIN_VALUE,\n+        Double.NEGATIVE_INFINITY,\n+        Double.POSITIVE_INFINITY,\n+        Double.NaN,\n+        Double.longBitsToDouble(0x7ff0000000000001L), \/\/ another NaN\n+        Double.MIN_NORMAL,\n+        0x0.fffffffffffffp-1022,   \/\/ Maximum Subnormal Value\n+        1.5,\n+        100.5,\n+        10000.5,\n+        -1.5,\n+        -100.5,\n+        -10000.5\n+      };\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = dv[rand.nextInt(dv.length)];\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Double.doubleToLongBits(input[j]));\n+        }\n+      }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorDoubleRandom.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -174,0 +174,35 @@\n+    \/\/ test cases for NaN, Inf, subnormal, and so on\n+    {\n+      Float[] dv = new Float[] {\n+        Float.MAX_VALUE,\n+        Float.MIN_VALUE,\n+        Float.NEGATIVE_INFINITY,\n+        Float.POSITIVE_INFINITY,\n+        Float.NaN,\n+        Float.intBitsToFloat(0x7f800001), \/\/ another NaN\n+        Float.MIN_NORMAL,\n+        0x0.fffffep-126f,   \/\/ Maximum Subnormal Value\n+        1.5f,\n+        100.5f,\n+        10000.5f,\n+        -1.5f,\n+        -100.5f,\n+        -10000.5f\n+      };\n+      for (int j = 0; j < ARRLEN; j++) {\n+        input[j] = dv[rand.nextInt(dv.length)];\n+      }\n+\n+      \/\/ run tests\n+      test_round(res, input);\n+\n+      \/\/ verify results\n+      for (int j = 0; j < ARRLEN; j++) {\n+        if (res[j] != golden_round(input[j])) {\n+          errn++;\n+          System.err.println(\"round error, input: \" + input[j] +\n+                             \", res: \" + res[j] + \"expected: \" + golden_round(input[j]) +\n+                             \", input hex: \" + Float.floatToIntBits(input[j]));\n+        }\n+      }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatRandom.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"}]}