{"files":[{"patch":"@@ -31,0 +31,1 @@\n+ * @modules java.base\/jdk.internal.math\n@@ -37,1 +38,1 @@\n-import compiler.lib.ir_framework.DontCompile;\n+import jdk.internal.math.DoubleConsts;\n@@ -62,3 +63,30 @@\n-  @DontCompile\n-  long golden_round(double d) {\n-    return Math.round(d);\n+  long golden_round(double a) {\n+    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n+    \/\/  public static int round(double a) { ... }\n+\n+    long longBits = Double.doubleToRawLongBits(a);\n+    long biasedExp = (longBits & DoubleConsts.EXP_BIT_MASK)\n+            >> (DoubleConsts.SIGNIFICAND_WIDTH - 1);\n+    long shift = (DoubleConsts.SIGNIFICAND_WIDTH - 2\n+            + DoubleConsts.EXP_BIAS) - biasedExp;\n+    if ((shift & -64) == 0) { \/\/ shift >= 0 && shift < 64\n+        \/\/ a is a finite number such that pow(2,-64) <= ulp(a) < 1\n+        long r = ((longBits & DoubleConsts.SIGNIF_BIT_MASK)\n+                | (DoubleConsts.SIGNIF_BIT_MASK + 1));\n+        if (longBits < 0) {\n+            r = -r;\n+        }\n+        \/\/ In the comments below each Java expression evaluates to the value\n+        \/\/ the corresponding mathematical expression:\n+        \/\/ (r) evaluates to a \/ ulp(a)\n+        \/\/ (r >> shift) evaluates to floor(a * 2)\n+        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n+        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n+        return ((r >> shift) + 1) >> 1;\n+    } else {\n+        \/\/ a is either\n+        \/\/ - a finite number with abs(a) < exp(2,DoubleConsts.SIGNIFICAND_WIDTH-64) < 1\/2\n+        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n+        \/\/ - an infinity or NaN\n+        return (long) a;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorDoubleRandom.java","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @modules java.base\/jdk.internal.math\n@@ -37,1 +38,1 @@\n-import compiler.lib.ir_framework.DontCompile;\n+import jdk.internal.math.FloatConsts;\n@@ -62,3 +63,30 @@\n-  @DontCompile\n-  int golden_round(float f) {\n-    return Math.round(f);\n+  int golden_round(float a) {\n+    \/\/ below code is copied from java.base\/share\/classes\/java\/lang\/Math.java\n+    \/\/  public static int round(float a) { ... }\n+\n+    int intBits = Float.floatToRawIntBits(a);\n+    int biasedExp = (intBits & FloatConsts.EXP_BIT_MASK)\n+            >> (FloatConsts.SIGNIFICAND_WIDTH - 1);\n+    int shift = (FloatConsts.SIGNIFICAND_WIDTH - 2\n+            + FloatConsts.EXP_BIAS) - biasedExp;\n+    if ((shift & -32) == 0) { \/\/ shift >= 0 && shift < 32\n+        \/\/ a is a finite number such that pow(2,-32) <= ulp(a) < 1\n+        int r = ((intBits & FloatConsts.SIGNIF_BIT_MASK)\n+                | (FloatConsts.SIGNIF_BIT_MASK + 1));\n+        if (intBits < 0) {\n+            r = -r;\n+        }\n+        \/\/ In the comments below each Java expression evaluates to the value\n+        \/\/ the corresponding mathematical expression:\n+        \/\/ (r) evaluates to a \/ ulp(a)\n+        \/\/ (r >> shift) evaluates to floor(a * 2)\n+        \/\/ ((r >> shift) + 1) evaluates to floor((a + 1\/2) * 2)\n+        \/\/ (((r >> shift) + 1) >> 1) evaluates to floor(a + 1\/2)\n+        return ((r >> shift) + 1) >> 1;\n+    } else {\n+        \/\/ a is either\n+        \/\/ - a finite number with abs(a) < exp(2,FloatConsts.SIGNIFICAND_WIDTH-32) < 1\/2\n+        \/\/ - a finite number with ulp(a) >= 1 and hence a is a mathematical integer\n+        \/\/ - an infinity or NaN\n+        return (int) a;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestRoundVectorFloatRandom.java","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"}]}