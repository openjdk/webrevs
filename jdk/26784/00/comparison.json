{"files":[{"patch":"@@ -28,2 +28,0 @@\n-import java.io.BufferedInputStream;\n-import java.io.ByteArrayOutputStream;\n@@ -31,1 +29,0 @@\n-import java.io.FileInputStream;\n@@ -35,1 +32,0 @@\n-import java.net.URL;\n@@ -38,8 +34,0 @@\n-import javax.sound.SoundClip;\n-import javax.sound.midi.InvalidMidiDataException;\n-import javax.sound.midi.MetaEventListener;\n-import javax.sound.midi.MetaMessage;\n-import javax.sound.midi.MidiFileFormat;\n-import javax.sound.midi.MidiSystem;\n-import javax.sound.midi.MidiUnavailableException;\n-import javax.sound.midi.Sequence;\n@@ -47,9 +35,3 @@\n-import javax.sound.sampled.AudioFormat;\n-import javax.sound.sampled.AudioInputStream;\n-import javax.sound.sampled.AudioSystem;\n-import javax.sound.sampled.Clip;\n-import javax.sound.sampled.DataLine;\n-import javax.sound.sampled.LineEvent;\n-import javax.sound.sampled.LineListener;\n-import javax.sound.sampled.SourceDataLine;\n-import javax.sound.sampled.UnsupportedAudioFileException;\n+import javax.sound.SoundClip;\n+import sun.java2d.Disposer;\n+import sun.java2d.DisposerRecord;\n@@ -60,2 +42,0 @@\n- * @author Arthur van Hoff, Kara Kytle, Jan Borgersen\n- * @author Florian Bomers\n@@ -63,33 +43,1 @@\n-public final class JavaSoundAudioClip implements MetaEventListener, LineListener {\n-\n-    private long lastPlayCall = 0;\n-    private static final int MINIMUM_PLAY_DELAY = 30;\n-\n-    private byte[] loadedAudio = null;\n-    private int loadedAudioByteLength = 0;\n-    private AudioFormat loadedAudioFormat = null;\n-\n-    private AutoClosingClip clip = null;\n-    private boolean clipLooping = false;\n-    private boolean clipPlaying = false;\n-\n-    private DataPusher datapusher = null;\n-    private boolean daemonThread = false;\n-\n-    private Sequencer sequencer = null;\n-    private Sequence sequence = null;\n-    private boolean sequencerloop = false;\n-    private volatile boolean success;\n-\n-    \/**\n-     * used for determining how many samples is the\n-     * threshold between playing as a Clip and streaming\n-     * from the file.\n-     *\n-     * $$jb: 11.07.99: the engine has a limit of 1M\n-     * samples to play as a Clip, so compare this number\n-     * with the number of samples in the stream.\n-     *\n-     *\/\n-    private static final long CLIP_THRESHOLD = 1048576;\n-    private static final int STREAM_BUFFER_SIZE = 1024;\n+public final class JavaSoundAudioClip {\n@@ -98,6 +46,1 @@\n-        JavaSoundAudioClip clip = new JavaSoundAudioClip();\n-        clip.daemonThread = true; \/\/ used only by javax.sound.SoundClip\n-        try (FileInputStream stream = new FileInputStream(file)) {\n-            clip.init(stream);\n-        }\n-        return clip;\n+        return new JavaSoundAudioClip(file);\n@@ -130,7 +73,1 @@\n-    private void init(InputStream in) throws IOException {\n-        BufferedInputStream bis = new BufferedInputStream(in, STREAM_BUFFER_SIZE);\n-        bis.mark(STREAM_BUFFER_SIZE);\n-        try {\n-            AudioInputStream as = AudioSystem.getAudioInputStream(bis);\n-            \/\/ load the stream data into memory\n-            success = loadAudioData(as);\n+    private JavaSoundAudioClipDelegate delegate;\n@@ -138,17 +75,4 @@\n-            if (success) {\n-                success = false;\n-                if (loadedAudioByteLength < CLIP_THRESHOLD) {\n-                    success = createClip();\n-                }\n-                if (!success) {\n-                    success = createSourceDataLine();\n-                }\n-            }\n-        } catch (UnsupportedAudioFileException e) {\n-            try {\n-                MidiFileFormat mff = MidiSystem.getMidiFileFormat(bis);\n-                success = createSequencer(bis);\n-            } catch (InvalidMidiDataException e1) {\n-                success = false;\n-            }\n-        }\n+    public JavaSoundAudioClip(final File file) throws IOException {\n+        disposerRecord = new AudioClipDisposerRecord();\n+        Disposer.addRecord(this, disposerRecord);\n+        delegate = new JavaSoundAudioClipDelegate(file, disposerRecord);\n@@ -158,1 +82,1 @@\n-        return success;\n+        return delegate.canPlay();\n@@ -162,10 +86,1 @@\n-        if (!canPlay()) {\n-            return false;\n-        } else if (clip != null) {\n-            return clipPlaying;\n-        } else if (datapusher != null) {\n-            return datapusher.isPlaying();\n-        } else if (sequencer != null) {\n-           return sequencer.isRunning();\n-        }\n-        return false;\n+        return delegate.isPlaying();\n@@ -175,4 +90,1 @@\n-        if (!success) {\n-            return;\n-        }\n-        startImpl(false);\n+        delegate.play();\n@@ -182,68 +94,1 @@\n-        if (!success) {\n-            return;\n-        }\n-        startImpl(true);\n-    }\n-\n-    private synchronized void startImpl(boolean loop) {\n-        \/\/ hack for some applications that call the start method very rapidly...\n-        long currentTime = System.currentTimeMillis();\n-        long diff = currentTime - lastPlayCall;\n-        if (diff < MINIMUM_PLAY_DELAY) {\n-            return;\n-        }\n-        lastPlayCall = currentTime;\n-        try {\n-            if (clip != null) {\n-                \/\/ We need to disable autoclosing mechanism otherwise the clip\n-                \/\/ can be closed after \"!clip.isOpen()\" check, because of\n-                \/\/ previous inactivity.\n-                clip.setAutoClosing(false);\n-                try {\n-                    if (!clip.isOpen()) {\n-                        clip.open(loadedAudioFormat, loadedAudio, 0,\n-                                  loadedAudioByteLength);\n-                    } else {\n-                        clip.flush();\n-                        if (loop != clipLooping) {\n-                            \/\/ need to stop in case the looped status changed\n-                            clip.stop();\n-                        }\n-                    }\n-                    clip.setFramePosition(0);\n-                    if (loop) {\n-                        clip.loop(Clip.LOOP_CONTINUOUSLY);\n-                    } else {\n-                        clip.start();\n-                    }\n-                    clipLooping = loop;\n-                } finally {\n-                    clip.setAutoClosing(true);\n-                }\n-            } else if (datapusher != null ) {\n-                datapusher.start(loop);\n-\n-            } else if (sequencer != null) {\n-                sequencerloop = loop;\n-                if (sequencer.isRunning()) {\n-                    sequencer.setMicrosecondPosition(0);\n-                }\n-                if (!sequencer.isOpen()) {\n-                    try {\n-                        sequencer.open();\n-                        sequencer.setSequence(sequence);\n-\n-                    } catch (InvalidMidiDataException | MidiUnavailableException e) {\n-                        if (Printer.err) e.printStackTrace();\n-                    }\n-                }\n-                sequencer.addMetaEventListener(this);\n-                try {\n-                    sequencer.start();\n-                } catch (Exception e) {\n-                    if (Printer.err) e.printStackTrace();\n-                }\n-            }\n-        } catch (Exception e) {\n-            if (Printer.err) e.printStackTrace();\n-        }\n+        delegate.loop();\n@@ -253,63 +98,1 @@\n-        if (!success) {\n-            return;\n-        }\n-        lastPlayCall = 0;\n-\n-        if (clip != null) {\n-            try {\n-                clip.flush();\n-            } catch (Exception e1) {\n-                if (Printer.err) e1.printStackTrace();\n-            }\n-            try {\n-                clip.stop();\n-            } catch (Exception e2) {\n-                if (Printer.err) e2.printStackTrace();\n-            }\n-        } else if (datapusher != null) {\n-            datapusher.stop();\n-        } else if (sequencer != null) {\n-            try {\n-                sequencerloop = false;\n-                sequencer.removeMetaEventListener(this);\n-                sequencer.stop();\n-            } catch (Exception e3) {\n-                if (Printer.err) e3.printStackTrace();\n-            }\n-            try {\n-                sequencer.close();\n-            } catch (Exception e4) {\n-                if (Printer.err) e4.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    \/\/ Event handlers (for debugging)\n-\n-    @Override\n-    public synchronized void update(LineEvent event) {\n-       if (clip != null) {\n-           if (clip == event.getSource()) {\n-               if (event.getType() == LineEvent.Type.START) {\n-                  clipPlaying = true;\n-               } else if ((event.getType() == LineEvent.Type.STOP) ||\n-                          (event.getType() == LineEvent.Type.CLOSE)) {\n-                  clipPlaying = false;\n-               }\n-           }\n-       }\n-    }\n-\n-    \/\/ handle MIDI track end meta events for looping\n-\n-    @Override\n-    public synchronized void meta(MetaMessage message) {\n-        if( message.getType() == 47 ) {\n-            if (sequencerloop){\n-                \/\/notifyAll();\n-                sequencer.setMicrosecondPosition(0);\n-                loop();\n-            } else {\n-                stop();\n-            }\n-        }\n+        delegate.stop();\n@@ -323,26 +106,2 @@\n-    @Override\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() {\n-\n-        if (clip != null) {\n-            clip.close();\n-        }\n-\n-        \/\/$$fb 2001-09-26: may improve situation related to bug #4302884\n-        if (datapusher != null) {\n-            datapusher.close();\n-        }\n-\n-        if (sequencer != null) {\n-            sequencer.close();\n-        }\n-    }\n-\n-    \/\/ FILE LOADING METHODS\n-\n-    private boolean loadAudioData(AudioInputStream as)  throws IOException, UnsupportedAudioFileException {\n-        \/\/ first possibly convert this stream to PCM\n-        as = Toolkit.getPCMConvertedAudioInputStream(as);\n-        if (as == null) {\n-            return false;\n-        }\n+    private AudioClipDisposerRecord disposerRecord;\n+    static class AudioClipDisposerRecord implements DisposerRecord {\n@@ -350,22 +109,3 @@\n-        loadedAudioFormat = as.getFormat();\n-        long frameLen = as.getFrameLength();\n-        int frameSize = loadedAudioFormat.getFrameSize();\n-        long byteLen = AudioSystem.NOT_SPECIFIED;\n-        if (frameLen != AudioSystem.NOT_SPECIFIED\n-            && frameLen > 0\n-            && frameSize != AudioSystem.NOT_SPECIFIED\n-            && frameSize > 0) {\n-            byteLen = frameLen * frameSize;\n-        }\n-        if (byteLen != AudioSystem.NOT_SPECIFIED) {\n-            \/\/ if the stream length is known, it can be efficiently loaded into memory\n-            readStream(as, byteLen);\n-        } else {\n-            \/\/ otherwise we use a ByteArrayOutputStream to load it into memory\n-            readStream(as);\n-        }\n-\n-        \/\/ if everything went fine, we have now the audio data in\n-        \/\/ loadedAudio, and the byte length in loadedAudioByteLength\n-        return true;\n-    }\n+        private volatile AutoClosingClip clip;\n+        private volatile DataPusher datapusher;\n+        private volatile Sequencer sequencer;\n@@ -373,7 +113,2 @@\n-    private void readStream(AudioInputStream as, long byteLen) throws IOException {\n-        \/\/ arrays \"only\" max. 2GB\n-        int intLen;\n-        if (byteLen > 2147483647) {\n-            intLen = 2147483647;\n-        } else {\n-            intLen = (int) byteLen;\n+        void setClip(AutoClosingClip clip) {\n+            this.clip = clip;\n@@ -381,2 +116,0 @@\n-        loadedAudio = new byte[intLen];\n-        loadedAudioByteLength = 0;\n@@ -384,8 +117,2 @@\n-        \/\/ this loop may throw an IOException\n-        while (true) {\n-            int bytesRead = as.read(loadedAudio, loadedAudioByteLength, intLen - loadedAudioByteLength);\n-            if (bytesRead <= 0) {\n-                as.close();\n-                break;\n-            }\n-            loadedAudioByteLength += bytesRead;\n+        void setDataPusher(DataPusher datapusher) {\n+            this.datapusher = datapusher;\n@@ -393,1 +120,0 @@\n-    }\n@@ -395,6 +121,2 @@\n-    private void readStream(AudioInputStream as) throws IOException {\n-\n-        DirectBAOS baos = new DirectBAOS();\n-        int totalBytesRead;\n-        try (as) {\n-            totalBytesRead = (int) as.transferTo(baos);\n+        void setSequencer(Sequencer sequencer) {\n+            this.sequencer = sequencer;\n@@ -402,5 +124,0 @@\n-        loadedAudio = baos.getInternalBuffer();\n-        loadedAudioByteLength = totalBytesRead;\n-    }\n-\n-    \/\/ METHODS FOR CREATING THE DEVICE\n@@ -408,13 +125,3 @@\n-    private boolean createClip() {\n-        try {\n-            DataLine.Info info = new DataLine.Info(Clip.class, loadedAudioFormat);\n-            if (!(AudioSystem.isLineSupported(info)) ) {\n-                if (Printer.err) Printer.err(\"Clip not supported: \"+loadedAudioFormat);\n-                \/\/ fail silently\n-                return false;\n-            }\n-            Object line = AudioSystem.getLine(info);\n-            if (!(line instanceof AutoClosingClip)) {\n-                if (Printer.err) Printer.err(\"Clip is not auto closing!\"+clip);\n-                \/\/ fail -> will try with SourceDataLine\n-                return false;\n+        public void dispose() {\n+            if (clip != null) {\n+                clip.close();\n@@ -422,15 +129,0 @@\n-            clip = (AutoClosingClip) line;\n-            clip.setAutoClosing(true);\n-            clip.addLineListener(this);\n-        } catch (Exception e) {\n-            if (Printer.err) e.printStackTrace();\n-            \/\/ fail silently\n-            return false;\n-        }\n-\n-        if (clip==null) {\n-            \/\/ fail silently\n-            return false;\n-        }\n-        return true;\n-    }\n@@ -438,7 +130,2 @@\n-    private boolean createSourceDataLine() {\n-        try {\n-            DataLine.Info info = new DataLine.Info(SourceDataLine.class, loadedAudioFormat);\n-            if (!(AudioSystem.isLineSupported(info)) ) {\n-                if (Printer.err) Printer.err(\"Line not supported: \"+loadedAudioFormat);\n-                \/\/ fail silently\n-                return false;\n+            if (datapusher != null) {\n+                datapusher.close();\n@@ -446,7 +133,0 @@\n-            SourceDataLine source = (SourceDataLine) AudioSystem.getLine(info);\n-            datapusher = new DataPusher(source, loadedAudioFormat, loadedAudio, loadedAudioByteLength, daemonThread);\n-        } catch (Exception e) {\n-            if (Printer.err) e.printStackTrace();\n-            \/\/ fail silently\n-            return false;\n-        }\n@@ -454,23 +134,2 @@\n-        if (datapusher==null) {\n-            \/\/ fail silently\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    private boolean createSequencer(BufferedInputStream in) throws IOException {\n-        \/\/ get the sequencer\n-        try {\n-            sequencer = MidiSystem.getSequencer( );\n-        } catch(MidiUnavailableException me) {\n-            if (Printer.err) me.printStackTrace();\n-            return false;\n-        }\n-        if (sequencer==null) {\n-            return false;\n-        }\n-\n-        try {\n-            sequence = MidiSystem.getSequence(in);\n-            if (sequence == null) {\n-                return false;\n+            if (sequencer != null) {\n+                sequencer.close();\n@@ -478,3 +137,0 @@\n-        } catch (InvalidMidiDataException e) {\n-            if (Printer.err) e.printStackTrace();\n-            return false;\n@@ -482,1 +138,0 @@\n-        return true;\n@@ -484,15 +139,0 @@\n-\n-    \/*\n-     * private inner class representing a ByteArrayOutputStream\n-     * which allows retrieval of the internal array\n-     *\/\n-    private static class DirectBAOS extends ByteArrayOutputStream {\n-        DirectBAOS() {\n-            super();\n-        }\n-\n-        public byte[] getInternalBuffer() {\n-            return buf;\n-        }\n-\n-    } \/\/ class DirectBAOS\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/JavaSoundAudioClip.java","additions":33,"deletions":393,"binary":false,"changes":426,"status":"modified"},{"patch":"@@ -0,0 +1,455 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.media.sound;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import javax.sound.SoundClip;\n+import javax.sound.midi.InvalidMidiDataException;\n+import javax.sound.midi.MetaEventListener;\n+import javax.sound.midi.MetaMessage;\n+import javax.sound.midi.MidiFileFormat;\n+import javax.sound.midi.MidiSystem;\n+import javax.sound.midi.MidiUnavailableException;\n+import javax.sound.midi.Sequence;\n+import javax.sound.midi.Sequencer;\n+import javax.sound.sampled.AudioFormat;\n+import javax.sound.sampled.AudioInputStream;\n+import javax.sound.sampled.AudioSystem;\n+import javax.sound.sampled.Clip;\n+import javax.sound.sampled.DataLine;\n+import javax.sound.sampled.LineEvent;\n+import javax.sound.sampled.LineListener;\n+import javax.sound.sampled.SourceDataLine;\n+import javax.sound.sampled.UnsupportedAudioFileException;\n+import com.sun.media.sound.JavaSoundAudioClip.AudioClipDisposerRecord;\n+\n+\/**\n+ * Java Sound audio clip;\n+ *\n+ *\/\n+public final class JavaSoundAudioClipDelegate implements MetaEventListener, LineListener {\n+\n+    private long lastPlayCall = 0;\n+    private static final int MINIMUM_PLAY_DELAY = 30;\n+\n+    private byte[] loadedAudio = null;\n+    private int loadedAudioByteLength = 0;\n+    private AudioFormat loadedAudioFormat = null;\n+\n+    private AutoClosingClip clip = null;\n+    private boolean clipLooping = false;\n+    private boolean clipPlaying = false;\n+\n+    private DataPusher datapusher = null;\n+\n+    private Sequencer sequencer = null;\n+    private Sequence sequence = null;\n+    private boolean sequencerloop = false;\n+    private volatile boolean success;\n+\n+    \/**\n+     * used for determining how many samples is the\n+     * threshold between playing as a Clip and streaming\n+     * from the file.\n+     *\n+     * $$jb: 11.07.99: the engine has a limit of 1M\n+     * samples to play as a Clip, so compare this number\n+     * with the number of samples in the stream.\n+     *\n+     *\/\n+    private static final long CLIP_THRESHOLD = 1048576;\n+    private static final int STREAM_BUFFER_SIZE = 1024;\n+\n+    private AudioClipDisposerRecord disposerRecord;\n+    JavaSoundAudioClipDelegate(File file, AudioClipDisposerRecord record) throws IOException {\n+       this.disposerRecord = record;\n+        try (FileInputStream stream = new FileInputStream(file)) {\n+            init(stream);\n+        }\n+\n+    }\n+\n+    private void init(InputStream in) throws IOException {\n+        BufferedInputStream bis = new BufferedInputStream(in, STREAM_BUFFER_SIZE);\n+        bis.mark(STREAM_BUFFER_SIZE);\n+        try {\n+            AudioInputStream as = AudioSystem.getAudioInputStream(bis);\n+            \/\/ load the stream data into memory\n+            success = loadAudioData(as);\n+\n+            if (success) {\n+                success = false;\n+                if (loadedAudioByteLength < CLIP_THRESHOLD) {\n+                    success = createClip();\n+                }\n+                if (!success) {\n+                    success = createSourceDataLine();\n+                }\n+            }\n+        } catch (UnsupportedAudioFileException e) {\n+            try {\n+                MidiFileFormat mff = MidiSystem.getMidiFileFormat(bis);\n+                success = createSequencer(bis);\n+            } catch (InvalidMidiDataException e1) {\n+                success = false;\n+            }\n+        }\n+    }\n+\n+    public synchronized boolean canPlay() {\n+        return success;\n+    }\n+\n+    public synchronized boolean isPlaying() {\n+        if (!canPlay()) {\n+            return false;\n+        } else if (clip != null) {\n+            return clipPlaying;\n+        } else if (datapusher != null) {\n+            return datapusher.isPlaying();\n+        } else if (sequencer != null) {\n+           return sequencer.isRunning();\n+        }\n+        return false;\n+    }\n+\n+    public synchronized void play() {\n+        if (!success) {\n+            return;\n+        }\n+        startImpl(false);\n+    }\n+\n+    public synchronized void loop() {\n+        if (!success) {\n+            return;\n+        }\n+        startImpl(true);\n+    }\n+\n+    private synchronized void startImpl(boolean loop) {\n+        \/\/ hack for some applications that call the start method very rapidly...\n+        long currentTime = System.currentTimeMillis();\n+        long diff = currentTime - lastPlayCall;\n+        if (diff < MINIMUM_PLAY_DELAY) {\n+            return;\n+        }\n+        lastPlayCall = currentTime;\n+        try {\n+            if (clip != null) {\n+                \/\/ We need to disable autoclosing mechanism otherwise the clip\n+                \/\/ can be closed after \"!clip.isOpen()\" check, because of\n+                \/\/ previous inactivity.\n+                clip.setAutoClosing(false);\n+                try {\n+                    if (!clip.isOpen()) {\n+                        clip.open(loadedAudioFormat, loadedAudio, 0,\n+                                  loadedAudioByteLength);\n+                    } else {\n+                        clip.flush();\n+                        if (loop != clipLooping) {\n+                            \/\/ need to stop in case the looped status changed\n+                            clip.stop();\n+                        }\n+                    }\n+                    clip.setFramePosition(0);\n+                    if (loop) {\n+                        clip.loop(Clip.LOOP_CONTINUOUSLY);\n+                    } else {\n+                        clip.start();\n+                    }\n+                    clipLooping = loop;\n+                } finally {\n+                    clip.setAutoClosing(true);\n+                }\n+            } else if (datapusher != null ) {\n+                datapusher.start(loop);\n+\n+            } else if (sequencer != null) {\n+                sequencerloop = loop;\n+                if (sequencer.isRunning()) {\n+                    sequencer.setMicrosecondPosition(0);\n+                }\n+                if (!sequencer.isOpen()) {\n+                    try {\n+                        sequencer.open();\n+                        sequencer.setSequence(sequence);\n+\n+                    } catch (InvalidMidiDataException | MidiUnavailableException e) {\n+                        if (Printer.err) e.printStackTrace();\n+                    }\n+                }\n+                sequencer.addMetaEventListener(this);\n+                try {\n+                    sequencer.start();\n+                } catch (Exception e) {\n+                    if (Printer.err) e.printStackTrace();\n+                }\n+            }\n+        } catch (Exception e) {\n+            if (Printer.err) e.printStackTrace();\n+        }\n+    }\n+\n+    public synchronized void stop() {\n+        if (!success) {\n+            return;\n+        }\n+        lastPlayCall = 0;\n+\n+        if (clip != null) {\n+            try {\n+                clip.flush();\n+            } catch (Exception e1) {\n+                if (Printer.err) e1.printStackTrace();\n+            }\n+            try {\n+                clip.stop();\n+            } catch (Exception e2) {\n+                if (Printer.err) e2.printStackTrace();\n+            }\n+        } else if (datapusher != null) {\n+            datapusher.stop();\n+        } else if (sequencer != null) {\n+            try {\n+                sequencerloop = false;\n+                sequencer.removeMetaEventListener(this);\n+                sequencer.stop();\n+            } catch (Exception e3) {\n+                if (Printer.err) e3.printStackTrace();\n+            }\n+            try {\n+                sequencer.close();\n+            } catch (Exception e4) {\n+                if (Printer.err) e4.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    \/\/ Event handlers (for debugging)\n+\n+    @Override\n+    public synchronized void update(LineEvent event) {\n+       if (clip != null) {\n+           if (clip == event.getSource()) {\n+               if (event.getType() == LineEvent.Type.START) {\n+                  clipPlaying = true;\n+               } else if ((event.getType() == LineEvent.Type.STOP) ||\n+                          (event.getType() == LineEvent.Type.CLOSE)) {\n+                  clipPlaying = false;\n+               }\n+           }\n+       }\n+    }\n+\n+    \/\/ handle MIDI track end meta events for looping\n+\n+    @Override\n+    public synchronized void meta(MetaMessage message) {\n+        if( message.getType() == 47 ) {\n+            if (sequencerloop){\n+                \/\/notifyAll();\n+                sequencer.setMicrosecondPosition(0);\n+                loop();\n+            } else {\n+                stop();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getClass().toString();\n+    }\n+\n+    \/\/ FILE LOADING METHODS\n+\n+    private boolean loadAudioData(AudioInputStream as)  throws IOException, UnsupportedAudioFileException {\n+        \/\/ first possibly convert this stream to PCM\n+        as = Toolkit.getPCMConvertedAudioInputStream(as);\n+        if (as == null) {\n+            return false;\n+        }\n+\n+        loadedAudioFormat = as.getFormat();\n+        long frameLen = as.getFrameLength();\n+        int frameSize = loadedAudioFormat.getFrameSize();\n+        long byteLen = AudioSystem.NOT_SPECIFIED;\n+        if (frameLen != AudioSystem.NOT_SPECIFIED\n+            && frameLen > 0\n+            && frameSize != AudioSystem.NOT_SPECIFIED\n+            && frameSize > 0) {\n+            byteLen = frameLen * frameSize;\n+        }\n+        if (byteLen != AudioSystem.NOT_SPECIFIED) {\n+            \/\/ if the stream length is known, it can be efficiently loaded into memory\n+            readStream(as, byteLen);\n+        } else {\n+            \/\/ otherwise we use a ByteArrayOutputStream to load it into memory\n+            readStream(as);\n+        }\n+\n+        \/\/ if everything went fine, we have now the audio data in\n+        \/\/ loadedAudio, and the byte length in loadedAudioByteLength\n+        return true;\n+    }\n+\n+    private void readStream(AudioInputStream as, long byteLen) throws IOException {\n+        \/\/ arrays \"only\" max. 2GB\n+        int intLen;\n+        if (byteLen > 2147483647) {\n+            intLen = 2147483647;\n+        } else {\n+            intLen = (int) byteLen;\n+        }\n+        loadedAudio = new byte[intLen];\n+        loadedAudioByteLength = 0;\n+\n+        \/\/ this loop may throw an IOException\n+        while (true) {\n+            int bytesRead = as.read(loadedAudio, loadedAudioByteLength, intLen - loadedAudioByteLength);\n+            if (bytesRead <= 0) {\n+                as.close();\n+                break;\n+            }\n+            loadedAudioByteLength += bytesRead;\n+        }\n+    }\n+\n+    private void readStream(AudioInputStream as) throws IOException {\n+\n+        DirectBAOS baos = new DirectBAOS();\n+        int totalBytesRead;\n+        try (as) {\n+            totalBytesRead = (int) as.transferTo(baos);\n+        }\n+        loadedAudio = baos.getInternalBuffer();\n+        loadedAudioByteLength = totalBytesRead;\n+    }\n+\n+    \/\/ METHODS FOR CREATING THE DEVICE\n+\n+    private boolean createClip() {\n+        try {\n+            DataLine.Info info = new DataLine.Info(Clip.class, loadedAudioFormat);\n+            if (!(AudioSystem.isLineSupported(info)) ) {\n+                if (Printer.err) Printer.err(\"Clip not supported: \"+loadedAudioFormat);\n+                \/\/ fail silently\n+                return false;\n+            }\n+            Object line = AudioSystem.getLine(info);\n+            if (!(line instanceof AutoClosingClip)) {\n+                if (Printer.err) Printer.err(\"Clip is not auto closing!\"+clip);\n+                \/\/ fail -> will try with SourceDataLine\n+                return false;\n+            }\n+            clip = (AutoClosingClip) line;\n+            disposerRecord.setClip(clip);\n+            clip.setAutoClosing(true);\n+            clip.addLineListener(this);\n+        } catch (Exception e) {\n+            if (Printer.err) e.printStackTrace();\n+            \/\/ fail silently\n+            return false;\n+        }\n+\n+        if (clip==null) {\n+            \/\/ fail silently\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private boolean createSourceDataLine() {\n+        try {\n+            DataLine.Info info = new DataLine.Info(SourceDataLine.class, loadedAudioFormat);\n+            if (!(AudioSystem.isLineSupported(info)) ) {\n+                if (Printer.err) Printer.err(\"Line not supported: \"+loadedAudioFormat);\n+                \/\/ fail silently\n+                return false;\n+            }\n+            SourceDataLine source = (SourceDataLine) AudioSystem.getLine(info);\n+            datapusher = new DataPusher(source, loadedAudioFormat, loadedAudio, loadedAudioByteLength, true);\n+            disposerRecord.setDataPusher(datapusher);\n+        } catch (Exception e) {\n+            if (Printer.err) e.printStackTrace();\n+            \/\/ fail silently\n+            return false;\n+        }\n+\n+        if (datapusher==null) {\n+            \/\/ fail silently\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private boolean createSequencer(BufferedInputStream in) throws IOException {\n+        \/\/ get the sequencer\n+        try {\n+            sequencer = MidiSystem.getSequencer( );\n+            disposerRecord.setSequencer(sequencer);\n+        } catch(MidiUnavailableException me) {\n+            if (Printer.err) me.printStackTrace();\n+            return false;\n+        }\n+        if (sequencer==null) {\n+            return false;\n+        }\n+\n+        try {\n+            sequence = MidiSystem.getSequence(in);\n+            if (sequence == null) {\n+                return false;\n+            }\n+        } catch (InvalidMidiDataException e) {\n+            if (Printer.err) e.printStackTrace();\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    \/*\n+     * private inner class representing a ByteArrayOutputStream\n+     * which allows retrieval of the internal array\n+     *\/\n+    private static class DirectBAOS extends ByteArrayOutputStream {\n+        DirectBAOS() {\n+            super();\n+        }\n+\n+        public byte[] getInternalBuffer() {\n+            return buf;\n+        }\n+\n+    } \/\/ class DirectBAOS\n+}\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/JavaSoundAudioClipDelegate.java","additions":455,"deletions":0,"binary":false,"changes":455,"status":"added"}]}