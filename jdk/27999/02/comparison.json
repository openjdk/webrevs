{"files":[{"patch":"@@ -917,5 +917,4 @@\n-            int blen = (coder == LATIN1) ? ae.encodeFromLatin1(val, 0, len, ba)\n-                    : ae.encodeFromUTF16(val, 0, len, ba);\n-            if (blen != -1) {\n-                return trimArray(ba, blen);\n-            }\n+            int blen = coder == LATIN1\n+                    ? ae.encodeFromLatin1(val, 0, len, ba, 0)\n+                    : ae.encodeFromUTF16(val, 0, len, ba, 0);\n+            return trimArray(ba, blen);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,4 @@\n-\/*\n- * FastPath char[]\/byte[] -> byte[] encoder, REPLACE on malformed input or\n- * unmappable input.\n+\/**\n+ * Fast-path for {@code byte[]}-to-{@code byte[]} encoding,\n+ * {@link java.nio.charset.CodingErrorAction#REPLACE REPLACE} on malformed\n+ * input, or unmappable input.\n@@ -32,1 +33,0 @@\n-\n@@ -35,2 +35,1 @@\n-    \/\/  is only used by j.u.zip.ZipCoder for utf8\n-    int encode(char[] src, int off, int len, byte[] dst);\n+    int encodeFromLatin1(byte[] src, int sp, int len, byte[] dst, int dp);\n@@ -38,3 +37,1 @@\n-    default int encodeFromLatin1(byte[] src, int sp, int len, byte[] dst) {\n-        return -1;\n-    }\n+    int encodeFromUTF16(byte[] src, int sp, int len, byte[] dst, int dp);\n@@ -42,3 +39,1 @@\n-    default int encodeFromUTF16(byte[] src, int sp, int len, byte[] dst) {\n-        return -1;\n-    }\n+    boolean isASCIICompatible();\n@@ -46,3 +41,0 @@\n-    default boolean isASCIICompatible() {\n-        return false;\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ArrayEncoder.java","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -397,2 +397,1 @@\n-    private static class Encoder extends CharsetEncoder\n-                                 implements ArrayEncoder {\n+    private static class Encoder extends CharsetEncoder {\n@@ -547,43 +546,0 @@\n-        \/\/ returns -1 if there is malformed char(s) and the\n-        \/\/ \"action\" for malformed input is not REPLACE.\n-        public int encode(char[] sa, int sp, int len, byte[] da) {\n-            int sl = sp + len;\n-            int dp = 0;\n-\n-            \/\/ Handle ASCII-only prefix\n-            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n-            sp += n;\n-            dp += n;\n-\n-            while (sp < sl) {\n-                char c = sa[sp++];\n-                if (c < 0x80) {\n-                    \/\/ Have at most seven bits\n-                    da[dp++] = (byte)c;\n-                } else if (c < 0x800) {\n-                    \/\/ 2 bytes, 11 bits\n-                    da[dp++] = (byte)(0xc0 | (c >> 6));\n-                    da[dp++] = (byte)(0x80 | (c & 0x3f));\n-                } else if (Character.isSurrogate(c)) {\n-                    if (sgp == null)\n-                        sgp = new Surrogate.Parser();\n-                    int uc = sgp.parse(c, sa, sp - 1, sl);\n-                    if (uc < 0) {\n-                        if (malformedInputAction() != CodingErrorAction.REPLACE)\n-                            return -1;\n-                        da[dp++] = replacement()[0];\n-                    } else {\n-                        to3Bytes(da, dp, Character.highSurrogate(uc));\n-                        dp += 3;\n-                        to3Bytes(da, dp, Character.lowSurrogate(uc));\n-                        dp += 3;\n-                        sp++;  \/\/ 2 chars\n-                    }\n-                } else {\n-                    \/\/ 3 bytes, 16 bits\n-                    to3Bytes(da, dp, c);\n-                    dp += 3;\n-                }\n-            }\n-            return dp;\n-        }\n@@ -591,0 +547,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/CESU_8.java","additions":2,"deletions":45,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -685,34 +685,1 @@\n-        public int encode(char[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n-            int sl = sp + len;\n-            if (isASCIICompatible) {\n-                int n = JLA.encodeASCII(src, sp, dst, dp, len);\n-                sp += n;\n-                dp += n;\n-            }\n-            while (sp < sl) {\n-                char c = src[sp++];\n-                int bb = encodeChar(c);\n-                if (bb == UNMAPPABLE_ENCODING) {\n-                    if (Character.isHighSurrogate(c) && sp < sl &&\n-                        Character.isLowSurrogate(src[sp])) {\n-                        sp++;\n-                    }\n-                    dst[dp++] = repl[0];\n-                    if (repl.length > 1)\n-                        dst[dp++] = repl[1];\n-                    continue;\n-                } \/\/else\n-                if (bb > MAX_SINGLEBYTE) { \/\/ DoubleByte\n-                    dst[dp++] = (byte)(bb >> 8);\n-                    dst[dp++] = (byte)bb;\n-                } else {                          \/\/ SingleByte\n-                    dst[dp++] = (byte)bb;\n-                }\n-            }\n-            return dp;\n-        }\n-\n-        @Override\n-        public int encodeFromLatin1(byte[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n+        public int encodeFromLatin1(byte[] src, int sp, int len, byte[] dst, int dp) {\n@@ -743,2 +710,1 @@\n-        public int encodeFromUTF16(byte[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n+        public int encodeFromUTF16(byte[] src, int sp, int len, byte[] dst, int dp) {\n@@ -1003,43 +969,1 @@\n-        public int encode(char[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n-            int sl = sp + len;\n-            while (sp < sl) {\n-                char c = src[sp++];\n-                int bb = encodeChar(c);\n-\n-                if (bb == UNMAPPABLE_ENCODING) {\n-                    if (Character.isHighSurrogate(c) && sp < sl &&\n-                        Character.isLowSurrogate(src[sp])) {\n-                        sp++;\n-                    }\n-                    dst[dp++] = repl[0];\n-                    if (repl.length > 1)\n-                        dst[dp++] = repl[1];\n-                    continue;\n-                } \/\/else\n-                if (bb > MAX_SINGLEBYTE) {           \/\/ DoubleByte\n-                    if (currentState == SBCS) {\n-                        currentState = DBCS;\n-                        dst[dp++] = SO;\n-                    }\n-                    dst[dp++] = (byte)(bb >> 8);\n-                    dst[dp++] = (byte)bb;\n-                } else {                             \/\/ SingleByte\n-                    if (currentState == DBCS) {\n-                         currentState = SBCS;\n-                         dst[dp++] = SI;\n-                    }\n-                    dst[dp++] = (byte)bb;\n-                }\n-            }\n-\n-            if (currentState == DBCS) {\n-                 currentState = SBCS;\n-                 dst[dp++] = SI;\n-            }\n-            return dp;\n-        }\n-\n-        @Override\n-        public int encodeFromLatin1(byte[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n+        public int encodeFromLatin1(byte[] src, int sp, int len, byte[] dst, int dp) {\n@@ -1080,2 +1004,1 @@\n-        public int encodeFromUTF16(byte[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n+        public int encodeFromUTF16(byte[] src, int sp, int len, byte[] dst, int dp) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":4,"deletions":81,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -355,29 +355,1 @@\n-        public int encode(char[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n-            int sl = sp + len;\n-            while (sp < sl) {\n-                char c = src[sp++];\n-                int bb = encodeChar(c);\n-                if (bb == UNMAPPABLE_ENCODING) {\n-                    if (!Character.isHighSurrogate(c) || sp == sl ||\n-                        !Character.isLowSurrogate(src[sp]) ||\n-                        (bb = encodeSupp(Character.toCodePoint(c, src[sp++])))\n-                        == UNMAPPABLE_ENCODING) {\n-                        dst[dp++] = repl[0];\n-                        if (repl.length > 1)\n-                            dst[dp++] = repl[1];\n-                        continue;\n-                    }\n-                }\n-                if (bb > MAX_SINGLEBYTE) {        \/\/ DoubleByte\n-                    dst[dp++] = (byte)(bb >> 8);\n-                    dst[dp++] = (byte)bb;\n-                } else {                          \/\/ SingleByte\n-                    dst[dp++] = (byte)bb;\n-                }\n-            }\n-            return dp;\n-        }\n-\n-        public int encodeFromUTF16(byte[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n+        public int encodeFromUTF16(byte[] src, int sp, int len, byte[] dst, int dp) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/HKSCS.java","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -293,23 +293,0 @@\n-        public int encode(char[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n-            int sl = sp + Math.min(len, dst.length);\n-            while (sp < sl) {\n-                char c = src[sp++];\n-                int b = encode(c);\n-                if (b != UNMAPPABLE_ENCODING) {\n-                    dst[dp++] = (byte)b;\n-                    continue;\n-                }\n-                if (Character.isHighSurrogate(c) && sp < sl &&\n-                    Character.isLowSurrogate(src[sp])) {\n-                    if (len > dst.length) {\n-                        sl++;\n-                        len--;\n-                    }\n-                    sp++;\n-                }\n-                dst[dp++] = repl;\n-            }\n-            return dp;\n-        }\n-\n@@ -317,2 +294,1 @@\n-        public int encodeFromLatin1(byte[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n+        public int encodeFromLatin1(byte[] src, int sp, int len, byte[] dst, int dp) {\n@@ -333,2 +309,1 @@\n-        public int encodeFromUTF16(byte[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n+        public int encodeFromUTF16(byte[] src, int sp, int len, byte[] dst, int dp) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":2,"deletions":27,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-     * ArrayEncoder#encodeFromLatin1(byte[], int, int, byte[])\n+     * ArrayEncoder#encodeFromLatin1(byte[], int, int, byte[], int)\n@@ -205,1 +205,1 @@\n-        int dp = arrayEncoder.encodeFromLatin1(sa, 0, 1, da);\n+        int dp = arrayEncoder.encodeFromLatin1(sa, 0, 1, da, 0);\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceLatin1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-     * ArrayEncoder#encodeFromUTF16(byte[], int, int, byte[])\n+     * ArrayEncoder#encodeFromUTF16(byte[], int, int, byte[], int)\n@@ -194,1 +194,1 @@\n-        int dp = arrayEncoder.encodeFromUTF16(unmappableUTF16Bytes, 0, unmappableUTF16Bytes.length >>> 1, da);\n+        int dp = arrayEncoder.encodeFromUTF16(unmappableUTF16Bytes, 0, unmappableUTF16Bytes.length >>> 1, da, 0);\n","filename":"test\/jdk\/sun\/nio\/cs\/TestEncoderReplaceUTF16.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -35,0 +36,4 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n@@ -198,9 +203,0 @@\n-            enc.replaceWith(new byte[] { (byte)'A'});\n-            sun.nio.cs.ArrayEncoder cae = (sun.nio.cs.ArrayEncoder)enc;\n-\n-            String str = \"ab\\uD800\\uDC00\\uD800\\uDC00cd\";\n-            byte[] ba = new byte[str.length() - 2];\n-            int n = cae.encode(str.toCharArray(), 0, str.length(), ba);\n-            if (n != 6 || !\"abAAcd\".equals(new String(ba, cs.name())))\n-                throw new RuntimeException(\"encode1(surrogates) failed  -> \"\n-                                           + cs.name());\n@@ -208,13 +204,63 @@\n-            ba = new byte[str.length()];\n-            n = cae.encode(str.toCharArray(), 0, str.length(), ba);\n-            if (n != 6 || !\"abAAcd\".equals(new String(ba, 0, n,\n-                                                     cs.name())))\n-                throw new RuntimeException(\"encode2(surrogates) failed  -> \"\n-                                           + cs.name());\n-            str = \"ab\\uD800B\\uDC00Bcd\";\n-            ba = new byte[str.length()];\n-            n = cae.encode(str.toCharArray(), 0, str.length(), ba);\n-            if (n != 8 || !\"abABABcd\".equals(new String(ba, 0, n,\n-                                                       cs.name())))\n-                throw new RuntimeException(\"encode3(surrogates) failed  -> \"\n-                                           + cs.name());\n+            \/\/ Configure the replacement sequence\n+            enc.replaceWith(new byte[]{(byte) 'A'});\n+\n+            \/\/ Test `String::new(byte[], Charset)` with surrogate-pair\n+            {\n+                var srcStr = \"ab\\uD800\\uDC00\\uD800\\uDC00cd\";\n+                assertEquals(8, srcStr.length());\n+                var srcBuf = CharBuffer.wrap(srcStr.toCharArray(), 0, 8);\n+                var dstBuf = ByteBuffer.allocate(6);\n+                var cr = enc.encode(srcBuf, dstBuf, true);\n+                if (cr.isError()) {\n+                    cr.throwException();\n+                }\n+                var dstArr = dstBuf.array();\n+                assertEquals(\n+                        6, dstBuf.position(),\n+                        \"Was expecting 6 items, found: \" + Map.of(\n+                                \"position\", dstBuf.position(),\n+                                \"array\", prettyPrintBytes(dstArr)));\n+                var dstStr = new String(dstArr, cs);\n+                assertEquals(\"abAAcd\", dstStr);\n+            }\n+\n+            \/\/ Test `String::new(byte[], int, int, Charset)` with surrogate-pair\n+            {\n+                var srcStr = \"ab\\uD800\\uDC00\\uD800\\uDC00cd\";\n+                assertEquals(8, srcStr.length());\n+                var srcBuf = CharBuffer.wrap(srcStr.toCharArray(), 0, 8);\n+                var dstBuf = ByteBuffer.allocate(8);\n+                var cr = enc.encode(srcBuf, dstBuf, true);\n+                if (cr.isError()) {\n+                    cr.throwException();\n+                }\n+                var dstArr = dstBuf.array();\n+                assertEquals(\n+                        6, dstBuf.position(),\n+                        \"Was expecting 6 items, found: \" + Map.of(\n+                                \"position\", dstBuf.position(),\n+                                \"array\", prettyPrintBytes(dstArr)));\n+                var dstStr = new String(dstArr, 0, 6, cs);\n+                assertEquals(\"abAAcd\", dstStr);\n+            }\n+\n+            \/\/ Test `String::new(byte[], int, int, Charset)` with a dangling\n+            \/\/ high- and low-surrogate\n+            {\n+                var srcStr = \"ab\\uD800B\\uDC00Bcd\";\n+                var srcBuf = CharBuffer.wrap(srcStr.toCharArray(), 0, 8);\n+                var dstBuf = ByteBuffer.allocate(8);\n+                var cr = enc.encode(srcBuf, dstBuf, true);\n+                if (cr.isError()) {\n+                    cr.throwException();\n+                }\n+                var dstArr = dstBuf.array();\n+                assertEquals(\n+                        8, dstBuf.position(),\n+                        \"Was expecting 8 items, found: \" + Map.of(\n+                                \"position\", dstBuf.position(),\n+                                \"array\", prettyPrintBytes(dstArr)));\n+                var dstStr = new String(dstArr, 0, 8, cs);\n+                assertEquals(\"abABABcd\", dstStr);\n+            }\n+\n@@ -245,0 +291,5 @@\n+\n+    private static String prettyPrintBytes(byte[] bs) {\n+        return \"[\" + HexFormat.ofDelimiter(\", \").withPrefix(\"0x\").formatHex(bs) + \"]\";\n+    }\n+\n","filename":"test\/jdk\/sun\/nio\/cs\/TestStringCoding.java","additions":74,"deletions":23,"binary":false,"changes":97,"status":"modified"}]}