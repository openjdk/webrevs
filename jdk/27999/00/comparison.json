{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,4 @@\n-\/*\n- * FastPath char[]\/byte[] -> byte[] encoder, REPLACE on malformed input or\n- * unmappable input.\n+\/**\n+ * Fast-path for {@code byte[]}-to-{@code byte[]} encoding,\n+ * {@link java.nio.charset.CodingErrorAction#REPLACE REPLACE} on malformed\n+ * input, or unmappable input.\n@@ -32,1 +33,0 @@\n-\n@@ -35,3 +35,0 @@\n-    \/\/  is only used by j.u.zip.ZipCoder for utf8\n-    int encode(char[] src, int off, int len, byte[] dst);\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ArrayEncoder.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -547,43 +547,0 @@\n-        \/\/ returns -1 if there is malformed char(s) and the\n-        \/\/ \"action\" for malformed input is not REPLACE.\n-        public int encode(char[] sa, int sp, int len, byte[] da) {\n-            int sl = sp + len;\n-            int dp = 0;\n-\n-            \/\/ Handle ASCII-only prefix\n-            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n-            sp += n;\n-            dp += n;\n-\n-            while (sp < sl) {\n-                char c = sa[sp++];\n-                if (c < 0x80) {\n-                    \/\/ Have at most seven bits\n-                    da[dp++] = (byte)c;\n-                } else if (c < 0x800) {\n-                    \/\/ 2 bytes, 11 bits\n-                    da[dp++] = (byte)(0xc0 | (c >> 6));\n-                    da[dp++] = (byte)(0x80 | (c & 0x3f));\n-                } else if (Character.isSurrogate(c)) {\n-                    if (sgp == null)\n-                        sgp = new Surrogate.Parser();\n-                    int uc = sgp.parse(c, sa, sp - 1, sl);\n-                    if (uc < 0) {\n-                        if (malformedInputAction() != CodingErrorAction.REPLACE)\n-                            return -1;\n-                        da[dp++] = replacement()[0];\n-                    } else {\n-                        to3Bytes(da, dp, Character.highSurrogate(uc));\n-                        dp += 3;\n-                        to3Bytes(da, dp, Character.lowSurrogate(uc));\n-                        dp += 3;\n-                        sp++;  \/\/ 2 chars\n-                    }\n-                } else {\n-                    \/\/ 3 bytes, 16 bits\n-                    to3Bytes(da, dp, c);\n-                    dp += 3;\n-                }\n-            }\n-            return dp;\n-        }\n@@ -591,0 +548,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/CESU_8.java","additions":1,"deletions":43,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -684,32 +684,0 @@\n-        @Override\n-        public int encode(char[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n-            int sl = sp + len;\n-            if (isASCIICompatible) {\n-                int n = JLA.encodeASCII(src, sp, dst, dp, len);\n-                sp += n;\n-                dp += n;\n-            }\n-            while (sp < sl) {\n-                char c = src[sp++];\n-                int bb = encodeChar(c);\n-                if (bb == UNMAPPABLE_ENCODING) {\n-                    if (Character.isHighSurrogate(c) && sp < sl &&\n-                        Character.isLowSurrogate(src[sp])) {\n-                        sp++;\n-                    }\n-                    dst[dp++] = repl[0];\n-                    if (repl.length > 1)\n-                        dst[dp++] = repl[1];\n-                    continue;\n-                } \/\/else\n-                if (bb > MAX_SINGLEBYTE) { \/\/ DoubleByte\n-                    dst[dp++] = (byte)(bb >> 8);\n-                    dst[dp++] = (byte)bb;\n-                } else {                          \/\/ SingleByte\n-                    dst[dp++] = (byte)bb;\n-                }\n-            }\n-            return dp;\n-        }\n-\n@@ -1002,41 +970,0 @@\n-        @Override\n-        public int encode(char[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n-            int sl = sp + len;\n-            while (sp < sl) {\n-                char c = src[sp++];\n-                int bb = encodeChar(c);\n-\n-                if (bb == UNMAPPABLE_ENCODING) {\n-                    if (Character.isHighSurrogate(c) && sp < sl &&\n-                        Character.isLowSurrogate(src[sp])) {\n-                        sp++;\n-                    }\n-                    dst[dp++] = repl[0];\n-                    if (repl.length > 1)\n-                        dst[dp++] = repl[1];\n-                    continue;\n-                } \/\/else\n-                if (bb > MAX_SINGLEBYTE) {           \/\/ DoubleByte\n-                    if (currentState == SBCS) {\n-                        currentState = DBCS;\n-                        dst[dp++] = SO;\n-                    }\n-                    dst[dp++] = (byte)(bb >> 8);\n-                    dst[dp++] = (byte)bb;\n-                } else {                             \/\/ SingleByte\n-                    if (currentState == DBCS) {\n-                         currentState = SBCS;\n-                         dst[dp++] = SI;\n-                    }\n-                    dst[dp++] = (byte)bb;\n-                }\n-            }\n-\n-            if (currentState == DBCS) {\n-                 currentState = SBCS;\n-                 dst[dp++] = SI;\n-            }\n-            return dp;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -355,27 +355,0 @@\n-        public int encode(char[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n-            int sl = sp + len;\n-            while (sp < sl) {\n-                char c = src[sp++];\n-                int bb = encodeChar(c);\n-                if (bb == UNMAPPABLE_ENCODING) {\n-                    if (!Character.isHighSurrogate(c) || sp == sl ||\n-                        !Character.isLowSurrogate(src[sp]) ||\n-                        (bb = encodeSupp(Character.toCodePoint(c, src[sp++])))\n-                        == UNMAPPABLE_ENCODING) {\n-                        dst[dp++] = repl[0];\n-                        if (repl.length > 1)\n-                            dst[dp++] = repl[1];\n-                        continue;\n-                    }\n-                }\n-                if (bb > MAX_SINGLEBYTE) {        \/\/ DoubleByte\n-                    dst[dp++] = (byte)(bb >> 8);\n-                    dst[dp++] = (byte)bb;\n-                } else {                          \/\/ SingleByte\n-                    dst[dp++] = (byte)bb;\n-                }\n-            }\n-            return dp;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/HKSCS.java","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -293,23 +293,0 @@\n-        public int encode(char[] src, int sp, int len, byte[] dst) {\n-            int dp = 0;\n-            int sl = sp + Math.min(len, dst.length);\n-            while (sp < sl) {\n-                char c = src[sp++];\n-                int b = encode(c);\n-                if (b != UNMAPPABLE_ENCODING) {\n-                    dst[dp++] = (byte)b;\n-                    continue;\n-                }\n-                if (Character.isHighSurrogate(c) && sp < sl &&\n-                    Character.isLowSurrogate(src[sp])) {\n-                    if (len > dst.length) {\n-                        sl++;\n-                        len--;\n-                    }\n-                    sp++;\n-                }\n-                dst[dp++] = repl;\n-            }\n-            return dp;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -35,0 +36,4 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n@@ -198,9 +203,0 @@\n-            enc.replaceWith(new byte[] { (byte)'A'});\n-            sun.nio.cs.ArrayEncoder cae = (sun.nio.cs.ArrayEncoder)enc;\n-\n-            String str = \"ab\\uD800\\uDC00\\uD800\\uDC00cd\";\n-            byte[] ba = new byte[str.length() - 2];\n-            int n = cae.encode(str.toCharArray(), 0, str.length(), ba);\n-            if (n != 6 || !\"abAAcd\".equals(new String(ba, cs.name())))\n-                throw new RuntimeException(\"encode1(surrogates) failed  -> \"\n-                                           + cs.name());\n@@ -208,13 +204,63 @@\n-            ba = new byte[str.length()];\n-            n = cae.encode(str.toCharArray(), 0, str.length(), ba);\n-            if (n != 6 || !\"abAAcd\".equals(new String(ba, 0, n,\n-                                                     cs.name())))\n-                throw new RuntimeException(\"encode2(surrogates) failed  -> \"\n-                                           + cs.name());\n-            str = \"ab\\uD800B\\uDC00Bcd\";\n-            ba = new byte[str.length()];\n-            n = cae.encode(str.toCharArray(), 0, str.length(), ba);\n-            if (n != 8 || !\"abABABcd\".equals(new String(ba, 0, n,\n-                                                       cs.name())))\n-                throw new RuntimeException(\"encode3(surrogates) failed  -> \"\n-                                           + cs.name());\n+            \/\/ Configure the replacement sequence\n+            enc.replaceWith(new byte[]{(byte) 'A'});\n+\n+            \/\/ Test `String::new(byte[], Charset)` with surrogate-pair\n+            {\n+                var srcStr = \"ab\\uD800\\uDC00\\uD800\\uDC00cd\";\n+                assertEquals(8, srcStr.length());\n+                var srcBuf = CharBuffer.wrap(srcStr.toCharArray(), 0, 8);\n+                var dstBuf = ByteBuffer.allocate(6);\n+                var cr = enc.encode(srcBuf, dstBuf, true);\n+                if (cr.isError()) {\n+                    cr.throwException();\n+                }\n+                var dstArr = dstBuf.array();\n+                assertEquals(\n+                        6, dstBuf.position(),\n+                        \"Was expecting 6 items, found: \" + Map.of(\n+                                \"position\", dstBuf.position(),\n+                                \"array\", prettyPrintBytes(dstArr)));\n+                var dstStr = new String(dstArr, cs);\n+                assertEquals(\"abAAcd\", dstStr);\n+            }\n+\n+            \/\/ Test `String::new(byte[], int, int, Charset)` with surrogate-pair\n+            {\n+                var srcStr = \"ab\\uD800\\uDC00\\uD800\\uDC00cd\";\n+                assertEquals(8, srcStr.length());\n+                var srcBuf = CharBuffer.wrap(srcStr.toCharArray(), 0, 8);\n+                var dstBuf = ByteBuffer.allocate(8);\n+                var cr = enc.encode(srcBuf, dstBuf, true);\n+                if (cr.isError()) {\n+                    cr.throwException();\n+                }\n+                var dstArr = dstBuf.array();\n+                assertEquals(\n+                        6, dstBuf.position(),\n+                        \"Was expecting 6 items, found: \" + Map.of(\n+                                \"position\", dstBuf.position(),\n+                                \"array\", prettyPrintBytes(dstArr)));\n+                var dstStr = new String(dstArr, 0, 6, cs);\n+                assertEquals(\"abAAcd\", dstStr);\n+            }\n+\n+            \/\/ Test `String::new(byte[], int, int, Charset)` with a dangling\n+            \/\/ high- and low-surrogate\n+            {\n+                var srcStr = \"ab\\uD800B\\uDC00Bcd\";\n+                var srcBuf = CharBuffer.wrap(srcStr.toCharArray(), 0, 8);\n+                var dstBuf = ByteBuffer.allocate(8);\n+                var cr = enc.encode(srcBuf, dstBuf, true);\n+                if (cr.isError()) {\n+                    cr.throwException();\n+                }\n+                var dstArr = dstBuf.array();\n+                assertEquals(\n+                        8, dstBuf.position(),\n+                        \"Was expecting 8 items, found: \" + Map.of(\n+                                \"position\", dstBuf.position(),\n+                                \"array\", prettyPrintBytes(dstArr)));\n+                var dstStr = new String(dstArr, 0, 8, cs);\n+                assertEquals(\"abABABcd\", dstStr);\n+            }\n+\n@@ -245,0 +291,7 @@\n+\n+    private static String prettyPrintBytes(byte[] bs) {\n+        return IntStream.range(0, bs.length)\n+                .mapToObj(i -> String.format(\"0x%02X\", bs[i] & 0xFF))\n+                .collect(Collectors.joining(\", \", \"[\", \"]\"));\n+    }\n+\n","filename":"test\/jdk\/sun\/nio\/cs\/TestStringCoding.java","additions":76,"deletions":23,"binary":false,"changes":99,"status":"modified"}]}