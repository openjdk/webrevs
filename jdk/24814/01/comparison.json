{"files":[{"patch":"@@ -42,4 +42,0 @@\n-size_t ZAllocatorEden::tlab_used() const {\n-  return _object_allocator.used();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-  size_t tlab_used() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,0 +136,5 @@\n+  \/\/ Set a small initial TLAB size to avoid depending on the current capacity\n+  if (FLAG_IS_DEFAULT(TLABSize)) {\n+    FLAG_SET_DEFAULT(TLABSize, 8*K);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  return _heap.max_tlab_size();\n+  return _heap.max_tlab_size() \/ HeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -840,0 +840,3 @@\n+  \/\/ Update TLAB usage\n+  ZHeap::heap()->update_tlab_usage(_page_allocator->used_eden());\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    _tlab_usage(InitialHeapSize),\n@@ -134,1 +135,1 @@\n-  return capacity();\n+  return _tlab_usage.capacity();\n@@ -138,1 +139,1 @@\n-  return _allocator_eden.tlab_used();\n+  return _tlab_usage.used();\n@@ -160,0 +161,13 @@\n+void ZHeap::update_tlab_usage(size_t used) {\n+  const size_t old_used = _tlab_usage.used();\n+  const size_t old_capacity = _tlab_usage.capacity();\n+\n+  _tlab_usage.update(used);\n+\n+  log_debug(gc, tlab)(\"TLAB usage update: used %zuM -> %zuM, capacity: %zuM -> %zuM\",\n+                      old_used \/ M,\n+                      _tlab_usage.used() \/ M,\n+                      old_capacity \/ M,\n+                      _tlab_usage.capacity() \/ M);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/z\/zTLABUsage.hpp\"\n@@ -58,0 +59,2 @@\n+  ZTLABUsage              _tlab_usage;\n+\n@@ -84,0 +87,1 @@\n+  void update_tlab_usage(size_t used);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-    _used(0),\n-    _undone(0),\n@@ -61,7 +59,1 @@\n-  ZPage* const page = ZHeap::heap()->alloc_page(type, size, flags, _age);\n-  if (page != nullptr) {\n-    \/\/ Increment used bytes\n-    Atomic::add(_used.addr(), size);\n-  }\n-\n-  return page;\n+  return ZHeap::heap()->alloc_page(type, size, flags, _age);\n@@ -75,3 +67,0 @@\n-  \/\/ Increment undone bytes\n-  Atomic::add(_undone.addr(), page->size());\n-\n@@ -232,17 +221,0 @@\n-size_t ZObjectAllocator::used() const {\n-  size_t total_used = 0;\n-  size_t total_undone = 0;\n-\n-  ZPerCPUConstIterator<size_t> iter_used(&_used);\n-  for (const size_t* cpu_used; iter_used.next(&cpu_used);) {\n-    total_used += *cpu_used;\n-  }\n-\n-  ZPerCPUConstIterator<size_t> iter_undone(&_undone);\n-  for (const size_t* cpu_undone; iter_undone.next(&cpu_undone);) {\n-    total_undone += *cpu_undone;\n-  }\n-\n-  return total_used - total_undone;\n-}\n-\n@@ -263,4 +235,0 @@\n-  \/\/ Reset used and undone bytes\n-  _used.set_all(0);\n-  _undone.set_all(0);\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":1,"deletions":33,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-  ZPerCPU<size_t>    _used;\n-  ZPerCPU<size_t>    _undone;\n@@ -83,1 +81,0 @@\n-  size_t used() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1267,0 +1267,1 @@\n+    _used_eden(0),\n@@ -1357,0 +1358,4 @@\n+size_t ZPageAllocator::used_eden() const {\n+  return Atomic::load(&_used_eden);\n+}\n+\n@@ -1417,0 +1422,1 @@\n+  \/\/ Update per-collection statistics\n@@ -1418,0 +1424,5 @@\n+\n+  \/\/ Clear eden statistics\n+  reset_used_eden();\n+\n+  \/\/ Return the collected statistics\n@@ -2080,0 +2091,5 @@\n+  const size_t size = allocation->size();\n+  const ZPageType type = allocation->type();\n+  const ZPageAge age = allocation->age();\n+  const ZGenerationId id = age == ZPageAge::old ? ZGenerationId::old : ZGenerationId::young;\n+\n@@ -2084,1 +2100,1 @@\n-  \/\/ the generation statistics could se a decreasing used value between mark\n+  \/\/ the generation statistics could see a decreasing used value between mark\n@@ -2087,5 +2103,4 @@\n-  const ZGenerationId id = allocation->age() == ZPageAge::old ? ZGenerationId::old : ZGenerationId::young;\n-  increase_used_generation(id, allocation->size());\n-\n-  const ZPageType type = allocation->type();\n-  const ZPageAge age = allocation->age();\n+  increase_used_generation(id, size);\n+  if (age == ZPageAge::eden) {\n+    increase_used_eden(size);\n+  }\n@@ -2265,0 +2280,10 @@\n+void ZPageAllocator::increase_used_eden(size_t size) {\n+  \/\/ Update atomically since we have concurrent readers and writers\n+  Atomic::add(&_used_eden, size, memory_order_relaxed);\n+}\n+\n+void ZPageAllocator::reset_used_eden() {\n+  \/\/ Reset atomically since we have concurrent readers and writers\n+  Atomic::store(&_used_eden, (size_t) 0);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":31,"deletions":6,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -162,0 +162,1 @@\n+  volatile size_t             _used_eden;\n@@ -235,0 +236,3 @@\n+  void increase_used_eden(size_t size);\n+  void reset_used_eden();\n+\n@@ -259,0 +263,1 @@\n+  size_t used_eden() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"gc\/z\/zTLABUsage.hpp\"\n+\n+ZTLABUsage::ZTLABUsage(size_t initial_heap_size)\n+  : _used_history() {\n+    \/\/ To get reasonable values for used and capacity until the first GC\n+    \/\/ we populate the used history with the initial heap size.\n+    _used_history.add(initial_heap_size);\n+  }\n+\n+void ZTLABUsage::update(size_t used) {\n+  if (used == 0) {\n+    \/\/ Avoid updates for the second young generation collection of a SystemGC\n+    return;\n+  }\n+  _used_history.add(used);\n+}\n+\n+size_t ZTLABUsage::used() const {\n+  return _used_history.last();\n+}\n+\n+size_t ZTLABUsage::capacity() const {\n+  return _used_history.davg();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zTLABUsage.cpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_Z_ZTLABUSAGE_HPP\n+#define SHARE_GC_Z_ZTLABUSAGE_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+\n+\/\/ ZGC is retiring TLABs concurrently with the application running when\n+\/\/ processing the stack watermarks. For the common TLAB heuristic to work we\n+\/\/ need to return consistent TLAB usage information when a TLAB is retired.\n+\/\/ We snapshot the TLAB usage in the mark start pause for the young generation\n+\/\/ and use this information until the next garbage collection cycle.\n+\/\/\n+\/\/ ZGC does not have set generation sizes unlike most other GCs and because of\n+\/\/ this there is no fixed TLAB capacity. For the common TLAB sizing heuristic\n+\/\/ to work properly ZGC estimates the current capacity by using a weighted\n+\/\/ average of the last 10 used values.\n+\n+class ZTLABUsage {\n+private:\n+  TruncatedSeq _used_history;\n+\n+public:\n+  ZTLABUsage(size_t initial_heap_size);\n+\n+  void update(size_t used);\n+\n+  size_t used() const;\n+  size_t capacity() const;\n+};\n+\n+#endif \/\/ SHARE_GC_Z_ZTLABUSAGE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zTLABUsage.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"}]}