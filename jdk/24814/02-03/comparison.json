{"files":[{"patch":"@@ -136,1 +136,1 @@\n-  \/\/ Set a small initial TLAB size to avoid depending on the current capacity\n+  \/\/ Set an initial TLAB size to avoid depending on the current capacity\n@@ -138,1 +138,1 @@\n-    FLAG_SET_DEFAULT(TLABSize, 8*K);\n+    FLAG_SET_DEFAULT(TLABSize, 256*K);\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -160,5 +160,0 @@\n-\n-void ZHeap::increment_tlab_used() {\n-  _tlab_usage.add(ZPageSizeSmall);\n-}\n-\n@@ -231,0 +226,24 @@\n+static bool is_small_eden_page(ZPage* page) {\n+  return page->type() == ZPageType::small && page->age() == ZPageAge::eden;\n+}\n+\n+void ZHeap::account_alloc_page(ZPage* page) {\n+  \/\/ Do TLAB accounting for small eden pages\n+  if (is_small_eden_page(page)) {\n+    _tlab_usage.increase_used(page->size());\n+  }\n+}\n+\n+void ZHeap::account_undo_alloc_page(ZPage* page) {\n+  \/\/ Increase the undo counter\n+  ZStatInc(ZCounterUndoPageAllocation);\n+\n+  \/\/ Undo TLAB accounting for small eden pages\n+  if (is_small_eden_page(page)) {\n+    _tlab_usage.decrease_used(page->size());\n+  }\n+\n+  log_trace(gc)(\"Undo page allocation, thread: \" PTR_FORMAT \" (%s), page: \" PTR_FORMAT \", size: %zu\",\n+                p2i(Thread::current()), ZUtils::thread_name(), p2i(page), page->size());\n+}\n+\n@@ -236,0 +255,3 @@\n+\n+    \/\/ Do accounting for the allocated page\n+    account_alloc_page(page);\n@@ -244,3 +266,2 @@\n-  ZStatInc(ZCounterUndoPageAllocation);\n-  log_trace(gc)(\"Undo page allocation, thread: \" PTR_FORMAT \" (%s), page: \" PTR_FORMAT \", size: %zu\",\n-                p2i(Thread::current()), ZUtils::thread_name(), p2i(page), page->size());\n+  \/\/ Undo accounting for the page being freed\n+  account_undo_alloc_page(page);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -63,0 +63,4 @@\n+  \/\/ Page allocation accounting\n+  void account_alloc_page(ZPage* page);\n+  void account_undo_alloc_page(ZPage* page);\n+\n@@ -87,2 +91,0 @@\n-\n-  void increment_tlab_used();\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -112,6 +112,0 @@\n-      } else {\n-        \/\/ Page successfully installed\n-        if (_age == ZPageAge::eden && page_type == ZPageType::small) {\n-          \/\/ Increment TLAB usage for small eden pages\n-          ZHeap::heap()->increment_tlab_used();\n-        }\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-void ZTLABUsage::add(size_t size) {\n+void ZTLABUsage::increase_used(size_t size) {\n@@ -37,0 +37,5 @@\n+void ZTLABUsage::decrease_used(size_t size) {\n+  precond(size <= _used);\n+  Atomic::sub(&_used, size, memory_order_relaxed);\n+}\n+\n@@ -38,1 +43,1 @@\n-  size_t current_used = Atomic::xchg(&_used, (size_t) 0);\n+  const size_t current_used = Atomic::xchg(&_used, (size_t) 0);\n@@ -46,2 +51,2 @@\n-  size_t old_used = used();\n-  size_t old_capacity = capacity();\n+  const size_t old_used = used();\n+  const size_t old_capacity = capacity();\n","filename":"src\/hotspot\/share\/gc\/z\/zTLABUsage.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-  void add(size_t size);\n+  void increase_used(size_t size);\n+  void decrease_used(size_t size);\n","filename":"src\/hotspot\/share\/gc\/z\/zTLABUsage.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}