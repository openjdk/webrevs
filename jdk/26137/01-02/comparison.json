{"files":[{"patch":"@@ -94,1 +94,0 @@\n-import java.net.URI;\n@@ -103,0 +102,1 @@\n+import java.nio.file.ProviderNotFoundException;\n@@ -2000,7 +2000,16 @@\n-            Collection<Path> paths = new ArrayList<>();\n-            MemoryFileManager fm = proc.taskFactory.configuredFileManager();\n-\n-            appendPaths(fm, StandardLocation.PLATFORM_CLASS_PATH, paths);\n-            appendPaths(fm, StandardLocation.CLASS_PATH, paths);\n-            appendPaths(fm, StandardLocation.SOURCE_PATH, paths);\n-            appendModulePaths(fm, StandardLocation.MODULE_PATH, paths);\n+            Collection<Path> paths = proc.taskFactory.parse(\"\", task -> {\n+                MemoryFileManager fm = proc.taskFactory.fileManager();\n+                Collection<Path> _paths = new ArrayList<>();\n+                try {\n+                    appendPaths(fm, StandardLocation.PLATFORM_CLASS_PATH, _paths);\n+                    appendPaths(fm, StandardLocation.CLASS_PATH, _paths);\n+                    appendPaths(fm, StandardLocation.SOURCE_PATH, _paths);\n+                    appendModulePaths(fm, StandardLocation.SYSTEM_MODULES, _paths);\n+                    appendModulePaths(fm, StandardLocation.UPGRADE_MODULE_PATH, _paths);\n+                    appendModulePaths(fm, StandardLocation.MODULE_PATH, _paths);\n+                    return _paths;\n+                } catch (Exception ex) {\n+                    proc.debug(ex, \"SourceCodeAnalysisImpl.refreshIndexes(\" + version + \")\");\n+                    return List.of();\n+                }\n+            });\n@@ -2059,10 +2068,7 @@\n-    private void appendModulePaths(MemoryFileManager fm, Location loc, Collection<Path> paths) {\n-        Iterable<? extends Path> locationPaths = fm.getLocationAsPaths(loc);\n-        if (locationPaths == null)\n-            return ;\n-        for (Path path : locationPaths) {\n-            if (Files.isDirectory(path) && !Files.exists(path.resolve(\"module-info.class\"))) {\n-                try (var ds = Files.newDirectoryStream(path)) {\n-                    ds.forEach(paths::add);\n-                } catch (IOException ex) {\n-                    proc.debug(ex, \"appendModulePaths: \" + path);\n+    private void appendModulePaths(MemoryFileManager fm, Location loc, Collection<Path> paths) throws IOException {\n+        for (Set<Location> moduleLocations : fm.listLocationsForModules(loc)) {\n+            for (Location moduleLocation : moduleLocations) {\n+                Iterable<? extends Path> modulePaths = fm.getLocationAsPaths(moduleLocation);\n+\n+                if (modulePaths == null) {\n+                    continue;\n@@ -2070,2 +2076,2 @@\n-            } else {\n-                paths.add(path);\n+\n+                modulePaths.forEach(paths::add);\n@@ -2079,18 +2085,1 @@\n-        if (isJRTMarkerFile(path)) {\n-            FileSystem jrtfs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n-            Path modules = jrtfs.getPath(\"modules\");\n-            return PATH_TO_INDEX.compute(path, (p, index) -> {\n-                try {\n-                    long lastModified = Files.getLastModifiedTime(modules).toMillis();\n-                    if (index == null || index.timestamp != lastModified) {\n-                        try (DirectoryStream<Path> stream = Files.newDirectoryStream(modules)) {\n-                            index = doIndex(lastModified, path, stream);\n-                        }\n-                    }\n-                    return index;\n-                } catch (IOException ex) {\n-                    proc.debug(ex, \"SourceCodeAnalysisImpl.indexesForPath(\" + path.toString() + \")\");\n-                    return new ClassIndex(-1, path, Collections.emptySet(), Collections.emptyMap());\n-                }\n-            });\n-        } else if (!Files.isDirectory(path)) {\n+        if (!Files.isDirectory(path)) {\n@@ -2109,1 +2098,1 @@\n-                    } catch (IOException ex) {\n+                    } catch (IOException | ProviderNotFoundException ex) {\n@@ -2128,4 +2117,0 @@\n-    static boolean isJRTMarkerFile(Path path) {\n-        return path.equals(Paths.get(System.getProperty(\"java.home\"), \"lib\", \"modules\"));\n-    }\n-\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":28,"deletions":43,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -141,5 +141,0 @@\n-    MemoryFileManager configuredFileManager() {\n-        parse(\"\", _ -> null);\n-        return fileManager;\n-    }\n-\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TaskFactory.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -203,0 +203,54 @@\n+\n+    @Test\n+    public void testUpgradeModulePathIndexing() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                module m {\n+                    exports p1.p2;\n+                    exports p1.p3;\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"-C--upgrade-module-path\", \"-C\" + compiler.getPath(p1.resolve(jarName)).toString()},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n+\n+    @Test\n+    public void testBootClassPathPrepend() {\n+        Path p1 = outDir.resolve(\"dir1\");\n+        compiler.compile(p1,\n+                \"\"\"\n+                package p1.p2;\n+                public class Test {\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package p1.p3;\n+                public class Test {\n+                }\n+                \"\"\");\n+        String jarName = \"test.jar\";\n+        compiler.jar(p1, jarName, \"p1\/p2\/Test.class\", \"p1\/p3\/Test.class\");\n+\n+        test(false, new String[]{\"--no-startup\", \"-C-Xbootclasspath\/p:\" + compiler.getPath(p1.resolve(jarName)).toString(), \"-C--source=8\"},\n+                (a) -> assertCompletions(a, \"p1.\", \".*p2\\\\..*p3\\\\..*\"),\n+                 \/\/cancel the input, so that JShell can be finished:\n+                (a) -> assertCommand(a, \"\\003\", null)\n+                );\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/ToolCompletionTest.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"}]}