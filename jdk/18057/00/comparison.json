{"files":[{"patch":"@@ -1051,136 +1051,0 @@\n-HeapWord*\n-PSParallelCompact::compute_dense_prefix_via_density(const SpaceId id,\n-                                                    bool maximum_compaction)\n-{\n-  const size_t region_size = ParallelCompactData::RegionSize;\n-  const ParallelCompactData& sd = summary_data();\n-\n-  const MutableSpace* const space = _space_info[id].space();\n-  HeapWord* const top_aligned_up = sd.region_align_up(space->top());\n-  const RegionData* const beg_cp = sd.addr_to_region_ptr(space->bottom());\n-  const RegionData* const end_cp = sd.addr_to_region_ptr(top_aligned_up);\n-\n-  \/\/ Skip full regions at the beginning of the space--they are necessarily part\n-  \/\/ of the dense prefix.\n-  size_t full_count = 0;\n-  const RegionData* cp;\n-  for (cp = beg_cp; cp < end_cp && cp->data_size() == region_size; ++cp) {\n-    ++full_count;\n-  }\n-\n-  const uint total_invocations = ParallelScavengeHeap::heap()->total_full_collections();\n-  assert(total_invocations >= _maximum_compaction_gc_num, \"sanity\");\n-  const size_t gcs_since_max = total_invocations - _maximum_compaction_gc_num;\n-  const bool interval_ended = gcs_since_max > HeapMaximumCompactionInterval;\n-  if (maximum_compaction || cp == end_cp || interval_ended) {\n-    _maximum_compaction_gc_num = total_invocations;\n-    return sd.region_to_addr(cp);\n-  }\n-\n-  HeapWord* const new_top = _space_info[id].new_top();\n-  const size_t space_live = pointer_delta(new_top, space->bottom());\n-  const size_t space_used = space->used_in_words();\n-  const size_t space_capacity = space->capacity_in_words();\n-\n-  const double cur_density = double(space_live) \/ space_capacity;\n-  const double deadwood_density =\n-    (1.0 - cur_density) * (1.0 - cur_density) * cur_density * cur_density;\n-  const size_t deadwood_goal = size_t(space_capacity * deadwood_density);\n-\n-  log_develop_debug(gc, compaction)(\n-      \"cur_dens=%5.3f dw_dens=%5.3f dw_goal=\" SIZE_FORMAT,\n-      cur_density, deadwood_density, deadwood_goal);\n-  log_develop_debug(gc, compaction)(\n-      \"space_live=\" SIZE_FORMAT \" space_used=\" SIZE_FORMAT \" \"\n-      \"space_cap=\" SIZE_FORMAT,\n-      space_live, space_used,\n-      space_capacity);\n-\n-  \/\/ XXX - Use binary search?\n-  HeapWord* dense_prefix = sd.region_to_addr(cp);\n-  const RegionData* full_cp = cp;\n-  const RegionData* const top_cp = sd.addr_to_region_ptr(space->top() - 1);\n-  while (cp < end_cp) {\n-    HeapWord* region_destination = cp->destination();\n-    const size_t cur_deadwood = pointer_delta(dense_prefix, region_destination);\n-\n-    log_develop_trace(gc, compaction)(\n-        \"c#=\" SIZE_FORMAT_W(4) \" dst=\" PTR_FORMAT \" \"\n-        \"dp=\" PTR_FORMAT \" cdw=\" SIZE_FORMAT_W(8),\n-        sd.region(cp), p2i(region_destination),\n-        p2i(dense_prefix), cur_deadwood);\n-\n-    if (cur_deadwood >= deadwood_goal) {\n-      \/\/ Found the region that has the correct amount of deadwood to the left.\n-      \/\/ This typically occurs after crossing a fairly sparse set of regions, so\n-      \/\/ iterate backwards over those sparse regions, looking for the region\n-      \/\/ that has the lowest density of live objects 'to the right.'\n-      size_t space_to_left = sd.region(cp) * region_size;\n-      size_t live_to_left = space_to_left - cur_deadwood;\n-      size_t space_to_right = space_capacity - space_to_left;\n-      size_t live_to_right = space_live - live_to_left;\n-      double density_to_right = double(live_to_right) \/ space_to_right;\n-      while (cp > full_cp) {\n-        --cp;\n-        const size_t prev_region_live_to_right = live_to_right -\n-          cp->data_size();\n-        const size_t prev_region_space_to_right = space_to_right + region_size;\n-        double prev_region_density_to_right =\n-          double(prev_region_live_to_right) \/ prev_region_space_to_right;\n-        if (density_to_right <= prev_region_density_to_right) {\n-          return dense_prefix;\n-        }\n-\n-        log_develop_trace(gc, compaction)(\n-            \"backing up from c=\" SIZE_FORMAT_W(4) \" d2r=%10.8f \"\n-            \"pc_d2r=%10.8f\",\n-            sd.region(cp), density_to_right,\n-            prev_region_density_to_right);\n-\n-        dense_prefix -= region_size;\n-        live_to_right = prev_region_live_to_right;\n-        space_to_right = prev_region_space_to_right;\n-        density_to_right = prev_region_density_to_right;\n-      }\n-      return dense_prefix;\n-    }\n-\n-    dense_prefix += region_size;\n-    ++cp;\n-  }\n-\n-  return dense_prefix;\n-}\n-\n-#ifndef PRODUCT\n-void PSParallelCompact::print_dense_prefix_stats(const char* const algorithm,\n-                                                 const SpaceId id,\n-                                                 const bool maximum_compaction,\n-                                                 HeapWord* const addr)\n-{\n-  const size_t region_idx = summary_data().addr_to_region_idx(addr);\n-  RegionData* const cp = summary_data().region(region_idx);\n-  const MutableSpace* const space = _space_info[id].space();\n-  HeapWord* const new_top = _space_info[id].new_top();\n-\n-  const size_t space_live = pointer_delta(new_top, space->bottom());\n-  const size_t dead_to_left = pointer_delta(addr, cp->destination());\n-  const size_t space_cap = space->capacity_in_words();\n-  const double dead_to_left_pct = double(dead_to_left) \/ space_cap;\n-  const size_t live_to_right = new_top - cp->destination();\n-  const size_t dead_to_right = space->top() - addr - live_to_right;\n-\n-  log_develop_debug(gc, compaction)(\n-      \"%s=\" PTR_FORMAT \" dpc=\" SIZE_FORMAT_W(5) \" \"\n-      \"spl=\" SIZE_FORMAT \" \"\n-      \"d2l=\" SIZE_FORMAT \" d2l%%=%6.4f \"\n-      \"d2r=\" SIZE_FORMAT \" l2r=\" SIZE_FORMAT \" \"\n-      \"ratio=%10.8f\",\n-      algorithm, p2i(addr), region_idx,\n-      space_live,\n-      dead_to_left, dead_to_left_pct,\n-      dead_to_right, live_to_right,\n-      double(dead_to_right) \/ live_to_right);\n-}\n-#endif  \/\/ #ifndef PRODUCT\n-\n@@ -1514,9 +1378,0 @@\n-#ifndef PRODUCT\n-    if (log_is_enabled(Debug, gc, compaction)) {\n-      print_dense_prefix_stats(\"ratio\", id, maximum_compaction,\n-                               dense_prefix_end);\n-      HeapWord* addr = compute_dense_prefix_via_density(id, maximum_compaction);\n-      print_dense_prefix_stats(\"density\", id, maximum_compaction, addr);\n-    }\n-#endif  \/\/ #ifndef PRODUCT\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":0,"deletions":145,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -978,5 +978,0 @@\n-  \/\/ Compute the dense prefix for the designated space.  This is an experimental\n-  \/\/ implementation currently not used in production.\n-  static HeapWord* compute_dense_prefix_via_density(const SpaceId id,\n-                                                    bool maximum_compaction);\n-\n@@ -1173,4 +1168,0 @@\n-  static void print_dense_prefix_stats(const char* const algorithm,\n-                                       const SpaceId id,\n-                                       const bool maximum_compaction,\n-                                       HeapWord* const addr);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"}]}