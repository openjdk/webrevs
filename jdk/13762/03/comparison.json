{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import sun.security.util.Debug;\n@@ -163,0 +164,54 @@\n+\n+    \/**\n+     * Convenience method for fetching System property values that are timeouts.\n+     * Accepted timeout values may be purely numeric, a numeric value\n+     * followed by \"s\" (both interpreted as seconds), or a numeric value\n+     * followed by \"ms\" (interpreted as milliseconds).\n+     *\n+     * @param prop the name of the System property\n+     * @param def a default value (in milliseconds)\n+     * @param dbg a Debug object, if null no debug messages will be sent\n+     *\n+     * @return an integer value corresponding to the timeout value in the System\n+     *      property in milliseconds.  If the property value is empty, negative,\n+     *      or contains non-numeric characters (besides a trailing \"s\" or \"ms\")\n+     *      then the default value will be returned.  If a negative value for\n+     *      the \"def\" parameter is supplied, zero will be returned if the\n+     *      property's value does not conform to the allowed syntax.\n+     *\/\n+    public static int privilegedGetTimeoutProp(String prop, int def, Debug dbg) {\n+        if (def < 0) {\n+            def = 0;\n+        }\n+\n+        String propVal = privilegedGetProperty(prop, \"\").trim();\n+        if (propVal.length() == 0) {\n+            return def;\n+        }\n+\n+        \/\/ Determine if \"ms\" or just \"s\" is on the end of the string\n+        boolean isMillis = false;\n+        if (propVal.toLowerCase().endsWith(\"ms\")) {\n+            propVal = propVal.substring(0, propVal.length() - 2);\n+            isMillis = true;\n+        } else if (propVal.toLowerCase().endsWith(\"s\")) {\n+            propVal = propVal.substring(0, propVal.length() - 1);\n+        }\n+\n+        \/\/ Next check to make sure the string is built only from digits\n+        if (propVal.matches(\"^\\\\d+$\")) {\n+            try {\n+                int timeout = Integer.parseInt(propVal);\n+                return isMillis ? timeout : timeout * 1000;\n+            } catch (NumberFormatException nfe) {\n+                if (dbg != null) {\n+                    dbg.println(\"Warning: Unexpected \" + nfe +\n+                            \" for timeout value \" + propVal +\n+                            \". Using default value of \" + def + \" msec.\");\n+                }\n+                return def;\n+            }\n+        } else {\n+            return def;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/action\/GetPropertyAction.java","additions":56,"deletions":1,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -29,4 +29,1 @@\n-import java.net.URI;\n-import java.net.URL;\n-import java.net.HttpURLConnection;\n-import java.net.URLEncoder;\n+import java.net.*;\n@@ -44,1 +41,1 @@\n-import sun.security.action.GetIntegerAction;\n+import sun.security.action.GetPropertyAction;\n@@ -73,0 +70,1 @@\n+    private static final int DEFAULT_READ_TIMEOUT = 15000;\n@@ -75,3 +73,3 @@\n-     * Integer value indicating the timeout length, in seconds, to be\n-     * used for the OCSP check. A timeout of zero is interpreted as\n-     * an infinite timeout.\n+     * Integer value indicating the timeout length, in milliseconds, to be\n+     * used for establishing a connection to an OCSP responder. A timeout of\n+     * zero is interpreted as an infinite timeout.\n@@ -79,1 +77,10 @@\n-    private static final int CONNECT_TIMEOUT = initializeTimeout();\n+    private static final int CONNECT_TIMEOUT = initializeTimeout(\n+            \"com.sun.security.ocsp.timeout\", DEFAULT_CONNECT_TIMEOUT);\n+\n+    \/**\n+     * Integer value indicating the timeout length, in milliseconds, to be\n+     * used for reading an OCSP response from the responder.  A timeout of\n+     * zero is interpreted as an infinite timeout.\n+     *\/\n+    private static final int READ_TIMEOUT = initializeTimeout(\n+            \"com.sun.security.ocsp.readtimeout\", DEFAULT_READ_TIMEOUT);\n@@ -86,6 +93,5 @@\n-    private static int initializeTimeout() {\n-        @SuppressWarnings(\"removal\")\n-        Integer tmp = java.security.AccessController.doPrivileged(\n-                new GetIntegerAction(\"com.sun.security.ocsp.timeout\"));\n-        if (tmp == null || tmp < 0) {\n-            return DEFAULT_CONNECT_TIMEOUT;\n+    private static int initializeTimeout(String prop, int def) {\n+        int timeoutVal =\n+                GetPropertyAction.privilegedGetTimeoutProp(prop, def, debug);\n+        if (debug != null) {\n+            debug.println(prop + \" set to \" + timeoutVal + \" milliseconds\");\n@@ -93,3 +99,1 @@\n-        \/\/ Convert to milliseconds, as the system property will be\n-        \/\/ specified in seconds\n-        return tmp * 1000;\n+        return timeoutVal;\n@@ -186,2 +190,1 @@\n-                @SuppressWarnings(\"deprecation\")\n-                var _unused = url = new URL(encodedGetReq.toString());\n+                url = new URI(encodedGetReq.toString()).toURL();\n@@ -189,0 +192,2 @@\n+                con.setConnectTimeout(CONNECT_TIMEOUT);\n+                con.setReadTimeout(READ_TIMEOUT);\n@@ -196,1 +201,1 @@\n-                con.setReadTimeout(CONNECT_TIMEOUT);\n+                con.setReadTimeout(READ_TIMEOUT);\n@@ -226,0 +231,2 @@\n+        } catch (URISyntaxException urise) {\n+            throw new IOException(urise);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSP.java","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,2 @@\n-import sun.security.action.GetIntegerAction;\n+\n+import sun.security.action.GetPropertyAction;\n@@ -130,0 +131,4 @@\n+    \/\/ Default connect and read timeouts for CA certificate fetching (15 sec)\n+    private static final int DEFAULT_CACERT_CONNECT_TIMEOUT = 15000;\n+    private static final int DEFAULT_CACERT_READ_TIMEOUT = 15000;\n+\n@@ -131,1 +136,1 @@\n-     * Integer value indicating the connect timeout, in seconds, to be\n+     * Integer value indicating the connect timeout, in milliseconds, to be\n@@ -140,1 +145,1 @@\n-     * Integer value indicating the read timeout, in seconds, to be\n+     * Integer value indicating the read timeout, in milliseconds, to be\n@@ -148,0 +153,18 @@\n+    \/**\n+     * Integer value indicating the connect timeout, in milliseconds, to be\n+     * used for the CA certificate download. A timeout of zero is interpreted\n+     * as an infinite timeout.\n+     *\/\n+    private static final int CACERT_CONNECT_TIMEOUT =\n+            initializeTimeout(\"com.sun.security.cert.timeout\",\n+                    DEFAULT_CACERT_CONNECT_TIMEOUT);\n+\n+    \/**\n+     * Integer value indicating the read timeout, in milliseconds, to be\n+     * used for the CA certificate download. A timeout of zero is interpreted\n+     * as an infinite timeout.\n+     *\/\n+    private static final int CACERT_READ_TIMEOUT =\n+            initializeTimeout(\"com.sun.security.cert.readtimeout\",\n+                    DEFAULT_CACERT_READ_TIMEOUT);\n+\n@@ -154,4 +177,2 @@\n-        Integer tmp = GetIntegerAction.privilegedGetProperty(prop);\n-        if (tmp == null || tmp < 0) {\n-            return def;\n-        }\n+        int timeoutVal =\n+                GetPropertyAction.privilegedGetTimeoutProp(prop, def, debug);\n@@ -159,1 +180,1 @@\n-            debug.println(prop + \" set to \" + tmp + \" seconds\");\n+            debug.println(prop + \" set to \" + timeoutVal + \" milliseconds\");\n@@ -161,3 +182,1 @@\n-        \/\/ Convert to milliseconds, as the system property will be\n-        \/\/ specified in seconds\n-        return tmp * 1000;\n+        return timeoutVal;\n@@ -279,0 +298,2 @@\n+            connection.setConnectTimeout(CACERT_CONNECT_TIMEOUT);\n+            connection.setReadTimeout(CACERT_READ_TIMEOUT);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/URICertStore.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ Security properties, once set, cannot revert to unset.  To avoid\n+\/\/ conflicts with tests running in the same VM isolate this test by\n+\/\/ running it in otherVM mode.\n+\/\/\n+\n+\/**\n+ * @test\n+ * @bug 8179502\n+ * @summary Enhance OCSP, CRL and Certificate Fetch Timeouts\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.provider.certpath\n+ *          java.base\/sun.security.util\n+ * @library ..\/..\/..\/..\/..\/java\/security\/testlibrary\n+ * @build CertificateBuilder SimpleOCSPServer\n+ * @run main\/othervm OCSPTimeout 1000 true\n+ * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=2\n+ *      OCSPTimeout 1000 true\n+ * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=1\n+ *      OCSPTimeout 2000 false\n+ * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=1s\n+ *      OCSPTimeout 2000 false\n+ * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=1500ms\n+ *      OCSPTimeout 2000 false\n+ * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=2750ms\n+ *      OCSPTimeout 2000 true\n+ *\/\n+\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.net.*;\n+import java.security.*;\n+import java.security.cert.Certificate;\n+import java.security.spec.ECGenParameterSpec;\n+import java.util.*;\n+import java.security.cert.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import sun.security.testlibrary.SimpleOCSPServer;\n+import sun.security.testlibrary.CertificateBuilder;\n+\n+import static java.security.cert.PKIXRevocationChecker.Option.*;\n+\n+public class OCSPTimeout {\n+\n+    static String passwd = \"passphrase\";\n+    static String ROOT_ALIAS = \"root\";\n+    static String EE_ALIAS = \"endentity\";\n+\n+    \/\/ Enable debugging for additional output\n+    static final boolean debug = true;\n+\n+    \/\/ PKI components we will need for this test\n+    static X509Certificate rootCert;        \/\/ The root CA certificate\n+    static X509Certificate eeCert;          \/\/ The end entity certificate\n+    static KeyStore rootKeystore;           \/\/ Root CA Keystore\n+    static KeyStore eeKeystore;             \/\/ End Entity Keystore\n+    static KeyStore trustStore;             \/\/ SSL Client trust store\n+    static SimpleOCSPServer rootOcsp;       \/\/ Root CA OCSP Responder\n+    static int rootOcspPort;                \/\/ Port number for root OCSP\n+\n+    public static void main(String args[]) throws Exception {\n+        int ocspTimeout = 15000;\n+        boolean expected = false;\n+\n+        createPKI();\n+\n+        if (args[0] != null) {\n+            ocspTimeout = Integer.parseInt(args[0]);\n+        }\n+        rootOcsp.setDelay(ocspTimeout);\n+\n+        expected = (args[1] != null && Boolean.parseBoolean(args[1]));\n+        log(\"Test case expects to \" + (expected ? \"pass\" : \"fail\"));\n+\n+        \/\/ validate chain\n+        CertPathValidator cpv = CertPathValidator.getInstance(\"PKIX\");\n+        PKIXRevocationChecker prc =\n+                (PKIXRevocationChecker) cpv.getRevocationChecker();\n+        prc.setOptions(EnumSet.of(NO_FALLBACK, SOFT_FAIL));\n+        PKIXParameters params =\n+                new PKIXParameters(Set.of(new TrustAnchor(rootCert, null)));\n+        params.addCertPathChecker(prc);\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        CertPath cp = cf.generateCertPath(List.of(eeCert));\n+        cpv.validate(cp, params);\n+\n+        \/\/ unwrap soft fail exceptions and check for SocketTimeoutException\n+        List<CertPathValidatorException> softExc = prc.getSoftFailExceptions();\n+        if (expected) {\n+            if (softExc.size() > 0) {\n+                throw new RuntimeException(\"Expected to pass, found \" +\n+                        softExc.size() + \" soft fail exceptions\");\n+            }\n+        } else {\n+            \/\/ If we expect to fail the validation then there should be a\n+            \/\/ SocketTimeoutException\n+            boolean found = false;\n+            for (CertPathValidatorException softFail : softExc) {\n+                log(\"CPVE: \" + softFail);\n+                Throwable cause = softFail.getCause();\n+                log(\"Cause: \" + cause);\n+                while (cause != null) {\n+                    if (cause instanceof SocketTimeoutException) {\n+                        found = true;\n+                        break;\n+                    }\n+                    cause = cause.getCause();\n+                }\n+                if (found) {\n+                    break;\n+                }\n+            }\n+\n+            if (!found) {\n+                throw new RuntimeException(\"SocketTimeoutException not thrown\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates the PKI components necessary for this test, including\n+     * Root CA, Intermediate CA and SSL server certificates, the keystores\n+     * for each entity, a client trust store, and starts the OCSP responders.\n+     *\/\n+    private static void createPKI() throws Exception {\n+        CertificateBuilder cbld = new CertificateBuilder();\n+        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"EC\");\n+        keyGen.initialize(new ECGenParameterSpec(\"secp256r1\"));\n+        KeyStore.Builder keyStoreBuilder =\n+                KeyStore.Builder.newInstance(\"PKCS12\", null,\n+                        new KeyStore.PasswordProtection(passwd.toCharArray()));\n+\n+        \/\/ Generate Root and EE keys\n+        KeyPair rootCaKP = keyGen.genKeyPair();\n+        log(\"Generated Root CA KeyPair\");\n+        KeyPair eeKP = keyGen.genKeyPair();\n+        log(\"Generated End Entity KeyPair\");\n+\n+        \/\/ Set up the Root CA Cert\n+        cbld.setSubjectName(\"CN=Root CA Cert, O=SomeCompany\");\n+        cbld.setPublicKey(rootCaKP.getPublic());\n+        cbld.setSerialNumber(new BigInteger(\"1\"));\n+        \/\/ Make a 3 year validity starting from 60 days ago\n+        long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(60);\n+        long end = start + TimeUnit.DAYS.toMillis(1085);\n+        cbld.setValidity(new Date(start), new Date(end));\n+        addCommonExts(cbld, rootCaKP.getPublic(), rootCaKP.getPublic());\n+        addCommonCAExts(cbld);\n+        \/\/ Make our Root CA Cert!\n+        rootCert = cbld.build(null, rootCaKP.getPrivate(),\n+                \"SHA256withECDSA\");\n+        log(\"Root CA Created:\\n%s\", certInfo(rootCert));\n+\n+        \/\/ Now build a keystore and add the keys and cert\n+        rootKeystore = keyStoreBuilder.getKeyStore();\n+        Certificate[] rootChain = {rootCert};\n+        rootKeystore.setKeyEntry(ROOT_ALIAS, rootCaKP.getPrivate(),\n+                passwd.toCharArray(), rootChain);\n+\n+        \/\/ Now fire up the OCSP responder\n+        rootOcsp = new SimpleOCSPServer(rootKeystore, passwd, ROOT_ALIAS, null);\n+        rootOcsp.enableLog(debug);\n+        rootOcsp.setNextUpdateInterval(3600);\n+        rootOcsp.setDisableContentLength(true);\n+        rootOcsp.start();\n+\n+        \/\/ Wait 5 seconds for server ready\n+        boolean readyStatus = rootOcsp.awaitServerReady(5, TimeUnit.SECONDS);\n+        if (!readyStatus) {\n+            throw new RuntimeException(\"Server not ready\");\n+        }\n+\n+        rootOcspPort = rootOcsp.getPort();\n+        String rootRespURI = \"http:\/\/localhost:\" + rootOcspPort;\n+        log(\"Root OCSP Responder URI is %s\", rootRespURI);\n+\n+        \/\/ Now that we have the root keystore and OCSP responder we can\n+        \/\/ create our end entity certificate\n+        cbld.reset();\n+        cbld.setSubjectName(\"CN=SSLCertificate, O=SomeCompany\");\n+        cbld.setPublicKey(eeKP.getPublic());\n+        cbld.setSerialNumber(new BigInteger(\"4096\"));\n+        \/\/ Make a 1 year validity starting from 7 days ago\n+        start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);\n+        end = start + TimeUnit.DAYS.toMillis(365);\n+        cbld.setValidity(new Date(start), new Date(end));\n+\n+        \/\/ Add extensions\n+        addCommonExts(cbld, eeKP.getPublic(), rootCaKP.getPublic());\n+        boolean[] kuBits = {true, false, false, false, false, false,\n+                false, false, false};\n+        cbld.addKeyUsageExt(kuBits);\n+        List<String> ekuOids = new ArrayList<>();\n+        ekuOids.add(\"1.3.6.1.5.5.7.3.1\");\n+        ekuOids.add(\"1.3.6.1.5.5.7.3.2\");\n+        cbld.addExtendedKeyUsageExt(ekuOids);\n+        cbld.addSubjectAltNameDNSExt(Collections.singletonList(\"localhost\"));\n+        cbld.addAIAExt(Collections.singletonList(rootRespURI));\n+        \/\/ Make our End Entity Cert!\n+        eeCert = cbld.build(rootCert, rootCaKP.getPrivate(),\n+                \"SHA256withECDSA\");\n+        log(\"SSL Certificate Created:\\n%s\", certInfo(eeCert));\n+\n+        \/\/ Provide end entity cert revocation info to the Root CA\n+        \/\/ OCSP responder.\n+        Map<BigInteger, SimpleOCSPServer.CertStatusInfo> revInfo =\n+                new HashMap<>();\n+        revInfo.put(eeCert.getSerialNumber(),\n+                new SimpleOCSPServer.CertStatusInfo(\n+                        SimpleOCSPServer.CertStatus.CERT_STATUS_GOOD));\n+        rootOcsp.updateStatusDb(revInfo);\n+\n+        \/\/ Now build a keystore and add the keys, chain and root cert as a TA\n+        eeKeystore = keyStoreBuilder.getKeyStore();\n+        Certificate[] eeChain = {eeCert, rootCert};\n+        eeKeystore.setKeyEntry(EE_ALIAS, eeKP.getPrivate(),\n+                passwd.toCharArray(), eeChain);\n+        eeKeystore.setCertificateEntry(ROOT_ALIAS, rootCert);\n+\n+        \/\/ And finally a Trust Store for the client\n+        trustStore = keyStoreBuilder.getKeyStore();\n+        trustStore.setCertificateEntry(ROOT_ALIAS, rootCert);\n+    }\n+\n+    private static void addCommonExts(CertificateBuilder cbld,\n+            PublicKey subjKey, PublicKey authKey) throws IOException {\n+        cbld.addSubjectKeyIdExt(subjKey);\n+        cbld.addAuthorityKeyIdExt(authKey);\n+    }\n+\n+    private static void addCommonCAExts(CertificateBuilder cbld)\n+            throws IOException {\n+        cbld.addBasicConstraintsExt(true, true, -1);\n+        \/\/ Set key usage bits for digitalSignature, keyCertSign and cRLSign\n+        boolean[] kuBitSettings = {true, false, false, false, false, true,\n+                true, false, false};\n+        cbld.addKeyUsageExt(kuBitSettings);\n+    }\n+\n+    \/**\n+     * Helper routine that dumps only a few cert fields rather than\n+     * the whole toString() output.\n+     *\n+     * @param cert an X509Certificate to be displayed\n+     *\n+     * @return the String output of the issuer, subject and\n+     * serial number\n+     *\/\n+    private static String certInfo(X509Certificate cert) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Issuer: \").append(cert.getIssuerX500Principal()).\n+                append(\"\\n\");\n+        sb.append(\"Subject: \").append(cert.getSubjectX500Principal()).\n+                append(\"\\n\");\n+        sb.append(\"Serial: \").append(cert.getSerialNumber()).append(\"\\n\");\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Log a message on stdout\n+     *\n+     * @param format the format string for the log entry\n+     * @param args zero or more arguments corresponding to the format string\n+     *\/\n+    private static void log(String format, Object ... args) {\n+        System.out.format(format + \"\\n\", args);\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/OCSP\/OCSPTimeout.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-    public void setSubjectName(X500Principal name) {\n+    public CertificateBuilder setSubjectName(X500Principal name) {\n@@ -120,0 +120,1 @@\n+        return this;\n@@ -127,1 +128,1 @@\n-    public void setSubjectName(String name) {\n+    public CertificateBuilder setSubjectName(String name) {\n@@ -129,0 +130,1 @@\n+        return this;\n@@ -136,1 +138,1 @@\n-    public void setPublicKey(PublicKey pubKey) {\n+    public CertificateBuilder setPublicKey(PublicKey pubKey) {\n@@ -138,0 +140,1 @@\n+        return this;\n@@ -146,1 +149,1 @@\n-    public void setNotBefore(Date nbDate) {\n+    public CertificateBuilder setNotBefore(Date nbDate) {\n@@ -149,0 +152,1 @@\n+        return this;\n@@ -157,1 +161,1 @@\n-    public void setNotAfter(Date naDate) {\n+    public CertificateBuilder setNotAfter(Date naDate) {\n@@ -160,0 +164,1 @@\n+        return this;\n@@ -170,3 +175,2 @@\n-    public void setValidity(Date nbDate, Date naDate) {\n-        setNotBefore(nbDate);\n-        setNotAfter(naDate);\n+    public CertificateBuilder setValidity(Date nbDate, Date naDate) {\n+        return setNotBefore(nbDate).setNotAfter(naDate);\n@@ -180,1 +184,1 @@\n-    public void setSerialNumber(BigInteger serial) {\n+    public CertificateBuilder setSerialNumber(BigInteger serial) {\n@@ -183,0 +187,1 @@\n+        return this;\n@@ -191,1 +196,1 @@\n-    public void addExtension(Extension ext) {\n+    public CertificateBuilder addExtension(Extension ext) {\n@@ -194,0 +199,1 @@\n+        return this;\n@@ -202,1 +208,1 @@\n-    public void addExtensions(List<Extension> extList) {\n+    public CertificateBuilder addExtensions(List<Extension> extList) {\n@@ -207,0 +213,1 @@\n+        return this;\n@@ -216,1 +223,2 @@\n-    public void addSubjectAltNameDNSExt(List<String> dnsNames) throws IOException {\n+    public CertificateBuilder addSubjectAltNameDNSExt(List<String> dnsNames)\n+            throws IOException {\n@@ -225,0 +233,1 @@\n+        return this;\n@@ -229,1 +238,7 @@\n-     * certificate extension.\n+     * certificate extension.  Location strings can be in two forms:\n+     * 1) Just a URI by itself: This will be treated as using the OCSP\n+     *    access description (legacy behavior).\n+     * 2) An access description name (case-insensitive) followed by a\n+     *    pipe (|) and the URI (e.g. OCSP|http:\/\/ocsp.company.com\/revcheck).\n+     * Current description names are OCSP and CAISSUER. Others may be\n+     * added later.\n@@ -231,1 +246,1 @@\n-     * @param locations A list of one or more OCSP responder URIs as strings\n+     * @param locations A list of one or more access descriptor URIs as strings\n@@ -235,1 +250,1 @@\n-    public void addAIAExt(List<String> locations)\n+    public CertificateBuilder addAIAExt(List<String> locations)\n@@ -239,4 +254,23 @@\n-            for (String ocspUri : locations) {\n-                acDescList.add(new AccessDescription(\n-                        AccessDescription.Ad_OCSP_Id,\n-                        new GeneralName(new URIName(ocspUri))));\n+            for (String loc : locations) {\n+                String[] tokens = loc.split(\"\\\\|\", 2);\n+                ObjectIdentifier adObj;\n+                String uriLoc;\n+                if (tokens.length == 1) {\n+                    \/\/ Legacy form, assume OCSP\n+                    adObj = AccessDescription.Ad_OCSP_Id;\n+                    uriLoc = tokens[0];\n+                } else {\n+                    switch (tokens[0].toUpperCase()) {\n+                        case \"OCSP\":\n+                            adObj = AccessDescription.Ad_OCSP_Id;\n+                            break;\n+                        case \"CAISSUER\":\n+                            adObj = AccessDescription.Ad_CAISSUERS_Id;\n+                            break;\n+                        default:\n+                            throw new IOException(\"Unknown AD: \" + tokens[0]);\n+                    }\n+                    uriLoc = tokens[1];\n+                }\n+                acDescList.add(new AccessDescription(adObj,\n+                        new GeneralName(new URIName(uriLoc))));\n@@ -246,0 +280,1 @@\n+        return this;\n@@ -248,0 +283,1 @@\n+\n@@ -257,2 +293,3 @@\n-    public void addKeyUsageExt(boolean[] bitSettings) throws IOException {\n-        addExtension(new KeyUsageExtension(bitSettings));\n+    public CertificateBuilder addKeyUsageExt(boolean[] bitSettings)\n+            throws IOException {\n+        return addExtension(new KeyUsageExtension(bitSettings));\n@@ -273,1 +310,1 @@\n-    public void addBasicConstraintsExt(boolean crit, boolean isCA,\n+    public CertificateBuilder addBasicConstraintsExt(boolean crit, boolean isCA,\n@@ -275,1 +312,2 @@\n-        addExtension(new BasicConstraintsExtension(crit, isCA, maxPathLen));\n+        return addExtension(new BasicConstraintsExtension(crit, isCA,\n+                maxPathLen));\n@@ -285,1 +323,1 @@\n-    public void addAuthorityKeyIdExt(X509Certificate authorityCert)\n+    public CertificateBuilder addAuthorityKeyIdExt(X509Certificate authorityCert)\n@@ -287,1 +325,1 @@\n-        addAuthorityKeyIdExt(authorityCert.getPublicKey());\n+        return addAuthorityKeyIdExt(authorityCert.getPublicKey());\n@@ -297,1 +335,2 @@\n-    public void addAuthorityKeyIdExt(PublicKey authorityKey) throws IOException {\n+    public CertificateBuilder addAuthorityKeyIdExt(PublicKey authorityKey)\n+            throws IOException {\n@@ -299,1 +338,2 @@\n-        addExtension(new AuthorityKeyIdentifierExtension(kid, null, null));\n+        return addExtension(new AuthorityKeyIdentifierExtension(kid,\n+                null, null));\n@@ -309,1 +349,2 @@\n-    public void addSubjectKeyIdExt(PublicKey subjectKey) throws IOException {\n+    public CertificateBuilder addSubjectKeyIdExt(PublicKey subjectKey)\n+            throws IOException {\n@@ -311,1 +352,1 @@\n-        addExtension(new SubjectKeyIdentifierExtension(keyIdBytes));\n+        return addExtension(new SubjectKeyIdentifierExtension(keyIdBytes));\n@@ -321,1 +362,1 @@\n-    public void addExtendedKeyUsageExt(List<String> ekuOids)\n+    public CertificateBuilder addExtendedKeyUsageExt(List<String> ekuOids)\n@@ -330,0 +371,1 @@\n+        return this;\n@@ -336,1 +378,1 @@\n-    public void reset() {\n+    public CertificateBuilder reset() {\n@@ -345,0 +387,1 @@\n+        return this;\n@@ -386,1 +429,1 @@\n-     * @param signAlg The signature algorithm object\n+     * @param algName The signature algorithm object\n@@ -452,4 +495,7 @@\n-        \/\/ Hardcode to V3\n-        byte[] v3int = {0x02, 0x01, 0x02};\n-        tbsCertItems.write(DerValue.createTag(DerValue.TAG_CONTEXT, true,\n-                (byte)0), v3int);\n+        \/\/ If extensions exist then it needs to be v3, otherwise\n+        \/\/ we can make it v1 and omit the version field as v1 is the default.\n+        if (!extensions.isEmpty()) {\n+            byte[] v3int = {0x02, 0x01, 0x02};\n+            tbsCertItems.write(DerValue.createTag(DerValue.TAG_CONTEXT, true,\n+                    (byte) 0), v3int);\n+        }\n@@ -485,1 +531,1 @@\n-        \/\/ TODO: Extensions!\n+        \/\/ Encode any extensions in the builder\n@@ -526,1 +572,0 @@\n-\n","filename":"test\/jdk\/java\/security\/testlibrary\/CertificateBuilder.java","additions":84,"deletions":39,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -0,0 +1,292 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8179502\n+ * @summary Enhance OCSP, CRL and Certificate Fetch Timeouts\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib ..\/..\/..\/..\/java\/security\/testlibrary\n+ * @build CertificateBuilder\n+ * @run main\/othervm -Dcom.sun.security.enableAIAcaIssuers=true\n+ *      -Dcom.sun.security.cert.readtimeout=1 AIACertTimeout 2000 false\n+ * @run main\/othervm -Dcom.sun.security.enableAIAcaIssuers=true\n+ *      -Dcom.sun.security.cert.readtimeout=1s AIACertTimeout 2000 false\n+ * @run main\/othervm -Dcom.sun.security.enableAIAcaIssuers=true\n+ *      -Dcom.sun.security.cert.readtimeout=3 AIACertTimeout 2000 true\n+ * @run main\/othervm -Dcom.sun.security.enableAIAcaIssuers=true\n+ *      -Dcom.sun.security.cert.readtimeout=1500ms AIACertTimeout 2000 false\n+ * @run main\/othervm -Dcom.sun.security.enableAIAcaIssuers=true\n+ *      -Dcom.sun.security.cert.readtimeout=2750ms AIACertTimeout 2000 true\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.enableAIAcaIssuers=false\n+ *      -Dcom.sun.security.cert.readtimeout=20000ms AIACertTimeout 10000 false\n+ *\/\n+\n+import com.sun.net.httpserver.*;\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.net.InetSocketAddress;\n+import java.security.cert.*;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.*;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import sun.security.testlibrary.CertificateBuilder;\n+\n+import sun.security.x509.*;\n+import sun.security.util.*;\n+\n+public class AIACertTimeout {\n+\n+    private static final boolean logging = true;\n+\n+    \/\/ PKI and server components we will need for this test\n+    private static KeyPair          rootKp;     \/\/ Root CA keys\n+    private static X509Certificate  rootCert;\n+    private static KeyPair          intKp;      \/\/ Intermediate CA keys\n+    private static X509Certificate  intCert;\n+    private static KeyPair          eeKp;       \/\/ End-entity keys\n+    private static X509Certificate  eeCert;\n+\n+    public static void main(String[] args) throws Exception {\n+        int servTimeoutMsec = (args != null && args.length >= 1) ?\n+                Integer.parseInt(args[0]) : -1;\n+        boolean expectedPass = args != null && args.length >= 2 &&\n+                Boolean.parseBoolean(args[1]);\n+\n+        createAuthorities();\n+        CaCertHttpServer aiaServer = new CaCertHttpServer(intCert,\n+                servTimeoutMsec);\n+        try {\n+            aiaServer.start();\n+            createEE(aiaServer.getAddress());\n+\n+            X509CertSelector target = new X509CertSelector();\n+            target.setCertificate(eeCert);\n+            PKIXParameters params = new PKIXBuilderParameters(Set.of(\n+                        new TrustAnchor(rootCert, null)), target);\n+            params.setRevocationEnabled(false);\n+\n+            try {\n+                CertPathBuilder cpb = CertPathBuilder.getInstance(\"PKIX\");\n+                CertPathBuilderResult result = cpb.build(params);\n+                if (expectedPass) {\n+                    int pathLen = result.getCertPath().getCertificates().size();\n+                    if (pathLen != 2) {\n+                        throw new RuntimeException(\"Expected 2 certificates \" +\n+                                \"in certpath, got \" + pathLen);\n+                    }\n+                } else {\n+                    throw new RuntimeException(\"Missing expected CertPathBuilderException\");\n+                }\n+            } catch (CertPathBuilderException cpve) {\n+                if (!expectedPass) {\n+                    log(\"Cert path building failed as expected: \" + cpve);\n+                } else {\n+                    throw cpve;\n+                }\n+            }\n+        } finally {\n+            aiaServer.stop();\n+        }\n+    }\n+\n+    private static class CaCertHttpServer {\n+\n+        private final X509Certificate caCert;\n+        private final HttpServer server;\n+        private final int timeout;\n+\n+        public CaCertHttpServer(X509Certificate cert, int timeout)\n+                throws IOException {\n+            caCert = Objects.requireNonNull(cert, \"Null CA cert disallowed\");\n+            server = HttpServer.create();\n+            this.timeout = timeout;\n+            if (timeout > 0) {\n+                log(\"Created HttpServer with timeout of \" + timeout + \" msec.\");\n+            } else {\n+                log(\"Created HttpServer with no timeout\");\n+            }\n+        }\n+\n+        public void start() throws IOException {\n+            server.bind(new InetSocketAddress(\"localhost\", 0), 0);\n+            server.createContext(\"\/cacert\", t -> {\n+                try (InputStream is = t.getRequestBody()) {\n+                    is.readAllBytes();\n+                }\n+                try {\n+                    if (timeout > 0) {\n+                        \/\/ Sleep in order to simulate network latency\n+                        log(\"Server sleeping for \" + timeout + \" msec.\");\n+                        Thread.sleep(timeout);\n+                    }\n+\n+                    byte[] derCert = caCert.getEncoded();\n+                    t.getResponseHeaders().add(\"Content-Type\",\n+                            \"application\/pkix-cert\");\n+                    t.sendResponseHeaders(200, derCert.length);\n+                    try (OutputStream os = t.getResponseBody()) {\n+                        os.write(derCert);\n+                    }\n+                } catch (InterruptedException |\n+                        CertificateEncodingException exc) {\n+                    throw new IOException(exc);\n+                }\n+            });\n+            server.setExecutor(null);\n+            server.start();\n+            log(\"Started HttpServer: Listening on \" + server.getAddress());\n+        }\n+\n+        public void stop() {\n+            server.stop(0);\n+        }\n+\n+        public InetSocketAddress getAddress() {\n+            return server.getAddress();\n+        }\n+    }\n+\n+\n+    \/**\n+     * Creates the CA PKI components necessary for this test.\n+     *\/\n+    private static void createAuthorities() throws Exception {\n+        CertificateBuilder cbld = new CertificateBuilder();\n+        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"EC\");\n+        keyGen.initialize(new ECGenParameterSpec(\"secp256r1\"));\n+\n+        \/\/ Generate Root, IntCA, EE keys\n+        rootKp = keyGen.genKeyPair();\n+        log(\"Generated Root CA KeyPair\");\n+        intKp = keyGen.genKeyPair();\n+        log(\"Generated Intermediate CA KeyPair\");\n+        eeKp = keyGen.genKeyPair();\n+        log(\"Generated End Entity Cert KeyPair\");\n+\n+        \/\/ Make a 3 year validity starting from 60 days ago\n+        long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(60);\n+        long end = start + TimeUnit.DAYS.toMillis(1085);\n+\n+        boolean[] kuBitSettings = {true, false, false, false, false, true,\n+                true, false, false};\n+\n+        \/\/ Set up the Root CA Cert\n+        cbld.setSubjectName(\"CN=Root CA Cert, O=SomeCompany\").\n+                setPublicKey(rootKp.getPublic()).\n+                setSerialNumber(new BigInteger(\"1\")).\n+                setValidity(new Date(start), new Date(end)).\n+                addSubjectKeyIdExt(rootKp.getPublic()).\n+                addAuthorityKeyIdExt(rootKp.getPublic()).\n+                addBasicConstraintsExt(true, true, -1).\n+                addKeyUsageExt(kuBitSettings);\n+\n+        \/\/ Make our Root CA Cert!\n+        rootCert = cbld.build(null, rootKp.getPrivate(), \"SHA256withECDSA\");\n+        log(\"Root CA Created:\\n\" + certInfo(rootCert));\n+\n+        \/\/ Make a 2 year validity starting from 30 days ago\n+        start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(30);\n+        end = start + TimeUnit.DAYS.toMillis(730);\n+\n+        \/\/ Now that we have the root keystore we can create our\n+        \/\/ intermediate CA.\n+        cbld.reset();\n+        cbld.setSubjectName(\"CN=Intermediate CA Cert, O=SomeCompany\").\n+                setPublicKey(intKp.getPublic()).\n+                setSerialNumber(new BigInteger(\"100\")).\n+                setValidity(new Date(start), new Date(end)).\n+                addSubjectKeyIdExt(intKp.getPublic()).\n+                addAuthorityKeyIdExt(rootKp.getPublic()).\n+                addBasicConstraintsExt(true, true, -1).\n+                addKeyUsageExt(kuBitSettings);\n+\n+        \/\/ Make our Intermediate CA Cert!\n+        intCert = cbld.build(rootCert, rootKp.getPrivate(), \"SHA256withECDSA\");\n+        log(\"Intermediate CA Created:\\n\" + certInfo(intCert));\n+    }\n+\n+    \/**\n+     * Creates the end entity certificate from the previously generated\n+     * intermediate CA cert.\n+     *\n+     * @param aiaAddr the address\/port of the server that will hold the issuer\n+     *                certificate. This will be used to create an AIA URI.\n+     *\/\n+    private static void createEE(InetSocketAddress aiaAddr) throws Exception {\n+        \/\/ Make a 1 year validity starting from 7 days ago\n+        long start = System.currentTimeMillis() - TimeUnit.DAYS.toMillis(7);\n+        long end = start + TimeUnit.DAYS.toMillis(365);\n+        boolean[] kuBits = {true, false, false, false, false, false,\n+                false, false, false};\n+        List<String> ekuOids = List.of(\"1.3.6.1.5.5.7.3.1\",\n+                \"1.3.6.1.5.5.7.3.2\", \"1.3.6.1.5.5.7.3.4\");\n+        String aiaUri = String.format(\"http:\/\/%s:%d\/cacert\",\n+                aiaAddr.getHostName(), aiaAddr.getPort());\n+\n+        CertificateBuilder cbld = new CertificateBuilder();\n+        cbld.setSubjectName(\"CN=Oscar T. Grouch, O=SomeCompany\").\n+                setPublicKey(eeKp.getPublic()).\n+                setSerialNumber(new BigInteger(\"4096\")).\n+                setValidity(new Date(start), new Date(end)).\n+                addSubjectKeyIdExt(eeKp.getPublic()).\n+                addAuthorityKeyIdExt(intKp.getPublic()).\n+                addKeyUsageExt(kuBits).addExtendedKeyUsageExt(ekuOids).\n+                addAIAExt(List.of(\"CAISSUER|\" + aiaUri));\n+\n+        \/\/ Build the cert\n+        eeCert = cbld.build(intCert, intKp.getPrivate(), \"SHA256withECDSA\");\n+        log(\"EE Certificate Created:\\n\" + certInfo(eeCert));\n+    }\n+\n+    \/**\n+     * Helper routine that dumps only a few cert fields rather than\n+     * the whole toString() output.\n+     *\n+     * @param cert an X509Certificate to be displayed\n+     *\n+     * @return the String output of the issuer, subject and\n+     * serial number\n+     *\/\n+    private static String certInfo(X509Certificate cert) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Issuer: \").append(cert.getIssuerX500Principal()).\n+                append(\"\\n\");\n+        sb.append(\"Subject: \").append(cert.getSubjectX500Principal()).\n+                append(\"\\n\");\n+        sb.append(\"Serial: \").append(cert.getSerialNumber()).append(\"\\n\");\n+        return sb.toString();\n+    }\n+\n+    private static void log(String str) {\n+        if (logging) {\n+            System.out.println(\"[\" + Thread.currentThread().getName() + \"] \" +\n+                    str);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/x509\/URICertStore\/AIACertTimeout.java","additions":292,"deletions":0,"binary":false,"changes":292,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8191808\n+ * @bug 8191808 8179502\n@@ -28,0 +28,2 @@\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n@@ -29,1 +31,5 @@\n- * @run main\/othervm -Dcom.sun.security.crl.readtimeout=1 CRLReadTimeout\n+ * @run main\/othervm -Dcom.sun.security.crl.readtimeout=1 CRLReadTimeout 2000 false\n+ * @run main\/othervm -Dcom.sun.security.crl.readtimeout=1s CRLReadTimeout 2000 false\n+ * @run main\/othervm -Dcom.sun.security.crl.readtimeout=4 CRLReadTimeout 2000 true\n+ * @run main\/othervm -Dcom.sun.security.crl.readtimeout=1500ms CRLReadTimeout 2000 false\n+ * @run main\/othervm -Dcom.sun.security.crl.readtimeout=2750ms CRLReadTimeout 2000 true\n@@ -32,3 +38,2 @@\n-import java.io.File;\n-import java.io.InputStream;\n-import java.io.IOException;\n+import java.io.*;\n+import java.math.BigInteger;\n@@ -37,0 +42,1 @@\n+import java.security.GeneralSecurityException;\n@@ -38,9 +44,3 @@\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.CertPath;\n-import java.security.cert.CertPathValidator;\n-import java.security.cert.CertPathValidatorException;\n-import java.security.cert.PKIXParameters;\n-import java.security.cert.PKIXRevocationChecker;\n-import static java.security.cert.PKIXRevocationChecker.Option.*;\n-import java.security.cert.TrustAnchor;\n-import java.security.cert.X509Certificate;\n+import java.security.PrivateKey;\n+import java.security.cert.*;\n+import java.util.Date;\n@@ -50,1 +50,3 @@\n-import com.sun.net.httpserver.HttpServer;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.security.cert.PKIXRevocationChecker.Option.*;\n@@ -52,0 +54,1 @@\n+import com.sun.net.httpserver.HttpServer;\n@@ -54,0 +57,2 @@\n+import sun.security.util.SignatureUtil;\n+import sun.security.x509.*;\n@@ -57,0 +62,3 @@\n+    public static final String PASS = \"changeit\";\n+    public static X509CRL crl;\n+\n@@ -59,5 +67,6 @@\n-        String timeout = System.getProperty(\"com.sun.security.crl.readtimeout\");\n-        if (timeout == null) {\n-            timeout = \"15\";\n-        }\n-        System.out.println(\"Testing timeout of \" + timeout + \" seconds\");\n+        int serverTimeout = (args != null && args[0] != null) ?\n+                Integer.parseInt(args[0]) : 15000;\n+        boolean expectedPass = args != null && args[1] != null &&\n+                Boolean.parseBoolean(args[1]);\n+        System.out.println(\"Server timeout is \" + serverTimeout + \" msec.\");\n+        System.out.println(\"Test is expected to \" + (expectedPass ? \"pass\" : \"fail\"));\n@@ -65,1 +74,1 @@\n-        CrlHttpServer crlServer = new CrlHttpServer(Integer.parseInt(timeout));\n+        CrlHttpServer crlServer = new CrlHttpServer(serverTimeout);\n@@ -68,1 +77,1 @@\n-            testTimeout(crlServer.getPort());\n+            testTimeout(crlServer.getPort(), expectedPass);\n@@ -74,1 +83,2 @@\n-    private static void testTimeout(int port) throws Exception {\n+    private static void testTimeout(int port, boolean expectedPass)\n+            throws Exception {\n@@ -85,2 +95,1 @@\n-        KeyStore ks = KeyStore.getInstance(new File(\"ks\"),\n-                                           \"changeit\".toCharArray());\n+        KeyStore ks = KeyStore.getInstance(new File(\"ks\"), PASS.toCharArray());\n@@ -89,0 +98,1 @@\n+        crl = genCrl(ks, \"root\", PASS);\n@@ -103,6 +113,18 @@\n-        boolean expected = false;\n-        for (CertPathValidatorException softFail:prc.getSoftFailExceptions()) {\n-            Throwable cause = softFail.getCause();\n-            while (cause != null) {\n-                if (cause instanceof SocketTimeoutException) {\n-                    expected = true;\n+        List<CertPathValidatorException> softExc = prc.getSoftFailExceptions();\n+        if (expectedPass) {\n+            if (softExc.size() > 0) {\n+                throw new RuntimeException(\"Expected to pass, found \" +\n+                        softExc.size() + \" soft fail exceptions\");\n+            }\n+        } else {\n+            boolean foundSockTOExc = false;\n+            for (CertPathValidatorException softFail : softExc) {\n+                Throwable cause = softFail.getCause();\n+                while (cause != null) {\n+                    if (cause instanceof SocketTimeoutException) {\n+                        foundSockTOExc = true;\n+                        break;\n+                    }\n+                    cause = cause.getCause();\n+                }\n+                if (foundSockTOExc) {\n@@ -111,1 +133,0 @@\n-                cause = cause.getCause();\n@@ -113,2 +134,2 @@\n-            if (expected) {\n-                break;\n+            if (!foundSockTOExc) {\n+                throw new Exception(\"SocketTimeoutException not thrown\");\n@@ -117,3 +138,0 @@\n-        if (!expected) {\n-            throw new Exception(\"SocketTimeoutException not thrown\");\n-        }\n@@ -123,2 +141,26 @@\n-        return SecurityTools.keytool(\"-storepass changeit \"\n-                + \"-keystore ks \" + cmd);\n+        return SecurityTools.keytool(\"-storepass \" + PASS +\n+                \" -keystore ks \" + cmd);\n+    }\n+\n+    private static X509CRL genCrl(KeyStore ks, String issAlias, String pass)\n+            throws GeneralSecurityException, IOException {\n+        \/\/ Create an empty CRL with a 1-day validity period.\n+        X509Certificate issuerCert = (X509Certificate)ks.getCertificate(issAlias);\n+        PrivateKey issuerKey = (PrivateKey)ks.getKey(issAlias, pass.toCharArray());\n+\n+        long curTime = System.currentTimeMillis();\n+        Date thisUp = new Date(curTime - TimeUnit.SECONDS.toMillis(43200));\n+        Date nextUp = new Date(curTime + TimeUnit.SECONDS.toMillis(43200));\n+        CRLExtensions exts = new CRLExtensions();\n+        var aki = new AuthorityKeyIdentifierExtension(new KeyIdentifier(\n+                issuerCert.getPublicKey()), null, null);\n+        var crlNum = new CRLNumberExtension(BigInteger.ONE);\n+        exts.setExtension(aki.getId(), aki);\n+        exts.setExtension(crlNum.getId(), crlNum);\n+        X509CRLImpl.TBSCertList cList = new X509CRLImpl.TBSCertList(\n+                new X500Name(issuerCert.getSubjectX500Principal().toString()),\n+                thisUp, nextUp, null, exts);\n+        X509CRL crl = X509CRLImpl.newSigned(cList, issuerKey,\n+                SignatureUtil.getDefaultSigAlgForKey(issuerKey));\n+        System.out.println(\"ISSUED CRL:\\n\" + crl);\n+        return crl;\n@@ -139,1 +181,1 @@\n-            server.createContext(\"\/\", t -> {\n+            server.createContext(\"\/crl\", t -> {\n@@ -144,4 +186,12 @@\n-                    \/\/ sleep for 2 seconds longer to force timeout\n-                    Thread.sleep((timeout + 2)*1000);\n-                } catch (InterruptedException ie) {\n-                    throw new IOException(ie);\n+                    \/\/ Sleep in order to simulate network latency\n+                    Thread.sleep(timeout);\n+\n+                    byte[] derCrl = crl.getEncoded();\n+                    t.getResponseHeaders().add(\"Content-Type\",\n+                            \"application\/pkix-crl\");\n+                    t.sendResponseHeaders(200, derCrl.length);\n+                    try (OutputStream os = t.getResponseBody()) {\n+                        os.write(derCrl);\n+                    }\n+                } catch (InterruptedException | CRLException exc) {\n+                    throw new IOException(exc);\n","filename":"test\/jdk\/sun\/security\/x509\/URICertStore\/CRLReadTimeout.java","additions":95,"deletions":45,"binary":false,"changes":140,"status":"modified"}]}