{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import javax.lang.model.element.Name;\n@@ -42,1 +43,0 @@\n-import javax.lang.model.util.SimpleElementVisitor14;\n@@ -527,1 +527,1 @@\n-                List<Element> list = lmt.getMembers(inheritedMember, kind);\n+                List<Element> list = lmt.getMembers(inheritedMember.getSimpleName(), kind);\n@@ -703,1 +703,1 @@\n-        List<Element> lMethods = lmt.getMembers(inheritedMethod, Kind.METHODS);\n+        List<Element> lMethods = lmt.getMembers(inheritedMethod.getSimpleName(), Kind.METHODS);\n@@ -838,6 +838,3 @@\n-     * This class encapsulates the details of local members. orderedMembers\n-     * contains the members in the declaration order, additionally a\n-     * HashMap is maintained for performance optimization to look up\n-     * members. As a future enhancement is perhaps to consolidate the ordering\n-     * into a Map, capturing the insertion order, thereby eliminating an\n-     * ordered list.\n+     * A container of members declared in this class or interface. Members of\n+     * the same kind stored in declaration order. The container supports\n+     * efficient lookup by a member's simple name.\n@@ -845,1 +842,1 @@\n-    class LocalMemberTable {\n+    private class LocalMemberTable {\n@@ -847,5 +844,2 @@\n-        \/\/ Maintains declaration order\n-        private final Map<Kind, List<Element>> orderedMembers;\n-\n-        \/\/ Performance optimization\n-        private final Map<Kind, Map<String, List<Element>>> memberMap;\n+        final Map<Kind, List<Element>> orderedMembers = new EnumMap<>(Kind.class);\n+        final Map<Kind, Map<Name, List<Element>>> namedMembers = new EnumMap<>(Kind.class);\n@@ -854,3 +848,2 @@\n-            orderedMembers = new EnumMap<>(Kind.class);\n-            memberMap = new EnumMap<>(Kind.class);\n-            \/\/ elements directly declared by te\n+            \/\/ elements directly declared by this class or interface,\n+            \/\/ listed in declaration order\n@@ -873,0 +866,3 @@\n+                    case ENUM_CONSTANT:\n+                        addMember(e, Kind.ENUM_CONSTANTS);\n+                        break;\n@@ -875,1 +871,0 @@\n-                            ExecutableElement ee = (ExecutableElement) e;\n@@ -877,1 +872,1 @@\n-                            addMember(e, ee.getDefaultValue() == null\n+                            addMember(e, ((ExecutableElement) e).getDefaultValue() == null\n@@ -887,3 +882,0 @@\n-                    case ENUM_CONSTANT:\n-                        addMember(e, Kind.ENUM_CONSTANTS);\n-                        break;\n@@ -893,22 +885,3 @@\n-            \/\/ Freeze the data structures\n-            for (Kind kind : Kind.values()) {\n-                orderedMembers.computeIfPresent(kind, (k, v) -> Collections.unmodifiableList(v));\n-                orderedMembers.computeIfAbsent(kind, t -> List.of());\n-\n-                memberMap.computeIfPresent(kind, (k, v) -> Collections.unmodifiableMap(v));\n-                memberMap.computeIfAbsent(kind, t -> Map.of());\n-            }\n-        }\n-\n-        String getMemberKey(Element e) {\n-            return new SimpleElementVisitor14<String, Void>() {\n-                @Override\n-                public String visitExecutable(ExecutableElement e, Void aVoid) {\n-                    return e.getSimpleName() + \":\" + e.getParameters().size();\n-                }\n-\n-                @Override\n-                protected String defaultAction(Element e, Void aVoid) {\n-                    return e.getSimpleName().toString();\n-                }\n-            }.visit(e);\n+            \/\/ protect from unintended change\n+            orderedMembers.replaceAll((k, l) -> l == null ? List.of() : Collections.unmodifiableList(l));\n+            namedMembers.replaceAll((k, m) -> m == null ? Map.of() : Collections.unmodifiableMap(m));\n@@ -918,6 +891,4 @@\n-            List<Element> list = orderedMembers.computeIfAbsent(kind, k -> new ArrayList<>());\n-            list.add(e);\n-\n-            Map<String, List<Element>> map = memberMap.computeIfAbsent(kind, k -> new HashMap<>());\n-            list = map.computeIfAbsent(getMemberKey(e), l -> new ArrayList<>());\n-            list.add(e);\n+            orderedMembers.computeIfAbsent(kind, k -> new ArrayList<>()).add(e);\n+            namedMembers.computeIfAbsent(kind, k -> new HashMap<>())\n+                    .computeIfAbsent(e.getSimpleName(), l -> new ArrayList<>())\n+                    .add(e);\n@@ -930,3 +901,2 @@\n-        List<Element> getMembers(Element e, Kind kind) {\n-            String key = getMemberKey(e);\n-            return getMembers(key, kind);\n+        List<Element> getMembers(Name simpleName, Kind kind) {\n+            return namedMembers.get(kind).getOrDefault(simpleName, List.of());\n@@ -935,8 +905,2 @@\n-        List<Element> getMembers(String key, Kind kind) {\n-            Map<String, List<Element>> map = memberMap.get(kind);\n-            return map.getOrDefault(key, List.of());\n-        }\n-\n-        <T extends Element> List<T> getMembers(String key, Kind kind, Class<T> clazz) {\n-            Map<String, List<Element>> map = memberMap.get(kind);\n-            return map.getOrDefault(key, List.of())\n+        <T extends Element> List<T> getMembers(Name simpleName, Kind kind, Class<T> clazz) {\n+            return getMembers(simpleName, kind)\n@@ -948,2 +912,2 @@\n-        List<ExecutableElement> getPropertyMethods(String methodName, int argcount) {\n-            return getMembers(methodName + \":\" + argcount, Kind.METHODS).stream()\n+        List<ExecutableElement> getPropertyMethods(Name simpleName) {\n+            return getMembers(simpleName, Kind.METHODS).stream()\n@@ -1013,1 +977,1 @@\n-            List<VariableElement> flist = lmt.getMembers(baseName, Kind.FIELDS, VariableElement.class);\n+            List<VariableElement> flist = lmt.getMembers(utils.elementUtils.getName(baseName), Kind.FIELDS, VariableElement.class);\n@@ -1016,7 +980,8 @@\n-            ExecutableElement getter = null, setter = null;\n-            List<ExecutableElement> found = lmt.getPropertyMethods(pUtils.getGetName(propertyMethod), 0);\n-            if (!found.isEmpty()) {\n-                \/\/ Getters have zero params, no overloads! pick the first.\n-                getter = found.get(0);\n-            }\n-            if (getter == null) {\n+            \/\/ TODO: this code does not seem to be covered by tests well (JDK-8304170)\n+            ExecutableElement getter = null;\n+            var g = lmt.getPropertyMethods(utils.elementUtils.getName(pUtils.getGetName(propertyMethod))).stream()\n+                    .filter(m -> m.getParameters().isEmpty()) \/\/ Getters have zero params, no overloads!\n+                    .findAny();\n+            if (g.isPresent()) {\n+                getter = g.get();\n+            } else {\n@@ -1024,2 +989,4 @@\n-                found = lmt.getPropertyMethods(pUtils.getIsName(propertyMethod), 0);\n-                if (!found.isEmpty()) {\n+                var i = lmt.getPropertyMethods(utils.elementUtils.getName(pUtils.getIsName(propertyMethod))).stream()\n+                        .filter(m -> m.getParameters().isEmpty())\n+                        .findAny();\n+                if (i.isPresent()) {\n@@ -1028,11 +995,2 @@\n-                        \/\/ Getters have zero params, no overloads!, pick the first.\n-                        getter = found.get(0);\n-                    }\n-                }\n-            }\n-            found = lmt.getPropertyMethods(pUtils.getSetName(propertyMethod), 1);\n-            if (found != null) {\n-                for (ExecutableElement e : found) {\n-                    if (pUtils.isValidSetterMethod(e)) {\n-                        setter = e;\n-                        break;\n+                        \/\/ Getters have zero params, no overloads!\n+                        getter = i.get();\n@@ -1043,0 +1001,6 @@\n+            var setter = lmt.getPropertyMethods(utils.elementUtils.getName(pUtils.getSetName(propertyMethod))).stream()\n+                    \/\/ TODO: the number and the types of parameters a setter takes is not tested (JDK-8304170)\n+                    .filter(m -> m.getParameters().size() == 1 && pUtils.isValidSetterMethod(m))\n+                    .findAny()\n+                    .orElse(null);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":49,"deletions":85,"binary":false,"changes":134,"status":"modified"}]}