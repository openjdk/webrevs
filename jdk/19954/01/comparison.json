{"files":[{"patch":"@@ -3743,0 +3743,7 @@\n+  if (log_is_enabled(Info, perf, vmmutex)) {\n+    if (!UsePerfData) {\n+      warning(\"Disabling -Xlog:perf+vmmutex since UsePerfData is turned off.\");\n+      LogConfiguration::configure_stdout(LogLevel::Off, false, LOG_TAGS(perf, vmmutex));\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -363,0 +364,2 @@\n+\n+  MutexLockerImpl::print_counters_on(tty);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-Mutex::Mutex(Rank rank, const char * name, bool allow_vm_block) : _owner(nullptr) {\n+Mutex::Mutex(Rank rank, const char * name, bool allow_vm_block) : _owner(nullptr), _id(-1) {\n@@ -279,0 +279,1 @@\n+  _id = MutexLocker::name2id(name);\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+  int _id;                               \/\/ ID for named mutexes. It is for indexing into the _perf_lock_count,\n+                                         \/\/ _perf_lock_wait_time, and _perf_lock_hold_time arrays in MutexLockerImpl.\n@@ -197,0 +199,2 @@\n+  int id() const { return _id; }\n+\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"services\/management.hpp\"\n@@ -374,0 +376,96 @@\n+static const int MAX_NAMES = 200;\n+\/\/ _names stores all the names of the mutexes in the order of their creation.\n+static const char* _names[MAX_NAMES] = { nullptr };\n+\/\/ _is_unique is false if the Mutex is not a singleton instance; the ones created from mutex_init() are singleton instances.\n+static bool _is_unique[MAX_NAMES] = { false };\n+static int _num_names = 0;\n+\n+PerfCounter** MutexLockerImpl::_perf_lock_count     = nullptr;\n+PerfCounter** MutexLockerImpl::_perf_lock_wait_time = nullptr;\n+PerfCounter** MutexLockerImpl::_perf_lock_hold_time = nullptr;\n+\n+void MutexLockerImpl::init_counters() {\n+  if (log_is_enabled(Info, perf, vmmutex)) {\n+    ResourceMark rm;\n+    EXCEPTION_MARK;\n+    _perf_lock_count     = NEW_C_HEAP_ARRAY(PerfCounter*, MAX_NAMES + 1, mtInternal);\n+    _perf_lock_wait_time = NEW_C_HEAP_ARRAY(PerfCounter*, MAX_NAMES + 1, mtInternal);\n+    _perf_lock_hold_time = NEW_C_HEAP_ARRAY(PerfCounter*, MAX_NAMES + 1, mtInternal);\n+\n+    NEWPERFEVENTCOUNTER(_perf_lock_count[0],     SUN_RT, PerfDataManager::counter_name(\"Other\", \"Count\"));\n+    NEWPERFEVENTCOUNTER(_perf_lock_wait_time[0], SUN_RT, PerfDataManager::counter_name(\"Other\", \"WaitTime\"));\n+    NEWPERFEVENTCOUNTER(_perf_lock_hold_time[0], SUN_RT, PerfDataManager::counter_name(\"Other\", \"HoldTime\"));\n+    for (int i = 0; i < MAX_NAMES; i++) {\n+      ResourceMark rm;\n+      const char* counter_name = _names[i];\n+      if (counter_name == nullptr) {\n+        stringStream ss;\n+        ss.print(\"UnnamedMutex#%d\", i);\n+        counter_name = ss.as_string();\n+      }\n+      NEWPERFEVENTCOUNTER(_perf_lock_count[i+1],       SUN_RT, PerfDataManager::counter_name(counter_name, \"Count\"));\n+      NEWPERFEVENTCOUNTER(_perf_lock_wait_time[i + 1], SUN_RT, PerfDataManager::counter_name(counter_name, \"WaitTime\"));\n+      NEWPERFEVENTCOUNTER(_perf_lock_hold_time[i + 1], SUN_RT, PerfDataManager::counter_name(counter_name, \"HoldTime\"));\n+    }\n+    if (HAS_PENDING_EXCEPTION) {\n+      vm_exit_during_initialization(\"MutexLockerImpl::init_counters() failed unexpectedly\");\n+    }\n+  }\n+}\n+\n+int MutexLockerImpl::name2id(const char* name) {\n+  if (log_is_enabled(Info, perf, vmmutex)) {\n+    for (int i = 0; i < _num_names; i++) {\n+      if (strcmp(_names[i], name) == 0) {\n+        _is_unique[i] = false;\n+        return i;\n+      }\n+    }\n+    if (_num_names < MAX_NAMES) {\n+      int new_id = _num_names++;\n+      _names[new_id] = os::strdup(name, mtInternal);\n+      _is_unique[new_id] = true;\n+      return new_id;\n+    }\n+    log_debug(init)(\"Unnamed: %s\", name); \/\/ no slots left\n+  }\n+  return -1;\n+}\n+\n+void MutexLockerImpl::print_counter_on(outputStream* st, const char* name, bool is_unique, int idx) {\n+  jlong count = _perf_lock_count[idx]->get_value();\n+  if (count > 0) {\n+    st->print_cr(\"  %3d: %s%40s = \" JLONG_FORMAT_W(5) \"ms (\" JLONG_FORMAT_W(5) \"ms) \/ \" JLONG_FORMAT_W(9) \" events\", idx, (is_unique ? \" \" : \"M\"), name,\n+                 Management::ticks_to_ms(_perf_lock_hold_time[idx]->get_value()),\n+                 Management::ticks_to_ms(_perf_lock_wait_time[idx]->get_value()),\n+                 count);\n+  }\n+}\n+\n+static jlong accumulate_lock_counters(PerfCounter** lock_counters) {\n+  jlong acc = 0;\n+  for (int i = 0; i < _num_mutex + 1; i++) { \/\/ 0 slot is reserved for unnamed locks\n+    acc += lock_counters[i]->get_value();\n+  }\n+  return acc;\n+}\n+\n+void MutexLockerImpl::print_counters_on(outputStream* st) {\n+  if (log_is_enabled(Info, perf, vmmutex)) {\n+    jlong total_count     = accumulate_lock_counters(_perf_lock_count);\n+    jlong total_wait_time = accumulate_lock_counters(_perf_lock_wait_time);\n+    jlong total_hold_time = accumulate_lock_counters(_perf_lock_hold_time);\n+\n+    st->print_cr(\"MutexLocker: Total: %d named locks (%d unique names); hold = \"\n+                 \"\" JLONG_FORMAT \"ms (wait = \" JLONG_FORMAT \"ms) \/ \" JLONG_FORMAT \" events for thread \\\"main\\\"\",\n+                 _num_mutex, _num_names,\n+                 Management::ticks_to_ms(total_hold_time),\n+                 Management::ticks_to_ms(total_wait_time),\n+                 total_count);\n+    for (int i = 0; i < _num_names; i++) {\n+      print_counter_on(st, _names[i], _is_unique[i], i+1);\n+    }\n+    print_counter_on(st, \"Unnamed \/ Other\", false \/*is_unique*\/, 0);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"logging\/log.hpp\"\n@@ -31,0 +32,2 @@\n+#include \"runtime\/perfData.hpp\"\n+#include \"runtime\/thread.hpp\"\n@@ -191,0 +194,10 @@\n+  bool _prof;\n+  elapsedTimer _wait_time; \/\/ time waiting for a mutex locker\n+  elapsedTimer _hold_time; \/\/ time a mutex locker has been held\n+\n+private:\n+  static PerfCounter** _perf_lock_count;\n+  static PerfCounter** _perf_lock_wait_time;\n+  static PerfCounter** _perf_lock_hold_time;\n+\n+public:\n@@ -193,1 +206,3 @@\n-    _mutex(mutex) {\n+    _mutex(mutex),\n+    _prof(log_is_enabled(Info, perf, vmmutex) && Thread::current_or_null() != nullptr && Thread::current()->profile_vm_locks()) {\n+\n@@ -196,0 +211,2 @@\n+      if (_prof) { _wait_time.start(); } \/\/ waiting\n+\n@@ -201,0 +218,2 @@\n+\n+      if (_prof) { _wait_time.stop(); _hold_time.start(); } \/\/ holding\n@@ -205,1 +224,4 @@\n-    _mutex(mutex) {\n+    _mutex(mutex), _prof(thread->profile_vm_locks()) {\n+\n+    if (_prof) { _wait_time.start(); } \/\/ waiting\n+\n@@ -214,0 +236,2 @@\n+\n+    if (_prof) { _wait_time.stop(); _hold_time.start(); } \/\/ holding\n@@ -220,0 +244,8 @@\n+\n+      if (_prof) {\n+        assert(UsePerfData, \"required\");\n+        _hold_time.stop();\n+        _perf_lock_count    [_mutex->id() + 1]->inc();\n+        _perf_lock_wait_time[_mutex->id() + 1]->inc(_wait_time.ticks());\n+        _perf_lock_hold_time[_mutex->id() + 1]->inc(_hold_time.ticks());\n+      }\n@@ -223,0 +255,5 @@\n+ protected:\n+  static void init_counters();\n+ private:\n+  static void print_counter_on(outputStream* st, const char* name, bool is_unique, int idx);\n+\n@@ -224,0 +261,2 @@\n+  static int name2id(const char* name);\n+\n@@ -225,0 +264,1 @@\n+  static void print_counters_on(outputStream* st);\n@@ -240,0 +280,3 @@\n+   static void init_counters() {\n+     MutexLockerImpl::init_counters();\n+   }\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -146,0 +146,2 @@\n+\n+  _profile_vm_locks = false;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -642,0 +642,5 @@\n+\n+  bool  _profile_vm_locks;\n+ public:\n+   bool     profile_vm_locks() const { return _profile_vm_locks; }\n+   void set_profile_vm_locks()       { _profile_vm_locks = true; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -533,0 +533,2 @@\n+  MutexLocker::init_counters(); \/\/ depends on mutex_init(), perfMemory_init(), and Thread::initialize_thread_current().\n+\n@@ -830,0 +832,7 @@\n+  if (log_is_enabled(Info, perf, vmmutex)) {\n+    LogStreamHandle(Info, perf, vmmutex) log;\n+    log.print_cr(\"At VM initialization completion\");\n+    MutexLockerImpl::print_counters_on(&log);\n+    main_thread->set_profile_vm_locks();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}