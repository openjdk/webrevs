{"files":[{"patch":"@@ -61,2 +61,2 @@\n-        MethodHandle handle = (MethodHandle) underlying.resolveConstantDesc(lookup);\n-        MethodType methodType = (MethodType) type.resolveConstantDesc(lookup);\n+        MethodHandle handle = underlying.resolveConstantDesc(lookup);\n+        MethodType methodType = type.resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/AsTypeMethodHandleDesc.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -365,0 +366,3 @@\n+    @Override\n+    Class<?> resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,4 +102,0 @@\n-     * @apiNote {@linkplain MethodTypeDesc} can represent method type descriptors\n-     * that are not representable by {@linkplain MethodType}, such as methods with\n-     * more than 255 parameter slots, so attempts to resolve these may result in errors.\n-     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDesc.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,2 +155,2 @@\n-        Class<?> resolvedOwner = (Class<?>) owner.resolveConstantDesc(lookup);\n-        MethodType invocationType = (MethodType) this.invocationType().resolveConstantDesc(lookup);\n+        Class<?> resolvedOwner = owner.resolveConstantDesc(lookup);\n+        MethodType invocationType = this.invocationType().resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DirectMethodHandleDescImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-        MethodHandle bsm = (MethodHandle) bootstrapMethod.resolveConstantDesc(lookup);\n+        MethodHandle bsm = bootstrapMethod.resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DynamicCallSiteDesc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -255,1 +255,1 @@\n-            MethodHandle bsm = (MethodHandle) bootstrapMethod.resolveConstantDesc(lookup);\n+            MethodHandle bsm = bootstrapMethod.resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DynamicConstantDesc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,0 +207,3 @@\n+    @Override\n+    MethodHandle resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodHandleDesc.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -191,0 +192,10 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @apiNote {@linkplain MethodTypeDesc} can represent method type descriptors\n+     * that are not representable by {@linkplain MethodType}, such as methods with\n+     * more than 255 parameter slots, so attempts to resolve these may result in errors.\n+     *\/\n+    @Override\n+    MethodType resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/MethodTypeDesc.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}