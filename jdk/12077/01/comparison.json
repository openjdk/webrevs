{"files":[{"patch":"@@ -2464,0 +2464,3 @@\n+            public int countPositives(byte[] bytes, int offset, int length) {\n+                return StringCoding.countPositives(bytes, offset, length);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.util.ArraysSupport;\n@@ -212,1 +213,0 @@\n-\n@@ -214,15 +214,8 @@\n-            int h = 0;\n-            while (off < end) {\n-                byte b = a[off];\n-                if (b >= 0) {\n-                    \/\/ ASCII, keep going\n-                    h = 31 * h + b;\n-                    off++;\n-                } else {\n-                    \/\/ Non-ASCII, fall back to decoding a String\n-                    \/\/ We avoid using decoder() here since the UTF8ZipCoder is\n-                    \/\/ shared and that decoder is not thread safe.\n-                    \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n-                    \/\/ exceptions eagerly when opening ZipFiles\n-                    return hash(JLA.newStringUTF8NoRepl(a, end - len, len));\n-                }\n+            int asciiLen = JLA.countPositives(a, off, len);\n+            if (asciiLen != len) {\n+                \/\/ Non-ASCII, fall back to decoding a String\n+                \/\/ We avoid using decoder() here since the UTF8ZipCoder is\n+                \/\/ shared and that decoder is not thread safe.\n+                \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n+                \/\/ exceptions eagerly when opening ZipFiles\n+                return hash(JLA.newStringUTF8NoRepl(a, off, len));\n@@ -230,1 +223,2 @@\n-\n+            \/\/ T_BOOLEAN to treat the array as unsigned bytes, in line with StringLatin1.hashCode\n+            int h = ArraysSupport.vectorizedHashCode(a, off, len, 0, ArraysSupport.T_BOOLEAN);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":11,"deletions":17,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -305,0 +305,5 @@\n+    \/**\n+     * Count the number of leading positive bytes in the range.\n+     *\/\n+    int countPositives(byte[] ba, int off, int len);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.util.zip;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.concurrent.TimeUnit;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+\/**\n+ * Simple benchmark measuring cost of opening zip files, parsing CEN\n+ * entries.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class ZipFileOpen {\n+\n+    @Param({\"512\", \"1024\"})\n+    private int size;\n+\n+    public File zipFile;\n+\n+    @Setup(Level.Trial)\n+    public void beforeRun() throws IOException {\n+        \/\/ Create a test Zip file with the number of entries.\n+        File tempFile = Files.createTempFile(\"zip-micro\", \".zip\").toFile();\n+        tempFile.deleteOnExit();\n+        try (FileOutputStream fos = new FileOutputStream(tempFile);\n+             ZipOutputStream zos = new ZipOutputStream(fos)) {\n+\n+            \/\/ Vary dir and entry sizes, with a bias towards shorter entries.\n+            String[] dirPrefixes = new String[] { \"dir1\", \"dir2\", \"dir3\",\n+                    \"longer-directory-name-\", \"ridiculously-long-pathname-to-help-exercize-vectorized-subroutines-\"};\n+            String[] entryPrefixes = new String[] { \"e\", \"long-entry-name-\",\n+                    \"ridiculously-long-entry-name-to-help-exercize-vectorized-subroutines-\"};\n+\n+            for (int i = 0; i < size; i++) {\n+                String ename = dirPrefixes[i % dirPrefixes.length] + i + \"\/\";\n+                zos.putNextEntry(new ZipEntry(ename));\n+\n+                ename += entryPrefixes[i % entryPrefixes.length] + \"-\" + i;\n+                zos.putNextEntry(new ZipEntry(ename));\n+            }\n+        }\n+        zipFile = tempFile;\n+    }\n+\n+    @Benchmark\n+    public ZipFile openCloseZipFile() throws Exception {\n+        \/\/ Some shared resources in ZipFile are cached in a shared structure\n+        \/\/ and needs to be cleaned up to properly capture overhead of creating\n+        \/\/ a ZipFile - otherwise opening the same zip file again will reuse the\n+        \/\/ cached data and look artificially fast. By including the ZipFile.close()\n+        \/\/ we aggressively clear those resources pre-emptively. The operations\n+        \/\/ appears to be complex enough to not be subject to DCE but care needs\n+        \/\/ to be taken to check that things like initCEN is properly accounted\n+        \/\/ for if\/when the ZipFile setup improves.\n+        ZipFile zf = new ZipFile(zipFile);\n+        zf.close();\n+        return zf;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/zip\/ZipFileOpen.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}