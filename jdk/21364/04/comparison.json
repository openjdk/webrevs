{"files":[{"patch":"@@ -71,0 +71,24 @@\n+    \/**\n+     * The ML-DSA-44 parameters\n+     *\n+     * @since 24\n+     *\/\n+    public static final NamedParameterSpec ML_DSA_44\n+        = new NamedParameterSpec(\"ML-DSA-44\");\n+\n+    \/**\n+     * The ML-DSA-65 parameters\n+     *\n+     * @since 24\n+     *\/\n+    public static final NamedParameterSpec ML_DSA_65\n+        = new NamedParameterSpec(\"ML-DSA-65\");\n+\n+    \/**\n+     * The ML-DSA-87 parameters\n+     *\n+     * @since 24\n+     *\/\n+    public static final NamedParameterSpec ML_DSA_87\n+        = new NamedParameterSpec(\"ML-DSA-87\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/NamedParameterSpec.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,1427 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import sun.security.provider.SHA3.SHAKE128;\n+import sun.security.provider.SHA3.SHAKE256;\n+\n+import java.util.Arrays;\n+\n+public class ML_DSA {\n+    private static final int mlDsa_q = 8380417;\n+    private static final int mlDsa_n = 256;\n+    private static final int shake256BlockSize = 136; \/\/ the block length for SHAKE256\n+    private static final int montRBits = 32;\n+    private static final long montR = 4294967296L; \/\/ 1 << montRBits\n+    private static final int montQ = 8380417;\n+    private static final int montRSquareModQ = 2365951;\n+    private static final int montQInvModR = 58728449;\n+    private static final int montRModQ = 4193792;\n+    private static final int montDimInverse = 16382; \/\/ toMont((mlDsa_n)^-1 (mod mlDsa_q))\n+    private static final int[] montZetasForNtt = new int[]{\n+        25847, -2608894, -518909, 237124, -777960, -876248, 466468, 1826347,\n+        2353451, -359251, -2091905, 3119733, -2884855, 3111497, 2680103, 2725464,\n+        1024112, -1079900, 3585928, -549488, -1119584, 2619752, -2108549, -2118186,\n+        -3859737, -1399561, -3277672, 1757237, -19422, 4010497, 280005, 2706023,\n+        95776, 3077325, 3530437, -1661693, -3592148, -2537516, 3915439, -3861115,\n+        -3043716, 3574422, -2867647, 3539968, -300467, 2348700, -539299, -1699267,\n+        -1643818, 3505694, -3821735, 3507263, -2140649, -1600420, 3699596, 811944,\n+        531354, 954230, 3881043, 3900724, -2556880, 2071892, -2797779, -3930395,\n+        -1528703, -3677745, -3041255, -1452451, 3475950, 2176455, -1585221, -1257611,\n+        1939314, -4083598, -1000202, -3190144, -3157330, -3632928, 126922, 3412210,\n+        -983419, 2147896, 2715295, -2967645, -3693493, -411027, -2477047, -671102,\n+        -1228525, -22981, -1308169, -381987, 1349076, 1852771, -1430430, -3343383,\n+        264944, 508951, 3097992, 44288, -1100098, 904516, 3958618, -3724342,\n+        -8578, 1653064, -3249728, 2389356, -210977, 759969, -1316856, 189548,\n+        -3553272, 3159746, -1851402, -2409325, -177440, 1315589, 1341330, 1285669,\n+        -1584928, -812732, -1439742, -3019102, -3881060, -3628969, 3839961, 2091667,\n+        3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462, 266997,\n+        2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378, 900702,\n+        1859098, 909542, 819034, 495491, -1613174, -43260, -522500, -655327,\n+        -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838, 342297,\n+        286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044, 2842341,\n+        2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974, -3767016,\n+        1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970, -1333058,\n+        1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642, -1279661,\n+        1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031, -542412,\n+        -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993, -2013608,\n+        2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385, -3183426,\n+        162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107, -3038916,\n+        3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078, -426683,\n+        1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893, -2939036,\n+        -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687, -554416,\n+        3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782\n+    };\n+    private static final int[] montZetasForInverseNtt = new int[]{\n+        -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,\n+        3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,\n+        3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,\n+        -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,\n+        1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,\n+        1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,\n+        3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,\n+        -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,\n+        1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,\n+        1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,\n+        -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,\n+        -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,\n+        3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,\n+        522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,\n+        3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,\n+        3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,\n+        -3839961, 3628969, 3881060, 3019102, 1439742, 812732, 1584928, -1285669,\n+        -1341330, -1315589, 177440, 2409325, 1851402, -3159746, 3553272, -189548,\n+        1316856, -759969, 210977, -2389356, 3249728, -1653064, 8578, 3724342,\n+        -3958618, -904516, 1100098, -44288, -3097992, -508951, -264944, 3343383,\n+        1430430, -1852771, -1349076, 381987, 1308169, 22981, 1228525, 671102,\n+        2477047, 411027, 3693493, 2967645, -2715295, -2147896, 983419, -3412210,\n+        -126922, 3632928, 3157330, 3190144, 1000202, 4083598, -1939314, 1257611,\n+        1585221, -2176455, -3475950, 1452451, 3041255, 3677745, 1528703, 3930395,\n+        2797779, -2071892, 2556880, -3900724, -3881043, -954230, -531354, -811944,\n+        -3699596, 1600420, 2140649, -3507263, 3821735, -3505694, 1643818, 1699267,\n+        539299, -2348700, 300467, -3539968, 2867647, -3574422, 3043716, 3861115,\n+        -3915439, 2537516, 3592148, 1661693, -3530437, -3077325, -95776, -2706023,\n+        -280005, -4010497, 19422, -1757237, 3277672, 1399561, 3859737, 2118186,\n+        2108549, -2619752, 1119584, 549488, -3585928, 1079900, -1024112, -2725464,\n+        -2680103, -3111497, 2884855, -3119733, 2091905, 359251, -2353451, -1826347,\n+        -466468, 876248, 777960, -237124, 518909, 2608894, -25847\n+    };\n+\n+    private static final int[] montZetasForVectorNtt = new int[]{\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+\n+        1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,\n+        1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,\n+        2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,\n+        2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,\n+        -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,\n+        -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,\n+        -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,\n+        -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,\n+        3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,\n+        3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,\n+        -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,\n+        -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,\n+        3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,\n+        3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,\n+        2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,\n+        2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,\n+\n+        2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464,\n+        1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112,\n+        -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900,\n+        3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928,\n+        -549488, -549488, -549488, -549488, -549488, -549488, -549488, -549488,\n+        -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584,\n+        2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752,\n+        -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549,\n+        -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186,\n+        -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737,\n+        -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561,\n+        -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672,\n+        1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237,\n+        -19422, -19422, -19422, -19422, -19422, -19422, -19422, -19422,\n+        4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497,\n+        280005, 280005, 280005, 280005, 280005, 280005, 280005, 280005,\n+\n+        2706023, 2706023, 2706023, 2706023, 95776, 95776, 95776, 95776,\n+        3077325, 3077325, 3077325, 3077325, 3530437, 3530437, 3530437, 3530437,\n+        -1661693, -1661693, -1661693, -1661693, -3592148, -3592148, -3592148, -3592148,\n+        -2537516, -2537516, -2537516, -2537516, 3915439, 3915439, 3915439, 3915439,\n+        -3861115, -3861115, -3861115, -3861115, -3043716, -3043716, -3043716, -3043716,\n+        3574422, 3574422, 3574422, 3574422, -2867647, -2867647, -2867647, -2867647,\n+        3539968, 3539968, 3539968, 3539968, -300467, -300467, -300467, -300467,\n+        2348700, 2348700, 2348700, 2348700, -539299, -539299, -539299, -539299,\n+        -1699267, -1699267, -1699267, -1699267, -1643818, -1643818, -1643818, -1643818,\n+        3505694, 3505694, 3505694, 3505694, -3821735, -3821735, -3821735, -3821735,\n+        3507263, 3507263, 3507263, 3507263, -2140649, -2140649, -2140649, -2140649,\n+        -1600420, -1600420, -1600420, -1600420, 3699596, 3699596, 3699596, 3699596,\n+        811944, 811944, 811944, 811944, 531354, 531354, 531354, 531354,\n+        954230, 954230, 954230, 954230, 3881043, 3881043, 3881043, 3881043,\n+        3900724, 3900724, 3900724, 3900724, -2556880, -2556880, -2556880, -2556880,\n+        2071892, 2071892, 2071892, 2071892, -2797779, -2797779, -2797779, -2797779,\n+\n+        -3930395, -3930395, -1528703, -1528703, -3677745, -3677745, -3041255, -3041255,\n+        -1452451, -1452451, 3475950, 3475950, 2176455, 2176455, -1585221, -1585221,\n+        -1257611, -1257611, 1939314, 1939314, -4083598, -4083598, -1000202, -1000202,\n+        -3190144, -3190144, -3157330, -3157330, -3632928, -3632928, 126922, 126922,\n+        3412210, 3412210, -983419, -983419, 2147896, 2147896, 2715295, 2715295,\n+        -2967645, -2967645, -3693493, -3693493, -411027, -411027, -2477047, -2477047,\n+        -671102, -671102, -1228525, -1228525, -22981, -22981, -1308169, -1308169,\n+        -381987, -381987, 1349076, 1349076, 1852771, 1852771, -1430430, -1430430,\n+        -3343383, -3343383, 264944, 264944, 508951, 508951, 3097992, 3097992,\n+        44288, 44288, -1100098, -1100098, 904516, 904516, 3958618, 3958618,\n+        -3724342, -3724342, -8578, -8578, 1653064, 1653064, -3249728, -3249728,\n+        2389356, 2389356, -210977, -210977, 759969, 759969, -1316856, -1316856,\n+        189548, 189548, -3553272, -3553272, 3159746, 3159746, -1851402, -1851402,\n+        -2409325, -2409325, -177440, -177440, 1315589, 1315589, 1341330, 1341330,\n+        1285669, 1285669, -1584928, -1584928, -812732, -812732, -1439742, -1439742,\n+        -3019102, -3019102, -3881060, -3881060, -3628969, -3628969, 3839961, 3839961,\n+\n+        2091667, 3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462,\n+        266997, 2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378,\n+        900702, 1859098, 909542, 819034, 495491, -1613174, -43260, -522500,\n+        -655327, -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838,\n+        342297, 286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044,\n+        2842341, 2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974,\n+        -3767016, 1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970,\n+        -1333058, 1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642,\n+        -1279661, 1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031,\n+        -542412, -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993,\n+        -2013608, 2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385,\n+        -3183426, 162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107,\n+        -3038916, 3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078,\n+        -426683, 1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893,\n+        -2939036, -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687,\n+        -554416, 3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782\n+    };\n+\n+    private static final int[] montZetasForVectorInverseNtt = new int[]{\n+        -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,\n+        3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,\n+        3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,\n+        -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,\n+        1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,\n+        1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,\n+        3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,\n+        -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,\n+        1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,\n+        1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,\n+        -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,\n+        -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,\n+        3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,\n+        522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,\n+        3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,\n+        3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,\n+\n+        -3839961, -3839961, 3628969, 3628969, 3881060, 3881060, 3019102, 3019102,\n+        1439742, 1439742, 812732, 812732, 1584928, 1584928, -1285669, -1285669,\n+        -1341330, - 1341330, -1315589, -1315589, 177440, 177440, 2409325, 2409325,\n+        1851402, 1851402, -3159746, -3159746, 3553272, 3553272, -189548, -189548,\n+        1316856, 1316856, -759969, -759969, 210977, 210977, -2389356, -2389356,\n+        3249728, 3249728, -1653064, -1653064, 8578, 8578, 3724342, 3724342,\n+        -3958618, -3958618, -904516, -904516, 1100098, 1100098, -44288, -44288,\n+        -3097992, -3097992, -508951, -508951, -264944, -264944, 3343383, 3343383,\n+        1430430, 1430430, -1852771, -1852771, -1349076, -1349076, 381987, 381987,\n+        1308169, 1308169, 22981, 22981, 1228525, 1228525, 671102, 671102,\n+        2477047, 2477047, 411027, 411027, 3693493, 3693493, 2967645, 2967645,\n+        -2715295, -2715295, -2147896, -2147896, 983419, 983419, -3412210, -3412210,\n+        -126922, -126922, 3632928, 3632928, 3157330, 3157330, 3190144, 3190144,\n+        1000202, 1000202, 4083598, 4083598, -1939314, -1939314, 1257611, 1257611,\n+        1585221, 1585221, -2176455, -2176455, -3475950, -3475950, 1452451, 1452451,\n+        3041255, 3041255, 3677745, 3677745, 1528703, 1528703, 3930395, 3930395,\n+\n+        2797779, 2797779, 2797779, 2797779, -2071892, -2071892, -2071892, -2071892,\n+        2556880, 2556880, 2556880, 2556880, -3900724, -3900724, -3900724, -3900724,\n+        -3881043, -3881043, -3881043, -3881043, -954230, -954230, -954230, -954230,\n+        -531354, -531354, -531354, -531354, -811944, -811944, -811944, -811944,\n+        -3699596, -3699596, -3699596, -3699596, 1600420, 1600420, 1600420, 1600420,\n+        2140649, 2140649, 2140649, 2140649, -3507263, -3507263, -3507263, -3507263,\n+        3821735, 3821735, 3821735, 3821735, -3505694, -3505694, -3505694, -3505694,\n+        1643818, 1643818, 1643818, 1643818, 1699267, 1699267, 1699267, 1699267,\n+        539299, 539299, 539299, 539299, -2348700, -2348700, -2348700, -2348700,\n+        300467, 300467, 300467, 300467, -3539968, -3539968, -3539968, -3539968,\n+        2867647, 2867647, 2867647, 2867647, -3574422, -3574422, -3574422, -3574422,\n+        3043716, 3043716, 3043716, 3043716, 3861115, 3861115, 3861115, 3861115,\n+        -3915439, -3915439, -3915439, -3915439, 2537516, 2537516, 2537516, 2537516,\n+        3592148, 3592148, 3592148, 3592148, 1661693, 1661693, 1661693, 1661693,\n+        -3530437, -3530437, -3530437, -3530437, -3077325, -3077325, -3077325, -3077325,\n+        -95776, -95776, -95776, -95776, -2706023, -2706023, -2706023, -2706023,\n+\n+        -280005, -280005, -280005, -280005, -280005, -280005, -280005, -280005,\n+        -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497,\n+        19422, 19422, 19422, 19422, 19422, 19422, 19422, 19422,\n+        -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237,\n+        3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672,\n+        1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561,\n+        3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737,\n+        2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186,\n+        2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549,\n+        -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752,\n+        1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584,\n+        549488, 549488, 549488, 549488, 549488, 549488, 549488, 549488,\n+        -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928,\n+        1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900,\n+        -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112,\n+        -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464,\n+\n+        -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,\n+        -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,\n+        -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,\n+        -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,\n+        2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,\n+        2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,\n+        -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,\n+        -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,\n+        2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,\n+        2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,\n+        359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,\n+        359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,\n+        -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,\n+        -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,\n+        -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,\n+        -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,\n+\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847\n+    };\n+    private final int mlDsaASeedLength = 32;\n+    private final int mlDsaS1S2SeedLength = 64;\n+    private final int mlDsaKLength = 32;\n+    private final int mlDsaTrLength = 64;\n+    private final int mlDsaMuLength = 64;\n+    private final int mlDsaMaskSeedLength = 64;\n+    private static final int mlDsa_d = 13;\n+    private static final int dMask = (1 << mlDsa_d) - 1;\n+    private final int tau;\n+    private final int lambda;\n+    private final int gamma1;\n+    private final int gamma1Bits;\n+    private final int gamma2;\n+    private final int mlDsa_k;\n+    private final int mlDsa_l;\n+    private final int eta;\n+    private final int beta;\n+    private final int omega;\n+    private final int s1PackedLength;\n+    private final int s2PackedLength;\n+    private final int s1s2CoeffSize;\n+    private final int t0CoeffSize = 13;\n+    private final int privateKeyLength;\n+    private final int publicKeyLength;\n+    private final int signatureLength;\n+    private final int wCoeffSize;\n+    private final int level;\n+\n+    public ML_DSA(int security_level) {\n+        switch (security_level) {\n+            case 2:\n+                level = 2;\n+                tau = 39;\n+                lambda = 128;\n+                gamma1 = 1 << 17;\n+                gamma1Bits = 17;\n+                gamma2 = (mlDsa_q - 1) \/ 88;\n+                mlDsa_k = 4;\n+                mlDsa_l = 4;\n+                eta = 2;\n+                beta = 78;\n+                omega = 80;\n+                privateKeyLength = 0;\n+                publicKeyLength = 1312;\n+                signatureLength = 2420;\n+                s1PackedLength = 384;\n+                s2PackedLength = 384;\n+                s1s2CoeffSize = 3;\n+                wCoeffSize = 6;\n+                break;\n+            case 3:\n+                level = 3;\n+                tau = 49;\n+                lambda = 192;\n+                gamma1 = 1 << 19;\n+                gamma1Bits = 19;\n+                gamma2 = (mlDsa_q - 1) \/ 32;\n+                mlDsa_k = 6;\n+                mlDsa_l = 5;\n+                eta = 4;\n+                beta = 196;\n+                omega = 55;\n+                privateKeyLength = 0;\n+                publicKeyLength = 1952;\n+                signatureLength = 3293;\n+                s1PackedLength = 640;\n+                s2PackedLength = 768;\n+                s1s2CoeffSize = 4;\n+                wCoeffSize = 4;\n+                break;\n+            case 5:\n+                level = 4;\n+                tau = 60;\n+                lambda = 256;\n+                gamma1 = 1 << 19;\n+                gamma1Bits = 19;\n+                gamma2 = (mlDsa_q - 1) \/ 32;\n+                mlDsa_k = 8;\n+                mlDsa_l = 7;\n+                eta = 2;\n+                beta = 120;\n+                omega = 75;\n+                privateKeyLength = 0;\n+                publicKeyLength = 2592;\n+                signatureLength = 4595;\n+                s1PackedLength = 672;\n+                s2PackedLength = 768;\n+                s1s2CoeffSize = 3;\n+                wCoeffSize = 4;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Wrong security level\");\n+        }\n+    }\n+\n+    public record ML_DSA_PrivateKey(byte[] rho, byte[] k, byte[] tr, int[][] s1, int[][] s2, int[][] t0) {\n+    }\n+\n+    public record ML_DSA_PublicKey(byte[] rho, int[][] t1) {\n+    }\n+\n+    public record ML_DSA_KeyPair(ML_DSA_PrivateKey privateKey, ML_DSA_PublicKey publicKey) {\n+    }\n+\n+    public record ML_DSA_Signature(byte[] commitmentHash, int[][] response, boolean[][] hint) {\n+    }\n+\n+    \/\/Internal functions in Section 6 of specification\n+    public ML_DSA_KeyPair generateKeyPairInternal(byte[] randomBytes) {\n+        \/\/Initialize hash functions\n+        var hash = new SHAKE256(0);\n+        var crHash = new SHAKE256(mlDsaTrLength);\n+\n+        \/\/Expand seed\n+        hash.update(randomBytes);\n+        hash.update((byte)mlDsa_k);\n+        hash.update((byte)mlDsa_l);\n+        byte[] rho = hash.squeeze(mlDsaASeedLength);\n+        byte[] rhoPrime = hash.squeeze(mlDsaS1S2SeedLength);\n+        byte[] k = hash.squeeze(mlDsaKLength);\n+        hash.reset();\n+\n+        \/\/Sample A\n+        int[][][] keygenA = generateA(rho); \/\/A is in NTT domain\n+\n+        \/\/Sample S1 and S2\n+        int[][] s1 = new int[mlDsa_l][mlDsa_n];\n+        int[][] s2 = new int[mlDsa_k][mlDsa_n];\n+        sampleS1S2(s1, s2, hash, rhoPrime); \/\/hash is reset before being used in sampleS1S2\n+\n+        \/\/Compute t and tr\n+        mlDsaVectorNtt(s1); \/\/s1 now in NTT domain\n+        int[][] As1 = matrixVectorPointwiseMultiply(keygenA, s1);\n+        mlDsaVectorInverseNtt(s1); \/\/take s1 out of NTT domain\n+\n+        mlDsaVectorInverseNtt(As1);\n+        int[][] t = vectorAddPos(As1, s2);\n+        int[][] t0 = new int[mlDsa_k][mlDsa_n];\n+        int[][] t1 = new int[mlDsa_k][mlDsa_n];\n+        power2Round(t, t0, t1);\n+\n+        \/\/Encode PK and SK\n+        ML_DSA_PublicKey pk = new ML_DSA_PublicKey(rho, t1);\n+        byte[] publicKeyBytes = pkEncode(pk);\n+        crHash.update(publicKeyBytes);\n+        byte[] tr = crHash.digest();\n+        ML_DSA_PrivateKey sk = new ML_DSA_PrivateKey(rho, k, tr, s1, s2, t0);\n+\n+        return new ML_DSA_KeyPair(sk, pk);\n+    }\n+\n+    public ML_DSA_Signature signInternal(byte[] message, byte[] rnd, byte[] skBytes) {\n+        \/\/Decode private key and initialize hash function\n+        ML_DSA_PrivateKey sk = skDecode(skBytes);\n+        var hash = new SHAKE256(0);\n+\n+        \/\/Do some NTTs\n+        mlDsaVectorNtt(sk.s1());\n+        mlDsaVectorNtt(sk.s2());\n+        mlDsaVectorNtt(sk.t0());\n+        int[][][] aHat = generateA(sk.rho());\n+\n+        \/\/Compute mu\n+        hash.update(sk.tr());\n+        hash.update(message);\n+        byte[] mu = hash.squeeze(mlDsaMuLength);\n+        hash.reset();\n+\n+        \/\/Compute rho'\n+        hash.update(sk.k());\n+        hash.update(rnd);\n+        hash.update(mu);\n+        byte[] rhoDoublePrime = hash.squeeze(mlDsaMaskSeedLength);\n+        hash.reset();\n+\n+        \/\/Initialize vectors used in loop\n+        int[][] z = null;\n+        boolean[][] h = null;\n+        byte[] commitmentHash = new byte[lambda\/4];\n+\n+        int kappa = 0;\n+        while (true) {\n+            int[][] y = expandMask(rhoDoublePrime, kappa);\n+\n+            \/\/Compute w and w1\n+            mlDsaVectorNtt(y); \/\/y is now in NTT domain\n+            int[][] w = matrixVectorPointwiseMultiply(aHat, y);\n+            mlDsaVectorInverseNtt(w); \/\/w is now in normal domain\n+            int[][] w0 = new int[mlDsa_k][mlDsa_n];\n+            int[][] w1 = new int[mlDsa_k][mlDsa_n];\n+            decompose(w, w0, w1);\n+            mlDsaVectorInverseNtt(y);\n+\n+            \/\/Get commitment hash\n+            hash.update(mu);\n+            hash.update(simpleBitPack(wCoeffSize, w1));\n+            commitmentHash = hash.squeeze(lambda\/4);\n+            hash.reset();\n+\n+            \/\/Get z and r0\n+            int[] c = sampleInBall(commitmentHash);\n+            mlDsaNtt(c); \/\/c is now in NTT domain\n+            int[][] cs1 = nttConstMultiply(c, sk.s1());\n+            int[][] cs2 = nttConstMultiply(c, sk.s2());\n+            mlDsaVectorInverseNtt(cs1);\n+            mlDsaVectorInverseNtt(cs2);\n+            z = vectorAdd(y, cs1);\n+            int[][] r0 = vectorSub(w0, cs2);\n+\n+            \/\/Update z and h\n+            kappa += mlDsa_l;\n+            if (vectorNormBound(z, gamma1 - beta) || vectorNormBound(r0, gamma2 - beta)) {\n+                continue;\n+            } else {\n+                int[][] ct0 = nttConstMultiply(c, sk.t0());\n+                mlDsaVectorInverseNtt(ct0);\n+                h = makeHint(vectorConstMul(-1, ct0), vectorAdd(vectorAdd(w, vectorConstMul(-1, cs2)), ct0));\n+                if (vectorNormBound(ct0, gamma2) || (hammingWeight(h) > omega)) {\n+                    continue;\n+                }\n+            }\n+            return new ML_DSA_Signature(commitmentHash, z, h);\n+        }\n+    }\n+\n+    public boolean verifyInternal(byte[] pkBytes, byte[] message, byte[] sigBytes) {\n+        \/\/Decode sig and initialize hash\n+        ML_DSA_Signature sig = sigDecode(sigBytes);\n+        var hash = new SHAKE256(0);\n+\n+        \/\/Check hint encoding\n+        if (sig.hint() == null) {return false;}\n+\n+        \/\/Decode pk\n+        ML_DSA_PublicKey pk = pkDecode(pkBytes);\n+\n+        \/\/Expand A\n+        int[][][] aHat = generateA(pk.rho());\n+\n+        \/\/Generate tr\n+        hash.update(pkBytes);\n+        byte[] tr = hash.squeeze(mlDsaTrLength);\n+        hash.reset();\n+\n+        \/\/Generate mu\n+        hash.update(tr);\n+        hash.update(message);\n+        byte[] mu = hash.squeeze(mlDsaMuLength);\n+        hash.reset();\n+\n+        \/\/Get verifiers challenge\n+        int[] cHat = sampleInBall(sig.commitmentHash());\n+        mlDsaNtt(cHat);\n+\n+        \/\/Compute response norm and put it in NTT domain\n+        boolean zNorm = vectorNormBound(sig.response(), gamma1 - beta);\n+        mlDsaVectorNtt(sig.response());\n+\n+        \/\/Reconstruct signer's commitment\n+        int[][] aHatZ = matrixVectorPointwiseMultiply(aHat, sig.response());\n+        int[][] t1Hat = vectorConstMul(1 << mlDsa_d, pk.t1());\n+        mlDsaVectorNtt(t1Hat);\n+        int[][] wApprox = vectorSub(aHatZ,nttConstMultiply(cHat, t1Hat));\n+        mlDsaVectorInverseNtt(wApprox);\n+        int[][] w1Prime = useHint(sig.hint(), wApprox);\n+\n+        \/\/Hash signer's commitment\n+        hash.update(mu);\n+        hash.update(simpleBitPack(wCoeffSize, w1Prime));\n+        byte[] cTildePrime = hash.squeeze(lambda\/4);\n+\n+        \/\/Check verify conditions\n+        boolean hashEq = Arrays.equals(sig.commitmentHash(), cTildePrime);\n+        return !zNorm && hashEq;\n+    }\n+\n+    \/*\n+    Data conversion functions in Section 7.1 of specification\n+     *\/\n+\n+    \/\/ Bit-pack the t1 and w1 vector into a byte array.\n+    \/\/ The coefficients of the polynomials in the vector should be nonnegative and less than 2^bitsPerCoeff .\n+    public byte[] simpleBitPack(int bitsPerCoeff, int[][] vector) {\n+        byte[] result = new byte[(mlDsa_k * mlDsa_n * bitsPerCoeff) \/ 8];\n+        int acc = 0;\n+        int shift = 0;\n+        int i = 0;\n+        for (int[] poly : vector) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                acc += (poly[m] << shift);\n+                shift += bitsPerCoeff;\n+                while (shift >= 8) {\n+                    result[i++] = (byte) acc;\n+                    acc >>= 8;\n+                    shift -= 8;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public byte[] bitPack(int[][] vector, int bitsPerCoeff, int maxValue) {\n+        int vecLen = vector.length;\n+        byte[] result = new byte[(vecLen * mlDsa_n * bitsPerCoeff) \/ 8];\n+        int acc = 0;\n+        int shift = 0;\n+        int i = 0;\n+        for (int[] poly : vector) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                acc += (maxValue - poly[m]) << shift;\n+                shift += bitsPerCoeff;\n+                while (shift >= 8) {\n+                    result[i++] = (byte) acc;\n+                    acc >>= 8;\n+                    shift -= 8;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public int[][] t1Unpack(byte[] v) {\n+        int[][] t1 = new int[mlDsa_k][mlDsa_n];\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_n \/ 4; j++) {\n+                int tOffset = j*4;\n+                int vOffset = (i*320) + (j*5);\n+                t1[i][tOffset] = (v[vOffset] & 0xFF) + ((v[vOffset+1] << 8) & 0x3FF);\n+                t1[i][tOffset+1] = ((v[vOffset+1] >> 2) & 0x3F) + ((v[vOffset+2] << 6) & 0x3FF);\n+                t1[i][tOffset+2] = ((v[vOffset+2] >> 4) & 0xF) + ((v[vOffset+3] << 4) & 0x3FF);\n+                t1[i][tOffset+3] = ((v[vOffset+3] >> 6) & 0x3) + ((v[vOffset+4] << 2) & 0x3FF);\n+            }\n+        }\n+        return t1;\n+    }\n+\n+    public int[][] bitUnpack(byte[] v, int dim, int maxValue, int bitsPerCoeff) {\n+        int[][] res = new int[dim][mlDsa_n];\n+\n+        int mask = (1 << bitsPerCoeff) - 1;\n+        int top = 0;\n+        int shift = 0;\n+        int acc = 0;\n+        int index = 0;\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                while (top - shift < bitsPerCoeff) {\n+                    acc += ((v[index++] & 0xff) << top);\n+                    top += 8;\n+                }\n+                res[i][j] = maxValue - ((acc >> shift) & mask);\n+                shift += bitsPerCoeff;\n+                while (shift >= 8) {\n+                    top -= 8;\n+                    shift -= 8;\n+                    acc >>>= 8;\n+                }\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private byte[] hintBitPack(boolean[][] h) {\n+        byte[] y = new byte[omega + mlDsa_k];\n+        int idx = 0;\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                if (h[i][j]) {\n+                    y[idx] = (byte)j;\n+                    idx++;\n+                }\n+            }\n+            y[omega + i] = (byte)idx;\n+        }\n+        return y;\n+    }\n+\n+    private boolean[][] hintBitUnpack(byte[] y) {\n+        boolean[][] h = new boolean[mlDsa_k][mlDsa_n];\n+        int idx = 0;\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            int j = y[omega + i];\n+            if (j < idx || j > omega) {\n+                return null;\n+            }\n+            int first = idx;\n+            while (idx < j) {\n+                if (idx > first) {\n+                    if ((y[idx - 1] & 0xff) >= (y[idx] & 0xff)) {\n+                        return null;\n+                    }\n+                }\n+                int hintIndex = y[idx] & 0xff;\n+                h[i][hintIndex] = true;\n+                idx++;\n+            }\n+        }\n+\n+        while (idx < omega) {\n+            if (y[idx] != 0) {\n+                return null;\n+            }\n+            idx++;\n+        }\n+        return h;\n+    }\n+\n+    \/*\n+    Encoding functions as specified in Section 7.2 of the specification\n+     *\/\n+\n+    public byte[] pkEncode(ML_DSA_PublicKey key) {\n+        byte[] t1Packed = simpleBitPack(10, key.t1);\n+        byte[] publicKeyBytes = new byte[mlDsaASeedLength + t1Packed.length];\n+        System.arraycopy(key.rho, 0, publicKeyBytes, 0, mlDsaASeedLength);\n+        System.arraycopy(t1Packed, 0, publicKeyBytes, mlDsaASeedLength, t1Packed.length);\n+\n+        return publicKeyBytes;\n+    }\n+\n+    public ML_DSA_PublicKey pkDecode(byte[] pk) {\n+        byte[] rho = new byte[mlDsaASeedLength];\n+        System.arraycopy(pk, 0, rho, 0, mlDsaASeedLength);\n+\n+        byte[] v = Arrays.copyOfRange(pk, mlDsaASeedLength, pk.length);\n+        int[][] t1 = t1Unpack(v);\n+        return new ML_DSA_PublicKey(rho, t1);\n+    }\n+\n+    public byte[] skEncode(ML_DSA_PrivateKey key) {\n+\n+        byte[] s1Packed = bitPack(key.s1, s1s2CoeffSize, eta);\n+        byte[] s2Packed = bitPack(key.s2, s1s2CoeffSize, eta);\n+        byte[] t0Packed = bitPack(key.t0, t0CoeffSize, 1 << 12);\n+\n+        byte[] skBytes = new byte[mlDsaASeedLength + mlDsaKLength + key.tr.length +\n+            s1PackedLength + s2PackedLength + t0Packed.length];\n+\n+        System.arraycopy(key.rho, 0, skBytes, 0, mlDsaASeedLength);\n+        System.arraycopy(key.k, 0, skBytes, mlDsaASeedLength, mlDsaKLength);\n+        System.arraycopy(key.tr, 0, skBytes, mlDsaASeedLength + mlDsaKLength, mlDsaTrLength);\n+        System.arraycopy(s1Packed, 0, skBytes, mlDsaASeedLength + mlDsaKLength + key.tr.length, s1PackedLength);\n+        System.arraycopy(s2Packed, 0, skBytes, mlDsaASeedLength + mlDsaKLength + key.tr.length + s1PackedLength, s2PackedLength);\n+        System.arraycopy(t0Packed, 0, skBytes, mlDsaASeedLength + mlDsaKLength + key.tr.length + s1PackedLength + s2PackedLength, t0Packed.length);\n+\n+        return skBytes;\n+    }\n+\n+    public ML_DSA_PrivateKey skDecode(byte[] sk) {\n+        byte[] rho = new byte[mlDsaASeedLength];\n+        System.arraycopy(sk, 0, rho, 0, mlDsaASeedLength);\n+\n+        byte[] k = new byte[mlDsaKLength];\n+        System.arraycopy(sk, mlDsaASeedLength, k, 0, mlDsaKLength);\n+\n+        byte[] tr = new byte[mlDsaTrLength];\n+        System.arraycopy(sk, mlDsaASeedLength + mlDsaKLength, tr, 0, mlDsaTrLength);\n+\n+        \/\/Parse s1\n+        int start = mlDsaASeedLength + mlDsaKLength + mlDsaTrLength;\n+        int end = start + (32 * mlDsa_l * s1s2CoeffSize);\n+        byte[] y = Arrays.copyOfRange(sk, start, end);\n+        int[][] s1 = bitUnpack(y, mlDsa_l, eta, s1s2CoeffSize);\n+\n+        \/\/Parse s2\n+        start = end;\n+        end += 32 * s1s2CoeffSize * mlDsa_k;\n+        byte[] z = Arrays.copyOfRange(sk, start, end);\n+        int[][] s2 = bitUnpack(z, mlDsa_k, eta, s1s2CoeffSize);\n+\n+        \/\/Parse t0\n+        start = end;\n+        end += 32 * mlDsa_d * mlDsa_k;\n+        byte[] w = Arrays.copyOfRange(sk, start, end);\n+        int[][] t0 = bitUnpack(w, mlDsa_k, 1 << 12, t0CoeffSize);\n+\n+        return new ML_DSA_PrivateKey(rho, k, tr, s1, s2, t0);\n+    }\n+\n+    public byte[] sigEncode(ML_DSA_Signature sig) {\n+        int cSize = lambda \/ 4;\n+        int zSize = mlDsa_l * 32 * (1 + gamma1Bits);\n+\n+        byte[] zPacked = bitPack(sig.response, gamma1Bits + 1, gamma1);\n+        byte[] hPacked = hintBitPack(sig.hint);\n+\n+        byte[] sigBytes = new byte[cSize + zSize + omega + mlDsa_k];\n+        System.arraycopy(sig.commitmentHash, 0, sigBytes, 0, cSize);\n+        System.arraycopy(zPacked, 0, sigBytes, cSize, zSize);\n+        System.arraycopy(hPacked, 0, sigBytes, cSize + zSize, omega + mlDsa_k);\n+        return sigBytes;\n+    }\n+\n+    public ML_DSA_Signature sigDecode(byte[] sig) {\n+        \/\/Decode cTilde\n+        byte[] cTilde = Arrays.copyOfRange(sig, 0, lambda\/4);\n+\n+        \/\/Decode z\n+        int start = lambda \/ 4;\n+        int end = start + (32 * mlDsa_l * (1 + gamma1Bits));\n+        byte[] x = Arrays.copyOfRange(sig, start, end);\n+        int[][] z = bitUnpack(x, mlDsa_l, gamma1, gamma1Bits + 1);\n+\n+        \/\/Decode h\n+        start = end;\n+        end += omega + mlDsa_k;\n+        byte[] y = Arrays.copyOfRange(sig, start, end);\n+        boolean[][] h = hintBitUnpack(y);\n+        return new ML_DSA_Signature(cTilde, z, h);\n+    }\n+\n+    \/*\n+    Auxiliary functions defined in Section 7.3 of specification\n+     *\/\n+\n+    private class Shake256Slicer {\n+        SHAKE256 xof;\n+        byte[] block;\n+        int byteOffset;\n+        int current;\n+        int bitsInCurrent;\n+        int bitsPerCall;\n+        int bitMask;\n+\n+        Shake256Slicer(SHAKE256 xof, int bitsPerCall) {\n+            this.xof = xof;\n+            this.bitsPerCall = bitsPerCall;\n+            bitMask = (1 << bitsPerCall) - 1;\n+            current = 0;\n+            byteOffset = shake256BlockSize;\n+            bitsInCurrent = 0;\n+            block = new byte[shake256BlockSize];\n+        }\n+\n+        void reset() {\n+            xof.reset();\n+            current = 0;\n+            byteOffset = shake256BlockSize;\n+            bitsInCurrent = 0;\n+        }\n+\n+        int squeezeBits() {\n+            while (bitsInCurrent < bitsPerCall) {\n+                if (byteOffset == shake256BlockSize) {\n+                    xof.squeeze(block, 0, shake256BlockSize);\n+                    byteOffset = 0;\n+                }\n+                current += ((block[byteOffset++] & 0xff) << bitsInCurrent);\n+                bitsInCurrent += 8;\n+            }\n+            int result = current & bitMask;\n+            current >>= bitsPerCall;\n+            bitsInCurrent -= bitsPerCall;\n+            return result;\n+        }\n+    }\n+\n+    private int[] sampleInBall(byte[] rho) {\n+        var xof = new SHAKE256(0);\n+        Shake256Slicer slicer = new Shake256Slicer(xof, 8);\n+        xof.update(rho);\n+\n+        long parity = 0;\n+        for (int i = 0; i < 8; i++) {\n+            long sample = slicer.squeezeBits();\n+            parity |= sample << 8 * i;\n+        }\n+\n+        int[] c = new int[mlDsa_n];\n+        int k = 8;\n+        for (int i = 256 - tau; i < 256; i++) {\n+            \/\/Get random index < i\n+            int j = slicer.squeezeBits();\n+            while (j > i) {\n+                j = slicer.squeezeBits();\n+            }\n+\n+            \/\/Swap c[i] and c[j], set c[j] based on parity\n+            c[i] = c[j];\n+            c[j] = (int) (1 - 2 * (parity & 1));\n+            parity >>= 1;\n+        }\n+        return c;\n+    }\n+\n+    int[][][] generateA(byte[] seed) {\n+        int blockSize = 168;  \/\/ the size of one block of SHAKE128 output\n+        var xof = new SHAKE128(0);\n+        byte[] xofSeed = new byte[mlDsaASeedLength + 2];\n+        System.arraycopy(seed, 0, xofSeed, 0, mlDsaASeedLength);\n+        int[][][] a = new int[mlDsa_k][mlDsa_l][mlDsa_n];\n+\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_l; j++) {\n+                xofSeed[mlDsaASeedLength] = (byte) j;\n+                xofSeed[mlDsaASeedLength + 1] = (byte) i;\n+                xof.reset();\n+                xof.update(xofSeed);\n+\n+                byte[] rawAij = new byte[blockSize];\n+                int[] aij = new int[mlDsa_n];\n+                int ofs = 0;\n+                int rawOfs = blockSize;\n+                int tmp;\n+                while (ofs < mlDsa_n) {\n+                    if (rawOfs == blockSize) {  \/\/ works because 3 divides blockSize (=168)\n+                        xof.squeeze(rawAij, 0, blockSize);\n+                        rawOfs = 0;\n+                    }\n+                    tmp = (rawAij[rawOfs] & 0xFF) +\n+                        ((rawAij[rawOfs + 1] & 0xFF) << 8) +\n+                        ((rawAij[rawOfs + 2] & 0x7F) << 16);\n+                    rawOfs += 3;\n+                    if (tmp < mlDsa_q) {\n+                        aij[ofs] = tmp;\n+                        ofs++;\n+                    }\n+                }\n+                a[i][j] = aij;\n+            }\n+        }\n+        return a;\n+    }\n+\n+    private void sampleS1S2(int[][] s1, int[][] s2, SHAKE256 xof, byte[] rhoPrime) {\n+        byte[] seed = new byte[mlDsaS1S2SeedLength + 2];\n+        System.arraycopy(rhoPrime, 0, seed, 0, mlDsaS1S2SeedLength);\n+\n+        int bitsPerCall = 4;\n+        Shake256Slicer slicer = new Shake256Slicer(xof, bitsPerCall);\n+        for (int i = 0; i < mlDsa_l; i++) {\n+            seed[mlDsaS1S2SeedLength] = (byte) i;\n+            seed[mlDsaS1S2SeedLength + 1] = 0;\n+            slicer.reset();\n+            xof.update(seed);\n+            if (eta == 2) {\n+                for (int j = 0; j < mlDsa_n; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 14);\n+                    s1[i][j] = eta - sample + (205 * sample >> 10) * 5; \/\/ 2 - sample mod 5\n+                }\n+            } else { \/\/ eta == 4\n+                for (int j = 0; j < mlDsa_n; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 2 * eta);\n+                    s1[i][j] = eta - sample;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            seed[mlDsaS1S2SeedLength] = (byte) (mlDsa_l + i);\n+            seed[mlDsaS1S2SeedLength + 1] = 0;\n+            slicer.reset();\n+            xof.update(seed);\n+            if (eta == 2) {\n+                for (int j = 0; j < mlDsa_n; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 14);\n+                    s2[i][j] = eta - sample + (205 * sample >> 10) * 5;\n+                }\n+            } else {\n+                for (int j = 0; j < mlDsa_n; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 2 * eta);\n+                    s2[i][j] = eta - sample;\n+                }\n+            }\n+        }\n+    }\n+\n+    private int[][] expandMask(byte[] rho, int mu) {\n+        var xof = new SHAKE256(0);\n+\n+        int[][] res = new int[mlDsa_l][mlDsa_n];\n+        int c = 1 + gamma1Bits;\n+        byte[] v = new byte[mlDsa_l * 32 * c];\n+        for (int r = 0; r < mlDsa_l; r++) {\n+            int a = mu + r;\n+            byte[] n = {(byte) a, (byte) (a >> 8)};\n+\n+            xof.update(rho);\n+            xof.update(n);\n+            for (int i = 0; i < 32*c; i++) {\n+                v[r*32*c + i] = xof.squeeze(1)[0];\n+            }\n+            xof.reset();\n+        }\n+        return bitUnpack(v, mlDsa_l, gamma1, c);\n+    }\n+\n+    \/*\n+    Auxiliary functions defined in section 7.4 of specification\n+     *\/\n+\n+    private void power2Round(int[][] input, int[][] lowPart, int[][] highPart) {\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                int rplus = input[i][m];\n+                int r0 = input[i][m] & dMask;\n+                int r00 = (1 << (mlDsa_d - 1)) - r0 ; \/\/ 2^d\/2 - r+\n+                r0 -= (r00 >> 31) & (1 << mlDsa_d); \/\/0 if r+ < 2^d\/2\n+                lowPart[i][m] = r0;\n+                highPart[i][m] = (rplus - r0) >> mlDsa_d;\n+            }\n+        }\n+    }\n+\n+    private void decompose(int[][] input, int[][] lowPart, int[][] highPart) {\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                int rplus = (input[i][m] + mlDsa_q) % mlDsa_q;\n+                int r0 = rplus % (2*gamma2);\n+                r0 -= r0 > gamma2 ? 2*gamma2 : 0;\n+                int r1;\n+                if (rplus - r0 == mlDsa_q - 1) {\n+                    r1 = 0;\n+                    r0 = r0 - 1;\n+                } else {\n+                    r1 = (rplus - r0) \/ (2*gamma2);\n+                }\n+                lowPart[i][m] = r0;\n+                highPart[i][m] = r1;\n+            }\n+        }\n+    }\n+\n+    private int highBits(int input) {\n+        int rplus = (input + mlDsa_q) % mlDsa_q;\n+        int r0 = rplus % (2*gamma2);\n+        r0 -= r0 > gamma2 ? 2*gamma2 : 0;\n+        int r1;\n+        if (rplus - r0 == mlDsa_q - 1) {\n+            r1 = 0;\n+            r0 = r0 - 1;\n+        } else {\n+            r1 = (rplus - r0) \/ (2*gamma2);\n+        }\n+        return r1;\n+    }\n+\n+    private boolean[][] makeHint(int[][] z, int[][] r) {\n+        int[][] v1 = vectorAdd(r,z);\n+        boolean[][] res = new boolean[mlDsa_k][mlDsa_n];\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                int r1High = highBits(r[i][j]);\n+                int v1High = highBits(v1[i][j]);\n+                res[i][j] = r1High != v1High;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private int[][] useHint(boolean[][] h, int[][] r) {\n+        int m = (mlDsa_q - 1) \/ (2*gamma2);\n+        int[][] lowPart = new int[mlDsa_k][mlDsa_n];\n+        int[][] highPart = new int[mlDsa_k][mlDsa_n];\n+        decompose(r, lowPart, highPart);\n+\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                if (h[i][j]) {\n+                    highPart[i][j] += lowPart[i][j] > 0 ? 1 : -1;\n+                }\n+                highPart[i][j] = ((highPart[i][j] % m) + m) % m;\n+            }\n+        }\n+        return highPart;\n+    }\n+\n+    \/*\n+    NTT functions as specified in Section 7.5 of specification\n+    *\/\n+\n+    public static int[] mlDsaNtt(int[] coeffs) {\n+        int result = implMlDsaAlmostNtt(coeffs, montZetasForVectorNtt);\n+        int[] check = coeffs.clone();\n+        result = implMlDsaMontMulByConstant(coeffs,  montRModQ);\n+        return coeffs;\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implMlDsaAlmostNtt(int[] coeffs, int[] zetas) {\n+        return implMlDsaAlmostNttJava(coeffs);\n+    }\n+\n+    static int implMlDsaAlmostNttJava(int[] coeffs) {\n+        int dimension = mlDsa_n;\n+        int m = 0;\n+        for (int l = dimension \/ 2; l > 0; l \/= 2) {\n+            for (int s = 0; s < dimension; s += 2 * l) {\n+                for (int j = s; j < s + l; j++) {\n+                    int tmp = montMul(montZetasForNtt[m], coeffs[j + l]);\n+                    coeffs[j + l] = coeffs[j] - tmp;\n+                    coeffs[j] = coeffs[j] + tmp;\n+                }\n+                m++;\n+            }\n+        }\n+\n+        return 1;\n+    }\n+\n+    public static int[] mlDsaInverseNtt(int[] coeffs) {\n+        int result = implMlDsaAlmostInverseNtt(coeffs, montZetasForVectorInverseNtt);\n+        result = implMlDsaMontMulByConstant(coeffs, montDimInverse);\n+        return coeffs;\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implMlDsaAlmostInverseNtt(int[] coeffs, int[] zetas) {\n+        return implMlDsaAlmostInverseNttJava(coeffs);\n+    }\n+\n+    static int implMlDsaAlmostInverseNttJava(int[] coeffs) {\n+        int dimension = mlDsa_n;\n+        int m = 0;\n+        for (int l = 1; l < dimension; l *= 2) {\n+            for (int s = 0; s < dimension; s += 2 * l) {\n+                for (int j = s; j < s + l; j++) {\n+                    int tmp = coeffs[j];\n+                    coeffs[j] = (tmp + coeffs[j + l]);\n+                    coeffs[j + l] = montMul(tmp - coeffs[j + l], montZetasForInverseNtt[m]);\n+                }\n+                m++;\n+            }\n+        }\n+\n+        return 1;\n+    }\n+\n+    void mlDsaVectorNtt(int[][] vector) {\n+        for (int[] ints : vector) {\n+            mlDsaNtt(ints);\n+        }\n+    }\n+\n+    void mlDsaVectorInverseNtt(int[][] vector) {\n+        for (int[] ints : vector) {\n+            mlDsaInverseNtt(ints);\n+        }\n+    }\n+\n+    public static int[] mlDsaNttMultiply(int[] coeffs1, int[] coeffs2) {\n+        int[] product = new int[mlDsa_n];\n+        int result = implMlDsaNttMult(product, coeffs1, coeffs2);\n+        return product;\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implMlDsaNttMult(int[] product, int[] coeffs1, int[] coeffs2) {\n+        return implMlDsaNttMultJava(product, coeffs1, coeffs2);\n+    }\n+\n+    static int implMlDsaNttMultJava(int[] product, int[] coeffs1, int[] coeffs2) {\n+        for (int i = 0; i < mlDsa_n; i++) {\n+            product[i] = montMul(coeffs1[i], toMont(coeffs2[i]));\n+        }\n+        return 1;\n+    }\n+\n+    public static void montMulByConstant(int[] coeffs, int constant) {\n+        int[] check = coeffs.clone();\n+        int result = implMlDsaMontMulByConstant(coeffs, constant);\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implMlDsaMontMulByConstant(int[] coeffs, int constant) {\n+        return implMlDsaMontMulByConstantJava(coeffs, constant);\n+    }\n+\n+    static int implMlDsaMontMulByConstantJava(int[] coeffs, int constant) {\n+        for (int i = 0; i < mlDsa_n; i++) {\n+            coeffs[i] = montMul((coeffs[i]), constant);\n+        }\n+        return 1;\n+    }\n+\n+    public static int mlDsaDecomposePoly(int[] input, int[] lowPart, int[] highPart,\n+                                         int twoGamma2, int multiplier) {\n+        return implMlDsaDecomposePoly(input, lowPart, highPart,\n+            twoGamma2, multiplier);\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implMlDsaDecomposePoly(int[] input, int[] lowPart, int[] highPart,\n+                                          int twoGamma2, int multiplier) {\n+        return decomposePolyJava(input, lowPart, highPart, twoGamma2, multiplier);\n+    }\n+\n+    static int decomposePolyJava(int[] input, int[] lowPart, int[] highPart,\n+                                 int twoGamma2, int multiplier) {\n+        for (int m = 0; m < mlDsa_n; m++) {\n+            int rplus = input[m];\n+            rplus = rplus - ((rplus + 5373807) >> 23) * mlDsa_q;\n+            rplus = rplus + ((rplus >> 31) & mlDsa_q);\n+            int r0 = rplus - ((rplus * multiplier) >> 22) * twoGamma2;\n+            r0 -= (((twoGamma2 - r0) >> 22) & twoGamma2);\n+            r0 -= (((twoGamma2 \/ 2 - r0) >> 31) & twoGamma2);\n+            int r1 = rplus - r0 - (mlDsa_q - 1);\n+            r1 = (r1 | (-r1)) >> 31;\n+            r0 += ~r1;\n+            r1 = r1 & ((rplus - r0) \/ twoGamma2);\n+            lowPart[m] = r0;\n+            highPart[m] = r1;\n+        }\n+        return 1;\n+    }\n+\n+    private int[][] matrixVectorPointwiseMultiply(int[][][] matrix, int[][] vector) {\n+        int[][] result = new int[mlDsa_k][mlDsa_n];\n+        int resulti[] = new int[mlDsa_n];\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                resulti[m] = 0;\n+            }\n+            for (int j = 0; j < mlDsa_l; j++) {\n+                int[] product = mlDsaNttMultiply(matrix[i][j], vector[j]);\n+                for (int m = 0; m < mlDsa_n; m++) {\n+                    resulti[m] += product[m];\n+                }\n+            }\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                result[i][m] = montMul(resulti[m], montRModQ);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private int[][] nttConstMultiply(int[] a, int[][] b) {\n+        int[][] res = new int[b.length][mlDsa_n];\n+        for (int i = 0; i < b.length; i++) {\n+            res[i] = mlDsaNttMultiply(a, b[i]);\n+        }\n+        return res;\n+    }\n+\n+    private int[][] vectorConstMul(int c, int[][] vec) {\n+        int[][] res = new int[vec.length][vec[0].length];\n+        for (int i = 0; i < vec.length; i++) {\n+            for (int j = 0; j < vec[0].length; j++) {\n+                res[i][j] = (c * vec[i][j]) % mlDsa_q;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    \/\/ Adds two vectors of polynomials\n+    \/\/ The coefficients in the input should be between -montQ and montQ .\n+    \/\/ The coefficients in the output will be nonnegative and less than montQ\n+    int[][] vectorAddPos(int[][] vec1, int[][] vec2) {\n+        int dim = vec1.length;\n+        int[][] result = new int[dim][mlDsa_n];\n+        for (int i = 0; i < dim; i++) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                int r = vec1[i][m] + vec2[i][m]; \/\/ -2 * montQ < r < 2 * montQ\n+                r += (((r >> 31) & (2 * montQ)) - montQ); \/\/ -montQ < r < montQ\n+                r += ((r >> 31) & montQ); \/\/ 0 <= r < montQ\n+                result[i][m] = r;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    int[][] vectorAdd(int[][] vec1, int[][] vec2) {\n+        int dim = vec1.length;\n+        int[][] result = new int[dim][mlDsa_n];\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                int tmp = vec1[i][j] + vec2[i][j];\n+                tmp -= tmp >= mlDsa_q ? mlDsa_q : 0;\n+                result[i][j] = tmp;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    int[][] vectorSub(int[][] vec1, int[][] vec2) {\n+        int dim = vec1.length;\n+        int[][] result = new int[dim][mlDsa_n];\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                int tmp = vec1[i][j] - vec2[i][j];\n+                tmp += tmp < 0 ? mlDsa_q : 0;\n+                result[i][j] = tmp;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/\/Precondition: 2^-31 <= r1 <= 2^31 - 5 * 2^20, and bound < q - 5234431\n+    \/\/Computes whether the infinity norm of a vector is >= bound\n+    boolean vectorNormBound(int[][] vec, int bound) {\n+        boolean res = false;\n+        for (int i = 0; i < vec.length; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                int r1 = vec[i][j];\n+                r1 = r1 - ((r1 + (5  << 20)) >> 23) * mlDsa_q;\n+                r1 = r1 - ((r1 >> 31) & r1) * 2;\n+                res |= (r1 >= bound);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private int hammingWeight(boolean[][] vec) {\n+        int weight = 0;\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                weight += vec[i][j] ? 1 : 0;\n+            }\n+        }\n+        return weight;\n+    }\n+\n+    \/\/ precondition: -2^31 * montQ <= a, b < 2^31, -2^31 < a * b < 2^31 * montQ\n+    \/\/ computes a * b * 2^-32 mod montQ\n+    \/\/ the result is greater than -montQ and less than montQ\n+    private static int montMul(int b, int c) {\n+        long a = (long) b * (long) c;\n+        int aHigh = (int) (a >> montRBits);\n+        int aLow = (int) a;\n+        int m = montQInvModR * aLow; \/\/ signed low product\n+\n+        return (aHigh - (int) (((long)m * montQ) >> montRBits));  \/\/ subtract signed high product\n+    }\n+\n+    static int toMont(int a) {\n+        return montMul(a, montRSquareModQ);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":1427,"deletions":0,"binary":false,"changes":1427,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.jca.JCAUtil;\n+import java.security.*;\n+import java.security.SecureRandom;\n+\n+public class ML_DSA_Provider {\n+\n+    static int name2int(String name) {\n+        if (name.endsWith(\"44\")) return 2;\n+        else if (name.endsWith(\"65\")) return 3;\n+        else if (name.endsWith(\"87\")) return 5;\n+        else throw new ProviderException();\n+    }\n+\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            \/\/ ML-DSA-65 is default\n+            super(\"ML-DSA\", \"ML-DSA-65\", \"ML-DSA-44\", \"ML-DSA-87\");\n+        }\n+\n+        public KPG(String pname) {\n+            super(\"ML-DSA\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n+            byte[] seed = new byte[32];\n+            var r = sr != null ? sr : JCAUtil.getDefSecureRandom();\n+            r.nextBytes(seed);\n+            ML_DSA mlDsa = new ML_DSA(name2int(name));\n+            ML_DSA.ML_DSA_KeyPair kp = mlDsa.generateKeyPairInternal(seed);\n+            return new byte[][] {\n+                    mlDsa.pkEncode(kp.publicKey()),\n+                    mlDsa.skEncode(kp.privateKey()) };\n+        }\n+    }\n+\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"ML-DSA-44\");\n+        }\n+    }\n+\n+    public static class KPG3 extends KPG {\n+        public KPG3() {\n+            super(\"ML-DSA-65\");\n+        }\n+    }\n+\n+    public static class KPG5 extends KPG {\n+        public KPG5() {\n+            super(\"ML-DSA-87\");\n+        }\n+    }\n+\n+    public static class KF extends NamedKeyFactory {\n+        public KF() {\n+            super(\"ML-DSA\", \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n+        }\n+        public KF(String name) {\n+            super(\"ML-DSA\", name);\n+        }\n+    }\n+\n+    public static class KF2 extends KF {\n+        public KF2() {\n+            super(\"ML-DSA-44\");\n+        }\n+    }\n+\n+    public static class KF3 extends KF {\n+        public KF3() {\n+            super(\"ML-DSA-65\");\n+        }\n+    }\n+\n+    public static class KF5 extends KF {\n+        public KF5() {\n+            super(\"ML-DSA-87\");\n+        }\n+    }\n+\n+    \/\/ TODO: check key in initSign and initVerify?\n+    public static class SIG extends NamedSignature {\n+        public SIG() {\n+            super(\"ML-DSA\", \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n+        }\n+        public SIG(String name) {\n+            super(\"ML-DSA\", name);\n+        }\n+\n+        @Override\n+        public byte[] implSign(String name, byte[] skBytes, Object sk2, byte[] msg, SecureRandom sr) {\n+            var size = name2int(name);\n+            var r = sr != null ? sr : JCAUtil.getDefSecureRandom();\n+            byte[] rnd = new byte[32];\n+            r.nextBytes(rnd);\n+            var mlDsa = new ML_DSA(size);\n+            ML_DSA.ML_DSA_Signature sig = mlDsa.signInternal(msg, rnd, skBytes);\n+            return mlDsa.sigEncode(sig);\n+        }\n+\n+        @Override\n+        public boolean implVerify(String name, byte[] pkBytes, Object pk2, byte[] msg, byte[] sigBytes) {\n+            var size = name2int(name);\n+            var mlDsa = new ML_DSA(size);\n+            return mlDsa.verifyInternal(pkBytes, msg, sigBytes);\n+        }\n+    }\n+\n+    public static class SIG2 extends SIG {\n+        public SIG2() {\n+            super(\"ML-DSA-44\");\n+        }\n+    }\n+\n+    public static class SIG3 extends SIG {\n+        public SIG3() {\n+            super(\"ML-DSA-65\");\n+        }\n+    }\n+\n+    public static class SIG5 extends SIG {\n+        public SIG5() {\n+            super(\"ML-DSA-87\");\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Provider.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -192,0 +192,13 @@\n+\n+        add(p, \"Signature\", \"ML-DSA\", \"sun.security.provider.ML_DSA_Provider$SIG\", attrs);\n+        addWithAlias(p, \"Signature\", \"ML-DSA-44\", \"sun.security.provider.ML_DSA_Provider$SIG2\", attrs);\n+        addWithAlias(p, \"Signature\", \"ML-DSA-65\", \"sun.security.provider.ML_DSA_Provider$SIG3\", attrs);\n+        addWithAlias(p, \"Signature\", \"ML-DSA-87\", \"sun.security.provider.ML_DSA_Provider$SIG5\", attrs);\n+        add(p, \"KeyPairGenerator\", \"ML-DSA\", \"sun.security.provider.ML_DSA_Provider$KPG\", attrs);\n+        addWithAlias(p, \"KeyPairGenerator\", \"ML-DSA-44\", \"sun.security.provider.ML_DSA_Provider$KPG2\", attrs);\n+        addWithAlias(p, \"KeyPairGenerator\", \"ML-DSA-65\", \"sun.security.provider.ML_DSA_Provider$KPG3\", attrs);\n+        addWithAlias(p, \"KeyPairGenerator\", \"ML-DSA-87\", \"sun.security.provider.ML_DSA_Provider$KPG5\", attrs);\n+        add(p, \"KeyFactory\", \"ML-DSA\", \"sun.security.provider.ML_DSA_Provider$KF\", attrs);\n+        addWithAlias(p, \"KeyFactory\", \"ML-DSA-44\", \"sun.security.provider.ML_DSA_Provider$KF2\", attrs);\n+        addWithAlias(p, \"KeyFactory\", \"ML-DSA-65\", \"sun.security.provider.ML_DSA_Provider$KF3\", attrs);\n+        addWithAlias(p, \"KeyFactory\", \"ML-DSA-87\", \"sun.security.provider.ML_DSA_Provider$KF5\", attrs);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -322,0 +322,5 @@\n+    \/\/PQC\n+    ML_DSA_44(\"1.3.6.1.4.1.2.267.12.4.4\", \"ML-DSA-44\"),\n+    ML_DSA_65(\"1.3.6.1.4.1.2.267.12.6.5\", \"ML-DSA-65\"),\n+    ML_DSA_87(\"1.3.6.1.4.1.2.267.12.8.7\", \"ML-DSA-87\"),\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}