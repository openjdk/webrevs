{"files":[{"patch":"@@ -71,0 +71,24 @@\n+    \/**\n+     * The ML-DSA-44 parameters\n+     *\n+     * @since 24\n+     *\/\n+    public static final NamedParameterSpec ML_DSA_44\n+        = new NamedParameterSpec(\"ML-DSA-44\");\n+\n+    \/**\n+     * The ML-DSA-65 parameters\n+     *\n+     * @since 24\n+     *\/\n+    public static final NamedParameterSpec ML_DSA_65\n+        = new NamedParameterSpec(\"ML-DSA-65\");\n+\n+    \/**\n+     * The ML-DSA-87 parameters\n+     *\n+     * @since 24\n+     *\/\n+    public static final NamedParameterSpec ML_DSA_87\n+        = new NamedParameterSpec(\"ML-DSA-87\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/NamedParameterSpec.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs;\n+\n+import sun.security.util.DerInputStream;\n+import sun.security.util.DerValue;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.security.auth.DestroyFailedException;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.Serial;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+\n+public final class NamedPKCS8Key extends PKCS8Key {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    private final String fname;\n+    private final transient NamedParameterSpec paramSpec;\n+    private final byte[] h;\n+\n+    private transient boolean destroyed = false;\n+\n+    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n+    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n+    public NamedPKCS8Key(String fname, String pname, byte[] h) {\n+        this.fname = fname;\n+        this.paramSpec = new NamedParameterSpec(pname);\n+        try {\n+            this.algid = AlgorithmId.get(pname);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ProviderException(e);\n+        }\n+        this.h = h;\n+\n+        DerValue val = new DerValue(DerValue.tag_OctetString, h);\n+        try {\n+            this.key = val.toByteArray();\n+        } finally {\n+            val.clear();\n+        }\n+    }\n+\n+    \/\/\/ Ctor from family name, and PKCS #8 bytes\n+    public NamedPKCS8Key(String fname, byte[] encoded) throws InvalidKeyException {\n+        super(encoded);\n+        this.fname = fname;\n+        try {\n+            paramSpec = new NamedParameterSpec(algid.getName());\n+            if (algid.getEncodedParams() != null) {\n+                throw new InvalidKeyException(\"algorithm identifier has params\");\n+            }\n+            h = new DerInputStream(key).getOctetString();\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\"Cannot parse input\", e);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Do not modify: this can be used by earlier JDKs that\n+        \/\/ do not have the getParams() method\n+        return paramSpec.getName() + \" private key\";\n+    }\n+\n+    \/\/\/ Returns the reference to the internal key. Caller must not modify\n+    \/\/\/ the content or keep a reference.\n+    public byte[] getRawBytes() {\n+        return h;\n+    }\n+\n+    @Override\n+    public NamedParameterSpec getParams() {\n+        return paramSpec;\n+    }\n+\n+    @Override\n+    public String getAlgorithm() {\n+        return fname;\n+    }\n+\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"NamedPKCS8Key keys are not directly deserializable\");\n+    }\n+\n+    @Override\n+    public void destroy() throws DestroyFailedException {\n+        Arrays.fill(h, (byte)0);\n+        Arrays.fill(this.key, (byte)0);\n+        if (this.encodedKey != null) {\n+            Arrays.fill(this.encodedKey, (byte)0);\n+        }\n+        destroyed = true;\n+    }\n+\n+    @Override\n+    public boolean isDestroyed() {\n+        return destroyed;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/NamedPKCS8Key.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,1420 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import sun.security.provider.SHA3.SHAKE128;\n+import sun.security.provider.SHA3.SHAKE256;\n+\n+import java.util.Arrays;\n+\n+public class ML_DSA {\n+    private static final int mlDsa_q = 8380417;\n+    private static final int mlDsa_n = 256;\n+    private static final int shake256BlockSize = 136; \/\/ the block length for SHAKE256\n+    private static final int montRBits = 32;\n+    private static final long montR = 4294967296L; \/\/ 1 << montRBits\n+    private static final int montQ = 8380417;\n+    private static final int montRSquareModQ = 2365951;\n+    private static final int montQInvModR = 58728449;\n+    private static final int montRModQ = 4193792;\n+    private static final int montDimInverse = 16382; \/\/ toMont((mlDsa_n)^-1 (mod mlDsa_q))\n+    private static final int[] montZetasForNtt = new int[]{\n+        25847, -2608894, -518909, 237124, -777960, -876248, 466468, 1826347,\n+        2353451, -359251, -2091905, 3119733, -2884855, 3111497, 2680103, 2725464,\n+        1024112, -1079900, 3585928, -549488, -1119584, 2619752, -2108549, -2118186,\n+        -3859737, -1399561, -3277672, 1757237, -19422, 4010497, 280005, 2706023,\n+        95776, 3077325, 3530437, -1661693, -3592148, -2537516, 3915439, -3861115,\n+        -3043716, 3574422, -2867647, 3539968, -300467, 2348700, -539299, -1699267,\n+        -1643818, 3505694, -3821735, 3507263, -2140649, -1600420, 3699596, 811944,\n+        531354, 954230, 3881043, 3900724, -2556880, 2071892, -2797779, -3930395,\n+        -1528703, -3677745, -3041255, -1452451, 3475950, 2176455, -1585221, -1257611,\n+        1939314, -4083598, -1000202, -3190144, -3157330, -3632928, 126922, 3412210,\n+        -983419, 2147896, 2715295, -2967645, -3693493, -411027, -2477047, -671102,\n+        -1228525, -22981, -1308169, -381987, 1349076, 1852771, -1430430, -3343383,\n+        264944, 508951, 3097992, 44288, -1100098, 904516, 3958618, -3724342,\n+        -8578, 1653064, -3249728, 2389356, -210977, 759969, -1316856, 189548,\n+        -3553272, 3159746, -1851402, -2409325, -177440, 1315589, 1341330, 1285669,\n+        -1584928, -812732, -1439742, -3019102, -3881060, -3628969, 3839961, 2091667,\n+        3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462, 266997,\n+        2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378, 900702,\n+        1859098, 909542, 819034, 495491, -1613174, -43260, -522500, -655327,\n+        -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838, 342297,\n+        286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044, 2842341,\n+        2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974, -3767016,\n+        1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970, -1333058,\n+        1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642, -1279661,\n+        1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031, -542412,\n+        -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993, -2013608,\n+        2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385, -3183426,\n+        162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107, -3038916,\n+        3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078, -426683,\n+        1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893, -2939036,\n+        -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687, -554416,\n+        3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782\n+    };\n+    private static final int[] montZetasForInverseNtt = new int[]{\n+        -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,\n+        3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,\n+        3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,\n+        -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,\n+        1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,\n+        1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,\n+        3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,\n+        -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,\n+        1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,\n+        1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,\n+        -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,\n+        -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,\n+        3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,\n+        522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,\n+        3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,\n+        3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,\n+        -3839961, 3628969, 3881060, 3019102, 1439742, 812732, 1584928, -1285669,\n+        -1341330, -1315589, 177440, 2409325, 1851402, -3159746, 3553272, -189548,\n+        1316856, -759969, 210977, -2389356, 3249728, -1653064, 8578, 3724342,\n+        -3958618, -904516, 1100098, -44288, -3097992, -508951, -264944, 3343383,\n+        1430430, -1852771, -1349076, 381987, 1308169, 22981, 1228525, 671102,\n+        2477047, 411027, 3693493, 2967645, -2715295, -2147896, 983419, -3412210,\n+        -126922, 3632928, 3157330, 3190144, 1000202, 4083598, -1939314, 1257611,\n+        1585221, -2176455, -3475950, 1452451, 3041255, 3677745, 1528703, 3930395,\n+        2797779, -2071892, 2556880, -3900724, -3881043, -954230, -531354, -811944,\n+        -3699596, 1600420, 2140649, -3507263, 3821735, -3505694, 1643818, 1699267,\n+        539299, -2348700, 300467, -3539968, 2867647, -3574422, 3043716, 3861115,\n+        -3915439, 2537516, 3592148, 1661693, -3530437, -3077325, -95776, -2706023,\n+        -280005, -4010497, 19422, -1757237, 3277672, 1399561, 3859737, 2118186,\n+        2108549, -2619752, 1119584, 549488, -3585928, 1079900, -1024112, -2725464,\n+        -2680103, -3111497, 2884855, -3119733, 2091905, 359251, -2353451, -1826347,\n+        -466468, 876248, 777960, -237124, 518909, 2608894, -25847\n+    };\n+\n+    private static final int[] montZetasForVectorNtt = new int[]{\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+\n+        1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,\n+        1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,\n+        2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,\n+        2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,\n+        -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,\n+        -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,\n+        -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,\n+        -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,\n+        3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,\n+        3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,\n+        -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,\n+        -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,\n+        3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,\n+        3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,\n+        2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,\n+        2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,\n+\n+        2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464,\n+        1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112,\n+        -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900,\n+        3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928,\n+        -549488, -549488, -549488, -549488, -549488, -549488, -549488, -549488,\n+        -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584,\n+        2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752,\n+        -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549,\n+        -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186,\n+        -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737,\n+        -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561,\n+        -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672,\n+        1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237,\n+        -19422, -19422, -19422, -19422, -19422, -19422, -19422, -19422,\n+        4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497,\n+        280005, 280005, 280005, 280005, 280005, 280005, 280005, 280005,\n+\n+        2706023, 2706023, 2706023, 2706023, 95776, 95776, 95776, 95776,\n+        3077325, 3077325, 3077325, 3077325, 3530437, 3530437, 3530437, 3530437,\n+        -1661693, -1661693, -1661693, -1661693, -3592148, -3592148, -3592148, -3592148,\n+        -2537516, -2537516, -2537516, -2537516, 3915439, 3915439, 3915439, 3915439,\n+        -3861115, -3861115, -3861115, -3861115, -3043716, -3043716, -3043716, -3043716,\n+        3574422, 3574422, 3574422, 3574422, -2867647, -2867647, -2867647, -2867647,\n+        3539968, 3539968, 3539968, 3539968, -300467, -300467, -300467, -300467,\n+        2348700, 2348700, 2348700, 2348700, -539299, -539299, -539299, -539299,\n+        -1699267, -1699267, -1699267, -1699267, -1643818, -1643818, -1643818, -1643818,\n+        3505694, 3505694, 3505694, 3505694, -3821735, -3821735, -3821735, -3821735,\n+        3507263, 3507263, 3507263, 3507263, -2140649, -2140649, -2140649, -2140649,\n+        -1600420, -1600420, -1600420, -1600420, 3699596, 3699596, 3699596, 3699596,\n+        811944, 811944, 811944, 811944, 531354, 531354, 531354, 531354,\n+        954230, 954230, 954230, 954230, 3881043, 3881043, 3881043, 3881043,\n+        3900724, 3900724, 3900724, 3900724, -2556880, -2556880, -2556880, -2556880,\n+        2071892, 2071892, 2071892, 2071892, -2797779, -2797779, -2797779, -2797779,\n+\n+        -3930395, -3930395, -1528703, -1528703, -3677745, -3677745, -3041255, -3041255,\n+        -1452451, -1452451, 3475950, 3475950, 2176455, 2176455, -1585221, -1585221,\n+        -1257611, -1257611, 1939314, 1939314, -4083598, -4083598, -1000202, -1000202,\n+        -3190144, -3190144, -3157330, -3157330, -3632928, -3632928, 126922, 126922,\n+        3412210, 3412210, -983419, -983419, 2147896, 2147896, 2715295, 2715295,\n+        -2967645, -2967645, -3693493, -3693493, -411027, -411027, -2477047, -2477047,\n+        -671102, -671102, -1228525, -1228525, -22981, -22981, -1308169, -1308169,\n+        -381987, -381987, 1349076, 1349076, 1852771, 1852771, -1430430, -1430430,\n+        -3343383, -3343383, 264944, 264944, 508951, 508951, 3097992, 3097992,\n+        44288, 44288, -1100098, -1100098, 904516, 904516, 3958618, 3958618,\n+        -3724342, -3724342, -8578, -8578, 1653064, 1653064, -3249728, -3249728,\n+        2389356, 2389356, -210977, -210977, 759969, 759969, -1316856, -1316856,\n+        189548, 189548, -3553272, -3553272, 3159746, 3159746, -1851402, -1851402,\n+        -2409325, -2409325, -177440, -177440, 1315589, 1315589, 1341330, 1341330,\n+        1285669, 1285669, -1584928, -1584928, -812732, -812732, -1439742, -1439742,\n+        -3019102, -3019102, -3881060, -3881060, -3628969, -3628969, 3839961, 3839961,\n+\n+        2091667, 3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462,\n+        266997, 2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378,\n+        900702, 1859098, 909542, 819034, 495491, -1613174, -43260, -522500,\n+        -655327, -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838,\n+        342297, 286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044,\n+        2842341, 2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974,\n+        -3767016, 1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970,\n+        -1333058, 1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642,\n+        -1279661, 1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031,\n+        -542412, -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993,\n+        -2013608, 2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385,\n+        -3183426, 162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107,\n+        -3038916, 3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078,\n+        -426683, 1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893,\n+        -2939036, -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687,\n+        -554416, 3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782\n+    };\n+\n+    private static final int[] montZetasForVectorInverseNtt = new int[]{\n+        -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,\n+        3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,\n+        3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,\n+        -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,\n+        1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,\n+        1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,\n+        3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,\n+        -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,\n+        1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,\n+        1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,\n+        -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,\n+        -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,\n+        3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,\n+        522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,\n+        3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,\n+        3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,\n+\n+        -3839961, -3839961, 3628969, 3628969, 3881060, 3881060, 3019102, 3019102,\n+        1439742, 1439742, 812732, 812732, 1584928, 1584928, -1285669, -1285669,\n+        -1341330, - 1341330, -1315589, -1315589, 177440, 177440, 2409325, 2409325,\n+        1851402, 1851402, -3159746, -3159746, 3553272, 3553272, -189548, -189548,\n+        1316856, 1316856, -759969, -759969, 210977, 210977, -2389356, -2389356,\n+        3249728, 3249728, -1653064, -1653064, 8578, 8578, 3724342, 3724342,\n+        -3958618, -3958618, -904516, -904516, 1100098, 1100098, -44288, -44288,\n+        -3097992, -3097992, -508951, -508951, -264944, -264944, 3343383, 3343383,\n+        1430430, 1430430, -1852771, -1852771, -1349076, -1349076, 381987, 381987,\n+        1308169, 1308169, 22981, 22981, 1228525, 1228525, 671102, 671102,\n+        2477047, 2477047, 411027, 411027, 3693493, 3693493, 2967645, 2967645,\n+        -2715295, -2715295, -2147896, -2147896, 983419, 983419, -3412210, -3412210,\n+        -126922, -126922, 3632928, 3632928, 3157330, 3157330, 3190144, 3190144,\n+        1000202, 1000202, 4083598, 4083598, -1939314, -1939314, 1257611, 1257611,\n+        1585221, 1585221, -2176455, -2176455, -3475950, -3475950, 1452451, 1452451,\n+        3041255, 3041255, 3677745, 3677745, 1528703, 1528703, 3930395, 3930395,\n+\n+        2797779, 2797779, 2797779, 2797779, -2071892, -2071892, -2071892, -2071892,\n+        2556880, 2556880, 2556880, 2556880, -3900724, -3900724, -3900724, -3900724,\n+        -3881043, -3881043, -3881043, -3881043, -954230, -954230, -954230, -954230,\n+        -531354, -531354, -531354, -531354, -811944, -811944, -811944, -811944,\n+        -3699596, -3699596, -3699596, -3699596, 1600420, 1600420, 1600420, 1600420,\n+        2140649, 2140649, 2140649, 2140649, -3507263, -3507263, -3507263, -3507263,\n+        3821735, 3821735, 3821735, 3821735, -3505694, -3505694, -3505694, -3505694,\n+        1643818, 1643818, 1643818, 1643818, 1699267, 1699267, 1699267, 1699267,\n+        539299, 539299, 539299, 539299, -2348700, -2348700, -2348700, -2348700,\n+        300467, 300467, 300467, 300467, -3539968, -3539968, -3539968, -3539968,\n+        2867647, 2867647, 2867647, 2867647, -3574422, -3574422, -3574422, -3574422,\n+        3043716, 3043716, 3043716, 3043716, 3861115, 3861115, 3861115, 3861115,\n+        -3915439, -3915439, -3915439, -3915439, 2537516, 2537516, 2537516, 2537516,\n+        3592148, 3592148, 3592148, 3592148, 1661693, 1661693, 1661693, 1661693,\n+        -3530437, -3530437, -3530437, -3530437, -3077325, -3077325, -3077325, -3077325,\n+        -95776, -95776, -95776, -95776, -2706023, -2706023, -2706023, -2706023,\n+\n+        -280005, -280005, -280005, -280005, -280005, -280005, -280005, -280005,\n+        -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497,\n+        19422, 19422, 19422, 19422, 19422, 19422, 19422, 19422,\n+        -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237,\n+        3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672,\n+        1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561,\n+        3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737,\n+        2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186,\n+        2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549,\n+        -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752,\n+        1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584,\n+        549488, 549488, 549488, 549488, 549488, 549488, 549488, 549488,\n+        -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928,\n+        1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900,\n+        -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112,\n+        -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464,\n+\n+        -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,\n+        -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,\n+        -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,\n+        -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,\n+        2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,\n+        2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,\n+        -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,\n+        -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,\n+        2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,\n+        2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,\n+        359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,\n+        359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,\n+        -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,\n+        -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,\n+        -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,\n+        -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,\n+\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847\n+    };\n+    private final int mlDsaASeedLength = 32;\n+    private final int mlDsaS1S2SeedLength = 64;\n+    private final int mlDsaKLength = 32;\n+    private final int mlDsaTrLength = 64;\n+    private final int mlDsaMuLength = 64;\n+    private final int mlDsaMaskSeedLength = 64;\n+    private static final int mlDsa_d = 13;\n+    private static final int dMask = (1 << mlDsa_d) - 1;\n+    private final int tau;\n+    private final int lambda;\n+    private final int gamma1;\n+    private final int gamma1Bits;\n+    private final int gamma2;\n+    private final int mlDsa_k;\n+    private final int mlDsa_l;\n+    private final int eta;\n+    private final int beta;\n+    private final int omega;\n+    private final int s1PackedLength;\n+    private final int s2PackedLength;\n+    private final int s1s2CoeffSize;\n+    private final int t0CoeffSize = 13;\n+    private final int privateKeyLength;\n+    private final int publicKeyLength;\n+    private final int signatureLength;\n+    private final int wCoeffSize;\n+    private final int level;\n+\n+    public ML_DSA(int security_level) {\n+        switch (security_level) {\n+            case 2:\n+                level = 2;\n+                tau = 39;\n+                lambda = 128;\n+                gamma1 = 1 << 17;\n+                gamma1Bits = 17;\n+                gamma2 = (mlDsa_q - 1) \/ 88;\n+                mlDsa_k = 4;\n+                mlDsa_l = 4;\n+                eta = 2;\n+                beta = 78;\n+                omega = 80;\n+                privateKeyLength = 0;\n+                publicKeyLength = 1312;\n+                signatureLength = 2420;\n+                s1PackedLength = 384;\n+                s2PackedLength = 384;\n+                s1s2CoeffSize = 3;\n+                wCoeffSize = 6;\n+                break;\n+            case 3:\n+                level = 3;\n+                tau = 49;\n+                lambda = 192;\n+                gamma1 = 1 << 19;\n+                gamma1Bits = 19;\n+                gamma2 = (mlDsa_q - 1) \/ 32;\n+                mlDsa_k = 6;\n+                mlDsa_l = 5;\n+                eta = 4;\n+                beta = 196;\n+                omega = 55;\n+                privateKeyLength = 0;\n+                publicKeyLength = 1952;\n+                signatureLength = 3293;\n+                s1PackedLength = 640;\n+                s2PackedLength = 768;\n+                s1s2CoeffSize = 4;\n+                wCoeffSize = 4;\n+                break;\n+            case 5:\n+                level = 4;\n+                tau = 60;\n+                lambda = 256;\n+                gamma1 = 1 << 19;\n+                gamma1Bits = 19;\n+                gamma2 = (mlDsa_q - 1) \/ 32;\n+                mlDsa_k = 8;\n+                mlDsa_l = 7;\n+                eta = 2;\n+                beta = 120;\n+                omega = 75;\n+                privateKeyLength = 0;\n+                publicKeyLength = 2592;\n+                signatureLength = 4595;\n+                s1PackedLength = 672;\n+                s2PackedLength = 768;\n+                s1s2CoeffSize = 3;\n+                wCoeffSize = 4;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Wrong security level\");\n+        }\n+    }\n+\n+    public record ML_DSA_PrivateKey(byte[] rho, byte[] k, byte[] tr, int[][] s1, int[][] s2, int[][] t0) {\n+    }\n+\n+    public record ML_DSA_PublicKey(byte[] rho, int[][] t1) {\n+    }\n+\n+    public record ML_DSA_KeyPair(ML_DSA_PrivateKey privateKey, ML_DSA_PublicKey publicKey) {\n+    }\n+\n+    public record ML_DSA_Signature(byte[] commitmentHash, int[][] response, boolean[][] hint) {\n+    }\n+\n+    public ML_DSA_KeyPair generateKeyPair(byte[] randomBytes) {\n+        \/\/Initialize hash functions\n+        var hash = new SHAKE256(0);\n+        var crHash = new SHAKE256(mlDsaTrLength);\n+\n+        \/\/Expand seed\n+        hash.update(randomBytes);\n+        hash.update((byte)mlDsa_k);\n+        hash.update((byte)mlDsa_l);\n+        byte[] rho = hash.squeeze(mlDsaASeedLength);\n+        byte[] rhoPrime = hash.squeeze(mlDsaS1S2SeedLength);\n+        byte[] k = hash.squeeze(mlDsaKLength);\n+        hash.reset();\n+\n+        \/\/Sample A\n+        int[][][] keygenA = generateA(rho); \/\/A is in NTT domain\n+\n+        \/\/Sample S1 and S2\n+        int[][] s1 = new int[mlDsa_l][mlDsa_n];\n+        int[][] s2 = new int[mlDsa_k][mlDsa_n];\n+        sampleS1S2(s1, s2, hash, rhoPrime); \/\/hash is reset before being used in sampleS1S2\n+\n+        \/\/Compute t and tr\n+        mlDsaVectorNtt(s1); \/\/s1 now in NTT domain\n+        int[][] As1 = matrixVectorPointwiseMultiply(keygenA, s1);\n+        mlDsaVectorInverseNtt(s1); \/\/take s1 out of NTT domain\n+\n+        mlDsaVectorInverseNtt(As1);\n+        int[][] t = vectorAddPos(As1, s2);\n+        int[][] t0 = new int[mlDsa_k][mlDsa_n];\n+        int[][] t1 = new int[mlDsa_k][mlDsa_n];\n+        power2Round(t, t0, t1);\n+\n+        \/\/Encode PK and SK\n+        ML_DSA_PublicKey pk = new ML_DSA_PublicKey(rho, t1);\n+        byte[] publicKeyBytes = pkEncode(pk);\n+        crHash.update(publicKeyBytes);\n+        byte[] tr = crHash.digest();\n+        ML_DSA_PrivateKey sk = new ML_DSA_PrivateKey(rho, k, tr, s1, s2, t0);\n+\n+        return new ML_DSA_KeyPair(sk, pk);\n+    }\n+\n+    public ML_DSA_Signature sign(byte[] message, byte[] rnd, ML_DSA_PrivateKey sk) {\n+        \/\/Initialize hash functions\n+        var hash = new SHAKE256(0);\n+\n+        int[][] s1 = Arrays.stream(sk.s1()).map(int[]::clone).toArray(int[][]::new);\n+        int[][] s2 = Arrays.stream(sk.s2()).map(int[]::clone).toArray(int[][]::new);\n+        int[][] t0 = Arrays.stream(sk.t0()).map(int[]::clone).toArray(int[][]::new);\n+\n+        \/\/Do some NTTs\n+        mlDsaVectorNtt(s1);\n+        mlDsaVectorNtt(s2);\n+        mlDsaVectorNtt(t0);\n+        int[][][] aHat = generateA(sk.rho());\n+\n+        \/\/Compute mu\n+        hash.update(sk.tr());\n+        hash.update(message);\n+        byte[] mu = hash.squeeze(mlDsaMuLength);\n+        hash.reset();\n+\n+        \/\/Compute rho'\n+        hash.update(sk.k());\n+        hash.update(rnd);\n+        hash.update(mu);\n+        byte[] rhoPrime = hash.squeeze(mlDsaMaskSeedLength);\n+        hash.reset();\n+\n+        \/\/Initialize vectors used in loop\n+        int[][] z = null;\n+        boolean[][] h = null;\n+        byte[] commitmentHash = new byte[lambda\/4];\n+\n+        int kappa = 0;\n+        while (true) {\n+            int[][] y = expandMask(rhoPrime, kappa);\n+\n+            \/\/Compute w and w1\n+            mlDsaVectorNtt(y); \/\/y is now in NTT domain\n+            int[][] w = matrixVectorPointwiseMultiply(aHat, y);\n+            mlDsaVectorInverseNtt(w); \/\/w is not in normal domain\n+            int[][] w0 = new int[mlDsa_k][mlDsa_n];\n+            int[][] w1 = new int[mlDsa_k][mlDsa_n];\n+            decompose(w, w0, w1);\n+            mlDsaVectorInverseNtt(y);\n+\n+            \/\/Get commitment hash\n+            hash.update(mu);\n+            hash.update(simpleBitPack(wCoeffSize, w1));\n+            commitmentHash = hash.squeeze(lambda\/4);\n+            hash.reset();\n+\n+            \/\/Get z and r0\n+            int[] c = sampleInBall(commitmentHash);\n+            mlDsaNtt(c); \/\/c is now in NTT domain\n+            int[][] cs1 = nttConstMultiply(c, s1);\n+            int[][] cs2 = nttConstMultiply(c, s2);\n+            mlDsaVectorInverseNtt(cs1);\n+            mlDsaVectorInverseNtt(cs2);\n+            z = vectorAdd(y, cs1);\n+            int[][] r0 = vectorSub(w0, cs2);\n+\n+            \/\/Update z and h\n+            kappa += mlDsa_l;\n+            if (vectorNormBound(z, gamma1 - beta) || vectorNormBound(r0, gamma2 - beta)) {\n+                continue;\n+            } else {\n+                int[][] ct0 = nttConstMultiply(c, t0);\n+                mlDsaVectorInverseNtt(ct0);\n+                h = makeHint(vectorConstMul(-1, ct0), vectorAdd(vectorAdd(w, vectorConstMul(-1, cs2)), ct0));\n+                if (vectorNormBound(ct0, gamma2) || (hammingWeight(h) > omega)) {\n+                    continue;\n+                }\n+            }\n+            return new ML_DSA_Signature(commitmentHash, z, h);\n+        }\n+    }\n+\n+    public boolean verify(ML_DSA_PublicKey pk, byte[] message, ML_DSA_Signature sig) {\n+        var hash = new SHAKE256(0);\n+\n+        \/\/Check hint encoding\n+        if (sig.hint() == null) {return false;}\n+\n+        \/\/Expand A\n+        int[][][] aHat = generateA(pk.rho());\n+\n+        \/\/Generate tr\n+        hash.update(pkEncode(pk));\n+        byte[] tr = hash.squeeze(mlDsaTrLength);\n+        hash.reset();\n+\n+        \/\/Generate mu\n+        hash.update(tr);\n+        hash.update(message);\n+        byte[] mu = hash.squeeze(mlDsaMuLength);\n+        hash.reset();\n+\n+        \/\/Get verifiers challenge\n+        int[] cHat = sampleInBall(sig.commitmentHash());\n+        mlDsaNtt(cHat);\n+\n+        \/\/Deal with z\n+        int[][] z = Arrays.stream(sig.response()).map(int[]::clone).toArray(int[][]::new);\n+        boolean zNorm = vectorNormBound(z, gamma1 - beta);\n+        mlDsaVectorNtt(z);\n+\n+        \/\/Reconstruct signer's commitment\n+        int[][] aHatZ = matrixVectorPointwiseMultiply(aHat, z);\n+        int[][] t1Hat = vectorConstMul(1 << mlDsa_d, pk.t1());\n+        mlDsaVectorNtt(t1Hat);\n+        int[][] wApprox = vectorSub(aHatZ,nttConstMultiply(cHat, t1Hat));\n+        mlDsaVectorInverseNtt(wApprox);\n+        int[][] w1Prime = useHint(sig.hint(), wApprox);\n+\n+        \/\/Hash signer's commitment\n+        hash.update(mu);\n+        hash.update(simpleBitPack(wCoeffSize, w1Prime));\n+        byte[] cTildePrime = hash.squeeze(lambda\/4);\n+\n+        \/\/Check verify conditions\n+        boolean hashEq = Arrays.equals(sig.commitmentHash(), cTildePrime);\n+        boolean weight = hammingWeight(sig.hint()) <= omega;\n+        return !zNorm && hashEq && weight;\n+    }\n+\n+    \/*\n+    Data conversion functions in Section 8.1 of specification\n+     *\/\n+\n+    \/\/ Bit-pack the t1 and w1 vector into a byte array.\n+    \/\/ The coefficients of the polynomials in the vector should be nonnegative and less than 2^bitsPerCoeff .\n+    public byte[] simpleBitPack(int bitsPerCoeff, int[][] vector) {\n+        byte[] result = new byte[(mlDsa_k * mlDsa_n * bitsPerCoeff) \/ 8];\n+        int acc = 0;\n+        int shift = 0;\n+        int i = 0;\n+        for (int[] poly : vector) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                acc += (poly[m] << shift);\n+                shift += bitsPerCoeff;\n+                while (shift >= 8) {\n+                    result[i++] = (byte) acc;\n+                    acc >>= 8;\n+                    shift -= 8;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public byte[] bitPack(int[][] vector, int bitsPerCoeff, int maxValue) {\n+        int vecLen = vector.length;\n+        byte[] result = new byte[(vecLen * mlDsa_n * bitsPerCoeff) \/ 8];\n+        int acc = 0;\n+        int shift = 0;\n+        int i = 0;\n+        for (int[] poly : vector) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                acc += (maxValue - poly[m]) << shift;\n+                shift += bitsPerCoeff;\n+                while (shift >= 8) {\n+                    result[i++] = (byte) acc;\n+                    acc >>= 8;\n+                    shift -= 8;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public int[][] t1Unpack(byte[] v) {\n+        int[][] t1 = new int[mlDsa_k][mlDsa_n];\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_n \/ 4; j++) {\n+                int tOffset = j*4;\n+                int vOffset = (i*320) + (j*5);\n+                t1[i][tOffset] = (v[vOffset] & 0xFF) + ((v[vOffset+1] << 8) & 0x3FF);\n+                t1[i][tOffset+1] = ((v[vOffset+1] >> 2) & 0x3F) + ((v[vOffset+2] << 6) & 0x3FF);\n+                t1[i][tOffset+2] = ((v[vOffset+2] >> 4) & 0xF) + ((v[vOffset+3] << 4) & 0x3FF);\n+                t1[i][tOffset+3] = ((v[vOffset+3] >> 6) & 0x3) + ((v[vOffset+4] << 2) & 0x3FF);\n+            }\n+        }\n+        return t1;\n+    }\n+\n+    public int[][] bitUnpack(byte[] v, int dim, int maxValue, int bitsPerCoeff) {\n+        int[][] res = new int[dim][mlDsa_n];\n+\n+        int mask = (1 << bitsPerCoeff) - 1;\n+        int top = 0;\n+        int shift = 0;\n+        int acc = 0;\n+        int index = 0;\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                while (top - shift < bitsPerCoeff) {\n+                    acc += ((v[index++] & 0xff) << top);\n+                    top += 8;\n+                }\n+                res[i][j] = maxValue - ((acc >> shift) & mask);\n+                shift += bitsPerCoeff;\n+                while (shift >= 8) {\n+                    top -= 8;\n+                    shift -= 8;\n+                    acc >>>= 8;\n+                }\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private byte[] hintBitPack(boolean[][] h) {\n+        byte[] y = new byte[omega + mlDsa_k];\n+        int idx = 0;\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                if (h[i][j]) {\n+                    y[idx] = (byte)j;\n+                    idx++;\n+                }\n+            }\n+            y[omega + i] = (byte)idx;\n+        }\n+        return y;\n+    }\n+\n+    private boolean[][] hintBitUnpack(byte[] y) {\n+        boolean[][] h = new boolean[mlDsa_k][mlDsa_n];\n+        int idx = 0;\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            int j = y[omega + i];\n+            if (j < idx || j > omega) {\n+                return null;\n+            }\n+            while (idx < j) {\n+                int hintIndex = y[idx] & 0xff;\n+                h[i][hintIndex] = true;\n+                idx++;\n+            }\n+        }\n+\n+        while (idx < omega) {\n+            if (y[idx] != 0) {\n+                return null;\n+            }\n+            idx++;\n+        }\n+        return h;\n+    }\n+\n+    \/*\n+    Encoding functions as specified in Section 8.2 of the specification\n+     *\/\n+\n+    public byte[] pkEncode(ML_DSA_PublicKey key) {\n+        byte[] t1Packed = simpleBitPack(10, key.t1);\n+        byte[] publicKeyBytes = new byte[mlDsaASeedLength + t1Packed.length];\n+        System.arraycopy(key.rho, 0, publicKeyBytes, 0, mlDsaASeedLength);\n+        System.arraycopy(t1Packed, 0, publicKeyBytes, mlDsaASeedLength, t1Packed.length);\n+\n+        return publicKeyBytes;\n+    }\n+\n+    public ML_DSA_PublicKey pkDecode(byte[] pk) {\n+        byte[] rho = new byte[mlDsaASeedLength];\n+        System.arraycopy(pk, 0, rho, 0, mlDsaASeedLength);\n+\n+        byte[] v = Arrays.copyOfRange(pk, mlDsaASeedLength, pk.length);\n+        int[][] t1 = t1Unpack(v);\n+        return new ML_DSA_PublicKey(rho, t1);\n+    }\n+\n+    public byte[] skEncode(ML_DSA_PrivateKey key) {\n+\n+        byte[] s1Packed = bitPack(key.s1, s1s2CoeffSize, eta);\n+        byte[] s2Packed = bitPack(key.s2, s1s2CoeffSize, eta);\n+        byte[] t0Packed = bitPack(key.t0, t0CoeffSize, 1 << 12);\n+\n+        byte[] skBytes = new byte[mlDsaASeedLength + mlDsaKLength + key.tr.length +\n+            s1PackedLength + s2PackedLength + t0Packed.length];\n+\n+        System.arraycopy(key.rho, 0, skBytes, 0, mlDsaASeedLength);\n+        System.arraycopy(key.k, 0, skBytes, mlDsaASeedLength, mlDsaKLength);\n+        System.arraycopy(key.tr, 0, skBytes, mlDsaASeedLength + mlDsaKLength, mlDsaTrLength);\n+        System.arraycopy(s1Packed, 0, skBytes, mlDsaASeedLength + mlDsaKLength + key.tr.length, s1PackedLength);\n+        System.arraycopy(s2Packed, 0, skBytes, mlDsaASeedLength + mlDsaKLength + key.tr.length + s1PackedLength, s2PackedLength);\n+        System.arraycopy(t0Packed, 0, skBytes, mlDsaASeedLength + mlDsaKLength + key.tr.length + s1PackedLength + s2PackedLength, t0Packed.length);\n+\n+        return skBytes;\n+    }\n+\n+    public ML_DSA_PrivateKey skDecode(byte[] sk) {\n+        byte[] rho = new byte[mlDsaASeedLength];\n+        System.arraycopy(sk, 0, rho, 0, mlDsaASeedLength);\n+\n+        byte[] k = new byte[mlDsaKLength];\n+        System.arraycopy(sk, mlDsaASeedLength, k, 0, mlDsaKLength);\n+\n+        byte[] tr = new byte[mlDsaTrLength];\n+        System.arraycopy(sk, mlDsaASeedLength + mlDsaKLength, tr, 0, mlDsaTrLength);\n+\n+        \/\/Parse s1\n+        int start = mlDsaASeedLength + mlDsaKLength + mlDsaTrLength;\n+        int end = start + (32 * mlDsa_l * s1s2CoeffSize);\n+        byte[] y = Arrays.copyOfRange(sk, start, end);\n+        int[][] s1 = bitUnpack(y, mlDsa_l, eta, s1s2CoeffSize);\n+\n+        \/\/Parse s2\n+        start = end;\n+        end += 32 * s1s2CoeffSize * mlDsa_k;\n+        byte[] z = Arrays.copyOfRange(sk, start, end);\n+        int[][] s2 = bitUnpack(z, mlDsa_k, eta, s1s2CoeffSize);\n+\n+        \/\/Parse t0\n+        start = end;\n+        end += 32 * mlDsa_d * mlDsa_k;\n+        byte[] w = Arrays.copyOfRange(sk, start, end);\n+        int[][] t0 = bitUnpack(w, mlDsa_k, 1 << 12, t0CoeffSize);\n+\n+        return new ML_DSA_PrivateKey(rho, k, tr, s1, s2, t0);\n+    }\n+\n+    public byte[] sigEncode(ML_DSA_Signature sig) {\n+        int cSize = lambda \/ 4;\n+        int zSize = mlDsa_l * 32 * (1 + gamma1Bits);\n+\n+        byte[] zPacked = bitPack(sig.response, gamma1Bits + 1, gamma1);\n+        byte[] hPacked = hintBitPack(sig.hint);\n+\n+        byte[] sigBytes = new byte[cSize + zSize + omega + mlDsa_k];\n+        System.arraycopy(sig.commitmentHash, 0, sigBytes, 0, cSize);\n+        System.arraycopy(zPacked, 0, sigBytes, cSize, zSize);\n+        System.arraycopy(hPacked, 0, sigBytes, cSize + zSize, omega + mlDsa_k);\n+        return sigBytes;\n+    }\n+\n+    public ML_DSA_Signature sigDecode(byte[] sig) {\n+        \/\/Decode cTilde\n+        byte[] cTilde = Arrays.copyOfRange(sig, 0, lambda\/4);\n+\n+        \/\/Decode z\n+        int start = lambda \/ 4;\n+        int end = start + (32 * mlDsa_l * (1 + gamma1Bits));\n+        byte[] x = Arrays.copyOfRange(sig, start, end);\n+        int[][] z = bitUnpack(x, mlDsa_l, gamma1, gamma1Bits + 1);\n+\n+        \/\/Decode h\n+        start = end;\n+        end += omega + mlDsa_k;\n+        byte[] y = Arrays.copyOfRange(sig, start, end);\n+        boolean[][] h = hintBitUnpack(y);\n+        return new ML_DSA_Signature(cTilde, z, h);\n+    }\n+\n+    \/*\n+    Auxiliary functions defined in Section 8.3 of specification\n+     *\/\n+\n+    private class Shake256Slicer {\n+        SHAKE256 xof;\n+        byte[] block;\n+        int byteOffset;\n+        int current;\n+        int bitsInCurrent;\n+        int bitsPerCall;\n+        int bitMask;\n+\n+        Shake256Slicer(SHAKE256 xof, int bitsPerCall) {\n+            this.xof = xof;\n+            this.bitsPerCall = bitsPerCall;\n+            bitMask = (1 << bitsPerCall) - 1;\n+            current = 0;\n+            byteOffset = shake256BlockSize;\n+            bitsInCurrent = 0;\n+            block = new byte[shake256BlockSize];\n+        }\n+\n+        void reset() {\n+            xof.reset();\n+            current = 0;\n+            byteOffset = shake256BlockSize;\n+            bitsInCurrent = 0;\n+        }\n+\n+        int squeezeBits() {\n+            while (bitsInCurrent < bitsPerCall) {\n+                if (byteOffset == shake256BlockSize) {\n+                    xof.squeeze(block, 0, shake256BlockSize);\n+                    byteOffset = 0;\n+                }\n+                current += ((block[byteOffset++] & 0xff) << bitsInCurrent);\n+                bitsInCurrent += 8;\n+            }\n+            int result = current & bitMask;\n+            current >>= bitsPerCall;\n+            bitsInCurrent -= bitsPerCall;\n+            return result;\n+        }\n+    }\n+\n+    private int[] sampleInBall(byte[] rho) {\n+        var xof = new SHAKE256(0);\n+        Shake256Slicer slicer = new Shake256Slicer(xof, 8);\n+        xof.update(rho);\n+\n+        long parity = 0;\n+        for (int i = 0; i < 8; i++) {\n+            long sample = slicer.squeezeBits();\n+            parity |= sample << 8 * i;\n+        }\n+\n+        int[] c = new int[mlDsa_n];\n+        int k = 8;\n+        for (int i = 256 - tau; i < 256; i++) {\n+            \/\/Get random index < i\n+            int j = slicer.squeezeBits();\n+            while (j > i) {\n+                j = slicer.squeezeBits();\n+            }\n+\n+            \/\/Swap c[i] and c[j], set c[j] based on parity\n+            c[i] = c[j];\n+            c[j] = (int) (1 - 2 * (parity & 1));\n+            parity >>= 1;\n+        }\n+        return c;\n+    }\n+\n+    private void sampleS1S2(int[][] s1, int[][] s2, SHAKE256 xof, byte[] rhoPrime) {\n+        byte[] seed = new byte[mlDsaS1S2SeedLength + 2];\n+        System.arraycopy(rhoPrime, 0, seed, 0, mlDsaS1S2SeedLength);\n+\n+        int bitsPerCall = 4;\n+        Shake256Slicer slicer = new Shake256Slicer(xof, bitsPerCall);\n+        for (int i = 0; i < mlDsa_l; i++) {\n+            seed[mlDsaS1S2SeedLength] = (byte) i;\n+            seed[mlDsaS1S2SeedLength + 1] = 0;\n+            slicer.reset();\n+            xof.update(seed);\n+            if (eta == 2) {\n+                for (int j = 0; j < mlDsa_n; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 14);\n+                    s1[i][j] = eta - sample + (205 * sample >> 10) * 5; \/\/ 2 - sample mod 5\n+                }\n+            } else { \/\/ eta == 4\n+                for (int j = 0; j < mlDsa_n; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 2 * eta);\n+                    s1[i][j] = eta - sample;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            seed[mlDsaS1S2SeedLength] = (byte) (mlDsa_l + i);\n+            seed[mlDsaS1S2SeedLength + 1] = 0;\n+            slicer.reset();\n+            xof.update(seed);\n+            if (eta == 2) {\n+                for (int j = 0; j < mlDsa_n; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 14);\n+                    s2[i][j] = eta - sample + (205 * sample >> 10) * 5;\n+                }\n+            } else {\n+                for (int j = 0; j < mlDsa_n; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 2 * eta);\n+                    s2[i][j] = eta - sample;\n+                }\n+            }\n+        }\n+    }\n+\n+    int[][][] generateA(byte[] seed) {\n+        int blockSize = 168;  \/\/ the size of one block of SHAKE128 output\n+        var xof = new SHAKE128(0);\n+        byte[] xofSeed = new byte[mlDsaASeedLength + 2];\n+        System.arraycopy(seed, 0, xofSeed, 0, mlDsaASeedLength);\n+        int[][][] a = new int[mlDsa_k][mlDsa_l][mlDsa_n];\n+\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_l; j++) {\n+                xofSeed[mlDsaASeedLength] = (byte) j;\n+                xofSeed[mlDsaASeedLength + 1] = (byte) i;\n+                xof.reset();\n+                xof.update(xofSeed);\n+\n+                byte[] rawAij = new byte[blockSize];\n+                int[] aij = new int[mlDsa_n];\n+                int ofs = 0;\n+                int rawOfs = blockSize;\n+                int tmp;\n+                while (ofs < mlDsa_n) {\n+                    if (rawOfs == blockSize) {  \/\/ works because 3 divides blockSize (=168)\n+                        xof.squeeze(rawAij, 0, blockSize);\n+                        rawOfs = 0;\n+                    }\n+                    tmp = (rawAij[rawOfs] & 0xFF) +\n+                        ((rawAij[rawOfs + 1] & 0xFF) << 8) +\n+                        ((rawAij[rawOfs + 2] & 0x7F) << 16);\n+                    rawOfs += 3;\n+                    if (tmp < mlDsa_q) {\n+                        aij[ofs] = tmp;\n+                        ofs++;\n+                    }\n+                }\n+                a[i][j] = aij;\n+            }\n+        }\n+        return a;\n+    }\n+\n+    private int[][] expandMask(byte[] rho, int mu) {\n+        var xof = new SHAKE256(0);\n+\n+        int[][] res = new int[mlDsa_l][mlDsa_n];\n+        int c = 1 + gamma1Bits;\n+        byte[] v = new byte[mlDsa_l * 32 * c];\n+        for (int r = 0; r < mlDsa_l; r++) {\n+            int a = mu + r;\n+            byte[] n = {(byte) a, (byte) (a >> 8)};\n+\n+            xof.update(rho);\n+            xof.update(n);\n+            for (int i = 0; i < 32*c; i++) {\n+                v[r*32*c + i] = xof.squeeze(1)[0];\n+            }\n+            xof.reset();\n+        }\n+        return bitUnpack(v, mlDsa_l, gamma1, c);\n+    }\n+\n+    \/*\n+    Auxiliary functions defined in section 8.4 of specification\n+     *\/\n+\n+    private void power2Round(int[][] input, int[][] lowPart, int[][] highPart) {\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                int rplus = input[i][m];\n+                int r0 = input[i][m] & dMask;\n+                int r00 = (1 << (mlDsa_d - 1)) - r0 ; \/\/ 2^d\/2 - r+\n+                r0 -= (r00 >> 31) & (1 << mlDsa_d); \/\/0 if r+ < 2^d\/2\n+                lowPart[i][m] = r0;\n+                highPart[i][m] = (rplus - r0) >> mlDsa_d;\n+            }\n+        }\n+    }\n+\n+    private void decompose(int[][] input, int[][] lowPart, int[][] highPart) {\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                int rplus = (input[i][m] + mlDsa_q) % mlDsa_q;\n+                int r0 = rplus % (2*gamma2);\n+                r0 -= r0 > gamma2 ? 2*gamma2 : 0;\n+                int r1;\n+                if (rplus - r0 == mlDsa_q - 1) {\n+                    r1 = 0;\n+                    r0 = r0 - 1;\n+                } else {\n+                    r1 = (rplus - r0) \/ (2*gamma2);\n+                }\n+                lowPart[i][m] = r0;\n+                highPart[i][m] = r1;\n+            }\n+        }\n+    }\n+\n+    private int highBits(int input) {\n+        int rplus = (input + mlDsa_q) % mlDsa_q;\n+        int r0 = rplus % (2*gamma2);\n+        r0 -= r0 > gamma2 ? 2*gamma2 : 0;\n+        int r1;\n+        if (rplus - r0 == mlDsa_q - 1) {\n+            r1 = 0;\n+            r0 = r0 - 1;\n+        } else {\n+            r1 = (rplus - r0) \/ (2*gamma2);\n+        }\n+        return r1;\n+    }\n+\n+    private boolean[][] makeHint(int[][] z, int[][] r) {\n+        int[][] v1 = vectorAdd(r,z);\n+        boolean[][] res = new boolean[mlDsa_k][mlDsa_n];\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                int r1High = highBits(r[i][j]);\n+                int v1High = highBits(v1[i][j]);\n+                res[i][j] = r1High != v1High;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private int[][] useHint(boolean[][] h, int[][] r) {\n+        int m = (mlDsa_q - 1) \/ (2*gamma2);\n+        int[][] lowPart = new int[mlDsa_k][mlDsa_n];\n+        int[][] highPart = new int[mlDsa_k][mlDsa_n];\n+        decompose(r, lowPart, highPart);\n+\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                if (h[i][j]) {\n+                    highPart[i][j] += lowPart[i][j] > 0 ? 1 : -1;\n+                }\n+                highPart[i][j] = ((highPart[i][j] % m) + m) % m;\n+            }\n+        }\n+        return highPart;\n+    }\n+\n+    \/*\n+    NTT functions as specified in Section 8.5 of specification\n+    *\/\n+\n+    public static int[] mlDsaNtt(int[] coeffs) {\n+        int result = implMlDsaAlmostNtt(coeffs, montZetasForVectorNtt);\n+        int[] check = coeffs.clone();\n+        result = implMlDsaMontMulByConstant(coeffs,  montRModQ);\n+        return coeffs;\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implMlDsaAlmostNtt(int[] coeffs, int[] zetas) {\n+        return implMlDsaAlmostNttJava(coeffs);\n+    }\n+\n+    static int implMlDsaAlmostNttJava(int[] coeffs) {\n+        int dimension = mlDsa_n;\n+        int m = 0;\n+        for (int l = dimension \/ 2; l > 0; l \/= 2) {\n+            for (int s = 0; s < dimension; s += 2 * l) {\n+                for (int j = s; j < s + l; j++) {\n+                    int tmp = montMul(montZetasForNtt[m], coeffs[j + l]);\n+                    coeffs[j + l] = coeffs[j] - tmp;\n+                    coeffs[j] = coeffs[j] + tmp;\n+                }\n+                m++;\n+            }\n+        }\n+\n+        return 1;\n+    }\n+\n+    public static int[] mlDsaInverseNtt(int[] coeffs) {\n+        int result = implMlDsaAlmostInverseNtt(coeffs, montZetasForVectorInverseNtt);\n+        result = implMlDsaMontMulByConstant(coeffs, montDimInverse);\n+        return coeffs;\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implMlDsaAlmostInverseNtt(int[] coeffs, int[] zetas) {\n+        return implMlDsaAlmostInverseNttJava(coeffs);\n+    }\n+\n+    static int implMlDsaAlmostInverseNttJava(int[] coeffs) {\n+        int dimension = mlDsa_n;\n+        int m = 0;\n+        for (int l = 1; l < dimension; l *= 2) {\n+            for (int s = 0; s < dimension; s += 2 * l) {\n+                for (int j = s; j < s + l; j++) {\n+                    int tmp = coeffs[j];\n+                    coeffs[j] = (tmp + coeffs[j + l]);\n+                    coeffs[j + l] = montMul(tmp - coeffs[j + l], montZetasForInverseNtt[m]);\n+                }\n+                m++;\n+            }\n+        }\n+\n+        return 1;\n+    }\n+\n+    void mlDsaVectorNtt(int[][] vector) {\n+        for (int[] ints : vector) {\n+            mlDsaNtt(ints);\n+        }\n+    }\n+\n+    void mlDsaVectorInverseNtt(int[][] vector) {\n+        for (int[] ints : vector) {\n+            mlDsaInverseNtt(ints);\n+        }\n+    }\n+\n+    public static int[] mlDsaNttMultiply(int[] coeffs1, int[] coeffs2) {\n+        int[] product = new int[mlDsa_n];\n+        int result = implMlDsaNttMult(product, coeffs1, coeffs2);\n+        return product;\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implMlDsaNttMult(int[] product, int[] coeffs1, int[] coeffs2) {\n+        return implMlDsaNttMultJava(product, coeffs1, coeffs2);\n+    }\n+\n+    static int implMlDsaNttMultJava(int[] product, int[] coeffs1, int[] coeffs2) {\n+        for (int i = 0; i < mlDsa_n; i++) {\n+            product[i] = montMul(coeffs1[i], toMont(coeffs2[i]));\n+        }\n+        return 1;\n+    }\n+\n+    public static void montMulByConstant(int[] coeffs, int constant) {\n+        int[] check = coeffs.clone();\n+        int result = implMlDsaMontMulByConstant(coeffs, constant);\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implMlDsaMontMulByConstant(int[] coeffs, int constant) {\n+        return implMlDsaMontMulByConstantJava(coeffs, constant);\n+    }\n+\n+    static int implMlDsaMontMulByConstantJava(int[] coeffs, int constant) {\n+        for (int i = 0; i < mlDsa_n; i++) {\n+            coeffs[i] = montMul((coeffs[i]), constant);\n+        }\n+        return 1;\n+    }\n+\n+    public static int mlDsaDecomposePoly(int[] input, int[] lowPart, int[] highPart,\n+                                         int twoGamma2, int multiplier) {\n+        return implMlDsaDecomposePoly(input, lowPart, highPart,\n+            twoGamma2, multiplier);\n+    }\n+\n+    @IntrinsicCandidate\n+    static int implMlDsaDecomposePoly(int[] input, int[] lowPart, int[] highPart,\n+                                          int twoGamma2, int multiplier) {\n+        return decomposePolyJava(input, lowPart, highPart, twoGamma2, multiplier);\n+    }\n+\n+    static int decomposePolyJava(int[] input, int[] lowPart, int[] highPart,\n+                                 int twoGamma2, int multiplier) {\n+        for (int m = 0; m < mlDsa_n; m++) {\n+            int rplus = input[m];\n+            rplus = rplus - ((rplus + 5373807) >> 23) * mlDsa_q;\n+            rplus = rplus + ((rplus >> 31) & mlDsa_q);\n+            int r0 = rplus - ((rplus * multiplier) >> 22) * twoGamma2;\n+            r0 -= (((twoGamma2 - r0) >> 22) & twoGamma2);\n+            r0 -= (((twoGamma2 \/ 2 - r0) >> 31) & twoGamma2);\n+            int r1 = rplus - r0 - (mlDsa_q - 1);\n+            r1 = (r1 | (-r1)) >> 31;\n+            r0 += ~r1;\n+            r1 = r1 & ((rplus - r0) \/ twoGamma2);\n+            lowPart[m] = r0;\n+            highPart[m] = r1;\n+        }\n+        return 1;\n+    }\n+\n+    private int[][] matrixVectorPointwiseMultiply(int[][][] matrix, int[][] vector) {\n+        int[][] result = new int[mlDsa_k][mlDsa_n];\n+        int resulti[] = new int[mlDsa_n];\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                resulti[m] = 0;\n+            }\n+            for (int j = 0; j < mlDsa_l; j++) {\n+                int[] product = mlDsaNttMultiply(matrix[i][j], vector[j]);\n+                for (int m = 0; m < mlDsa_n; m++) {\n+                    resulti[m] += product[m];\n+                }\n+            }\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                result[i][m] = montMul(resulti[m], montRModQ);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private int[][] nttConstMultiply(int[] a, int[][] b) {\n+        int[][] res = new int[b.length][mlDsa_n];\n+        for (int i = 0; i < b.length; i++) {\n+            res[i] = mlDsaNttMultiply(a, b[i]);\n+        }\n+        return res;\n+    }\n+\n+    private int[][] vectorConstMul(int c, int[][] vec) {\n+        int[][] res = new int[vec.length][vec[0].length];\n+        for (int i = 0; i < vec.length; i++) {\n+            for (int j = 0; j < vec[0].length; j++) {\n+                res[i][j] = (c * vec[i][j]) % mlDsa_q;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    \/\/ Adds two vectors of polynomials\n+    \/\/ The coefficients in the input should be between -montQ and montQ .\n+    \/\/ The coefficients in the output will be nonnegative and less than montQ\n+    int[][] vectorAddPos(int[][] vec1, int[][] vec2) {\n+        int dim = vec1.length;\n+        int[][] result = new int[dim][mlDsa_n];\n+        for (int i = 0; i < dim; i++) {\n+            for (int m = 0; m < mlDsa_n; m++) {\n+                int r = vec1[i][m] + vec2[i][m]; \/\/ -2 * montQ < r < 2 * montQ\n+                r += (((r >> 31) & (2 * montQ)) - montQ); \/\/ -montQ < r < montQ\n+                r += ((r >> 31) & montQ); \/\/ 0 <= r < montQ\n+                result[i][m] = r;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    int[][] vectorAdd(int[][] vec1, int[][] vec2) {\n+        int dim = vec1.length;\n+        int[][] result = new int[dim][mlDsa_n];\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                int tmp = vec1[i][j] + vec2[i][j];\n+                tmp -= tmp >= mlDsa_q ? mlDsa_q : 0;\n+                result[i][j] = tmp;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    int[][] vectorSub(int[][] vec1, int[][] vec2) {\n+        int dim = vec1.length;\n+        int[][] result = new int[dim][mlDsa_n];\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                int tmp = vec1[i][j] - vec2[i][j];\n+                tmp += tmp < 0 ? mlDsa_q : 0;\n+                result[i][j] = tmp;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/\/Precondition: 2^-31 <= r1 <= 2^31 - 5 * 2^20, and bound < q - 5234431\n+    \/\/Computes whether the infinity norm of a vector is >= bound\n+    boolean vectorNormBound(int[][] vec, int bound) {\n+        boolean res = false;\n+        for (int i = 0; i < vec.length; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                int r1 = vec[i][j];\n+                r1 = r1 - ((r1 + (5  << 20)) >> 23) * mlDsa_q;\n+                r1 = r1 - ((r1 >> 31) & r1) * 2;\n+                res |= (r1 >= bound);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private int hammingWeight(boolean[][] vec) {\n+        int weight = 0;\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_n; j++) {\n+                weight += vec[i][j] ? 1 : 0;\n+            }\n+        }\n+        return weight;\n+    }\n+\n+    \/\/ precondition: -2^31 * montQ <= a, b < 2^31, -2^31 < a * b < 2^31 * montQ\n+    \/\/ computes a * b * 2^-32 mod montQ\n+    \/\/ the result is greater than -montQ and less than montQ\n+    private static int montMul(int b, int c) {\n+        long a = (long) b * (long) c;\n+        int aHigh = (int) (a >> montRBits);\n+        int aLow = (int) a;\n+        int m = montQInvModR * aLow; \/\/ signed low product\n+\n+        return (aHigh - (int) (((long)m * montQ) >> montRBits));  \/\/ subtract signed high product\n+    }\n+\n+    static int toMont(int a) {\n+        return montMul(a, montRSquareModQ);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":1420,"deletions":0,"binary":false,"changes":1420,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.jca.JCAUtil;\n+import java.security.*;\n+import java.security.SecureRandom;\n+\n+public class ML_DSA_Provider {\n+\n+    static int name2int(String name) {\n+        if (name.endsWith(\"44\")) return 2;\n+        else if (name.endsWith(\"65\")) return 3;\n+        else if (name.endsWith(\"87\")) return 5;\n+        else throw new ProviderException();\n+    }\n+\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            \/\/ ML-DSA-65 is default\n+            super(\"ML-DSA\", \"ML-DSA-65\", \"ML-DSA-44\", \"ML-DSA-87\");\n+        }\n+\n+        public KPG(String pname) {\n+            super(\"ML-DSA\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n+            byte[] seed = new byte[32];\n+            var r = sr != null ? sr : JCAUtil.getDefSecureRandom();\n+            r.nextBytes(seed);\n+            ML_DSA mlDsa = new ML_DSA(name2int(name));\n+            ML_DSA.ML_DSA_KeyPair kp = mlDsa.generateKeyPair(seed);\n+            return new byte[][] {\n+                    mlDsa.pkEncode(kp.publicKey()),\n+                    mlDsa.skEncode(kp.privateKey()) };\n+        }\n+    }\n+\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"ML-DSA-44\");\n+        }\n+    }\n+\n+    public static class KPG3 extends KPG {\n+        public KPG3() {\n+            super(\"ML-DSA-65\");\n+        }\n+    }\n+\n+    public static class KPG5 extends KPG {\n+        public KPG5() {\n+            super(\"ML-DSA-87\");\n+        }\n+    }\n+\n+    public static class KF extends NamedKeyFactory {\n+        public KF() {\n+            super(\"ML-DSA\", \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n+        }\n+        public KF(String name) {\n+            super(\"ML-DSA\", name);\n+        }\n+    }\n+\n+    public static class KF2 extends KF {\n+        public KF2() {\n+            super(\"ML-DSA-44\");\n+        }\n+    }\n+\n+    public static class KF3 extends KF {\n+        public KF3() {\n+            super(\"ML-DSA-65\");\n+        }\n+    }\n+\n+    public static class KF5 extends KF {\n+        public KF5() {\n+            super(\"ML-DSA-87\");\n+        }\n+    }\n+\n+    \/\/ TODO: check key in initSign and initVerify?\n+    public static class SIG extends NamedSignature {\n+        public SIG() {\n+            super(\"ML-DSA\", \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n+        }\n+        public SIG(String name) {\n+            super(\"ML-DSA\", name);\n+        }\n+\n+        @Override\n+        public byte[] implSign(String name, byte[] skBytes, Object sk2, byte[] msg, SecureRandom sr) {\n+            var size = name2int(name);\n+            var r = sr != null ? sr : JCAUtil.getDefSecureRandom();\n+            byte[] rnd = new byte[32];\n+            r.nextBytes(rnd);\n+            var mlDsa = new ML_DSA(size);\n+            var sk = mlDsa.skDecode(skBytes);\n+            ML_DSA.ML_DSA_Signature sig = mlDsa.sign(msg, rnd, sk);\n+            return mlDsa.sigEncode(sig);\n+        }\n+\n+        @Override\n+        public boolean implVerify(String name, byte[] pkBytes, Object pk2, byte[] msg, byte[] sigBytes) {\n+            var size = name2int(name);\n+            var mlDsa = new ML_DSA(size);\n+            var pk = mlDsa.pkDecode(pkBytes);\n+            var sig = mlDsa.sigDecode(sigBytes);\n+            return mlDsa.verify(pk, msg, sig);\n+        }\n+    }\n+\n+    public static class SIG2 extends SIG {\n+        public SIG2() {\n+            super(\"ML-DSA-44\");\n+        }\n+    }\n+\n+    public static class SIG3 extends SIG {\n+        public SIG3() {\n+            super(\"ML-DSA-65\");\n+        }\n+    }\n+\n+    public static class SIG5 extends SIG {\n+        public SIG5() {\n+            super(\"ML-DSA-87\");\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Provider.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+\/\/\/ An implementation extends this class to create its own `KEM`.\n+\/\/\/\n+\/\/\/ @see NamedKeyPairGenerator\n+public abstract class NamedKEM implements KEMSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    \/\/\/ Creates a new `NamedKEM` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedKEM(String fname, String... pnames) {\n+        this.fname = Objects.requireNonNull(fname);\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.pnames = pnames;\n+    }\n+\n+    @Override\n+    public EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"No params needed\");\n+        }\n+        \/\/ translate also check the key\n+        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(publicKey);\n+        var pk = nk.getRawBytes();\n+        return getKeyConsumerImpl(this, nk.getParams(), pk,\n+                implCheckPublicKey(nk.getParams().getName(), pk), secureRandom);\n+    }\n+\n+    @Override\n+    public DecapsulatorSpi engineNewDecapsulator(\n+            PrivateKey privateKey, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"No params needed\");\n+        }\n+        \/\/ translate also check the key\n+        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(privateKey);\n+        var sk = nk.getRawBytes();\n+        return getKeyConsumerImpl(this, nk.getParams(), sk,\n+                implCheckPrivateKey(nk.getParams().getName(), sk), null);\n+    }\n+\n+    \/\/ We don't have a flag on whether key is public key or private key.\n+    \/\/ The correct method should always be called.\n+    private record KeyConsumerImpl(NamedKEM kem, String name, int sslen,\n+            int clen, byte[] key, Object k2, SecureRandom sr)\n+            implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation, int from, int to,\n+                String algorithm) throws DecapsulateException {\n+            if (encapsulation.length != clen) {\n+                throw new DecapsulateException(\"Invalid key encapsulation message length\");\n+            }\n+            var ss = kem.implDecapsulate(name, key, k2, encapsulation);\n+            try {\n+                return new SecretKeySpec(ss,\n+                        from, to - from, algorithm);\n+            } finally {\n+                Arrays.fill(ss, (byte)0);\n+            }\n+        }\n+\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm) {\n+            var enc = kem.implEncapsulate(name, key, k2, sr);\n+            try {\n+                return new KEM.Encapsulated(\n+                        new SecretKeySpec(enc[1],\n+                                from, to - from, algorithm),\n+                        enc[0],\n+                        null);\n+            } finally {\n+                Arrays.fill(enc[1], (byte)0);\n+            }\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            return sslen;\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            return clen;\n+        }\n+    }\n+\n+    private static KeyConsumerImpl getKeyConsumerImpl(NamedKEM kem,\n+            NamedParameterSpec nps, byte[] key, Object k2, SecureRandom sr) {\n+        String name = nps.getName();\n+        return new KeyConsumerImpl(kem, name, kem.implSecretSize(name), kem.implEncapsulationSize(name),\n+                key, k2, sr);\n+    }\n+\n+    \/\/\/ User-defined encap function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @param pk2 parsed public key, `null` if none.\n+    \/\/\/ @param sr SecureRandom object, `null` if not initialized\n+    \/\/\/ @return the key encapsulation message and the shared key (in this order)\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    public abstract byte[][] implEncapsulate(String name, byte[] pk, Object pk2, SecureRandom sr);\n+\n+    \/\/\/ User-defined decap function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @param sk2 parsed private key, `null` if none.\n+    \/\/\/ @param encap the key encapsulation message\n+    \/\/\/ @return the shared key\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws DecapsulateException if there is another error\n+    public abstract byte[] implDecapsulate(String name, byte[] sk, Object sk2, byte[] encap)\n+            throws DecapsulateException;\n+\n+    \/\/\/ User-defined function returning shared secret key length.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @return shared secret key length\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    public abstract int implSecretSize(String name);\n+\n+    \/\/\/ User-defined function returning key encapsulation message length.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @return key encapsulation message length\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    public abstract int implEncapsulationSize(String name);\n+\n+    \/\/\/ User-defined function to validate a public key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `newEncapsulator`. This gives provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optional return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implEncapsulate] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    public Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined function to validate a private key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `newDecapsulator`. This gives provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optional return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implDecapsulate] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    public Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKEM.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.util.RawKeySpec;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.AsymmetricKey;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyFactorySpi;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.spec.EncodedKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+\/\/\/ An implementation extends this class to create its own `KeyFactory`.\n+\/\/\/\n+\/\/\/ Bonus: This factory supports reading and writing to RAW formats:\n+\/\/\/\n+\/\/\/ 1. It reads from a RAW key using `translateKey` if `key.getFormat` is \"RAW\".\n+\/\/\/ 2. It writes to a RAW [EncodedKeySpec] if `getKeySpec(key, EncodedKeySpec.class)`\n+\/\/\/    is called. The format of the output is \"RAW\" and the algorithm is\n+\/\/\/    intentionally left unspecified.\n+\/\/\/ 3. It reads from and writes to the internal type [RawKeySpec].\n+\/\/\/\n+\/\/\/ When reading from a RAW format, it needs enough info to derive the\n+\/\/\/ parameter set name.\n+\/\/\/\n+\/\/\/ @see NamedKeyPairGenerator\n+public class NamedKeyFactory extends KeyFactorySpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    \/\/\/ Creates a new `NamedKeyFactory` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedKeyFactory(String fname, String... pnames) {\n+        this.fname = Objects.requireNonNull(fname);\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.pnames = pnames;\n+    }\n+\n+    private String checkName(String name) throws InvalidKeyException  {\n+        for (var pname : pnames) {\n+            if (pname.equalsIgnoreCase(name)) {\n+                \/\/ return the stored standard name\n+                return pname;\n+            }\n+        }\n+        throw new InvalidKeyException(\"Unknown parameter set name: \" + name);\n+    }\n+\n+    @Override\n+    protected PublicKey engineGeneratePublic(KeySpec keySpec)\n+            throws InvalidKeySpecException {\n+        if (keySpec instanceof X509EncodedKeySpec xspec) {\n+            try {\n+                return fromX509(xspec.getEncoded());\n+            } catch (InvalidKeyException e) {\n+                throw new InvalidKeySpecException(e);\n+            }\n+        } else if (keySpec instanceof RawKeySpec rks) {\n+            if (pnames.length == 1) {\n+                return new NamedX509Key(fname, pnames[0], rks.getKeyArr());\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else if (keySpec instanceof EncodedKeySpec espec\n+                && espec.getFormat().equalsIgnoreCase(\"RAW\")) {\n+            if (pnames.length == 1) {\n+                return new NamedX509Key(fname, pnames[0], espec.getEncoded());\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else {\n+            throw new InvalidKeySpecException(\"Unsupported keyspec: \" + keySpec);\n+        }\n+    }\n+\n+    @Override\n+    protected PrivateKey engineGeneratePrivate(KeySpec keySpec)\n+            throws InvalidKeySpecException {\n+        if (keySpec instanceof PKCS8EncodedKeySpec pspec) {\n+            var bytes = pspec.getEncoded();\n+            try {\n+                return fromPKCS8(bytes);\n+            } catch (InvalidKeyException e) {\n+                throw new InvalidKeySpecException(e);\n+            } finally {\n+                Arrays.fill(bytes, (byte) 0);\n+            }\n+        } else if (keySpec instanceof RawKeySpec rks) {\n+            if (pnames.length == 1) {\n+                var bytes = rks.getKeyArr();\n+                try {\n+                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n+                } finally {\n+                    Arrays.fill(bytes, (byte) 0);\n+                }\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else if (keySpec instanceof EncodedKeySpec espec\n+                && espec.getFormat().equalsIgnoreCase(\"RAW\")) {\n+            if (pnames.length == 1) {\n+                var bytes = espec.getEncoded();\n+                try {\n+                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n+                } finally {\n+                    Arrays.fill(bytes, (byte) 0);\n+                }\n+            } else {\n+                throw new InvalidKeySpecException(\"Parameter set name unavailable\");\n+            }\n+        } else {\n+            throw new InvalidKeySpecException(\"Unsupported keyspec: \" + keySpec);\n+        }\n+    }\n+\n+    private PrivateKey fromPKCS8(byte[] bytes)\n+            throws InvalidKeyException, InvalidKeySpecException {\n+        var k = new NamedPKCS8Key(fname, bytes);\n+        checkName(k.getParams().getName());\n+        return k;\n+    }\n+\n+    private PublicKey fromX509(byte[] bytes)\n+            throws InvalidKeyException, InvalidKeySpecException {\n+        var k = new NamedX509Key(fname, bytes);\n+        checkName(k.getParams().getName());\n+        return k;\n+    }\n+\n+    private static class RawEncodedKeySpec extends EncodedKeySpec {\n+        public RawEncodedKeySpec(byte[] encodedKey) {\n+            super(encodedKey);\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return \"RAW\";\n+        }\n+    }\n+\n+    @Override\n+    protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec)\n+            throws InvalidKeySpecException {\n+        try {\n+            key = engineTranslateKey(key);\n+        } catch (InvalidKeyException e) {\n+            throw new InvalidKeySpecException(e);\n+        }\n+        \/\/ key is now either NamedPKCS8Key or NamedX509Key of permitted param set\n+        if (key instanceof NamedPKCS8Key nk) {\n+            byte[] bytes = null;\n+            try {\n+                if (keySpec == PKCS8EncodedKeySpec.class) {\n+                    return keySpec.cast(\n+                            new PKCS8EncodedKeySpec(bytes = key.getEncoded()));\n+                } else if (keySpec == RawKeySpec.class) {\n+                    return keySpec.cast(new RawKeySpec(nk.getRawBytes()));\n+                } else if (keySpec.isAssignableFrom(EncodedKeySpec.class)) {\n+                    return keySpec.cast(\n+                            new RawEncodedKeySpec(nk.getRawBytes()));\n+                } else {\n+                    throw new InvalidKeySpecException(\"Unsupported type: \" + keySpec);\n+                }\n+            } finally {\n+                if (bytes != null) {\n+                    Arrays.fill(bytes, (byte)0);\n+                }\n+            }\n+        } else if (key instanceof NamedX509Key nk) {\n+            if (keySpec == X509EncodedKeySpec.class\n+                    && key.getFormat().equalsIgnoreCase(\"X.509\")) {\n+                return keySpec.cast(new X509EncodedKeySpec(key.getEncoded()));\n+            } else if (keySpec == RawKeySpec.class) {\n+                return keySpec.cast(new RawKeySpec(nk.getRawBytes()));\n+            } else if (keySpec.isAssignableFrom(EncodedKeySpec.class)) {\n+                return keySpec.cast(new RawEncodedKeySpec(nk.getRawBytes()));\n+            } else {\n+                throw new InvalidKeySpecException(\"Unsupported type: \" + keySpec);\n+            }\n+        }\n+        throw new AssertionError(\"No \" + keySpec.getName() + \" for \" + key.getClass());\n+    }\n+\n+    @Override\n+    protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+        if (key == null) {\n+            throw new InvalidKeyException(\"Key must not be null\");\n+        }\n+        if (key instanceof NamedX509Key nk) {\n+            checkName(nk.getParams().getName());\n+            return key;\n+        }\n+        if (key instanceof NamedPKCS8Key nk) {\n+            checkName(nk.getParams().getName());\n+            return key;\n+        }\n+        var format = key.getFormat();\n+        if (format == null) {\n+            throw new InvalidKeyException(\"Unextractable key\");\n+        } else if (format.equalsIgnoreCase(\"RAW\")) {\n+            var kAlg = key.getAlgorithm();\n+            if (key instanceof AsymmetricKey pk) {\n+                String name;\n+                \/\/ Three case that we can find the parameter set name from a RAW key:\n+                \/\/ 1. getParams() returns one\n+                \/\/ 2. getAlgorithm() returns param set name (some provider does this)\n+                \/\/ 3. getAlgorithm() returns family name but this KF is for param set name\n+                if (pk.getParams() instanceof NamedParameterSpec nps) {\n+                    name = checkName(nps.getName());\n+                } else {\n+                    if (kAlg.equalsIgnoreCase(fname)) {\n+                        if (pnames.length == 1) {\n+                            name = pnames[0];\n+                        } else {\n+                            throw new InvalidKeyException(\"No parameter set info\");\n+                        }\n+                    } else {\n+                        name = checkName(kAlg);\n+                    }\n+                }\n+                return key instanceof PrivateKey\n+                        ? new NamedPKCS8Key(fname, name, key.getEncoded())\n+                        : new NamedX509Key(fname, name, key.getEncoded());\n+            } else {\n+                throw new InvalidKeyException(\"Unsupported key type: \" + key.getClass());\n+            }\n+        } else if (format.equalsIgnoreCase(\"PKCS#8\") && key instanceof PrivateKey) {\n+            var bytes = key.getEncoded();\n+            try {\n+                return fromPKCS8(bytes);\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(\"Invalid PKCS#8 key\", e);\n+            } finally {\n+                Arrays.fill(bytes, (byte) 0);\n+            }\n+        } else if (format.equalsIgnoreCase(\"X.509\") && key instanceof PublicKey) {\n+            try {\n+                return fromX509(key.getEncoded());\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(\"Invalid X.509 key\", e);\n+            }\n+        } else {\n+            throw new InvalidKeyException(\"Unknown key format: \" + key.getFormat());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyFactory.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGeneratorSpi;\n+import java.security.ProviderException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Objects;\n+\n+\/\/\/ An implementation extends this class to create its own `KeyPairGenerator`.\n+\/\/\/\n+\/\/\/ An implementation must include a zero-argument public constructor that calls\n+\/\/\/ `super(fname, pnames)`, where `fname` is the family name of the algorithm and\n+\/\/\/ `pnames` are the supported parameter set names. `pnames` must contain at least\n+\/\/\/ one element and the first element is the default parameter set name,\n+\/\/\/ i.e. the parameter set to be used in key pair generation unless\n+\/\/\/ [#initialize(AlgorithmParameterSpec, java.security.SecureRandom)]\n+\/\/\/ is called to choose a specific parameter set. This requirement also applies\n+\/\/\/ to implementations of [NamedKeyFactory], [NamedKEM], and [NamedSignature],\n+\/\/\/ although there is no default parameter set concept for these classes.\n+\/\/\/\n+\/\/\/ An implementation must implement all abstract methods. For all these\n+\/\/\/ methods, the implementation must relinquish any \"ownership\" of any input\n+\/\/\/ and output array argument. Precisely, the implementation must not retain\n+\/\/\/ any reference to a returning array so that it won't be able to modify its\n+\/\/\/ content later. Similarly, the implementation must not modify any input\n+\/\/\/ array argument and must not retain any reference to an input array argument\n+\/\/\/ after the call. Together, this makes sure that the caller does not need to\n+\/\/\/ make any defensive copy on the input and output arrays. This requirement\n+\/\/\/ also applies to abstract methods defined in [NamedKEM] and [NamedSignature].\n+\/\/\/\n+\/\/\/ Also, an implementation must not keep any extra copy of a private key.\n+\/\/\/ For key generation, the only copy is the one returned in the\n+\/\/\/ [#implGenerateKeyPair] call. For all other methods, it must not make\n+\/\/\/ a copy of the input private key. A `KEM` implementation also must\n+\/\/\/ not keep a copy of the shared secret key, no matter if it's an\n+\/\/\/ encapsulator or a decapsulator.\n+\/\/\/\n+\/\/\/ The `NamedSignature` and `NamedKEM` classes provide `implCheckPublicKey`\n+\/\/\/ and `implCheckPrivateKey` methods that allow an implementation to validate\n+\/\/\/ a key before using it. An implementation may return a parsed key of\n+\/\/\/ a local type, and this parsed key will be passed to an operational method\n+\/\/\/ (For example, `implSign`) later. An implementation must not retain\n+\/\/\/ a reference of the parsed key.\n+public abstract class NamedKeyPairGenerator extends KeyPairGeneratorSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    protected String name = null; \/\/ init as\n+    private SecureRandom secureRandom;\n+\n+    \/\/\/ Creates a new `NamedKeyPairGenerator` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames supported parameter set names, at least one is needed.\n+    \/\/\/     If multiple, the first one becomes the default parameter set name.\n+    protected NamedKeyPairGenerator(String fname, String... pnames) {\n+        this.fname = Objects.requireNonNull(fname);\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.pnames = pnames;\n+    }\n+\n+    private String checkName(String name) throws InvalidAlgorithmParameterException  {\n+        for (var pname : pnames) {\n+            if (pname.equalsIgnoreCase(name)) {\n+                \/\/ return the stored standard name\n+                return pname;\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+                \"Unknown parameter set name: \" + name);\n+    }\n+\n+    @Override\n+    public void initialize(AlgorithmParameterSpec params, SecureRandom random)\n+            throws InvalidAlgorithmParameterException {\n+        if (params instanceof NamedParameterSpec spec) {\n+            name = checkName(spec.getName());\n+        } else {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Unknown AlgorithmParameterSpec: \" + params);\n+        }\n+        this.secureRandom = random ;\n+    }\n+\n+    @Override\n+    public void initialize(int keysize, SecureRandom random) {\n+        if (keysize != -1) {\n+            \/\/ Bonus: a chance to provide a SecureRandom without\n+            \/\/ specifying a parameter set name\n+            throw new InvalidParameterException(\"keysize not supported\");\n+        }\n+        this.secureRandom = random;\n+    }\n+\n+    @Override\n+    public KeyPair generateKeyPair() {\n+        String pname = name != null ? name : pnames[0];\n+        var keys = implGenerateKeyPair(pname, secureRandom);\n+        return new KeyPair(new NamedX509Key(fname, pname, keys[0]),\n+                new NamedPKCS8Key(fname, pname, keys[1]));\n+    }\n+\n+    \/\/\/ User-defined key pair generator.\n+    \/\/\/\n+    \/\/\/ @param pname parameter set name\n+    \/\/\/ @param sr `SecureRandom` object, `null` if not initialized\n+    \/\/\/ @return public key and private key (in this order) in raw bytes\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    public abstract byte[][] implGenerateKeyPair(String pname, SecureRandom sr);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyPairGenerator.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidParameterException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureException;\n+import java.security.SignatureSpi;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Objects;\n+\n+\/\/\/ An implementation extends this class to create its own `Signature`.\n+\/\/\/\n+\/\/\/ This class does not work with preHash signatures.\n+\/\/\/\n+\/\/\/ @see NamedKeyPairGenerator\n+public abstract class NamedSignature extends SignatureSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    private final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+\n+    \/\/ init with...\n+    private String name = null;\n+    private byte[] secKey = null;\n+    private byte[] pubKey = null;\n+\n+    private Object sk2 = null;\n+    private Object pk2 = null;\n+\n+    \/\/\/ Creates a new `NamedSignature` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedSignature(String fname, String... pnames) {\n+        this.fname = Objects.requireNonNull(fname);\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.pnames = pnames;\n+    }\n+\n+    @Override\n+    protected void engineInitVerify(PublicKey publicKey) throws InvalidKeyException {\n+        \/\/ translate also check the key\n+        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(publicKey);\n+        name = nk.getParams().getName();\n+        pubKey = nk.getRawBytes();\n+        pk2 = implCheckPublicKey(name, pubKey);\n+        secKey = null;\n+        bout.reset();\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey) throws InvalidKeyException {\n+        \/\/ translate also check the key\n+        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(privateKey);\n+        name = nk.getParams().getName();\n+        secKey = nk.getRawBytes();\n+        sk2 = implCheckPrivateKey(name, secKey);\n+        pubKey = null;\n+        bout.reset();\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte b) throws SignatureException {\n+        bout.write(b);\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte[] b, int off, int len) throws SignatureException {\n+        bout.write(b, off, len);\n+    }\n+\n+    @Override\n+    protected byte[] engineSign() throws SignatureException {\n+        if (secKey != null) {\n+            var msg = bout.toByteArray();\n+            bout.reset();\n+            return implSign(name, secKey, sk2, msg, appRandom);\n+        } else {\n+            throw new IllegalStateException(\"No private key\");\n+        }\n+    }\n+\n+    @Override\n+    protected boolean engineVerify(byte[] sig) throws SignatureException {\n+        if (pubKey != null) {\n+            var msg = bout.toByteArray();\n+            bout.reset();\n+            return implVerify(name, pubKey, pk2, msg, sig);\n+        } else {\n+            throw new IllegalStateException(\"No public key\");\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected void engineSetParameter(String param, Object value)\n+            throws InvalidParameterException {\n+        throw new UnsupportedOperationException(\"setParameter() not supported\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected Object engineGetParameter(String param) throws InvalidParameterException {\n+        throw new UnsupportedOperationException(\"getParameter() not supported\");\n+    }\n+\n+    @Override\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidAlgorithmParameterException(\"No params needed\");\n+        }\n+    }\n+\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined sign function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @param sk2 parsed private key, `null` if none.\n+    \/\/\/ @param msg the message\n+    \/\/\/ @param sr SecureRandom object, `null` if not initialized\n+    \/\/\/ @return the signature\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws SignatureException if there is another error\n+    public abstract byte[] implSign(String name, byte[] sk, Object sk2,\n+            byte[] msg, SecureRandom sr) throws SignatureException;\n+\n+    \/\/\/ User-defined verify function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @param pk2 parsed public key, `null` if none.\n+    \/\/\/ @param msg the message\n+    \/\/\/ @param sig the signature\n+    \/\/\/ @return true if verified\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws SignatureException if there is another error\n+    public abstract boolean implVerify(String name, byte[] pk, Object pk2,\n+            byte[] msg, byte[] sig) throws SignatureException;\n+\n+    \/\/\/ User-defined function to validate a public key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `initVerify`. This gives provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optional return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implVerify] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    public Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined function to validate a private key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `initSign`. This gives provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optional return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implSign] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    public Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedSignature.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -192,0 +192,13 @@\n+\n+        add(p, \"Signature\", \"ML-DSA\", \"sun.security.provider.ML_DSA_Provider$SIG\", attrs);\n+        addWithAlias(p, \"Signature\", \"ML-DSA-44\", \"sun.security.provider.ML_DSA_Provider$SIG2\", attrs);\n+        addWithAlias(p, \"Signature\", \"ML-DSA-65\", \"sun.security.provider.ML_DSA_Provider$SIG3\", attrs);\n+        addWithAlias(p, \"Signature\", \"ML-DSA-87\", \"sun.security.provider.ML_DSA_Provider$SIG5\", attrs);\n+        add(p, \"KeyPairGenerator\", \"ML-DSA\", \"sun.security.provider.ML_DSA_Provider$KPG\", attrs);\n+        addWithAlias(p, \"KeyPairGenerator\", \"ML-DSA-44\", \"sun.security.provider.ML_DSA_Provider$KPG2\", attrs);\n+        addWithAlias(p, \"KeyPairGenerator\", \"ML-DSA-65\", \"sun.security.provider.ML_DSA_Provider$KPG3\", attrs);\n+        addWithAlias(p, \"KeyPairGenerator\", \"ML-DSA-87\", \"sun.security.provider.ML_DSA_Provider$KPG5\", attrs);\n+        add(p, \"KeyFactory\", \"ML-DSA\", \"sun.security.provider.ML_DSA_Provider$KF\", attrs);\n+        addWithAlias(p, \"KeyFactory\", \"ML-DSA-44\", \"sun.security.provider.ML_DSA_Provider$KF2\", attrs);\n+        addWithAlias(p, \"KeyFactory\", \"ML-DSA-65\", \"sun.security.provider.ML_DSA_Provider$KF3\", attrs);\n+        addWithAlias(p, \"KeyFactory\", \"ML-DSA-87\", \"sun.security.provider.ML_DSA_Provider$KF5\", attrs);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -322,0 +322,5 @@\n+    \/\/PQC\n+    ML_DSA_44(\"1.3.6.1.4.1.2.267.12.4.4\", \"ML-DSA-44\"),\n+    ML_DSA_65(\"1.3.6.1.4.1.2.267.12.6.5\", \"ML-DSA-65\"),\n+    ML_DSA_87(\"1.3.6.1.4.1.2.267.12.8.7\", \"ML-DSA-87\"),\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -393,2 +393,2 @@\n-            if (key instanceof EdECKey) {\n-                return AlgorithmId.get(((EdECKey) key).getParams().getName());\n+            if (key.getParams() instanceof NamedParameterSpec nps) {\n+                return AlgorithmId.get(nps.getName());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.x509;\n+\n+import sun.security.util.BitArray;\n+\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.Serial;\n+import java.security.InvalidKeyException;\n+import java.security.KeyRep;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.NamedParameterSpec;\n+\n+public final class NamedX509Key extends X509Key {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    private final String fname;\n+    private final transient NamedParameterSpec paramSpec;\n+    private final byte[] h;\n+\n+    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n+    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n+    public NamedX509Key(String fname, String pname, byte[] h) {\n+        this.fname = fname;\n+        this.paramSpec = new NamedParameterSpec(pname);\n+        try {\n+            this.algid = AlgorithmId.get(pname);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ProviderException(e);\n+        }\n+        this.h = h;\n+\n+        setKey(new BitArray(h.length * 8, h));\n+    }\n+\n+    \/\/\/ Ctor from family name, and X.509 bytes\n+    public NamedX509Key(String fname, byte[] encoded) throws InvalidKeyException {\n+        this.fname = fname;\n+        decode(encoded);\n+        paramSpec = new NamedParameterSpec(algid.getName());\n+        if (algid.encodedParams != null) {\n+            throw new InvalidKeyException(\"algorithm identifier has params\");\n+        }\n+        h = getKey().toByteArray();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Do not modify: this can be used by earlier JDKs that\n+        \/\/ do not have the getParams() method\n+        return paramSpec.getName() + \" public key\";\n+    }\n+\n+    \/\/\/ Returns the reference to the internal key. Caller must not modify\n+    \/\/\/ the content or keep a reference.\n+    public byte[] getRawBytes() {\n+        return h;\n+    }\n+\n+    @Override\n+    public NamedParameterSpec getParams() {\n+        return paramSpec;\n+    }\n+\n+    @Override\n+    public String getAlgorithm() {\n+        return fname;\n+    }\n+\n+    @java.io.Serial\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n+        return new KeyRep(KeyRep.Type.PUBLIC, getAlgorithm(), getFormat(),\n+                getEncoded());\n+    }\n+\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"NamedX509Key keys are not directly deserializable\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/NamedX509Key.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327\n+ * @modules java.base\/sun.security.ec.ed\n+ *          java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.jca\n+ *          java.base\/sun.security.provider\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.ec.ed.EdDSAOperations;\n+import sun.security.ec.ed.EdDSAParameters;\n+import sun.security.ec.point.AffinePoint;\n+import sun.security.jca.JCAUtil;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.provider.NamedSignature;\n+\n+import java.security.*;\n+import java.security.spec.EdDSAParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class NamedEdDSA {\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"Named\", \"0\", \"\");\n+            put(\"KeyPairGenerator.EdDSA\", EdDSAKeyPairGenerator.class.getName());\n+            put(\"KeyPairGenerator.Ed25519\", EdDSAKeyPairGenerator.Ed25519.class.getName());\n+            put(\"KeyPairGenerator.Ed448\", EdDSAKeyPairGenerator.Ed448.class.getName());\n+            put(\"KeyFactory.EdDSA\", EdDSAKeyFactory.class.getName());\n+            put(\"KeyFactory.Ed25519\", EdDSAKeyFactory.Ed25519.class.getName());\n+            put(\"KeyFactory.Ed448\", EdDSAKeyFactory.Ed448.class.getName());\n+            put(\"Signature.EdDSA\", EdDSASignature.class.getName());\n+            put(\"Signature.Ed25519\", EdDSASignature.Ed25519.class.getName());\n+            put(\"Signature.Ed448\", EdDSASignature.Ed448.class.getName());\n+        }\n+    }\n+\n+    public static class EdDSASignature extends NamedSignature {\n+        public EdDSASignature() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSASignature(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSASignature {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSASignature {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[] implSign(String name, byte[] sk, Object sk2, byte[] msg, SecureRandom sr) throws SignatureException {\n+            return getOps(name).sign(plain, sk, msg);\n+        }\n+\n+        @Override\n+        public boolean implVerify(String name, byte[] pk, Object pk2, byte[] msg, byte[] sig) throws SignatureException {\n+            return getOps(name).verify(plain, (AffinePoint) pk2, pk, msg, sig);\n+        }\n+\n+        @Override\n+        public Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+            return getOps(name).decodeAffinePoint(InvalidKeyException::new, pk);\n+        }\n+    }\n+\n+    public static class EdDSAKeyFactory extends NamedKeyFactory {\n+        public EdDSAKeyFactory() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyFactory(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyFactory {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyFactory {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+    }\n+\n+    public static class EdDSAKeyPairGenerator extends NamedKeyPairGenerator {\n+        public EdDSAKeyPairGenerator() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyPairGenerator(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyPairGenerator {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyPairGenerator {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String pname, SecureRandom sr) {\n+            sr = sr == null ? JCAUtil.getDefSecureRandom() : sr;\n+            var op = getOps(pname);\n+            var sk = op.generatePrivate(sr);\n+            var point = op.computePublic(sk);\n+            byte[] encodedPoint = point.getY().toByteArray();\n+            reverse(encodedPoint);\n+            \/\/ array may be too large or too small, depending on the value\n+            encodedPoint = Arrays.copyOf(encodedPoint, op.getParameters().getKeyLength());\n+            \/\/ set the high-order bit of the encoded point\n+            byte msb = (byte) (point.isXOdd() ? 0x80 : 0);\n+            encodedPoint[encodedPoint.length - 1] |= msb;\n+            return new byte[][] { encodedPoint, sk };\n+        }\n+\n+        private static void swap(byte[] arr, int i, int j) {\n+            byte tmp = arr[i];\n+            arr[i] = arr[j];\n+            arr[j] = tmp;\n+        }\n+\n+        private static void reverse(byte [] arr) {\n+            int i = 0;\n+            int j = arr.length - 1;\n+\n+            while (i < j) {\n+                swap(arr, i, j);\n+                i++;\n+                j--;\n+            }\n+        }\n+    }\n+\n+    private static EdDSAOperations getOps(String pname) {\n+        var op = switch (pname) {\n+            case \"Ed25519\" -> e2;\n+            case \"Ed448\" -> e4;\n+            default -> throw new AssertionError(\"unknown pname \" + pname);\n+        };\n+        return op;\n+    }\n+\n+    static final EdDSAParameterSpec plain = new EdDSAParameterSpec(false);\n+    static final EdDSAOperations e2, e4;\n+    static {\n+        try {\n+            e2 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 255));\n+            e4 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 448));\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var ps = List.of(new ProviderImpl(), Security.getProvider(\"SunEC\"));\n+        for (var p1 : ps) {\n+            for (var p2 : ps) {\n+                for (var p3 : ps) {\n+                    test(p1, p2, p3);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void test(Provider p1, Provider p2, Provider p3) throws Exception {\n+        System.out.println(p1.getName() + \" \" + p2.getName() + \" \" + p3.getName());\n+        var g = KeyPairGenerator.getInstance(\"EdDSA\", p1);\n+        g.initialize(NamedParameterSpec.ED448);\n+        var kp = g.generateKeyPair();\n+        var s1 = Signature.getInstance(\"EdDSA\", p2);\n+        var s2 = Signature.getInstance(\"EdDSA\", p3);\n+        var f1 = KeyFactory.getInstance(\"EdDSA\", p2);\n+        var f2 = KeyFactory.getInstance(\"EdDSA\", p3);\n+        var sk = (PrivateKey) f1.translateKey(kp.getPrivate());\n+        var pk = (PublicKey) f2.translateKey(kp.getPublic());\n+        \/\/ sign and verify twice to make sure the key is intact\n+        s1.initSign(sk);\n+        var sig1 = s1.sign();\n+        s1.initSign(sk);\n+        var sig2 = s1.sign();\n+        \/\/ EdDSA signing is deterministic\n+        Asserts.assertEqualsByteArray(sig1, sig2);\n+        s2.initVerify(pk);\n+        Asserts.assertTrue(s2.verify(sig1));\n+        s2.initVerify(pk);\n+        Asserts.assertTrue(s2.verify(sig2));\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedEdDSA.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.util.RawKeySpec;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.*;\n+import java.security.spec.*;\n+\n+public class NamedKeyFactoryTest {\n+\n+    private static final SeededSecureRandom RAND = SeededSecureRandom.one();\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new ProviderImpl());\n+\n+        var g = KeyPairGenerator.getInstance(\"sHA\");\n+        var g2 = KeyPairGenerator.getInstance(\"ShA-256\");\n+        var g5 = KeyPairGenerator.getInstance(\"SHa-512\");\n+        var kf = KeyFactory.getInstance(\"ShA\");\n+        var kf2 = KeyFactory.getInstance(\"Sha-256\");\n+        var kf5 = KeyFactory.getInstance(\"Sha-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        Utils.runAndCheckException(() -> g.initialize(NamedParameterSpec.ED448),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+        Utils.runAndCheckException(() -> g.initialize(new NamedParameterSpec(\"SHA-384\")),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+\n+        Utils.runAndCheckException(() -> g5.initialize(new NamedParameterSpec(\"SHA-256\")),\n+                InvalidAlgorithmParameterException.class); \/\/ diff pname\n+        g5.initialize(new NamedParameterSpec(\"SHA-512\"));\n+\n+        g.initialize(new NamedParameterSpec(\"sHA-512\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-512\");\n+        g.initialize(new NamedParameterSpec(\"ShA-256\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+\n+        var pk = new NamedX509Key(\"sHa\", \"ShA-256\", RAND.nBytes(2));\n+        var sk = new NamedPKCS8Key(\"sHa\", \"SHa-256\", RAND.nBytes(2));\n+        checkKey(pk, \"sHa\", \"ShA-256\");\n+        checkKey(sk, \"sHa\", \"SHa-256\");\n+\n+        Asserts.assertEquals(\"X.509\", pk.getFormat());\n+        Asserts.assertEquals(\"PKCS#8\", sk.getFormat());\n+\n+        var pkSpec = kf.getKeySpec(pk, X509EncodedKeySpec.class);\n+        var skSpec = kf.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+\n+        kf2.getKeySpec(pk, X509EncodedKeySpec.class);\n+        kf2.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(pk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(sk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+        Utils.runAndCheckException(() -> kf.getKeySpec(pk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KeySpec\n+        Utils.runAndCheckException(() -> kf.getKeySpec(sk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePrivate(pkSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf2.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        checkKey(kf2.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf5.generatePublic(pkSpec),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        \/\/ The private RawKeySpec and unnamed RAW EncodedKeySpec\n+        var prk = kf.getKeySpec(pk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), pk.getRawBytes());\n+        var prk2 = kf.getKeySpec(pk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", prk2.getFormat());\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), prk2.getEncoded());\n+\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk), InvalidKeySpecException.class); \/\/ no pname\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk2).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var srk = kf.getKeySpec(sk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(srk.getKeyArr(), sk.getRawBytes());\n+        var srk2 = kf.getKeySpec(sk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", srk2.getFormat());\n+        Asserts.assertEqualsByteArray(srk2.getEncoded(), sk.getRawBytes());\n+\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk), InvalidKeySpecException.class); \/\/ no pname\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk2).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var pk1 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var pk2 = new PublicKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var pk3 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(pk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(pk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk3), InvalidKeyException.class);\n+\n+        var sk1 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var sk2 = new PrivateKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+        };\n+        var sk3 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAND.nBytes(2); }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(sk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(sk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk3), InvalidKeyException.class);\n+    }\n+\n+    static void checkKeyPair(KeyPair kp, String algName, String toString) {\n+        checkKey(kp.getPrivate(), algName, toString);\n+        checkKey(kp.getPublic(), algName, toString);\n+    }\n+\n+    static void checkKey(Key k, String algName, String pname) {\n+        Asserts.assertEquals(algName, k.getAlgorithm());\n+        Asserts.assertTrue(k.toString().contains(pname));\n+        if (k instanceof AsymmetricKey ak && ak.getParams() instanceof NamedParameterSpec nps) {\n+            Asserts.assertEquals(pname, nps.getName());\n+        }\n+    }\n+\n+    \/\/ Provider\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"P\", \"1\", \"...\");\n+            put(\"KeyFactory.SHA\", KF.class.getName());\n+            put(\"KeyFactory.SHA-256\", KF1.class.getName());\n+            put(\"KeyFactory.SHA-512\", KF2.class.getName());\n+            put(\"KeyPairGenerator.SHA\", KPG.class.getName());\n+            put(\"KeyPairGenerator.SHA-256\", KPG1.class.getName());\n+            put(\"KeyPairGenerator.SHA-512\", KPG2.class.getName());\n+        }\n+    }\n+    public static class KF extends NamedKeyFactory {\n+        public KF() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+    }\n+    public static class KF1 extends NamedKeyFactory {\n+        public KF1() {\n+            super(\"SHA\", \"SHA-256\");\n+        }\n+    }\n+    public static class KF2 extends NamedKeyFactory {\n+        public KF2() {\n+            super(\"SHA\", \"SHA-512\");\n+        }\n+    }\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+\n+        public KPG(String pname) {\n+            super(\"SHA\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n+            var out = new byte[2][];\n+            out[0] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n+            out[1] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n+            return out;\n+        }\n+    }\n+    public static class KPG1 extends KPG {\n+        public KPG1() {\n+            super(\"SHA-256\");\n+        }\n+    }\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"SHA-512\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedKeyFactoryTest.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"}]}