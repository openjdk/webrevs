{"files":[{"patch":"@@ -64,1 +64,2 @@\n-    private static final int MONT_DIM_INVERSE = 16382; \/\/ toMont((ML_DSA_N)^-1 (mod ML_DSA_Q))\n+    \/\/ toMont((ML_DSA_N)^-1 (mod ML_DSA_Q))\n+    private static final int MONT_DIM_INVERSE = 16382;\n@@ -233,1 +234,2 @@\n-    public record ML_DSA_PrivateKey(byte[] rho, byte[] k, byte[] tr, int[][] s1, int[][] s2, int[][] t0) {\n+    public record ML_DSA_PrivateKey(byte[] rho, byte[] k, byte[] tr,\n+                                    int[][] s1, int[][] s2, int[][] t0) {\n@@ -251,1 +253,2 @@\n-    public record ML_DSA_KeyPair(ML_DSA_PrivateKey privateKey, ML_DSA_PublicKey publicKey) {\n+    public record ML_DSA_KeyPair(ML_DSA_PrivateKey privateKey,\n+                                 ML_DSA_PublicKey publicKey) {\n@@ -254,1 +257,2 @@\n-    public record ML_DSA_Signature(byte[] commitmentHash, int[][] response, boolean[][] hint) {\n+    public record ML_DSA_Signature(byte[] commitmentHash,\n+                                   int[][] response, boolean[][] hint) {\n@@ -300,1 +304,2 @@\n-        sampleS1S2(s1, s2, hash, rhoPrime); \/\/hash is reset before being used in sampleS1S2\n+        \/\/hash is reset before being used in sampleS1S2\n+        sampleS1S2(s1, s2, hash, rhoPrime);\n@@ -399,1 +404,2 @@\n-            if (vectorNormBound(z, gamma1 - beta) || vectorNormBound(w0, gamma2 - beta)) {\n+            if (vectorNormBound(z, gamma1 - beta) ||\n+                vectorNormBound(w0, gamma2 - beta)) {\n@@ -476,1 +482,2 @@\n-    \/\/ The coefficients of the polynomials in the vector should be nonnegative and less than 2^bitsPerCoeff .\n+    \/\/ The coefficients of the polynomials in the vector should be\n+    \/\/ nonnegative and less than 2^bitsPerCoeff .\n@@ -522,4 +529,8 @@\n-                t1[i][tOffset] = (v[vOffset] & 0xFF) + ((v[vOffset+1] << 8) & 0x3FF);\n-                t1[i][tOffset+1] = ((v[vOffset+1] >> 2) & 0x3F) + ((v[vOffset+2] << 6) & 0x3FF);\n-                t1[i][tOffset+2] = ((v[vOffset+2] >> 4) & 0xF) + ((v[vOffset+3] << 4) & 0x3FF);\n-                t1[i][tOffset+3] = ((v[vOffset+3] >> 6) & 0x3) + ((v[vOffset+4] << 2) & 0x3FF);\n+                t1[i][tOffset] = (v[vOffset] & 0xFF) +\n+                    ((v[vOffset+1] << 8) & 0x3FF);\n+                t1[i][tOffset+1] = ((v[vOffset+1] >> 2) & 0x3F) +\n+                    ((v[vOffset+2] << 6) & 0x3FF);\n+                t1[i][tOffset+2] = ((v[vOffset+2] >> 4) & 0xF) +\n+                    ((v[vOffset+3] << 4) & 0x3FF);\n+                t1[i][tOffset+3] = ((v[vOffset+3] >> 6) & 0x3) +\n+                    ((v[vOffset+4] << 2) & 0x3FF);\n@@ -531,1 +542,3 @@\n-    public int[][] bitUnpack(int[][] result, byte[] v, int offset, int dim, int maxValue, int bitsPerCoeff) {\n+    public int[][] bitUnpack(int[][] result, byte[] v, int offset, int dim,\n+                             int maxValue, int bitsPerCoeff) {\n+\n@@ -538,1 +551,2 @@\n-            default -> throw new RuntimeException(\"Wrong bitspercoeffb value in bitUnpack (\" + bitsPerCoeff + \").\");\n+            default -> throw new RuntimeException(\n+                \"Wrong bitsPerCoeff value in bitUnpack (\" + bitsPerCoeff + \").\");\n@@ -565,1 +579,2 @@\n-    public void bitUnpack18(int [][] result, byte[] v, int offset, int dim, int maxValue) {\n+    public void bitUnpack18(int [][] result, byte[] v, int offset,\n+                            int dim, int maxValue) {\n@@ -587,1 +602,2 @@\n-    public void bitUnpack20(int[][] result, byte[] v, int offset, int dim, int maxValue) {\n+    public void bitUnpack20(int[][] result, byte[] v, int offset,\n+                            int dim, int maxValue) {\n@@ -856,1 +872,2 @@\n-                    if (rawOfs == blockSize) {  \/\/ works because 3 divides blockSize (=168)\n+                    if (rawOfs == blockSize) {\n+                        \/\/ works because 3 divides blockSize (=168)\n@@ -891,1 +908,2 @@\n-                    s1[i][j] = eta - sample + (205 * sample >> 10) * 5; \/\/ 2 - sample mod 5\n+                    \/\/ 2 - sample mod 5\n+                    s1[i][j] = eta - sample + (205 * sample >> 10) * 5;\n@@ -965,1 +983,2 @@\n-            ML_DSA.mlDsaDecomposePoly(input[i], lowPart[i], highPart[i], gamma2 * 2, multiplier);\n+            ML_DSA.mlDsaDecomposePoly(input[i], lowPart[i],\n+                highPart[i], gamma2 * 2, multiplier);\n@@ -1050,1 +1069,2 @@\n-                    coeffs[j + l] = montMul(tmp - coeffs[j + l], MONT_ZETAS_FOR_INVERSE_NTT[m]);\n+                    coeffs[j + l] = montMul(tmp - coeffs[j + l],\n+                        MONT_ZETAS_FOR_INVERSE_NTT[m]);\n@@ -1119,1 +1139,3 @@\n-    private void matrixVectorPointwiseMultiply(int[][] res, int[][][] matrix, int[][] vector) {\n+    private void matrixVectorPointwiseMultiply(int[][] res, int[][][] matrix,\n+                                               int[][] vector) {\n+\n@@ -1223,1 +1245,2 @@\n-        return (aHigh - (int) (((long)m * MONT_Q) >> MONT_R_BITS));  \/\/ subtract signed high product\n+        \/\/ subtract signed high product\n+        return (aHigh - (int) (((long)m * MONT_Q) >> MONT_R_BITS));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":44,"deletions":21,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -59,1 +59,3 @@\n-    public sealed static class KPG extends NamedKeyPairGenerator permits KPG2, KPG3, KPG5 {\n+    public sealed static class KPG extends\n+        NamedKeyPairGenerator permits KPG2, KPG3, KPG5 {\n+\n@@ -142,1 +144,2 @@\n-        protected byte[] implSign(String name, byte[] skBytes, Object sk2, byte[] msg, SecureRandom sr) {\n+        protected byte[] implSign(String name, byte[] skBytes,\n+                                  Object sk2, byte[] msg, SecureRandom sr) {\n@@ -160,1 +163,2 @@\n-        protected boolean implVerify(String name, byte[] pkBytes, Object pk2, byte[] msg, byte[] sigBytes)\n+        protected boolean implVerify(String name, byte[] pkBytes,\n+                                     Object pk2, byte[] msg, byte[] sigBytes)\n@@ -175,1 +179,3 @@\n-        protected Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+        protected Object implCheckPublicKey(String name, byte[] pk)\n+            throws InvalidKeyException {\n+\n@@ -181,1 +187,3 @@\n-        protected Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+        protected Object implCheckPrivateKey(String name, byte[] sk)\n+            throws InvalidKeyException {\n+            \n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Impls.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"}]}