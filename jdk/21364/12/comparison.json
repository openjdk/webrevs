{"files":[{"patch":"@@ -71,0 +71,24 @@\n+    \/**\n+     * The ML-DSA-44 parameters\n+     *\n+     * @since 24\n+     *\/\n+    public static final NamedParameterSpec ML_DSA_44\n+        = new NamedParameterSpec(\"ML-DSA-44\");\n+\n+    \/**\n+     * The ML-DSA-65 parameters\n+     *\n+     * @since 24\n+     *\/\n+    public static final NamedParameterSpec ML_DSA_65\n+        = new NamedParameterSpec(\"ML-DSA-65\");\n+\n+    \/**\n+     * The ML-DSA-87 parameters\n+     *\n+     * @since 24\n+     *\/\n+    public static final NamedParameterSpec ML_DSA_87\n+        = new NamedParameterSpec(\"ML-DSA-87\");\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/spec\/NamedParameterSpec.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,1450 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+import sun.security.provider.SHA3.SHAKE128;\n+import sun.security.provider.SHA3.SHAKE256;\n+\n+import java.security.MessageDigest;\n+import java.util.Arrays;\n+\n+public class ML_DSA {\n+    \/\/ Constants from FIPS 204 that do not depend on security level\n+    private static final int ML_DSA_D = 13;\n+    private static final int ML_DSA_Q = 8380417;\n+    private static final int ML_DSA_N = 256;\n+    private static final int SHAKE256_BLOCK_SIZE = 136; \/\/ the block length for SHAKE256\n+\n+    private final int A_SEED_LEN = 32;\n+    private final int S1S2_SEED_LEN = 64;\n+    private final int K_LEN = 32;\n+    private final int TR_LEN = 64;\n+    private final int MU_LEN = 64;\n+    private final int MASK_SEED_LEN = 64;\n+    private static final int D_MASK = (1 << ML_DSA_D) - 1;\n+    private final int T0_COEFF_SIZE = 13;\n+    \n+    private static final int MONT_R_BITS = 32;\n+    private static final long MONT_R = 4294967296L; \/\/ 1 << MONT_R_BITS\n+    private static final int MONT_Q = 8380417;\n+    private static final int MONT_R_SQUARE_MOD_Q = 2365951;\n+    private static final int MONT_Q_INV_MOD_R = 58728449;\n+    private static final int MONT_R_MOD_Q = 4193792;\n+    private static final int MONT_DIM_INVERSE = 16382; \/\/ toMont((ML_DSA_N)^-1 (mod ML_DSA_Q))\n+\n+    \/\/ Zeta values for NTT with montgomery factor precomputed\n+    private static final int[] MONT_ZETAS_FOR_NTT = new int[]{\n+        25847, -2608894, -518909, 237124, -777960, -876248, 466468, 1826347,\n+        2353451, -359251, -2091905, 3119733, -2884855, 3111497, 2680103, 2725464,\n+        1024112, -1079900, 3585928, -549488, -1119584, 2619752, -2108549, -2118186,\n+        -3859737, -1399561, -3277672, 1757237, -19422, 4010497, 280005, 2706023,\n+        95776, 3077325, 3530437, -1661693, -3592148, -2537516, 3915439, -3861115,\n+        -3043716, 3574422, -2867647, 3539968, -300467, 2348700, -539299, -1699267,\n+        -1643818, 3505694, -3821735, 3507263, -2140649, -1600420, 3699596, 811944,\n+        531354, 954230, 3881043, 3900724, -2556880, 2071892, -2797779, -3930395,\n+        -1528703, -3677745, -3041255, -1452451, 3475950, 2176455, -1585221, -1257611,\n+        1939314, -4083598, -1000202, -3190144, -3157330, -3632928, 126922, 3412210,\n+        -983419, 2147896, 2715295, -2967645, -3693493, -411027, -2477047, -671102,\n+        -1228525, -22981, -1308169, -381987, 1349076, 1852771, -1430430, -3343383,\n+        264944, 508951, 3097992, 44288, -1100098, 904516, 3958618, -3724342,\n+        -8578, 1653064, -3249728, 2389356, -210977, 759969, -1316856, 189548,\n+        -3553272, 3159746, -1851402, -2409325, -177440, 1315589, 1341330, 1285669,\n+        -1584928, -812732, -1439742, -3019102, -3881060, -3628969, 3839961, 2091667,\n+        3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462, 266997,\n+        2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378, 900702,\n+        1859098, 909542, 819034, 495491, -1613174, -43260, -522500, -655327,\n+        -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838, 342297,\n+        286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044, 2842341,\n+        2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974, -3767016,\n+        1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970, -1333058,\n+        1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642, -1279661,\n+        1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031, -542412,\n+        -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993, -2013608,\n+        2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385, -3183426,\n+        162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107, -3038916,\n+        3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078, -426683,\n+        1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893, -2939036,\n+        -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687, -554416,\n+        3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782\n+    };\n+    private static final int[] MONT_ZETAS_FOR_INVERSE_NTT = new int[]{\n+        -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,\n+        3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,\n+        3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,\n+        -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,\n+        1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,\n+        1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,\n+        3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,\n+        -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,\n+        1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,\n+        1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,\n+        -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,\n+        -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,\n+        3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,\n+        522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,\n+        3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,\n+        3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,\n+        -3839961, 3628969, 3881060, 3019102, 1439742, 812732, 1584928, -1285669,\n+        -1341330, -1315589, 177440, 2409325, 1851402, -3159746, 3553272, -189548,\n+        1316856, -759969, 210977, -2389356, 3249728, -1653064, 8578, 3724342,\n+        -3958618, -904516, 1100098, -44288, -3097992, -508951, -264944, 3343383,\n+        1430430, -1852771, -1349076, 381987, 1308169, 22981, 1228525, 671102,\n+        2477047, 411027, 3693493, 2967645, -2715295, -2147896, 983419, -3412210,\n+        -126922, 3632928, 3157330, 3190144, 1000202, 4083598, -1939314, 1257611,\n+        1585221, -2176455, -3475950, 1452451, 3041255, 3677745, 1528703, 3930395,\n+        2797779, -2071892, 2556880, -3900724, -3881043, -954230, -531354, -811944,\n+        -3699596, 1600420, 2140649, -3507263, 3821735, -3505694, 1643818, 1699267,\n+        539299, -2348700, 300467, -3539968, 2867647, -3574422, 3043716, 3861115,\n+        -3915439, 2537516, 3592148, 1661693, -3530437, -3077325, -95776, -2706023,\n+        -280005, -4010497, 19422, -1757237, 3277672, 1399561, 3859737, 2118186,\n+        2108549, -2619752, 1119584, 549488, -3585928, 1079900, -1024112, -2725464,\n+        -2680103, -3111497, 2884855, -3119733, 2091905, 359251, -2353451, -1826347,\n+        -466468, 876248, 777960, -237124, 518909, 2608894, -25847\n+    };\n+\n+    private static final int[] MONT_ZETAS_FOR_VECTOR_NTT = new int[]{\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+        25847, 25847, 25847, 25847, 25847, 25847, 25847, 25847,\n+\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894, -2608894,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+        -518909, -518909, -518909, -518909, -518909, -518909, -518909, -518909,\n+\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        237124, 237124, 237124, 237124, 237124, 237124, 237124, 237124,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -777960, -777960, -777960, -777960, -777960, -777960, -777960, -777960,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        -876248, -876248, -876248, -876248, -876248, -876248, -876248, -876248,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+        466468, 466468, 466468, 466468, 466468, 466468, 466468, 466468,\n+\n+        1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,\n+        1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347, 1826347,\n+        2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,\n+        2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451, 2353451,\n+        -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,\n+        -359251, -359251, -359251, -359251, -359251, -359251, -359251, -359251,\n+        -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,\n+        -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905, -2091905,\n+        3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,\n+        3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733, 3119733,\n+        -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,\n+        -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855, -2884855,\n+        3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,\n+        3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497, 3111497,\n+        2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,\n+        2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103, 2680103,\n+\n+        2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464, 2725464,\n+        1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112, 1024112,\n+        -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900, -1079900,\n+        3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928, 3585928,\n+        -549488, -549488, -549488, -549488, -549488, -549488, -549488, -549488,\n+        -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584, -1119584,\n+        2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752, 2619752,\n+        -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549, -2108549,\n+        -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186, -2118186,\n+        -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737, -3859737,\n+        -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561, -1399561,\n+        -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672, -3277672,\n+        1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237, 1757237,\n+        -19422, -19422, -19422, -19422, -19422, -19422, -19422, -19422,\n+        4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497, 4010497,\n+        280005, 280005, 280005, 280005, 280005, 280005, 280005, 280005,\n+\n+        2706023, 2706023, 2706023, 2706023, 95776, 95776, 95776, 95776,\n+        3077325, 3077325, 3077325, 3077325, 3530437, 3530437, 3530437, 3530437,\n+        -1661693, -1661693, -1661693, -1661693, -3592148, -3592148, -3592148, -3592148,\n+        -2537516, -2537516, -2537516, -2537516, 3915439, 3915439, 3915439, 3915439,\n+        -3861115, -3861115, -3861115, -3861115, -3043716, -3043716, -3043716, -3043716,\n+        3574422, 3574422, 3574422, 3574422, -2867647, -2867647, -2867647, -2867647,\n+        3539968, 3539968, 3539968, 3539968, -300467, -300467, -300467, -300467,\n+        2348700, 2348700, 2348700, 2348700, -539299, -539299, -539299, -539299,\n+        -1699267, -1699267, -1699267, -1699267, -1643818, -1643818, -1643818, -1643818,\n+        3505694, 3505694, 3505694, 3505694, -3821735, -3821735, -3821735, -3821735,\n+        3507263, 3507263, 3507263, 3507263, -2140649, -2140649, -2140649, -2140649,\n+        -1600420, -1600420, -1600420, -1600420, 3699596, 3699596, 3699596, 3699596,\n+        811944, 811944, 811944, 811944, 531354, 531354, 531354, 531354,\n+        954230, 954230, 954230, 954230, 3881043, 3881043, 3881043, 3881043,\n+        3900724, 3900724, 3900724, 3900724, -2556880, -2556880, -2556880, -2556880,\n+        2071892, 2071892, 2071892, 2071892, -2797779, -2797779, -2797779, -2797779,\n+\n+        -3930395, -3930395, -1528703, -1528703, -3677745, -3677745, -3041255, -3041255,\n+        -1452451, -1452451, 3475950, 3475950, 2176455, 2176455, -1585221, -1585221,\n+        -1257611, -1257611, 1939314, 1939314, -4083598, -4083598, -1000202, -1000202,\n+        -3190144, -3190144, -3157330, -3157330, -3632928, -3632928, 126922, 126922,\n+        3412210, 3412210, -983419, -983419, 2147896, 2147896, 2715295, 2715295,\n+        -2967645, -2967645, -3693493, -3693493, -411027, -411027, -2477047, -2477047,\n+        -671102, -671102, -1228525, -1228525, -22981, -22981, -1308169, -1308169,\n+        -381987, -381987, 1349076, 1349076, 1852771, 1852771, -1430430, -1430430,\n+        -3343383, -3343383, 264944, 264944, 508951, 508951, 3097992, 3097992,\n+        44288, 44288, -1100098, -1100098, 904516, 904516, 3958618, 3958618,\n+        -3724342, -3724342, -8578, -8578, 1653064, 1653064, -3249728, -3249728,\n+        2389356, 2389356, -210977, -210977, 759969, 759969, -1316856, -1316856,\n+        189548, 189548, -3553272, -3553272, 3159746, 3159746, -1851402, -1851402,\n+        -2409325, -2409325, -177440, -177440, 1315589, 1315589, 1341330, 1341330,\n+        1285669, 1285669, -1584928, -1584928, -812732, -812732, -1439742, -1439742,\n+        -3019102, -3019102, -3881060, -3881060, -3628969, -3628969, 3839961, 3839961,\n+\n+        2091667, 3407706, 2316500, 3817976, -3342478, 2244091, -2446433, -3562462,\n+        266997, 2434439, -1235728, 3513181, -3520352, -3759364, -1197226, -3193378,\n+        900702, 1859098, 909542, 819034, 495491, -1613174, -43260, -522500,\n+        -655327, -3122442, 2031748, 3207046, -3556995, -525098, -768622, -3595838,\n+        342297, 286988, -2437823, 4108315, 3437287, -3342277, 1735879, 203044,\n+        2842341, 2691481, -2590150, 1265009, 4055324, 1247620, 2486353, 1595974,\n+        -3767016, 1250494, 2635921, -3548272, -2994039, 1869119, 1903435, -1050970,\n+        -1333058, 1237275, -3318210, -1430225, -451100, 1312455, 3306115, -1962642,\n+        -1279661, 1917081, -2546312, -1374803, 1500165, 777191, 2235880, 3406031,\n+        -542412, -2831860, -1671176, -1846953, -2584293, -3724270, 594136, -3776993,\n+        -2013608, 2432395, 2454455, -164721, 1957272, 3369112, 185531, -1207385,\n+        -3183426, 162844, 1616392, 3014001, 810149, 1652634, -3694233, -1799107,\n+        -3038916, 3523897, 3866901, 269760, 2213111, -975884, 1717735, 472078,\n+        -426683, 1723600, -1803090, 1910376, -1667432, -1104333, -260646, -3833893,\n+        -2939036, -2235985, -420899, -2286327, 183443, -976891, 1612842, -3545687,\n+        -554416, 3919660, -48306, -1362209, 3937738, 1400424, -846154, 1976782\n+    };\n+\n+    private static final int[] MONT_ZETAS_FOR_VECTOR_INVERSE_NTT = new int[]{\n+        -1976782, 846154, -1400424, -3937738, 1362209, 48306, -3919660, 554416,\n+        3545687, -1612842, 976891, -183443, 2286327, 420899, 2235985, 2939036,\n+        3833893, 260646, 1104333, 1667432, -1910376, 1803090, -1723600, 426683,\n+        -472078, -1717735, 975884, -2213111, -269760, -3866901, -3523897, 3038916,\n+        1799107, 3694233, -1652634, -810149, -3014001, -1616392, -162844, 3183426,\n+        1207385, -185531, -3369112, -1957272, 164721, -2454455, -2432395, 2013608,\n+        3776993, -594136, 3724270, 2584293, 1846953, 1671176, 2831860, 542412,\n+        -3406031, -2235880, -777191, -1500165, 1374803, 2546312, -1917081, 1279661,\n+        1962642, -3306115, -1312455, 451100, 1430225, 3318210, -1237275, 1333058,\n+        1050970, -1903435, -1869119, 2994039, 3548272, -2635921, -1250494, 3767016,\n+        -1595974, -2486353, -1247620, -4055324, -1265009, 2590150, -2691481, -2842341,\n+        -203044, -1735879, 3342277, -3437287, -4108315, 2437823, -286988, -342297,\n+        3595838, 768622, 525098, 3556995, -3207046, -2031748, 3122442, 655327,\n+        522500, 43260, 1613174, -495491, -819034, -909542, -1859098, -900702,\n+        3193378, 1197226, 3759364, 3520352, -3513181, 1235728, -2434439, -266997,\n+        3562462, 2446433, -2244091, 3342478, -3817976, -2316500, -3407706, -2091667,\n+\n+        -3839961, -3839961, 3628969, 3628969, 3881060, 3881060, 3019102, 3019102,\n+        1439742, 1439742, 812732, 812732, 1584928, 1584928, -1285669, -1285669,\n+        -1341330, - 1341330, -1315589, -1315589, 177440, 177440, 2409325, 2409325,\n+        1851402, 1851402, -3159746, -3159746, 3553272, 3553272, -189548, -189548,\n+        1316856, 1316856, -759969, -759969, 210977, 210977, -2389356, -2389356,\n+        3249728, 3249728, -1653064, -1653064, 8578, 8578, 3724342, 3724342,\n+        -3958618, -3958618, -904516, -904516, 1100098, 1100098, -44288, -44288,\n+        -3097992, -3097992, -508951, -508951, -264944, -264944, 3343383, 3343383,\n+        1430430, 1430430, -1852771, -1852771, -1349076, -1349076, 381987, 381987,\n+        1308169, 1308169, 22981, 22981, 1228525, 1228525, 671102, 671102,\n+        2477047, 2477047, 411027, 411027, 3693493, 3693493, 2967645, 2967645,\n+        -2715295, -2715295, -2147896, -2147896, 983419, 983419, -3412210, -3412210,\n+        -126922, -126922, 3632928, 3632928, 3157330, 3157330, 3190144, 3190144,\n+        1000202, 1000202, 4083598, 4083598, -1939314, -1939314, 1257611, 1257611,\n+        1585221, 1585221, -2176455, -2176455, -3475950, -3475950, 1452451, 1452451,\n+        3041255, 3041255, 3677745, 3677745, 1528703, 1528703, 3930395, 3930395,\n+\n+        2797779, 2797779, 2797779, 2797779, -2071892, -2071892, -2071892, -2071892,\n+        2556880, 2556880, 2556880, 2556880, -3900724, -3900724, -3900724, -3900724,\n+        -3881043, -3881043, -3881043, -3881043, -954230, -954230, -954230, -954230,\n+        -531354, -531354, -531354, -531354, -811944, -811944, -811944, -811944,\n+        -3699596, -3699596, -3699596, -3699596, 1600420, 1600420, 1600420, 1600420,\n+        2140649, 2140649, 2140649, 2140649, -3507263, -3507263, -3507263, -3507263,\n+        3821735, 3821735, 3821735, 3821735, -3505694, -3505694, -3505694, -3505694,\n+        1643818, 1643818, 1643818, 1643818, 1699267, 1699267, 1699267, 1699267,\n+        539299, 539299, 539299, 539299, -2348700, -2348700, -2348700, -2348700,\n+        300467, 300467, 300467, 300467, -3539968, -3539968, -3539968, -3539968,\n+        2867647, 2867647, 2867647, 2867647, -3574422, -3574422, -3574422, -3574422,\n+        3043716, 3043716, 3043716, 3043716, 3861115, 3861115, 3861115, 3861115,\n+        -3915439, -3915439, -3915439, -3915439, 2537516, 2537516, 2537516, 2537516,\n+        3592148, 3592148, 3592148, 3592148, 1661693, 1661693, 1661693, 1661693,\n+        -3530437, -3530437, -3530437, -3530437, -3077325, -3077325, -3077325, -3077325,\n+        -95776, -95776, -95776, -95776, -2706023, -2706023, -2706023, -2706023,\n+\n+        -280005, -280005, -280005, -280005, -280005, -280005, -280005, -280005,\n+        -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497, -4010497,\n+        19422, 19422, 19422, 19422, 19422, 19422, 19422, 19422,\n+        -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237, -1757237,\n+        3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672, 3277672,\n+        1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561, 1399561,\n+        3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737, 3859737,\n+        2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186, 2118186,\n+        2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549, 2108549,\n+        -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752, -2619752,\n+        1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584, 1119584,\n+        549488, 549488, 549488, 549488, 549488, 549488, 549488, 549488,\n+        -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928, -3585928,\n+        1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900, 1079900,\n+        -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112, -1024112,\n+        -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464, -2725464,\n+\n+        -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,\n+        -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103, -2680103,\n+        -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,\n+        -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497, -3111497,\n+        2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,\n+        2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855, 2884855,\n+        -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,\n+        -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733, -3119733,\n+        2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,\n+        2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905, 2091905,\n+        359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,\n+        359251, 359251, 359251, 359251, 359251, 359251, 359251, 359251,\n+        -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,\n+        -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451, -2353451,\n+        -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,\n+        -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347, -1826347,\n+\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        -466468, -466468, -466468, -466468, -466468, -466468, -466468, -466468,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        876248, 876248, 876248, 876248, 876248, 876248, 876248, 876248,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        777960, 777960, 777960, 777960, 777960, 777960, 777960, 777960,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+        -237124, -237124, -237124, -237124, -237124, -237124, -237124, -237124,\n+\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        518909, 518909, 518909, 518909, 518909, 518909, 518909, 518909,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+        2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894, 2608894,\n+\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847,\n+        -25847, -25847, -25847, -25847, -25847, -25847, -25847, -25847\n+    };\n+\n+    \/\/ Constants defined for each security level\n+    private final int level;\n+    private final int tau;\n+    private final int lambda;\n+    private final int gamma1;\n+    private final int gamma2;\n+    private final int mlDsa_k;\n+    private final int mlDsa_l;\n+    private final int eta;\n+    private final int beta;\n+    private final int omega;\n+\n+    \/\/ Second-class constants derived from above values\n+    \/\/ log_2(gamma1)\n+    private final int gamma1Bits;\n+    \/\/ mlDsa_l * (eta + 1) * 256 \/ 8\n+    private final int s1PackedLength;\n+    \/\/ mlDsa_k * (eta + 1) * 256 \/ 8\n+    private final int s2PackedLength;\n+    \/\/ mlDsa_k * ML_DSA_D * 256 \/ 8\n+    private final int t0PackedLength;\n+    \/\/ log_2(eta) + 1\n+    private final int s1s2CoeffSize;\n+    \/\/ rho_size + t1_size\n+    private final int publicKeyLength;\n+    \/\/ c_tilde_size + z_size + h_size\n+    private final int signatureLength;\n+    \/\/ mlDsa_k * log_2((q-1)\/(2*gamma2) - 1) * 256 \/ 8\n+    private final int wCoeffSize;\n+\n+    public ML_DSA(int security_level) {\n+        switch (security_level) {\n+            case 2:\n+                level = 2;\n+                tau = 39;\n+                lambda = 128;\n+                gamma1 = 1 << 17;\n+                gamma1Bits = 17;\n+                gamma2 = (ML_DSA_Q - 1) \/ 88;\n+                mlDsa_k = 4;\n+                mlDsa_l = 4;\n+                eta = 2;\n+                beta = 78;\n+                omega = 80;\n+                publicKeyLength = 1312;\n+                signatureLength = 2420;\n+                s1PackedLength = 384;\n+                s2PackedLength = 384;\n+                t0PackedLength = 1664;\n+                s1s2CoeffSize = 3;\n+                wCoeffSize = 6;\n+                break;\n+            case 3:\n+                level = 3;\n+                tau = 49;\n+                lambda = 192;\n+                gamma1 = 1 << 19;\n+                gamma2 = (ML_DSA_Q - 1) \/ 32;\n+                mlDsa_k = 6;\n+                mlDsa_l = 5;\n+                eta = 4;\n+                beta = 196;\n+                omega = 55;\n+                publicKeyLength = 1952;\n+                signatureLength = 3293;\n+                s1PackedLength = 640;\n+                s2PackedLength = 768;\n+                t0PackedLength = 2496;\n+                s1s2CoeffSize = 4;\n+                wCoeffSize = 4;\n+                gamma1Bits = 19;\n+                break;\n+            case 5:\n+                level = 4;\n+                tau = 60;\n+                lambda = 256;\n+                gamma1 = 1 << 19;\n+                gamma1Bits = 19;\n+                gamma2 = (ML_DSA_Q - 1) \/ 32;\n+                mlDsa_k = 8;\n+                mlDsa_l = 7;\n+                eta = 2;\n+                beta = 120;\n+                omega = 75;\n+                publicKeyLength = 2592;\n+                signatureLength = 4595;\n+                s1PackedLength = 672;\n+                s2PackedLength = 768;\n+                t0PackedLength = 3328;\n+                s1s2CoeffSize = 3;\n+                wCoeffSize = 4;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Wrong security level\");\n+        }\n+    }\n+\n+    public record ML_DSA_PrivateKey(byte[] rho, byte[] k, byte[] tr, int[][] s1, int[][] s2, int[][] t0) {\n+        void destroy() {\n+            Arrays.fill(k, (byte)0);\n+            for (var b : s1) {\n+                Arrays.fill(b, (byte) 0);\n+            }\n+            for (var b : s2) {\n+                Arrays.fill(b, (byte) 0);\n+            }\n+            for (var b : t0) {\n+                Arrays.fill(b, (byte) 0);\n+            }\n+        }\n+    }\n+\n+    public record ML_DSA_PublicKey(byte[] rho, int[][] t1) {\n+    }\n+\n+    public record ML_DSA_KeyPair(ML_DSA_PrivateKey privateKey, ML_DSA_PublicKey publicKey) {\n+    }\n+\n+    public record ML_DSA_Signature(byte[] commitmentHash, int[][] response, boolean[][] hint) {\n+    }\n+\n+    \/\/Internal functions in Section 6 of specification\n+    public ML_DSA_KeyPair generateKeyPairInternal(byte[] randomBytes) {\n+        \/\/Initialize hash functions\n+        var hash = new SHAKE256(0);\n+        var crHash = new SHAKE256(TR_LEN);\n+\n+        \/\/Expand seed\n+        hash.update(randomBytes);\n+        hash.update((byte)mlDsa_k);\n+        hash.update((byte)mlDsa_l);\n+        byte[] rho = hash.squeeze(A_SEED_LEN);\n+        byte[] rhoPrime = hash.squeeze(S1S2_SEED_LEN);\n+        byte[] k = hash.squeeze(K_LEN);\n+        hash.reset();\n+\n+        \/\/Sample A\n+        int[][][] keygenA = generateA(rho); \/\/A is in NTT domain\n+\n+        \/\/Sample S1 and S2\n+        int[][] s1 = new int[mlDsa_l][ML_DSA_N];\n+        int[][] s2 = new int[mlDsa_k][ML_DSA_N];\n+        sampleS1S2(s1, s2, hash, rhoPrime); \/\/hash is reset before being used in sampleS1S2\n+\n+        \/\/Compute t and tr\n+        mlDsaVectorNtt(s1); \/\/s1 now in NTT domain\n+        int[][] As1 = new int[mlDsa_k][ML_DSA_N];\n+        matrixVectorPointwiseMultiply(As1, keygenA, s1);\n+        mlDsaVectorInverseNtt(s1); \/\/take s1 out of NTT domain\n+\n+        mlDsaVectorInverseNtt(As1);\n+        int[][] t = vectorAddPos(As1, s2);\n+        int[][] t0 = new int[mlDsa_k][ML_DSA_N];\n+        int[][] t1 = new int[mlDsa_k][ML_DSA_N];\n+        power2Round(t, t0, t1);\n+\n+        \/\/Encode PK and SK\n+        ML_DSA_PublicKey pk = new ML_DSA_PublicKey(rho, t1);\n+        byte[] publicKeyBytes = pkEncode(pk);\n+        crHash.update(publicKeyBytes);\n+        byte[] tr = crHash.digest();\n+        ML_DSA_PrivateKey sk = new ML_DSA_PrivateKey(rho, k, tr, s1, s2, t0);\n+\n+        return new ML_DSA_KeyPair(sk, pk);\n+    }\n+\n+    public ML_DSA_Signature signInternal(byte[] message, byte[] rnd, byte[] skBytes) {\n+        \/\/Decode private key and initialize hash function\n+        ML_DSA_PrivateKey sk = skDecode(skBytes);\n+        var hash = new SHAKE256(0);\n+\n+        \/\/Do some NTTs\n+        mlDsaVectorNtt(sk.s1());\n+        mlDsaVectorNtt(sk.s2());\n+        mlDsaVectorNtt(sk.t0());\n+        int[][][] aHat = generateA(sk.rho());\n+\n+        \/\/Compute mu\n+        hash.update(sk.tr());\n+        hash.update(message);\n+        byte[] mu = hash.squeeze(MU_LEN);\n+        hash.reset();\n+\n+        \/\/Compute rho'\n+        hash.update(sk.k());\n+        hash.update(rnd);\n+        hash.update(mu);\n+        byte[] rhoDoublePrime = hash.squeeze(MASK_SEED_LEN);\n+        hash.reset();\n+\n+        \/\/Initialize vectors used in loop\n+        int[][] z = null;\n+        boolean[][] h = null;\n+        byte[] commitmentHash = new byte[lambda\/4];\n+        int[][] y = new int[mlDsa_l][ML_DSA_N];\n+        int[][] w = new int[mlDsa_k][ML_DSA_N];\n+        int[][] w0 = new int[mlDsa_k][ML_DSA_N];\n+        int[][] w1 = new int[mlDsa_k][ML_DSA_N];\n+        int[] c =  new int[ML_DSA_N];\n+\n+        int kappa = 0;\n+        while (true) {\n+            expandMask(y, rhoDoublePrime, kappa);\n+\n+            \/\/Compute w and w1\n+            mlDsaVectorNtt(y); \/\/y is now in NTT domain\n+            matrixVectorPointwiseMultiply(w, aHat, y);\n+            mlDsaVectorInverseNtt(w); \/\/w is now in normal domain\n+            decompose(w, w0, w1);\n+            mlDsaVectorInverseNtt(y);\n+\n+            \/\/Get commitment hash\n+            hash.update(mu);\n+            hash.update(simpleBitPack(wCoeffSize, w1));\n+            commitmentHash = hash.squeeze(lambda\/4);\n+            hash.reset();\n+\n+            \/\/Get z and r0\n+            sampleInBall(c, commitmentHash);\n+            mlDsaNtt(c); \/\/c is now in NTT domain\n+            int[][] cs1 = nttConstMultiply(c, sk.s1());\n+            int[][] cs2 = nttConstMultiply(c, sk.s2());\n+            mlDsaVectorInverseNtt(cs1);\n+            mlDsaVectorInverseNtt(cs2);\n+            z = vectorAdd(y, cs1);\n+            int[][] r0 = vectorSub(w0, cs2);\n+\n+            \/\/Update z and h\n+            kappa += mlDsa_l;\n+            if (vectorNormBound(z, gamma1 - beta) || vectorNormBound(r0, gamma2 - beta)) {\n+                continue;\n+            } else {\n+                int[][] ct0 = nttConstMultiply(c, sk.t0());\n+                mlDsaVectorInverseNtt(ct0);\n+                h = makeHint(vectorConstMul(-1, ct0), vectorAdd(vectorAdd(w, vectorConstMul(-1, cs2)), ct0));\n+                if (vectorNormBound(ct0, gamma2) || (hammingWeight(h) > omega)) {\n+                    continue;\n+                }\n+            }\n+            sk.destroy();\n+            return new ML_DSA_Signature(commitmentHash, z, h);\n+        }\n+    }\n+\n+    public boolean verifyInternal(byte[] pkBytes, byte[] message, byte[] sigBytes) {\n+        \/\/Decode sig and initialize hash\n+        ML_DSA_Signature sig = sigDecode(sigBytes);\n+        var hash = new SHAKE256(0);\n+\n+        \/\/Check hint encoding\n+        if (sig.hint() == null) {return false;}\n+\n+        \/\/Decode pk\n+        ML_DSA_PublicKey pk = pkDecode(pkBytes);\n+\n+        \/\/Expand A\n+        int[][][] aHat = generateA(pk.rho());\n+\n+        \/\/Generate tr\n+        hash.update(pkBytes);\n+        byte[] tr = hash.squeeze(TR_LEN);\n+        hash.reset();\n+\n+        \/\/Generate mu\n+        hash.update(tr);\n+        hash.update(message);\n+        byte[] mu = hash.squeeze(MU_LEN);\n+        hash.reset();\n+\n+        \/\/Get verifiers challenge\n+        int[] cHat = new int[ML_DSA_N];\n+        sampleInBall(cHat, sig.commitmentHash());\n+        mlDsaNtt(cHat);\n+\n+        \/\/Compute response norm and put it in NTT domain\n+        boolean zNorm = vectorNormBound(sig.response(), gamma1 - beta);\n+        mlDsaVectorNtt(sig.response());\n+\n+        \/\/Reconstruct signer's commitment\n+        int[][] aHatZ = new int[mlDsa_k][ML_DSA_N];\n+        matrixVectorPointwiseMultiply(aHatZ, aHat, sig.response());\n+        int[][] t1Hat = vectorConstMul(1 << ML_DSA_D, pk.t1());\n+        mlDsaVectorNtt(t1Hat);\n+        int[][] wApprox = vectorSub(aHatZ, nttConstMultiply(cHat, t1Hat));\n+        mlDsaVectorInverseNtt(wApprox);\n+        int[][] w1Prime = useHint(sig.hint(), wApprox);\n+\n+        \/\/Hash signer's commitment\n+        hash.update(mu);\n+        hash.update(simpleBitPack(wCoeffSize, w1Prime));\n+        byte[] cTildePrime = hash.squeeze(lambda\/4);\n+\n+        \/\/Check verify conditions\n+        boolean hashEq = MessageDigest.isEqual(sig.commitmentHash(), cTildePrime);\n+        return !zNorm && hashEq;\n+    }\n+\n+    \/*\n+    Data conversion functions in Section 7.1 of specification\n+     *\/\n+\n+    \/\/ Bit-pack the t1 and w1 vector into a byte array.\n+    \/\/ The coefficients of the polynomials in the vector should be nonnegative and less than 2^bitsPerCoeff .\n+    public byte[] simpleBitPack(int bitsPerCoeff, int[][] vector) {\n+        byte[] result = new byte[(mlDsa_k * ML_DSA_N * bitsPerCoeff) \/ 8];\n+        int acc = 0;\n+        int shift = 0;\n+        int i = 0;\n+        for (int[] poly : vector) {\n+            for (int m = 0; m < ML_DSA_N; m++) {\n+                acc += (poly[m] << shift);\n+                shift += bitsPerCoeff;\n+                while (shift >= 8) {\n+                    result[i++] = (byte) acc;\n+                    acc >>= 8;\n+                    shift -= 8;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public void bitPack(int[][] vector, int bitsPerCoeff, int maxValue,\n+            byte[] output, int offset) {\n+        int vecLen = vector.length;\n+        int acc = 0;\n+        int shift = 0;\n+        for (int[] poly : vector) {\n+            for (int m = 0; m < ML_DSA_N; m++) {\n+                acc += (maxValue - poly[m]) << shift;\n+                shift += bitsPerCoeff;\n+                while (shift >= 8) {\n+                    output[offset++] = (byte) acc;\n+                    acc >>= 8;\n+                    shift -= 8;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/This is simpleBitUnpack from FIPS 204. Since it is only called on the\n+    \/\/vector t1 we can optimize for that case\n+    public int[][] t1Unpack(byte[] v) {\n+        int[][] t1 = new int[mlDsa_k][ML_DSA_N];\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < ML_DSA_N \/ 4; j++) {\n+                int tOffset = j*4;\n+                int vOffset = (i*320) + (j*5);\n+                t1[i][tOffset] = (v[vOffset] & 0xFF) + ((v[vOffset+1] << 8) & 0x3FF);\n+                t1[i][tOffset+1] = ((v[vOffset+1] >> 2) & 0x3F) + ((v[vOffset+2] << 6) & 0x3FF);\n+                t1[i][tOffset+2] = ((v[vOffset+2] >> 4) & 0xF) + ((v[vOffset+3] << 4) & 0x3FF);\n+                t1[i][tOffset+3] = ((v[vOffset+3] >> 6) & 0x3) + ((v[vOffset+4] << 2) & 0x3FF);\n+            }\n+        }\n+        return t1;\n+    }\n+\n+    public int[][] bitUnpack(int[][] result, byte[] v, int offset, int dim, int maxValue, int bitsPerCoeff) {\n+        switch (bitsPerCoeff) {\n+            case 3 -> { bitUnpackGeneral(result, v, offset, dim, maxValue, 3); }\n+            case 4 -> { bitUnpackGeneral(result, v, offset, dim, maxValue, 4); }\n+            case 13 -> { bitUnpackGeneral(result, v, offset, dim,  maxValue, 13); }\n+            case 18 -> { bitUnpack18(result, v, offset, dim, maxValue); }\n+            case 20 -> { bitUnpack20(result, v, offset, dim, maxValue); }\n+            default -> throw new RuntimeException(\"Wrong bitspercoeffb value in bitUnpack (\" + bitsPerCoeff + \").\");\n+        }\n+        return result;\n+    }\n+    public void bitUnpackGeneral(int[][] result,\n+            byte[] v, int offset, int dim, int maxValue, int bitsPerCoeff) {\n+\n+        int mask = (1 << bitsPerCoeff) - 1;\n+        int top = 0;\n+        int shift = 0;\n+        int acc = 0;\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n+                while (top - shift < bitsPerCoeff) {\n+                    acc += ((v[offset++] & 0xff) << top);\n+                    top += 8;\n+                }\n+                result[i][j] = maxValue - ((acc >> shift) & mask);\n+                shift += bitsPerCoeff;\n+                while (shift >= 8) {\n+                    top -= 8;\n+                    shift -= 8;\n+                    acc >>>= 8;\n+                }\n+            }\n+        }\n+    }\n+    public void bitUnpack18(int [][] result, byte[] v, int offset, int dim, int maxValue) {\n+\n+        int vIndex = offset;\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < ML_DSA_N; j += 4) {\n+                result[i][j] = maxValue - ((v[vIndex] & 0xff) +\n+                        ((v[vIndex + 1] & 0xff) << 8) +\n+                        ((v[vIndex + 2] & 0x3) << 16));\n+                result[i][j + 1] = maxValue - (((v[vIndex + 2] >> 2) & 0x3f) +\n+                        ((v[vIndex + 3] & 0xff) << 6) +\n+                        ((v[vIndex + 4] & 0xf) << 14));\n+                result[i][j + 2] = maxValue - (((v[vIndex + 4] >> 4) & 0xf) +\n+                        ((v[vIndex + 5] & 0xff) << 4) +\n+                        ((v[vIndex + 6] & 0x3f) << 12));\n+                result[i][j + 3] = maxValue - (((v[vIndex + 6] >> 6) & 0x3) +\n+                        ((v[vIndex + 7] & 0xff) << 2) +\n+                        ((v[vIndex + 8] & 0xff) << 10));\n+                vIndex += 9;\n+            }\n+        }\n+    }\n+\n+    public void bitUnpack20(int[][] result, byte[] v, int offset, int dim, int maxValue) {\n+        int vIndex = offset;\n+\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < ML_DSA_N; j += 2) {\n+                result[i][j] = maxValue - ((v[vIndex] & 0xff) +\n+                        ((v[vIndex + 1] & 0xff) << 8) +\n+                        ((v[vIndex + 2] & 0xf) << 16));\n+                result[i][j + 1] = maxValue - (((v[vIndex + 2] >> 4) & 0xf) +\n+                        ((v[vIndex + 3] & 0xff) << 4) +\n+                        ((v[vIndex + 4] & 0xff) << 12));\n+                vIndex += 5;\n+            }\n+        }\n+    }\n+\n+    private void hintBitPack(boolean[][] h, byte[] buffer, int offset) {\n+        int idx = 0;\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n+                if (h[i][j]) {\n+                    buffer[offset + idx] = (byte)j;\n+                    idx++;\n+                }\n+            }\n+            buffer[offset + omega + i] = (byte)idx;\n+        }\n+    }\n+\n+    private boolean[][] hintBitUnpack(byte[] y, int offset) {\n+        boolean[][] h = new boolean[mlDsa_k][ML_DSA_N];\n+        int idx = 0;\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            int j = y[offset + omega + i];\n+            if (j < idx || j > omega) {\n+                return null;\n+            }\n+            int first = idx;\n+            while (idx < j) {\n+                if (idx > first) {\n+                    if ((y[offset + idx - 1] & 0xff) >= (y[offset + idx] & 0xff)) {\n+                        return null;\n+                    }\n+                }\n+                int hintIndex = y[offset + idx] & 0xff;\n+                h[i][hintIndex] = true;\n+                idx++;\n+            }\n+        }\n+\n+        while (idx < omega) {\n+            if (y[offset + idx] != 0) {\n+                return null;\n+            }\n+            idx++;\n+        }\n+        return h;\n+    }\n+\n+    \/*\n+    Encoding functions as specified in Section 7.2 of the specification\n+     *\/\n+\n+    public byte[] pkEncode(ML_DSA_PublicKey key) {\n+        byte[] t1Packed = simpleBitPack(10, key.t1);\n+        byte[] publicKeyBytes = new byte[A_SEED_LEN + t1Packed.length];\n+        System.arraycopy(key.rho, 0, publicKeyBytes, 0, A_SEED_LEN);\n+        System.arraycopy(t1Packed, 0, publicKeyBytes, A_SEED_LEN, t1Packed.length);\n+\n+        return publicKeyBytes;\n+    }\n+\n+    public ML_DSA_PublicKey pkDecode(byte[] pk) {\n+        byte[] rho = Arrays.copyOfRange(pk, 0, A_SEED_LEN);\n+        byte[] v = Arrays.copyOfRange(pk, A_SEED_LEN, pk.length);\n+        int[][] t1 = t1Unpack(v);\n+        return new ML_DSA_PublicKey(rho, t1);\n+    }\n+\n+    public byte[] skEncode(ML_DSA_PrivateKey key) {\n+\n+        byte[] skBytes = new byte[A_SEED_LEN + K_LEN + key.tr.length +\n+                s1PackedLength + s2PackedLength + t0PackedLength];\n+\n+        int pos = 0;\n+        System.arraycopy(key.rho, 0, skBytes, pos, A_SEED_LEN);\n+        pos += A_SEED_LEN;\n+        System.arraycopy(key.k, 0, skBytes, pos, K_LEN);\n+        pos += K_LEN;\n+        System.arraycopy(key.tr, 0, skBytes, pos, TR_LEN);\n+        pos += TR_LEN;\n+\n+        bitPack(key.s1, s1s2CoeffSize, eta, skBytes, pos);\n+        pos += s1PackedLength;\n+        bitPack(key.s2, s1s2CoeffSize, eta, skBytes, pos);\n+        pos += s2PackedLength;\n+        bitPack(key.t0, T0_COEFF_SIZE, 1 << 12, skBytes, pos);\n+\n+        return skBytes;\n+    }\n+\n+    public ML_DSA_PrivateKey skDecode(byte[] sk) {\n+        byte[] rho = new byte[A_SEED_LEN];\n+        System.arraycopy(sk, 0, rho, 0, A_SEED_LEN);\n+\n+        byte[] k = new byte[K_LEN];\n+        System.arraycopy(sk, A_SEED_LEN, k, 0, K_LEN);\n+\n+        byte[] tr = new byte[TR_LEN];\n+        System.arraycopy(sk, A_SEED_LEN + K_LEN, tr, 0, TR_LEN);\n+\n+        \/\/Parse s1\n+        int start = A_SEED_LEN + K_LEN + TR_LEN;\n+        int end = start + (32 * mlDsa_l * s1s2CoeffSize);\n+        int[][] s1 = new int[mlDsa_l][ML_DSA_N];\n+        bitUnpack(s1, sk, start, mlDsa_l, eta, s1s2CoeffSize);\n+\n+        \/\/Parse s2\n+        start = end;\n+        end += 32 * s1s2CoeffSize * mlDsa_k;\n+        int[][] s2 = new int[mlDsa_k][ML_DSA_N];\n+        bitUnpack(s2, sk, start, mlDsa_k, eta, s1s2CoeffSize);\n+\n+        \/\/Parse t0\n+        start = end;\n+        int[][] t0 = new int[mlDsa_k][ML_DSA_N];\n+        bitUnpack(t0, sk, start, mlDsa_k, 1 << 12, T0_COEFF_SIZE);\n+\n+        return new ML_DSA_PrivateKey(rho, k, tr, s1, s2, t0);\n+    }\n+\n+    public byte[] sigEncode(ML_DSA_Signature sig) {\n+        int cSize = lambda \/ 4;\n+        int zSize = mlDsa_l * 32 * (1 + gamma1Bits);\n+\n+        byte[] sigBytes = new byte[cSize + zSize + omega + mlDsa_k];\n+\n+        System.arraycopy(sig.commitmentHash, 0, sigBytes, 0, cSize);\n+        bitPack(sig.response, gamma1Bits + 1, gamma1, sigBytes, cSize);\n+        hintBitPack(sig.hint, sigBytes, cSize + zSize);\n+\n+        return sigBytes;\n+    }\n+\n+    public ML_DSA_Signature sigDecode(byte[] sig) {\n+        \/\/Decode cTilde\n+        byte[] cTilde = Arrays.copyOfRange(sig, 0, lambda\/4);\n+\n+        \/\/Decode z\n+        int start = lambda \/ 4;\n+        int end = start + (32 * mlDsa_l * (1 + gamma1Bits));\n+        int[][] z = new int[mlDsa_l][ML_DSA_N];\n+        bitUnpack(z, sig, start, mlDsa_l, gamma1, gamma1Bits + 1);\n+\n+        \/\/Decode h\n+        start = end;\n+        boolean[][] h = hintBitUnpack(sig, start);\n+        return new ML_DSA_Signature(cTilde, z, h);\n+    }\n+\n+    \/*\n+    Auxiliary functions defined in Section 7.3 of specification\n+     *\/\n+\n+    private class Shake256Slicer {\n+        SHAKE256 xof;\n+        byte[] block;\n+        int byteOffset;\n+        int current;\n+        int bitsInCurrent;\n+        int bitsPerCall;\n+        int bitMask;\n+\n+        Shake256Slicer(SHAKE256 xof, int bitsPerCall) {\n+            this.xof = xof;\n+            \/\/BitsPerCall can only be 4 (when called from sampleS1S2),\n+            \/\/or 8 (when called from sampleInBall)\n+            this.bitsPerCall = bitsPerCall;\n+            bitMask = (1 << bitsPerCall) - 1;\n+            current = 0;\n+            byteOffset = SHAKE256_BLOCK_SIZE;\n+            bitsInCurrent = 0;\n+            block = new byte[SHAKE256_BLOCK_SIZE];\n+        }\n+\n+        void reset() {\n+            xof.reset();\n+            current = 0;\n+            byteOffset = SHAKE256_BLOCK_SIZE;\n+            bitsInCurrent = 0;\n+        }\n+\n+        int squeezeBits() {\n+            while (bitsInCurrent < bitsPerCall) {\n+                if (byteOffset == SHAKE256_BLOCK_SIZE) {\n+                    xof.squeeze(block, 0, SHAKE256_BLOCK_SIZE);\n+                    byteOffset = 0;\n+                }\n+                current += ((block[byteOffset++] & 0xff) << bitsInCurrent);\n+                bitsInCurrent += 8;\n+            }\n+            int result = current & bitMask;\n+            current >>= bitsPerCall;\n+            bitsInCurrent -= bitsPerCall;\n+            return result;\n+        }\n+    }\n+\n+    private void sampleInBall(int[] c, byte[] rho) {\n+        var xof = new SHAKE256(0);\n+        Shake256Slicer slicer = new Shake256Slicer(xof, 8);\n+        xof.update(rho);\n+\n+        long parity = 0;\n+        for (int i = 0; i < 8; i++) {\n+            long sample = slicer.squeezeBits();\n+            parity |= sample << 8 * i;\n+        }\n+\n+        Arrays.fill(c, 0);\n+\n+        int k = 8;\n+        for (int i = 256 - tau; i < 256; i++) {\n+            \/\/Get random index < i\n+            int j = slicer.squeezeBits();\n+            while (j > i) {\n+                j = slicer.squeezeBits();\n+            }\n+\n+            \/\/Swap c[i] and c[j], set c[j] based on parity\n+            c[i] = c[j];\n+            c[j] = (int) (1 - 2 * (parity & 1));\n+            parity >>= 1;\n+        }\n+    }\n+\n+    int[][][] generateA(byte[] seed) {\n+        int blockSize = 168;  \/\/ the size of one block of SHAKE128 output\n+        var xof = new SHAKE128(0);\n+        byte[] xofSeed = new byte[A_SEED_LEN + 2];\n+        System.arraycopy(seed, 0, xofSeed, 0, A_SEED_LEN);\n+        int[][][] a = new int[mlDsa_k][mlDsa_l][ML_DSA_N];\n+\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_l; j++) {\n+                xofSeed[A_SEED_LEN] = (byte) j;\n+                xofSeed[A_SEED_LEN + 1] = (byte) i;\n+                xof.reset();\n+                xof.update(xofSeed);\n+\n+                byte[] rawAij = new byte[blockSize];\n+                int[] aij = new int[ML_DSA_N];\n+                int ofs = 0;\n+                int rawOfs = blockSize;\n+                int tmp;\n+                while (ofs < ML_DSA_N) {\n+                    if (rawOfs == blockSize) {  \/\/ works because 3 divides blockSize (=168)\n+                        xof.squeeze(rawAij, 0, blockSize);\n+                        rawOfs = 0;\n+                    }\n+                    tmp = (rawAij[rawOfs] & 0xFF) +\n+                        ((rawAij[rawOfs + 1] & 0xFF) << 8) +\n+                        ((rawAij[rawOfs + 2] & 0x7F) << 16);\n+                    rawOfs += 3;\n+                    if (tmp < ML_DSA_Q) {\n+                        aij[ofs] = tmp;\n+                        ofs++;\n+                    }\n+                }\n+                a[i][j] = aij;\n+            }\n+        }\n+        return a;\n+    }\n+\n+    private void sampleS1S2(int[][] s1, int[][] s2, SHAKE256 xof, byte[] rhoPrime) {\n+        byte[] seed = new byte[S1S2_SEED_LEN + 2];\n+        System.arraycopy(rhoPrime, 0, seed, 0, S1S2_SEED_LEN);\n+\n+        Shake256Slicer slicer = new Shake256Slicer(xof, 4);\n+        for (int i = 0; i < mlDsa_l; i++) {\n+            seed[S1S2_SEED_LEN] = (byte) i;\n+            seed[S1S2_SEED_LEN + 1] = 0;\n+            slicer.reset();\n+            xof.update(seed);\n+            if (eta == 2) {\n+                for (int j = 0; j < ML_DSA_N; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 14);\n+                    s1[i][j] = eta - sample + (205 * sample >> 10) * 5; \/\/ 2 - sample mod 5\n+                }\n+            } else { \/\/ eta == 4\n+                for (int j = 0; j < ML_DSA_N; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 2 * eta);\n+                    s1[i][j] = eta - sample;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            seed[S1S2_SEED_LEN] = (byte) (mlDsa_l + i);\n+            seed[S1S2_SEED_LEN + 1] = 0;\n+            slicer.reset();\n+            xof.update(seed);\n+            if (eta == 2) {\n+                for (int j = 0; j < ML_DSA_N; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 14);\n+                    s2[i][j] = eta - sample + (205 * sample >> 10) * 5;\n+                }\n+            } else {\n+                for (int j = 0; j < ML_DSA_N; j++) {\n+                    int sample;\n+                    do {\n+                        sample = slicer.squeezeBits();\n+                    } while (sample > 2 * eta);\n+                    s2[i][j] = eta - sample;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void expandMask(int[][] result, byte[] rho, int mu) {\n+        var xof = new SHAKE256(0);\n+\n+        int c = 1 + gamma1Bits;\n+        byte[] v = new byte[mlDsa_l * 32 * c];\n+        for (int r = 0; r < mlDsa_l; r++) {\n+            int a = mu + r;\n+            byte[] n = {(byte) a, (byte) (a >> 8)};\n+\n+            xof.update(rho);\n+            xof.update(n);\n+            xof.squeeze(v, r * 32 * c, 32 * c);\n+            xof.reset();\n+        }\n+        bitUnpack(result, v, 0, mlDsa_l, gamma1, c);\n+    }\n+\n+    \/*\n+    Auxiliary functions defined in section 7.4 of specification\n+     *\/\n+\n+    private void power2Round(int[][] input, int[][] lowPart, int[][] highPart) {\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int m = 0; m < ML_DSA_N; m++) {\n+                int rplus = input[i][m];\n+                int r0 = input[i][m] & D_MASK;\n+                int r00 = (1 << (ML_DSA_D - 1)) - r0 ; \/\/ 2^d\/2 - r+\n+                r0 -= (r00 >> 31) & (1 << ML_DSA_D); \/\/0 if r+ < 2^d\/2\n+                lowPart[i][m] = r0;\n+                highPart[i][m] = (rplus - r0) >> ML_DSA_D;\n+            }\n+        }\n+    }\n+\n+    private void decompose(int[][] input, int[][] lowPart, int[][] highPart) {\n+        int multiplier = (gamma2 == 95232 ? 22 : 8);\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            ML_DSA.mlDsaDecomposePoly(input[i], lowPart[i], highPart[i], gamma2 * 2, multiplier);\n+        }\n+    }\n+\n+    private int[][] highBits(int[][] input) {\n+        int[][] lowPart = new int[mlDsa_k][ML_DSA_N];\n+        int[][] highPart = new int[mlDsa_k][ML_DSA_N];\n+        decompose(input, lowPart, highPart);\n+        return highPart;\n+    }\n+\n+    private boolean[][] makeHint(int[][] z, int[][] r) {\n+        int[][] r1 = highBits(r);\n+        int[][] v1 = highBits(vectorAdd(r,z));\n+        boolean[][] res = new boolean[mlDsa_k][ML_DSA_N];\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n+                res[i][j] = (r1[i][j] != v1[i][j]);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private int[][] useHint(boolean[][] h, int[][] r) {\n+        int m = (ML_DSA_Q - 1) \/ (2*gamma2);\n+        int[][] lowPart = new int[mlDsa_k][ML_DSA_N];\n+        int[][] highPart = new int[mlDsa_k][ML_DSA_N];\n+        decompose(r, lowPart, highPart);\n+\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n+                if (h[i][j]) {\n+                    highPart[i][j] += lowPart[i][j] > 0 ? 1 : -1;\n+                }\n+                highPart[i][j] = ((highPart[i][j] % m) + m) % m;\n+            }\n+        }\n+        return highPart;\n+    }\n+\n+    \/*\n+    NTT functions as specified in Section 7.5 of specification\n+    *\/\n+\n+    public static int[] mlDsaNtt(int[] coeffs) {\n+        implMlDsaAlmostNttJava(coeffs);\n+        implMlDsaMontMulByConstantJava(coeffs,  MONT_R_MOD_Q);\n+        return coeffs;\n+    }\n+\n+    static void implMlDsaAlmostNttJava(int[] coeffs) {\n+        int dimension = ML_DSA_N;\n+        int m = 0;\n+        for (int l = dimension \/ 2; l > 0; l \/= 2) {\n+            for (int s = 0; s < dimension; s += 2 * l) {\n+                for (int j = s; j < s + l; j++) {\n+                    int tmp = montMul(MONT_ZETAS_FOR_NTT[m], coeffs[j + l]);\n+                    coeffs[j + l] = coeffs[j] - tmp;\n+                    coeffs[j] = coeffs[j] + tmp;\n+                }\n+                m++;\n+            }\n+        }\n+    }\n+\n+    public static int[] mlDsaInverseNtt(int[] coeffs) {\n+        implMlDsaAlmostInverseNttJava(coeffs);\n+        implMlDsaMontMulByConstantJava(coeffs, MONT_DIM_INVERSE);\n+        return coeffs;\n+    }\n+\n+    static void implMlDsaAlmostInverseNttJava(int[] coeffs) {\n+        int dimension = ML_DSA_N;\n+        int m = 0;\n+        for (int l = 1; l < dimension; l *= 2) {\n+            for (int s = 0; s < dimension; s += 2 * l) {\n+                for (int j = s; j < s + l; j++) {\n+                    int tmp = coeffs[j];\n+                    coeffs[j] = (tmp + coeffs[j + l]);\n+                    coeffs[j + l] = montMul(tmp - coeffs[j + l], MONT_ZETAS_FOR_INVERSE_NTT[m]);\n+                }\n+                m++;\n+            }\n+        }\n+    }\n+\n+    void mlDsaVectorNtt(int[][] vector) {\n+        for (int[] ints : vector) {\n+            mlDsaNtt(ints);\n+        }\n+    }\n+\n+    void mlDsaVectorInverseNtt(int[][] vector) {\n+        for (int[] ints : vector) {\n+            mlDsaInverseNtt(ints);\n+        }\n+    }\n+\n+    public static int[] mlDsaNttMultiply(int[] coeffs1, int[] coeffs2) {\n+        int[] product = new int[ML_DSA_N];\n+        implMlDsaNttMultJava(product, coeffs1, coeffs2);\n+        return product;\n+    }\n+\n+    static void implMlDsaNttMultJava(int[] product, int[] coeffs1, int[] coeffs2) {\n+        for (int i = 0; i < ML_DSA_N; i++) {\n+            product[i] = montMul(coeffs1[i], toMont(coeffs2[i]));\n+        }\n+    }\n+\n+    public static void montMulByConstant(int[] coeffs, int constant) {\n+        implMlDsaMontMulByConstantJava(coeffs, constant);\n+    }\n+\n+    static void implMlDsaMontMulByConstantJava(int[] coeffs, int constant) {\n+        for (int i = 0; i < ML_DSA_N; i++) {\n+            coeffs[i] = montMul((coeffs[i]), constant);\n+        }\n+    }\n+\n+    public static void mlDsaDecomposePoly(int[] input, int[] lowPart, int[] highPart,\n+                                         int twoGamma2, int multiplier) {\n+        implMlDsaDecomposePoly(input, lowPart, highPart, twoGamma2, multiplier);\n+    }\n+\n+    @IntrinsicCandidate\n+    static void implMlDsaDecomposePoly(int[] input, int[] lowPart, int[] highPart,\n+                                          int twoGamma2, int multiplier) {\n+        decomposePolyJava(input, lowPart, highPart, twoGamma2, multiplier);\n+    }\n+\n+    static void decomposePolyJava(int[] input, int[] lowPart, int[] highPart,\n+                                 int twoGamma2, int multiplier) {\n+        for (int m = 0; m < ML_DSA_N; m++) {\n+            int rplus = input[m];\n+            rplus = rplus - ((rplus + 5373807) >> 23) * ML_DSA_Q;\n+            rplus = rplus + ((rplus >> 31) & ML_DSA_Q);\n+            int r0 = rplus - ((rplus * multiplier) >> 22) * twoGamma2;\n+            r0 -= (((twoGamma2 - r0) >> 22) & twoGamma2);\n+            r0 -= (((twoGamma2 \/ 2 - r0) >> 31) & twoGamma2);\n+            int r1 = rplus - r0 - (ML_DSA_Q - 1);\n+            r1 = (r1 | (-r1)) >> 31;\n+            r0 += ~r1;\n+            r1 = r1 & ((rplus - r0) \/ twoGamma2);\n+            lowPart[m] = r0;\n+            highPart[m] = r1;\n+        }\n+    }\n+\n+    private void matrixVectorPointwiseMultiply(int[][] res, int[][][] matrix, int[][] vector) {\n+        int resulti[] = new int[ML_DSA_N];\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int m = 0; m < ML_DSA_N; m++) {\n+                resulti[m] = 0;\n+            }\n+            for (int j = 0; j < mlDsa_l; j++) {\n+                int[] product = mlDsaNttMultiply(matrix[i][j], vector[j]);\n+                for (int m = 0; m < ML_DSA_N; m++) {\n+                    resulti[m] += product[m];\n+                }\n+            }\n+            for (int m = 0; m < ML_DSA_N; m++) {\n+                res[i][m] = montMul(resulti[m], MONT_R_MOD_Q);\n+            }\n+        }\n+    }\n+\n+    private int[][] nttConstMultiply(int[] a, int[][] b) {\n+        int[][] res = new int[b.length][ML_DSA_N];\n+        for (int i = 0; i < b.length; i++) {\n+            res[i] = mlDsaNttMultiply(a, b[i]);\n+        }\n+        return res;\n+    }\n+\n+    private int[][] vectorConstMul(int c, int[][] vec) {\n+        int[][] res = new int[vec.length][vec[0].length];\n+        for (int i = 0; i < vec.length; i++) {\n+            for (int j = 0; j < vec[0].length; j++) {\n+                res[i][j] = montMul(c, toMont(vec[i][j]));\n+            }\n+        }\n+        return res; \/\/ -q < res[i][j] < q\n+    }\n+\n+    \/\/ Adds two vectors of polynomials\n+    \/\/ The coefficients in the input should be between -MONT_Q and MONT_Q .\n+    \/\/ The coefficients in the output will be nonnegative and less than MONT_Q\n+    int[][] vectorAddPos(int[][] vec1, int[][] vec2) {\n+        int dim = vec1.length;\n+        int[][] result = new int[dim][ML_DSA_N];\n+        for (int i = 0; i < dim; i++) {\n+            for (int m = 0; m < ML_DSA_N; m++) {\n+                int r = vec1[i][m] + vec2[i][m]; \/\/ -2 * MONT_Q < r < 2 * MONT_Q\n+                r += (((r >> 31) & (2 * MONT_Q)) - MONT_Q); \/\/ -MONT_Q < r < MONT_Q\n+                r += ((r >> 31) & MONT_Q); \/\/ 0 <= r < MONT_Q\n+                result[i][m] = r;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    int[][] vectorAdd(int[][] vec1, int[][] vec2) {\n+        int dim = vec1.length;\n+        int[][] result = new int[dim][ML_DSA_N];\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n+                int tmp = vec1[i][j] + vec2[i][j];\n+                tmp -= tmp >= ML_DSA_Q ? ML_DSA_Q : 0;\n+                result[i][j] = tmp;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    int[][] vectorSub(int[][] vec1, int[][] vec2) {\n+        int dim = vec1.length;\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n+                int tmp = vec1[i][j] - vec2[i][j];\n+                tmp += tmp < 0 ? ML_DSA_Q : 0;\n+                vec1[i][j] = tmp;\n+            }\n+        }\n+        return vec1;\n+    }\n+\n+    \/\/Precondition: 2^-31 <= r1 <= 2^31 - 5 * 2^20, and bound < q - 5234431\n+    \/\/Computes whether the infinity norm of a vector is >= bound\n+    boolean vectorNormBound(int[][] vec, int bound) {\n+        boolean res = false;\n+        for (int i = 0; i < vec.length; i++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n+                int r1 = vec[i][j];\n+                r1 = r1 - ((r1 + (5  << 20)) >> 23) * ML_DSA_Q;\n+                r1 = r1 - ((r1 >> 31) & r1) * 2;\n+                res |= (r1 >= bound);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private int hammingWeight(boolean[][] vec) {\n+        int weight = 0;\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n+                weight += vec[i][j] ? 1 : 0;\n+            }\n+        }\n+        return weight;\n+    }\n+\n+    \/\/ precondition: -2^31 * MONT_Q <= a, b < 2^31, -2^31 < a * b < 2^31 * MONT_Q\n+    \/\/ computes a * b * 2^-32 mod MONT_Q\n+    \/\/ the result is greater than -MONT_Q and less than MONT_Q\n+    private static int montMul(int b, int c) {\n+        long a = (long) b * (long) c;\n+        int aHigh = (int) (a >> MONT_R_BITS);\n+        int aLow = (int) a;\n+        int m = MONT_Q_INV_MOD_R * aLow; \/\/ signed low product\n+\n+        return (aHigh - (int) (((long)m * MONT_Q) >> MONT_R_BITS));  \/\/ subtract signed high product\n+    }\n+\n+    static int toMont(int a) {\n+        return montMul(a, MONT_R_SQUARE_MOD_Q);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":1450,"deletions":0,"binary":false,"changes":1450,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.jca.JCAUtil;\n+import java.security.*;\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+\n+public class ML_DSA_Provider {\n+\n+    static int name2int(String name) {\n+        if (name.endsWith(\"44\")) return 2;\n+        else if (name.endsWith(\"65\")) return 3;\n+        else if (name.endsWith(\"87\")) return 5;\n+        else throw new ProviderException();\n+    }\n+\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            \/\/ ML-DSA-65 is default\n+            super(\"ML-DSA\", \"ML-DSA-65\", \"ML-DSA-44\", \"ML-DSA-87\");\n+        }\n+\n+        public KPG(String pname) {\n+            super(\"ML-DSA\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n+            byte[] seed = new byte[32];\n+            var r = sr != null ? sr : JCAUtil.getDefSecureRandom();\n+            r.nextBytes(seed);\n+            ML_DSA mlDsa = new ML_DSA(name2int(name));\n+            ML_DSA.ML_DSA_KeyPair kp = mlDsa.generateKeyPairInternal(seed);\n+            try {\n+                return new byte[][]{\n+                        mlDsa.pkEncode(kp.publicKey()),\n+                        mlDsa.skEncode(kp.privateKey())};\n+            } finally {\n+                kp.privateKey().destroy();\n+                Arrays.fill(seed, (byte)0);\n+            }\n+        }\n+    }\n+\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"ML-DSA-44\");\n+        }\n+    }\n+\n+    public static class KPG3 extends KPG {\n+        public KPG3() {\n+            super(\"ML-DSA-65\");\n+        }\n+    }\n+\n+    public static class KPG5 extends KPG {\n+        public KPG5() {\n+            super(\"ML-DSA-87\");\n+        }\n+    }\n+\n+    public static class KF extends NamedKeyFactory {\n+        public KF() {\n+            super(\"ML-DSA\", \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n+        }\n+        public KF(String name) {\n+            super(\"ML-DSA\", name);\n+        }\n+    }\n+\n+    public static class KF2 extends KF {\n+        public KF2() {\n+            super(\"ML-DSA-44\");\n+        }\n+    }\n+\n+    public static class KF3 extends KF {\n+        public KF3() {\n+            super(\"ML-DSA-65\");\n+        }\n+    }\n+\n+    public static class KF5 extends KF {\n+        public KF5() {\n+            super(\"ML-DSA-87\");\n+        }\n+    }\n+\n+    \/\/ TODO: check key in initSign and initVerify?\n+    public static class SIG extends NamedSignature {\n+        public SIG() {\n+            super(\"ML-DSA\", \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n+        }\n+        public SIG(String name) {\n+            super(\"ML-DSA\", name);\n+        }\n+\n+        @Override\n+        public byte[] implSign(String name, byte[] skBytes, Object sk2, byte[] msg, SecureRandom sr) {\n+            var size = name2int(name);\n+            var r = sr != null ? sr : JCAUtil.getDefSecureRandom();\n+            byte[] rnd = new byte[32];\n+            r.nextBytes(rnd);\n+            var mlDsa = new ML_DSA(size);\n+            ML_DSA.ML_DSA_Signature sig = mlDsa.signInternal(msg, rnd, skBytes);\n+            return mlDsa.sigEncode(sig);\n+        }\n+\n+        @Override\n+        public boolean implVerify(String name, byte[] pkBytes, Object pk2, byte[] msg, byte[] sigBytes) {\n+            var size = name2int(name);\n+            var mlDsa = new ML_DSA(size);\n+            return mlDsa.verifyInternal(pkBytes, msg, sigBytes);\n+        }\n+    }\n+\n+    public static class SIG2 extends SIG {\n+        public SIG2() {\n+            super(\"ML-DSA-44\");\n+        }\n+    }\n+\n+    public static class SIG3 extends SIG {\n+        public SIG3() {\n+            super(\"ML-DSA-65\");\n+        }\n+    }\n+\n+    public static class SIG5 extends SIG {\n+        public SIG5() {\n+            super(\"ML-DSA-87\");\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Provider.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -192,0 +192,6 @@\n+\n+        add(p, \"Signature\", \"ML-DSA\", \"sun.security.provider.ML_DSA_Provider$SIG\", attrs);\n+        addWithAlias(p, \"Signature\", \"ML-DSA-44\", \"sun.security.provider.ML_DSA_Provider$SIG2\", attrs);\n+        addWithAlias(p, \"Signature\", \"ML-DSA-65\", \"sun.security.provider.ML_DSA_Provider$SIG3\", attrs);\n+        addWithAlias(p, \"Signature\", \"ML-DSA-87\", \"sun.security.provider.ML_DSA_Provider$SIG5\", attrs);\n+\n@@ -197,1 +203,0 @@\n-        attrs.put(\"KeySize\", \"2048\"); \/\/ for DSA KPG and APG only\n@@ -201,0 +206,1 @@\n+        attrs.put(\"KeySize\", \"2048\");\n@@ -202,0 +208,6 @@\n+        attrs.remove(\"KeySize\");\n+\n+        add(p, \"KeyPairGenerator\", \"ML-DSA\", \"sun.security.provider.ML_DSA_Provider$KPG\", attrs);\n+        addWithAlias(p, \"KeyPairGenerator\", \"ML-DSA-44\", \"sun.security.provider.ML_DSA_Provider$KPG2\", attrs);\n+        addWithAlias(p, \"KeyPairGenerator\", \"ML-DSA-65\", \"sun.security.provider.ML_DSA_Provider$KPG3\", attrs);\n+        addWithAlias(p, \"KeyPairGenerator\", \"ML-DSA-87\", \"sun.security.provider.ML_DSA_Provider$KPG5\", attrs);\n@@ -206,0 +218,1 @@\n+        attrs.put(\"KeySize\", \"2048\");\n@@ -224,0 +237,5 @@\n+        add(p, \"KeyFactory\", \"ML-DSA\", \"sun.security.provider.ML_DSA_Provider$KF\", attrs);\n+        addWithAlias(p, \"KeyFactory\", \"ML-DSA-44\", \"sun.security.provider.ML_DSA_Provider$KF2\", attrs);\n+        addWithAlias(p, \"KeyFactory\", \"ML-DSA-65\", \"sun.security.provider.ML_DSA_Provider$KF3\", attrs);\n+        addWithAlias(p, \"KeyFactory\", \"ML-DSA-87\", \"sun.security.provider.ML_DSA_Provider$KF5\", attrs);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SunEntries.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -322,0 +322,5 @@\n+    \/\/ PQC\n+    ML_DSA_44(\"1.3.6.1.4.1.2.267.12.4.4\", \"ML-DSA-44\"),\n+    ML_DSA_65(\"1.3.6.1.4.1.2.267.12.6.5\", \"ML-DSA-65\"),\n+    ML_DSA_87(\"1.3.6.1.4.1.2.267.12.8.7\", \"ML-DSA-87\"),\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-            default -> throw new UnsupportedOperationException(alg);\n+            default -> -1;\n","filename":"test\/jdk\/sun\/security\/provider\/all\/Deterministic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}