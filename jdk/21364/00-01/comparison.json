{"files":[{"patch":"@@ -539,2 +539,3 @@\n-    public ML_DSA_Signature sign(byte[] message, byte[] rnd, ML_DSA_PrivateKey sk) {\n-        \/\/Initialize hash functions\n+    public ML_DSA_Signature sign(byte[] message, byte[] rnd, byte[] skBytes) {\n+        \/\/Decode private key and initialize hash function\n+        ML_DSA_PrivateKey sk = skDecode(skBytes);\n@@ -543,4 +544,0 @@\n-        int[][] s1 = Arrays.stream(sk.s1()).map(int[]::clone).toArray(int[][]::new);\n-        int[][] s2 = Arrays.stream(sk.s2()).map(int[]::clone).toArray(int[][]::new);\n-        int[][] t0 = Arrays.stream(sk.t0()).map(int[]::clone).toArray(int[][]::new);\n-\n@@ -548,3 +545,3 @@\n-        mlDsaVectorNtt(s1);\n-        mlDsaVectorNtt(s2);\n-        mlDsaVectorNtt(t0);\n+        mlDsaVectorNtt(sk.s1());\n+        mlDsaVectorNtt(sk.s2());\n+        mlDsaVectorNtt(sk.t0());\n@@ -563,1 +560,1 @@\n-        byte[] rhoPrime = hash.squeeze(mlDsaMaskSeedLength);\n+        byte[] rhoDoublePrime = hash.squeeze(mlDsaMaskSeedLength);\n@@ -573,1 +570,1 @@\n-            int[][] y = expandMask(rhoPrime, kappa);\n+            int[][] y = expandMask(rhoDoublePrime, kappa);\n@@ -578,1 +575,1 @@\n-            mlDsaVectorInverseNtt(w); \/\/w is not in normal domain\n+            mlDsaVectorInverseNtt(w); \/\/w is now in normal domain\n@@ -593,2 +590,2 @@\n-            int[][] cs1 = nttConstMultiply(c, s1);\n-            int[][] cs2 = nttConstMultiply(c, s2);\n+            int[][] cs1 = nttConstMultiply(c, sk.s1());\n+            int[][] cs2 = nttConstMultiply(c, sk.s2());\n@@ -605,1 +602,1 @@\n-                int[][] ct0 = nttConstMultiply(c, t0);\n+                int[][] ct0 = nttConstMultiply(c, sk.t0());\n@@ -616,1 +613,3 @@\n-    public boolean verify(ML_DSA_PublicKey pk, byte[] message, ML_DSA_Signature sig) {\n+    public boolean verify(byte[] pkBytes, byte[] message, byte[] sigBytes) {\n+        \/\/Decode sig and initialize hash\n+        ML_DSA_Signature sig = sigDecode(sigBytes);\n@@ -622,0 +621,3 @@\n+        \/\/Decode pk\n+        ML_DSA_PublicKey pk = pkDecode(pkBytes);\n+\n@@ -626,1 +628,1 @@\n-        hash.update(pkEncode(pk));\n+        hash.update(pkBytes);\n@@ -640,4 +642,3 @@\n-        \/\/Deal with z\n-        int[][] z = Arrays.stream(sig.response()).map(int[]::clone).toArray(int[][]::new);\n-        boolean zNorm = vectorNormBound(z, gamma1 - beta);\n-        mlDsaVectorNtt(z);\n+        \/\/Compute response norm and put it in NTT domain\n+        boolean zNorm = vectorNormBound(sig.response(), gamma1 - beta);\n+        mlDsaVectorNtt(sig.response());\n@@ -646,1 +647,1 @@\n-        int[][] aHatZ = matrixVectorPointwiseMultiply(aHat, z);\n+        int[][] aHatZ = matrixVectorPointwiseMultiply(aHat, sig.response());\n@@ -660,2 +661,1 @@\n-        boolean weight = hammingWeight(sig.hint()) <= omega;\n-        return !zNorm && hashEq && weight;\n+        return !zNorm && hashEq;\n@@ -665,1 +665,1 @@\n-    Data conversion functions in Section 8.1 of specification\n+    Data conversion functions in Section 7.1 of specification\n@@ -773,0 +773,1 @@\n+            int first = idx;\n@@ -774,0 +775,5 @@\n+                if (idx > first) {\n+                    if (y[idx - 1] >= y[idx]) {\n+                        return null;\n+                    }\n+                }\n@@ -790,1 +796,1 @@\n-    Encoding functions as specified in Section 8.2 of the specification\n+    Encoding functions as specified in Section 7.2 of the specification\n@@ -894,1 +900,1 @@\n-    Auxiliary functions defined in Section 8.3 of specification\n+    Auxiliary functions defined in Section 7.3 of specification\n@@ -967,0 +973,39 @@\n+    int[][][] generateA(byte[] seed) {\n+        int blockSize = 168;  \/\/ the size of one block of SHAKE128 output\n+        var xof = new SHAKE128(0);\n+        byte[] xofSeed = new byte[mlDsaASeedLength + 2];\n+        System.arraycopy(seed, 0, xofSeed, 0, mlDsaASeedLength);\n+        int[][][] a = new int[mlDsa_k][mlDsa_l][mlDsa_n];\n+\n+        for (int i = 0; i < mlDsa_k; i++) {\n+            for (int j = 0; j < mlDsa_l; j++) {\n+                xofSeed[mlDsaASeedLength] = (byte) j;\n+                xofSeed[mlDsaASeedLength + 1] = (byte) i;\n+                xof.reset();\n+                xof.update(xofSeed);\n+\n+                byte[] rawAij = new byte[blockSize];\n+                int[] aij = new int[mlDsa_n];\n+                int ofs = 0;\n+                int rawOfs = blockSize;\n+                int tmp;\n+                while (ofs < mlDsa_n) {\n+                    if (rawOfs == blockSize) {  \/\/ works because 3 divides blockSize (=168)\n+                        xof.squeeze(rawAij, 0, blockSize);\n+                        rawOfs = 0;\n+                    }\n+                    tmp = (rawAij[rawOfs] & 0xFF) +\n+                        ((rawAij[rawOfs + 1] & 0xFF) << 8) +\n+                        ((rawAij[rawOfs + 2] & 0x7F) << 16);\n+                    rawOfs += 3;\n+                    if (tmp < mlDsa_q) {\n+                        aij[ofs] = tmp;\n+                        ofs++;\n+                    }\n+                }\n+                a[i][j] = aij;\n+            }\n+        }\n+        return a;\n+    }\n+\n@@ -1021,39 +1066,0 @@\n-    int[][][] generateA(byte[] seed) {\n-        int blockSize = 168;  \/\/ the size of one block of SHAKE128 output\n-        var xof = new SHAKE128(0);\n-        byte[] xofSeed = new byte[mlDsaASeedLength + 2];\n-        System.arraycopy(seed, 0, xofSeed, 0, mlDsaASeedLength);\n-        int[][][] a = new int[mlDsa_k][mlDsa_l][mlDsa_n];\n-\n-        for (int i = 0; i < mlDsa_k; i++) {\n-            for (int j = 0; j < mlDsa_l; j++) {\n-                xofSeed[mlDsaASeedLength] = (byte) j;\n-                xofSeed[mlDsaASeedLength + 1] = (byte) i;\n-                xof.reset();\n-                xof.update(xofSeed);\n-\n-                byte[] rawAij = new byte[blockSize];\n-                int[] aij = new int[mlDsa_n];\n-                int ofs = 0;\n-                int rawOfs = blockSize;\n-                int tmp;\n-                while (ofs < mlDsa_n) {\n-                    if (rawOfs == blockSize) {  \/\/ works because 3 divides blockSize (=168)\n-                        xof.squeeze(rawAij, 0, blockSize);\n-                        rawOfs = 0;\n-                    }\n-                    tmp = (rawAij[rawOfs] & 0xFF) +\n-                        ((rawAij[rawOfs + 1] & 0xFF) << 8) +\n-                        ((rawAij[rawOfs + 2] & 0x7F) << 16);\n-                    rawOfs += 3;\n-                    if (tmp < mlDsa_q) {\n-                        aij[ofs] = tmp;\n-                        ofs++;\n-                    }\n-                }\n-                a[i][j] = aij;\n-            }\n-        }\n-        return a;\n-    }\n-\n@@ -1081,1 +1087,1 @@\n-    Auxiliary functions defined in section 8.4 of specification\n+    Auxiliary functions defined in section 7.4 of specification\n@@ -1161,1 +1167,1 @@\n-    NTT functions as specified in Section 8.5 of specification\n+    NTT functions as specified in Section 7.5 of specification\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":74,"deletions":68,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -125,2 +125,1 @@\n-            var sk = mlDsa.skDecode(skBytes);\n-            ML_DSA.ML_DSA_Signature sig = mlDsa.sign(msg, rnd, sk);\n+            ML_DSA.ML_DSA_Signature sig = mlDsa.sign(msg, rnd, skBytes);\n@@ -134,3 +133,1 @@\n-            var pk = mlDsa.pkDecode(pkBytes);\n-            var sig = mlDsa.sigDecode(sigBytes);\n-            return mlDsa.verify(pk, msg, sig);\n+            return mlDsa.verify(pkBytes, msg, sigBytes);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Provider.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}