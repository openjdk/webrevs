{"files":[{"patch":"@@ -36,11 +36,25 @@\n-    private static final int mlDsa_q = 8380417;\n-    private static final int mlDsa_n = 256;\n-    private static final int shake256BlockSize = 136; \/\/ the block length for SHAKE256\n-    private static final int montRBits = 32;\n-    private static final long montR = 4294967296L; \/\/ 1 << montRBits\n-    private static final int montQ = 8380417;\n-    private static final int montRSquareModQ = 2365951;\n-    private static final int montQInvModR = 58728449;\n-    private static final int montRModQ = 4193792;\n-    private static final int montDimInverse = 16382; \/\/ toMont((mlDsa_n)^-1 (mod mlDsa_q))\n-    private static final int[] montZetasForNtt = new int[]{\n+    \/\/ Constants from FIPS 204 that do not depend on security level\n+    private static final int ML_DSA_D = 13;\n+    private static final int ML_DSA_Q = 8380417;\n+    private static final int ML_DSA_N = 256;\n+    private static final int SHAKE256_BLOCK_SIZE = 136; \/\/ the block length for SHAKE256\n+\n+    private final int A_SEED_LEN = 32;\n+    private final int S1S2_SEED_LEN = 64;\n+    private final int K_LEN = 32;\n+    private final int TR_LEN = 64;\n+    private final int MU_LEN = 64;\n+    private final int MASK_SEED_LEN = 64;\n+    private static final int D_MASK = (1 << ML_DSA_D) - 1;\n+    private final int T0_COEFF_SIZE = 13;\n+    \n+    private static final int MONT_R_BITS = 32;\n+    private static final long MONT_R = 4294967296L; \/\/ 1 << MONT_R_BITS\n+    private static final int MONT_Q = 8380417;\n+    private static final int MONT_R_SQUARE_MOD_Q = 2365951;\n+    private static final int MONT_Q_INV_MOD_R = 58728449;\n+    private static final int MONT_R_MOD_Q = 4193792;\n+    private static final int MONT_DIM_INVERSE = 16382; \/\/ toMont((ML_DSA_N)^-1 (mod ML_DSA_Q))\n+\n+    \/\/ Zeta values for NTT with montgomery factor precomputed\n+    private static final int[] MONT_ZETAS_FOR_NTT = new int[]{\n@@ -80,1 +94,1 @@\n-    private static final int[] montZetasForInverseNtt = new int[]{\n+    private static final int[] MONT_ZETAS_FOR_INVERSE_NTT = new int[]{\n@@ -115,1 +129,1 @@\n-    private static final int[] montZetasForVectorNtt = new int[]{\n+    private static final int[] MONT_ZETAS_FOR_VECTOR_NTT = new int[]{\n@@ -253,1 +267,1 @@\n-    private static final int[] montZetasForVectorInverseNtt = new int[]{\n+    private static final int[] MONT_ZETAS_FOR_VECTOR_INVERSE_NTT = new int[]{\n@@ -390,8 +404,3 @@\n-    private final int mlDsaASeedLength = 32;\n-    private final int mlDsaS1S2SeedLength = 64;\n-    private final int mlDsaKLength = 32;\n-    private final int mlDsaTrLength = 64;\n-    private final int mlDsaMuLength = 64;\n-    private final int mlDsaMaskSeedLength = 64;\n-    private static final int mlDsa_d = 13;\n-    private static final int dMask = (1 << mlDsa_d) - 1;\n+\n+    \/\/ Constants defined for each security level\n+    private final int level;\n@@ -401,1 +410,0 @@\n-    private final int gamma1Bits;\n@@ -408,0 +416,5 @@\n+\n+    \/\/ Second-class constants derived from above values\n+    \/\/ log_2(gamma1)\n+    private final int gamma1Bits;\n+    \/\/ mlDsa_l * (eta + 1) * 256 \/ 8\n@@ -409,0 +422,1 @@\n+    \/\/ mlDsa_k * (eta + 1) * 256 \/ 8\n@@ -410,0 +424,1 @@\n+    \/\/ mlDsa_k * ML_DSA_D * 256 \/ 8\n@@ -411,0 +426,1 @@\n+    \/\/ log_2(eta) + 1\n@@ -412,2 +428,1 @@\n-    private final int t0CoeffSize = 13;\n-    private final int privateKeyLength;\n+    \/\/ rho_size + t1_size\n@@ -415,0 +430,1 @@\n+    \/\/ c_tilde_size + z_size + h_size\n@@ -416,0 +432,1 @@\n+    \/\/ mlDsa_k * log_2((q-1)\/(2*gamma2) - 1) * 256 \/ 8\n@@ -417,1 +434,0 @@\n-    private final int level;\n@@ -427,1 +443,1 @@\n-                gamma2 = (mlDsa_q - 1) \/ 88;\n+                gamma2 = (ML_DSA_Q - 1) \/ 88;\n@@ -433,1 +449,0 @@\n-                privateKeyLength = 0;\n@@ -447,2 +462,1 @@\n-                gamma1Bits = 19;\n-                gamma2 = (mlDsa_q - 1) \/ 32;\n+                gamma2 = (ML_DSA_Q - 1) \/ 32;\n@@ -454,1 +468,0 @@\n-                privateKeyLength = 0;\n@@ -462,0 +475,1 @@\n+                gamma1Bits = 19;\n@@ -469,1 +483,1 @@\n-                gamma2 = (mlDsa_q - 1) \/ 32;\n+                gamma2 = (ML_DSA_Q - 1) \/ 32;\n@@ -475,1 +489,0 @@\n-                privateKeyLength = 0;\n@@ -517,1 +530,1 @@\n-        var crHash = new SHAKE256(mlDsaTrLength);\n+        var crHash = new SHAKE256(TR_LEN);\n@@ -523,3 +536,3 @@\n-        byte[] rho = hash.squeeze(mlDsaASeedLength);\n-        byte[] rhoPrime = hash.squeeze(mlDsaS1S2SeedLength);\n-        byte[] k = hash.squeeze(mlDsaKLength);\n+        byte[] rho = hash.squeeze(A_SEED_LEN);\n+        byte[] rhoPrime = hash.squeeze(S1S2_SEED_LEN);\n+        byte[] k = hash.squeeze(K_LEN);\n@@ -532,2 +545,2 @@\n-        int[][] s1 = new int[mlDsa_l][mlDsa_n];\n-        int[][] s2 = new int[mlDsa_k][mlDsa_n];\n+        int[][] s1 = new int[mlDsa_l][ML_DSA_N];\n+        int[][] s2 = new int[mlDsa_k][ML_DSA_N];\n@@ -543,2 +556,2 @@\n-        int[][] t0 = new int[mlDsa_k][mlDsa_n];\n-        int[][] t1 = new int[mlDsa_k][mlDsa_n];\n+        int[][] t0 = new int[mlDsa_k][ML_DSA_N];\n+        int[][] t1 = new int[mlDsa_k][ML_DSA_N];\n@@ -571,1 +584,1 @@\n-        byte[] mu = hash.squeeze(mlDsaMuLength);\n+        byte[] mu = hash.squeeze(MU_LEN);\n@@ -578,1 +591,1 @@\n-        byte[] rhoDoublePrime = hash.squeeze(mlDsaMaskSeedLength);\n+        byte[] rhoDoublePrime = hash.squeeze(MASK_SEED_LEN);\n@@ -594,2 +607,2 @@\n-            int[][] w0 = new int[mlDsa_k][mlDsa_n];\n-            int[][] w1 = new int[mlDsa_k][mlDsa_n];\n+            int[][] w0 = new int[mlDsa_k][ML_DSA_N];\n+            int[][] w1 = new int[mlDsa_k][ML_DSA_N];\n@@ -648,1 +661,1 @@\n-        byte[] tr = hash.squeeze(mlDsaTrLength);\n+        byte[] tr = hash.squeeze(TR_LEN);\n@@ -654,1 +667,1 @@\n-        byte[] mu = hash.squeeze(mlDsaMuLength);\n+        byte[] mu = hash.squeeze(MU_LEN);\n@@ -667,1 +680,1 @@\n-        int[][] t1Hat = vectorConstMul(1 << mlDsa_d, pk.t1());\n+        int[][] t1Hat = vectorConstMul(1 << ML_DSA_D, pk.t1());\n@@ -690,1 +703,1 @@\n-        byte[] result = new byte[(mlDsa_k * mlDsa_n * bitsPerCoeff) \/ 8];\n+        byte[] result = new byte[(mlDsa_k * ML_DSA_N * bitsPerCoeff) \/ 8];\n@@ -695,1 +708,1 @@\n-            for (int m = 0; m < mlDsa_n; m++) {\n+            for (int m = 0; m < ML_DSA_N; m++) {\n@@ -714,1 +727,1 @@\n-            for (int m = 0; m < mlDsa_n; m++) {\n+            for (int m = 0; m < ML_DSA_N; m++) {\n@@ -729,1 +742,1 @@\n-        int[][] t1 = new int[mlDsa_k][mlDsa_n];\n+        int[][] t1 = new int[mlDsa_k][ML_DSA_N];\n@@ -731,1 +744,1 @@\n-            for (int j = 0; j < mlDsa_n \/ 4; j++) {\n+            for (int j = 0; j < ML_DSA_N \/ 4; j++) {\n@@ -744,1 +757,1 @@\n-        int[][] res = new int[dim][mlDsa_n];\n+        int[][] res = new int[dim][ML_DSA_N];\n@@ -751,1 +764,1 @@\n-            for (int j = 0; j < mlDsa_n; j++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n@@ -771,1 +784,1 @@\n-            for (int j = 0; j < mlDsa_n; j++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n@@ -782,1 +795,1 @@\n-        boolean[][] h = new boolean[mlDsa_k][mlDsa_n];\n+        boolean[][] h = new boolean[mlDsa_k][ML_DSA_N];\n@@ -817,3 +830,3 @@\n-        byte[] publicKeyBytes = new byte[mlDsaASeedLength + t1Packed.length];\n-        System.arraycopy(key.rho, 0, publicKeyBytes, 0, mlDsaASeedLength);\n-        System.arraycopy(t1Packed, 0, publicKeyBytes, mlDsaASeedLength, t1Packed.length);\n+        byte[] publicKeyBytes = new byte[A_SEED_LEN + t1Packed.length];\n+        System.arraycopy(key.rho, 0, publicKeyBytes, 0, A_SEED_LEN);\n+        System.arraycopy(t1Packed, 0, publicKeyBytes, A_SEED_LEN, t1Packed.length);\n@@ -825,2 +838,2 @@\n-        byte[] rho = Arrays.copyOfRange(pk, 0, mlDsaASeedLength);\n-        byte[] v = Arrays.copyOfRange(pk, mlDsaASeedLength, pk.length);\n+        byte[] rho = Arrays.copyOfRange(pk, 0, A_SEED_LEN);\n+        byte[] v = Arrays.copyOfRange(pk, A_SEED_LEN, pk.length);\n@@ -833,1 +846,1 @@\n-        byte[] skBytes = new byte[mlDsaASeedLength + mlDsaKLength + key.tr.length +\n+        byte[] skBytes = new byte[A_SEED_LEN + K_LEN + key.tr.length +\n@@ -837,6 +850,6 @@\n-        System.arraycopy(key.rho, 0, skBytes, pos, mlDsaASeedLength);\n-        pos += mlDsaASeedLength;\n-        System.arraycopy(key.k, 0, skBytes, pos, mlDsaKLength);\n-        pos += mlDsaKLength;\n-        System.arraycopy(key.tr, 0, skBytes, pos, mlDsaTrLength);\n-        pos += mlDsaTrLength;\n+        System.arraycopy(key.rho, 0, skBytes, pos, A_SEED_LEN);\n+        pos += A_SEED_LEN;\n+        System.arraycopy(key.k, 0, skBytes, pos, K_LEN);\n+        pos += K_LEN;\n+        System.arraycopy(key.tr, 0, skBytes, pos, TR_LEN);\n+        pos += TR_LEN;\n@@ -848,1 +861,1 @@\n-        bitPack(key.t0, t0CoeffSize, 1 << 12, skBytes, pos);\n+        bitPack(key.t0, T0_COEFF_SIZE, 1 << 12, skBytes, pos);\n@@ -854,2 +867,2 @@\n-        byte[] rho = new byte[mlDsaASeedLength];\n-        System.arraycopy(sk, 0, rho, 0, mlDsaASeedLength);\n+        byte[] rho = new byte[A_SEED_LEN];\n+        System.arraycopy(sk, 0, rho, 0, A_SEED_LEN);\n@@ -857,2 +870,2 @@\n-        byte[] k = new byte[mlDsaKLength];\n-        System.arraycopy(sk, mlDsaASeedLength, k, 0, mlDsaKLength);\n+        byte[] k = new byte[K_LEN];\n+        System.arraycopy(sk, A_SEED_LEN, k, 0, K_LEN);\n@@ -860,2 +873,2 @@\n-        byte[] tr = new byte[mlDsaTrLength];\n-        System.arraycopy(sk, mlDsaASeedLength + mlDsaKLength, tr, 0, mlDsaTrLength);\n+        byte[] tr = new byte[TR_LEN];\n+        System.arraycopy(sk, A_SEED_LEN + K_LEN, tr, 0, TR_LEN);\n@@ -864,1 +877,1 @@\n-        int start = mlDsaASeedLength + mlDsaKLength + mlDsaTrLength;\n+        int start = A_SEED_LEN + K_LEN + TR_LEN;\n@@ -875,1 +888,1 @@\n-        int[][] t0 = bitUnpack(sk, start, mlDsa_k, 1 << 12, t0CoeffSize);\n+        int[][] t0 = bitUnpack(sk, start, mlDsa_k, 1 << 12, T0_COEFF_SIZE);\n@@ -928,1 +941,1 @@\n-            byteOffset = shake256BlockSize;\n+            byteOffset = SHAKE256_BLOCK_SIZE;\n@@ -930,1 +943,1 @@\n-            block = new byte[shake256BlockSize];\n+            block = new byte[SHAKE256_BLOCK_SIZE];\n@@ -936,1 +949,1 @@\n-            byteOffset = shake256BlockSize;\n+            byteOffset = SHAKE256_BLOCK_SIZE;\n@@ -942,2 +955,2 @@\n-                if (byteOffset == shake256BlockSize) {\n-                    xof.squeeze(block, 0, shake256BlockSize);\n+                if (byteOffset == SHAKE256_BLOCK_SIZE) {\n+                    xof.squeeze(block, 0, SHAKE256_BLOCK_SIZE);\n@@ -967,1 +980,1 @@\n-        int[] c = new int[mlDsa_n];\n+        int[] c = new int[ML_DSA_N];\n@@ -987,3 +1000,3 @@\n-        byte[] xofSeed = new byte[mlDsaASeedLength + 2];\n-        System.arraycopy(seed, 0, xofSeed, 0, mlDsaASeedLength);\n-        int[][][] a = new int[mlDsa_k][mlDsa_l][mlDsa_n];\n+        byte[] xofSeed = new byte[A_SEED_LEN + 2];\n+        System.arraycopy(seed, 0, xofSeed, 0, A_SEED_LEN);\n+        int[][][] a = new int[mlDsa_k][mlDsa_l][ML_DSA_N];\n@@ -993,2 +1006,2 @@\n-                xofSeed[mlDsaASeedLength] = (byte) j;\n-                xofSeed[mlDsaASeedLength + 1] = (byte) i;\n+                xofSeed[A_SEED_LEN] = (byte) j;\n+                xofSeed[A_SEED_LEN + 1] = (byte) i;\n@@ -999,1 +1012,1 @@\n-                int[] aij = new int[mlDsa_n];\n+                int[] aij = new int[ML_DSA_N];\n@@ -1003,1 +1016,1 @@\n-                while (ofs < mlDsa_n) {\n+                while (ofs < ML_DSA_N) {\n@@ -1012,1 +1025,1 @@\n-                    if (tmp < mlDsa_q) {\n+                    if (tmp < ML_DSA_Q) {\n@@ -1024,2 +1037,2 @@\n-        byte[] seed = new byte[mlDsaS1S2SeedLength + 2];\n-        System.arraycopy(rhoPrime, 0, seed, 0, mlDsaS1S2SeedLength);\n+        byte[] seed = new byte[S1S2_SEED_LEN + 2];\n+        System.arraycopy(rhoPrime, 0, seed, 0, S1S2_SEED_LEN);\n@@ -1030,2 +1043,2 @@\n-            seed[mlDsaS1S2SeedLength] = (byte) i;\n-            seed[mlDsaS1S2SeedLength + 1] = 0;\n+            seed[S1S2_SEED_LEN] = (byte) i;\n+            seed[S1S2_SEED_LEN + 1] = 0;\n@@ -1035,1 +1048,1 @@\n-                for (int j = 0; j < mlDsa_n; j++) {\n+                for (int j = 0; j < ML_DSA_N; j++) {\n@@ -1043,1 +1056,1 @@\n-                for (int j = 0; j < mlDsa_n; j++) {\n+                for (int j = 0; j < ML_DSA_N; j++) {\n@@ -1053,2 +1066,2 @@\n-            seed[mlDsaS1S2SeedLength] = (byte) (mlDsa_l + i);\n-            seed[mlDsaS1S2SeedLength + 1] = 0;\n+            seed[S1S2_SEED_LEN] = (byte) (mlDsa_l + i);\n+            seed[S1S2_SEED_LEN + 1] = 0;\n@@ -1058,1 +1071,1 @@\n-                for (int j = 0; j < mlDsa_n; j++) {\n+                for (int j = 0; j < ML_DSA_N; j++) {\n@@ -1066,1 +1079,1 @@\n-                for (int j = 0; j < mlDsa_n; j++) {\n+                for (int j = 0; j < ML_DSA_N; j++) {\n@@ -1080,1 +1093,1 @@\n-        int[][] res = new int[mlDsa_l][mlDsa_n];\n+        int[][] res = new int[mlDsa_l][ML_DSA_N];\n@@ -1103,1 +1116,1 @@\n-            for (int m = 0; m < mlDsa_n; m++) {\n+            for (int m = 0; m < ML_DSA_N; m++) {\n@@ -1105,3 +1118,3 @@\n-                int r0 = input[i][m] & dMask;\n-                int r00 = (1 << (mlDsa_d - 1)) - r0 ; \/\/ 2^d\/2 - r+\n-                r0 -= (r00 >> 31) & (1 << mlDsa_d); \/\/0 if r+ < 2^d\/2\n+                int r0 = input[i][m] & D_MASK;\n+                int r00 = (1 << (ML_DSA_D - 1)) - r0 ; \/\/ 2^d\/2 - r+\n+                r0 -= (r00 >> 31) & (1 << ML_DSA_D); \/\/0 if r+ < 2^d\/2\n@@ -1109,1 +1122,1 @@\n-                highPart[i][m] = (rplus - r0) >> mlDsa_d;\n+                highPart[i][m] = (rplus - r0) >> ML_DSA_D;\n@@ -1116,2 +1129,2 @@\n-            for (int m = 0; m < mlDsa_n; m++) {\n-                int rplus = (input[i][m] + mlDsa_q) % mlDsa_q;\n+            for (int m = 0; m < ML_DSA_N; m++) {\n+                int rplus = (input[i][m] + ML_DSA_Q) % ML_DSA_Q;\n@@ -1121,1 +1134,1 @@\n-                if (rplus - r0 == mlDsa_q - 1) {\n+                if (rplus - r0 == ML_DSA_Q - 1) {\n@@ -1134,1 +1147,1 @@\n-        int rplus = (input + mlDsa_q) % mlDsa_q;\n+        int rplus = (input + ML_DSA_Q) % ML_DSA_Q;\n@@ -1138,1 +1151,1 @@\n-        if (rplus - r0 == mlDsa_q - 1) {\n+        if (rplus - r0 == ML_DSA_Q - 1) {\n@@ -1149,1 +1162,1 @@\n-        boolean[][] res = new boolean[mlDsa_k][mlDsa_n];\n+        boolean[][] res = new boolean[mlDsa_k][ML_DSA_N];\n@@ -1151,1 +1164,1 @@\n-            for (int j = 0; j < mlDsa_n; j++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n@@ -1161,3 +1174,3 @@\n-        int m = (mlDsa_q - 1) \/ (2*gamma2);\n-        int[][] lowPart = new int[mlDsa_k][mlDsa_n];\n-        int[][] highPart = new int[mlDsa_k][mlDsa_n];\n+        int m = (ML_DSA_Q - 1) \/ (2*gamma2);\n+        int[][] lowPart = new int[mlDsa_k][ML_DSA_N];\n+        int[][] highPart = new int[mlDsa_k][ML_DSA_N];\n@@ -1167,1 +1180,1 @@\n-            for (int j = 0; j < mlDsa_n; j++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n@@ -1182,1 +1195,1 @@\n-        int result = implMlDsaAlmostNtt(coeffs, montZetasForVectorNtt);\n+        int result = implMlDsaAlmostNtt(coeffs, MONT_ZETAS_FOR_VECTOR_NTT);\n@@ -1184,1 +1197,1 @@\n-        result = implMlDsaMontMulByConstant(coeffs,  montRModQ);\n+        result = implMlDsaMontMulByConstant(coeffs,  MONT_R_MOD_Q);\n@@ -1194,1 +1207,1 @@\n-        int dimension = mlDsa_n;\n+        int dimension = ML_DSA_N;\n@@ -1199,1 +1212,1 @@\n-                    int tmp = montMul(montZetasForNtt[m], coeffs[j + l]);\n+                    int tmp = montMul(MONT_ZETAS_FOR_NTT[m], coeffs[j + l]);\n@@ -1211,2 +1224,2 @@\n-        int result = implMlDsaAlmostInverseNtt(coeffs, montZetasForVectorInverseNtt);\n-        result = implMlDsaMontMulByConstant(coeffs, montDimInverse);\n+        int result = implMlDsaAlmostInverseNtt(coeffs, MONT_ZETAS_FOR_VECTOR_INVERSE_NTT);\n+        result = implMlDsaMontMulByConstant(coeffs, MONT_DIM_INVERSE);\n@@ -1222,1 +1235,1 @@\n-        int dimension = mlDsa_n;\n+        int dimension = ML_DSA_N;\n@@ -1229,1 +1242,1 @@\n-                    coeffs[j + l] = montMul(tmp - coeffs[j + l], montZetasForInverseNtt[m]);\n+                    coeffs[j + l] = montMul(tmp - coeffs[j + l], MONT_ZETAS_FOR_INVERSE_NTT[m]);\n@@ -1251,1 +1264,1 @@\n-        int[] product = new int[mlDsa_n];\n+        int[] product = new int[ML_DSA_N];\n@@ -1262,1 +1275,1 @@\n-        for (int i = 0; i < mlDsa_n; i++) {\n+        for (int i = 0; i < ML_DSA_N; i++) {\n@@ -1279,1 +1292,1 @@\n-        for (int i = 0; i < mlDsa_n; i++) {\n+        for (int i = 0; i < ML_DSA_N; i++) {\n@@ -1299,1 +1312,1 @@\n-        for (int m = 0; m < mlDsa_n; m++) {\n+        for (int m = 0; m < ML_DSA_N; m++) {\n@@ -1301,2 +1314,2 @@\n-            rplus = rplus - ((rplus + 5373807) >> 23) * mlDsa_q;\n-            rplus = rplus + ((rplus >> 31) & mlDsa_q);\n+            rplus = rplus - ((rplus + 5373807) >> 23) * ML_DSA_Q;\n+            rplus = rplus + ((rplus >> 31) & ML_DSA_Q);\n@@ -1306,1 +1319,1 @@\n-            int r1 = rplus - r0 - (mlDsa_q - 1);\n+            int r1 = rplus - r0 - (ML_DSA_Q - 1);\n@@ -1317,2 +1330,2 @@\n-        int[][] result = new int[mlDsa_k][mlDsa_n];\n-        int resulti[] = new int[mlDsa_n];\n+        int[][] result = new int[mlDsa_k][ML_DSA_N];\n+        int resulti[] = new int[ML_DSA_N];\n@@ -1320,1 +1333,1 @@\n-            for (int m = 0; m < mlDsa_n; m++) {\n+            for (int m = 0; m < ML_DSA_N; m++) {\n@@ -1325,1 +1338,1 @@\n-                for (int m = 0; m < mlDsa_n; m++) {\n+                for (int m = 0; m < ML_DSA_N; m++) {\n@@ -1329,2 +1342,2 @@\n-            for (int m = 0; m < mlDsa_n; m++) {\n-                result[i][m] = montMul(resulti[m], montRModQ);\n+            for (int m = 0; m < ML_DSA_N; m++) {\n+                result[i][m] = montMul(resulti[m], MONT_R_MOD_Q);\n@@ -1337,1 +1350,1 @@\n-        int[][] res = new int[b.length][mlDsa_n];\n+        int[][] res = new int[b.length][ML_DSA_N];\n@@ -1348,1 +1361,1 @@\n-                res[i][j] = (c * vec[i][j]) % mlDsa_q;\n+                res[i][j] = (c * vec[i][j]) % ML_DSA_Q;\n@@ -1355,2 +1368,2 @@\n-    \/\/ The coefficients in the input should be between -montQ and montQ .\n-    \/\/ The coefficients in the output will be nonnegative and less than montQ\n+    \/\/ The coefficients in the input should be between -MONT_Q and MONT_Q .\n+    \/\/ The coefficients in the output will be nonnegative and less than MONT_Q\n@@ -1359,1 +1372,1 @@\n-        int[][] result = new int[dim][mlDsa_n];\n+        int[][] result = new int[dim][ML_DSA_N];\n@@ -1361,4 +1374,4 @@\n-            for (int m = 0; m < mlDsa_n; m++) {\n-                int r = vec1[i][m] + vec2[i][m]; \/\/ -2 * montQ < r < 2 * montQ\n-                r += (((r >> 31) & (2 * montQ)) - montQ); \/\/ -montQ < r < montQ\n-                r += ((r >> 31) & montQ); \/\/ 0 <= r < montQ\n+            for (int m = 0; m < ML_DSA_N; m++) {\n+                int r = vec1[i][m] + vec2[i][m]; \/\/ -2 * MONT_Q < r < 2 * MONT_Q\n+                r += (((r >> 31) & (2 * MONT_Q)) - MONT_Q); \/\/ -MONT_Q < r < MONT_Q\n+                r += ((r >> 31) & MONT_Q); \/\/ 0 <= r < MONT_Q\n@@ -1373,1 +1386,1 @@\n-        int[][] result = new int[dim][mlDsa_n];\n+        int[][] result = new int[dim][ML_DSA_N];\n@@ -1375,1 +1388,1 @@\n-            for (int j = 0; j < mlDsa_n; j++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n@@ -1377,1 +1390,1 @@\n-                tmp -= tmp >= mlDsa_q ? mlDsa_q : 0;\n+                tmp -= tmp >= ML_DSA_Q ? ML_DSA_Q : 0;\n@@ -1386,1 +1399,1 @@\n-        int[][] result = new int[dim][mlDsa_n];\n+        int[][] result = new int[dim][ML_DSA_N];\n@@ -1388,1 +1401,1 @@\n-            for (int j = 0; j < mlDsa_n; j++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n@@ -1390,1 +1403,1 @@\n-                tmp += tmp < 0 ? mlDsa_q : 0;\n+                tmp += tmp < 0 ? ML_DSA_Q : 0;\n@@ -1402,1 +1415,1 @@\n-            for (int j = 0; j < mlDsa_n; j++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n@@ -1404,1 +1417,1 @@\n-                r1 = r1 - ((r1 + (5  << 20)) >> 23) * mlDsa_q;\n+                r1 = r1 - ((r1 + (5  << 20)) >> 23) * ML_DSA_Q;\n@@ -1415,1 +1428,1 @@\n-            for (int j = 0; j < mlDsa_n; j++) {\n+            for (int j = 0; j < ML_DSA_N; j++) {\n@@ -1422,3 +1435,3 @@\n-    \/\/ precondition: -2^31 * montQ <= a, b < 2^31, -2^31 < a * b < 2^31 * montQ\n-    \/\/ computes a * b * 2^-32 mod montQ\n-    \/\/ the result is greater than -montQ and less than montQ\n+    \/\/ precondition: -2^31 * MONT_Q <= a, b < 2^31, -2^31 < a * b < 2^31 * MONT_Q\n+    \/\/ computes a * b * 2^-32 mod MONT_Q\n+    \/\/ the result is greater than -MONT_Q and less than MONT_Q\n@@ -1427,1 +1440,1 @@\n-        int aHigh = (int) (a >> montRBits);\n+        int aHigh = (int) (a >> MONT_R_BITS);\n@@ -1429,1 +1442,1 @@\n-        int m = montQInvModR * aLow; \/\/ signed low product\n+        int m = MONT_Q_INV_MOD_R * aLow; \/\/ signed low product\n@@ -1431,1 +1444,1 @@\n-        return (aHigh - (int) (((long)m * montQ) >> montRBits));  \/\/ subtract signed high product\n+        return (aHigh - (int) (((long)m * MONT_Q) >> MONT_R_BITS));  \/\/ subtract signed high product\n@@ -1435,1 +1448,1 @@\n-        return montMul(a, montRSquareModQ);\n+        return montMul(a, MONT_R_SQUARE_MOD_Q);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":178,"deletions":165,"binary":false,"changes":343,"status":"modified"}]}