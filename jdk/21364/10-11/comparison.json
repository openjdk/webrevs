{"files":[{"patch":"@@ -551,1 +551,2 @@\n-        int[][] As1 = matrixVectorPointwiseMultiply(keygenA, s1);\n+        int[][] As1 = new int[mlDsa_k][ML_DSA_N];\n+        matrixVectorPointwiseMultiply(As1, keygenA, s1);\n@@ -598,0 +599,5 @@\n+        int[][] y = new int[mlDsa_l][ML_DSA_N];\n+        int[][] w = new int[mlDsa_k][ML_DSA_N];\n+        int[][] w0 = new int[mlDsa_k][ML_DSA_N];\n+        int[][] w1 = new int[mlDsa_k][ML_DSA_N];\n+        int[] c =  new int[ML_DSA_N];\n@@ -601,1 +607,1 @@\n-            int[][] y = expandMask(rhoDoublePrime, kappa);\n+            expandMask(y, rhoDoublePrime, kappa);\n@@ -605,1 +611,1 @@\n-            int[][] w = matrixVectorPointwiseMultiply(aHat, y);\n+            matrixVectorPointwiseMultiply(w, aHat, y);\n@@ -607,2 +613,0 @@\n-            int[][] w0 = new int[mlDsa_k][ML_DSA_N];\n-            int[][] w1 = new int[mlDsa_k][ML_DSA_N];\n@@ -619,1 +623,1 @@\n-            int[] c = sampleInBall(commitmentHash);\n+            sampleInBall(c, commitmentHash);\n@@ -671,1 +675,2 @@\n-        int[] cHat = sampleInBall(sig.commitmentHash());\n+        int[] cHat = new int[ML_DSA_N];\n+        sampleInBall(cHat, sig.commitmentHash());\n@@ -679,1 +684,2 @@\n-        int[][] aHatZ = matrixVectorPointwiseMultiply(aHat, sig.response());\n+        int[][] aHatZ = new int[mlDsa_k][ML_DSA_N];\n+        matrixVectorPointwiseMultiply(aHatZ, aHat, sig.response());\n@@ -756,2 +762,13 @@\n-    public int[][] bitUnpack(byte[] v, int offset, int dim, int maxValue, int bitsPerCoeff) {\n-        int[][] res = new int[dim][ML_DSA_N];\n+    public int[][] bitUnpack(int[][] result, byte[] v, int offset, int dim, int maxValue, int bitsPerCoeff) {\n+        switch (bitsPerCoeff) {\n+            case 3 -> { bitUnpackGeneral(result, v, offset, dim, maxValue, 3); }\n+            case 4 -> { bitUnpackGeneral(result, v, offset, dim, maxValue, 4); }\n+            case 13 -> { bitUnpackGeneral(result, v, offset, dim,  maxValue, 13); }\n+            case 18 -> { bitUnpack18(result, v, offset, dim, maxValue); }\n+            case 20 -> { bitUnpack20(result, v, offset, dim, maxValue); }\n+            default -> throw new RuntimeException(\"Wrong bitspercoeffb value in bitUnpack (\" + bitsPerCoeff + \").\");\n+        }\n+        return result;\n+    }\n+    public void bitUnpackGeneral(int[][] result,\n+            byte[] v, int offset, int dim, int maxValue, int bitsPerCoeff) {\n@@ -769,1 +786,1 @@\n-                res[i][j] = maxValue - ((acc >> shift) & mask);\n+                result[i][j] = maxValue - ((acc >> shift) & mask);\n@@ -778,1 +795,37 @@\n-        return res;\n+    }\n+    public void bitUnpack18(int [][] result, byte[] v, int offset, int dim, int maxValue) {\n+\n+        int vIndex = offset;\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < ML_DSA_N; j += 4) {\n+                result[i][j] = maxValue - ((v[vIndex] & 0xff) +\n+                        ((v[vIndex + 1] & 0xff) << 8) +\n+                        ((v[vIndex + 2] & 0x3) << 16));\n+                result[i][j + 1] = maxValue - (((v[vIndex + 2] >> 2) & 0x3f) +\n+                        ((v[vIndex + 3] & 0xff) << 6) +\n+                        ((v[vIndex + 4] & 0xf) << 14));\n+                result[i][j + 2] = maxValue - (((v[vIndex + 4] >> 4) & 0xf) +\n+                        ((v[vIndex + 5] & 0xff) << 4) +\n+                        ((v[vIndex + 6] & 0x3f) << 12));\n+                result[i][j + 3] = maxValue - (((v[vIndex + 6] >> 6) & 0x3) +\n+                        ((v[vIndex + 7] & 0xff) << 2) +\n+                        ((v[vIndex + 8] & 0xff) << 10));\n+                vIndex += 9;\n+            }\n+        }\n+    }\n+\n+    public void bitUnpack20(int[][] result, byte[] v, int offset, int dim, int maxValue) {\n+        int vIndex = offset;\n+\n+        for (int i = 0; i < dim; i++) {\n+            for (int j = 0; j < ML_DSA_N; j += 2) {\n+                result[i][j] = maxValue - ((v[vIndex] & 0xff) +\n+                        ((v[vIndex + 1] & 0xff) << 8) +\n+                        ((v[vIndex + 2] & 0xf) << 16));\n+                result[i][j + 1] = maxValue - (((v[vIndex + 2] >> 4) & 0xf) +\n+                        ((v[vIndex + 3] & 0xff) << 4) +\n+                        ((v[vIndex + 4] & 0xff) << 12));\n+                vIndex += 5;\n+            }\n+        }\n@@ -879,1 +932,2 @@\n-        int[][] s1 = bitUnpack(sk, start, mlDsa_l, eta, s1s2CoeffSize);\n+        int[][] s1 = new int[mlDsa_l][ML_DSA_N];\n+        bitUnpack(s1, sk, start, mlDsa_l, eta, s1s2CoeffSize);\n@@ -884,1 +938,2 @@\n-        int[][] s2 = bitUnpack(sk, start, mlDsa_k, eta, s1s2CoeffSize);\n+        int[][] s2 = new int[mlDsa_k][ML_DSA_N];\n+        bitUnpack(s2, sk, start, mlDsa_k, eta, s1s2CoeffSize);\n@@ -888,1 +943,2 @@\n-        int[][] t0 = bitUnpack(sk, start, mlDsa_k, 1 << 12, T0_COEFF_SIZE);\n+        int[][] t0 = new int[mlDsa_k][ML_DSA_N];\n+        bitUnpack(t0, sk, start, mlDsa_k, 1 << 12, T0_COEFF_SIZE);\n@@ -913,1 +969,2 @@\n-        int[][] z = bitUnpack(sig, start, mlDsa_l, gamma1, gamma1Bits + 1);\n+        int[][] z = new int[mlDsa_l][ML_DSA_N];\n+        bitUnpack(z, sig, start, mlDsa_l, gamma1, gamma1Bits + 1);\n@@ -969,1 +1026,1 @@\n-    private int[] sampleInBall(byte[] rho) {\n+    private void sampleInBall(int[] c, byte[] rho) {\n@@ -980,1 +1037,2 @@\n-        int[] c = new int[ML_DSA_N];\n+        Arrays.fill(c, 0);\n+\n@@ -994,1 +1052,0 @@\n-        return c;\n@@ -1040,2 +1097,1 @@\n-        int bitsPerCall = 4;\n-        Shake256Slicer slicer = new Shake256Slicer(xof, bitsPerCall);\n+        Shake256Slicer slicer = new Shake256Slicer(xof, 4);\n@@ -1090,1 +1146,1 @@\n-    private int[][] expandMask(byte[] rho, int mu) {\n+    private void expandMask(int[][] result, byte[] rho, int mu) {\n@@ -1093,1 +1149,0 @@\n-        int[][] res = new int[mlDsa_l][ML_DSA_N];\n@@ -1102,3 +1157,1 @@\n-            for (int i = 0; i < 32*c; i++) {\n-                v[r*32*c + i] = xof.squeeze(1)[0];\n-            }\n+            xof.squeeze(v, r * 32 * c, 32 * c);\n@@ -1107,1 +1160,1 @@\n-        return bitUnpack(v, 0, mlDsa_l, gamma1, c);\n+        bitUnpack(result, v, 0, mlDsa_l, gamma1, c);\n@@ -1128,0 +1181,1 @@\n+        int multiplier = (gamma2 == 95232 ? 22 : 8);\n@@ -1129,14 +1183,1 @@\n-            for (int m = 0; m < ML_DSA_N; m++) {\n-                int rplus = (input[i][m] + ML_DSA_Q) % ML_DSA_Q;\n-                int r0 = rplus % (2*gamma2);\n-                r0 -= r0 > gamma2 ? 2*gamma2 : 0;\n-                int r1;\n-                if (rplus - r0 == ML_DSA_Q - 1) {\n-                    r1 = 0;\n-                    r0 = r0 - 1;\n-                } else {\n-                    r1 = (rplus - r0) \/ (2*gamma2);\n-                }\n-                lowPart[i][m] = r0;\n-                highPart[i][m] = r1;\n-            }\n+            ML_DSA.mlDsaDecomposePoly(input[i], lowPart[i], highPart[i], gamma2 * 2, multiplier);\n@@ -1146,12 +1187,5 @@\n-    private int highBits(int input) {\n-        int rplus = (input + ML_DSA_Q) % ML_DSA_Q;\n-        int r0 = rplus % (2*gamma2);\n-        r0 -= r0 > gamma2 ? 2*gamma2 : 0;\n-        int r1;\n-        if (rplus - r0 == ML_DSA_Q - 1) {\n-            r1 = 0;\n-            r0 = r0 - 1;\n-        } else {\n-            r1 = (rplus - r0) \/ (2*gamma2);\n-        }\n-        return r1;\n+    private int[][] highBits(int[][] input) {\n+        int[][] lowPart = new int[mlDsa_k][ML_DSA_N];\n+        int[][] highPart = new int[mlDsa_k][ML_DSA_N];\n+        decompose(input, lowPart, highPart);\n+        return highPart;\n@@ -1161,1 +1195,2 @@\n-        int[][] v1 = vectorAdd(r, z);\n+        int[][] r1 = highBits(r);\n+        int[][] v1 = highBits(vectorAdd(r,z));\n@@ -1165,3 +1200,1 @@\n-                int r1High = highBits(r[i][j]);\n-                int v1High = highBits(v1[i][j]);\n-                res[i][j] = r1High != v1High;\n+                res[i][j] = (r1[i][j] != v1[i][j]);\n@@ -1329,2 +1362,1 @@\n-    private int[][] matrixVectorPointwiseMultiply(int[][][] matrix, int[][] vector) {\n-        int[][] result = new int[mlDsa_k][ML_DSA_N];\n+    private void matrixVectorPointwiseMultiply(int[][] res, int[][][] matrix, int[][] vector) {\n@@ -1343,1 +1375,1 @@\n-                result[i][m] = montMul(resulti[m], MONT_R_MOD_Q);\n+                res[i][m] = montMul(resulti[m], MONT_R_MOD_Q);\n@@ -1346,1 +1378,0 @@\n-        return result;\n@@ -1361,1 +1392,1 @@\n-                res[i][j] = (c * vec[i][j]) % ML_DSA_Q;\n+                res[i][j] = montMul(c, toMont(vec[i][j]));\n@@ -1364,1 +1395,1 @@\n-        return res;\n+        return res; \/\/ -q < res[i][j] < q\n@@ -1399,1 +1430,0 @@\n-        int[][] result = new int[dim][ML_DSA_N];\n@@ -1404,1 +1434,1 @@\n-                result[i][j] = tmp;\n+                vec1[i][j] = tmp;\n@@ -1407,1 +1437,1 @@\n-        return result;\n+        return vec1;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA.java","additions":96,"deletions":66,"binary":false,"changes":162,"status":"modified"}]}