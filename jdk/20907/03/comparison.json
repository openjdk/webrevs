{"files":[{"patch":"@@ -1529,0 +1529,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libagent8339725 += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3135,1 +3135,3 @@\n-\n+  \/\/ As for the GetFieldDeclaringClass method, the XSL generated C++ code that calls it has\n+  \/\/ a jclass of the relevant class or a subclass of it, which is fine in terms of ensuring\n+  \/\/ the holder is kept alive.\n@@ -3213,1 +3215,4 @@\n-  (*declaring_class_ptr) = get_jni_class_non_null(method->method_holder());\n+  Klass* k = method->method_holder();\n+  Handle holder(Thread::current(), k->klass_holder()); \/\/ keep the klass alive\n+  \/\/ Cannot check klass_holder == nullptr because klass could have null loader holder\n+  (*declaring_class_ptr) = k->is_loader_alive() ? get_jni_class_non_null(k) : nullptr;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -602,0 +602,1 @@\n+  assert(k->is_loader_alive(), \"Must be alive\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8339725\n+ * @summary Stress test GetMethodDeclaringClass\n+ * @requires vm.jvmti\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @library \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm\/native -agentlib:agent8339725 Test8339725\n+ *\/\n+\n+import java.util.Base64;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import java.io.File;\n+\n+public class Test8339725 {\n+    public static void main(String[] args) throws Exception {\n+        test(\"-XX:+UseG1GC\");\n+        test(\"-XX:+UseZGC\");\n+    }\n+\n+    public static void test(String gcArg) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-agentpath:\" + Utils.TEST_NATIVE_PATH + File.separator + System.mapLibraryName(\"agent8339725\"), \"-Xmx100m\", gcArg, \"Test\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getOutput());\n+        output.shouldContain(\"OutOfMemoryError\");\n+    }\n+}\n+\n+class Test {\n+    public static void main(String[] args) throws Exception {\n+        long last = System.nanoTime();\n+        for (int i = 0;; i++) {\n+            CustomClassLoader loader = new CustomClassLoader();\n+            Class<?> k = loader.findClass(\"TemplateFFFFFFFF\");\n+            Object o = k.getDeclaredConstructor().newInstance();\n+\n+            \/\/ call gc every ~1 second.\n+            if ((System.nanoTime() - last) >= 1e9) {\n+                System.gc();\n+                last = System.nanoTime();\n+            }\n+        }\n+    }\n+}\n+\n+class CustomClassLoader extends ClassLoader {\n+    @Override\n+    public Class findClass(String name) throws ClassNotFoundException {\n+        byte[] b = Base64.getDecoder()\n+                .decode(\"yv66vgAAADQADgoAAwALBwAMBwANAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJU\" +\n+                        \"YWJsZQEAEmRvVGVtcGxhdGVGRkZGRkZGRgEAClNvdXJjZUZpbGUBABVUZW1wbGF0ZUZGRkZGRkZG\" +\n+                        \"LmphdmEMAAQABQEAEFRlbXBsYXRlRkZGRkZGRkYBABBqYXZhL2xhbmcvT2JqZWN0ACEAAgADAAAA\" +\n+                        \"AAACAAEABAAFAAEABgAAAB0AAQABAAAABSq3AAGxAAAAAQAHAAAABgABAAAAAQABAAgABQABAAYA\" +\n+                        \"AAAZAAAAAQAAAAGxAAAAAQAHAAAABgABAAAAAwABAAkAAAACAAo=\");\n+        return defineClass(name, b, 0, b.length);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/8339725\/Test8339725.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include <jni.h>\n+#include <pthread.h>\n+\n+static jvmtiEnv *jvmti;\n+static JavaVM *_jvm;\n+static JNIEnv *_rb_env;\n+\n+#define BUFFER_SIZE 100000\n+static size_t ring_buffer[BUFFER_SIZE] = {0};\n+static volatile int ring_buffer_idx = 0;\n+static int reader_created = 0;\n+\n+void *get_method_details(void *arg)\n+{\n+    jmethodID method = (jmethodID)arg;\n+\n+    jclass method_class;\n+    char *class_name = NULL;\n+\n+    jvmtiError err = JVMTI_ERROR_NONE;\n+\n+    \/\/ For JVM 17, 21, 22 calling GetMethodDeclaringClass is enough.\n+    if ((err = jvmti->GetMethodDeclaringClass(method, &method_class)) == 0)\n+    {\n+        \/\/ JVM 8 needs this to crash\n+        jvmti->GetClassSignature(method_class, &class_name, NULL);\n+        jvmti->Deallocate((unsigned char *)class_name);\n+    }\n+    return NULL;\n+}\n+\n+void *read_ringbuffer(void *arg)\n+{\n+    JNIEnv *env;\n+    _jvm->AttachCurrentThread((void **)&env, NULL);\n+    _rb_env = env;\n+\n+    for (;;)\n+    {\n+        size_t id = ring_buffer[rand() % BUFFER_SIZE];\n+        if (id > 0)\n+        {\n+            get_method_details((void *)id);\n+        }\n+    }\n+    return NULL;\n+}\n+\n+static void JNICALL ClassPrepareCallback(jvmtiEnv *jvmti_env,\n+                                         JNIEnv *jni_env,\n+                                         jthread thread,\n+                                         jclass klass)\n+{\n+    if (reader_created == 0)\n+    {\n+        pthread_t tid;\n+        pthread_create(&tid, NULL, read_ringbuffer, NULL);\n+\n+        reader_created = 1;\n+    }\n+\n+    \/\/ Get the list of methods\n+    jint method_count;\n+    jmethodID *methods;\n+    if (jvmti_env->GetClassMethods(klass, &method_count, &methods) == JVMTI_ERROR_NONE)\n+    {\n+        for (int i = 0; i < method_count; i++)\n+        {\n+            ring_buffer[ring_buffer_idx++] = (size_t)methods[i];\n+            ring_buffer_idx = ring_buffer_idx % BUFFER_SIZE;\n+        }\n+        jvmti_env->Deallocate((unsigned char *)methods);\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved)\n+{\n+    jvmtiEventCallbacks callbacks;\n+    jvmtiError error;\n+\n+    _jvm = jvm;\n+\n+    if (jvm->GetEnv((void **)&jvmti, JVMTI_VERSION_1_0) != JNI_OK)\n+    {\n+        fprintf(stderr, \"Unable to access JVMTI!\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    \/\/ Set up the event callbacks\n+    memset(&callbacks, 0, sizeof(callbacks));\n+    callbacks.ClassPrepare = &ClassPrepareCallback;\n+\n+    \/\/ Register the callbacks\n+    error = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (error != JVMTI_ERROR_NONE)\n+    {\n+        fprintf(stderr, \"Error setting event callbacks: %d\\n\", error);\n+        return JNI_ERR;\n+    }\n+\n+    \/\/ Enable the ClassPrepare event\n+    error = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+    if (error != JVMTI_ERROR_NONE)\n+    {\n+        fprintf(stderr, \"Error enabling ClassPrepare event: %d\\n\", error);\n+        return JNI_ERR;\n+    }\n+\n+    return JNI_OK;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/8339725\/libagent8339725.cpp","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}