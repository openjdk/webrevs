{"files":[{"patch":"@@ -888,1 +888,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libMonitorWithDeadObjectTest.c libTestPsig.c exeGetCreatedJavaVMs.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libMonitorWithDeadObjectTest.c libTestPsig.c exeGetCreatedJavaVMs.c libTestUnloadedClass.cpp\n@@ -1529,0 +1529,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libTestUnloadedClass += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3135,1 +3135,3 @@\n-\n+  \/\/ As for the GetFieldDeclaringClass method, the XSL generated C++ code that calls it has\n+  \/\/ a jclass of the relevant class or a subclass of it, which is fine in terms of ensuring\n+  \/\/ the holder is kept alive.\n@@ -3213,1 +3215,3 @@\n-  (*declaring_class_ptr) = get_jni_class_non_null(method->method_holder());\n+  Klass* k = method->method_holder();\n+  Handle holder(Thread::current(), k->klass_holder()); \/\/ keep the klass alive\n+  (*declaring_class_ptr) = get_jni_class_non_null(k);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -602,0 +602,1 @@\n+  assert(k->is_loader_alive(), \"Must be alive\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8339725\n+ * @summary Stress test GetMethodDeclaringClass\n+ * @requires vm.jvmti\n+ * @requires (os.family == \"linux\") & (vm.debug != true)\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=300 TestUnloadedClass\n+ *\/\n+\n+import java.util.Base64;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+\n+public class TestUnloadedClass {\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                \"-agentpath:\" + Utils.TEST_NATIVE_PATH + File.separator + System.mapLibraryName(\"TestUnloadedClass\"),\n+                \"-Xmx50m\",\n+                \"Test\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldContain(\"OutOfMemoryError\");\n+    }\n+}\n+\n+class Test {\n+    public static void main(String[] args) throws Exception {\n+        long last = System.nanoTime();\n+        for (;;) {\n+            CustomClassLoader loader = new CustomClassLoader();\n+            Class<?> k = loader.findClass(\"MyClass\");\n+            Constructor<?> c = k.getDeclaredConstructor();\n+            c.setAccessible(true);\n+            c.newInstance();\n+\n+            \/\/ call gc every ~1 second.\n+            if ((System.nanoTime() - last) >= 1e9) {\n+                System.gc();\n+                last = System.nanoTime();\n+            }\n+        }\n+    }\n+}\n+\n+class CustomClassLoader extends ClassLoader {\n+    static byte[] BYTES;\n+\n+    static {\n+        try (InputStream in = CustomClassLoader.class.getResourceAsStream(\"MyClass.class\")) {\n+            try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n+                byte[] buf = new byte[4096];\n+                int len;\n+                while ((len = in.read(buf)) != -1) {\n+                    baos.write(buf, 0, len);\n+                }\n+                BYTES = baos.toByteArray();\n+            }\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    @Override\n+    public Class findClass(String name) throws ClassNotFoundException {\n+        return defineClass(name, BYTES, 0, BYTES.length);\n+    }\n+}\n+\n+class MyClass {\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetMethodDeclaringClass\/TestUnloadedClass.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <atomic>\n+\n+#include <jvmti.h>\n+#include <jni.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+static jvmtiEnv *_jvmti;\n+static JavaVM *_jvm;\n+\n+#define BUFFER_SIZE 100000\n+static std::atomic<jmethodID> ring_buffer[BUFFER_SIZE];\n+\n+void get_method_details(jmethodID method) {\n+  jclass method_class;\n+  char *class_name = NULL;\n+  if (_jvmti->GetMethodDeclaringClass(method, &method_class) == JVMTI_ERROR_NONE) {\n+    if (_jvmti->GetClassSignature(method_class, &class_name, NULL) == JVMTI_ERROR_NONE) {\n+      _jvmti->Deallocate((unsigned char *)class_name);\n+    }\n+  }\n+}\n+\n+void* read_ringbuffer(void* arg) {\n+  JNIEnv *env;\n+  _jvm->AttachCurrentThreadAsDaemon((void **)&env, NULL);\n+  for (;;) {\n+    jmethodID id = ring_buffer[rand() % BUFFER_SIZE].load(std::memory_order_relaxed);\n+    if (id != (jmethodID)0) {\n+      get_method_details(id);\n+    }\n+  }\n+  return NULL;\n+}\n+\n+static void JNICALL ClassPrepareCallback(jvmtiEnv *jvmti_env,\n+                                         JNIEnv *jni_env,\n+                                         jthread thread,\n+                                         jclass klass) {\n+  static bool reader_created = false;\n+  static int ring_buffer_idx = 0;\n+\n+  char *class_name = NULL;\n+  if (jvmti_env->GetClassSignature(klass, &class_name, NULL) != JVMTI_ERROR_NONE) {\n+    return;\n+  }\n+  \/\/ We only care MyClass and only one thread loads it\n+  bool is_my_class = strcmp(class_name, \"LMyClass;\") == 0;\n+  jvmti_env->Deallocate((unsigned char *)class_name);\n+  if (!is_my_class) {\n+    return;\n+  }\n+\n+  if (!reader_created) {\n+    pthread_t tid;\n+    pthread_create(&tid, NULL, read_ringbuffer, NULL);\n+    reader_created = true;\n+  }\n+\n+  jint method_count;\n+  jmethodID *methods;\n+  if (jvmti_env->GetClassMethods(klass, &method_count, &methods) == JVMTI_ERROR_NONE) {\n+    ring_buffer[ring_buffer_idx++].store(methods[0], std::memory_order_relaxed);\n+    ring_buffer_idx = ring_buffer_idx % BUFFER_SIZE;\n+    jvmti_env->Deallocate((unsigned char *)methods);\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  for (int i = 0; i < BUFFER_SIZE; i++) {\n+    ring_buffer[i].store(0, std::memory_order_relaxed);\n+  }\n+\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError error;\n+\n+  _jvm = jvm;\n+\n+  if (jvm->GetEnv((void **)&_jvmti, JVMTI_VERSION_1_0) != JNI_OK) {\n+    fprintf(stderr, \"Unable to access JVMTI!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ Set up the event callbacks\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.ClassPrepare = &ClassPrepareCallback;\n+\n+  \/\/ Register the callbacks\n+  error = _jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (error != JVMTI_ERROR_NONE) {\n+    fprintf(stderr, \"Error setting event callbacks: %d\\n\", error);\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ Enable the ClassPrepare event\n+  error = _jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, NULL);\n+  if (error != JVMTI_ERROR_NONE) {\n+    fprintf(stderr, \"Error enabling ClassPrepare event: %d\\n\", error);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetMethodDeclaringClass\/libTestUnloadedClass.cpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}