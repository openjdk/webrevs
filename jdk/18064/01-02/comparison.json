{"files":[{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"c1\/c1_LIRGenerator.hpp\"\n+#include \"c1\/c1_CodeStubs.hpp\"\n+#include \"gc\/g1\/c1\/g1BarrierSetC1.hpp\"\n+#include \"gc\/g1\/g1BarrierSet.hpp\"\n+#include \"gc\/g1\/g1BarrierSetAssembler.hpp\"\n+#include \"gc\/g1\/g1ThreadLocalData.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#ifdef ASSERT\n+#define __ gen->lir(__FILE__, __LINE__)->\n+#else\n+#define __ gen->lir()->\n+#endif\n+\n+void G1PreBarrierStub::emit_code(LIR_Assembler* ce) {\n+  G1BarrierSetAssembler* bs = (G1BarrierSetAssembler*)BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->gen_pre_barrier_stub(ce, this);\n+}\n+\n+void G1PostBarrierStub::emit_code(LIR_Assembler* ce) {\n+  G1BarrierSetAssembler* bs = (G1BarrierSetAssembler*)BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->gen_post_barrier_stub(ce, this);\n+}\n+\n+void G1BarrierSetC1::pre_barrier(LIRAccess& access, LIR_Opr addr_opr,\n+                                 LIR_Opr pre_val, CodeEmitInfo* info) {\n+  LIRGenerator* gen = access.gen();\n+  DecoratorSet decorators = access.decorators();\n+\n+  \/\/ First we test whether marking is in progress.\n+  BasicType flag_type;\n+  bool patch = (decorators & C1_NEEDS_PATCHING) != 0;\n+  bool do_load = pre_val == LIR_OprFact::illegalOpr;\n+  if (in_bytes(SATBMarkQueue::byte_width_of_active()) == 4) {\n+    flag_type = T_INT;\n+  } else {\n+    guarantee(in_bytes(SATBMarkQueue::byte_width_of_active()) == 1,\n+              \"Assumption\");\n+    \/\/ Use unsigned type T_BOOLEAN here rather than signed T_BYTE since some platforms, eg. ARM,\n+    \/\/ need to use unsigned instructions to use the large offset to load the satb_mark_queue.\n+    flag_type = T_BOOLEAN;\n+  }\n+  LIR_Opr thrd = gen->getThreadPointer();\n+  LIR_Address* mark_active_flag_addr =\n+    new LIR_Address(thrd,\n+                    in_bytes(G1ThreadLocalData::satb_mark_queue_active_offset()),\n+                    flag_type);\n+  \/\/ Read the marking-in-progress flag.\n+  \/\/ Note: When loading pre_val requires patching, i.e. do_load == true &&\n+  \/\/ patch == true, a safepoint can occur while patching. This makes the\n+  \/\/ pre-barrier non-atomic and invalidates the marking-in-progress check.\n+  \/\/ Therefore, in the presence of patching, we must repeat the same\n+  \/\/ marking-in-progress checking before calling into the Runtime. For\n+  \/\/ simplicity, we do this check unconditionally (regardless of the presence\n+  \/\/ of patching) in the runtime stub\n+  \/\/ (G1BarrierSetAssembler::generate_c1_pre_barrier_runtime_stub).\n+  LIR_Opr flag_val = gen->new_register(T_INT);\n+  __ load(mark_active_flag_addr, flag_val);\n+  __ cmp(lir_cond_notEqual, flag_val, LIR_OprFact::intConst(0));\n+\n+  LIR_PatchCode pre_val_patch_code = lir_patch_none;\n+\n+  CodeStub* slow;\n+\n+  if (do_load) {\n+    assert(pre_val == LIR_OprFact::illegalOpr, \"sanity\");\n+    assert(addr_opr != LIR_OprFact::illegalOpr, \"sanity\");\n+\n+    if (patch)\n+      pre_val_patch_code = lir_patch_normal;\n+\n+    pre_val = gen->new_register(T_OBJECT);\n+\n+    if (!addr_opr->is_address()) {\n+      assert(addr_opr->is_register(), \"must be\");\n+      addr_opr = LIR_OprFact::address(new LIR_Address(addr_opr, T_OBJECT));\n+    }\n+    slow = new G1PreBarrierStub(addr_opr, pre_val, pre_val_patch_code, info);\n+  } else {\n+    assert(addr_opr == LIR_OprFact::illegalOpr, \"sanity\");\n+    assert(pre_val->is_register(), \"must be\");\n+    assert(pre_val->type() == T_OBJECT, \"must be an object\");\n+    assert(info == nullptr, \"sanity\");\n+\n+    slow = new G1PreBarrierStub(pre_val);\n+  }\n+\n+  __ branch(lir_cond_notEqual, slow);\n+  __ branch_destination(slow->continuation());\n+}\n+\n+void G1BarrierSetC1::post_barrier(LIRAccess& access, LIR_Opr addr, LIR_Opr new_val) {\n+  LIRGenerator* gen = access.gen();\n+  DecoratorSet decorators = access.decorators();\n+  bool in_heap = (decorators & IN_HEAP) != 0;\n+  if (!in_heap) {\n+    return;\n+  }\n+\n+  \/\/ If the \"new_val\" is a constant null, no barrier is necessary.\n+  if (new_val->is_constant() &&\n+      new_val->as_constant_ptr()->as_jobject() == nullptr) return;\n+\n+  if (!new_val->is_register()) {\n+    LIR_Opr new_val_reg = gen->new_register(T_OBJECT);\n+    if (new_val->is_constant()) {\n+      __ move(new_val, new_val_reg);\n+    } else {\n+      __ leal(new_val, new_val_reg);\n+    }\n+    new_val = new_val_reg;\n+  }\n+  assert(new_val->is_register(), \"must be a register at this point\");\n+\n+  if (addr->is_address()) {\n+    LIR_Address* address = addr->as_address_ptr();\n+    LIR_Opr ptr = gen->new_pointer_register();\n+    if (!address->index()->is_valid() && address->disp() == 0) {\n+      __ move(address->base(), ptr);\n+    } else {\n+      assert(address->disp() != max_jint, \"lea doesn't support patched addresses!\");\n+      __ leal(addr, ptr);\n+    }\n+    addr = ptr;\n+  }\n+  assert(addr->is_register(), \"must be a register at this point\");\n+\n+  LIR_Opr xor_res = gen->new_pointer_register();\n+  LIR_Opr xor_shift_res = gen->new_pointer_register();\n+  if (two_operand_lir_form) {\n+    __ move(addr, xor_res);\n+    __ logical_xor(xor_res, new_val, xor_res);\n+    __ move(xor_res, xor_shift_res);\n+    __ unsigned_shift_right(xor_shift_res,\n+                            LIR_OprFact::intConst(checked_cast<jint>(HeapRegion::LogOfHRGrainBytes)),\n+                            xor_shift_res,\n+                            LIR_Opr::illegalOpr());\n+  } else {\n+    __ logical_xor(addr, new_val, xor_res);\n+    __ unsigned_shift_right(xor_res,\n+                            LIR_OprFact::intConst(checked_cast<jint>(HeapRegion::LogOfHRGrainBytes)),\n+                            xor_shift_res,\n+                            LIR_Opr::illegalOpr());\n+  }\n+\n+  __ cmp(lir_cond_notEqual, xor_shift_res, LIR_OprFact::intptrConst(NULL_WORD));\n+\n+  CodeStub* slow = new G1PostBarrierStub(addr, new_val);\n+  __ branch(lir_cond_notEqual, slow);\n+  __ branch_destination(slow->continuation());\n+}\n+\n+void G1BarrierSetC1::load_at_resolved(LIRAccess& access, LIR_Opr result) {\n+  DecoratorSet decorators = access.decorators();\n+  bool is_weak = (decorators & ON_WEAK_OOP_REF) != 0;\n+  bool is_phantom = (decorators & ON_PHANTOM_OOP_REF) != 0;\n+  bool is_anonymous = (decorators & ON_UNKNOWN_OOP_REF) != 0;\n+  LIRGenerator *gen = access.gen();\n+\n+  BarrierSetC1::load_at_resolved(access, result);\n+\n+  if (access.is_oop() && (is_weak || is_phantom || is_anonymous)) {\n+    \/\/ Register the value in the referent field with the pre-barrier\n+    LabelObj *Lcont_anonymous;\n+    if (is_anonymous) {\n+      Lcont_anonymous = new LabelObj();\n+      generate_referent_check(access, Lcont_anonymous);\n+    }\n+    pre_barrier(access, LIR_OprFact::illegalOpr \/* addr_opr *\/,\n+                result \/* pre_val *\/, access.patch_emit_info() \/* info *\/);\n+    if (is_anonymous) {\n+      __ branch_destination(Lcont_anonymous->label());\n+    }\n+  }\n+}\n+\n+class C1G1PreBarrierCodeGenClosure : public StubAssemblerCodeGenClosure {\n+  virtual OopMapSet* generate_code(StubAssembler* sasm) {\n+    G1BarrierSetAssembler* bs = (G1BarrierSetAssembler*)BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs->generate_c1_pre_barrier_runtime_stub(sasm);\n+    return nullptr;\n+  }\n+};\n+\n+class C1G1PostBarrierCodeGenClosure : public StubAssemblerCodeGenClosure {\n+  virtual OopMapSet* generate_code(StubAssembler* sasm) {\n+    G1BarrierSetAssembler* bs = (G1BarrierSetAssembler*)BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs->generate_c1_post_barrier_runtime_stub(sasm);\n+    return nullptr;\n+  }\n+};\n+\n+void G1BarrierSetC1::generate_c1_runtime_stubs(BufferBlob* buffer_blob) {\n+  C1G1PreBarrierCodeGenClosure pre_code_gen_cl;\n+  C1G1PostBarrierCodeGenClosure post_code_gen_cl;\n+  _pre_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, -1, \"g1_pre_barrier_slow\",\n+                                                              false, &pre_code_gen_cl);\n+  _post_barrier_c1_runtime_code_blob = Runtime1::generate_blob(buffer_blob, -1, \"g1_post_barrier_slow\",\n+                                                               false, &post_code_gen_cl);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.cpp","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"}]}