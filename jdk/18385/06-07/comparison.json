{"files":[{"patch":"@@ -63,1 +63,1 @@\n-    private final ConcatPolicy policy;\n+    private final boolean allowConcatenation;\n@@ -77,2 +77,2 @@\n-     * Creates a new input stream with the specified buffer size that will decode\n-     * concatenated GZIP streams according to {@link ConcatPolicy#ALLOW_LENIENT}.\n+     * Creates a new input stream with the specified buffer size that supports decoding\n+     * concatenated GZIP streams.\n@@ -90,1 +90,1 @@\n-        this(in, size, ConcatPolicy.ALLOW_LENIENT);\n+        this(in, size, true);\n@@ -94,2 +94,2 @@\n-     * Creates a new input stream with the default buffer size that will decode\n-     * concatenated GZIP streams according to {@link ConcatPolicy#ALLOW_LENIENT}.\n+     * Creates a new input stream with the default buffer size that supports decoding\n+     * concatenated GZIP streams.\n@@ -105,1 +105,1 @@\n-        this(in, 512, ConcatPolicy.ALLOW_LENIENT);\n+        this(in, 512, true);\n@@ -109,2 +109,2 @@\n-     * Creates a new input stream with the specified buffer size that will decode\n-     * concatenated GZIP streams according to the specified {@link ConcatPolicy}.\n+     * Creates a new input stream with the specified buffer size that optionally\n+     * supports decoding concatenated GZIP streams.\n@@ -113,3 +113,4 @@\n-     * When configured with {@link ConcatPolicy#DISALLOW}, decompression stops after the end of\n-     * the first compressed data stream (i.e., after encountering a GZIP trailer frame), and any\n-     * additional bytes in the input stream will cause an {@link IOException} to be thrown.\n+     * When {@code allowConcatenation} is false, decompression stops after the end of\n+     * the first compressed data stream (i.e., after encountering a GZIP trailer frame),\n+     * and the presence of any additional bytes in the input stream will cause an\n+     * {@link IOException} to be thrown.\n@@ -118,5 +119,6 @@\n-     * When configured with {@link ConcatPolicy#ALLOW} or {@link ConcatPolicy#ALLOW_LENIENT},\n-     * this class will attempt to decode any data that follows a GZIP trailer frame as the GZIP\n-     * header frame of a new compressed data stream and proceed to decompress it. As a result,\n-     * arbitrarily many consecutive compressed data streams in the underlying input will be read\n-     * back as a single uncompressed stream.\n+     * When {@code allowConcatenation} is true, this class will attempt to decode any data that\n+     * follows a GZIP trailer frame as the GZIP header frame of a new compressed data stream and,\n+     * if successful, proceed to decompress it. As a result, arbitrarily many consecutive compressed\n+     * data streams in the underlying input will be read back as a single uncompressed stream.\n+     * If data following a GZIP trailer frame is not a valid GZIP header frame, an {@link IOException}\n+     * is thrown.\n@@ -125,7 +127,3 @@\n-     * The choice between {@link ConcatPolicy#ALLOW} and {@link ConcatPolicy#ALLOW_LENIENT}\n-     * affects how an invalid GZIP header frame following a GZIP trailer frame is handled.\n-     * With {@link ConcatPolicy#ALLOW_LENIENT}, if the GZIP header frame is invalid, or reading it\n-     * generates an {@link IOException}, then the additional bytes read are discarded and EOF is returned.\n-     * In this scenario, it is indeterminate (a) how many additional bytes (if any) were read beyond the\n-     * GZIP trailer frame, and (b) whether reading stopped due to EOF, invalid data, or an underlying\n-     * {@link IOException}.\n+     * In either scenario, every byte of the underlying input stream must be part of a complete and valid\n+     * compressed data stream or else an {@link IOException} is guaranteed to be thrown; extraneous\n+     * trailing data is not allowed.\n@@ -133,10 +131,8 @@\n-     * <p>\n-     * With {@link ConcatPolicy#ALLOW}, an invalid GZIP header frame always triggers an {@link IOException},\n-     * and any {@link IOException} thrown while trying to read a GZIP header frame is propagated to the caller.\n-     * In this scenario, every byte of the underlying input stream must be part of a complete and valid\n-     * compressed data stream, or else an {@link IOException} is guaranteed to be thrown.\n-     *\n-     * @apiNote The original behavior of this class is replicated by {@link ConcatPolicy#ALLOW_LENIENT}.\n-     * However, use of {@link ConcatPolicy#ALLOW_LENIENT} is discouraged because of its imprecision in how\n-     * many additional bytes are read and the possibility that {@link IOException}s and\/or data corruption\n-     * in the underlying input stream can go undetected.\n+     * @apiNote The original behavior of this class was to always allow concatenation, but leniently:\n+     * if a GZIP header frame following a GZIP trailer frame was invalid, or reading it generated an\n+     * {@link IOException}, then the extra bytes read were simply discarded and EOF was declared.\n+     * This meant it was indeterminate how many additional bytes of the underlying input stream (if any)\n+     * were read beyond the GZIP trailer frame, and whether reading them was stopped due to EOF, an\n+     * invalid GZIP header frame, or an {@link IOException} from the underlying input stream. As a result,\n+     * {@link IOException}s and\/or data corruption in the underlying input stream could go undetected,\n+     * leading to incorrect results such as truncated data.\n@@ -146,1 +142,1 @@\n-     * @param policy policy regarding concatenated GZIP streams\n+     * @param allowConcatenation true to support decoding concatenated GZIP streams\n@@ -150,1 +146,1 @@\n-     * @throws    NullPointerException if {@code in} or {@code policy} is null\n+     * @throws    NullPointerException if {@code in} is null\n@@ -154,1 +150,1 @@\n-    public GZIPInputStream(InputStream in, int size, ConcatPolicy policy) throws IOException {\n+    public GZIPInputStream(InputStream in, int size, boolean allowConcatenation) throws IOException {\n@@ -156,1 +152,1 @@\n-        this.policy = Objects.requireNonNull(policy, \"policy\");\n+        this.allowConcatenation = allowConcatenation;\n@@ -333,13 +329,4 @@\n-        \/\/ Handle concatenation and\/or extra bytes\n-        if (policy.equals(ConcatPolicy.ALLOW_LENIENT)) {    \/\/ i.e., the legacy behavior\n-            try {\n-                m += readHeader(in, -1);                    \/\/ next.header\n-            } catch (IOException ze) {\n-                return true;  \/\/ ignore any malformed, do nothing\n-            }\n-        } else {\n-\n-            \/\/ If there is no more data, the input has terminated at a proper GZIP boundary\n-            int nextByte = in.read();\n-            if (nextByte == -1)\n-                return true;\n+        \/\/ If there is no more data, the input has terminated at a proper GZIP boundary\n+        int nextByte = in.read();\n+        if (nextByte == -1)\n+            return true;\n@@ -347,5 +334,3 @@\n-            \/\/ There is more data; verify that we are allowing concatenation\n-            if (!policy.isAllowsConcatenation()) {\n-                assert !policy.isLenient();\n-                throw new ZipException(\"Extra bytes after GZIP trailer\");\n-            }\n+        \/\/ There is more data; verify that we are allowing concatenation\n+        if (!allowConcatenation)\n+            throw new ZipException(\"Extra bytes after GZIP trailer\");\n@@ -353,3 +338,2 @@\n-            \/\/ Read in the next header\n-            m += readHeader(in, nextByte);                  \/\/ next.header\n-        }\n+        \/\/ Read in the next header\n+        m += readHeader(in, nextByte);                  \/\/ next.header\n@@ -411,68 +395,0 @@\n-\n-    \/**\n-     * Policy relating to the handling of an input stream containing multiple concatenated GZIP streams.\n-     *\n-     * @since 24\n-     *\/\n-    public enum ConcatPolicy {\n-\n-        \/**\n-         * Disallow concatenated GZIP streams.\n-         *\n-         * <p>\n-         * If any bytes follow the GZIP trailer frame, an {@link IOException} is thrown.\n-         *\/\n-        DISALLOW(false, false),\n-\n-        \/**\n-         * Allow concatenated GZIP streams.\n-         *\n-         * <p>\n-         * Any data that follows a GZIP trailer frame must constitute the valid GZIP header frame\n-         * of a new GZIP compressed stream.\n-         *\/\n-        ALLOW(true, false),\n-\n-        \/**\n-         * Allow concatenated GZIP streams with leniency for extra trailing data.\n-         *\n-         * <p>\n-         * Any data that follows a GZIP trailer frame but does not constitute a valid GZIP header\n-         * frame, or triggers an {@link IOException}, is discarded and ignored.\n-         *\/\n-        ALLOW_LENIENT(true, true);\n-\n-        private final boolean allowsConcatenation;\n-        private final boolean lenient;\n-\n-        \/**\n-         * Determine whether this policy permits the decoding of multiple concatenated GZIP streams\n-         * as a single output stream.\n-         *\n-         * <p>\n-         * Returns true for {@link #ALLOW} and {@link #ALLOW_LENIENT}.\n-         *\n-         * @return true if multiple concatenated GZIP streams are allowed\n-         *\/\n-        public boolean isAllowsConcatenation() {\n-            return this.allowsConcatenation;\n-        }\n-\n-        \/**\n-         * Determine whether this policy permits extra bytes following a GZIP trailer frame that do not\n-         * constitute a proper GZIP header frame.\n-         *\n-         * <p>\n-         * Returns true for {@link #ALLOW_LENIENT}.\n-         *\n-         * @return true if this policy is lenient towards extra bytes\n-         *\/\n-        public boolean isLenient() {\n-            return this.lenient;\n-        }\n-\n-        private ConcatPolicy(boolean allowsConcatenation, boolean lenient) {\n-            this.allowsConcatenation = allowsConcatenation;\n-            this.lenient = lenient;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPInputStream.java","additions":43,"deletions":127,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import org.junit.jupiter.api.Test;\n@@ -39,2 +38,0 @@\n-import static java.util.zip.GZIPInputStream.ConcatPolicy;\n-\n@@ -46,1 +43,1 @@\n-    private ConcatPolicy policy;\n+    private boolean allowConcatenation;\n@@ -53,1 +50,1 @@\n-        for (ConcatPolicy policy : ConcatPolicy.values()) {\n+        for (boolean allowConcatenation : new boolean[] { false, true }) {\n@@ -55,1 +52,1 @@\n-                scenarios.add(List.of(randomData(0, 100), size, policy));\n+                scenarios.add(List.of(randomData(0, 100), size, allowConcatenation));\n@@ -63,1 +60,1 @@\n-    public void testScenario(byte[] uncompressed, int size, ConcatPolicy policy) throws IOException {\n+    public void testScenario(byte[] uncompressed, int size, boolean allowConcatenation) throws IOException {\n@@ -65,1 +62,1 @@\n-        this.policy = policy;\n+        this.allowConcatenation = allowConcatenation;\n@@ -92,1 +89,1 @@\n-            testDecomp(input, output, !policy.isLenient() ? IOException.class : null);\n+            testDecomp(input, output, IOException.class);\n@@ -98,1 +95,1 @@\n-        testDecomp(input, output, !policy.isLenient() ? IOException.class : null);\n+        testDecomp(input, output, IOException.class);\n@@ -103,1 +100,1 @@\n-        testDecomp(input, output, policy.isAllowsConcatenation() || !policy.isLenient() ? IOException.class : null);\n+        testDecomp(input, output, IOException.class);\n@@ -107,2 +104,2 @@\n-        output = policy.isAllowsConcatenation() ? concat(uncompressed, uncompressed) : uncompressed;\n-        testDecomp(input, output, !policy.isAllowsConcatenation() && !policy.isLenient() ? ZipException.class : null);\n+        output = allowConcatenation ? concat(uncompressed, uncompressed) : uncompressed;\n+        testDecomp(input, output, !allowConcatenation ? ZipException.class : null);\n@@ -112,2 +109,2 @@\n-        output = policy.isAllowsConcatenation() ? concat(uncompressed, uncompressed, uncompressed) : uncompressed;\n-        testDecomp(input, output, !policy.isAllowsConcatenation() && !policy.isLenient() ? ZipException.class : null);\n+        output = allowConcatenation ? concat(uncompressed, uncompressed, uncompressed) : uncompressed;\n+        testDecomp(input, output, !allowConcatenation ? ZipException.class : null);\n@@ -117,2 +114,2 @@\n-        output = policy.isAllowsConcatenation() ? concat(uncompressed, uncompressed, uncompressed) : uncompressed;\n-        testDecomp(input, output, !policy.isLenient() ? IOException.class : null);\n+        output = allowConcatenation ? concat(uncompressed, uncompressed, uncompressed) : uncompressed;\n+        testDecomp(input, output, IOException.class);\n@@ -184,1 +181,1 @@\n-        return new GZIPInputStream(in, bufsize, policy).readAllBytes();\n+        return new GZIPInputStream(in, bufsize, allowConcatenation).readAllBytes();\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamConcat.java","additions":15,"deletions":18,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8322256\n+ * @summary Test decompression of streams created by the gzip(1) command\n+ * @run junit GZIPInputStreamGzipCommand\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+import java.util.stream.*;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+public class GZIPInputStreamGzipCommand {\n+\n+    public static Stream<String[]> testScenarios() throws IOException {\n+        final ArrayList<String[]> scenarios = new ArrayList();\n+\n+        \/*\n+            (\n+                for i in 1 2 3 4 5 6 7 8 9; do\n+                    printf 'this is compression level #%d\\n' \"$i\" | gzip -\"${i}\"\n+                done\n+            ) | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(new String[] { \"\"\"\n+            this is compression level #1\n+            this is compression level #2\n+            this is compression level #3\n+            this is compression level #4\n+            this is compression level #5\n+            this is compression level #6\n+            this is compression level #7\n+            this is compression level #8\n+            this is compression level #9\n+            \"\"\", \"\"\"\n+            1f8b0800d42ea46604032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2\n+            d41c0565432e0092bb84691d0000001f8b0800d42ea46600032bc9c82c5600a2\n+            e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565232e0051e8a9421d0000001f8b\n+            0800d42ea46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c\n+            0565632e0010d9b25b1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fc\n+            dc82a2d4e2e2ccfc3c859cd4b2d41c0565132e00d74ff3141d0000001f8b0800\n+            d42ea46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565\n+            532e00967ee80d1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fcdc82\n+            a2d4e2e2ccfc3c859cd4b2d41c0565332e00552dc5261d0000001f8b0800d42e\n+            a46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565732e\n+            00141cde3f1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fcdc82a2d4\n+            e2e2ccfc3c859cd4b2d41c05650b2e00db0046b81d0000001f8b0800d42ea466\n+            02032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c05654b2e009a\n+            315da11d000000\"\"\" });\n+\n+        \/*\n+            (\n+                printf 'this one has a name\\n' > file1 && gzip file1\n+                printf 'this one has no name\\n' > file2 && gzip --no-name file2\n+                cat file1.gz file2.gz\n+                rm file1.gz file2.gz\n+            ) | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(new String[] { \"\"\"\n+            this one has a name\n+            this one has no name\n+            \"\"\", \"\"\"\n+            1f8b08082230a466000366696c6531002bc9c82c56c8cf4b55c8482c564854c8\n+            4bcc4de50200d7ccdc5a140000001f8b08000000000000032bc9c82c56c8cf4b\n+            55c8482c56c8cb57c84bcc4de50200b1effb5015000000\"\"\" });\n+\n+        \/*\n+            (\n+                i=0\n+                while [ \"${i}\" -lt 1000 ]; do\n+                    printf 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n+                    i=`expr \"${i}\" + 1`\n+                done\n+            ) | gzip --best | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(new String[] {\n+            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\".repeat(1000),\n+            \"\"\"\n+            1f8b08002a35a4660203edc18100000000c320d6f94b1ce45501000000000000\n+            0000000000000000000000000000000000000000000000000000000000000000\n+            c08f01492d182728a00000\"\"\" });\n+\n+        return scenarios.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testScenarios\")\n+    public void testScenario(String input, String hexData) throws IOException {\n+\n+        \/\/ Get expected result\n+        final byte[] expected = input.getBytes(StandardCharsets.UTF_8);\n+\n+        \/\/ Get actual result\n+        final HexFormat hexFormat = HexFormat.of();\n+        final byte[] data = hexFormat.parseHex(hexData.replaceAll(\"\\\\s\", \"\"));\n+        final ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        try (GZIPInputStream gunzip = new GZIPInputStream(new ByteArrayInputStream(data))) {\n+            gunzip.transferTo(buf);\n+        }\n+        final byte[] actual = buf.toByteArray();\n+\n+        \/\/ Compare\n+        System.out.println(\"  ACTUAL: \" + hexFormat.formatHex(actual));\n+        System.out.println(\"EXPECTED: \" + hexFormat.formatHex(expected));\n+        assertArrayEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamGzipCommand.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"}]}