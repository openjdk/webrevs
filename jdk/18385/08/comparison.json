{"files":[{"patch":"@@ -37,2 +37,11 @@\n- * This class implements a stream filter for reading compressed data in\n- * the GZIP file format.\n+ * This class implements a stream filter for reading compressed data in the GZIP file format.\n+ *\n+ * <p>\n+ * The GZIP compressed data format is self-delimiting, i.e., it includes an explicit GZIP trailer\n+ * frame that marks the end of the compressed data. Therefore it's possible for the underlying\n+ * input to contain additional data beyond the end of the compressed GZIP data. In particular,\n+ * some GZIP compression tools function by partitioning the input, compressing each parttion\n+ * separately, and then concatenating the resulting compressed data streams. To support this kind\n+ * of input, after reading a GZIP trailer frame this class will attempt to read and decode a new\n+ * GZIP header frame. If succesful, it will proceed to decompress the new GZIP stream, otherwise,\n+ * it will return EOF. In the latter case, the number of additional bytes that were read is unspecified.\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPInputStream.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8322256\n+ * @summary Test support for concatenated gzip streams\n+ * @run junit GZIPInputStreamConcat\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.stream.*;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+public class GZIPInputStreamConcat {\n+\n+    private int bufsize;\n+\n+    public static Stream<Object[]> testScenarios() throws IOException {\n+\n+        \/\/ Test concat vs. non-concat, garbage vs. no-garbage, and various buffer sizes on random data\n+        Random random = new Random();\n+        final ArrayList<List<Object>> scenarios = new ArrayList<>();\n+        for (int size = 1; size < 1024; size += random.nextInt(32) + 1) {\n+            scenarios.add(List.of(randomData(0, 100), size));\n+        }\n+        return scenarios.stream().map(List::toArray);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testScenarios\")\n+    public void testScenario(byte[] uncompressed, int size) throws IOException {\n+        this.bufsize = size;\n+        testScenario(uncompressed);\n+    }\n+\n+    public void testScenario(byte[] uncompressed) throws IOException {\n+\n+        \/\/ Compress the test data\n+        byte[] compressed = deflate(uncompressed);\n+\n+        \/\/ Decompress a single stream with no extra garbage - should always work\n+        byte[] input = compressed;\n+        byte[] output = uncompressed;\n+        testDecomp(input, output, null);\n+\n+        \/\/ Decompress a truncated GZIP header\n+        input = oneByteShort(gzipHeader());\n+        testDecomp(input, null, EOFException.class);\n+\n+        \/\/ Decompress a single stream that is one byte short - should always fail\n+        input = oneByteShort(compressed);\n+        output = null;\n+        testDecomp(input, null, EOFException.class);\n+\n+        \/\/ Decompress a single stream with one byte of extra garbage (trying all 256 possible values)\n+        for (int extra = 0; extra < 0x100; extra++) {\n+            input = oneByteLong(compressed, extra);\n+            output = uncompressed;\n+            testDecomp(input, output, null);\n+        }\n+\n+        \/\/ Decompress a single stream followed by a truncated GZIP header\n+        input = concat(compressed, oneByteShort(gzipHeader()));\n+        output = uncompressed;\n+        testDecomp(input, output, null);\n+\n+        \/\/ Decompress a single stream followed by another stream that is one byte short\n+        input = concat(compressed, oneByteShort(compressed));\n+        output = uncompressed;\n+        testDecomp(input, output, IOException.class);\n+\n+        \/\/ Decompress two streams concatenated\n+        input = concat(compressed, compressed);\n+        output = concat(uncompressed, uncompressed);\n+        testDecomp(input, output, null);\n+\n+        \/\/ Decompress three streams concatenated\n+        input = concat(compressed, compressed, compressed);\n+        output = concat(uncompressed, uncompressed, uncompressed);\n+        testDecomp(input, output, null);\n+\n+        \/\/ Decompress three streams concatenated followed by a truncated GZIP header\n+        input = concat(compressed, compressed, compressed, oneByteShort(gzipHeader()));\n+        output = concat(uncompressed, uncompressed, uncompressed);\n+        testDecomp(input, output, null);\n+    }\n+\n+    \/\/ Do decompression and check result\n+    public void testDecomp(byte[] compressed, byte[] uncompressed, Class<? extends IOException> exceptionType) {\n+        try {\n+            byte[] readback = inflate(new ByteArrayInputStream(compressed));\n+            if (exceptionType != null)\n+                throw new AssertionError(\"expected \" + exceptionType.getSimpleName());\n+            assertArrayEquals(uncompressed, readback);\n+        } catch (IOException e) {\n+            if (exceptionType == null)\n+                throw new AssertionError(\"unexpected exception\", e);\n+            if (!exceptionType.isAssignableFrom(e.getClass())) {\n+                throw new AssertionError(String.format(\n+                  \"expected %s but got %s\", exceptionType.getSimpleName(), e.getClass().getSimpleName()), e);\n+            }\n+        }\n+    }\n+\n+    \/\/ Create a GZIP header\n+    public static byte[] gzipHeader() throws IOException {\n+        byte[] compressed = deflate(new byte[0]);\n+        return Arrays.copyOfRange(compressed, 0, 10);\n+    }\n+\n+    \/\/ Add one extra byte to the given array\n+    public static byte[] oneByteLong(byte[] array, int value) {\n+        byte[] array2 = new byte[array.length + 1];\n+        System.arraycopy(array, 0, array2, 0, array.length);\n+        array2[array.length] = (byte)value;\n+        return array2;\n+    }\n+\n+    \/\/ Chop off the last byte of the given array\n+    public static byte[] oneByteShort(byte[] array) {\n+        return Arrays.copyOfRange(array, 0, array.length - 1);\n+    }\n+\n+    \/\/ Create some random data\n+    public static byte[] randomData(int min, int max) {\n+        Random random = new Random();\n+        byte[] data = new byte[min + random.nextInt(max - min)];\n+        random.nextBytes(data);\n+        return data;\n+    }\n+\n+    \/\/ Concatenate byte arrays\n+    public static byte[] concat(byte[]... arrays) {\n+        final ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        for (byte[] array : arrays)\n+            buf.writeBytes(array);\n+        return buf.toByteArray();\n+    }\n+\n+    \/\/ GZIP compress data\n+    public static byte[] deflate(byte[] data) throws IOException {\n+        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        try (GZIPOutputStream out = new GZIPOutputStream(buf)) {\n+            out.write(data);\n+        }\n+        return buf.toByteArray();\n+    }\n+\n+    \/\/ GZIP decompress data\n+    public byte[] inflate(InputStream in) throws IOException {\n+        return new GZIPInputStream(in, bufsize).readAllBytes();\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamConcat.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8322256\n+ * @summary Test decompression of streams created by the gzip(1) command\n+ * @run junit GZIPInputStreamGzipCommand\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+import java.util.stream.*;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+public class GZIPInputStreamGzipCommand {\n+\n+    public static Stream<String[]> gzipScenarios() throws IOException {\n+        final ArrayList<String[]> scenarios = new ArrayList();\n+\n+        \/*\n+            # To regenerate the hex data below:\n+            (\n+                for i in 1 2 3 4 5 6 7 8 9; do\n+                    printf 'this is compression level #%d\\n' \"$i\" | gzip -\"${i}\"\n+                done\n+            ) | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(new String[] { \"\"\"\n+            this is compression level #1\n+            this is compression level #2\n+            this is compression level #3\n+            this is compression level #4\n+            this is compression level #5\n+            this is compression level #6\n+            this is compression level #7\n+            this is compression level #8\n+            this is compression level #9\n+            \"\"\", \"\"\"\n+            1f8b0800d42ea46604032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2\n+            d41c0565432e0092bb84691d0000001f8b0800d42ea46600032bc9c82c5600a2\n+            e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565232e0051e8a9421d0000001f8b\n+            0800d42ea46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c\n+            0565632e0010d9b25b1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fc\n+            dc82a2d4e2e2ccfc3c859cd4b2d41c0565132e00d74ff3141d0000001f8b0800\n+            d42ea46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565\n+            532e00967ee80d1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fcdc82\n+            a2d4e2e2ccfc3c859cd4b2d41c0565332e00552dc5261d0000001f8b0800d42e\n+            a46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565732e\n+            00141cde3f1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fcdc82a2d4\n+            e2e2ccfc3c859cd4b2d41c05650b2e00db0046b81d0000001f8b0800d42ea466\n+            02032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c05654b2e009a\n+            315da11d000000\"\"\" });\n+\n+        \/*\n+            # To regenerate the hex data below:\n+            (\n+                printf 'this one has a name\\n' > file1 && gzip file1\n+                printf 'this one has no name\\n' > file2 && gzip --no-name file2\n+                cat file1.gz file2.gz\n+                rm file1.gz file2.gz\n+            ) | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(new String[] { \"\"\"\n+            this one has a name\n+            this one has no name\n+            \"\"\", \"\"\"\n+            1f8b08082230a466000366696c6531002bc9c82c56c8cf4b55c8482c564854c8\n+            4bcc4de50200d7ccdc5a140000001f8b08000000000000032bc9c82c56c8cf4b\n+            55c8482c56c8cb57c84bcc4de50200b1effb5015000000\"\"\" });\n+\n+        \/*\n+            # To regenerate the hex data below:\n+            (\n+                i=0\n+                while [ \"${i}\" -lt 1000 ]; do\n+                    printf 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n+                    i=`expr \"${i}\" + 1`\n+                done\n+            ) | gzip --best | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(new String[] {\n+            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\".repeat(1000),\n+            \"\"\"\n+            1f8b08002a35a4660203edc18100000000c320d6f94b1ce45501000000000000\n+            0000000000000000000000000000000000000000000000000000000000000000\n+            c08f01492d182728a00000\"\"\" });\n+\n+        return scenarios.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"gzipScenarios\")\n+    public void testScenario(String input, String hexData) throws IOException {\n+\n+        \/\/ Get expected result\n+        final byte[] expected = input.getBytes(StandardCharsets.UTF_8);\n+\n+        \/\/ Get actual result\n+        final HexFormat hexFormat = HexFormat.of();\n+        final byte[] data = hexFormat.parseHex(hexData.replaceAll(\"\\\\s\", \"\"));\n+        final ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        try (GZIPInputStream gunzip = new GZIPInputStream(new ByteArrayInputStream(data))) {\n+            gunzip.transferTo(buf);\n+        }\n+        final byte[] actual = buf.toByteArray();\n+\n+        \/\/ Compare\n+        System.out.println(\"  ACTUAL: \" + hexFormat.formatHex(actual));\n+        System.out.println(\"EXPECTED: \" + hexFormat.formatHex(expected));\n+        assertArrayEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamGzipCommand.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"}]}