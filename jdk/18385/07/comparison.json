{"files":[{"patch":"@@ -37,2 +37,9 @@\n- * This class implements a stream filter for reading compressed data in\n- * the GZIP file format.\n+ * This class implements a stream filter for reading compressed data in the GZIP file format.\n+ *\n+ * <p>\n+ * The GZIP compressed data format is self-delimiting, i.e., it includes an explicit trailer\n+ * frame that marks the end of the compressed data. Therefore it's possible for the underlying\n+ * input to contain additional data beyond the end of the compressed GZIP data. In particular,\n+ * some GZIP compression tools will concatenate multiple compressed data streams together.\n+ * This class includes configurable support for decompressing multiple concatenated compressed\n+ * data streams as a single uncompressed data stream.\n@@ -56,0 +63,2 @@\n+    private final boolean allowConcatenation;\n+\n@@ -68,1 +77,3 @@\n-     * Creates a new input stream with the specified buffer size.\n+     * Creates a new input stream with the specified buffer size that supports decoding\n+     * concatenated GZIP streams.\n+     *\n@@ -79,0 +90,61 @@\n+        this(in, size, true);\n+    }\n+\n+    \/**\n+     * Creates a new input stream with the default buffer size that supports decoding\n+     * concatenated GZIP streams.\n+     *\n+     * @param in the input stream\n+     *\n+     * @throws    ZipException if a GZIP format error has occurred or the\n+     *                         compression method used is unsupported\n+     * @throws    NullPointerException if {@code in} is null\n+     * @throws    IOException if an I\/O error has occurred\n+     *\/\n+    public GZIPInputStream(InputStream in) throws IOException {\n+        this(in, 512, true);\n+    }\n+\n+    \/**\n+     * Creates a new input stream with the specified buffer size that optionally\n+     * supports decoding concatenated GZIP streams.\n+     *\n+     * <p>\n+     * When {@code allowConcatenation} is false, decompression stops after the end of\n+     * the first compressed data stream (i.e., after encountering a GZIP trailer frame),\n+     * and the presence of any additional bytes in the input stream will cause an\n+     * {@link IOException} to be thrown.\n+     *\n+     * <p>\n+     * When {@code allowConcatenation} is true, this class will attempt to decode any data that\n+     * follows a GZIP trailer frame as the GZIP header frame of a new compressed data stream and,\n+     * if successful, proceed to decompress it. As a result, arbitrarily many consecutive compressed\n+     * data streams in the underlying input will be read back as a single uncompressed stream.\n+     * If data following a GZIP trailer frame is not a valid GZIP header frame, an {@link IOException}\n+     * is thrown.\n+     *\n+     * <p>\n+     * In either scenario, every byte of the underlying input stream must be part of a complete and valid\n+     * compressed data stream or else an {@link IOException} is guaranteed to be thrown; extraneous\n+     * trailing data is not allowed.\n+     *\n+     * @apiNote The original behavior of this class was to always allow concatenation, but leniently:\n+     * if a GZIP header frame following a GZIP trailer frame was invalid, or reading it generated an\n+     * {@link IOException}, then the extra bytes read were simply discarded and EOF was declared.\n+     * This meant it was indeterminate how many additional bytes of the underlying input stream (if any)\n+     * were read beyond the GZIP trailer frame, and whether reading them was stopped due to EOF, an\n+     * invalid GZIP header frame, or an {@link IOException} from the underlying input stream. As a result,\n+     * {@link IOException}s and\/or data corruption in the underlying input stream could go undetected,\n+     * leading to incorrect results such as truncated data.\n+     *\n+     * @param in the input stream\n+     * @param size the input buffer size\n+     * @param allowConcatenation true to support decoding concatenated GZIP streams\n+     *\n+     * @throws    ZipException if a GZIP format error has occurred or the\n+     *                         compression method used is unsupported\n+     * @throws    NullPointerException if {@code in} is null\n+     * @throws    IOException if an I\/O error has occurred\n+     * @since     24\n+     *\/\n+    public GZIPInputStream(InputStream in, int size, boolean allowConcatenation) throws IOException {\n@@ -80,0 +152,1 @@\n+        this.allowConcatenation = allowConcatenation;\n@@ -82,1 +155,1 @@\n-            readHeader(in);\n+            readHeader(in, -1);\n@@ -104,13 +177,0 @@\n-    \/**\n-     * Creates a new input stream with a default buffer size.\n-     * @param in the input stream\n-     *\n-     * @throws    ZipException if a GZIP format error has occurred or the\n-     *                         compression method used is unsupported\n-     * @throws    NullPointerException if {@code in} is null\n-     * @throws    IOException if an I\/O error has occurred\n-     *\/\n-    public GZIPInputStream(InputStream in) throws IOException {\n-        this(in, 512);\n-    }\n-\n@@ -192,1 +252,3 @@\n-     * of this member header.\n+     * of this member header. Use the given value as the first byte\n+     * if not equal to -1 (and include it in the returned byte count).\n+     * Throws EOFException if there's not enough input data.\n@@ -194,1 +256,1 @@\n-    private int readHeader(InputStream this_in) throws IOException {\n+    private int readHeader(InputStream this_in, int firstByte) throws IOException {\n@@ -198,1 +260,4 @@\n-        if (readUShort(in) != GZIP_MAGIC) {\n+        int byte1 = firstByte != -1 ? firstByte : readUByte(in);\n+        int byte2 = readUByte(in);\n+        int magic = (byte2 << 8) | byte1;\n+        if (magic != GZIP_MAGIC) {\n@@ -261,7 +326,16 @@\n-        \/\/ try concatenated case\n-        int m = 8;                  \/\/ this.trailer\n-        try {\n-            m += readHeader(in);    \/\/ next.header\n-        } catch (IOException ze) {\n-            return true;  \/\/ ignore any malformed, do nothing\n-        }\n+        \/\/ Keep track of how many bytes of buffered data we may have read\n+        int m = 8;                                          \/\/ this.trailer\n+\n+        \/\/ If there is no more data, the input has terminated at a proper GZIP boundary\n+        int nextByte = in.read();\n+        if (nextByte == -1)\n+            return true;\n+\n+        \/\/ There is more data; verify that we are allowing concatenation\n+        if (!allowConcatenation)\n+            throw new ZipException(\"Extra bytes after GZIP trailer\");\n+\n+        \/\/ Read in the next header\n+        m += readHeader(in, nextByte);                  \/\/ next.header\n+\n+        \/\/ Pass along any remaining buffered data to the new inflater\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPInputStream.java","additions":101,"deletions":27,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8322256\n+ * @summary Test configurable support for concatenated gzip streams\n+ * @run junit GZIPInputStreamConcat\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.stream.*;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+public class GZIPInputStreamConcat {\n+\n+    private int bufsize;\n+    private boolean allowConcatenation;\n+\n+    public static Stream<Object[]> testScenarios() throws IOException {\n+\n+        \/\/ Test concat vs. non-concat, garbage vs. no-garbage, and various buffer sizes on random data\n+        Random random = new Random();\n+        final ArrayList<List<Object>> scenarios = new ArrayList<>();\n+        for (boolean allowConcatenation : new boolean[] { false, true }) {\n+            for (int size = 1; size < 1024; size += random.nextInt(32) + 1) {\n+                scenarios.add(List.of(randomData(0, 100), size, allowConcatenation));\n+            }\n+        }\n+        return scenarios.stream().map(List::toArray);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testScenarios\")\n+    public void testScenario(byte[] uncompressed, int size, boolean allowConcatenation) throws IOException {\n+        this.bufsize = size;\n+        this.allowConcatenation = allowConcatenation;\n+        testScenario(uncompressed);\n+    }\n+\n+    public void testScenario(byte[] uncompressed) throws IOException {\n+\n+        \/\/ Compress the test data\n+        byte[] compressed = deflate(uncompressed);\n+\n+        \/\/ Decompress a single stream with no extra garbage - should always work\n+        byte[] input = compressed;\n+        byte[] output = uncompressed;\n+        testDecomp(input, output, null);\n+\n+        \/\/ Decompress a truncated GZIP header\n+        input = oneByteShort(gzipHeader());\n+        testDecomp(input, null, EOFException.class);\n+\n+        \/\/ Decompress a single stream that is one byte short - should always fail\n+        input = oneByteShort(compressed);\n+        output = null;\n+        testDecomp(input, null, EOFException.class);\n+\n+        \/\/ Decompress a single stream with one byte of extra garbage (trying all 256 possible values)\n+        for (int extra = 0; extra < 0x100; extra++) {\n+            input = oneByteLong(compressed, extra);\n+            output = uncompressed;\n+            testDecomp(input, output, IOException.class);\n+        }\n+\n+        \/\/ Decompress a single stream followed by a truncated GZIP header\n+        input = concat(compressed, oneByteShort(gzipHeader()));\n+        output = uncompressed;\n+        testDecomp(input, output, IOException.class);\n+\n+        \/\/ Decompress a single stream followed by another stream that is one byte short\n+        input = concat(compressed, oneByteShort(compressed));\n+        output = uncompressed;\n+        testDecomp(input, output, IOException.class);\n+\n+        \/\/ Decompress two streams concatenated\n+        input = concat(compressed, compressed);\n+        output = allowConcatenation ? concat(uncompressed, uncompressed) : uncompressed;\n+        testDecomp(input, output, !allowConcatenation ? ZipException.class : null);\n+\n+        \/\/ Decompress three streams concatenated\n+        input = concat(compressed, compressed, compressed);\n+        output = allowConcatenation ? concat(uncompressed, uncompressed, uncompressed) : uncompressed;\n+        testDecomp(input, output, !allowConcatenation ? ZipException.class : null);\n+\n+        \/\/ Decompress three streams concatenated followed by a truncated GZIP header\n+        input = concat(compressed, compressed, compressed, oneByteShort(gzipHeader()));\n+        output = allowConcatenation ? concat(uncompressed, uncompressed, uncompressed) : uncompressed;\n+        testDecomp(input, output, IOException.class);\n+    }\n+\n+    \/\/ Do decompression and check result\n+    public void testDecomp(byte[] compressed, byte[] uncompressed, Class<? extends IOException> exceptionType) {\n+        try {\n+            byte[] readback = inflate(new ByteArrayInputStream(compressed));\n+            if (exceptionType != null)\n+                throw new AssertionError(\"expected \" + exceptionType.getSimpleName());\n+            assertArrayEquals(uncompressed, readback);\n+        } catch (IOException e) {\n+            if (exceptionType == null)\n+                throw new AssertionError(\"unexpected exception\", e);\n+            if (!exceptionType.isAssignableFrom(e.getClass())) {\n+                throw new AssertionError(String.format(\n+                  \"expected %s but got %s\", exceptionType.getSimpleName(), e.getClass().getSimpleName()), e);\n+            }\n+        }\n+    }\n+\n+    \/\/ Create a GZIP header\n+    public static byte[] gzipHeader() throws IOException {\n+        byte[] compressed = deflate(new byte[0]);\n+        return Arrays.copyOfRange(compressed, 0, 10);\n+    }\n+\n+    \/\/ Add one extra byte to the given array\n+    public static byte[] oneByteLong(byte[] array, int value) {\n+        byte[] array2 = new byte[array.length + 1];\n+        System.arraycopy(array, 0, array2, 0, array.length);\n+        array2[array.length] = (byte)value;\n+        return array2;\n+    }\n+\n+    \/\/ Chop off the last byte of the given array\n+    public static byte[] oneByteShort(byte[] array) {\n+        return Arrays.copyOfRange(array, 0, array.length - 1);\n+    }\n+\n+    \/\/ Create some random data\n+    public static byte[] randomData(int min, int max) {\n+        Random random = new Random();\n+        byte[] data = new byte[min + random.nextInt(max - min)];\n+        random.nextBytes(data);\n+        return data;\n+    }\n+\n+    \/\/ Concatenate byte arrays\n+    public static byte[] concat(byte[]... arrays) {\n+        final ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        for (byte[] array : arrays)\n+            buf.writeBytes(array);\n+        return buf.toByteArray();\n+    }\n+\n+    \/\/ GZIP compress data\n+    public static byte[] deflate(byte[] data) throws IOException {\n+        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        try (GZIPOutputStream out = new GZIPOutputStream(buf)) {\n+            out.write(data);\n+        }\n+        return buf.toByteArray();\n+    }\n+\n+    \/\/ GZIP decompress data\n+    public byte[] inflate(InputStream in) throws IOException {\n+        return new GZIPInputStream(in, bufsize, allowConcatenation).readAllBytes();\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamConcat.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8322256\n+ * @summary Test decompression of streams created by the gzip(1) command\n+ * @run junit GZIPInputStreamGzipCommand\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.*;\n+import java.util.stream.*;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+public class GZIPInputStreamGzipCommand {\n+\n+    public static Stream<String[]> testScenarios() throws IOException {\n+        final ArrayList<String[]> scenarios = new ArrayList();\n+\n+        \/*\n+            (\n+                for i in 1 2 3 4 5 6 7 8 9; do\n+                    printf 'this is compression level #%d\\n' \"$i\" | gzip -\"${i}\"\n+                done\n+            ) | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(new String[] { \"\"\"\n+            this is compression level #1\n+            this is compression level #2\n+            this is compression level #3\n+            this is compression level #4\n+            this is compression level #5\n+            this is compression level #6\n+            this is compression level #7\n+            this is compression level #8\n+            this is compression level #9\n+            \"\"\", \"\"\"\n+            1f8b0800d42ea46604032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2\n+            d41c0565432e0092bb84691d0000001f8b0800d42ea46600032bc9c82c5600a2\n+            e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565232e0051e8a9421d0000001f8b\n+            0800d42ea46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c\n+            0565632e0010d9b25b1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fc\n+            dc82a2d4e2e2ccfc3c859cd4b2d41c0565132e00d74ff3141d0000001f8b0800\n+            d42ea46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565\n+            532e00967ee80d1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fcdc82\n+            a2d4e2e2ccfc3c859cd4b2d41c0565332e00552dc5261d0000001f8b0800d42e\n+            a46600032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c0565732e\n+            00141cde3f1d0000001f8b0800d42ea46600032bc9c82c5600a2e4fcdc82a2d4\n+            e2e2ccfc3c859cd4b2d41c05650b2e00db0046b81d0000001f8b0800d42ea466\n+            02032bc9c82c5600a2e4fcdc82a2d4e2e2ccfc3c859cd4b2d41c05654b2e009a\n+            315da11d000000\"\"\" });\n+\n+        \/*\n+            (\n+                printf 'this one has a name\\n' > file1 && gzip file1\n+                printf 'this one has no name\\n' > file2 && gzip --no-name file2\n+                cat file1.gz file2.gz\n+                rm file1.gz file2.gz\n+            ) | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(new String[] { \"\"\"\n+            this one has a name\n+            this one has no name\n+            \"\"\", \"\"\"\n+            1f8b08082230a466000366696c6531002bc9c82c56c8cf4b55c8482c564854c8\n+            4bcc4de50200d7ccdc5a140000001f8b08000000000000032bc9c82c56c8cf4b\n+            55c8482c56c8cb57c84bcc4de50200b1effb5015000000\"\"\" });\n+\n+        \/*\n+            (\n+                i=0\n+                while [ \"${i}\" -lt 1000 ]; do\n+                    printf 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'\n+                    i=`expr \"${i}\" + 1`\n+                done\n+            ) | gzip --best | hexdump -e '32\/1 \"%02x\" \"\\n\"'\n+        *\/\n+        scenarios.add(new String[] {\n+            \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\".repeat(1000),\n+            \"\"\"\n+            1f8b08002a35a4660203edc18100000000c320d6f94b1ce45501000000000000\n+            0000000000000000000000000000000000000000000000000000000000000000\n+            c08f01492d182728a00000\"\"\" });\n+\n+        return scenarios.stream();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testScenarios\")\n+    public void testScenario(String input, String hexData) throws IOException {\n+\n+        \/\/ Get expected result\n+        final byte[] expected = input.getBytes(StandardCharsets.UTF_8);\n+\n+        \/\/ Get actual result\n+        final HexFormat hexFormat = HexFormat.of();\n+        final byte[] data = hexFormat.parseHex(hexData.replaceAll(\"\\\\s\", \"\"));\n+        final ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        try (GZIPInputStream gunzip = new GZIPInputStream(new ByteArrayInputStream(data))) {\n+            gunzip.transferTo(buf);\n+        }\n+        final byte[] actual = buf.toByteArray();\n+\n+        \/\/ Compare\n+        System.out.println(\"  ACTUAL: \" + hexFormat.formatHex(actual));\n+        System.out.println(\"EXPECTED: \" + hexFormat.formatHex(expected));\n+        assertArrayEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamGzipCommand.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"}]}