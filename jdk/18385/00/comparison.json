{"files":[{"patch":"@@ -36,2 +36,9 @@\n- * This class implements a stream filter for reading compressed data in\n- * the GZIP file format.\n+ * This class implements a stream filter for reading compressed data in the GZIP file format.\n+ *\n+ * <p>\n+ * The GZIP compressed data format is self-delimiting, i.e., it includes an explicit trailer\n+ * frame that marks the end of the compressed data. Therefore it's possible for the underlying\n+ * input to contain additional data beyond the end of the compressed GZIP data. In particular,\n+ * some GZIP compression tools will concatenate multiple compressed data streams together.\n+ * This class includes configurable support for decompressing multiple concatenated compressed\n+ * data streams as a single uncompressed data stream.\n@@ -55,0 +62,3 @@\n+    private final boolean allowConcatenation;\n+    private final boolean allowTrailingGarbage;\n+\n@@ -67,1 +77,3 @@\n-     * Creates a new input stream with the specified buffer size.\n+     * Creates a new input stream with the specified buffer size that\n+     * allows concatenated compressed streams and tolerates trailing garbage.\n+     *\n@@ -78,3 +90,1 @@\n-        super(in, in != null ? new Inflater(true) : null, size);\n-        usesDefaultInflater = true;\n-        readHeader(in);\n+        this(in, size, true, true);\n@@ -84,1 +94,3 @@\n-     * Creates a new input stream with a default buffer size.\n+     * Creates a new input stream with the default buffer size that\n+     * allows concatenated compressed streams and tolerates trailing garbage.\n+     *\n@@ -93,1 +105,52 @@\n-        this(in, 512);\n+        this(in, 512, true, true);\n+    }\n+\n+    \/**\n+     * Creates a new input stream with the specified buffer size,\n+     * support for concatenated streams, and tolerance for traliling garbage.\n+     *\n+     * <p>\n+     * When {@code allowConcatenation} is true, this class will attempt to decode any\n+     * data following a GZIP trailer frame as the start of a new compressed data stream\n+     * and proceed to decompress it, with the result that multiple concatenated compressed\n+     * data streams in the underlying input will be read back as a single uncompressed\n+     * stream. When {@code allowConcatenation} is false, decompression stops after the\n+     * first GZIP trailer frame encountered.\n+     *\n+     * <p>\n+     * The {@code allowTrailingGarbage} flag controls the behavior when data follows\n+     * the first GZIP trailer frame (if {@code allowConcatenation} is false) or when one\n+     * or more bytes of invalid GZIP header frame data appear after any GZIP trailer frame\n+     * (if {@code allowConcatenation} is true). When {@code allowTrailingGarbage} is true,\n+     * the unexpected data and\/or any {@link IOException} thrown while trying to read that\n+     * data are simply discarded and EOF is returned; when {@code allowTrailingGarbage} is\n+     * false, any unexpected data triggers an {@link IOException}, and any {@link IOException}\n+     * thrown while trying to read that data is propagated to the caller.\n+     *\n+     * @apiNote The original behavior of this class is replicated by setting both\n+     * {@code allowConcatenation} and {@code allowTrailingGarbage} to true. However,\n+     * enabling {@code allowTrailingGarbage} is discouraged because of its imprecision in\n+     * how many additional bytes are read, how underlying {@link IOException}s are handled,\n+     * and the possibility that trailing garbage could be misinterpreted as a valid GZIP\n+     * header frame.\n+     *\n+     * @param in the input stream\n+     * @param size the input buffer size\n+     * @param allowConcatenation true to allow multiple concatenated compressed data streams,\n+     *                           or false to expect exactly one compressed data stream\n+     * @param allowTrailingGarbage true to tolerate and ignore trailing garbage, false to\n+     *                             throw {@link IOException} if trailing garbage is encountered\n+     *\n+     * @throws    ZipException if a GZIP format error has occurred or the\n+     *                         compression method used is unsupported\n+     * @throws    NullPointerException if {@code in} is null\n+     * @throws    IOException if an I\/O error has occurred\n+     * @since     23\n+     *\/\n+    public GZIPInputStream(InputStream in, int size,\n+            boolean allowConcatenation, boolean allowTrailingGarbage) throws IOException {\n+        super(in, in != null ? new Inflater(true) : null, size);\n+        usesDefaultInflater = true;\n+        this.allowConcatenation = allowConcatenation;\n+        this.allowTrailingGarbage = allowTrailingGarbage;\n+        readHeader(in, -1);\n@@ -171,1 +234,3 @@\n-     * of this member header.\n+     * of this member header. Use the given value as the first byte\n+     * if not equal to -1 (and include it in the returned byte count).\n+     * Throws EOFException if there's not enough input data.\n@@ -173,1 +238,1 @@\n-    private int readHeader(InputStream this_in) throws IOException {\n+    private int readHeader(InputStream this_in, int firstByte) throws IOException {\n@@ -177,1 +242,4 @@\n-        if (readUShort(in) != GZIP_MAGIC) {\n+        int byte1 = firstByte != -1 ? firstByte : readUByte(in);\n+        int byte2 = readUByte(in);\n+        int magic = (byte2 << 8) | byte1;\n+        if (magic != GZIP_MAGIC) {\n@@ -240,6 +308,32 @@\n-        \/\/ try concatenated case\n-        int m = 8;                  \/\/ this.trailer\n-        try {\n-            m += readHeader(in);    \/\/ next.header\n-        } catch (IOException ze) {\n-            return true;  \/\/ ignore any malformed, do nothing\n+        \/\/ Keep track of how many bytes of buffered data we may have read\n+        int m = 8;                                          \/\/ this.trailer\n+\n+        \/\/ Handle concatenation and\/or trailing garbage\n+        if (allowConcatenation && allowTrailingGarbage) {   \/\/ i.e., the legacy behavior\n+            try {\n+                m += readHeader(in, -1);                    \/\/ next.header\n+            } catch (IOException ze) {\n+                return true;  \/\/ ignore any malformed, do nothing\n+            }\n+        } else {\n+\n+            \/\/ If there is no more data, the input has terminated at a proper GZIP boundary\n+            int nextByte = in.read();\n+            if (nextByte == -1)\n+                return true;\n+\n+            \/\/ There is more data. If we are not allowing concatenation, then we have trailing garbage\n+            if (!allowConcatenation) {\n+                if (!allowTrailingGarbage)\n+                    throw new ZipException(\"Trailing garbage after GZIP trailer\");\n+                return true;\n+            }\n+\n+            \/\/ We are allowing concatenation; try to read the next GZIP header\n+            try {\n+                m += readHeader(in, nextByte);              \/\/ next.header\n+            } catch (IOException e) {\n+                if (!allowTrailingGarbage)\n+                    throw e;\n+                return true;\n+            }\n@@ -247,0 +341,2 @@\n+\n+        \/\/ Pass along any remaining buffered data to the new inflater\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/GZIPInputStream.java","additions":113,"deletions":17,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8322256\n+ * @summary Test configurable support for concatenated gzip streams\n+ * @run junit GZIPInputStreamConcat\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.stream.*;\n+import java.util.zip.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+\n+public class GZIPInputStreamConcat {\n+\n+    private int bufsize;\n+    private boolean allowConcatenation;\n+    private boolean allowTrailingGarbage;\n+\n+    public static Stream<Object[]> testScenarios() throws IOException {\n+\n+        \/\/ Test concat vs. non-concat, garbage vs. no-garbage, and various buffer sizes on random data\n+        Random random = new Random();\n+        final ArrayList<List<Object>> scenarios = new ArrayList<>();\n+        for (boolean concat : new boolean[] { false, true }) {\n+            for (boolean garbage : new boolean[] { false, true }) {\n+                for (int size = 1; size < 1024; size += random.nextInt(32) + 1) {\n+                    scenarios.add(List.of(randomData(0, 100), size, concat, garbage));\n+                }\n+            }\n+        }\n+        return scenarios.stream().map(List::toArray);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testScenarios\")\n+    public void testScenario(byte[] uncompressed, int size, boolean concat, boolean garbage) throws IOException {\n+        this.bufsize = size;\n+        this.allowConcatenation = concat;\n+        this.allowTrailingGarbage = garbage;\n+        testScenario(uncompressed);\n+    }\n+\n+    public void testScenario(byte[] uncompressed) throws IOException {\n+\n+        \/\/ Compress the test data\n+        byte[] compressed = deflate(uncompressed);\n+\n+        \/\/ Decompress a single stream with no extra garbage - should always work\n+        byte[] input = compressed;\n+        byte[] output = uncompressed;\n+        testDecomp(input, output, null);\n+\n+        \/\/ Decompress a truncated GZIP header\n+        input = oneByteShort(gzipHeader());\n+        testDecomp(input, null, EOFException.class);\n+\n+        \/\/ Decompress a single stream that is one byte short - should always fail\n+        input = oneByteShort(compressed);\n+        output = null;\n+        testDecomp(input, null, EOFException.class);\n+\n+        \/\/ Decompress a single stream with one byte of extra garbage (trying all 256 possible values)\n+        for (int extra = 0; extra < 0x100; extra++) {\n+            input = oneByteLong(compressed, extra);\n+            output = uncompressed;\n+            testDecomp(input, output, !allowTrailingGarbage ? IOException.class : null);\n+        }\n+\n+        \/\/ Decompress a single stream followed by a truncated GZIP header\n+        input = concat(compressed, oneByteShort(gzipHeader()));\n+        output = uncompressed;\n+        testDecomp(input, output, !allowTrailingGarbage ? IOException.class : null);\n+\n+        \/\/ Decompress a single stream followed by another stream that is one byte short\n+        input = concat(compressed, oneByteShort(compressed));\n+        output = uncompressed;\n+        testDecomp(input, output, allowConcatenation || !allowTrailingGarbage ? IOException.class : null);\n+\n+        \/\/ Decompress two streams concatenated\n+        input = concat(compressed, compressed);\n+        output = allowConcatenation ? concat(uncompressed, uncompressed) : uncompressed;\n+        testDecomp(input, output, !allowConcatenation && !allowTrailingGarbage ? ZipException.class : null);\n+\n+        \/\/ Decompress three streams concatenated\n+        input = concat(compressed, compressed, compressed);\n+        output = allowConcatenation ? concat(uncompressed, uncompressed, uncompressed) : uncompressed;\n+        testDecomp(input, output, !allowConcatenation && !allowTrailingGarbage ? ZipException.class : null);\n+\n+        \/\/ Decompress three streams concatenated followed by a truncated GZIP header\n+        input = concat(compressed, compressed, compressed, oneByteShort(gzipHeader()));\n+        output = allowConcatenation ? concat(uncompressed, uncompressed, uncompressed) : uncompressed;\n+        testDecomp(input, output, !allowTrailingGarbage ? IOException.class : null);\n+    }\n+\n+    \/\/ Do decompression and check result\n+    public void testDecomp(byte[] compressed, byte[] uncompressed, Class<? extends IOException> exceptionType) {\n+        try {\n+            byte[] readback = inflate(new ByteArrayInputStream(compressed));\n+            if (exceptionType != null)\n+                throw new AssertionError(\"expected \" + exceptionType.getSimpleName());\n+            assertArrayEquals(uncompressed, readback);\n+        } catch (IOException e) {\n+            if (exceptionType == null)\n+                throw new AssertionError(\"unexpected exception\", e);\n+            if (!exceptionType.isAssignableFrom(e.getClass())) {\n+                throw new AssertionError(String.format(\n+                  \"expected %s but got %s\", exceptionType.getSimpleName(), e.getClass().getSimpleName()), e);\n+            }\n+        }\n+    }\n+\n+    \/\/ Create a GZIP header\n+    public static byte[] gzipHeader() throws IOException {\n+        byte[] compressed = deflate(new byte[0]);\n+        return Arrays.copyOfRange(compressed, 0, 10);\n+    }\n+\n+    \/\/ Add one extra byte to the given array\n+    public static byte[] oneByteLong(byte[] array, int value) {\n+        byte[] array2 = new byte[array.length + 1];\n+        System.arraycopy(array, 0, array2, 0, array.length);\n+        array2[array.length] = (byte)value;\n+        return array2;\n+    }\n+\n+    \/\/ Chop off the last byte of the given array\n+    public static byte[] oneByteShort(byte[] array) {\n+        return Arrays.copyOfRange(array, 0, array.length - 1);\n+    }\n+\n+    \/\/ Create some random data\n+    public static byte[] randomData(int min, int max) {\n+        Random random = new Random();\n+        byte[] data = new byte[min + random.nextInt(max - min)];\n+        random.nextBytes(data);\n+        return data;\n+    }\n+\n+    \/\/ Concatenate byte arrays\n+    public static byte[] concat(byte[]... arrays) {\n+        final ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        for (byte[] array : arrays)\n+            buf.writeBytes(array);\n+        return buf.toByteArray();\n+    }\n+\n+    \/\/ GZIP compress data\n+    public static byte[] deflate(byte[] data) throws IOException {\n+        ByteArrayOutputStream buf = new ByteArrayOutputStream();\n+        try (GZIPOutputStream out = new GZIPOutputStream(buf)) {\n+            out.write(data);\n+        }\n+        return buf.toByteArray();\n+    }\n+\n+    \/\/ GZIP decompress data\n+    public byte[] inflate(InputStream in) throws IOException {\n+        return new GZIPInputStream(in, bufsize, allowConcatenation, allowTrailingGarbage).readAllBytes();\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/GZIP\/GZIPInputStreamConcat.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"}]}