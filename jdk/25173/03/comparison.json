{"files":[{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.math.FormattedFPDecimal;\n@@ -1396,5 +1397,12 @@\n-        \/\/ Reminder: a zero double returns '0.0', so we cannot fastpath\n-        \/\/ to use the constant ZERO.  This might be important enough to\n-        \/\/ justify a factory approach, a cache, or a few private\n-        \/\/ constants, later.\n-        return new BigDecimal(Double.toString(val));\n+        if (!Double.isFinite(val)) {\n+            throw new NumberFormatException(\"Infinite or NaN\");\n+        }\n+\n+        var fmt = FormattedFPDecimal.valueForDoubleToString(Math.abs(val));\n+        long s = fmt.getSignificand();\n+        if (val < 0) {\n+            \/\/ Original s is never negative, so no overflow\n+            s = -s;\n+        }\n+\n+        return valueOf(s, -fmt.getExp(), fmt.getPrecision());\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,1 @@\n-        FormattedFPDecimal fd = new FormattedFPDecimal();\n-        DoubleToDecimal.split(v, fd);\n+        FormattedFPDecimal fd = split(v);\n@@ -72,0 +71,68 @@\n+    private static FormattedFPDecimal split(double v) {\n+        FormattedFPDecimal fd = new FormattedFPDecimal();\n+        DoubleToDecimal.split(v, fd);\n+        return fd;\n+    }\n+\n+    \/**\n+     * Returns a FormattedFPDecimal with the appropriate precision for\n+     * {@link Double#toString(double)}.\n+     *\n+     * @see java.math.BigDecimal#valueOf(double)\n+     *\/\n+    public static FormattedFPDecimal valueForDoubleToString(double v) {\n+        final FormattedFPDecimal fd = split(v);\n+        final int expR = fd.getExponentRounded();\n+\n+        \/\/ Adjust precision, following rules for Double.toString. There is\n+        \/\/ always at least one digit and some cases require an extra one to\n+        \/\/ force a digit after the decimal. No additional rounding is performed;\n+        \/\/ no significant trailing digits are removed.\n+\n+        final int targetPrec =\n+                \/\/ No extra trailing digit needed\n+                (-3 <= expR && expR < 0) ? 1\n+\n+                \/\/ Keep digits to left of decimal, plus leave a trailing zero\n+                : (0 <= expR && expR < 7) ? expR + 2 :\n+\n+                \/\/ Otherwise, require at least 2 digits, to include trailing\n+                \/\/ digit when there is a single digit\n+                2;\n+\n+\n+        long s = fd.f;\n+        int prec = fd.n;\n+\n+        if (prec < targetPrec) {\n+            \/\/ Add zeros needed to reach target precision\n+            final int addZeros = targetPrec - prec;\n+            s *= MathUtils.pow10(addZeros); \/\/ addZeros will be at most 8\n+            prec = targetPrec;\n+        } else {\n+            \/\/ Remove trailing zeros to try to reach target precision\n+            while (prec > targetPrec && s % 10 == 0) {\n+                s = s \/ 10;\n+                prec--;\n+            }\n+        }\n+\n+        \/\/ Calculate new e based on updated precision\n+        final int eNew = expR - prec + 1;  \/\/ expR is defined as prec + e - 1\n+        fd.set(s, eNew, prec);\n+\n+        return fd;\n+    }\n+\n+    public long getSignificand() {\n+        return f;\n+    }\n+\n+    public int getPrecision() {\n+        return n;\n+    }\n+\n+    public int getExp() {\n+        return e;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FormattedFPDecimal.java","additions":70,"deletions":3,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356709\n+ * @summary Test Double.toString(double)\n+ * @run junit ValueOfDouble\n+ *\/\n+\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.math.BigDecimal;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\n+public class ValueOfDouble {\n+    private static final String DIGITS = \"1234567000003456789\"; \/\/ Enough digits to fill a long\n+\n+    @Test\n+    public void testValueOfDouble() {\n+        checkValue(0.0);\n+        checkValue(-0.0);\n+        checkValue(Math.PI);\n+        checkValue(-Math.PI);\n+        checkValue(Double.MAX_VALUE);\n+        checkValue(Double.MIN_VALUE);\n+        checkValue(1e-44); \/\/ Lots of digits with lots of 9s\n+\n+        for (int prec = 1; prec < DIGITS.length(); prec++) {\n+            String prefix = DIGITS.substring(0, prec);\n+            for (int exp = -30; exp < 30; exp++) {\n+                double value = Double.parseDouble(prefix + \"e\" + exp);\n+                checkValue(value);\n+                checkValue(-value);\n+            }\n+        }\n+    }\n+\n+    private static void checkValue(double value) {\n+        BigDecimal expected = new BigDecimal(Double.toString(value));\n+        assertEquals(expected, BigDecimal.valueOf(value));\n+    }\n+\n+    @Test\n+    public void testExceptions() {\n+        assertThrows(NumberFormatException.class, () -> BigDecimal.valueOf(Double.NaN));\n+        assertThrows(NumberFormatException.class, () -> BigDecimal.valueOf(Double.POSITIVE_INFINITY));\n+        assertThrows(NumberFormatException.class, () -> BigDecimal.valueOf(Double.NEGATIVE_INFINITY));\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ValueOfDouble.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,0 +230,19 @@\n+\n+\n+    \/** Invokes the valueOf(double) of BigDecimal with various different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testValueOfWithDouble(Blackhole bh) {\n+        for (double s : doubleInputs) {\n+            bh.consume(BigDecimal.valueOf(s));\n+        }\n+    }\n+\n+    \/** Create BigDecimal from double with Double.toString on different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testValueOfWithDoubleString(Blackhole bh) {\n+        for (double s : doubleInputs) {\n+            bh.consume(new BigDecimal(Double.toString(s)));\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"}]}