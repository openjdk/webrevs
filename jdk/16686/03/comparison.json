{"files":[{"patch":"@@ -55,0 +55,1 @@\n+bool JvmtiThreadState::_seen_interp_only_mode = false;\n@@ -529,5 +530,8 @@\n-  JvmtiEventController::thread_started(thread);\n-  if (JvmtiExport::can_support_virtual_threads()) {\n-    if (JvmtiExport::should_post_vthread_start()) {\n-      JvmtiExport::post_vthread_start(vthread);\n-    }\n+  \/\/ If interp_only_mode is enabled then we must eagerly create JvmtiThreadState\n+  \/\/ objects for globally enabled virtual thread filtered events. Otherwise,\n+  \/\/ it is an important optimization to create JvmtiThreadState objects lazily.\n+  if (JvmtiThreadState::seen_interp_only_mode()) {\n+    JvmtiEventController::thread_started(thread);\n+  }\n+  if (JvmtiExport::should_post_vthread_start()) {\n+    JvmtiExport::post_vthread_start(vthread);\n@@ -552,4 +556,2 @@\n-  if (JvmtiExport::can_support_virtual_threads()) {\n-    if (JvmtiExport::should_post_vthread_end()) {\n-      JvmtiExport::post_vthread_end(vthread);\n-    }\n+  if (JvmtiExport::should_post_vthread_end()) {\n+    JvmtiExport::post_vthread_end(vthread);\n@@ -605,1 +607,2 @@\n-  {\n+  JvmtiThreadState* state = thread->jvmti_thread_state();\n+  if (state != nullptr && state->is_pending_interp_only_mode()) {\n@@ -607,1 +610,1 @@\n-    JvmtiThreadState* state = thread->jvmti_thread_state();\n+    state = thread->jvmti_thread_state();\n@@ -746,0 +749,1 @@\n+  _seen_interp_only_mode = true;\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -234,0 +234,2 @@\n+  static bool _seen_interp_only_mode; \/\/ interp_only_mode was requested once\n+\n@@ -253,0 +255,5 @@\n+  \/\/ Return true if any thread has entered interp_only_mode at any point during the JVMs execution.\n+  static bool seen_interp_only_mode() {\n+    return _seen_interp_only_mode;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}