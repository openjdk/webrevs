{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -400,10 +401,0 @@\n-    private String readAllCharsAsString() throws IOException {\n-        StringBuilder result = new StringBuilder();\n-        char[] cbuf = new char[TRANSFER_BUFFER_SIZE];\n-        int nread;\n-        while ((nread = read(cbuf, 0, cbuf.length)) != -1) {\n-            result.append(cbuf, 0, nread);\n-        }\n-        return result.toString();\n-    }\n-\n@@ -460,1 +451,58 @@\n-        return readAllCharsAsString().lines().toList();\n+        char[] cb = new char[TRANSFER_BUFFER_SIZE];\n+        int pos = 0;\n+        List<String> lines = new ArrayList<String>();\n+\n+        StringBuilder sb = new StringBuilder(82);\n+        int n = read(cb, 0, cb.length);\n+        boolean eos = (n == -1);\n+        while (!eos) {\n+            boolean eol = false;\n+            boolean stringAdded = false;\n+            while (!eol) {\n+                \/\/ Find the next line terminator. If none is found,\n+                \/\/ \"term\" will equal \"n\".\n+                int term = pos;\n+                while (term < n) {\n+                    char c = cb[term];\n+                    if (c == '\\r' || c == '\\n')\n+                        break;\n+                    term++;\n+                }\n+\n+                \/\/ Terminator found so at EOL.\n+                if (term < n)\n+                    eol = true;\n+\n+                if (term == pos) {\n+                    \/\/ Current position is terminator so skip it.\n+                    pos++;\n+                } else { \/\/ term > pos\n+                    if (eol && sb.length() == 0) {\n+                        \/\/ Create and add a string to avoid the StringBuilder.\n+                        lines.add(new String(cb, pos, term - pos));\n+                        stringAdded = true;\n+                    } else\n+                        sb.append(cb, pos, term - pos);\n+                    pos = term + 1;\n+                }\n+\n+                if (pos >= n) {\n+                    \/\/ Buffer content consumed so reload it.\n+                    if ((n = read(cb, 0, cb.length)) < 0) {\n+                        eos = eol = true;\n+                        break;\n+                    }\n+                    pos = 0;\n+                }\n+            }\n+\n+            if (!stringAdded) {\n+                \/\/ Derive a string and add it to the list.\n+                lines.add(sb.toString());\n+                sb.setLength(0);\n+            }\n+\n+            eol = false;\n+        }\n+\n+        return lines;\n@@ -502,1 +550,7 @@\n-        return readAllCharsAsString();\n+        StringBuilder result = new StringBuilder();\n+        char[] cbuf = new char[TRANSFER_BUFFER_SIZE];\n+        int nread;\n+        while ((nread = read(cbuf, 0, cbuf.length)) != -1) {\n+            result.append(cbuf, 0, nread);\n+        }\n+        return result.toString();\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":66,"deletions":12,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.io;\n+\n+import java.io.CharArrayReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+@State(Scope.Benchmark)\n+public class ReaderReadAllLines {\n+\n+    private char[] chars = null;\n+\n+    @Setup\n+    public void setup() throws IOException {\n+        final int len = 128_000;\n+        chars = new char[len];\n+        Random rnd = new Random(System.nanoTime());\n+        int off = 0;\n+        while (off < len) {\n+            int lineLen = 40 + rnd.nextInt(40);\n+            if (lineLen > len - off) {\n+                off = len;\n+            } else {\n+                chars[off + lineLen] = '\\n';\n+                off += lineLen;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public List<String> readAllLines() throws IOException {\n+        List<String> lines;\n+        try (Reader reader = new CharArrayReader(chars);) {\n+            lines = reader.readAllLines();\n+        }\n+        return lines;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/ReaderReadAllLines.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}