{"files":[{"patch":"@@ -30,0 +30,2 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n@@ -400,10 +402,0 @@\n-    private String readAllCharsAsString() throws IOException {\n-        StringBuilder result = new StringBuilder();\n-        char[] cbuf = new char[TRANSFER_BUFFER_SIZE];\n-        int nread;\n-        while ((nread = read(cbuf, 0, cbuf.length)) != -1) {\n-            result.append(cbuf, 0, nread);\n-        }\n-        return result.toString();\n-    }\n-\n@@ -460,1 +452,67 @@\n-        return readAllCharsAsString().lines().toList();\n+        List<String> lines = new ArrayList<>();\n+\n+        int writePos = 0;\n+        int fragPos = -1;\n+        int fragLen = 0;\n+\n+        char[] cb = new char[TRANSFER_BUFFER_SIZE];\n+        boolean skipLF = false;\n+        int n;\n+        while ((n = read(cb, writePos, cb.length - writePos)) != -1) {\n+            int pos = writePos;\n+            int limit = pos + n;\n+            while (pos < limit) {\n+                \/\/ find next line terminator\n+                int term = pos;\n+                while (term < limit) {\n+                    char c = cb[term];\n+                    if (c == '\\n' || c == '\\r')\n+                        break;\n+                    term++;\n+                }\n+\n+                if (term < limit) { \/\/ line terminator\n+                    boolean isCR = (cb[term] == '\\r');\n+                    if (isCR || !(skipLF && term == pos)) {\n+                        \/\/ line terminator is a CR or an LF just after a CR\n+                        if (fragPos != -1) {\n+                            lines.add(new String(cb, fragPos, term - fragPos));\n+                            fragPos = -1;\n+                        } else {\n+                            lines.add(new String(cb, pos, term - pos));\n+                        }\n+                    }\n+                    pos = term + 1;\n+                    if (pos == limit)\n+                        writePos = 0;\n+                    skipLF = isCR;\n+                } else { \/\/ no line terminator\n+                    int len = term - pos;\n+                    if (fragPos == -1) {\n+                        fragPos = pos;\n+                        fragLen = len;\n+                    } else {\n+                        fragLen += len;\n+                    }\n+                    if (fragLen >= cb.length\/2) {\n+                        \/\/ allocate larger buffer and copy chars to beginning\n+                        char[] tmp = new char[2*cb.length];\n+                        System.arraycopy(cb, fragPos, tmp, 0, fragLen);\n+                        cb = tmp;\n+                    } else if (fragPos != 0) {\n+                        \/\/ move fragment to beginning of buffer\n+                        System.arraycopy(cb, fragPos, cb, 0, fragLen);\n+                    }\n+                    writePos = fragLen;\n+                    fragPos = 0;\n+                    pos = limit;\n+                    skipLF = false;\n+                }\n+            }\n+        }\n+\n+        \/\/ add a string if EOS terminates the last line\n+        if (fragPos != -1)\n+            lines.add(new String(cb, fragPos, fragLen));\n+\n+        return Collections.unmodifiableList(lines);\n@@ -502,1 +560,7 @@\n-        return readAllCharsAsString();\n+        StringBuilder result = new StringBuilder();\n+        char[] cbuf = new char[TRANSFER_BUFFER_SIZE];\n+        int nread;\n+        while ((nread = read(cbuf, 0, cbuf.length)) != -1) {\n+            result.append(cbuf, 0, nread);\n+        }\n+        return result.toString();\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":76,"deletions":12,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-        List<String> strings = new ArrayList<String>(size);\n+        StringBuilder sb = new StringBuilder(plen);\n+        List<String> strings = new ArrayList<>(size);\n@@ -73,1 +74,22 @@\n-            strings.add(PHRASE.substring(fromIndex, toIndex));\n+            String s = PHRASE.substring(fromIndex, toIndex);\n+            sb.append(s);\n+            int bound = toIndex - fromIndex;\n+            if (bound > 0) {\n+                int offset = bound\/2;\n+                int n = rnd.nextInt(0, bound);\n+                for (int i = 0; i < n; i++) {\n+                    String f = null;\n+                    switch (rnd.nextInt(7)) {\n+                    case 0 -> f = \"\";\n+                    case 1 -> f = \"\\r\";\n+                    case 2 -> f = \"\\n\";\n+                    case 3 -> f = \"\\r\\n\";\n+                    case 4 -> f = \"\\r\\r\";\n+                    case 5 -> f = \"\\n\\n\";\n+                    case 6 -> f = \" \";\n+                    }\n+                    sb.insert(offset, f);\n+                }\n+            }\n+            strings.add(sb.toString());\n+            sb.setLength(0);\n@@ -75,0 +97,21 @@\n+\n+        String p4096  = PHRASE.repeat((4096 + plen - 1)\/plen);\n+        String p8192  = PHRASE.repeat((8192 + plen - 1)\/plen);\n+        String p16384 = PHRASE.repeat((16384 + plen - 1)\/plen);\n+\n+        for (int i = 0; i < 64; i++) {\n+            for (int j = 0; j < 32; j++) {\n+                switch (rnd.nextInt(8)) {\n+                case 0 -> sb.append(\"\");\n+                case 1 -> sb.append(\" \");\n+                case 2 -> sb.append(\"\\n\");\n+                case 3 -> sb.append(PHRASE);\n+                case 5 -> sb.append(p4096);\n+                case 6 -> sb.append(p8192);\n+                case 7 -> sb.append(p16384);\n+                }\n+            }\n+            strings.add(sb.toString());\n+            sb.setLength(0);\n+        }\n+\n@@ -88,0 +131,1 @@\n+        System.out.println(\"Reader implementation\");\n@@ -95,1 +139,12 @@\n-        assertEquals(linesExpected, lines);\n+        int count = linesExpected.size();\n+        if (lines.size() != count)\n+            throw new RuntimeException(\"Size mismatch: \" + lines.size() + \" != \" + count);\n+        for (int i = 0; i < count; i++) {\n+            String expected = linesExpected.get(i);\n+            String actual = lines.get(i);\n+            if (!actual.equals(expected)) {\n+                String msg = String.format(\"%d: \\\"%s\\\" != \\\"%s\\\"\",\n+                                           i, actual, expected);\n+                throw new RuntimeException(msg);\n+            }\n+        }\n@@ -98,0 +153,1 @@\n+        System.out.println(\"Reader.of implementation\");\n@@ -106,1 +162,12 @@\n-        assertEquals(linesExpected, lines);\n+        count = linesExpected.size();\n+        if (lines.size() != count)\n+            throw new RuntimeException(\"Size mismatch: \" + lines.size() + \" != \" + count);\n+        for (int i = 0; i < count; i++) {\n+            String expected = linesExpected.get(i);\n+            String actual = lines.get(i);\n+            if (!actual.equals(expected)) {\n+                String msg = String.format(\"%d: \\\"%s\\\" != \\\"%s\\\"\",\n+                                           i, actual, expected);\n+                throw new RuntimeException(msg);\n+            }\n+        }\n","filename":"test\/jdk\/java\/io\/Reader\/ReadAll.java","additions":71,"deletions":4,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.io;\n+\n+import java.io.CharArrayReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+@State(Scope.Benchmark)\n+public class ReaderReadAllLines {\n+\n+    private char[] chars = null;\n+\n+    @Setup\n+    public void setup() throws IOException {\n+        final int len = 128_000;\n+        chars = new char[len];\n+        Random rnd = new Random(System.nanoTime());\n+        int off = 0;\n+        while (off < len) {\n+            int lineLen = 40 + rnd.nextInt(8192);\n+            if (lineLen > len - off) {\n+                off = len;\n+            } else {\n+                chars[off + lineLen] = '\\n';\n+                off += lineLen;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public List<String> readAllLines() throws IOException {\n+        List<String> lines;\n+        try (Reader reader = new CharArrayReader(chars)) {\n+            lines = reader.readAllLines();\n+        }\n+        return lines;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/io\/ReaderReadAllLines.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}