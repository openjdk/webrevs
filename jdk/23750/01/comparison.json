{"files":[{"patch":"@@ -748,1 +748,17 @@\n-  ts = _local_table->statistics_get(Thread::current(), sz, ts);\n+\n+  Thread* jt = Thread::current();\n+  StringTableHash::StatisticsTask sts(_local_table);\n+  if (!sts.prepare(jt)) {\n+    return ts;  \/\/ return old table statistics\n+  }\n+  {\n+    TraceTime timer(\"GetStatistics\", TRACETIME_LOG(Debug, stringtable, perf));\n+    while (sts.do_task(jt, sz)) {\n+      sts.pause(jt);\n+      if (jt->is_Java_thread()) {\n+        ThreadBlockInVM tbivm(JavaThread::cast(jt));\n+      }\n+      sts.cont(jt);\n+    }\n+  }\n+  ts = sts.done(jt);\n@@ -753,2 +769,2 @@\n-  SizeFunc sz;\n-  _local_table->statistics_to(Thread::current(), sz, st, \"StringTable\");\n+  TableStatistics ts = get_table_statistics();\n+  ts.print(st, \"StringTable\");\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -575,2 +575,3 @@\n-struct SizeFunc : StackObj {\n-  size_t operator()(Symbol* value) {\n+TableStatistics SymbolTable::get_table_statistics() {\n+  static TableStatistics ts;\n+  auto sz = [&](Symbol* value) {\n@@ -580,1 +581,0 @@\n-};\n@@ -582,4 +582,16 @@\n-TableStatistics SymbolTable::get_table_statistics() {\n-  static TableStatistics ts;\n-  SizeFunc sz;\n-  ts = _local_table->statistics_get(Thread::current(), sz, ts);\n+  Thread* jt = Thread::current();\n+  SymbolTableHash::StatisticsTask sts(_local_table);\n+  if (!sts.prepare(jt)) {\n+    return ts;  \/\/ return old table statistics\n+  }\n+  {\n+    TraceTime timer(\"GetStatistics\", TRACETIME_LOG(Debug, symboltable, perf));\n+    while (sts.do_task(jt, sz)) {\n+      sts.pause(jt);\n+      if (jt->is_Java_thread()) {\n+        ThreadBlockInVM tbivm(JavaThread::cast(jt));\n+      }\n+      sts.cont(jt);\n+    }\n+  }\n+  ts = sts.done(jt);\n@@ -587,1 +599,1 @@\n-}\n+};\n@@ -590,2 +602,2 @@\n-  SizeFunc sz;\n-  _local_table->statistics_to(Thread::current(), sz, st, \"SymbolTable\");\n+  TableStatistics ts = get_table_statistics();\n+  ts.print(st, \"SymbolTable\");\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-  \/\/ Calculate statistics. Item sizes are calculated with VALUE_SIZE_FUNC.\n+  \/\/ Calculate statistics. Item sizes are calculated with VALUE_SIZE_FUNC, and accumulated in summary and literal_size.\n@@ -61,1 +61,4 @@\n-  TableStatistics statistics_calculate(Thread* thread, VALUE_SIZE_FUNC& vs_f);\n+  void internal_statistics_range(Thread* thread, size_t start, size_t stop,\n+                                 VALUE_SIZE_FUNC& sts_f, NumberSeq& summary, size_t& literal_size);\n+\n+  TableStatistics internal_statistics_epilog(Thread* thread, NumberSeq summary, size_t literal_size);\n@@ -534,6 +537,0 @@\n-  \/\/ Writes statistics to the outputStream. Item sizes are calculated with\n-  \/\/ VALUE_SIZE_FUNC.\n-  template <typename VALUE_SIZE_FUNC>\n-  void statistics_to(Thread* thread, VALUE_SIZE_FUNC& vs_f, outputStream* st,\n-                     const char* table_name);\n-\n@@ -562,0 +559,1 @@\n+  class StatisticsTask;\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1235,2 +1235,3 @@\n-inline TableStatistics ConcurrentHashTable<CONFIG, MT>::\n-  statistics_calculate(Thread* thread, VALUE_SIZE_FUNC& vs_f)\n+inline void ConcurrentHashTable<CONFIG, MT>::\n+  internal_statistics_range(Thread* thread, size_t start, size_t stop,\n+                            VALUE_SIZE_FUNC& vs_f, NumberSeq& summary, size_t& literal_size)\n@@ -1238,23 +1239,8 @@\n-  constexpr size_t batch_size = 128;\n-  NumberSeq summary;\n-  size_t literal_bytes = 0;\n-  InternalTable* table = get_table();\n-  size_t num_batches = table->_size \/ batch_size;\n-  for (size_t batch_start = 0; batch_start < _table->_size; batch_start += batch_size) {\n-    \/\/ We batch the use of ScopedCS here as it has been found to be quite expensive to\n-    \/\/ invoke it for every single bucket.\n-    size_t batch_end = MIN2(batch_start + batch_size, _table->_size);\n-    ScopedCS cs(thread, this);\n-    for (size_t bucket_it = batch_start; bucket_it < batch_end; bucket_it++) {\n-      size_t count = 0;\n-      Bucket* bucket = table->get_bucket(bucket_it);\n-      if (bucket->have_redirect() || bucket->is_locked()) {\n-        continue;\n-      }\n-      Node* current_node = bucket->first();\n-      while (current_node != nullptr) {\n-        ++count;\n-        literal_bytes += vs_f(current_node->value());\n-        current_node = current_node->next();\n-      }\n-      summary.add((double)count);\n+  \/\/ We batch the use of ScopedCS here as it has been found to be quite expensive to\n+  \/\/ invoke it for every single bucket.\n+  ScopedCS cs(thread, this);\n+  for (size_t bucket_it = start; bucket_it < stop; bucket_it++) {\n+    size_t count = 0;\n+    Bucket* bucket = _table->get_bucket(bucket_it);\n+    if (bucket->have_redirect() || bucket->is_locked()) {\n+      continue;\n@@ -1262,0 +1248,7 @@\n+    Node* current_node = bucket->first();\n+    while (current_node != nullptr) {\n+      ++count;\n+      literal_size += vs_f(current_node->value());\n+      current_node = current_node->next();\n+    }\n+    summary.add((double)count);\n@@ -1263,0 +1256,1 @@\n+}\n@@ -1264,0 +1258,5 @@\n+template <typename CONFIG, MemTag MT>\n+inline TableStatistics ConcurrentHashTable<CONFIG, MT>::\n+  internal_statistics_epilog(Thread* thread, NumberSeq summary, size_t literal_bytes)\n+{\n+  unlock_resize_lock(thread);\n@@ -1279,0 +1278,3 @@\n+  InternalTable* table = get_table();\n+  NumberSeq summary;\n+  size_t    literal_bytes = 0;\n@@ -1280,21 +1282,2 @@\n-  TableStatistics ts = statistics_calculate(thread, vs_f);\n-  unlock_resize_lock(thread);\n-\n-  return ts;\n-}\n-\n-template <typename CONFIG, MemTag MT>\n-template <typename VALUE_SIZE_FUNC>\n-inline void ConcurrentHashTable<CONFIG, MT>::\n-  statistics_to(Thread* thread, VALUE_SIZE_FUNC& vs_f,\n-                outputStream* st, const char* table_name)\n-{\n-  if (!try_resize_lock(thread)) {\n-    st->print_cr(\"statistics unavailable at this moment\");\n-    return;\n-  }\n-\n-  TableStatistics ts = statistics_calculate(thread, vs_f);\n-  unlock_resize_lock(thread);\n-\n-  ts.print(st, table_name);\n+  internal_statistics_range(thread, 0, table->_size, vs_f, summary, literal_bytes);\n+  return internal_statistics_epilog(thread, summary, literal_bytes);\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":29,"deletions":46,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,0 +232,44 @@\n+template <typename CONFIG, MemTag MT>\n+class ConcurrentHashTable<CONFIG, MT>::StatisticsTask :\n+  public BucketsOperation\n+{\n+  NumberSeq _summary;\n+  size_t    _literal_bytes;\n+ public:\n+  StatisticsTask(ConcurrentHashTable<CONFIG, MT>* cht) : BucketsOperation(cht), _literal_bytes(0) { }\n+\n+  \/\/ Before start prepare must be called.\n+  bool prepare(Thread* thread) {\n+    bool lock = BucketsOperation::_cht->try_resize_lock(thread);\n+    if (!lock) {\n+      return false;\n+    }\n+\n+    this->setup(thread);\n+    return true;\n+  }\n+\n+  \/\/ Scans part of the table adding to statistics.\n+  template <typename VALUE_SIZE_FUNC>\n+  bool do_task(Thread* thread, VALUE_SIZE_FUNC& sz) {\n+    size_t start, stop;\n+    assert(BucketsOperation::_cht->_resize_lock_owner != nullptr,\n+           \"Should be locked\");\n+    if (!this->claim(&start, &stop)) {\n+      return false;\n+    }\n+    BucketsOperation::_cht->internal_statistics_range(thread, start, stop, sz, _summary, _literal_bytes);\n+    assert(BucketsOperation::_cht->_resize_lock_owner != nullptr,\n+           \"Should be locked\");\n+    return true;\n+  }\n+\n+  \/\/ Must be called after do_task returns false.\n+  TableStatistics done(Thread* thread) {\n+    this->thread_owns_resize_lock(thread);\n+    TableStatistics ts = BucketsOperation::_cht->internal_statistics_epilog(thread, _summary, _literal_bytes);\n+    this->thread_do_not_own_resize_lock(thread);\n+    return ts;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTableTasks.inline.hpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"}]}