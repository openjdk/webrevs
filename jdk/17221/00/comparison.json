{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,4 @@\n+import jdk.internal.access.JavaIOPrintStreamAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.InternalLock;\n+import jdk.internal.vm.Continuation;\n@@ -45,1 +49,2 @@\n-    static final StackWalker STACK_WALKER;\n+    private static final JavaIOPrintStreamAccess JIOPSA = SharedSecrets.getJavaIOPrintStreamAccess();\n+    private static final StackWalker STACK_WALKER;\n@@ -89,1 +94,10 @@\n-     * Prints the continuation stack trace.\n+     * Returns true if the frame is native, a class initializer, or holds monitors.\n+     *\/\n+    private static boolean isInterestingFrame(LiveStackFrame f) {\n+        return f.isNativeMethod()\n+                || \"<clinit>\".equals(f.getMethodName())\n+                || (f.getMonitors().length > 0);\n+    }\n+\n+    \/**\n+     * Prints the current thread's stack trace.\n@@ -94,1 +108,1 @@\n-    static void printStackTrace(PrintStream out, boolean printAll) {\n+    static void printStackTrace(PrintStream out, Continuation.Pinned reason, boolean printAll) {\n@@ -100,0 +114,15 @@\n+        Object lockObj = JIOPSA.lock(out);\n+        if (lockObj instanceof InternalLock lock && lock.tryLock()) {\n+            try {\n+                \/\/ find the closest frame that is causing the thread to be pinned\n+                stack.stream()\n+                    .filter(f -> isInterestingFrame(f))\n+                    .map(LiveStackFrame::getDeclaringClass)\n+                    .findFirst()\n+                    .ifPresentOrElse(klass -> {\n+                        \/\/ print the stack trace if not already seen\n+                        int hash = hash(stack);\n+                        if (HASHES.get(klass).add(hash)) {\n+                            printStackTrace(out, reason, stack, printAll);\n+                        }\n+                    }, () -> printStackTrace(out, reason, stack, true));  \/\/ not found\n@@ -101,15 +130,4 @@\n-        \/\/ find the closest frame that is causing the thread to be pinned\n-        stack.stream()\n-            .filter(f -> (f.isNativeMethod() || f.getMonitors().length > 0))\n-            .map(LiveStackFrame::getDeclaringClass)\n-            .findFirst()\n-            .ifPresentOrElse(klass -> {\n-                int hash = hash(stack);\n-                Hashes hashes = HASHES.get(klass);\n-                synchronized (hashes) {\n-                    \/\/ print the stack trace if not already seen\n-                    if (hashes.add(hash)) {\n-                        printStackTrace(stack, out, printAll);\n-                    }\n-                }\n-            }, () -> printStackTrace(stack, out, true));  \/\/ not found\n+            } finally {\n+                lock.unlock();\n+            }\n+        }\n@@ -118,2 +136,3 @@\n-    private static void printStackTrace(List<LiveStackFrame> stack,\n-                                        PrintStream out,\n+    private static void printStackTrace(PrintStream out,\n+                                        Continuation.Pinned reason,\n+                                        List<LiveStackFrame> stack,\n@@ -121,1 +140,1 @@\n-        out.println(Thread.currentThread());\n+        out.format(\"%s reason:%s%n\", Thread.currentThread(), reason);\n@@ -127,1 +146,1 @@\n-            } else if (frame.isNativeMethod() || printAll) {\n+            } else if (printAll || isInterestingFrame(frame)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/PinnedThreadPrinter.java","additions":42,"deletions":23,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -194,1 +194,9 @@\n-                PinnedThreadPrinter.printStackTrace(System.out, printAll);\n+                VirtualThread vthread = (VirtualThread) Thread.currentThread();\n+                int oldState = vthread.state();\n+                try {\n+                    \/\/ avoid printing when in transition states\n+                    vthread.setState(RUNNING);\n+                    PinnedThreadPrinter.printStackTrace(System.out, reason, printAll);\n+                } finally {\n+                    vthread.setState(oldState);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8284161 8289284\n+ * @bug 8284161 8289284 8322846\n@@ -37,0 +37,1 @@\n+import java.util.concurrent.Executors;\n@@ -70,0 +71,1 @@\n+        assertContains(output, \"reason:MONITOR\");\n@@ -71,1 +73,0 @@\n-        assertDoesNotContain(output, \"(Native Method)\");\n@@ -81,0 +82,1 @@\n+        assertContains(output, \"reason:NATIVE\");\n@@ -82,1 +84,58 @@\n-        assertDoesNotContain(output, \"<== monitors\");\n+    }\n+\n+    \/**\n+     * Test parking in class initializer.\n+     *\/\n+    @Test\n+    void testPinnedCausedByClassInitializer() throws Exception {\n+        class C {\n+            static {\n+                park();\n+            }\n+        }\n+        String output = run(C::new);\n+        assertContains(output, \"reason:NATIVE\");\n+        assertContains(output, \"<clinit>\");\n+    }\n+\n+    \/**\n+     * Test contention writing to System.out when pinned.\n+     *\/\n+    @Test\n+    void testContention() throws Exception {\n+        \/\/ use several classes to avoid duplicate stack traces\n+        class C1 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+        class C2 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+        class C3 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+        class C4 {\n+            synchronized void print() {\n+                System.out.println(\"hello\");\n+            }\n+        }\n+\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            executor.submit(() -> {\n+                new C1().print();\n+            });\n+            executor.submit(() -> {\n+                new C2().print();\n+            });\n+            executor.submit(() -> {\n+                new C3().print();\n+            });\n+            executor.submit(() -> {\n+                new C4().print();\n+            });\n+        }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/TracePinnedThreads.java","additions":63,"deletions":4,"binary":false,"changes":67,"status":"modified"}]}