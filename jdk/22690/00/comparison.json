{"files":[{"patch":"@@ -780,0 +780,1 @@\n+          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n@@ -785,0 +786,1 @@\n+          __ move(LIR_OprFact::floatConst(-0.0), tmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -699,0 +699,2 @@\n+      \/\/ f2hf treats tmp as live_in. Workaround: initialize to some value.\n+      __ move(LIR_OprFact::floatConst(-0.0), tmp); \/\/ just to satisfy LinearScan\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -352,0 +352,1 @@\n+      __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n@@ -355,0 +356,1 @@\n+      __ move(LIR_OprFact::floatConst(-0.0), tmp);\n@@ -835,0 +837,1 @@\n+    __ move(LIR_OprFact::doubleConst(-0.0), tmp);\n@@ -839,0 +842,1 @@\n+    __ move(LIR_OprFact::floatConst(-0.0), tmp);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -638,18 +638,0 @@\n-    case lir_abs:\n-    case lir_sqrt:\n-    case lir_neg: {\n-      assert(in->is_fpu_register(), \"must be\");\n-      assert(res->is_fpu_register(), \"must be\");\n-      assert(in->is_last_use(), \"old value gets destroyed\");\n-\n-      insert_free_if_dead(res, in);\n-      insert_exchange(in);\n-      do_rename(in, res);\n-\n-      new_in = to_fpu_stack_top(res);\n-      new_res = new_in;\n-\n-      op1->set_fpu_stack_size(sim()->stack_size());\n-      break;\n-    }\n-\n@@ -777,0 +759,20 @@\n+    case lir_abs:\n+    case lir_sqrt:\n+    case lir_neg: {\n+      \/\/ Right argument appears to be unused\n+      assert(right->is_illegal(), \"must be\");\n+      assert(left->is_fpu_register(), \"must be\");\n+      assert(res->is_fpu_register(), \"must be\");\n+      assert(left->is_last_use(), \"old value gets destroyed\");\n+\n+      insert_free_if_dead(res, left);\n+      insert_exchange(left);\n+      do_rename(left, res);\n+\n+      new_left = to_fpu_stack_top(res);\n+      new_res = new_left;\n+\n+      op2->set_fpu_stack_size(sim()->stack_size());\n+      break;\n+    }\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.cpp","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,29 @@\n-  \/\/ No special case behaviours yet\n+  switch (op->code()) {\n+    case lir_tan: {\n+      \/\/ The slow path for these functions may need to save and\n+      \/\/ restore all live registers but we don't want to save and\n+      \/\/ restore everything all the time, so mark the xmms as being\n+      \/\/ killed.  If the slow path were explicit or we could propagate\n+      \/\/ live register masks down to the assembly we could do better\n+      \/\/ but we don't have any easy way to do that right now.  We\n+      \/\/ could also consider not killing all xmm registers if we\n+      \/\/ assume that slow paths are uncommon but it's not clear that\n+      \/\/ would be a good idea.\n+      if (UseSSE > 0) {\n+#ifdef ASSERT\n+        if (TraceLinearScanLevel >= 2) {\n+          tty->print_cr(\"killing XMMs for trig\");\n+        }\n+#endif\n+        int num_caller_save_xmm_regs = FrameMap::get_num_caller_save_xmms();\n+        int op_id = op->id();\n+        for (int xmm = 0; xmm < num_caller_save_xmm_regs; xmm++) {\n+          LIR_Opr opr = FrameMap::caller_save_xmm_reg_at(xmm);\n+          add_temp(reg_num(opr), op_id, noUse, T_ILLEGAL);\n+        }\n+      }\n+      break;\n+    }\n+    default:\n+      break;\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.hpp","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -455,5 +455,0 @@\n-    case lir_sqrt:           \/\/ FP Ops have no info, but input and result\n-    case lir_abs:\n-    case lir_neg:\n-    case lir_f2hf:\n-    case lir_hf2f:\n@@ -466,1 +461,0 @@\n-      if (op1->_tmp->is_valid())       do_temp(op1->_tmp);\n@@ -492,1 +486,0 @@\n-      assert(op1->_tmp->is_illegal(), \"not used\");\n@@ -576,0 +569,5 @@\n+    case lir_sqrt:\n+    case lir_abs:\n+    case lir_neg:\n+    case lir_f2hf:\n+    case lir_hf2f:\n@@ -672,1 +670,0 @@\n-      assert(op1->_tmp->is_illegal(), \"not used\");\n@@ -1736,5 +1733,0 @@\n-     case lir_abs:                   s = \"abs\";           break;\n-     case lir_neg:                   s = \"neg\";           break;\n-     case lir_sqrt:                  s = \"sqrt\";          break;\n-     case lir_f2hf:                  s = \"f2hf\";          break;\n-     case lir_hf2f:                  s = \"hf2f\";          break;\n@@ -1757,0 +1749,5 @@\n+     case lir_abs:                   s = \"abs\";           break;\n+     case lir_neg:                   s = \"neg\";           break;\n+     case lir_sqrt:                  s = \"sqrt\";          break;\n+     case lir_f2hf:                  s = \"f2hf\";          break;\n+     case lir_hf2f:                  s = \"hf2f\";          break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -942,5 +942,0 @@\n-      , lir_sqrt\n-      , lir_abs\n-      , lir_neg\n-      , lir_f2hf\n-      , lir_hf2f\n@@ -963,0 +958,7 @@\n+      , lir_sqrt\n+      , lir_abs\n+      , lir_neg\n+      , lir_tan\n+      , lir_f2hf\n+      , lir_hf2f\n+      , lir_log10\n@@ -1358,1 +1360,0 @@\n-  LIR_Opr         _tmp;\n@@ -1373,8 +1374,0 @@\n-    , _tmp(LIR_OprFact::illegalOpr)\n-    , _type(type)\n-    , _patch(patch)                    { assert(is_in_range(code, begin_op1, end_op1), \"code check\"); }\n-\n-  LIR_Op1(LIR_Code code, LIR_Opr opr, LIR_Opr result, LIR_Opr tmp, BasicType type = T_ILLEGAL, LIR_PatchCode patch = lir_patch_none, CodeEmitInfo* info = nullptr)\n-    : LIR_Op(code, result, info)\n-    , _opr(opr)\n-    , _tmp(tmp)\n@@ -1387,1 +1380,0 @@\n-    , _tmp(LIR_OprFact::illegalOpr)\n@@ -1397,1 +1389,0 @@\n-    , _tmp(LIR_OprFact::illegalOpr)\n@@ -1402,1 +1393,0 @@\n-  LIR_Opr tmp_opr()          const               { return _tmp;   }\n@@ -2285,3 +2275,3 @@\n-  void abs (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_abs , from, to, tmp)); }\n-  void negate(LIR_Opr from, LIR_Opr to, LIR_Opr tmp = LIR_OprFact::illegalOpr) { append(new LIR_Op1(lir_neg, from, to, tmp)); }\n-  void sqrt(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_sqrt, from, to, tmp)); }\n+  void abs (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_abs , from, tmp, to)); }\n+  void negate(LIR_Opr from, LIR_Opr to, LIR_Opr tmp = LIR_OprFact::illegalOpr)              { append(new LIR_Op2(lir_neg, from, tmp, to)); }\n+  void sqrt(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_sqrt, from, tmp, to)); }\n@@ -2290,2 +2280,4 @@\n-  void f2hf(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_f2hf, from, to, tmp)); }\n-  void hf2f(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op1(lir_hf2f, from, to, tmp)); }\n+  void log10 (LIR_Opr from, LIR_Opr to, LIR_Opr tmp)              { append(new LIR_Op2(lir_log10, from, LIR_OprFact::illegalOpr, to, tmp)); }\n+  void tan (LIR_Opr from, LIR_Opr to, LIR_Opr tmp1, LIR_Opr tmp2) { append(new LIR_Op2(lir_tan , from, tmp1, to, tmp2)); }\n+  void f2hf(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_f2hf, from, tmp, to)); }\n+  void hf2f(LIR_Opr from, LIR_Opr to, LIR_Opr tmp)                { append(new LIR_Op2(lir_hf2f, from, tmp, to)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":14,"deletions":22,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -530,11 +530,0 @@\n-    case lir_abs:\n-    case lir_sqrt:\n-    case lir_f2hf:\n-    case lir_hf2f:\n-      intrinsic_op(op->code(), op->in_opr(), op->tmp_opr(), op->result_opr(), op);\n-      break;\n-\n-    case lir_neg:\n-      negate(op->in_opr(), op->result_opr(), op->tmp_opr());\n-      break;\n-\n@@ -738,0 +727,13 @@\n+    case lir_abs:\n+    case lir_sqrt:\n+    case lir_tan:\n+    case lir_log10:\n+    case lir_f2hf:\n+    case lir_hf2f:\n+      intrinsic_op(op->code(), op->in_opr1(), op->in_opr2(), op->result_opr(), op);\n+      break;\n+\n+    case lir_neg:\n+      negate(op->in_opr1(), op->result_opr(), op->in_opr2());\n+      break;\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-  void intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr temp, LIR_Opr dest, LIR_Op* op);\n+  void intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr unused, LIR_Opr dest, LIR_Op* op);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6742,0 +6742,1 @@\n+        case lir_log10:\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}