{"files":[{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=platform\n+ * @summary Verifies JVMTI ClearAllFramePops clears all FramePop requests\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:ClearAllFramePops ClearAllFramePops platform\n+ *\/\n+\/*\n+ * @test id=virtual\n+ * @summary Verifies JVMTI ClearAllFramePops clears all FramePop requests\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:ClearAllFramePops ClearAllFramePops virtual\n+ *\/\n+\n+public class ClearAllFramePops {\n+\n+    final static int MAX_THREADS_LIMIT = 10;\n+    final static int NESTING_DEPTH = 5;\n+    final static String TEST_THREAD_NAME_BASE = \"Test Thread #\";\n+\n+    native static void clearAllFramePops();\n+    native static void getReady();\n+    native static void check();\n+\n+    public static void main(String args[]) {\n+        boolean isVirtual = args.length > 0 && args[0].equals(\"virtual\");\n+        final int THREADS_LIMIT = Math.min(Runtime.getRuntime().availableProcessors() + 1, MAX_THREADS_LIMIT);\n+        Thread[] t = new Thread[THREADS_LIMIT];\n+        getReady();\n+        Thread.Builder builder = (isVirtual ? Thread.ofVirtual() : Thread.ofPlatform())\n+                .name(TEST_THREAD_NAME_BASE, 0);\n+        for (int i = 0; i < THREADS_LIMIT; i++) {\n+            t[i] = builder.start(new TestTask());\n+        }\n+        for (int i = 0; i < THREADS_LIMIT; i++) {\n+            try {\n+                t[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n+            }\n+        }\n+        check();\n+    }\n+\n+    static class TestTask implements Runnable {\n+        int nestingCount = 0;\n+\n+        public void run() {\n+            if (nestingCount < NESTING_DEPTH) {\n+                nestingCount++;\n+                run();\n+            } else {\n+                clearAllFramePops();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/ClearAllFramePops\/ClearAllFramePops.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jrawMonitorID event_lock;\n+static jboolean watch_events = JNI_FALSE;\n+static int pop_count;\n+static const char* TEST_THREAD_NAME_BASE = \"Test Thread\";\n+static const char* TEST_CLASS_SIG = \"LClearAllFramePops$TestTask;\";\n+\n+static\n+bool isTestThread(JNIEnv *jni, jvmtiEnv *jvmti, jthread thr) {\n+  jvmtiThreadInfo inf = get_thread_info(jvmti, jni, thr);\n+  bool result = strncmp(inf.name, TEST_THREAD_NAME_BASE, strlen(TEST_THREAD_NAME_BASE)) == 0;\n+  deallocate(jvmti, jni, inf.name);\n+\n+  return result;\n+}\n+\n+static\n+void printInfo(JNIEnv *jni, jvmtiEnv *jvmti, jthread thr, jmethodID method, int depth) {\n+  jclass cls;\n+  char *mname, *msig, *csig;\n+  jvmtiThreadInfo inf = get_thread_info(jvmti, jni, thr);\n+\n+  check_jvmti_status(jni, jvmti->GetMethodDeclaringClass(method, &cls), \"Error in GetMethodDeclaringClass.\");\n+  check_jvmti_status(jni, jvmti->GetClassSignature(cls, &csig, nullptr), \"Error in GetClassSignature.\");\n+  check_jvmti_status(jni, jvmti->GetMethodName(method, &mname, &msig, nullptr), \"Error in GetMethodName.\");\n+\n+  LOG(\" %s: %s.%s%s, depth = %d\\n\", inf.name, csig, mname, msig, depth);\n+\n+  deallocate(jvmti, jni, inf.name);\n+  deallocate(jvmti, jni, mname);\n+  deallocate(jvmti, jni, msig);\n+  deallocate(jvmti, jni, csig);\n+}\n+\n+void JNICALL MethodEntry(jvmtiEnv *jvmti, JNIEnv *jni,\n+                         jthread thr, jmethodID method) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  if (watch_events == JNI_FALSE) {\n+    return;\n+  }\n+  if (!isTestThread(jni, jvmti, thr)) {\n+    return; \/\/ not a tested thread\n+  }\n+  jclass cls;\n+  char *csig;\n+  jvmtiThreadInfo inf = get_thread_info(jvmti, jni, thr);\n+\n+  check_jvmti_status(jni, jvmti->GetMethodDeclaringClass(method, &cls), \"Error in GetMethodDeclaringClass.\");\n+  check_jvmti_status(jni, jvmti->GetClassSignature(cls, &csig, nullptr), \"Error in GetClassSignature.\");\n+\n+  if (strcmp(csig, TEST_CLASS_SIG) != 0 ||\n+      strcmp(get_method_name(jvmti, jni, method), \"run\") != 0) {\n+    return; \/\/ not a tested method\n+  }\n+  LOG(\"\\n>>>Method entry event:\");\n+  printInfo(jni, jvmti, thr, method, get_frame_count(jvmti, jni, thr));\n+\n+  check_jvmti_status(jni, jvmti->NotifyFramePop(thr, 0), \"Error in NotifyFramePop.\");\n+  deallocate(jvmti, jni, csig);\n+}\n+\n+void JNICALL FramePop(jvmtiEnv *jvmti, JNIEnv *jni,\n+                      jthread thr, jmethodID method, jboolean wasPopedByException) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  jint frameCount = get_frame_count(jvmti, jni, thr);\n+\n+  LOG(\"\\n>>> Frame Pop event:\");\n+  printInfo(jni, jvmti, thr, method, frameCount);\n+  pop_count++;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+\n+  jint res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == nullptr) {\n+    LOG(\"Failed: Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  event_lock = create_raw_monitor(jvmti, \"_event_lock\");\n+\n+  memset(&caps, 0, sizeof(jvmtiCapabilities));\n+  caps.can_generate_frame_pop_events = 1;\n+  caps.can_generate_method_entry_events = 1;\n+  caps.can_support_virtual_threads = 1;\n+\n+  callbacks.MethodEntry = &MethodEntry;\n+  callbacks.FramePop = &FramePop;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(AddCapabilities) unexpected error: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(GetCapabilities) unexpected error: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL Java_ClearAllFramePops_clearAllFramePops(JNIEnv *jni, jclass cls) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  char* tname = get_thread_name(jvmti, jni, nullptr);\n+\n+  check_jvmti_status(jni, jvmti->ClearAllFramePops(nullptr), \"Error in ClearAllFramePops\");\n+  LOG(\"Called ClearAllFramePops for thread: %s\\n\", tname);\n+\n+  deallocate(jvmti, jni, tname);\n+}\n+\n+JNIEXPORT void JNICALL Java_ClearAllFramePops_getReady(JNIEnv *jni, jclass cls) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  watch_events = JNI_TRUE;\n+  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr);\n+  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, nullptr);\n+}\n+\n+JNIEXPORT void JNICALL Java_ClearAllFramePops_check(JNIEnv *jni, jclass cls) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  watch_events = JNI_FALSE;\n+  set_event_notification_mode(jvmti, jni, JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr);\n+  set_event_notification_mode(jvmti, jni, JVMTI_DISABLE, JVMTI_EVENT_FRAME_POP, nullptr);\n+  LOG(\"\\n>>> Total frame pops: %d\\n\", pop_count);\n+\n+  if (pop_count > 0) {\n+    fatal(jni, \"Failed: FramePop events are not expected\");\n+  }\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/ClearAllFramePops\/libClearAllFramePops.cpp","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"}]}