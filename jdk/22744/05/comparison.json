{"files":[{"patch":"@@ -3090,0 +3090,28 @@\n+    <function id=\"ClearAllFramePops\" num=\"67\" since=\"25\">\n+      <synopsis>Clear Frame Pop<\/synopsis>\n+      <description>\n+        Clear all frame pop requests so that a <eventlink id=\"FramePop\"><\/eventlink>\n+        event will not be generated for any frames.\n+        See the <eventlink id=\"FramePop\"><\/eventlink> event for details.\n+        <p\/>\n+        The specified thread must be suspended or must be the current thread.\n+      <\/description>\n+      <origin>new<\/origin>\n+      <capabilities>\n+        <required id=\"can_generate_frame_pop_events\"><\/required>\n+      <\/capabilities>\n+      <parameters>\n+        <param id=\"thread\">\n+          <jthread null=\"current\" impl=\"noconvert\"\/>\n+          <description>\n+            The thread for which all the frame pop events will be cleared.\n+          <\/description>\n+        <\/param>\n+      <\/parameters>\n+      <errors>\n+        <error id=\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\">\n+          Thread was not suspended and was not the current thread.\n+        <\/error>\n+      <\/errors>\n+    <\/function>\n+\n@@ -15481,0 +15509,3 @@\n+  <change date=\"10 January 2025\" version=\"25.0.0\">\n+      Add new function ClearAllFramePops. Needed to speedup debugger single stepping.\n+  <\/change>\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1807,1 +1807,1 @@\n-  SetFramePopClosure op(this, state, depth);\n+  SetOrClearFramePopClosure op(this, state, true \/* set *\/, depth);\n@@ -1813,0 +1813,27 @@\n+\/\/ Threads_lock NOT held, java_thread not protected by lock\n+jvmtiError\n+JvmtiEnv::ClearAllFramePops(jthread thread) {\n+  ResourceMark rm;\n+  JvmtiVTMSTransitionDisabler disabler(thread);\n+  JavaThread* current = JavaThread::current();\n+  ThreadsListHandle tlh(current);\n+\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, current, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return err;\n+  }\n+\n+  HandleMark hm(current);\n+  Handle thread_handle(current, thread_obj);\n+  JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread, thread_handle);\n+  if (state == nullptr) {\n+    return JVMTI_ERROR_THREAD_NOT_ALIVE;\n+  }\n+\n+  SetOrClearFramePopClosure op(this, state, false \/* clear all frame pops*\/);\n+  MutexLocker mu(current, JvmtiThreadState_lock);\n+  JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n+  return op.result();\n+} \/* end ClearAllFramePops *\/\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1366,0 +1366,7 @@\n+jvmtiError\n+JvmtiEnvBase::clear_all_frame_pops(JvmtiThreadState* state) {\n+  JvmtiEnvThreadState* ets = state->env_thread_state(this);\n+  ets->clear_all_frame_pops();\n+  return JVMTI_ERROR_NONE;\n+}\n+\n@@ -2481,1 +2488,1 @@\n-SetFramePopClosure::do_thread(Thread *target) {\n+SetOrClearFramePopClosure::do_thread(Thread *target) {\n@@ -2494,0 +2501,4 @@\n+  if (!_set) { \/\/ ClearAllFramePops\n+    _result = _env->clear_all_frame_pops(_state);\n+    return;\n+  }\n@@ -2505,1 +2516,1 @@\n-  _result = ((JvmtiEnvBase*)_env)->set_frame_pop(_state, jvf, _depth);\n+  _result = _env->set_frame_pop(_state, jvf, _depth);\n@@ -2509,1 +2520,1 @@\n-SetFramePopClosure::do_vthread(Handle target_h) {\n+SetOrClearFramePopClosure::do_vthread(Handle target_h) {\n@@ -2517,0 +2528,4 @@\n+  if (!_set) { \/\/ ClearAllFramePops\n+    _result = _env->clear_all_frame_pops(_state);\n+    return;\n+  }\n@@ -2518,1 +2533,1 @@\n-  _result = ((JvmtiEnvBase*)_env)->set_frame_pop(_state, jvf, _depth);\n+  _result = _env->set_frame_pop(_state, jvf, _depth);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -413,0 +413,1 @@\n+  jvmtiError clear_all_frame_pops(JvmtiThreadState* state);\n@@ -537,1 +538,1 @@\n-class SetFramePopClosure : public JvmtiUnitedHandshakeClosure {\n+class SetOrClearFramePopClosure : public JvmtiUnitedHandshakeClosure {\n@@ -539,1 +540,1 @@\n-  JvmtiEnv *_env;\n+  JvmtiEnvBase *_env;\n@@ -541,1 +542,2 @@\n-  jint _depth;\n+  bool _set;\n+  jint _depth; \/\/ used for NotiftyFramePop only\n@@ -544,3 +546,3 @@\n-  SetFramePopClosure(JvmtiEnv *env, JvmtiThreadState* state, jint depth)\n-    : JvmtiUnitedHandshakeClosure(\"SetFramePopClosure\"),\n-      _env(env),\n+  SetOrClearFramePopClosure(JvmtiEnv *env, JvmtiThreadState* state, bool set, jint depth = 0)\n+    : JvmtiUnitedHandshakeClosure(\"SetOrClearFramePopClosure\"),\n+      _env((JvmtiEnvBase*)env),\n@@ -548,0 +550,1 @@\n+      _set(set),\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -74,0 +74,4 @@\n+void\n+JvmtiFramePops::clear_all() {\n+  _pops->clear();\n+}\n@@ -215,4 +219,1 @@\n-#ifdef ASSERT\n-  Thread *current = Thread::current();\n-#endif\n-  assert(get_thread() == nullptr || get_thread()->is_handshake_safe_for(current),\n+  assert(get_thread() == nullptr || get_thread()->is_handshake_safe_for(Thread::current()),\n@@ -233,4 +234,1 @@\n-#ifdef ASSERT\n-  Thread *current = Thread::current();\n-#endif\n-  assert(get_thread() == nullptr || get_thread()->is_handshake_safe_for(current),\n+  assert(get_thread() == nullptr || get_thread()->is_handshake_safe_for(Thread::current()),\n@@ -244,4 +242,1 @@\n-#ifdef ASSERT\n-  Thread *current = Thread::current();\n-#endif\n-  assert(get_thread() == nullptr || get_thread()->is_handshake_safe_for(current),\n+  assert(get_thread() == nullptr || get_thread()->is_handshake_safe_for(Thread::current()),\n@@ -253,0 +248,5 @@\n+void JvmtiEnvThreadState::clear_all_frame_pops() {\n+  assert(get_thread() == nullptr || get_thread()->is_handshake_safe_for(Thread::current()),\n+         \"frame pop data only accessible from same or detached thread or direct handshake\");\n+  JvmtiEventController::clear_all_frame_pops(this);\n+}\n@@ -255,4 +255,1 @@\n-#ifdef ASSERT\n-  Thread *current = Thread::current();\n-#endif\n-  assert(get_thread() == nullptr || get_thread()->is_handshake_safe_for(current),\n+  assert(get_thread() == nullptr || get_thread()->is_handshake_safe_for(Thread::current()),\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+  void clear_all();\n@@ -187,0 +188,1 @@\n+  void clear_all_frame_pops();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -315,0 +315,1 @@\n+  static void clear_all_frame_pops(JvmtiEnvThreadState *env_thread);\n@@ -949,0 +950,9 @@\n+void\n+JvmtiEventControllerPrivate::clear_all_frame_pops(JvmtiEnvThreadState *ets) {\n+  EC_TRACE((\"[%s] # clear all frame pops\",\n+            JvmtiTrace::safe_get_thread_name(ets->get_thread_or_saved())\n+          ));\n+\n+  ets->get_frame_pops()->clear_all();\n+  recompute_thread_enabled(ets->jvmti_thread_state());\n+}\n@@ -1128,0 +1138,6 @@\n+void\n+JvmtiEventController::clear_all_frame_pops(JvmtiEnvThreadState *ets) {\n+  assert(JvmtiThreadState_lock->is_locked(), \"Must be locked.\");\n+  JvmtiEventControllerPrivate::clear_all_frame_pops(ets);\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -234,0 +234,1 @@\n+  static void clear_all_frame_pops(JvmtiEnvThreadState *env_thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1972,1 +1972,4 @@\n-          ets->clear_frame_pop(cur_frame_number);\n+          \/\/ Need to recheck the condition as the JVMTI ClearAllFramePops can do its work at a safepoint.\n+          if (ets->is_frame_pop(cur_frame_number)) {\n+            ets->clear_frame_pop(cur_frame_number);\n+          }\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=platform\n+ * @summary Verifies JVMTI ClearAllFramePops clears all FramePop requests\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:ClearAllFramePops ClearAllFramePops platform\n+ *\/\n+\/*\n+ * @test id=virtual\n+ * @summary Verifies JVMTI ClearAllFramePops clears all FramePop requests\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:ClearAllFramePops ClearAllFramePops virtual\n+ *\/\n+\n+public class ClearAllFramePops {\n+\n+    final static int MAX_THREADS_LIMIT = 10;\n+    final static int NESTING_DEPTH = 5;\n+    final static String TEST_THREAD_NAME_BASE = \"Test Thread #\";\n+\n+    native static void clearAllFramePops();\n+    native static void getReady();\n+    native static void check();\n+\n+    public static void main(String args[]) {\n+        boolean isVirtual = args.length > 0 && args[0].equals(\"virtual\");\n+        final int THREADS_LIMIT = Math.min(Runtime.getRuntime().availableProcessors() + 1, MAX_THREADS_LIMIT);\n+        Thread[] t = new Thread[THREADS_LIMIT];\n+        getReady();\n+        Thread.Builder builder = (isVirtual ? Thread.ofVirtual() : Thread.ofPlatform())\n+                .name(TEST_THREAD_NAME_BASE, 0);\n+        for (int i = 0; i < THREADS_LIMIT; i++) {\n+            t[i] = builder.start(new TestTask());\n+        }\n+        for (int i = 0; i < THREADS_LIMIT; i++) {\n+            try {\n+                t[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n+            }\n+        }\n+        check();\n+    }\n+\n+    static class TestTask implements Runnable {\n+        int nestingCount = 0;\n+\n+        public void run() {\n+            if (nestingCount < NESTING_DEPTH) {\n+                nestingCount++;\n+                run();\n+            } else {\n+                clearAllFramePops();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/ClearAllFramePops\/ClearAllFramePops.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jrawMonitorID event_lock;\n+static jboolean watch_events = JNI_FALSE;\n+static int pop_count;\n+static const char* TEST_THREAD_NAME_BASE = \"Test Thread\";\n+static const char* TEST_CLASS_SIG = \"LClearAllFramePops$TestTask;\";\n+\n+static\n+bool isTestThread(JNIEnv *jni, jvmtiEnv *jvmti, jthread thr) {\n+  char* tname = get_thread_name(jvmti, jni, thr);\n+  bool result = strncmp(tname, TEST_THREAD_NAME_BASE, strlen(TEST_THREAD_NAME_BASE)) == 0;\n+  deallocate(jvmti, jni, tname);\n+\n+  return result;\n+}\n+\n+static\n+void printInfo(JNIEnv *jni, jvmtiEnv *jvmti, jthread thr, jmethodID method, int depth) {\n+  jclass cls;\n+  char *mname, *msig, *csig;\n+  char* tname = get_thread_name(jvmti, jni, thr);\n+\n+  check_jvmti_status(jni, jvmti->GetMethodDeclaringClass(method, &cls), \"Error in GetMethodDeclaringClass.\");\n+  check_jvmti_status(jni, jvmti->GetClassSignature(cls, &csig, nullptr), \"Error in GetClassSignature.\");\n+  check_jvmti_status(jni, jvmti->GetMethodName(method, &mname, &msig, nullptr), \"Error in GetMethodName.\");\n+\n+  LOG(\" %s: %s.%s%s, depth = %d\\n\", tname, csig, mname, msig, depth);\n+\n+  deallocate(jvmti, jni, tname);\n+  deallocate(jvmti, jni, mname);\n+  deallocate(jvmti, jni, msig);\n+  deallocate(jvmti, jni, csig);\n+}\n+\n+void JNICALL MethodEntry(jvmtiEnv *jvmti, JNIEnv *jni,\n+                         jthread thr, jmethodID method) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  if (watch_events == JNI_FALSE) {\n+    return;\n+  }\n+  if (!isTestThread(jni, jvmti, thr)) {\n+    return; \/\/ not a tested thread\n+  }\n+  jclass cls;\n+  char *csig;\n+\n+  check_jvmti_status(jni, jvmti->GetMethodDeclaringClass(method, &cls), \"Error in GetMethodDeclaringClass.\");\n+  check_jvmti_status(jni, jvmti->GetClassSignature(cls, &csig, nullptr), \"Error in GetClassSignature.\");\n+\n+  if (strcmp(csig, TEST_CLASS_SIG) != 0 ||\n+      strcmp(get_method_name(jvmti, jni, method), \"run\") != 0) {\n+    return; \/\/ not a tested method\n+  }\n+  LOG(\"\\n>>>Method entry event:\");\n+  printInfo(jni, jvmti, thr, method, get_frame_count(jvmti, jni, thr));\n+\n+  check_jvmti_status(jni, jvmti->NotifyFramePop(thr, 0), \"Error in NotifyFramePop.\");\n+  deallocate(jvmti, jni, csig);\n+}\n+\n+void JNICALL FramePop(jvmtiEnv *jvmti, JNIEnv *jni,\n+                      jthread thr, jmethodID method, jboolean wasPopedByException) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  jint frameCount = get_frame_count(jvmti, jni, thr);\n+\n+  LOG(\"\\n>>> Frame Pop event:\");\n+  printInfo(jni, jvmti, thr, method, frameCount);\n+  pop_count++;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+\n+  jint res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == nullptr) {\n+    LOG(\"Failed: Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  event_lock = create_raw_monitor(jvmti, \"_event_lock\");\n+\n+  memset(&caps, 0, sizeof(jvmtiCapabilities));\n+  caps.can_generate_frame_pop_events = 1;\n+  caps.can_generate_method_entry_events = 1;\n+  caps.can_support_virtual_threads = 1;\n+\n+  callbacks.MethodEntry = &MethodEntry;\n+  callbacks.FramePop = &FramePop;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(AddCapabilities) unexpected error: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL Java_ClearAllFramePops_clearAllFramePops(JNIEnv *jni, jclass cls) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  char* tname = get_thread_name(jvmti, jni, nullptr);\n+\n+  check_jvmti_status(jni, jvmti->ClearAllFramePops(nullptr), \"Error in ClearAllFramePops\");\n+  LOG(\"Called ClearAllFramePops for thread: %s\\n\", tname);\n+\n+  deallocate(jvmti, jni, tname);\n+}\n+\n+JNIEXPORT void JNICALL Java_ClearAllFramePops_getReady(JNIEnv *jni, jclass cls) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  watch_events = JNI_TRUE;\n+  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr);\n+  set_event_notification_mode(jvmti, jni, JVMTI_ENABLE, JVMTI_EVENT_FRAME_POP, nullptr);\n+}\n+\n+JNIEXPORT void JNICALL Java_ClearAllFramePops_check(JNIEnv *jni, jclass cls) {\n+  RawMonitorLocker rml(jvmti, jni, event_lock);\n+\n+  watch_events = JNI_FALSE;\n+  set_event_notification_mode(jvmti, jni, JVMTI_DISABLE, JVMTI_EVENT_METHOD_ENTRY, nullptr);\n+  set_event_notification_mode(jvmti, jni, JVMTI_DISABLE, JVMTI_EVENT_FRAME_POP, nullptr);\n+  LOG(\"\\n>>> Total frame pops: %d\\n\", pop_count);\n+\n+  if (pop_count > 0) {\n+    fatal(jni, \"Failed: FramePop events are not expected\");\n+  }\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/ClearAllFramePops\/libClearAllFramePops.cpp","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"}]}