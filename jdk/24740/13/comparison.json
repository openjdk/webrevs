{"files":[{"patch":"@@ -128,0 +128,1 @@\n+      aotCodeCache.cpp \\\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -678,0 +678,3 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    return true;\n+  }\n@@ -862,0 +865,3 @@\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    return false;\n+  }\n@@ -2157,1 +2163,1 @@\n-  mov(rscratch1, entry_point);\n+  mov(rscratch1, RuntimeAddress(entry_point));\n@@ -3234,1 +3240,6 @@\n-  BLOCK_COMMENT(msg);\n+  \/\/ Skip AOT caching C strings in scratch buffer.\n+  const char* str = (code_section()->scratch_emit()) ? msg : AOTCodeCache::add_C_string(msg);\n+  BLOCK_COMMENT(str);\n+  \/\/ load msg into r0 so we can access it from the signal handler\n+  \/\/ ExternalAddress enables saving and restoring via the code cache\n+  lea(c_rarg0, ExternalAddress((address) str));\n@@ -3236,1 +3247,0 @@\n-  emit_int64((uintptr_t)msg);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -1318,0 +1319,4 @@\n+    if (AOTCodeCache::is_on_for_dump()) {\n+      \/\/ To calculate far_codestub_branch_size correctly.\n+      return true;\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -560,34 +560,0 @@\n-  if (VerifyAdapterCalls &&\n-      (Interpreter::code() != nullptr || StubRoutines::final_stubs_code() != nullptr)) {\n-#if 0\n-    \/\/ So, let's test for cascading c2i\/i2c adapters right now.\n-    \/\/  assert(Interpreter::contains($return_addr) ||\n-    \/\/         StubRoutines::contains($return_addr),\n-    \/\/         \"i2c adapter must return to an interpreter frame\");\n-    __ block_comment(\"verify_i2c { \");\n-    Label L_ok;\n-    if (Interpreter::code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  Interpreter::code()->code_start(), Interpreter::code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::initial_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::initial_stubs_code()->code_begin(),\n-                  StubRoutines::initial_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::final_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::final_stubs_code()->code_begin(),\n-                  StubRoutines::final_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    const char* msg = \"i2c adapter must return to an interpreter frame\";\n-    __ block_comment(msg);\n-    __ stop(msg);\n-    __ bind(L_ok);\n-    __ block_comment(\"} verify_i2ce \");\n-#endif\n-  }\n-\n@@ -714,6 +680,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -780,1 +746,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return;\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":41,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -615,6 +615,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -640,1 +640,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, nullptr);\n+  return;\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1146,6 +1146,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -1226,2 +1226,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry,\n-                                          c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return;\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -599,6 +599,7 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -661,1 +662,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return;\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2355,6 +2355,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -2414,1 +2414,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return;\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -369,1 +370,3 @@\n-  lea(c_rarg0, ExternalAddress((address) msg));\n+  \/\/ Skip AOT caching C strings in scratch buffer.\n+  const char* str = (code_section()->scratch_emit()) ? msg : AOTCodeCache::add_C_string(msg);\n+  lea(c_rarg0, ExternalAddress((address) str));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -678,1 +678,0 @@\n-\n@@ -829,13 +828,0 @@\n-static void range_check(MacroAssembler* masm, Register pc_reg, Register temp_reg,\n-                        address code_start, address code_end,\n-                        Label& L_ok) {\n-  Label L_fail;\n-  __ lea(temp_reg, AddressLiteral(code_start, relocInfo::none));\n-  __ cmpptr(pc_reg, temp_reg);\n-  __ jcc(Assembler::belowEqual, L_fail);\n-  __ lea(temp_reg, AddressLiteral(code_end, relocInfo::none));\n-  __ cmpptr(pc_reg, temp_reg);\n-  __ jcc(Assembler::below, L_ok);\n-  __ bind(L_fail);\n-}\n-\n@@ -874,35 +860,0 @@\n-  if (VerifyAdapterCalls &&\n-      (Interpreter::code() != nullptr || StubRoutines::final_stubs_code() != nullptr)) {\n-    \/\/ So, let's test for cascading c2i\/i2c adapters right now.\n-    \/\/  assert(Interpreter::contains($return_addr) ||\n-    \/\/         StubRoutines::contains($return_addr),\n-    \/\/         \"i2c adapter must return to an interpreter frame\");\n-    __ block_comment(\"verify_i2c { \");\n-    \/\/ Pick up the return address\n-    __ movptr(rax, Address(rsp, 0));\n-    Label L_ok;\n-    if (Interpreter::code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  Interpreter::code()->code_start(),\n-                  Interpreter::code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::initial_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::initial_stubs_code()->code_begin(),\n-                  StubRoutines::initial_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    if (StubRoutines::final_stubs_code() != nullptr) {\n-      range_check(masm, rax, r11,\n-                  StubRoutines::final_stubs_code()->code_begin(),\n-                  StubRoutines::final_stubs_code()->code_end(),\n-                  L_ok);\n-    }\n-    const char* msg = \"i2c adapter must return to an interpreter frame\";\n-    __ block_comment(msg);\n-    __ stop(msg);\n-    __ bind(L_ok);\n-    __ block_comment(\"} verify_i2ce \");\n-  }\n-\n@@ -1053,6 +1004,6 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n-                                                            int total_args_passed,\n-                                                            int comp_args_on_stack,\n-                                                            const BasicType *sig_bt,\n-                                                            const VMRegPair *regs,\n-                                                            AdapterFingerPrint* fingerprint) {\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n@@ -1120,1 +1071,2 @@\n-  return AdapterHandlerLibrary::new_entry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  handler->set_entry_points(i2c_entry, c2i_entry, c2i_unverified_entry, c2i_no_clinit_check_entry);\n+  return;\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":8,"deletions":56,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -53,12 +53,11 @@\n-AdapterHandlerEntry* SharedRuntime::generate_i2c2i_adapters(\n-                        MacroAssembler *masm,\n-                        int total_args_passed,\n-                        int comp_args_on_stack,\n-                        const BasicType *sig_bt,\n-                        const VMRegPair *regs,\n-                        AdapterFingerPrint *fingerprint) {\n-  return AdapterHandlerLibrary::new_entry(\n-    fingerprint,\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub),\n-    CAST_FROM_FN_PTR(address,zero_null_code_stub));\n+void SharedRuntime::generate_i2c2i_adapters(MacroAssembler *masm,\n+                                            int total_args_passed,\n+                                            int comp_args_on_stack,\n+                                            const BasicType *sig_bt,\n+                                            const VMRegPair *regs,\n+                                            AdapterHandlerEntry* handler) {\n+  handler->set_entry_points(CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            CAST_FROM_FN_PTR(address,zero_null_code_stub),\n+                            nullptr);\n+  return;\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -274,5 +274,2 @@\n-        \/\/ Pull a pointer to the error message out of the instruction\n-        \/\/ stream.\n-        const uint64_t *detail_msg_ptr\n-          = (uint64_t*)(pc + NativeInstruction::instruction_size);\n-        const char *detail_msg = (const char *)*detail_msg_ptr;\n+        \/\/ A pointer to the message will have been placed in r0\n+        const char *detail_msg = (const char *)(uc->uc_mcontext->DU3_PREFIX(ss,x[0]));\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -251,5 +251,2 @@\n-        \/\/ Pull a pointer to the error message out of the instruction\n-        \/\/ stream.\n-        const uint64_t *detail_msg_ptr\n-          = (uint64_t*)(pc + NativeInstruction::instruction_size);\n-        const char *detail_msg = (const char *)*detail_msg_ptr;\n+        \/\/ A pointer to the message will have been placed in r0\n+        const char *detail_msg = (const char *)(uc->uc_mcontext.regs[0]);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -725,1 +725,1 @@\n-    ((CodeBuffer*)this)->print();\n+    ((CodeBuffer*)this)->print_on(tty);\n@@ -864,1 +864,1 @@\n-    this->print();\n+    this->print_on(tty);\n@@ -952,1 +952,1 @@\n-    this->print();\n+    this->print_on(tty);\n@@ -1069,1 +1069,1 @@\n-void CodeSection::print(const char* name) {\n+void CodeSection::print_on(outputStream* st, const char* name) {\n@@ -1071,1 +1071,1 @@\n-  tty->print_cr(\" %7s.code = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d)\",\n+  st->print_cr(\" %7s.code = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d)\",\n@@ -1073,1 +1073,1 @@\n-  tty->print_cr(\" %7s.locs = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d) point=%d\",\n+  st->print_cr(\" %7s.locs = \" PTR_FORMAT \" : \" PTR_FORMAT \" : \" PTR_FORMAT \" (%d of %d) point=%d\",\n@@ -1077,1 +1077,1 @@\n-    iter.print();\n+    iter.print_on(st);\n@@ -1081,2 +1081,2 @@\n-void CodeBuffer::print() {\n-  tty->print_cr(\"CodeBuffer:\");\n+void CodeBuffer::print_on(outputStream* st) {\n+  st->print_cr(\"CodeBuffer:%s\", name());\n@@ -1086,1 +1086,1 @@\n-    cs->print(code_section_name(n));\n+    cs->print_on(st, code_section_name(n));\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  friend class AOTCodeReader;\n@@ -286,1 +287,1 @@\n-  void print(const char* name);\n+  void print_on(outputStream* st, const char* name);\n@@ -389,0 +390,1 @@\n+  friend class AOTCodeReader;\n@@ -745,1 +747,1 @@\n-  void    print();\n+  void    print_on(outputStream* st);\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotCacheAccess.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/filemap.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/stringTable.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+\n+void* AOTCacheAccess::allocate_aot_code_region(size_t size) {\n+  assert(CDSConfig::is_dumping_final_static_archive(), \"must be\");\n+  return (void*)ArchiveBuilder::ac_region_alloc(size);\n+}\n+\n+size_t AOTCacheAccess::get_aot_code_region_size() {\n+  assert(CDSConfig::is_using_archive(), \"must be\");\n+  FileMapInfo* mapinfo = FileMapInfo::current_info();\n+  assert(mapinfo != nullptr, \"must be\");\n+  return mapinfo->region_at(MetaspaceShared::ac)->used_aligned();\n+}\n+\n+bool AOTCacheAccess::map_aot_code_region(ReservedSpace rs) {\n+  FileMapInfo* static_mapinfo = FileMapInfo::current_info();\n+  assert(UseSharedSpaces && static_mapinfo != nullptr, \"must be\");\n+  return static_mapinfo->map_aot_code_region(rs);\n+}\n","filename":"src\/hotspot\/share\/cds\/aotCacheAccess.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTCACHEACCESS_HPP\n+#define SHARE_CDS_AOTCACHEACCESS_HPP\n+\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ReservedSpace;\n+\n+\/\/ AOT Cache API for AOT compiler\n+\n+class AOTCacheAccess : AllStatic {\n+public:\n+  static void* allocate_aot_code_region(size_t size) NOT_CDS_RETURN_(nullptr);\n+\n+  static size_t get_aot_code_region_size() NOT_CDS_RETURN_(0);\n+\n+  static bool map_aot_code_region(ReservedSpace rs) NOT_CDS_RETURN_(false);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTCACHEACCESS_HPP\n","filename":"src\/hotspot\/share\/cds\/aotCacheAccess.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -166,0 +167,1 @@\n+  _ac_region(\"ac\", MAX_SHARED_DELTA),\n@@ -309,1 +311,2 @@\n-  size_t buffer_size = LP64_ONLY(CompressedClassSpaceSize) NOT_LP64(256 * M);\n+  \/\/ AOTCodeCache::max_aot_code_size() accounts for aot code region.\n+  size_t buffer_size = LP64_ONLY(CompressedClassSpaceSize) NOT_LP64(256 * M) + AOTCodeCache::max_aot_code_size();\n@@ -534,0 +537,7 @@\n+  } else if (ref->msotype() == MetaspaceObj::AdapterHandlerEntryType) {\n+    if (AOTCodeCache::is_dumping_adapters()) {\n+      AdapterHandlerEntry* entry = (AdapterHandlerEntry*)ref->obj();\n+      return AdapterHandlerLibrary::is_abstract_method_adapter(entry) ? set_to_null : make_a_copy;\n+    } else {\n+      return set_to_null;\n+    }\n@@ -707,0 +717,5 @@\n+bool ArchiveBuilder::has_been_archived(address src_addr) const {\n+  SourceObjInfo* p = _src_obj_table.get(src_addr);\n+  return (p != nullptr);\n+}\n+\n@@ -975,0 +990,9 @@\n+void ArchiveBuilder::start_ac_region() {\n+  ro_region()->pack();\n+  start_dump_region(&_ac_region);\n+}\n+\n+void ArchiveBuilder::end_ac_region() {\n+  _ac_region.pack();\n+}\n+\n@@ -1084,2 +1108,3 @@\n-  ro_region()->pack();\n-\n+  if (!ro_region()->is_packed()) {\n+    ro_region()->pack();\n+  }\n@@ -1529,0 +1554,1 @@\n+  write_region(mapinfo, MetaspaceShared::ac, &_ac_region, \/*read_only=*\/false,\/*allow_exec=*\/false);\n@@ -1581,0 +1607,1 @@\n+  _ac_region.print(total_reserved);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+  DumpRegion _ac_region; \/\/ AOT code\n@@ -375,0 +376,1 @@\n+  DumpRegion* ac_region() { return &_ac_region; }\n@@ -382,0 +384,6 @@\n+  static char* ac_region_alloc(size_t num_bytes) {\n+    return current()->ac_region()->allocate(num_bytes);\n+  }\n+\n+  void start_ac_region();\n+  void end_ac_region();\n@@ -429,0 +437,2 @@\n+  bool has_been_archived(address src_addr) const;\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -273,0 +273,1 @@\n+  char* base = used() > 0 ? ArchiveBuilder::current()->to_requested(_base) : nullptr;\n@@ -275,1 +276,1 @@\n-                 p2i(ArchiveBuilder::current()->to_requested(_base)));\n+                 p2i(base));\n@@ -298,1 +299,4 @@\n-  assert(!is_packed(), \"sanity\");\n+  if (!is_packed()) {\n+    _end = (char*)align_up(_top, MetaspaceShared::core_region_alignment());\n+    _is_packed = true;\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+  bool is_empty()   const { return _base == _top; }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -405,0 +405,4 @@\n+  if (FLAG_IS_DEFAULT(AOTCache) && AOTAdapterCaching) {\n+    log_debug(aot,codecache,init)(\"AOTCache is not specified - AOTAdapterCaching is ignored\");\n+  }\n+\n@@ -520,1 +524,1 @@\n-    if (is_dumping_preimage_static_archive()) {\n+    if (is_dumping_preimage_static_archive() || is_dumping_final_static_archive()) {\n@@ -850,0 +854,19 @@\n+\n+\/\/ AOT code generation and its archiving is disabled by default.\n+\/\/ We enable it only in the final image dump after the metadata and heap are dumped.\n+\/\/ This affects only JITed code because it may have embedded oops and metadata pointers\n+\/\/ which AOT code encodes as offsets in final CDS archive regions.\n+\n+static bool _is_dumping_aot_code = false;\n+\n+bool CDSConfig::is_dumping_aot_code() {\n+  return _is_dumping_aot_code;\n+}\n+\n+void CDSConfig::disable_dumping_aot_code() {\n+  _is_dumping_aot_code = false;\n+}\n+\n+void CDSConfig::enable_dumping_aot_code() {\n+  _is_dumping_aot_code = true;\n+}\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -184,0 +184,6 @@\n+  \/\/ --- AOT code\n+\n+  static bool is_dumping_aot_code()                          NOT_CDS_RETURN_(false);\n+  static void disable_dumping_aot_code()                     NOT_CDS_RETURN;\n+  static void enable_dumping_aot_code()                      NOT_CDS_RETURN;\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,0 +130,16 @@\n+  \/* AOT Code flags *\/                                                      \\\n+                                                                            \\\n+  product(bool, AOTAdapterCaching, false, DIAGNOSTIC,                       \\\n+          \"Enable saving and restoring i2c2i adapters in AOT cache\")        \\\n+                                                                            \\\n+  product(uint, AOTCodeMaxSize, 10*M, DIAGNOSTIC,                           \\\n+          \"Buffer size in bytes for AOT code caching\")                      \\\n+          range(1*M, max_jint)                                              \\\n+                                                                            \\\n+  product(bool, AbortVMOnAOTCodeFailure, false, DIAGNOSTIC,                 \\\n+          \"Abort VM on the first occurrence of AOT code load or store \"     \\\n+          \"failure. By default VM will continue execute without AOT code.\") \\\n+                                                                            \\\n+  develop(bool, TestAOTAdapterLinkFailure, false,                           \\\n+          \"Test failure of adapter linking when loading from AOT cache.\")   \\\n+\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -284,0 +284,2 @@\n+  case MetaspaceObj::AdapterHandlerEntryType:\n+  case MetaspaceObj::AdapterFingerPrintType:\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -827,1 +827,1 @@\n-    \"rw\", \"ro\", \"bm\", \"hp\"\n+    \"rw\", \"ro\", \"bm\", \"hp\", \"ac\"\n@@ -913,0 +913,3 @@\n+  } else {\n+     log_info(cds)(\"Shared file region (%s) %d: %8zu\"\n+                   \" bytes\", region_name(region), region, size);\n@@ -1114,1 +1117,1 @@\n-static const char* shared_region_name[] = { \"ReadWrite\", \"ReadOnly\", \"Bitmap\", \"Heap\" };\n+static const char* shared_region_name[] = { \"ReadWrite\", \"ReadOnly\", \"Bitmap\", \"Heap\", \"Code\" };\n@@ -1277,0 +1280,36 @@\n+bool FileMapInfo::map_aot_code_region(ReservedSpace rs) {\n+  FileMapRegion* r = region_at(MetaspaceShared::ac);\n+  assert(r->used() > 0 && r->used_aligned() == rs.size(), \"must be\");\n+\n+  char* requested_base = rs.base();\n+  assert(requested_base != nullptr, \"should be inside code cache\");\n+\n+  char* mapped_base;\n+  if (MetaspaceShared::use_windows_memory_mapping()) {\n+    if (!read_region(MetaspaceShared::ac, requested_base, r->used_aligned(), \/* do_commit = *\/ true)) {\n+      log_info(cds)(\"Failed to read aot code shared space into reserved space at \" INTPTR_FORMAT,\n+                    p2i(requested_base));\n+      return false;\n+    }\n+    mapped_base = requested_base;\n+  } else {\n+    \/\/ We do not execute in-place in the AOT code region.\n+    \/\/ AOT code is copied to the CodeCache for execution.\n+    bool read_only = false, allow_exec = false;\n+    mapped_base = map_memory(_fd, _full_path, r->file_offset(),\n+                             requested_base, r->used_aligned(), read_only, allow_exec, mtClassShared);\n+  }\n+  if (mapped_base == nullptr) {\n+    log_info(cds)(\"failed to map aot code region\");\n+    return false;\n+  } else {\n+    assert(mapped_base == requested_base, \"must be\");\n+    r->set_mapped_from_file(true);\n+    r->set_mapped_base(mapped_base);\n+    log_info(cds)(\"Mapped static  region #%d at base \" INTPTR_FORMAT \" top \" INTPTR_FORMAT \" (%s)\",\n+                  MetaspaceShared::ac, p2i(r->mapped_base()), p2i(r->mapped_end()),\n+                  shared_region_name[MetaspaceShared::ac]);\n+    return true;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+  bool  map_aot_code_region(ReservedSpace rs);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -493,0 +494,2 @@\n+  AdapterHandlerLibrary::serialize_shared_table_header(soc);\n+\n@@ -611,0 +614,4 @@\n+  if (AOTCodeCache::is_dumping_adapters()) {\n+    AdapterHandlerLibrary::dump_aot_adapter_table();\n+  }\n+\n@@ -1008,0 +1015,11 @@\n+  if (AOTCodeCache::is_on_for_dump() && CDSConfig::is_dumping_final_static_archive()) {\n+    CDSConfig::enable_dumping_aot_code();\n+    {\n+      builder.start_ac_region();\n+      \/\/ Write the contents to AOT code region and close AOTCodeCache before packing the region\n+      AOTCodeCache::close();\n+      builder.end_ac_region();\n+    }\n+    CDSConfig::disable_dumping_aot_code();\n+  }\n+\n@@ -1775,0 +1793,1 @@\n+  AOTCodeCache::initialize();\n@@ -1826,0 +1845,5 @@\n+    if (AOTCodeCache::is_on_for_use()) {\n+      tty->print_cr(\"\\n\\nAOT Code\");\n+      AOTCodeCache::print_on(tty);\n+    }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+    ac = 4,  \/\/ aot code\n@@ -71,1 +72,1 @@\n-    n_regions = 4              \/\/ total number of regions\n+    n_regions = 5              \/\/ total number of regions\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -285,1 +285,9 @@\n-  inline void iterate(ITER* iter) const {\n+  inline void iterate(ITER* iter) const { iterate([&](V v) { iter->do_value(v); }); }\n+\n+  template<typename Function>\n+  inline void iterate(const Function& function) const { \/\/ lambda enabled API\n+    iterate(const_cast<Function&>(function));\n+  }\n+\n+  template<typename Function>\n+  inline void iterate(Function& function) const { \/\/ lambda enabled API\n@@ -293,1 +301,1 @@\n-        iter->do_value(decode(entry[0]));\n+        function(decode(entry[0]));\n@@ -295,1 +303,1 @@\n-        u4*entry_max = _entries + BUCKET_OFFSET(_buckets[i + 1]);\n+        u4* entry_max = _entries + BUCKET_OFFSET(_buckets[i + 1]);\n@@ -297,1 +305,1 @@\n-          iter->do_value(decode(entry[1]));\n+          function(decode(entry[1]));\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,1317 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotCacheAccess.hpp\"\n+#include \"cds\/cds_globals.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/javaAssertions.hpp\"\n+#include \"code\/aotCodeCache.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"gc\/shared\/gcConfig.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/memoryReserver.hpp\"\n+#include \"runtime\/flags\/flagSetting.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#ifdef COMPILER2\n+#include \"opto\/runtime.hpp\"\n+#endif\n+#if INCLUDE_G1GC\n+#include \"gc\/g1\/g1BarrierSetRuntime.hpp\"\n+#endif\n+#if INCLUDE_ZGC\n+#include \"gc\/z\/zBarrierSetRuntime.hpp\"\n+#endif\n+\n+#include <sys\/stat.h>\n+#include <errno.h>\n+\n+static void report_load_failure() {\n+  if (AbortVMOnAOTCodeFailure) {\n+    vm_exit_during_initialization(\"Unable to use AOT Code Cache.\", nullptr);\n+  }\n+  log_warning(aot, codecache, init)(\"Unable to use AOT Code Cache.\");\n+  AOTAdapterCaching = false;\n+}\n+\n+static void report_store_failure() {\n+  if (AbortVMOnAOTCodeFailure) {\n+    tty->print_cr(\"Unable to create AOT Code Cache.\");\n+    vm_abort(false);\n+  }\n+  log_warning(aot, codecache, exit)(\"Unable to create AOT Code Cache.\");\n+  AOTAdapterCaching = false;\n+}\n+\n+static uint _max_aot_code_size = 0;\n+uint AOTCodeCache::max_aot_code_size() {\n+  return _max_aot_code_size;\n+}\n+\n+void AOTCodeCache::initialize() {\n+  if (FLAG_IS_DEFAULT(AOTCache)) {\n+    log_info(aot, codecache, init)(\"AOT Code Cache is not used: AOTCache is not specified.\");\n+    return; \/\/ AOTCache must be specified to dump and use AOT code\n+  }\n+\n+  bool is_dumping = false;\n+  bool is_using   = false;\n+  if (CDSConfig::is_dumping_final_static_archive() && CDSConfig::is_dumping_aot_linked_classes()) {\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n+    is_dumping = true;\n+  } else if (CDSConfig::is_using_archive() && CDSConfig::is_using_aot_linked_classes()) {\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTAdapterCaching, true);\n+    is_using = true;\n+  } else {\n+    log_info(aot, codecache, init)(\"AOT Code Cache is not used: AOT Class Linking is not used.\");\n+    return; \/\/ nothing to do\n+  }\n+  if (!AOTAdapterCaching) {\n+    return; \/\/ AOT code caching disabled on command line\n+  }\n+  _max_aot_code_size = AOTCodeMaxSize;\n+  if (!FLAG_IS_DEFAULT(AOTCodeMaxSize)) {\n+    if (!is_aligned(AOTCodeMaxSize, os::vm_allocation_granularity())) {\n+      _max_aot_code_size = align_up(AOTCodeMaxSize, os::vm_allocation_granularity());\n+      log_debug(aot,codecache,init)(\"Max AOT Code Cache size is aligned up to %uK\", (int)(max_aot_code_size()\/K));\n+    }\n+  }\n+  size_t aot_code_size = is_using ? AOTCacheAccess::get_aot_code_region_size() : 0;\n+  if (is_using && aot_code_size == 0) {\n+    log_info(aot, codecache, init)(\"AOT Code Cache is empty\");\n+    return;\n+  }\n+  if (!open_cache(is_dumping, is_using)) {\n+    if (is_using) {\n+      report_load_failure();\n+    } else {\n+      report_store_failure();\n+    }\n+    return;\n+  }\n+  if (is_dumping) {\n+    FLAG_SET_DEFAULT(ForceUnreachable, true);\n+  }\n+  FLAG_SET_DEFAULT(DelayCompilerStubsGeneration, false);\n+}\n+\n+void AOTCodeCache::init2() {\n+  if (!is_on()) {\n+    return;\n+  }\n+  if (!verify_vm_config()) {\n+    close();\n+    report_load_failure();\n+  }\n+  \/\/ initialize the table of external routines so we can save\n+  \/\/ generated code blobs that reference them\n+  init_extrs_table();\n+}\n+\n+AOTCodeCache* AOTCodeCache::_cache = nullptr;\n+\n+bool AOTCodeCache::open_cache(bool is_dumping, bool is_using) {\n+  AOTCodeCache* cache = new AOTCodeCache(is_dumping, is_using);\n+  if (cache->failed()) {\n+    delete cache;\n+    _cache = nullptr;\n+    return false;\n+  }\n+  _cache = cache;\n+  return true;\n+}\n+\n+void AOTCodeCache::close() {\n+  if (is_on()) {\n+    delete _cache; \/\/ Free memory\n+    _cache = nullptr;\n+  }\n+}\n+\n+#define DATA_ALIGNMENT HeapWordSize\n+\n+AOTCodeCache::AOTCodeCache(bool is_dumping, bool is_using) :\n+  _load_header(nullptr),\n+  _load_buffer(nullptr),\n+  _store_buffer(nullptr),\n+  _C_store_buffer(nullptr),\n+  _write_position(0),\n+  _load_size(0),\n+  _store_size(0),\n+  _for_use(is_using),\n+  _for_dump(is_dumping),\n+  _adapter_caching(AOTAdapterCaching),\n+  _closing(false),\n+  _failed(false),\n+  _lookup_failed(false),\n+  _table(nullptr),\n+  _load_entries(nullptr),\n+  _search_entries(nullptr),\n+  _store_entries(nullptr),\n+  _C_strings_buf(nullptr),\n+  _store_entries_cnt(0)\n+{\n+  \/\/ Read header at the begining of cache\n+  if (_for_use) {\n+    \/\/ Read cache\n+    size_t load_size = AOTCacheAccess::get_aot_code_region_size();\n+    ReservedSpace rs = MemoryReserver::reserve(load_size, mtCode);\n+    if (!rs.is_reserved()) {\n+      log_warning(aot, codecache, init)(\"Failed to reserved %u bytes of memory for mapping AOT code region into AOT Code Cache\", (uint)load_size);\n+      set_failed();\n+      return;\n+    }\n+    if (!AOTCacheAccess::map_aot_code_region(rs)) {\n+      log_warning(aot, codecache, init)(\"Failed to read\/mmap cached code region into AOT Code Cache\");\n+      set_failed();\n+      return;\n+    }\n+\n+    _load_size = (uint)load_size;\n+    _load_buffer = (char*)rs.base();\n+    assert(is_aligned(_load_buffer, DATA_ALIGNMENT), \"load_buffer is not aligned\");\n+    log_debug(aot, codecache, init)(\"Mapped %u bytes at address \" INTPTR_FORMAT \" at AOT Code Cache\", _load_size, p2i(_load_buffer));\n+\n+    _load_header = (Header*)addr(0);\n+    if (!_load_header->verify_config(_load_size)) {\n+      set_failed();\n+      return;\n+    }\n+    log_info (aot, codecache, init)(\"Loaded %u AOT code entries from AOT Code Cache\", _load_header->entries_count());\n+    log_debug(aot, codecache, init)(\"  Adapters:  total=%u\", _load_header->adapters_count());\n+    log_debug(aot, codecache, init)(\"  All Blobs: total=%u\", _load_header->blobs_count());\n+    log_debug(aot, codecache, init)(\"  AOT code cache size: %u bytes\", _load_header->cache_size());\n+\n+    \/\/ Read strings\n+    load_strings();\n+  }\n+  if (_for_dump) {\n+    _C_store_buffer = NEW_C_HEAP_ARRAY(char, max_aot_code_size() + DATA_ALIGNMENT, mtCode);\n+    _store_buffer = align_up(_C_store_buffer, DATA_ALIGNMENT);\n+    \/\/ Entries allocated at the end of buffer in reverse (as on stack).\n+    _store_entries = (AOTCodeEntry*)align_up(_C_store_buffer + max_aot_code_size(), DATA_ALIGNMENT);\n+    log_debug(aot, codecache, init)(\"Allocated store buffer at address \" INTPTR_FORMAT \" of size %u\", p2i(_store_buffer), max_aot_code_size());\n+  }\n+  _table = new AOTCodeAddressTable();\n+}\n+\n+void AOTCodeCache::init_extrs_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_extrs();\n+  }\n+}\n+\n+void AOTCodeCache::init_shared_blobs_table() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->init_shared_blobs();\n+  }\n+}\n+\n+AOTCodeCache::~AOTCodeCache() {\n+  if (_closing) {\n+    return; \/\/ Already closed\n+  }\n+  \/\/ Stop any further access to cache.\n+  _closing = true;\n+\n+  MutexLocker ml(Compile_lock);\n+  if (for_dump()) { \/\/ Finalize cache\n+    finish_write();\n+  }\n+  _load_buffer = nullptr;\n+  if (_C_store_buffer != nullptr) {\n+    FREE_C_HEAP_ARRAY(char, _C_store_buffer);\n+    _C_store_buffer = nullptr;\n+    _store_buffer = nullptr;\n+  }\n+  if (_table != nullptr) {\n+    delete _table;\n+    _table = nullptr;\n+  }\n+}\n+\n+void AOTCodeCache::Config::record() {\n+  _flags = 0;\n+#ifdef ASSERT\n+  _flags |= debugVM;\n+#endif\n+  if (UseCompressedOops) {\n+    _flags |= compressedOops;\n+  }\n+  if (UseCompressedClassPointers) {\n+    _flags |= compressedClassPointers;\n+  }\n+  if (UseTLAB) {\n+    _flags |= useTLAB;\n+  }\n+  if (JavaAssertions::systemClassDefault()) {\n+    _flags |= systemClassAssertions;\n+  }\n+  if (JavaAssertions::userClassDefault()) {\n+    _flags |= userClassAssertions;\n+  }\n+  if (EnableContended) {\n+    _flags |= enableContendedPadding;\n+  }\n+  if (RestrictContended) {\n+    _flags |= restrictContendedPadding;\n+  }\n+  _compressedOopShift    = CompressedOops::shift();\n+  _compressedKlassShift  = CompressedKlassPointers::shift();\n+  _contendedPaddingWidth = ContendedPaddingWidth;\n+  _objectAlignment       = ObjectAlignmentInBytes;\n+  _gc                    = (uint)Universe::heap()->kind();\n+}\n+\n+bool AOTCodeCache::Config::verify() const {\n+#ifdef ASSERT\n+  if ((_flags & debugVM) == 0) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created by product VM, it can't be used by debug VM\");\n+    return false;\n+  }\n+#else\n+  if ((_flags & debugVM) != 0) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created by debug VM, it can't be used by product VM\");\n+    return false;\n+  }\n+#endif\n+\n+  CollectedHeap::Name aot_gc = (CollectedHeap::Name)_gc;\n+  if (aot_gc != Universe::heap()->kind()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with different GC: %s vs current %s\", GCConfig::hs_err_name(aot_gc), GCConfig::hs_err_name());\n+    return false;\n+  }\n+\n+  if (((_flags & compressedOops) != 0) != UseCompressedOops) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseCompressedOops = %s\", UseCompressedOops ? \"false\" : \"true\");\n+    return false;\n+  }\n+  if (((_flags & compressedClassPointers) != 0) != UseCompressedClassPointers) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with UseCompressedClassPointers = %s\", UseCompressedClassPointers ? \"false\" : \"true\");\n+    return false;\n+  }\n+\n+  if (((_flags & systemClassAssertions) != 0) != JavaAssertions::systemClassDefault()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with JavaAssertions::systemClassDefault() = %s\", JavaAssertions::systemClassDefault() ? \"disabled\" : \"enabled\");\n+    return false;\n+  }\n+  if (((_flags & userClassAssertions) != 0) != JavaAssertions::userClassDefault()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with JavaAssertions::userClassDefault() = %s\", JavaAssertions::userClassDefault() ? \"disabled\" : \"enabled\");\n+    return false;\n+  }\n+\n+  if (((_flags & enableContendedPadding) != 0) != EnableContended) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with EnableContended = %s\", EnableContended ? \"false\" : \"true\");\n+    return false;\n+  }\n+  if (((_flags & restrictContendedPadding) != 0) != RestrictContended) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with RestrictContended = %s\", RestrictContended ? \"false\" : \"true\");\n+    return false;\n+  }\n+  if (_compressedOopShift != (uint)CompressedOops::shift()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedOops::shift() = %d vs current %d\", _compressedOopShift, CompressedOops::shift());\n+    return false;\n+  }\n+  if (_compressedKlassShift != (uint)CompressedKlassPointers::shift()) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with CompressedKlassPointers::shift() = %d vs current %d\", _compressedKlassShift, CompressedKlassPointers::shift());\n+    return false;\n+  }\n+  if (_contendedPaddingWidth != (uint)ContendedPaddingWidth) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with ContendedPaddingWidth = %d vs current %d\", _contendedPaddingWidth, ContendedPaddingWidth);\n+    return false;\n+  }\n+  if (_objectAlignment != (uint)ObjectAlignmentInBytes) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: it was created with ObjectAlignmentInBytes = %d vs current %d\", _objectAlignment, ObjectAlignmentInBytes);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool AOTCodeCache::Header::verify_config(uint load_size) const {\n+  if (_version != AOT_CODE_VERSION) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: different AOT Code version %d vs %d recorded in AOT Code header\", AOT_CODE_VERSION, _version);\n+    return false;\n+  }\n+  if (load_size < _cache_size) {\n+    log_debug(aot, codecache, init)(\"AOT Code Cache disabled: AOT Code Cache size %d < %d recorded in AOT Code header\", load_size, _cache_size);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+AOTCodeCache* AOTCodeCache::open_for_use() {\n+  if (AOTCodeCache::is_on_for_use()) {\n+    return AOTCodeCache::cache();\n+  }\n+  return nullptr;\n+}\n+\n+AOTCodeCache* AOTCodeCache::open_for_dump() {\n+  if (AOTCodeCache::is_on_for_dump()) {\n+    AOTCodeCache* cache = AOTCodeCache::cache();\n+    cache->clear_lookup_failed(); \/\/ Reset bit\n+    return cache;\n+  }\n+  return nullptr;\n+}\n+\n+void copy_bytes(const char* from, address to, uint size) {\n+  assert(size > 0, \"sanity\");\n+  bool by_words = true;\n+  if ((size > 2 * HeapWordSize) && (((intptr_t)from | (intptr_t)to) & (HeapWordSize - 1)) == 0) {\n+    \/\/ Use wordwise copies if possible:\n+    Copy::disjoint_words((HeapWord*)from,\n+                         (HeapWord*)to,\n+                         ((size_t)size + HeapWordSize-1) \/ HeapWordSize);\n+  } else {\n+    by_words = false;\n+    Copy::conjoint_jbytes(from, to, (size_t)size);\n+  }\n+  log_trace(aot, codecache)(\"Copied %d bytes as %s from \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, size, (by_words ? \"HeapWord\" : \"bytes\"), p2i(from), p2i(to));\n+}\n+\n+AOTCodeReader::AOTCodeReader(AOTCodeCache* cache, AOTCodeEntry* entry) {\n+  _cache = cache;\n+  _entry = entry;\n+  _load_buffer = cache->cache_buffer();\n+  _read_position = 0;\n+  _lookup_failed = false;\n+}\n+\n+void AOTCodeReader::set_read_position(uint pos) {\n+  if (pos == _read_position) {\n+    return;\n+  }\n+  assert(pos < _cache->load_size(), \"offset:%d >= file size:%d\", pos, _cache->load_size());\n+  _read_position = pos;\n+}\n+\n+bool AOTCodeCache::set_write_position(uint pos) {\n+  if (pos == _write_position) {\n+    return true;\n+  }\n+  if (_store_size < _write_position) {\n+    _store_size = _write_position; \/\/ Adjust during write\n+  }\n+  assert(pos < _store_size, \"offset:%d >= file size:%d\", pos, _store_size);\n+  _write_position = pos;\n+  return true;\n+}\n+\n+static char align_buffer[256] = { 0 };\n+\n+bool AOTCodeCache::align_write() {\n+  \/\/ We are not executing code from cache - we copy it by bytes first.\n+  \/\/ No need for big alignment (or at all).\n+  uint padding = DATA_ALIGNMENT - (_write_position & (DATA_ALIGNMENT - 1));\n+  if (padding == DATA_ALIGNMENT) {\n+    return true;\n+  }\n+  uint n = write_bytes((const void*)&align_buffer, padding);\n+  if (n != padding) {\n+    return false;\n+  }\n+  log_trace(aot, codecache)(\"Adjust write alignment in AOT Code Cache\");\n+  return true;\n+}\n+\n+\/\/ Check to see if AOT code cache has required space to store \"nbytes\" of data\n+address AOTCodeCache::reserve_bytes(uint nbytes) {\n+  assert(for_dump(), \"Code Cache file is not created\");\n+  uint new_position = _write_position + nbytes;\n+  if (new_position >= (uint)((char*)_store_entries - _store_buffer)) {\n+    log_warning(aot,codecache)(\"Failed to ensure %d bytes at offset %d in AOT Code Cache. Increase AOTCodeMaxSize.\",\n+                               nbytes, _write_position);\n+    set_failed();\n+    report_store_failure();\n+    return nullptr;\n+  }\n+  address buffer = (address)(_store_buffer + _write_position);\n+  log_trace(aot, codecache)(\"Reserved %d bytes at offset %d in AOT Code Cache\", nbytes, _write_position);\n+  _write_position += nbytes;\n+  if (_store_size < _write_position) {\n+    _store_size = _write_position;\n+  }\n+  return buffer;\n+}\n+\n+uint AOTCodeCache::write_bytes(const void* buffer, uint nbytes) {\n+  assert(for_dump(), \"Code Cache file is not created\");\n+  if (nbytes == 0) {\n+    return 0;\n+  }\n+  uint new_position = _write_position + nbytes;\n+  if (new_position >= (uint)((char*)_store_entries - _store_buffer)) {\n+    log_warning(aot, codecache)(\"Failed to write %d bytes at offset %d to AOT Code Cache. Increase AOTCodeMaxSize.\",\n+                                nbytes, _write_position);\n+    set_failed();\n+    report_store_failure();\n+    return 0;\n+  }\n+  copy_bytes((const char* )buffer, (address)(_store_buffer + _write_position), nbytes);\n+  log_trace(aot, codecache)(\"Wrote %d bytes at offset %d to AOT Code Cache\", nbytes, _write_position);\n+  _write_position += nbytes;\n+  if (_store_size < _write_position) {\n+    _store_size = _write_position;\n+  }\n+  return nbytes;\n+}\n+\n+void* AOTCodeEntry::operator new(size_t x, AOTCodeCache* cache) {\n+  return (void*)(cache->add_entry());\n+}\n+\n+static bool check_entry(AOTCodeEntry::Kind kind, uint id, AOTCodeEntry* entry) {\n+  if (entry->kind() == kind) {\n+    assert(entry->id() == id, \"sanity\");\n+    return true; \/\/ Found\n+  }\n+  return false;\n+}\n+\n+AOTCodeEntry* AOTCodeCache::find_entry(AOTCodeEntry::Kind kind, uint id) {\n+  assert(_for_use, \"sanity\");\n+  uint count = _load_header->entries_count();\n+  if (_load_entries == nullptr) {\n+    \/\/ Read it\n+    _search_entries = (uint*)addr(_load_header->entries_offset()); \/\/ [id, index]\n+    _load_entries = (AOTCodeEntry*)(_search_entries + 2 * count);\n+    log_debug(aot, codecache, init)(\"Read %d entries table at offset %d from AOT Code Cache\", count, _load_header->entries_offset());\n+  }\n+  \/\/ Binary search\n+  int l = 0;\n+  int h = count - 1;\n+  while (l <= h) {\n+    int mid = (l + h) >> 1;\n+    int ix = mid * 2;\n+    uint is = _search_entries[ix];\n+    if (is == id) {\n+      int index = _search_entries[ix + 1];\n+      AOTCodeEntry* entry = &(_load_entries[index]);\n+      if (check_entry(kind, id, entry)) {\n+        return entry; \/\/ Found\n+      }\n+      break; \/\/ Not found match\n+    } else if (is < id) {\n+      l = mid + 1;\n+    } else {\n+      h = mid - 1;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+extern \"C\" {\n+  static int uint_cmp(const void *i, const void *j) {\n+    uint a = *(uint *)i;\n+    uint b = *(uint *)j;\n+    return a > b ? 1 : a < b ? -1 : 0;\n+  }\n+}\n+\n+bool AOTCodeCache::finish_write() {\n+  if (!align_write()) {\n+    return false;\n+  }\n+  uint strings_offset = _write_position;\n+  int strings_count = store_strings();\n+  if (strings_count < 0) {\n+    return false;\n+  }\n+  if (!align_write()) {\n+    return false;\n+  }\n+  uint strings_size = _write_position - strings_offset;\n+\n+  uint entries_count = 0; \/\/ Number of entrant (useful) code entries\n+  uint entries_offset = _write_position;\n+\n+  uint store_count = _store_entries_cnt;\n+  if (store_count > 0) {\n+    uint header_size = (uint)align_up(sizeof(AOTCodeCache::Header),  DATA_ALIGNMENT);\n+    uint code_count = store_count;\n+    uint search_count = code_count * 2;\n+    uint search_size = search_count * sizeof(uint);\n+    uint entries_size = (uint)align_up(code_count * sizeof(AOTCodeEntry), DATA_ALIGNMENT); \/\/ In bytes\n+    \/\/ _write_position includes size of code and strings\n+    uint code_alignment = code_count * DATA_ALIGNMENT; \/\/ We align_up code size when storing it.\n+    uint total_size = header_size + _write_position + code_alignment + search_size + entries_size;\n+    assert(total_size < max_aot_code_size(), \"AOT Code size (\" UINT32_FORMAT \" bytes) is greater than AOTCodeMaxSize(\" UINT32_FORMAT \" bytes).\", total_size, max_aot_code_size());\n+\n+    \/\/ Create ordered search table for entries [id, index];\n+    uint* search = NEW_C_HEAP_ARRAY(uint, search_count, mtCode);\n+    \/\/ Allocate in AOT Cache buffer\n+    char* buffer = (char *)AOTCacheAccess::allocate_aot_code_region(total_size + DATA_ALIGNMENT);\n+    char* start = align_up(buffer, DATA_ALIGNMENT);\n+    char* current = start + header_size; \/\/ Skip header\n+\n+    AOTCodeEntry* entries_address = _store_entries; \/\/ Pointer to latest entry\n+    uint adapters_count = 0;\n+    uint blobs_count = 0;\n+    uint max_size = 0;\n+    \/\/ AOTCodeEntry entries were allocated in reverse in store buffer.\n+    \/\/ Process them in reverse order to cache first code first.\n+    for (int i = store_count - 1; i >= 0; i--) {\n+      entries_address[i].set_next(nullptr); \/\/ clear pointers before storing data\n+      uint size = align_up(entries_address[i].size(), DATA_ALIGNMENT);\n+      if (size > max_size) {\n+        max_size = size;\n+      }\n+      copy_bytes((_store_buffer + entries_address[i].offset()), (address)current, size);\n+      entries_address[i].set_offset(current - start); \/\/ New offset\n+      current += size;\n+      uint n = write_bytes(&(entries_address[i]), sizeof(AOTCodeEntry));\n+      if (n != sizeof(AOTCodeEntry)) {\n+        FREE_C_HEAP_ARRAY(uint, search);\n+        return false;\n+      }\n+      search[entries_count*2 + 0] = entries_address[i].id();\n+      search[entries_count*2 + 1] = entries_count;\n+      entries_count++;\n+      AOTCodeEntry::Kind kind = entries_address[i].kind();\n+      if (kind == AOTCodeEntry::Adapter) {\n+        adapters_count++;\n+      } else if (kind == AOTCodeEntry::Blob) {\n+        blobs_count++;\n+      }\n+    }\n+    if (entries_count == 0) {\n+      log_info(aot, codecache, exit)(\"AOT Code Cache was not created: no entires\");\n+      FREE_C_HEAP_ARRAY(uint, search);\n+      return true; \/\/ Nothing to write\n+    }\n+    assert(entries_count <= store_count, \"%d > %d\", entries_count, store_count);\n+    \/\/ Write strings\n+    if (strings_count > 0) {\n+      copy_bytes((_store_buffer + strings_offset), (address)current, strings_size);\n+      strings_offset = (current - start); \/\/ New offset\n+      current += strings_size;\n+    }\n+\n+    uint new_entries_offset = (current - start); \/\/ New offset\n+    \/\/ Sort and store search table\n+    qsort(search, entries_count, 2*sizeof(uint), uint_cmp);\n+    search_size = 2 * entries_count * sizeof(uint);\n+    copy_bytes((const char*)search, (address)current, search_size);\n+    FREE_C_HEAP_ARRAY(uint, search);\n+    current += search_size;\n+\n+    \/\/ Write entries\n+    entries_size = entries_count * sizeof(AOTCodeEntry); \/\/ New size\n+    copy_bytes((_store_buffer + entries_offset), (address)current, entries_size);\n+    current += entries_size;\n+    uint size = (current - start);\n+    assert(size <= total_size, \"%d > %d\", size , total_size);\n+\n+    log_debug(aot, codecache, exit)(\"  Adapters:  total=%u\", adapters_count);\n+    log_debug(aot, codecache, exit)(\"  All Blobs: total=%u\", blobs_count);\n+    log_debug(aot, codecache, exit)(\"  AOT code cache size: %u bytes, max entry's size: %u bytes\", size, max_size);\n+\n+    \/\/ Finalize header\n+    AOTCodeCache::Header* header = (AOTCodeCache::Header*)start;\n+    header->init(size, (uint)strings_count, strings_offset,\n+                 entries_count, new_entries_offset,\n+                 adapters_count, blobs_count);\n+\n+    log_info(aot, codecache, exit)(\"Wrote %d AOT code entries to AOT Code Cache\", entries_count);\n+  }\n+  return true;\n+}\n+\n+\/\/------------------Store\/Load AOT code ----------------------\n+\n+bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, uint id, const char* name, int entry_offset_count, int* entry_offsets) {\n+  AOTCodeCache* cache = open_for_dump();\n+  if (cache == nullptr) {\n+    return false;\n+  }\n+  assert(AOTCodeEntry::is_valid_entry_kind(entry_kind), \"invalid entry_kind %d\", entry_kind);\n+\n+  if ((entry_kind == AOTCodeEntry::Adapter) && !cache->adapter_caching()) {\n+    return false;\n+  }\n+  log_debug(aot, codecache, stubs)(\"Writing blob '%s' to AOT Code Cache\", name);\n+\n+#ifdef ASSERT\n+  LogStreamHandle(Trace, aot, codecache, stubs) log;\n+  if (log.is_enabled()) {\n+    FlagSetting fs(PrintRelocations, true);\n+    blob.print_on(&log);\n+  }\n+#endif\n+  \/\/ we need to take a lock to prevent race between compiler threads generating AOT code\n+  \/\/ and the main thread generating adapter\n+  MutexLocker ml(Compile_lock);\n+  if (!cache->align_write()) {\n+    return false;\n+  }\n+  uint entry_position = cache->_write_position;\n+\n+  \/\/ Write name\n+  uint name_offset = cache->_write_position - entry_position;\n+  uint name_size = (uint)strlen(name) + 1; \/\/ Includes '\/0'\n+  uint n = cache->write_bytes(name, name_size);\n+  if (n != name_size) {\n+    return false;\n+  }\n+\n+  \/\/ Write CodeBlob\n+  if (!cache->align_write()) {\n+    return false;\n+  }\n+  uint blob_offset = cache->_write_position - entry_position;\n+  address archive_buffer = cache->reserve_bytes(blob.size());\n+  if (archive_buffer == nullptr) {\n+    return false;\n+  }\n+  CodeBlob::archive_blob(&blob, archive_buffer);\n+\n+  uint reloc_data_size = blob.relocation_size();\n+  n = cache->write_bytes((address)blob.relocation_begin(), reloc_data_size);\n+  if (n != reloc_data_size) {\n+    return false;\n+  }\n+\n+  bool has_oop_maps = false;\n+  if (blob.oop_maps() != nullptr) {\n+    if (!cache->write_oop_map_set(blob)) {\n+      return false;\n+    }\n+    has_oop_maps = true;\n+  }\n+\n+  if (!cache->write_relocations(blob)) {\n+    return false;\n+  }\n+\n+  \/\/ Write entries offsets\n+  n = cache->write_bytes(&entry_offset_count, sizeof(int));\n+  if (n != sizeof(int)) {\n+    return false;\n+  }\n+  for (int i = 0; i < entry_offset_count; i++) {\n+    uint32_t off = (uint32_t)entry_offsets[i];\n+    n = cache->write_bytes(&off, sizeof(uint32_t));\n+    if (n != sizeof(uint32_t)) {\n+      return false;\n+    }\n+  }\n+  uint entry_size = cache->_write_position - entry_position;\n+  AOTCodeEntry* entry = new(cache) AOTCodeEntry(entry_kind, id,\n+                                                entry_position, entry_size, name_offset, name_size,\n+                                                blob_offset, has_oop_maps, blob.content_begin());\n+  log_debug(aot, codecache, stubs)(\"Wrote code blob '%s(id=%d)' to AOT Code Cache\", name, id);\n+  return true;\n+}\n+\n+CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, uint id, const char* name, int entry_offset_count, int* entry_offsets) {\n+  AOTCodeCache* cache = open_for_use();\n+  if (cache == nullptr) {\n+    return nullptr;\n+  }\n+  assert(AOTCodeEntry::is_valid_entry_kind(entry_kind), \"invalid entry_kind %d\", entry_kind);\n+\n+  if ((entry_kind == AOTCodeEntry::Adapter) && !cache->adapter_caching()) {\n+    return nullptr;\n+  }\n+  log_debug(aot, codecache, stubs)(\"Reading blob '%s' from AOT Code Cache\", name);\n+\n+  AOTCodeEntry* entry = cache->find_entry(entry_kind, id);\n+  if (entry == nullptr) {\n+    return nullptr;\n+  }\n+  AOTCodeReader reader(cache, entry);\n+  return reader.compile_code_blob(name, entry_offset_count, entry_offsets);\n+}\n+\n+CodeBlob* AOTCodeReader::compile_code_blob(const char* name, int entry_offset_count, int* entry_offsets) {\n+  uint entry_position = _entry->offset();\n+\n+  \/\/ Read name\n+  uint name_offset = entry_position + _entry->name_offset();\n+  uint name_size = _entry->name_size(); \/\/ Includes '\/0'\n+  const char* stored_name = addr(name_offset);\n+\n+  if (strncmp(stored_name, name, (name_size - 1)) != 0) {\n+    log_warning(aot, codecache, stubs)(\"Saved blob's name '%s' is different from the expected name '%s'\",\n+                                       stored_name, name);\n+    ((AOTCodeCache*)_cache)->set_failed();\n+    report_load_failure();\n+    return nullptr;\n+  }\n+\n+  \/\/ Read archived code blob\n+  uint offset = entry_position + _entry->blob_offset();\n+  CodeBlob* archived_blob = (CodeBlob*)addr(offset);\n+  offset += archived_blob->size();\n+\n+  address reloc_data = (address)addr(offset);\n+  offset += archived_blob->relocation_size();\n+  set_read_position(offset);\n+\n+  ImmutableOopMapSet* oop_maps = nullptr;\n+  if (_entry->has_oop_maps()) {\n+    oop_maps = read_oop_map_set();\n+  }\n+\n+  CodeBlob* code_blob = CodeBlob::create(archived_blob, stored_name, reloc_data, oop_maps);\n+  if (code_blob == nullptr) { \/\/ no space left in CodeCache\n+    return nullptr;\n+  }\n+\n+  fix_relocations(code_blob);\n+\n+  \/\/ Read entries offsets\n+  offset = read_position();\n+  int stored_count = *(int*)addr(offset);\n+  assert(stored_count == entry_offset_count, \"entry offset count mismatch, count in AOT code cache=%d, expected=%d\", stored_count, entry_offset_count);\n+  offset += sizeof(int);\n+  set_read_position(offset);\n+  for (int i = 0; i < stored_count; i++) {\n+    uint32_t off = *(uint32_t*)addr(offset);\n+    offset += sizeof(uint32_t);\n+    const char* entry_name = (_entry->kind() == AOTCodeEntry::Adapter) ? AdapterHandlerEntry::entry_name(i) : \"\";\n+    log_trace(aot, codecache, stubs)(\"Reading adapter '%s:%s' (0x%x) offset: 0x%x from AOT Code Cache\",\n+                                      stored_name, entry_name, _entry->id(), off);\n+    entry_offsets[i] = off;\n+  }\n+\n+  log_debug(aot, codecache, stubs)(\"Read blob '%s' from AOT Code Cache\", name);\n+#ifdef ASSERT\n+  LogStreamHandle(Trace, aot, codecache, stubs) log;\n+  if (log.is_enabled()) {\n+    FlagSetting fs(PrintRelocations, true);\n+    code_blob->print_on(&log);\n+  }\n+#endif\n+  return code_blob;\n+}\n+\n+\/\/ ------------ process code and data --------------\n+\n+bool AOTCodeCache::write_relocations(CodeBlob& code_blob) {\n+  GrowableArray<uint> reloc_data;\n+  RelocIterator iter(&code_blob);\n+  LogStreamHandle(Trace, aot, codecache, reloc) log;\n+  while (iter.next()) {\n+    int idx = reloc_data.append(0); \/\/ default value\n+    switch (iter.type()) {\n+      case relocInfo::none:\n+        break;\n+      case relocInfo::runtime_call_type: {\n+        \/\/ Record offset of runtime destination\n+        CallRelocation* r = (CallRelocation*)iter.reloc();\n+        address dest = r->destination();\n+        if (dest == r->addr()) { \/\/ possible call via trampoline on Aarch64\n+          dest = (address)-1;    \/\/ do nothing in this case when loading this relocation\n+        }\n+        reloc_data.at_put(idx, _table->id_for_address(dest, iter, &code_blob));\n+        break;\n+      }\n+      case relocInfo::runtime_call_w_cp_type:\n+        fatal(\"runtime_call_w_cp_type unimplemented\");\n+        break;\n+      case relocInfo::external_word_type: {\n+        \/\/ Record offset of runtime target\n+        address target = ((external_word_Relocation*)iter.reloc())->target();\n+        reloc_data.at_put(idx, _table->id_for_address(target, iter, &code_blob));\n+        break;\n+      }\n+      case relocInfo::internal_word_type:\n+        break;\n+      case relocInfo::section_word_type:\n+        break;\n+      default:\n+        fatal(\"relocation %d unimplemented\", (int)iter.type());\n+        break;\n+    }\n+    if (log.is_enabled()) {\n+      iter.print_current_on(&log);\n+    }\n+  }\n+\n+  \/\/ Write additional relocation data: uint per relocation\n+  \/\/ Write the count first\n+  int count = reloc_data.length();\n+  write_bytes(&count, sizeof(int));\n+  for (GrowableArrayIterator<uint> iter = reloc_data.begin();\n+       iter != reloc_data.end(); ++iter) {\n+    uint value = *iter;\n+    int n = write_bytes(&value, sizeof(uint));\n+    if (n != sizeof(uint)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+void AOTCodeReader::fix_relocations(CodeBlob* code_blob) {\n+  LogStreamHandle(Trace, aot, reloc) log;\n+  uint offset = read_position();\n+  int count = *(int*)addr(offset);\n+  offset += sizeof(int);\n+  if (log.is_enabled()) {\n+    log.print_cr(\"======== extra relocations count=%d\", count);\n+  }\n+  uint* reloc_data = (uint*)addr(offset);\n+  offset += (count * sizeof(uint));\n+  set_read_position(offset);\n+\n+  RelocIterator iter(code_blob);\n+  int j = 0;\n+  while (iter.next()) {\n+    switch (iter.type()) {\n+      case relocInfo::none:\n+        break;\n+      case relocInfo::runtime_call_type: {\n+        address dest = _cache->address_for_id(reloc_data[j]);\n+        if (dest != (address)-1) {\n+          ((CallRelocation*)iter.reloc())->set_destination(dest);\n+        }\n+        break;\n+      }\n+      case relocInfo::runtime_call_w_cp_type:\n+        fatal(\"runtime_call_w_cp_type unimplemented\");\n+        break;\n+      case relocInfo::external_word_type: {\n+        address target = _cache->address_for_id(reloc_data[j]);\n+        \/\/ Add external address to global table\n+        int index = ExternalsRecorder::find_index(target);\n+        \/\/ Update index in relocation\n+        Relocation::add_jint(iter.data(), index);\n+        external_word_Relocation* reloc = (external_word_Relocation*)iter.reloc();\n+        assert(reloc->target() == target, \"sanity\");\n+        reloc->set_value(target); \/\/ Patch address in the code\n+        break;\n+      }\n+      case relocInfo::internal_word_type: {\n+        internal_word_Relocation* r = (internal_word_Relocation*)iter.reloc();\n+        r->fix_relocation_after_aot_load(aot_code_entry()->dumptime_content_start_addr(), code_blob->content_begin());\n+        break;\n+      }\n+      case relocInfo::section_word_type: {\n+        section_word_Relocation* r = (section_word_Relocation*)iter.reloc();\n+        r->fix_relocation_after_aot_load(aot_code_entry()->dumptime_content_start_addr(), code_blob->content_begin());\n+        break;\n+      }\n+      default:\n+        fatal(\"relocation %d unimplemented\", (int)iter.type());\n+        break;\n+    }\n+    if (log.is_enabled()) {\n+      iter.print_current_on(&log);\n+    }\n+    j++;\n+  }\n+  assert(j == count, \"sanity\");\n+}\n+\n+bool AOTCodeCache::write_oop_map_set(CodeBlob& cb) {\n+  ImmutableOopMapSet* oopmaps = cb.oop_maps();\n+  int oopmaps_size = oopmaps->nr_of_bytes();\n+  if (!write_bytes(&oopmaps_size, sizeof(int))) {\n+    return false;\n+  }\n+  uint n = write_bytes(oopmaps, oopmaps->nr_of_bytes());\n+  if (n != (uint)oopmaps->nr_of_bytes()) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+ImmutableOopMapSet* AOTCodeReader::read_oop_map_set() {\n+  uint offset = read_position();\n+  int size = *(int *)addr(offset);\n+  offset += sizeof(int);\n+  ImmutableOopMapSet* oopmaps = (ImmutableOopMapSet *)addr(offset);\n+  offset += size;\n+  set_read_position(offset);\n+  return oopmaps;\n+}\n+\n+\/\/======================= AOTCodeAddressTable ===============\n+\n+\/\/ address table ids for generated routines, external addresses and C\n+\/\/ string addresses are partitioned into positive integer ranges\n+\/\/ defined by the following positive base and max values\n+\/\/ i.e. [_extrs_base, _extrs_base + _extrs_max -1],\n+\/\/      [_blobs_base, _blobs_base + _blobs_max -1],\n+\/\/      ...\n+\/\/      [_c_str_base, _c_str_base + _c_str_max -1],\n+#define _extrs_max 10\n+#define _blobs_max 10\n+#define _all_max   20\n+\n+#define _extrs_base 0\n+#define _blobs_base (_extrs_base + _extrs_max)\n+#define _blobs_end  (_blobs_base + _blobs_max)\n+\n+#if (_blobs_end > _all_max)\n+#error AOTCodeAddress table ranges need adjusting\n+#endif\n+\n+#define SET_ADDRESS(type, addr)                           \\\n+  {                                                       \\\n+    type##_addr[type##_length++] = (address) (addr);      \\\n+    assert(type##_length <= type##_max, \"increase size\"); \\\n+  }\n+\n+static bool initializing_extrs = false;\n+\n+void AOTCodeAddressTable::init_extrs() {\n+  if (_extrs_complete || initializing_extrs) return; \/\/ Done already\n+  initializing_extrs = true;\n+  _extrs_addr = NEW_C_HEAP_ARRAY(address, _extrs_max, mtCode);\n+\n+  _extrs_length = 0;\n+\n+  \/\/ Recored addresses of VM runtime methods\n+  SET_ADDRESS(_extrs, SharedRuntime::fixup_callers_callsite);\n+  SET_ADDRESS(_extrs, SharedRuntime::handle_wrong_method);\n+  SET_ADDRESS(_extrs, SharedRuntime::handle_wrong_method_abstract);\n+  SET_ADDRESS(_extrs, SharedRuntime::handle_wrong_method_ic_miss);\n+#if INCLUDE_G1GC\n+  SET_ADDRESS(_extrs, G1BarrierSetRuntime::write_ref_field_post_entry);\n+  SET_ADDRESS(_extrs, G1BarrierSetRuntime::write_ref_field_pre_entry);\n+#endif\n+#if INCLUDE_ZGC\n+  SET_ADDRESS(_extrs, ZBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded_addr());\n+#if defined(AMD64)\n+  SET_ADDRESS(_extrs, &ZPointerLoadShift);\n+#endif\n+#endif\n+#ifdef COMPILER2\n+  SET_ADDRESS(_extrs, OptoRuntime::handle_exception_C);\n+#endif\n+#ifndef ZERO\n+#if defined(AMD64) || defined(AARCH64) || defined(RISCV64)\n+  SET_ADDRESS(_extrs, MacroAssembler::debug64);\n+#endif\n+#endif \/\/ ZERO\n+\n+  _extrs_complete = true;\n+  log_debug(aot, codecache, init)(\"External addresses recorded\");\n+}\n+\n+static bool initializing_shared_blobs = false;\n+\n+void AOTCodeAddressTable::init_shared_blobs() {\n+  if (_complete || initializing_shared_blobs) return; \/\/ Done already\n+  initializing_shared_blobs = true;\n+  _blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n+\n+  _blobs_length = 0;       \/\/ for shared blobs\n+\n+  \/\/ Recored addresses of generated code blobs\n+  SET_ADDRESS(_blobs, SharedRuntime::get_handle_wrong_method_stub());\n+  SET_ADDRESS(_blobs, SharedRuntime::get_ic_miss_stub());\n+\n+  _shared_blobs_complete = true;\n+  log_debug(aot, codecache, init)(\"Early shared blobs recorded\");\n+  _complete = true;\n+}\n+\n+#undef SET_ADDRESS\n+\n+AOTCodeAddressTable::~AOTCodeAddressTable() {\n+  if (_extrs_addr != nullptr) {\n+    FREE_C_HEAP_ARRAY(address, _extrs_addr);\n+  }\n+  if (_blobs_addr != nullptr) {\n+    FREE_C_HEAP_ARRAY(address, _blobs_addr);\n+  }\n+}\n+\n+#ifdef PRODUCT\n+#define MAX_STR_COUNT 200\n+#else\n+#define MAX_STR_COUNT 500\n+#endif\n+#define _c_str_max  MAX_STR_COUNT\n+#define _c_str_base _all_max\n+\n+static const char* _C_strings_in[MAX_STR_COUNT] = {nullptr}; \/\/ Incoming strings\n+static const char* _C_strings[MAX_STR_COUNT]    = {nullptr}; \/\/ Our duplicates\n+static int _C_strings_count = 0;\n+static int _C_strings_s[MAX_STR_COUNT] = {0};\n+static int _C_strings_id[MAX_STR_COUNT] = {0};\n+static int _C_strings_used = 0;\n+\n+void AOTCodeCache::load_strings() {\n+  uint strings_count  = _load_header->strings_count();\n+  if (strings_count == 0) {\n+    return;\n+  }\n+  uint strings_offset = _load_header->strings_offset();\n+  uint* string_lengths = (uint*)addr(strings_offset);\n+  strings_offset += (strings_count * sizeof(uint));\n+  uint strings_size = _load_header->entries_offset() - strings_offset;\n+  \/\/ We have to keep cached strings longer than _cache buffer\n+  \/\/ because they are refernced from compiled code which may\n+  \/\/ still be executed on VM exit after _cache is freed.\n+  char* p = NEW_C_HEAP_ARRAY(char, strings_size+1, mtCode);\n+  memcpy(p, addr(strings_offset), strings_size);\n+  _C_strings_buf = p;\n+  assert(strings_count <= MAX_STR_COUNT, \"sanity\");\n+  for (uint i = 0; i < strings_count; i++) {\n+    _C_strings[i] = p;\n+    uint len = string_lengths[i];\n+    _C_strings_s[i] = i;\n+    _C_strings_id[i] = i;\n+    p += len;\n+  }\n+  assert((uint)(p - _C_strings_buf) <= strings_size, \"(\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \") = %d > %d \", p2i(p), p2i(_C_strings_buf), (uint)(p - _C_strings_buf), strings_size);\n+  _C_strings_count = strings_count;\n+  _C_strings_used  = strings_count;\n+  log_debug(aot, codecache, init)(\"  Loaded %d C strings of total length %d at offset %d from AOT Code Cache\", _C_strings_count, strings_size, strings_offset);\n+}\n+\n+int AOTCodeCache::store_strings() {\n+  if (_C_strings_used > 0) {\n+    uint offset = _write_position;\n+    uint length = 0;\n+    uint* lengths = (uint *)reserve_bytes(sizeof(uint) * _C_strings_used);\n+    if (lengths == nullptr) {\n+      return -1;\n+    }\n+    for (int i = 0; i < _C_strings_used; i++) {\n+      const char* str = _C_strings[_C_strings_s[i]];\n+      uint len = (uint)strlen(str) + 1;\n+      length += len;\n+      assert(len < 1000, \"big string: %s\", str);\n+      lengths[i] = len;\n+      uint n = write_bytes(str, len);\n+      if (n != len) {\n+        return -1;\n+      }\n+    }\n+    log_debug(aot, codecache, exit)(\"  Wrote %d C strings of total length %d at offset %d to AOT Code Cache\",\n+                                   _C_strings_used, length, offset);\n+  }\n+  return _C_strings_used;\n+}\n+\n+const char* AOTCodeCache::add_C_string(const char* str) {\n+  if (is_on_for_dump() && str != nullptr) {\n+    return _cache->_table->add_C_string(str);\n+  }\n+  return str;\n+}\n+\n+const char* AOTCodeAddressTable::add_C_string(const char* str) {\n+  if (_extrs_complete) {\n+    LogStreamHandle(Trace, aot, codecache, stringtable) log; \/\/ ctor outside lock\n+    MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n+    \/\/ Check previous strings address\n+    for (int i = 0; i < _C_strings_count; i++) {\n+      if (_C_strings_in[i] == str) {\n+        return _C_strings[i]; \/\/ Found previous one - return our duplicate\n+      } else if (strcmp(_C_strings[i], str) == 0) {\n+        return _C_strings[i];\n+      }\n+    }\n+    \/\/ Add new one\n+    if (_C_strings_count < MAX_STR_COUNT) {\n+      \/\/ Passed in string can be freed and used space become inaccessible.\n+      \/\/ Keep original address but duplicate string for future compare.\n+      _C_strings_id[_C_strings_count] = -1; \/\/ Init\n+      _C_strings_in[_C_strings_count] = str;\n+      const char* dup = os::strdup(str);\n+      _C_strings[_C_strings_count++] = dup;\n+      if (log.is_enabled()) {\n+        log.print_cr(\"add_C_string: [%d] \" INTPTR_FORMAT \" '%s'\", _C_strings_count, p2i(dup), dup);\n+      }\n+      return dup;\n+    } else {\n+      fatal(\"Number of C strings >= MAX_STR_COUNT\");\n+    }\n+  }\n+  return str;\n+}\n+\n+int AOTCodeAddressTable::id_for_C_string(address str) {\n+  if (str == nullptr) {\n+    return -1;\n+  }\n+  MutexLocker ml(AOTCodeCStrings_lock, Mutex::_no_safepoint_check_flag);\n+  for (int i = 0; i < _C_strings_count; i++) {\n+    if (_C_strings[i] == (const char*)str) { \/\/ found\n+      int id = _C_strings_id[i];\n+      if (id >= 0) {\n+        assert(id < _C_strings_used, \"%d >= %d\", id , _C_strings_used);\n+        return id; \/\/ Found recorded\n+      }\n+      \/\/ Not found in recorded, add new\n+      id = _C_strings_used++;\n+      _C_strings_s[id] = i;\n+      _C_strings_id[i] = id;\n+      return id;\n+    }\n+  }\n+  return -1;\n+}\n+\n+address AOTCodeAddressTable::address_for_C_string(int idx) {\n+  assert(idx < _C_strings_count, \"sanity\");\n+  return (address)_C_strings[idx];\n+}\n+\n+static int search_address(address addr, address* table, uint length) {\n+  for (int i = 0; i < (int)length; i++) {\n+    if (table[i] == addr) {\n+      return i;\n+    }\n+  }\n+  return -1;\n+}\n+\n+address AOTCodeAddressTable::address_for_id(int idx) {\n+  if (!_extrs_complete) {\n+    fatal(\"AOT Code Cache VM runtime addresses table is not complete\");\n+  }\n+  if (idx == -1) {\n+    return (address)-1;\n+  }\n+  uint id = (uint)idx;\n+  \/\/ special case for symbols based relative to os::init\n+  if (id > (_c_str_base + _c_str_max)) {\n+    return (address)os::init + idx;\n+  }\n+  if (idx < 0) {\n+    fatal(\"Incorrect id %d for AOT Code Cache addresses table\", id);\n+  }\n+  \/\/ no need to compare unsigned id against 0\n+  if (\/* id >= _extrs_base && *\/ id < _extrs_length) {\n+    return _extrs_addr[id - _extrs_base];\n+  }\n+  if (id >= _blobs_base && id < _blobs_base + _blobs_length) {\n+    return _blobs_addr[id - _blobs_base];\n+  }\n+  if (id >= _c_str_base && id < (_c_str_base + (uint)_C_strings_count)) {\n+    return address_for_C_string(id - _c_str_base);\n+  }\n+  fatal(\"Incorrect id %d for AOT Code Cache addresses table\", id);\n+  return nullptr;\n+}\n+\n+int AOTCodeAddressTable::id_for_address(address addr, RelocIterator reloc, CodeBlob* code_blob) {\n+  if (!_extrs_complete) {\n+    fatal(\"AOT Code Cache VM runtime addresses table is not complete\");\n+  }\n+  int id = -1;\n+  if (addr == (address)-1) { \/\/ Static call stub has jump to itself\n+    return id;\n+  }\n+  \/\/ Seach for C string\n+  id = id_for_C_string(addr);\n+  if (id >= 0) {\n+    return id + _c_str_base;\n+  }\n+  if (StubRoutines::contains(addr)) {\n+    \/\/ Search in stubs\n+    StubCodeDesc* desc = StubCodeDesc::desc_for(addr);\n+    if (desc == nullptr) {\n+      desc = StubCodeDesc::desc_for(addr + frame::pc_return_offset);\n+    }\n+    const char* sub_name = (desc != nullptr) ? desc->name() : \"<unknown>\";\n+    fatal(\"Address \" INTPTR_FORMAT \" for Stub:%s is missing in AOT Code Cache addresses table\", p2i(addr), sub_name);\n+  } else {\n+    CodeBlob* cb = CodeCache::find_blob(addr);\n+    if (cb != nullptr) {\n+      \/\/ Search in code blobs\n+      int id_base = _blobs_base;\n+      id = search_address(addr, _blobs_addr, _blobs_length);\n+      if (id < 0) {\n+        fatal(\"Address \" INTPTR_FORMAT \" for Blob:%s is missing in AOT Code Cache addresses table\", p2i(addr), cb->name());\n+      } else {\n+        return id_base + id;\n+      }\n+    } else {\n+      \/\/ Search in runtime functions\n+      id = search_address(addr, _extrs_addr, _extrs_length);\n+      if (id < 0) {\n+        ResourceMark rm;\n+        const int buflen = 1024;\n+        char* func_name = NEW_RESOURCE_ARRAY(char, buflen);\n+        int offset = 0;\n+        if (os::dll_address_to_function_name(addr, func_name, buflen, &offset)) {\n+          if (offset > 0) {\n+            \/\/ Could be address of C string\n+            uint dist = (uint)pointer_delta(addr, (address)os::init, 1);\n+            log_debug(aot, codecache)(\"Address \" INTPTR_FORMAT \" (offset %d) for runtime target '%s' is missing in AOT Code Cache addresses table\",\n+                                      p2i(addr), dist, (const char*)addr);\n+            assert(dist > (uint)(_all_max + MAX_STR_COUNT), \"change encoding of distance\");\n+            return dist;\n+          }\n+          reloc.print_current_on(tty);\n+          code_blob->print_on(tty);\n+          code_blob->print_code_on(tty);\n+          fatal(\"Address \" INTPTR_FORMAT \" for runtime target '%s+%d' is missing in AOT Code Cache addresses table\", p2i(addr), func_name, offset);\n+        } else {\n+          reloc.print_current_on(tty);\n+          code_blob->print_on(tty);\n+          code_blob->print_code_on(tty);\n+          os::find(addr, tty);\n+          fatal(\"Address \" INTPTR_FORMAT \" for <unknown>\/('%s') is missing in AOT Code Cache addresses table\", p2i(addr), (const char*)addr);\n+        }\n+      } else {\n+        return _extrs_base + id;\n+      }\n+    }\n+  }\n+  return id;\n+}\n+\n+void AOTCodeCache::print_on(outputStream* st) {\n+  AOTCodeCache* cache = open_for_use();\n+  if (cache != nullptr) {\n+    uint count = cache->_load_header->entries_count();\n+    uint* search_entries = (uint*)cache->addr(cache->_load_header->entries_offset()); \/\/ [id, index]\n+    AOTCodeEntry* load_entries = (AOTCodeEntry*)(search_entries + 2 * count);\n+\n+    for (uint i = 0; i < count; i++) {\n+      \/\/ Use search_entries[] to order ouput\n+      int index = search_entries[2*i + 1];\n+      AOTCodeEntry* entry = &(load_entries[index]);\n+\n+      uint entry_position = entry->offset();\n+      uint name_offset = entry->name_offset() + entry_position;\n+      const char* saved_name = cache->addr(name_offset);\n+\n+      st->print_cr(\"%4u: entry_idx:%4u Kind:%u Id:%u size=%u '%s'\",\n+                   i, index, entry->kind(), entry->id(), entry->size(), saved_name);\n+    }\n+  } else {\n+    st->print_cr(\"failed to map code cache\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":1317,"deletions":0,"binary":false,"changes":1317,"status":"added"},{"patch":"@@ -0,0 +1,369 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CODE_AOTCODECACHE_HPP\n+#define SHARE_CODE_AOTCODECACHE_HPP\n+\n+\/*\n+ * AOT Code Cache collects code from Code Cache and corresponding metadata\n+ * during application training run.\n+ * In following \"production\" runs this code and data can be loaded into\n+ * Code Cache skipping its generation.\n+ *\/\n+\n+class CodeBuffer;\n+class RelocIterator;\n+class AOTCodeCache;\n+class AdapterBlob;\n+class ExceptionBlob;\n+class ImmutableOopMapSet;\n+\n+enum class vmIntrinsicID : int;\n+enum CompLevel : signed char;\n+\n+\/\/ Descriptor of AOT Code Cache's entry\n+class AOTCodeEntry {\n+public:\n+  enum Kind {\n+    None    = 0,\n+    Adapter = 1,\n+    Blob    = 2\n+  };\n+\n+private:\n+  AOTCodeEntry* _next;\n+  Kind   _kind;\n+  uint   _id;          \/\/ Adapter's id, vmIntrinsic::ID for stub or name's hash for nmethod\n+  uint   _offset;      \/\/ Offset to entry\n+  uint   _size;        \/\/ Entry size\n+  uint   _name_offset; \/\/ Code blob name\n+  uint   _name_size;\n+  uint   _blob_offset; \/\/ Start of code in cache\n+  bool   _has_oop_maps;\n+  address _dumptime_content_start_addr; \/\/ CodeBlob::content_begin() at dump time; used for applying relocations\n+\n+public:\n+  AOTCodeEntry(Kind kind,         uint id,\n+               uint offset,       uint size,\n+               uint name_offset,  uint name_size,\n+               uint blob_offset,  bool has_oop_maps,\n+               address dumptime_content_start_addr) {\n+    _next         = nullptr;\n+    _kind         = kind;\n+    _id           = id;\n+    _offset       = offset;\n+    _size         = size;\n+    _name_offset  = name_offset;\n+    _name_size    = name_size;\n+    _blob_offset  = blob_offset;\n+    _has_oop_maps = has_oop_maps;\n+    _dumptime_content_start_addr = dumptime_content_start_addr;\n+  }\n+  void* operator new(size_t x, AOTCodeCache* cache);\n+  \/\/ Delete is a NOP\n+  void operator delete( void *ptr ) {}\n+\n+  AOTCodeEntry* next()        const { return _next; }\n+  void set_next(AOTCodeEntry* next) { _next = next; }\n+\n+  Kind kind()         const { return _kind; }\n+  uint id()           const { return _id; }\n+\n+  uint offset()       const { return _offset; }\n+  void set_offset(uint off) { _offset = off; }\n+\n+  uint size()         const { return _size; }\n+  uint name_offset()  const { return _name_offset; }\n+  uint name_size()    const { return _name_size; }\n+  uint blob_offset()  const { return _blob_offset; }\n+  bool has_oop_maps() const { return _has_oop_maps; }\n+  address dumptime_content_start_addr() const { return _dumptime_content_start_addr; }\n+\n+  static bool is_valid_entry_kind(Kind kind) { return kind == Adapter || kind == Blob; }\n+};\n+\n+\/\/ Addresses of stubs, blobs and runtime finctions called from compiled code.\n+class AOTCodeAddressTable : public CHeapObj<mtCode> {\n+private:\n+  address* _extrs_addr;\n+  address* _blobs_addr;\n+  uint     _extrs_length;\n+  uint     _blobs_length;\n+\n+  bool _extrs_complete;\n+  bool _shared_blobs_complete;\n+  bool _complete;\n+\n+public:\n+  AOTCodeAddressTable() :\n+    _extrs_addr(nullptr),\n+    _blobs_addr(nullptr),\n+    _extrs_length(0),\n+    _blobs_length(0),\n+    _extrs_complete(false),\n+    _shared_blobs_complete(false),\n+    _complete(false)\n+  { }\n+  ~AOTCodeAddressTable();\n+  void init_extrs();\n+  void init_shared_blobs();\n+  const char* add_C_string(const char* str);\n+  int  id_for_C_string(address str);\n+  address address_for_C_string(int idx);\n+  int  id_for_address(address addr, RelocIterator iter, CodeBlob* code_blob);\n+  address address_for_id(int id);\n+};\n+\n+class AOTCodeCache : public CHeapObj<mtCode> {\n+\n+\/\/ Classes used to describe AOT code cache.\n+protected:\n+  class Config {\n+    uint _compressedOopShift;\n+    uint _compressedKlassShift;\n+    uint _contendedPaddingWidth;\n+    uint _objectAlignment;\n+    uint _gc;\n+    enum Flags {\n+      none                     = 0,\n+      debugVM                  = 1,\n+      compressedOops           = 2,\n+      compressedClassPointers  = 4,\n+      useTLAB                  = 8,\n+      systemClassAssertions    = 16,\n+      userClassAssertions      = 32,\n+      enableContendedPadding   = 64,\n+      restrictContendedPadding = 128\n+    };\n+    uint _flags;\n+\n+  public:\n+    void record();\n+    bool verify() const;\n+  };\n+\n+  class Header : public CHeapObj<mtCode> {\n+  private:\n+    enum {\n+      AOT_CODE_VERSION = 1\n+    };\n+    uint   _version;         \/\/ AOT code version (should match when reading code cache)\n+    uint   _cache_size;      \/\/ cache size in bytes\n+    uint   _strings_count;   \/\/ number of recorded C strings\n+    uint   _strings_offset;  \/\/ offset to recorded C strings\n+    uint   _entries_count;   \/\/ number of recorded entries\n+    uint   _entries_offset;  \/\/ offset of AOTCodeEntry array describing entries\n+    uint   _adapters_count;\n+    uint   _blobs_count;\n+    Config _config;\n+\n+public:\n+    void init(uint cache_size,\n+              uint strings_count,  uint strings_offset,\n+              uint entries_count,  uint entries_offset,\n+              uint adapters_count, uint blobs_count) {\n+      _version        = AOT_CODE_VERSION;\n+      _cache_size     = cache_size;\n+      _strings_count  = strings_count;\n+      _strings_offset = strings_offset;\n+      _entries_count  = entries_count;\n+      _entries_offset = entries_offset;\n+      _adapters_count = adapters_count;\n+      _blobs_count    = blobs_count;\n+\n+      _config.record();\n+    }\n+\n+\n+    uint cache_size()     const { return _cache_size; }\n+    uint strings_count()  const { return _strings_count; }\n+    uint strings_offset() const { return _strings_offset; }\n+    uint entries_count()  const { return _entries_count; }\n+    uint entries_offset() const { return _entries_offset; }\n+    uint adapters_count() const { return _adapters_count; }\n+    uint blobs_count()    const { return _blobs_count; }\n+\n+    bool verify_config(uint load_size)  const;\n+    bool verify_vm_config() const { \/\/ Called after Universe initialized\n+      return _config.verify();\n+    }\n+  };\n+\n+\/\/ Continue with AOTCodeCache class definition.\n+private:\n+  Header* _load_header;\n+  char*   _load_buffer;    \/\/ Aligned buffer for loading cached code\n+  char*   _store_buffer;   \/\/ Aligned buffer for storing cached code\n+  char*   _C_store_buffer; \/\/ Original unaligned buffer\n+\n+  uint   _write_position;  \/\/ Position in _store_buffer\n+  uint   _load_size;       \/\/ Used when reading cache\n+  uint   _store_size;      \/\/ Used when writing cache\n+  bool   _for_use;         \/\/ AOT cache is open for using AOT code\n+  bool   _for_dump;        \/\/ AOT cache is open for dumping AOT code\n+  bool   _adapter_caching;\n+  bool   _closing;         \/\/ Closing cache file\n+  bool   _failed;          \/\/ Failed read\/write to\/from cache (cache is broken?)\n+  bool   _lookup_failed;   \/\/ Failed to lookup for info (skip only this code load)\n+\n+  AOTCodeAddressTable* _table;\n+\n+  AOTCodeEntry* _load_entries;   \/\/ Used when reading cache\n+  uint*         _search_entries; \/\/ sorted by ID table [id, index]\n+  AOTCodeEntry* _store_entries;  \/\/ Used when writing cache\n+  const char*   _C_strings_buf;  \/\/ Loaded buffer for _C_strings[] table\n+  uint          _store_entries_cnt;\n+\n+  static AOTCodeCache* open_for_use();\n+  static AOTCodeCache* open_for_dump();\n+\n+  bool set_write_position(uint pos);\n+  bool align_write();\n+  address reserve_bytes(uint nbytes);\n+  uint write_bytes(const void* buffer, uint nbytes);\n+  const char* addr(uint offset) const { return _load_buffer + offset; }\n+  static AOTCodeAddressTable* addr_table() {\n+    return is_on() && (cache()->_table != nullptr) ? cache()->_table : nullptr;\n+  }\n+\n+  void set_lookup_failed()     { _lookup_failed = true; }\n+  void clear_lookup_failed()   { _lookup_failed = false; }\n+  bool lookup_failed()   const { return _lookup_failed; }\n+\n+public:\n+  AOTCodeCache(bool is_dumping, bool is_using);\n+  ~AOTCodeCache();\n+\n+  const char* cache_buffer() const { return _load_buffer; }\n+  bool failed() const { return _failed; }\n+  void set_failed()   { _failed = true; }\n+\n+  static uint max_aot_code_size();\n+\n+  uint load_size() const { return _load_size; }\n+  uint write_position() const { return _write_position; }\n+\n+  void load_strings();\n+  int store_strings();\n+\n+  static void init_extrs_table() NOT_CDS_RETURN;\n+  static void init_shared_blobs_table() NOT_CDS_RETURN;\n+\n+  address address_for_id(int id) const { return _table->address_for_id(id); }\n+\n+  bool for_use()  const { return _for_use  && !_failed; }\n+  bool for_dump() const { return _for_dump && !_failed; }\n+\n+  bool adapter_caching() const { return _adapter_caching; }\n+\n+  bool closing()          const { return _closing; }\n+\n+  AOTCodeEntry* add_entry() {\n+    _store_entries_cnt++;\n+    _store_entries -= 1;\n+    return _store_entries;\n+  }\n+\n+  AOTCodeEntry* find_entry(AOTCodeEntry::Kind kind, uint id);\n+\n+  bool finish_write();\n+\n+  bool write_relocations(CodeBlob& code_blob);\n+  bool write_oop_map_set(CodeBlob& cb);\n+\n+  static bool store_code_blob(CodeBlob& blob,\n+                              AOTCodeEntry::Kind entry_kind,\n+                              uint id, const char* name,\n+                              int entry_offset_count,\n+                              int* entry_offsets) NOT_CDS_RETURN_(false);\n+\n+  static CodeBlob* load_code_blob(AOTCodeEntry::Kind kind,\n+                                  uint id, const char* name,\n+                                  int entry_offset_count,\n+                                  int* entry_offsets) NOT_CDS_RETURN_(nullptr);\n+\n+  static uint store_entries_cnt() {\n+    if (is_on_for_dump()) {\n+      return cache()->_store_entries_cnt;\n+    }\n+    return -1;\n+  }\n+\n+\/\/ Static access\n+\n+private:\n+  static AOTCodeCache*  _cache;\n+\n+  static bool open_cache(bool is_dumping, bool is_using);\n+  static bool verify_vm_config() {\n+    if (is_on_for_use()) {\n+      return _cache->_load_header->verify_vm_config();\n+    }\n+    return true;\n+  }\n+public:\n+  static AOTCodeCache* cache() { return _cache; }\n+  static void initialize() NOT_CDS_RETURN;\n+  static void init2() NOT_CDS_RETURN;\n+  static void close() NOT_CDS_RETURN;\n+  static bool is_on() CDS_ONLY({ return _cache != nullptr && !_cache->closing(); }) NOT_CDS_RETURN_(false);\n+  static bool is_on_for_use()  { return is_on() && _cache->for_use(); }\n+  static bool is_on_for_dump() { return is_on() && _cache->for_dump(); }\n+\n+  static bool is_dumping_adapters() { return is_on_for_dump() && _cache->adapter_caching(); }\n+\n+  static bool is_using_adapters()   { return is_on_for_use() && _cache->adapter_caching(); }\n+\n+  static const char* add_C_string(const char* str) NOT_CDS_RETURN_(str);\n+\n+  static void print_on(outputStream* st) NOT_CDS_RETURN;\n+};\n+\n+\/\/ Concurent AOT code reader\n+class AOTCodeReader {\n+private:\n+  const AOTCodeCache*  _cache;\n+  const AOTCodeEntry*  _entry;\n+  const char*          _load_buffer; \/\/ Loaded cached code buffer\n+  uint  _read_position;              \/\/ Position in _load_buffer\n+  uint  read_position() const { return _read_position; }\n+  void  set_read_position(uint pos);\n+  const char* addr(uint offset) const { return _load_buffer + offset; }\n+\n+  bool _lookup_failed;       \/\/ Failed to lookup for info (skip only this code load)\n+  void set_lookup_failed()     { _lookup_failed = true; }\n+  void clear_lookup_failed()   { _lookup_failed = false; }\n+  bool lookup_failed()   const { return _lookup_failed; }\n+\n+  AOTCodeEntry* aot_code_entry() { return (AOTCodeEntry*)_entry; }\n+public:\n+  AOTCodeReader(AOTCodeCache* cache, AOTCodeEntry* entry);\n+\n+  CodeBlob* compile_code_blob(const char* name, int entry_offset_count, int* entry_offsets);\n+\n+  ImmutableOopMapSet* read_oop_map_set();\n+\n+  void fix_relocations(CodeBlob* code_blob);\n+};\n+#endif \/\/ SHARE_CODE_AOTCODECACH_HPP\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":369,"deletions":0,"binary":false,"changes":369,"status":"added"},{"patch":"@@ -81,0 +81,3 @@\n+#ifdef COMPILER2\n+const ExceptionBlob::Vptr            ExceptionBlob::_vpntr;\n+#endif \/\/ COMPILER2\n@@ -83,1 +86,1 @@\n-const CodeBlob::Vptr* CodeBlob::vptr() const {\n+const CodeBlob::Vptr* CodeBlob::vptr(CodeBlobKind kind) {\n@@ -101,1 +104,5 @@\n-  return array[(size_t)_kind];\n+  return array[(size_t)kind];\n+}\n+\n+const CodeBlob::Vptr* CodeBlob::vptr() const {\n+  return vptr(_kind);\n@@ -184,0 +191,13 @@\n+void CodeBlob::restore_mutable_data(address reloc_data) {\n+  \/\/ Relocation data is now stored as part of the mutable data area; allocate it before copy relocations\n+  if (_mutable_data_size > 0) {\n+    _mutable_data = (address)os::malloc(_mutable_data_size, mtCode);\n+    if (_mutable_data == nullptr) {\n+      vm_exit_out_of_memory(_mutable_data_size, OOM_MALLOC_ERROR, \"codebuffer: no space for mutable data\");\n+    }\n+  }\n+  if (_relocation_size > 0) {\n+    memcpy((address)relocation_begin(), reloc_data, relocation_size());\n+  }\n+}\n+\n@@ -218,0 +238,62 @@\n+void CodeBlob::prepare_for_archiving_impl() {\n+  set_name(nullptr);\n+  _oop_maps = nullptr;\n+  _mutable_data = nullptr;\n+#ifndef PRODUCT\n+  asm_remarks().clear();\n+  dbg_strings().clear();\n+#endif \/* PRODUCT *\/\n+}\n+\n+void CodeBlob::prepare_for_archiving() {\n+  vptr(_kind)->prepare_for_archiving(this);\n+}\n+\n+void CodeBlob::archive_blob(CodeBlob* blob, address archive_buffer) {\n+  blob->copy_to(archive_buffer);\n+  CodeBlob* archived_blob = (CodeBlob*)archive_buffer;\n+  archived_blob->prepare_for_archiving();\n+}\n+\n+void CodeBlob::post_restore_impl() {\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+}\n+\n+void CodeBlob::post_restore() {\n+  vptr(_kind)->post_restore(this);\n+}\n+\n+CodeBlob* CodeBlob::restore(address code_cache_buffer, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps) {\n+  copy_to(code_cache_buffer);\n+  CodeBlob* code_blob = (CodeBlob*)code_cache_buffer;\n+  code_blob->set_name(name);\n+  code_blob->restore_mutable_data(archived_reloc_data);\n+  code_blob->set_oop_maps(archived_oop_maps);\n+  return code_blob;\n+}\n+\n+CodeBlob* CodeBlob::create(CodeBlob* archived_blob, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  CodeCache::gc_on_allocation();\n+\n+  CodeBlob* blob = nullptr;\n+  unsigned int size = archived_blob->size();\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    address code_cache_buffer = (address)CodeCache::allocate(size, CodeBlobType::NonNMethod);\n+    if (code_cache_buffer != nullptr) {\n+      blob = archived_blob->restore(code_cache_buffer, name, archived_reloc_data, archived_oop_maps);\n+      assert(blob != nullptr, \"sanity check\");\n+      \/\/ Flush the code block\n+      ICache::invalidate_range(blob->code_begin(), blob->code_size());\n+      CodeCache::commit(blob); \/\/ Count adapters\n+    }\n+  }\n+  if (blob != nullptr) {\n+    blob->post_restore();\n+  }\n+  return blob;\n+}\n+\n@@ -723,1 +805,1 @@\n-  st->print_cr(\"[CodeBlob (\" INTPTR_FORMAT \")]\", p2i(this));\n+  st->print_cr(\"[CodeBlob kind:%d (\" INTPTR_FORMAT \")]\", (int)_kind, p2i(this));\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":85,"deletions":3,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+class AdapterBlob;\n+class ExceptionBlob;\n@@ -105,0 +107,3 @@\n+private:\n+  void restore_mutable_data(address reloc_data);\n+\n@@ -143,0 +148,6 @@\n+    virtual void prepare_for_archiving(CodeBlob* instance) const {\n+      instance->prepare_for_archiving_impl();\n+    };\n+    virtual void post_restore(CodeBlob* instance) const {\n+      instance->post_restore_impl();\n+    };\n@@ -145,0 +156,1 @@\n+  static const Vptr* vptr(CodeBlobKind kind);\n@@ -154,0 +166,1 @@\n+\n@@ -156,0 +169,3 @@\n+  void prepare_for_archiving_impl();\n+  void post_restore_impl();\n+\n@@ -191,0 +207,1 @@\n+  AdapterBlob* as_adapter_blob() const        { assert(is_adapter_blob(), \"must be adapter blob\"); return (AdapterBlob*) this; }\n@@ -247,0 +264,1 @@\n+  void set_oop_maps(ImmutableOopMapSet* p)       { _oop_maps = p; }\n@@ -281,0 +299,13 @@\n+\n+  void copy_to(address buffer) {\n+    memcpy(buffer, this, this->size());\n+  }\n+\n+  \/\/ methods to archive a blob into AOT code cache\n+  void prepare_for_archiving();\n+  static void archive_blob(CodeBlob* blob, address archive_buffer);\n+\n+  \/\/ methods to restore a blob from AOT code cache into the CodeCache\n+  void post_restore();\n+  CodeBlob* restore(address code_cache_buffer, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps);\n+  static CodeBlob* create(CodeBlob* archived_blob, const char* name, address archived_reloc_data, ImmutableOopMapSet* archived_oop_maps);\n@@ -620,0 +651,12 @@\n+\n+  void post_restore_impl() {\n+    trace_new_stub(this, \"ExceptionBlob\");\n+  }\n+\n+  class Vptr : public SingletonBlob::Vptr {\n+    void post_restore(CodeBlob* instance) const override {\n+      ((ExceptionBlob*)instance)->post_restore_impl();\n+    }\n+  };\n+\n+  static const Vptr _vpntr;\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -3246,1 +3246,1 @@\n-  iter.print();\n+  iter.print_on(tty);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,0 +182,20 @@\n+RelocIterator::RelocIterator(CodeBlob* cb) {\n+  initialize_misc();\n+  if (cb->is_nmethod()) {\n+    _code = cb->as_nmethod();\n+  } else {\n+    _code = nullptr;\n+  }\n+  _current = cb->relocation_begin() - 1;\n+  _end = cb->relocation_end();\n+  _addr = cb->content_begin();\n+\n+  _section_start[CodeBuffer::SECT_CONSTS] = cb->content_begin();\n+  _section_start[CodeBuffer::SECT_INSTS] = cb->code_begin();\n+\n+  _section_end[CodeBuffer::SECT_CONSTS] = cb->code_begin();\n+  _section_start[CodeBuffer::SECT_INSTS] = cb->code_end();\n+  assert(!has_current(), \"just checking\");\n+  set_limits(nullptr, nullptr);\n+}\n+\n@@ -184,0 +204,3 @@\n+  if (_section_start[n] == nullptr) {\n+    return false;\n+  }\n@@ -474,1 +497,3 @@\n-  p = pack_1_int_to(p, index);\n+  \/\/ Use 4 bytes to store index to be able patch it when\n+  \/\/ updating relocations in AOTCodeReader::read_relocations().\n+  p = add_jint(p, index);\n@@ -769,0 +794,8 @@\n+void internal_word_Relocation::fix_relocation_after_aot_load(address orig_base_addr, address current_base_addr) {\n+  address target = _target;\n+  if (target == nullptr) {\n+    target = this->target();\n+    target = current_base_addr + (target - orig_base_addr);\n+  }\n+  set_value(target);\n+}\n@@ -782,6 +815,1 @@\n-\/\/---------------------------------------------------------------------------------\n-\/\/ Non-product code\n-\n-#ifndef PRODUCT\n-\n-static const char* reloc_type_string(relocInfo::relocType t) {\n+const char* relocInfo::type_name(relocInfo::relocType t) {\n@@ -805,2 +833,1 @@\n-\n-void RelocIterator::print_current() {\n+void RelocIterator::print_current_on(outputStream* st) {\n@@ -808,1 +835,1 @@\n-    tty->print_cr(\"(no relocs)\");\n+    st->print_cr(\"(no relocs)\");\n@@ -811,2 +838,2 @@\n-  tty->print(\"relocInfo@\" INTPTR_FORMAT \" [type=%d(%s) addr=\" INTPTR_FORMAT \" offset=%d\",\n-             p2i(_current), type(), reloc_type_string((relocInfo::relocType) type()), p2i(_addr), _current->addr_offset());\n+  st->print(\"relocInfo@\" INTPTR_FORMAT \" [type=%d(%s) addr=\" INTPTR_FORMAT \" offset=%d\",\n+             p2i(_current), type(), relocInfo::type_name((relocInfo::relocType) type()), p2i(_addr), _current->addr_offset());\n@@ -814,1 +841,1 @@\n-    tty->print(\" format=%d\", current()->format());\n+    st->print(\" format=%d\", current()->format());\n@@ -816,1 +843,1 @@\n-    tty->print(\" data=%d\", data()[0]);\n+    st->print(\" data=%d\", data()[0]);\n@@ -818,1 +845,1 @@\n-    tty->print(\" data={\");\n+    st->print(\" data={\");\n@@ -820,1 +847,1 @@\n-      tty->print(\"%04x\", data()[i] & 0xFFFF);\n+      st->print(\"%04x\", data()[i] & 0xFFFF);\n@@ -822,1 +849,1 @@\n-    tty->print(\"}\");\n+    st->print(\"}\");\n@@ -824,1 +851,1 @@\n-  tty->print(\"]\");\n+  st->print(\"]\");\n@@ -837,1 +864,1 @@\n-      tty->print(\" | [oop_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n+      st->print(\" | [oop_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n@@ -842,1 +869,1 @@\n-        tty->print(\"oop_value=\" INTPTR_FORMAT \": \", p2i(oop_value));\n+        st->print(\"oop_value=\" INTPTR_FORMAT \": \", p2i(oop_value));\n@@ -844,1 +871,1 @@\n-          oop_value->print_value_on(tty);\n+          oop_value->print_value_on(st);\n@@ -860,1 +887,1 @@\n-      tty->print(\" | [metadata_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n+      st->print(\" | [metadata_addr=\" INTPTR_FORMAT \" *=\" INTPTR_FORMAT \"]\",\n@@ -863,2 +890,2 @@\n-        tty->print(\"metadata_value=\" INTPTR_FORMAT \": \", p2i(metadata_value));\n-        metadata_value->print_value_on(tty);\n+        st->print(\"metadata_value=\" INTPTR_FORMAT \": \", p2i(metadata_value));\n+        metadata_value->print_value_on(st);\n@@ -873,1 +900,1 @@\n-      tty->print(\" | [target=\" INTPTR_FORMAT \"]\", p2i(r->value())); \/\/value==target\n+      st->print(\" | [target=\" INTPTR_FORMAT \"]\", p2i(r->value())); \/\/value==target\n@@ -879,1 +906,1 @@\n-      tty->print(\" | [destination=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n+      st->print(\" | [destination=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n@@ -883,1 +910,1 @@\n-        tty->print(\" Blob::%s\", cb->name());\n+        st->print(\" Blob::%s\", cb->name());\n@@ -892,1 +919,1 @@\n-      tty->print(\" | [destination=\" INTPTR_FORMAT \"]\", p2i(dest));\n+      st->print(\" | [destination=\" INTPTR_FORMAT \"]\", p2i(dest));\n@@ -899,1 +926,1 @@\n-          tty->print(\" Stub::%s\", desc->name());\n+          st->print(\" Stub::%s\", desc->name());\n@@ -904,1 +931,1 @@\n-          tty->print(\" %s\", cb->name());\n+          st->print(\" %s\", cb->name());\n@@ -911,1 +938,1 @@\n-            tty->print(\" %s\", buf);\n+            st->print(\" %s\", buf);\n@@ -913,1 +940,1 @@\n-              tty->print(\"+%d\", offset);\n+              st->print(\"+%d\", offset);\n@@ -923,1 +950,1 @@\n-      tty->print(\" | [destination=\" INTPTR_FORMAT \" cached_value=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n+      st->print(\" | [destination=\" INTPTR_FORMAT \" cached_value=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n@@ -927,1 +954,1 @@\n-        tty->print(\" Blob::%s\", cb->name());\n+        st->print(\" Blob::%s\", cb->name());\n@@ -934,1 +961,1 @@\n-      tty->print(\" | [static_call=\" INTPTR_FORMAT \"]\", p2i(r->static_call()));\n+      st->print(\" | [static_call=\" INTPTR_FORMAT \"]\", p2i(r->static_call()));\n@@ -940,1 +967,1 @@\n-      tty->print(\" | [trampoline owner=\" INTPTR_FORMAT \"]\", p2i(r->owner()));\n+      st->print(\" | [trampoline owner=\" INTPTR_FORMAT \"]\", p2i(r->owner()));\n@@ -946,1 +973,1 @@\n-      tty->print(\" | [destination=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n+      st->print(\" | [destination=\" INTPTR_FORMAT \" metadata=\" INTPTR_FORMAT \"]\",\n@@ -950,1 +977,1 @@\n-        tty->print(\" Blob::%s\", cb->name());\n+        st->print(\" Blob::%s\", cb->name());\n@@ -957,1 +984,1 @@\n-  tty->cr();\n+  st->cr();\n@@ -961,1 +988,1 @@\n-void RelocIterator::print() {\n+void RelocIterator::print_on(outputStream* st) {\n@@ -972,1 +999,1 @@\n-    tty->print(\"         @\" INTPTR_FORMAT \": \", p2i(scan));\n+    st->print(\"         @\" INTPTR_FORMAT \": \", p2i(scan));\n@@ -976,1 +1003,1 @@\n-      tty->print(\"%04x\", *(short*)scan & 0xFFFF);\n+      st->print(\"%04x\", *(short*)scan & 0xFFFF);\n@@ -979,1 +1006,1 @@\n-    tty->cr();\n+    st->cr();\n@@ -982,1 +1009,1 @@\n-    print_current();\n+    print_current_on(st);\n@@ -988,0 +1015,5 @@\n+\/\/---------------------------------------------------------------------------------\n+\/\/ Non-product code\n+\n+#ifndef PRODUCT\n+\n@@ -993,1 +1025,1 @@\n-  iter.print();\n+  iter.print_on(tty);\n@@ -998,1 +1030,1 @@\n-  cb->print();\n+  cb->print_on(tty);\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":78,"deletions":46,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -454,0 +454,2 @@\n+\n+  static const char* type_name(relocInfo::relocType t);\n@@ -603,0 +605,1 @@\n+  RelocIterator(CodeBlob* cb);\n@@ -641,1 +644,1 @@\n-    assert(_section_start[n], \"must be initialized\");\n+    assert(_section_start[n], \"section %d must be initialized\", n);\n@@ -645,1 +648,1 @@\n-    assert(_section_end[n], \"must be initialized\");\n+    assert(_section_end[n], \"section %d must be initialized\", n);\n@@ -661,1 +664,0 @@\n-#ifndef PRODUCT\n@@ -663,3 +665,2 @@\n-  void print();\n-  void print_current();\n-#endif\n+  void print_on(outputStream* st);\n+  void print_current_on(outputStream* st);\n@@ -675,0 +676,1 @@\n+  friend class AOTCodeReader;\n@@ -1380,0 +1382,2 @@\n+  void fix_relocation_after_aot_load(address orig_base_addr, address current_base_addr);\n+\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -732,1 +732,0 @@\n-#ifdef ASSERT\n@@ -741,1 +740,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -295,3 +295,1 @@\n-#ifdef ASSERT\n-  int nr_of_bytes() const; \/\/ this is an expensive operation, only used in debug builds\n-#endif\n+  int nr_of_bytes() const; \/\/ this is an expensive operation, only used in debug builds or in aot code generation\n@@ -381,1 +379,0 @@\n-#ifdef ASSERT\n@@ -383,1 +380,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#define NUM_CDS_REGIONS 4 \/\/ this must be the same as MetaspaceShared::n_regions\n+#define NUM_CDS_REGIONS 5 \/\/ this must be the same as MetaspaceShared::n_regions\n@@ -43,1 +43,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 18\n+#define CURRENT_CDS_ARCHIVE_VERSION 19\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -317,1 +317,3 @@\n-  f(RecordComponent)\n+  f(RecordComponent) \\\n+  f(AdapterHandlerEntry) \\\n+  f(AdapterFingerPrint)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -399,0 +399,5 @@\n+      if (reserved_rgn->mem_tag() == mtCode) {\n+        assert(reserved_rgn->contain_region(base_addr, size), \"Reserved code region should contain this mapping region\");\n+        return true;\n+      }\n+\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -395,0 +396,1 @@\n+  it->push(&_adapter);\n@@ -408,0 +410,3 @@\n+  if (AOTCodeCache::is_dumping_adapters() && _adapter != nullptr) {\n+    _adapter->remove_unshareable_info();\n+  }\n@@ -413,0 +418,4 @@\n+  if (_adapter != nullptr) {\n+    assert(_adapter->is_linked(), \"must be\");\n+    _from_compiled_entry = _adapter->get_c2i_entry();\n+  }\n@@ -1140,1 +1149,3 @@\n-  _adapter = nullptr;\n+  if (!AOTCodeCache::is_dumping_adapters() || AdapterHandlerLibrary::is_abstract_method_adapter(_adapter)) {\n+    _adapter = nullptr;\n+  }\n@@ -1181,1 +1192,5 @@\n-    return;\n+    if (adapter()->is_shared()) {\n+      assert(adapter()->is_linked(), \"Adapter is shared but not linked\");\n+    } else {\n+      return;\n+    }\n@@ -1188,1 +1203,1 @@\n-  assert(adapter() == nullptr, \"init'd to null\");\n+  assert(adapter() == nullptr || adapter()->is_linked(), \"init'd to null or restored from cache\");\n@@ -1209,1 +1224,4 @@\n-  (void) make_adapters(h_method, CHECK);\n+  if (_adapter == nullptr) {\n+    (void) make_adapters(h_method, CHECK);\n+    assert(adapter()->is_linked(), \"Adapter must have been linked\");\n+  }\n@@ -1485,0 +1503,3 @@\n+  if (m->adapter() != nullptr) {\n+    m->set_from_compiled_entry(m->adapter()->get_c2i_entry());\n+  }\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+  friend class AOTCodeAddressTable;\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -146,1 +147,1 @@\n-\n+  AOTCodeCache::init2();     \/\/ depends on universe_init\n@@ -159,0 +160,2 @@\n+  AOTCodeCache::init_shared_blobs_table();  \/\/ need this after generate_stubs\n+  SharedRuntime::init_adapter_library(); \/\/ do this after AOTCodeCache::init_shared_blobs_table\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -126,0 +126,2 @@\n+Mutex*   AOTCodeCStrings_lock         = nullptr;\n+\n@@ -322,0 +324,2 @@\n+  MUTEX_DEFL(AOTCodeCStrings_lock           , PaddedMutex  , tty_lock);\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,0 +151,2 @@\n+extern Mutex*   AOTCodeCStrings_lock;            \/\/ used to guard access to the AOT code C strings table\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.inline.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -150,2 +153,0 @@\n-  AdapterHandlerLibrary::initialize();\n-\n@@ -171,0 +172,4 @@\n+void SharedRuntime::init_adapter_library() {\n+  AdapterHandlerLibrary::initialize();\n+}\n+\n@@ -2173,1 +2178,2 @@\n-static int _hits;    \/\/ number of successful lookups\n+static int _archived_hits; \/\/ number of successful lookups in archived table\n+static int _runtime_hits;  \/\/ number of successful lookups in runtime table\n@@ -2179,1 +2185,1 @@\n-class AdapterFingerPrint : public CHeapObj<mtCode> {\n+class AdapterFingerPrint : public MetaspaceObj {\n@@ -2190,6 +2196,23 @@\n-  union {\n-    int  _compact[_compact_int_count];\n-    int* _fingerprint;\n-  } _value;\n-  int _length; \/\/ A negative length indicates the fingerprint is in the compact form,\n-               \/\/ Otherwise _value._fingerprint is the array.\n+  int _length;\n+  int _value[_compact_int_count];\n+\n+  \/\/ Private construtor. Use allocate() to get an instance.\n+  AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {\n+    \/\/ Pack the BasicTypes with 8 per int\n+    _length = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n+    int sig_index = 0;\n+    for (int index = 0; index < _length; index++) {\n+      int value = 0;\n+      for (int byte = 0; sig_index < total_args_passed && byte < _basic_types_per_int; byte++) {\n+        int bt = adapter_encoding(sig_bt[sig_index++]);\n+        assert((bt & _basic_type_mask) == bt, \"must fit in 4 bits\");\n+        value = (value << _basic_type_bits) | bt;\n+      }\n+      _value[index] = value;\n+    }\n+  }\n+\n+  \/\/ Call deallocate instead\n+  ~AdapterFingerPrint() {\n+    FreeHeap(this);\n+  }\n@@ -2232,18 +2255,6 @@\n- public:\n-  AdapterFingerPrint(int total_args_passed, BasicType* sig_bt) {\n-    \/\/ The fingerprint is based on the BasicType signature encoded\n-    \/\/ into an array of ints with eight entries per int.\n-    int* ptr;\n-    int len = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n-    if (len <= _compact_int_count) {\n-      assert(_compact_int_count == 3, \"else change next line\");\n-      _value._compact[0] = _value._compact[1] = _value._compact[2] = 0;\n-      \/\/ Storing the signature encoded as signed chars hits about 98%\n-      \/\/ of the time.\n-      _length = -len;\n-      ptr = _value._compact;\n-    } else {\n-      _length = len;\n-      _value._fingerprint = NEW_C_HEAP_ARRAY(int, _length, mtCode);\n-      ptr = _value._fingerprint;\n-    }\n+  void* operator new(size_t size, size_t fp_size) throw() {\n+    assert(fp_size >= size, \"sanity check\");\n+    void* p = AllocateHeap(fp_size, mtCode);\n+    memset(p, 0, fp_size);\n+    return p;\n+  }\n@@ -2251,8 +2262,12 @@\n-    \/\/ Now pack the BasicTypes with 8 per int\n-    int sig_index = 0;\n-    for (int index = 0; index < len; index++) {\n-      int value = 0;\n-      for (int byte = 0; sig_index < total_args_passed && byte < _basic_types_per_int; byte++) {\n-        int bt = adapter_encoding(sig_bt[sig_index++]);\n-        assert((bt & _basic_type_mask) == bt, \"must fit in 4 bits\");\n-        value = (value << _basic_type_bits) | bt;\n+  template<typename Function>\n+  void iterate_args(Function function) {\n+    for (int i = 0; i < length(); i++) {\n+      unsigned val = (unsigned)value(i);\n+      \/\/ args are packed so that first\/lower arguments are in the highest\n+      \/\/ bits of each int value, so iterate from highest to the lowest\n+      for (int j = 32 - _basic_type_bits; j >= 0; j -= _basic_type_bits) {\n+        unsigned v = (val >> j) & _basic_type_mask;\n+        if (v == 0) {\n+          continue;\n+        }\n+        function(v);\n@@ -2260,1 +2275,0 @@\n-      ptr[index] = value;\n@@ -2264,4 +2278,13 @@\n-  ~AdapterFingerPrint() {\n-    if (_length > 0) {\n-      FREE_C_HEAP_ARRAY(int, _value._fingerprint);\n-    }\n+ public:\n+  static int allocation_size(int total_args_passed, BasicType* sig_bt) {\n+    int len = (total_args_passed + (_basic_types_per_int-1)) \/ _basic_types_per_int;\n+    return sizeof(AdapterFingerPrint) + (len > _compact_int_count ? (len - _compact_int_count) * sizeof(int) : 0);\n+  }\n+\n+  static AdapterFingerPrint* allocate(int total_args_passed, BasicType* sig_bt) {\n+    int size_in_bytes = allocation_size(total_args_passed, sig_bt);\n+    return new (size_in_bytes) AdapterFingerPrint(total_args_passed, sig_bt);\n+  }\n+\n+  static void deallocate(AdapterFingerPrint* fp) {\n+    fp->~AdapterFingerPrint();\n@@ -2271,4 +2294,1 @@\n-    if (_length < 0) {\n-      return _value._compact[index];\n-    }\n-    return _value._fingerprint[index];\n+    return _value[index];\n@@ -2276,0 +2296,1 @@\n+\n@@ -2282,1 +2303,1 @@\n-    return _length <= 0;\n+    return _length <= _compact_int_count;\n@@ -2289,1 +2310,2 @@\n-      hash = (hash << 8) ^ v ^ (hash >> 5);\n+      \/\/Add arithmetic operation to the hash, like +3 to improve hashing\n+      hash = ((hash << 8) ^ v ^ (hash >> 5)) + 3;\n@@ -2303,3 +2325,0 @@\n-#ifndef PRODUCT\n-  \/\/ Reconstitutes the basic type arguments from the fingerprint,\n-  \/\/ producing strings like LIJDF\n@@ -2309,25 +2328,7 @@\n-    for (int i = 0; i < length(); i++) {\n-      unsigned val = (unsigned)value(i);\n-      \/\/ args are packed so that first\/lower arguments are in the highest\n-      \/\/ bits of each int value, so iterate from highest to the lowest\n-      for (int j = 32 - _basic_type_bits; j >= 0; j -= _basic_type_bits) {\n-        unsigned v = (val >> j) & _basic_type_mask;\n-        if (v == 0) {\n-          assert(i == length() - 1, \"Only expect zeroes in the last word\");\n-          continue;\n-        }\n-        if (long_prev) {\n-          long_prev = false;\n-          if (v == T_VOID) {\n-            st.print(\"J\");\n-          } else {\n-            st.print(\"L\");\n-          }\n-        }\n-        switch (v) {\n-          case T_INT:    st.print(\"I\");    break;\n-          case T_LONG:   long_prev = true; break;\n-          case T_FLOAT:  st.print(\"F\");    break;\n-          case T_DOUBLE: st.print(\"D\");    break;\n-          case T_VOID:   break;\n-          default: ShouldNotReachHere();\n+    iterate_args([&] (int arg) {\n+      if (long_prev) {\n+        long_prev = false;\n+        if (arg == T_VOID) {\n+          st.print(\"J\");\n+        } else {\n+          st.print(\"L\");\n@@ -2336,1 +2337,9 @@\n-    }\n+      switch (arg) {\n+        case T_INT:    st.print(\"I\");    break;\n+        case T_LONG:   long_prev = true; break;\n+        case T_FLOAT:  st.print(\"F\");    break;\n+        case T_DOUBLE: st.print(\"D\");    break;\n+        case T_VOID:   break;\n+        default: ShouldNotReachHere();\n+      }\n+    });\n@@ -2342,1 +2351,51 @@\n-#endif \/\/ !product\n+\n+  BasicType* as_basic_type(int& nargs) {\n+    nargs = 0;\n+    GrowableArray<BasicType> btarray;\n+    bool long_prev = false;\n+\n+    iterate_args([&] (int arg) {\n+      if (long_prev) {\n+        long_prev = false;\n+        if (arg == T_VOID) {\n+          btarray.append(T_LONG);\n+        } else {\n+          btarray.append(T_OBJECT); \/\/ it could be T_ARRAY; it shouldn't matter\n+        }\n+      }\n+      switch (arg) {\n+        case T_INT: \/\/ fallthrough\n+        case T_FLOAT: \/\/ fallthrough\n+        case T_DOUBLE:\n+        case T_VOID:\n+          btarray.append((BasicType)arg);\n+          break;\n+        case T_LONG:\n+          long_prev = true;\n+          break;\n+        default: ShouldNotReachHere();\n+      }\n+    });\n+\n+    if (long_prev) {\n+      btarray.append(T_OBJECT);\n+    }\n+\n+    nargs = btarray.length();\n+    BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, nargs);\n+    int index = 0;\n+    GrowableArrayIterator<BasicType> iter = btarray.begin();\n+    while (iter != btarray.end()) {\n+      sig_bt[index++] = *iter;\n+      ++iter;\n+    }\n+    assert(index == btarray.length(), \"sanity check\");\n+#ifdef ASSERT\n+    {\n+      AdapterFingerPrint* compare_fp = AdapterFingerPrint::allocate(nargs, sig_bt);\n+      assert(this->equals(compare_fp), \"sanity check\");\n+      AdapterFingerPrint::deallocate(compare_fp);\n+    }\n+#endif\n+    return sig_bt;\n+  }\n@@ -2347,6 +2406,0 @@\n-    }\n-    if (_length < 0) {\n-      assert(_compact_int_count == 3, \"else change next line\");\n-      return _value._compact[0] == other->_value._compact[0] &&\n-             _value._compact[1] == other->_value._compact[1] &&\n-             _value._compact[2] == other->_value._compact[2];\n@@ -2355,1 +2408,1 @@\n-        if (_value._fingerprint[i] != other->_value._fingerprint[i]) {\n+        if (_value[i] != other->_value[i]) {\n@@ -2363,0 +2416,5 @@\n+  \/\/ methods required by virtue of being a MetaspaceObj\n+  void metaspace_pointers_do(MetaspaceClosure* it) { return; \/* nothing to do here *\/ }\n+  int size() const { return (int)heap_word_size(sizeof(AdapterFingerPrint) + (_length > _compact_int_count ? (_length - _compact_int_count) * sizeof(int) : 0)); }\n+  MetaspaceObj::Type type() const { return AdapterFingerPrintType; }\n+\n@@ -2373,0 +2431,11 @@\n+#if INCLUDE_CDS\n+static inline bool adapter_fp_equals_compact_hashtable_entry(AdapterHandlerEntry* entry, AdapterFingerPrint* fp, int len_unused) {\n+  return AdapterFingerPrint::equals(entry->fingerprint(), fp);\n+}\n+\n+class ArchivedAdapterTable : public OffsetCompactHashtable<\n+  AdapterFingerPrint*,\n+  AdapterHandlerEntry*,\n+  adapter_fp_equals_compact_hashtable_entry> {};\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -2379,0 +2448,1 @@\n+static GrowableArray<AdapterHandlerEntry*>* _adapter_handler_list = nullptr;\n@@ -2381,1 +2451,1 @@\n-static AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt) {\n+AdapterHandlerEntry* AdapterHandlerLibrary::lookup(int total_args_passed, BasicType* sig_bt) {\n@@ -2384,3 +2454,9 @@\n-  AdapterFingerPrint fp(total_args_passed, sig_bt);\n-  AdapterHandlerEntry** entry = _adapter_handler_table->get(&fp);\n-  if (entry != nullptr) {\n+  AdapterFingerPrint* fp = AdapterFingerPrint::allocate(total_args_passed, sig_bt);\n+  AdapterHandlerEntry* entry = nullptr;\n+#if INCLUDE_CDS\n+  \/\/ if we are building the archive then the archived adapter table is\n+  \/\/ not valid and we need to use the ones added to the runtime table\n+  if (!AOTCodeCache::is_dumping_adapters()) {\n+    \/\/ Search archived table first. It is read-only table so can be searched without lock\n+    entry = _aot_adapter_handler_table.lookup(fp, fp->compute_hash(), 0 \/* unused *\/);\n+    if (entry != nullptr) {\n@@ -2388,2 +2464,4 @@\n-    if (fp.is_compact()) _compact++;\n-    _hits++;\n+      if (fp->is_compact()) {\n+        _compact++;\n+      }\n+      _archived_hits++;\n@@ -2391,1 +2469,1 @@\n-    return *entry;\n+    }\n@@ -2393,1 +2471,17 @@\n-  return nullptr;\n+#endif \/\/ INCLUDE_CDS\n+  if (entry == nullptr) {\n+    assert_lock_strong(AdapterHandlerLibrary_lock);\n+    AdapterHandlerEntry** entry_p = _adapter_handler_table->get(fp);\n+    if (entry_p != nullptr) {\n+      entry = *entry_p;\n+      assert(entry->fingerprint()->equals(fp), \"fingerprint mismatch key fp %s %s (hash=%d) != found fp %s %s (hash=%d)\",\n+             entry->fingerprint()->as_basic_args_string(), entry->fingerprint()->as_string(), entry->fingerprint()->compute_hash(),\n+             fp->as_basic_args_string(), fp->as_string(), fp->compute_hash());\n+  #ifndef PRODUCT\n+      if (fp->is_compact()) _compact++;\n+      _runtime_hits++;\n+  #endif\n+    }\n+  }\n+  AdapterFingerPrint::deallocate(fp);\n+  return entry;\n@@ -2405,2 +2499,3 @@\n-  tty->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d compact %d\",\n-                _lookups, _equals, _hits, _compact);\n+  int total_hits = _archived_hits + _runtime_hits;\n+  tty->print_cr(\"AdapterHandlerTable: lookups %d equals %d hits %d (archived=%d+runtime=%d) compact %d\",\n+                _lookups, _equals, total_hits, _archived_hits, _runtime_hits, _compact);\n@@ -2418,1 +2513,4 @@\n-const int AdapterHandlerLibrary_size = 16*K;\n+#if INCLUDE_CDS\n+ArchivedAdapterTable AdapterHandlerLibrary::_aot_adapter_handler_table;\n+#endif \/\/ INCLUDE_CDS\n+static const int AdapterHandlerLibrary_size = 16*K;\n@@ -2422,0 +2520,1 @@\n+  assert(_buffer != nullptr, \"should be initialized\");\n@@ -2444,0 +2543,15 @@\n+void AdapterHandlerLibrary::create_abstract_method_handler() {\n+  assert_lock_strong(AdapterHandlerLibrary_lock);\n+  \/\/ Create a special handler for abstract methods.  Abstract methods\n+  \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n+  \/\/ throw AbstractMethodError just in case.\n+  \/\/ Pass wrong_method_abstract for the c2i transitions to return\n+  \/\/ AbstractMethodError for invalid invocations.\n+  address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n+  _abstract_method_handler = AdapterHandlerLibrary::new_entry(AdapterFingerPrint::allocate(0, nullptr));\n+  _abstract_method_handler->set_entry_points(SharedRuntime::throw_AbstractMethodError_entry(),\n+                                             wrong_method_abstract,\n+                                             wrong_method_abstract,\n+                                             nullptr);\n+}\n+\n@@ -2445,0 +2559,17 @@\n+  {\n+    ResourceMark rm;\n+    MutexLocker mu(AdapterHandlerLibrary_lock);\n+    _adapter_handler_table = new (mtCode) AdapterHandlerTable();\n+    _buffer = BufferBlob::create(\"adapters\", AdapterHandlerLibrary_size);\n+    create_abstract_method_handler();\n+  }\n+\n+#if INCLUDE_CDS\n+  \/\/ Link adapters in AOT Cache to their code in AOT Code Cache\n+  if (!_aot_adapter_handler_table.empty()) {\n+    link_aot_adapters();\n+    lookup_simple_adapters();\n+    return;\n+  }\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -2452,1 +2583,0 @@\n-    _adapter_handler_table = new (mtCode) AdapterHandlerTable();\n@@ -2455,12 +2585,1 @@\n-    \/\/ Create a special handler for abstract methods.  Abstract methods\n-    \/\/ are never compiled so an i2c entry is somewhat meaningless, but\n-    \/\/ throw AbstractMethodError just in case.\n-    \/\/ Pass wrong_method_abstract for the c2i transitions to return\n-    \/\/ AbstractMethodError for invalid invocations.\n-    address wrong_method_abstract = SharedRuntime::get_handle_wrong_method_abstract_stub();\n-    _abstract_method_handler = AdapterHandlerLibrary::new_entry(new AdapterFingerPrint(0, nullptr),\n-                                                                SharedRuntime::throw_AbstractMethodError_entry(),\n-                                                                wrong_method_abstract, wrong_method_abstract);\n-\n-    _buffer = BufferBlob::create(\"adapters\", AdapterHandlerLibrary_size);\n-    _no_arg_handler = create_adapter(no_arg_blob, 0, nullptr, true);\n+    _no_arg_handler = create_adapter(no_arg_blob, 0, nullptr);\n@@ -2469,1 +2588,1 @@\n-    _obj_arg_handler = create_adapter(obj_arg_blob, 1, obj_args, true);\n+    _obj_arg_handler = create_adapter(obj_arg_blob, 1, obj_args);\n@@ -2472,1 +2591,1 @@\n-    _int_arg_handler = create_adapter(int_arg_blob, 1, int_args, true);\n+    _int_arg_handler = create_adapter(int_arg_blob, 1, int_args);\n@@ -2475,1 +2594,1 @@\n-    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, 2, obj_int_args, true);\n+    _obj_int_arg_handler = create_adapter(obj_int_arg_blob, 2, obj_int_args);\n@@ -2478,1 +2597,1 @@\n-    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, 2, obj_obj_args, true);\n+    _obj_obj_arg_handler = create_adapter(obj_obj_arg_blob, 2, obj_obj_args);\n@@ -2481,4 +2600,4 @@\n-          obj_arg_blob != nullptr &&\n-          int_arg_blob != nullptr &&\n-          obj_int_arg_blob != nullptr &&\n-          obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n+           obj_arg_blob != nullptr &&\n+           int_arg_blob != nullptr &&\n+           obj_int_arg_blob != nullptr &&\n+           obj_obj_arg_blob != nullptr, \"Initial adapters must be properly created\");\n@@ -2495,8 +2614,2 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint,\n-                                                      address i2c_entry,\n-                                                      address c2i_entry,\n-                                                      address c2i_unverified_entry,\n-                                                      address c2i_no_clinit_check_entry) {\n-  \/\/ Insert an entry into the table\n-  return new AdapterHandlerEntry(fingerprint, i2c_entry, c2i_entry, c2i_unverified_entry,\n-                                 c2i_no_clinit_check_entry);\n+AdapterHandlerEntry* AdapterHandlerLibrary::new_entry(AdapterFingerPrint* fingerprint) {\n+  return AdapterHandlerEntry::allocate(fingerprint);\n@@ -2586,0 +2699,16 @@\n+\n+const char* AdapterHandlerEntry::_entry_names[] = {\n+  \"i2c\", \"c2i\", \"c2i_unverified\", \"c2i_no_clinit_check\"\n+};\n+\n+#ifdef ASSERT\n+void AdapterHandlerLibrary::verify_adapter_sharing(int total_args_passed, BasicType* sig_bt, AdapterHandlerEntry* cached_entry) {\n+  AdapterBlob* comparison_blob = nullptr;\n+  AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, total_args_passed, sig_bt, true);\n+  assert(comparison_blob == nullptr, \"no blob should be created when creating an adapter for comparison\");\n+  assert(comparison_entry->compare_code(cached_entry), \"code must match\");\n+  \/\/ Release the one just created\n+  AdapterHandlerEntry::deallocate(comparison_entry);\n+}\n+#endif \/* ASSERT*\/\n+\n@@ -2599,1 +2728,1 @@\n-  AdapterBlob* new_adapter = nullptr;\n+  AdapterBlob* adapter_blob = nullptr;\n@@ -2615,0 +2744,1 @@\n+      assert(entry->is_linked(), \"AdapterHandlerEntry must have been linked\");\n@@ -2616,7 +2746,2 @@\n-      if (VerifyAdapterSharing) {\n-        AdapterBlob* comparison_blob = nullptr;\n-        AdapterHandlerEntry* comparison_entry = create_adapter(comparison_blob, total_args_passed, sig_bt, false);\n-        assert(comparison_blob == nullptr, \"no blob should be created when creating an adapter for comparison\");\n-        assert(comparison_entry->compare_code(entry), \"code must match\");\n-        \/\/ Release the one just created and return the original\n-        delete comparison_entry;\n+      if (!entry->is_shared() && VerifyAdapterSharing) {\n+        verify_adapter_sharing(total_args_passed, sig_bt, entry);\n@@ -2625,1 +2750,2 @@\n-      return entry;\n+    } else {\n+      entry = create_adapter(adapter_blob, total_args_passed, sig_bt);\n@@ -2627,2 +2753,0 @@\n-\n-    entry = create_adapter(new_adapter, total_args_passed, sig_bt, \/* allocate_code_blob *\/ true);\n@@ -2632,2 +2756,2 @@\n-  if (new_adapter != nullptr) {\n-    post_adapter_creation(new_adapter, entry);\n+  if (adapter_blob != nullptr) {\n+    post_adapter_creation(adapter_blob, entry);\n@@ -2638,4 +2762,42 @@\n-AdapterHandlerEntry* AdapterHandlerLibrary::create_adapter(AdapterBlob*& new_adapter,\n-                                                           int total_args_passed,\n-                                                           BasicType* sig_bt,\n-                                                           bool allocate_code_blob) {\n+AdapterBlob* AdapterHandlerLibrary::lookup_aot_cache(AdapterHandlerEntry* handler) {\n+  ResourceMark rm;\n+  const char* name = AdapterHandlerLibrary::name(handler->fingerprint());\n+  const uint32_t id = AdapterHandlerLibrary::id(handler->fingerprint());\n+  int offsets[AdapterHandlerEntry::ENTRIES_COUNT];\n+\n+  AdapterBlob* adapter_blob = nullptr;\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::Adapter, id, name, AdapterHandlerEntry::ENTRIES_COUNT, offsets);\n+  if (blob != nullptr) {\n+    adapter_blob = blob->as_adapter_blob();\n+    address i2c_entry = adapter_blob->content_begin();\n+    assert(offsets[0] == 0, \"sanity check\");\n+    handler->set_entry_points(i2c_entry, i2c_entry + offsets[1], i2c_entry + offsets[2], i2c_entry + offsets[3]);\n+  }\n+  return adapter_blob;\n+}\n+\n+#ifndef PRODUCT\n+void AdapterHandlerLibrary::print_adapter_handler_info(outputStream* st, AdapterHandlerEntry* handler, AdapterBlob* adapter_blob) {\n+  ttyLocker ttyl;\n+  ResourceMark rm;\n+  int insts_size = adapter_blob->code_size();\n+  handler->print_adapter_on(tty);\n+  st->print_cr(\"i2c argument handler for: %s %s (%d bytes generated)\",\n+                handler->fingerprint()->as_basic_args_string(),\n+                handler->fingerprint()->as_string(), insts_size);\n+  st->print_cr(\"c2i argument handler starts at \" INTPTR_FORMAT, p2i(handler->get_c2i_entry()));\n+  if (Verbose || PrintStubCode) {\n+    address first_pc = handler->base_address();\n+    if (first_pc != nullptr) {\n+      Disassembler::decode(first_pc, first_pc + insts_size, st, &adapter_blob->asm_remarks());\n+      st->cr();\n+    }\n+  }\n+}\n+#endif \/\/ PRODUCT\n+\n+bool AdapterHandlerLibrary::generate_adapter_code(AdapterBlob*& adapter_blob,\n+                                                  AdapterHandlerEntry* handler,\n+                                                  int total_args_passed,\n+                                                  BasicType* sig_bt,\n+                                                  bool is_transient) {\n@@ -2646,11 +2808,0 @@\n-  \/\/ StubRoutines::_final_stubs_code is initialized after this function can be called. As a result,\n-  \/\/ VerifyAdapterCalls and VerifyAdapterSharing can fail if we re-use code that generated prior\n-  \/\/ to all StubRoutines::_final_stubs_code being set. Checks refer to runtime range checks generated\n-  \/\/ in an I2C stub that ensure that an I2C stub is called from an interpreter frame or stubs.\n-  bool contains_all_checks = StubRoutines::final_stubs_code() != nullptr;\n-\n-  VMRegPair stack_regs[16];\n-  VMRegPair* regs = (total_args_passed <= 16) ? stack_regs : NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);\n-\n-  \/\/ Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage\n-  int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n@@ -2661,11 +2812,4 @@\n-                                          sizeof(buffer_locs)\/sizeof(relocInfo));\n-\n-  \/\/ Make a C heap allocated version of the fingerprint to store in the adapter\n-  AdapterFingerPrint* fingerprint = new AdapterFingerPrint(total_args_passed, sig_bt);\n-  MacroAssembler _masm(&buffer);\n-  AdapterHandlerEntry* entry = SharedRuntime::generate_i2c2i_adapters(&_masm,\n-                                                total_args_passed,\n-                                                comp_args_on_stack,\n-                                                sig_bt,\n-                                                regs,\n-                                                fingerprint);\n+                                         sizeof(buffer_locs)\/sizeof(relocInfo));\n+  MacroAssembler masm(&buffer);\n+  VMRegPair stack_regs[16];\n+  VMRegPair* regs = (total_args_passed <= 16) ? stack_regs : NEW_RESOURCE_ARRAY(VMRegPair, total_args_passed);\n@@ -2673,0 +2817,8 @@\n+  \/\/ Get a description of the compiled java calling convention and the largest used (VMReg) stack slot usage\n+  int comp_args_on_stack = SharedRuntime::java_calling_convention(sig_bt, regs, total_args_passed);\n+  SharedRuntime::generate_i2c2i_adapters(&masm,\n+                                         total_args_passed,\n+                                         comp_args_on_stack,\n+                                         sig_bt,\n+                                         regs,\n+                                         handler);\n@@ -2675,3 +2827,3 @@\n-    entry->save_code(buf->code_begin(), buffer.insts_size());\n-    if (!allocate_code_blob) {\n-      return entry;\n+    handler->save_code(buf->code_begin(), buffer.insts_size());\n+    if (is_transient) {\n+      return true;\n@@ -2682,3 +2834,2 @@\n-  new_adapter = AdapterBlob::create(&buffer);\n-  NOT_PRODUCT(int insts_size = buffer.insts_size());\n-  if (new_adapter == nullptr) {\n+  adapter_blob = AdapterBlob::create(&buffer);\n+  if (adapter_blob == nullptr) {\n@@ -2688,1 +2839,1 @@\n-    return nullptr;\n+    return false;\n@@ -2690,1 +2841,15 @@\n-  entry->relocate(new_adapter->content_begin());\n+  if (!is_transient && AOTCodeCache::is_dumping_adapters()) {\n+    \/\/ try to save generated code\n+    const char* name = AdapterHandlerLibrary::name(handler->fingerprint());\n+    const uint32_t id = AdapterHandlerLibrary::id(handler->fingerprint());\n+    int entry_offset[AdapterHandlerEntry::ENTRIES_COUNT];\n+    assert(AdapterHandlerEntry::ENTRIES_COUNT == 4, \"sanity\");\n+    address i2c_entry = handler->get_i2c_entry();\n+    entry_offset[0] = 0; \/\/ i2c_entry offset\n+    entry_offset[1] = handler->get_c2i_entry() - i2c_entry;\n+    entry_offset[2] = handler->get_c2i_unverified_entry() - i2c_entry;\n+    entry_offset[3] = handler->get_c2i_no_clinit_check_entry() - i2c_entry;\n+    bool success = AOTCodeCache::store_code_blob(*adapter_blob, AOTCodeEntry::Adapter, id, name, AdapterHandlerEntry::ENTRIES_COUNT, entry_offset);\n+    assert(success || !AOTCodeCache::is_dumping_adapters(), \"sanity\");\n+  }\n+  handler->relocate(adapter_blob->content_begin());\n@@ -2694,12 +2859,61 @@\n-    ttyLocker ttyl;\n-    entry->print_adapter_on(tty);\n-    tty->print_cr(\"i2c argument handler #%d for: %s %s (%d bytes generated)\",\n-                  _adapter_handler_table->number_of_entries(), fingerprint->as_basic_args_string(),\n-                  fingerprint->as_string(), insts_size);\n-    tty->print_cr(\"c2i argument handler starts at \" INTPTR_FORMAT, p2i(entry->get_c2i_entry()));\n-    if (Verbose || PrintStubCode) {\n-      address first_pc = entry->base_address();\n-      if (first_pc != nullptr) {\n-        Disassembler::decode(first_pc, first_pc + insts_size, tty\n-                             NOT_PRODUCT(COMMA &new_adapter->asm_remarks()));\n-        tty->cr();\n+    print_adapter_handler_info(tty, handler, adapter_blob);\n+  }\n+#endif\n+  return true;\n+}\n+\n+AdapterHandlerEntry* AdapterHandlerLibrary::create_adapter(AdapterBlob*& adapter_blob,\n+                                                           int total_args_passed,\n+                                                           BasicType* sig_bt,\n+                                                           bool is_transient) {\n+  AdapterFingerPrint* fp = AdapterFingerPrint::allocate(total_args_passed, sig_bt);\n+  AdapterHandlerEntry* handler = AdapterHandlerLibrary::new_entry(fp);\n+  if (!generate_adapter_code(adapter_blob, handler, total_args_passed, sig_bt, is_transient)) {\n+    AdapterHandlerEntry::deallocate(handler);\n+    return nullptr;\n+  }\n+  if (!is_transient) {\n+    assert_lock_strong(AdapterHandlerLibrary_lock);\n+    _adapter_handler_table->put(fp, handler);\n+  }\n+  return handler;\n+}\n+\n+#if INCLUDE_CDS\n+void AdapterHandlerEntry::remove_unshareable_info() {\n+#ifdef ASSERT\n+   _saved_code = nullptr;\n+   _saved_code_length = 0;\n+#endif \/\/ ASSERT\n+  set_entry_points(nullptr, nullptr, nullptr, nullptr, false);\n+}\n+\n+class CopyAdapterTableToArchive : StackObj {\n+private:\n+  CompactHashtableWriter* _writer;\n+  ArchiveBuilder* _builder;\n+public:\n+  CopyAdapterTableToArchive(CompactHashtableWriter* writer) : _writer(writer),\n+                                                             _builder(ArchiveBuilder::current())\n+  {}\n+\n+  bool do_entry(AdapterFingerPrint* fp, AdapterHandlerEntry* entry) {\n+    LogStreamHandle(Trace, cds) lsh;\n+    if (ArchiveBuilder::current()->has_been_archived((address)entry)) {\n+      assert(ArchiveBuilder::current()->has_been_archived((address)fp), \"must be\");\n+      AdapterFingerPrint* buffered_fp = ArchiveBuilder::current()->get_buffered_addr(fp);\n+      assert(buffered_fp != nullptr,\"sanity check\");\n+      AdapterHandlerEntry* buffered_entry = ArchiveBuilder::current()->get_buffered_addr(entry);\n+      assert(buffered_entry != nullptr,\"sanity check\");\n+\n+      uint hash = fp->compute_hash();\n+      u4 delta = _builder->buffer_to_offset_u4((address)buffered_entry);\n+      _writer->add(hash, delta);\n+      if (lsh.is_enabled()) {\n+        address fp_runtime_addr = (address)buffered_fp + ArchiveBuilder::current()->buffer_to_requested_delta();\n+        address entry_runtime_addr = (address)buffered_entry + ArchiveBuilder::current()->buffer_to_requested_delta();\n+        log_trace(cds)(\"Added fp=%p (%s), entry=%p to the archived adater table\", buffered_fp, buffered_fp->as_basic_args_string(), buffered_entry);\n+      }\n+    } else {\n+      if (lsh.is_enabled()) {\n+        log_trace(cds)(\"Skipping adapter handler %p (fp=%s) as it is not archived\", entry, fp->as_basic_args_string());\n@@ -2708,0 +2922,20 @@\n+    return true;\n+  }\n+};\n+\n+void AdapterHandlerLibrary::dump_aot_adapter_table() {\n+  CompactHashtableStats stats;\n+  CompactHashtableWriter writer(_adapter_handler_table->number_of_entries(), &stats);\n+  CopyAdapterTableToArchive copy(&writer);\n+  _adapter_handler_table->iterate(&copy);\n+  writer.dump(&_aot_adapter_handler_table, \"archived adapter table\");\n+}\n+\n+void AdapterHandlerLibrary::serialize_shared_table_header(SerializeClosure* soc) {\n+  _aot_adapter_handler_table.serialize_header(soc);\n+}\n+\n+AdapterBlob* AdapterHandlerLibrary::link_aot_adapter_handler(AdapterHandlerEntry* handler) {\n+#ifdef ASSERT\n+  if (TestAOTAdapterLinkFailure) {\n+    return nullptr;\n@@ -2710,0 +2944,9 @@\n+  AdapterBlob* blob = lookup_aot_cache(handler);\n+#ifndef PRODUCT\n+  \/\/ debugging support\n+  if ((blob != nullptr) && (PrintAdapterHandlers || PrintStubCode)) {\n+    print_adapter_handler_info(tty, handler, blob);\n+  }\n+#endif\n+  return blob;\n+}\n@@ -2711,5 +2954,28 @@\n-  \/\/ Add the entry only if the entry contains all required checks (see sharedRuntime_xxx.cpp)\n-  \/\/ The checks are inserted only if -XX:+VerifyAdapterCalls is specified.\n-  if (contains_all_checks || !VerifyAdapterCalls) {\n-    assert_lock_strong(AdapterHandlerLibrary_lock);\n-    _adapter_handler_table->put(fingerprint, entry);\n+\/\/ This method is used during production run to link archived adapters (stored in AOT Cache)\n+\/\/ to their code in AOT Code Cache\n+void AdapterHandlerEntry::link() {\n+  AdapterBlob* adapter_blob = nullptr;\n+  ResourceMark rm;\n+  assert(_fingerprint != nullptr, \"_fingerprint must not be null\");\n+  bool generate_code = false;\n+  \/\/ Generate code only if AOTCodeCache is not available, or\n+  \/\/ caching adapters is disabled, or we fail to link\n+  \/\/ the AdapterHandlerEntry to its code in the AOTCodeCache\n+  if (AOTCodeCache::is_using_adapters()) {\n+    adapter_blob = AdapterHandlerLibrary::link_aot_adapter_handler(this);\n+    if (adapter_blob == nullptr) {\n+      log_warning(cds)(\"Failed to link AdapterHandlerEntry (fp=%s) to its code in the AOT code cache\", _fingerprint->as_basic_args_string());\n+      generate_code = true;\n+    }\n+  } else {\n+    generate_code = true;\n+  }\n+  if (generate_code) {\n+    int nargs;\n+    BasicType* bt = _fingerprint->as_basic_type(nargs);\n+    if (!AdapterHandlerLibrary::generate_adapter_code(adapter_blob, this, nargs, bt, \/* is_transient *\/ false)) {\n+      \/\/ Don't throw exceptions during VM initialization because java.lang.* classes\n+      \/\/ might not have been initialized, causing problems when constructing the\n+      \/\/ Java exception object.\n+      vm_exit_during_initialization(\"Out of space in CodeCache for adapters\");\n+    }\n@@ -2717,1 +2983,12 @@\n-  return entry;\n+  \/\/ Outside of the lock\n+  if (adapter_blob != nullptr) {\n+    post_adapter_creation(adapter_blob, this);\n+  }\n+  assert(_linked, \"AdapterHandlerEntry must now be linked\");\n+}\n+\n+void AdapterHandlerLibrary::link_aot_adapters() {\n+  _aot_adapter_handler_table.iterate([](AdapterHandlerEntry* entry) {\n+    assert(!entry->is_linked(), \"AdapterHandlerEntry is already linked!\");\n+    entry->link();\n+  });\n@@ -2720,0 +2997,33 @@\n+\/\/ This method is called during production run to lookup simple adapters\n+\/\/ in the archived adapter handler table\n+void AdapterHandlerLibrary::lookup_simple_adapters() {\n+  assert(!_aot_adapter_handler_table.empty(), \"archived adapter handler table is empty\");\n+\n+  MutexLocker mu(AdapterHandlerLibrary_lock);\n+  _no_arg_handler = lookup(0, nullptr);\n+\n+  BasicType obj_args[] = { T_OBJECT };\n+  _obj_arg_handler = lookup(1, obj_args);\n+\n+  BasicType int_args[] = { T_INT };\n+  _int_arg_handler = lookup(1, int_args);\n+\n+  BasicType obj_int_args[] = { T_OBJECT, T_INT };\n+  _obj_int_arg_handler = lookup(2, obj_int_args);\n+\n+  BasicType obj_obj_args[] = { T_OBJECT, T_OBJECT };\n+  _obj_obj_arg_handler = lookup(2, obj_obj_args);\n+\n+  assert(_no_arg_handler != nullptr &&\n+         _obj_arg_handler != nullptr &&\n+         _int_arg_handler != nullptr &&\n+         _obj_int_arg_handler != nullptr &&\n+         _obj_obj_arg_handler != nullptr, \"Initial adapters not found in archived adapter handler table\");\n+  assert(_no_arg_handler->is_linked() &&\n+         _obj_arg_handler->is_linked() &&\n+         _int_arg_handler->is_linked() &&\n+         _obj_int_arg_handler->is_linked() &&\n+         _obj_obj_arg_handler->is_linked(), \"Initial adapters not in linked state\");\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -2744,0 +3054,8 @@\n+void AdapterHandlerEntry::metaspace_pointers_do(MetaspaceClosure* it) {\n+  LogStreamHandle(Trace, cds) lsh;\n+  if (lsh.is_enabled()) {\n+    lsh.print(\"Iter(AdapterHandlerEntry): %p(%s)\", this, _fingerprint->as_basic_args_string());\n+    lsh.cr();\n+  }\n+  it->push(&_fingerprint);\n+}\n@@ -2746,1 +3064,4 @@\n-  delete _fingerprint;\n+  if (_fingerprint != nullptr) {\n+    AdapterFingerPrint::deallocate(_fingerprint);\n+    _fingerprint = nullptr;\n+  }\n@@ -2750,0 +3071,1 @@\n+  FreeHeap(this);\n@@ -3054,2 +3376,3 @@\n-  auto findblob = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n-    return (found = (b == CodeCache::find_blob(a->get_i2c_entry())));\n+#if INCLUDE_CDS\n+  auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n+    return (found = (b == CodeCache::find_blob(handler->get_i2c_entry())));\n@@ -3057,2 +3380,9 @@\n-  assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n-  _adapter_handler_table->iterate(findblob);\n+  _aot_adapter_handler_table.iterate(findblob_archived_table);\n+#endif \/\/ INCLUDE_CDS\n+  if (!found) {\n+    auto findblob_runtime_table = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n+      return (found = (b == CodeCache::find_blob(a->get_i2c_entry())));\n+    };\n+    assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n+    _adapter_handler_table->iterate(findblob_runtime_table);\n+  }\n@@ -3062,0 +3392,9 @@\n+const char* AdapterHandlerLibrary::name(AdapterFingerPrint* fingerprint) {\n+  return fingerprint->as_basic_args_string();\n+}\n+\n+uint32_t AdapterHandlerLibrary::id(AdapterFingerPrint* fingerprint) {\n+  unsigned int hash = fingerprint->compute_hash();\n+  return hash;\n+}\n+\n@@ -3064,2 +3403,3 @@\n-  auto findblob = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n-    if (b == CodeCache::find_blob(a->get_i2c_entry())) {\n+#if INCLUDE_CDS\n+  auto findblob_archived_table = [&] (AdapterHandlerEntry* handler) {\n+    if (b == CodeCache::find_blob(handler->get_i2c_entry())) {\n@@ -3068,1 +3408,1 @@\n-      a->print_adapter_on(st);\n+      handler->print_adapter_on(st);\n@@ -3072,0 +3412,1 @@\n+\n@@ -3074,2 +3415,16 @@\n-  assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n-  _adapter_handler_table->iterate(findblob);\n+  _aot_adapter_handler_table.iterate(findblob_archived_table);\n+#endif \/\/ INCLUDE_CDS\n+  if (!found) {\n+    auto findblob_runtime_table = [&] (AdapterFingerPrint* key, AdapterHandlerEntry* a) {\n+      if (b == CodeCache::find_blob(a->get_i2c_entry())) {\n+        found = true;\n+        st->print(\"Adapter for signature: \");\n+        a->print_adapter_on(st);\n+        return true;\n+      } else {\n+        return false; \/\/ keep looking\n+      }\n+    };\n+    assert_locked_or_safepoint(AdapterHandlerLibrary_lock);\n+    _adapter_handler_table->iterate(findblob_runtime_table);\n+  }\n@@ -3104,0 +3459,7 @@\n+bool AdapterHandlerLibrary::is_abstract_method_adapter(AdapterHandlerEntry* entry) {\n+  if (entry == _abstract_method_handler) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":561,"deletions":199,"binary":false,"changes":760,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/compactHashtable.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"memory\/metaspaceClosure.hpp\"\n@@ -117,0 +119,1 @@\n+  static void init_adapter_library();\n@@ -467,6 +470,6 @@\n-  static AdapterHandlerEntry* generate_i2c2i_adapters(MacroAssembler *_masm,\n-                                                      int total_args_passed,\n-                                                      int max_arg,\n-                                                      const BasicType *sig_bt,\n-                                                      const VMRegPair *regs,\n-                                                      AdapterFingerPrint* fingerprint);\n+  static void generate_i2c2i_adapters(MacroAssembler *_masm,\n+                               int total_args_passed,\n+                               int max_arg,\n+                               const BasicType *sig_bt,\n+                               const VMRegPair *regs,\n+                               AdapterHandlerEntry* handler);\n@@ -669,1 +672,1 @@\n-class AdapterHandlerEntry : public CHeapObj<mtCode> {\n+class AdapterHandlerEntry : public MetaspaceObj {\n@@ -672,0 +675,3 @@\n+ public:\n+  static const int ENTRIES_COUNT = 4;\n+\n@@ -678,0 +684,3 @@\n+  bool    _linked;\n+\n+  static const char *_entry_names[];\n@@ -686,3 +695,1 @@\n-  AdapterHandlerEntry(AdapterFingerPrint* fingerprint, address i2c_entry, address c2i_entry,\n-                      address c2i_unverified_entry,\n-                      address c2i_no_clinit_check_entry) :\n+  AdapterHandlerEntry(AdapterFingerPrint* fingerprint) :\n@@ -690,4 +697,5 @@\n-    _i2c_entry(i2c_entry),\n-    _c2i_entry(c2i_entry),\n-    _c2i_unverified_entry(c2i_unverified_entry),\n-    _c2i_no_clinit_check_entry(c2i_no_clinit_check_entry)\n+    _i2c_entry(nullptr),\n+    _c2i_entry(nullptr),\n+    _c2i_unverified_entry(nullptr),\n+    _c2i_no_clinit_check_entry(nullptr),\n+    _linked(false)\n@@ -695,1 +703,2 @@\n-    , _saved_code_length(0)\n+    , _saved_code(nullptr),\n+    _saved_code_length(0)\n@@ -701,0 +710,9 @@\n+  \/\/ Allocate on CHeap instead of metaspace (see JDK-8331086).\n+  \/\/ Dummy argument is used to avoid C++ warning about using\n+  \/\/ deleted opearator MetaspaceObj::delete().\n+  void* operator new(size_t size, size_t dummy) throw() {\n+    void* p = AllocateHeap(size, mtCode);\n+    memset(p, 0, size);\n+    return p;\n+  }\n+\n@@ -702,0 +720,16 @@\n+  static AdapterHandlerEntry* allocate(AdapterFingerPrint* fingerprint) {\n+    return new(0) AdapterHandlerEntry(fingerprint);\n+  }\n+\n+  static void deallocate(AdapterHandlerEntry *handler) {\n+    handler->~AdapterHandlerEntry();\n+  }\n+\n+  void set_entry_points(address i2c_entry, address c2i_entry, address c2i_unverified_entry, address c2i_no_clinit_check_entry, bool linked = true) {\n+    _i2c_entry = i2c_entry;\n+    _c2i_entry = c2i_entry;\n+    _c2i_unverified_entry = c2i_unverified_entry;\n+    _c2i_no_clinit_check_entry = c2i_no_clinit_check_entry;\n+    _linked = linked;\n+  }\n+\n@@ -707,0 +741,6 @@\n+  static const char* entry_name(int i) {\n+    assert(i >=0 && i < ENTRIES_COUNT, \"entry id out of range\");\n+    return _entry_names[i];\n+  }\n+\n+  bool is_linked() const { return _linked; }\n@@ -720,0 +760,7 @@\n+\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  int size() const {return (int)heap_word_size(sizeof(AdapterHandlerEntry)); }\n+  MetaspaceObj::Type type() const { return AdapterHandlerEntryType; }\n+\n+  void remove_unshareable_info() NOT_CDS_RETURN;\n+  void link() NOT_CDS_RETURN;\n@@ -722,0 +769,4 @@\n+#if INCLUDE_CDS\n+class ArchivedAdapterTable;\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -732,0 +783,3 @@\n+#if INCLUDE_CDS\n+  static ArchivedAdapterTable _aot_adapter_handler_table;\n+#endif \/\/ INCLUDE_CDS\n@@ -735,0 +789,2 @@\n+  static AdapterHandlerEntry* get_simple_adapter(const methodHandle& method);\n+  static AdapterBlob* lookup_aot_cache(AdapterHandlerEntry* handler);\n@@ -738,2 +794,6 @@\n-                                             bool allocate_code_blob);\n-  static AdapterHandlerEntry* get_simple_adapter(const methodHandle& method);\n+                                             bool is_transient = false);\n+  static void create_abstract_method_handler();\n+  static void lookup_simple_adapters() NOT_CDS_RETURN;\n+#ifndef PRODUCT\n+  static void print_adapter_handler_info(outputStream* st, AdapterHandlerEntry* handler, AdapterBlob* adapter_blob);\n+#endif \/\/ PRODUCT\n@@ -742,5 +802,1 @@\n-  static AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint,\n-                                        address i2c_entry,\n-                                        address c2i_entry,\n-                                        address c2i_unverified_entry,\n-                                        address c2i_no_clinit_check_entry = nullptr);\n+  static AdapterHandlerEntry* new_entry(AdapterFingerPrint* fingerprint);\n@@ -749,0 +805,10 @@\n+  static AdapterHandlerEntry* lookup(int total_args_passed, BasicType* sig_bt);\n+  static bool generate_adapter_code(AdapterBlob*& adapter_blob,\n+                                    AdapterHandlerEntry* handler,\n+                                    int total_args_passed,\n+                                    BasicType* sig_bt,\n+                                    bool is_transient);\n+\n+#ifdef ASSERT\n+  static void verify_adapter_sharing(int total_args_passed, BasicType* sig_bt, AdapterHandlerEntry* cached);\n+#endif \/\/ ASSERT\n@@ -753,0 +819,2 @@\n+  static const char* name(AdapterFingerPrint* fingerprint);\n+  static uint32_t id(AdapterFingerPrint* fingerprint);\n@@ -757,0 +825,6 @@\n+  static bool is_abstract_method_adapter(AdapterHandlerEntry* adapter);\n+\n+  static AdapterBlob* link_aot_adapter_handler(AdapterHandlerEntry* handler) NOT_CDS_RETURN_(nullptr);\n+  static void dump_aot_adapter_table() NOT_CDS_RETURN;\n+  static void serialize_shared_table_header(SerializeClosure* soc) NOT_CDS_RETURN;\n+  static void link_aot_adapters() NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":96,"deletions":22,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -413,0 +413,1 @@\n+ -runtime\/cds\/appcds\/aotCode \\\n@@ -513,0 +514,1 @@\n+ -runtime\/cds\/appcds\/aotCode \\\n@@ -591,0 +593,1 @@\n+  runtime\/cds\/appcds\/aotCode \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Sanity test of combinations of the AOT Code Caching diagnostic flags\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.flagless\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/lib \/test\/setup_aot\n+ * @build AOTCodeFlags JavacBenchApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 JavacBenchApp\n+ *                 JavacBenchApp$ClassFile\n+ *                 JavacBenchApp$FileManager\n+ *                 JavacBenchApp$SourceFile\n+ * @run driver AOTCodeFlags\n+ *\/\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTCodeFlags {\n+    public static int flag_sign = 0;\n+    public static void main(String... args) throws Exception {\n+        Tester t = new Tester();\n+        for (int i = 0; i < 2; i++) {\n+            flag_sign = i;\n+            t.run(new String[] {\"AOT\"});\n+        }\n+    }\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(\"AOTCodeFlags\" + flag_sign);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return \"app.jar\";\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            switch (runMode) {\n+            case RunMode.ASSEMBLY:\n+            case RunMode.PRODUCTION:\n+                return new String[] {\n+                    \"-XX:+UnlockDiagnosticVMOptions\",\n+                    \"-XX:\" + (flag_sign == 0 ? \"-\" : \"+\") + \"AOTAdapterCaching\",\n+                    \"-Xlog:aot+codecache+init=debug\",\n+                    \"-Xlog:aot+codecache+exit=debug\",\n+                };\n+            }\n+            return new String[] {};\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                \"JavacBenchApp\", \"10\"\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (flag_sign == 0) {\n+                switch (runMode) {\n+                case RunMode.ASSEMBLY:\n+                case RunMode.PRODUCTION:\n+                    out.shouldNotContain(\"Adapters:  total\");\n+                    break;\n+                }\n+\n+            } else {\n+                switch (runMode) {\n+                case RunMode.ASSEMBLY:\n+                case RunMode.PRODUCTION:\n+                    out.shouldContain(\"Adapters:  total\");\n+                    break;\n+                }\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"}]}