{"files":[{"patch":"@@ -32,1 +32,0 @@\n-class ParMarkBitMapClosure;\n@@ -34,1 +33,0 @@\n-class ParCompactionManager;\n@@ -57,1 +55,0 @@\n-  inline bool is_unmarked(idx_t bit)      const;\n@@ -61,11 +58,0 @@\n-  \/\/ Convert sizes from bits to HeapWords and back.  An object that is n bits\n-  \/\/ long will be bits_to_words(n) words long.  An object that is m words long\n-  \/\/ will take up words_to_bits(m) bits in the bitmap.\n-  inline static size_t bits_to_words(idx_t bits);\n-  inline static idx_t  words_to_bits(size_t words);\n-\n-  inline HeapWord* region_start() const;\n-  inline HeapWord* region_end() const;\n-  inline size_t    region_size() const;\n-  inline size_t    size() const;\n-\n@@ -78,8 +64,0 @@\n-  \/\/ Return word-aligned up range_end, which must not be greater than size().\n-  inline idx_t align_range_end(idx_t range_end) const;\n-\n-  \/\/ Return the bit index of the first marked object that begins (or ends,\n-  \/\/ respectively) in the range [beg, end).  If no object is found, return end.\n-  \/\/ end must be word-aligned.\n-  inline idx_t find_obj_beg(idx_t beg, idx_t end) const;\n-\n@@ -95,5 +73,0 @@\n-  \/\/ Return the number of bits required to represent the specified number of\n-  \/\/ HeapWords, or the specified region.\n-  static inline idx_t bits_required(size_t words);\n-  static inline idx_t bits_required(MemRegion covered_region);\n-\n@@ -107,2 +80,0 @@\n-  inline void verify_bit(idx_t bit) const;\n-  inline void verify_addr(HeapWord* addr) const;\n@@ -116,1 +87,0 @@\n-  static inline size_t obj_granularity() { return size_t(MinObjAlignment); }\n@@ -124,0 +94,24 @@\n+\n+  \/\/ Return the number of bits required to represent the specified number of\n+  \/\/ HeapWords, or the specified region.\n+  static inline idx_t bits_required(size_t words);\n+  static inline idx_t bits_required(MemRegion covered_region);\n+\n+  \/\/ Convert sizes from bits to HeapWords and back.  An object that is n bits\n+  \/\/ long will be bits_to_words(n) words long.  An object that is m words long\n+  \/\/ will take up words_to_bits(m) bits in the bitmap.\n+  inline static size_t bits_to_words(idx_t bits);\n+  inline static idx_t  words_to_bits(size_t words);\n+\n+  \/\/ Return word-aligned up range_end, which must not be greater than size().\n+  inline idx_t align_range_end(idx_t range_end) const;\n+\n+  inline HeapWord* region_start() const;\n+  inline HeapWord* region_end() const;\n+  inline size_t    region_size() const;\n+  inline size_t    size() const;\n+\n+#ifdef  ASSERT\n+  inline void verify_bit(idx_t bit) const;\n+  inline void verify_addr(HeapWord* addr) const;\n+#endif  \/\/ #ifdef ASSERT\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.hpp","additions":24,"deletions":30,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -77,4 +77,0 @@\n-inline bool ParMarkBitMap::is_unmarked(idx_t bit) const {\n-  return !is_marked(bit);\n-}\n-\n@@ -121,4 +117,0 @@\n-inline ParMarkBitMap::idx_t ParMarkBitMap::find_obj_beg(idx_t beg, idx_t end) const {\n-  return _beg_bits.find_first_set_bit_aligned_right(beg, end);\n-}\n-\n@@ -129,1 +121,2 @@\n-  const idx_t res_bit = MIN2(find_obj_beg(beg_bit, search_end), end_bit);\n+  const idx_t res_bit = MIN2(_beg_bits.find_first_set_bit_aligned_right(beg_bit, search_end),\n+                             end_bit);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.inline.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"}]}