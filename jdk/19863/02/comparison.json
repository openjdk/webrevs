{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.invoke.InnerClassLambdaMetafactory.MethodBody;\n@@ -42,0 +43,1 @@\n+import java.util.function.Consumer;\n@@ -69,0 +71,2 @@\n+    private static final Consumer<FieldBuilder> STATIC_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_STATIC);\n+    private static final Consumer<FieldBuilder> FINAL_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_FINAL);\n@@ -616,56 +620,61 @@\n-            return ClassFile.of().build(classDesc, clb -> {\n-                clb.withFlags(ACC_FINAL | ACC_SUPER)\n-                   .withSuperclass(superClassDesc)\n-                   .with(SourceFileAttribute.of(classDesc.displayName()))\n-\n-                \/\/ emit static types and BMH_SPECIES fields\n-                   .withField(sdFieldName, CD_SPECIES_DATA, ACC_STATIC);\n-\n-                \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n-                class Var {\n-                    final int index;\n-                    final String name;\n-                    final Class<?> type;\n-                    final ClassDesc desc;\n-                    final BasicType basicType;\n-                    final int slotIndex;\n-                    Var(int index, int slotIndex) {\n-                        this.index = index;\n-                        this.slotIndex = slotIndex;\n-                        name = null; type = null; desc = null;\n-                        basicType = BasicType.V_TYPE;\n-                    }\n-                    Var(String name, Class<?> type, Var prev) {\n-                        int slotIndex = prev.nextSlotIndex();\n-                        int index = prev.nextIndex();\n-                        if (name == null)  name = \"x\";\n-                        if (name.endsWith(\"#\"))\n-                            name = name.substring(0, name.length()-1) + index;\n-                        assert(!type.equals(void.class));\n-                        this.index = index;\n-                        this.name = name;\n-                        this.type = type;\n-                        this.desc = classDesc(type);\n-                        this.basicType = BasicType.basicType(type);\n-                        this.slotIndex = slotIndex;\n-                    }\n-                    Var lastOf(List<Var> vars) {\n-                        int n = vars.size();\n-                        return (n == 0 ? this : vars.get(n-1));\n-                    }\n-                    <X> List<Var> fromTypes(List<X> types) {\n-                        Var prev = this;\n-                        ArrayList<Var> result = new ArrayList<>(types.size());\n-                        int i = 0;\n-                        for (X x : types) {\n-                            String vn = name;\n-                            Class<?> vt;\n-                            if (x instanceof Class<?> cl) {\n-                                vt = cl;\n-                                \/\/ make the names friendlier if debugging\n-                                assert((vn = vn + \"_\" + (i++)) != null);\n-                            } else {\n-                                @SuppressWarnings(\"unchecked\")\n-                                Var v = (Var) x;\n-                                vn = v.name;\n-                                vt = v.type;\n+            return ClassFile.of().build(classDesc, new Consumer<ClassBuilder>() {\n+                @Override\n+                public void accept(ClassBuilder clb) {\n+                    clb.withFlags(ACC_FINAL | ACC_SUPER)\n+                       .withSuperclass(superClassDesc)\n+                       .with(SourceFileAttribute.of(classDesc.displayName()))\n+\n+                    \/\/ emit static types and BMH_SPECIES fields\n+                       .withField(sdFieldName, CD_SPECIES_DATA, STATIC_FIELD_FLAGS);\n+\n+                    \/\/ handy holder for dealing with groups of typed values (ctor arguments and fields)\n+                    class Var {\n+                        final int index;\n+                        final String name;\n+                        final Class<?> type;\n+                        final ClassDesc desc;\n+                        final BasicType basicType;\n+                        final int slotIndex;\n+                        Var(int index, int slotIndex) {\n+                            this.index = index;\n+                            this.slotIndex = slotIndex;\n+                            name = null; type = null; desc = null;\n+                            basicType = BasicType.V_TYPE;\n+                        }\n+                        Var(String name, Class<?> type, Var prev) {\n+                            int slotIndex = prev.nextSlotIndex();\n+                            int index = prev.nextIndex();\n+                            if (name == null)  name = \"x\";\n+                            if (name.endsWith(\"#\"))\n+                                name = name.substring(0, name.length()-1) + index;\n+                            assert(!type.equals(void.class));\n+                            this.index = index;\n+                            this.name = name;\n+                            this.type = type;\n+                            this.desc = classDesc(type);\n+                            this.basicType = BasicType.basicType(type);\n+                            this.slotIndex = slotIndex;\n+                        }\n+                        Var lastOf(List<Var> vars) {\n+                            int n = vars.size();\n+                            return (n == 0 ? this : vars.get(n-1));\n+                        }\n+                        <X> List<Var> fromTypes(List<X> types) {\n+                            Var prev = this;\n+                            ArrayList<Var> result = new ArrayList<>(types.size());\n+                            int i = 0;\n+                            for (X x : types) {\n+                                String vn = name;\n+                                Class<?> vt;\n+                                if (x instanceof Class<?> cl) {\n+                                    vt = cl;\n+                                    \/\/ make the names friendlier if debugging\n+                                    assert((vn = vn + \"_\" + (i++)) != null);\n+                                } else {\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    Var v = (Var) x;\n+                                    vn = v.name;\n+                                    vt = v.type;\n+                                }\n+                                prev = new Var(vn, vt, prev);\n+                                result.add(prev);\n@@ -673,2 +682,1 @@\n-                            prev = new Var(vn, vt, prev);\n-                            result.add(prev);\n+                            return result;\n@@ -676,37 +684,0 @@\n-                        return result;\n-                    }\n-\n-                    int slotSize() { return basicType.basicTypeSlots(); }\n-                    int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n-                    int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n-                    boolean isInHeap() { return slotIndex < 0; }\n-                    void emitLoadInstruction(CodeBuilder cob) {\n-                        cob.loadLocal(basicType.btKind, slotIndex);\n-                    }\n-                }\n-\n-                final Var NO_THIS = new Var(0, 0),\n-                        AFTER_THIS = new Var(0, 1),\n-                        IN_HEAP = new Var(0, -1);\n-\n-                \/\/ figure out the field types\n-                final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n-                final List<Var> fields = new ArrayList<>(fieldTypes.size());\n-                {\n-                    Var nextF = IN_HEAP;\n-                    for (Class<?> ft : fieldTypes) {\n-                        String fn = chooseFieldName(ft, nextF.nextIndex());\n-                        nextF = new Var(fn, ft, nextF);\n-                        fields.add(nextF);\n-                    }\n-                }\n-\n-                \/\/ emit bound argument fields\n-                for (Var field : fields) {\n-                    clb.withField(field.name, field.desc, ACC_FINAL);\n-                }\n-\n-                \/\/ emit implementation of speciesData()\n-                clb.withMethodBody(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n-                        cob -> cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n-                                  .areturn());\n@@ -714,11 +685,7 @@\n-                \/\/ figure out the constructor arguments\n-                MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n-                MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n-\n-                \/\/ emit constructor\n-                clb.withMethodBody(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE, cob -> {\n-                    cob.aload(0); \/\/ this\n-\n-                    final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n-                    for (Var ca : ctorArgs) {\n-                        ca.emitLoadInstruction(cob);\n+                        int slotSize() { return basicType.basicTypeSlots(); }\n+                        int nextIndex() { return index + (slotSize() == 0 ? 0 : 1); }\n+                        int nextSlotIndex() { return slotIndex >= 0 ? slotIndex + slotSize() : slotIndex; }\n+                        boolean isInHeap() { return slotIndex < 0; }\n+                        void emitLoadInstruction(CodeBuilder cob) {\n+                            cob.loadLocal(basicType.btKind, slotIndex);\n+                        }\n@@ -727,11 +694,14 @@\n-                    \/\/ super(ca...)\n-                    cob.invokespecial(superClassDesc, INIT_NAME, methodDesc(superCtorType));\n-\n-                    \/\/ store down fields\n-                    Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n-                    for (Var f : fields) {\n-                        \/\/ this.argL1 = argL1\n-                        cob.aload(0);  \/\/ this\n-                        lastFV = new Var(f.name, f.type, lastFV);\n-                        lastFV.emitLoadInstruction(cob);\n-                        cob.putfield(classDesc, f.name, f.desc);\n+                    final Var NO_THIS = new Var(0, 0),\n+                            AFTER_THIS = new Var(0, 1),\n+                            IN_HEAP = new Var(0, -1);\n+\n+                    \/\/ figure out the field types\n+                    final List<Class<?>> fieldTypes = speciesData.fieldTypes();\n+                    final List<Var> fields = new ArrayList<>(fieldTypes.size());\n+                    {\n+                        Var nextF = IN_HEAP;\n+                        for (Class<?> ft : fieldTypes) {\n+                            String fn = chooseFieldName(ft, nextF.nextIndex());\n+                            nextF = new Var(fn, ft, nextF);\n+                            fields.add(nextF);\n+                        }\n@@ -740,12 +710,3 @@\n-                    cob.return_();\n-                });\n-\n-                \/\/ emit make()  ...factory method wrapping constructor\n-                MethodType ftryType = thisCtorType.changeReturnType(topClass());\n-                clb.withMethodBody(\"make\", methodDesc(ftryType), ACC_STATIC, cob -> {\n-                    \/\/ make instance\n-                    cob.new_(classDesc)\n-                       .dup();\n-                    \/\/ load factory method arguments:  ctarg... and arg...\n-                    for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n-                        v.emitLoadInstruction(cob);\n+                    \/\/ emit bound argument fields\n+                    for (Var field : fields) {\n+                        clb.withField(field.name, field.desc, FINAL_FIELD_FLAGS);\n@@ -754,40 +715,7 @@\n-                    \/\/ finally, invoke the constructor and return\n-                    cob.invokespecial(classDesc, INIT_NAME, methodDesc(thisCtorType))\n-                       .areturn();\n-                });\n-\n-                \/\/ For each transform, emit the customized override of the transform method.\n-                \/\/ This method mixes together some incoming arguments (from the transform's\n-                \/\/ static type signature) with the field types themselves, and passes\n-                \/\/ the resulting mish-mosh of values to a method handle produced by\n-                \/\/ the species itself.  (Typically this method handle is the factory\n-                \/\/ method of this species or a related one.)\n-                for (int i = 0; i < TRANSFORM_NAMES.size(); i++) {\n-                    final int whichtm = i;\n-                    final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n-                    final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n-                    final int        TMODS = TRANSFORM_MODS.get(whichtm);\n-                    clb.withMethod(TNAME, methodDesc(TTYPE), (TMODS & ACC_PPP) | ACC_FINAL, mb -> {\n-                        mb.with(ExceptionsAttribute.ofSymbols(CD_Throwable))\n-                          .withCode(cob -> {\n-                            \/\/ return a call to the corresponding \"transform helper\", something like this:\n-                            \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n-                            cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n-                               .loadConstant(whichtm)\n-                               .invokevirtual(CD_SPECIES_DATA, \"transformHelper\", MTD_TRANFORM_HELPER);\n-\n-                            List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n-                            List<Var> tfields = new ArrayList<>(fields);\n-                            \/\/ mix them up and load them for the transform helper:\n-                            List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n-                            ClassDesc[] helperTypes = new ClassDesc[helperArgs.size()];\n-                            for (int hi = 0; hi < helperTypes.length; hi++) {\n-                                Var ha = helperArgs.get(hi);\n-                                helperTypes[hi] = ha.basicType.basicTypeWrapper().basicClassDescriptor();\n-                                if (ha.isInHeap()) {\n-                                    assert(tfields.contains(ha));\n-                                    cob.aload(0);\n-                                    cob.getfield(classDesc, ha.name, ha.desc);\n-                                } else {\n-                                    assert(targs.contains(ha));\n-                                    ha.emitLoadInstruction(cob);\n+                    \/\/ emit implementation of speciesData()\n+                    clb.withMethod(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                                            .areturn();\n@@ -795,10 +723,108 @@\n-                            }\n-\n-                            \/\/ jump into the helper (which is probably a factory method)\n-                            final Class<?> rtype = TTYPE.returnType();\n-                            if (!rtype.isPrimitive()) {\n-                                cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", MethodTypeDescImpl.ofValidated(CD_Object, helperTypes))\n-                                   .checkcast(classDesc(rtype))\n-                                   .areturn();\n-                            } else {\n-                                throw newInternalError(\"NYI: transform of type \"+rtype);\n+                            }));\n+\n+                    \/\/ figure out the constructor arguments\n+                    MethodType superCtorType = ClassSpecializer.this.baseConstructorType();\n+                    MethodType thisCtorType = superCtorType.appendParameterTypes(fieldTypes);\n+\n+                    \/\/ emit constructor\n+                    clb.withMethod(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    cob.aload(0); \/\/ this\n+\n+                                    final List<Var> ctorArgs = AFTER_THIS.fromTypes(superCtorType.parameterList());\n+                                    for (Var ca : ctorArgs) {\n+                                        ca.emitLoadInstruction(cob);\n+                                    }\n+\n+                                    \/\/ super(ca...)\n+                                    cob.invokespecial(superClassDesc, INIT_NAME, methodDesc(superCtorType));\n+\n+                                    \/\/ store down fields\n+                                    Var lastFV = AFTER_THIS.lastOf(ctorArgs);\n+                                    for (Var f : fields) {\n+                                        \/\/ this.argL1 = argL1\n+                                        cob.aload(0);  \/\/ this\n+                                        lastFV = new Var(f.name, f.type, lastFV);\n+                                        lastFV.emitLoadInstruction(cob);\n+                                        cob.putfield(classDesc, f.name, f.desc);\n+                                    }\n+\n+                                    cob.return_();\n+                                }\n+                            }));\n+\n+                    \/\/ emit make()  ...factory method wrapping constructor\n+                    MethodType ftryType = thisCtorType.changeReturnType(topClass());\n+                    clb.withMethod(\"make\", methodDesc(ftryType), ACC_STATIC,\n+                            new MethodBody(new Consumer<CodeBuilder>() {\n+                                @Override\n+                                public void accept(CodeBuilder cob) {\n+                                    \/\/ make instance\n+                                    cob.new_(classDesc)\n+                                            .dup();\n+                                    \/\/ load factory method arguments:  ctarg... and arg...\n+                                    for (Var v : NO_THIS.fromTypes(ftryType.parameterList())) {\n+                                        v.emitLoadInstruction(cob);\n+                                    }\n+\n+                                    \/\/ finally, invoke the constructor and return\n+                                    cob.invokespecial(classDesc, INIT_NAME, methodDesc(thisCtorType))\n+                                            .areturn();\n+                                }\n+                            }));\n+\n+                    \/\/ For each transform, emit the customized override of the transform method.\n+                    \/\/ This method mixes together some incoming arguments (from the transform's\n+                    \/\/ static type signature) with the field types themselves, and passes\n+                    \/\/ the resulting mish-mosh of values to a method handle produced by\n+                    \/\/ the species itself.  (Typically this method handle is the factory\n+                    \/\/ method of this species or a related one.)\n+                    for (int i = 0; i < TRANSFORM_NAMES.size(); i++) {\n+                        final int whichtm = i;\n+                        final String     TNAME = TRANSFORM_NAMES.get(whichtm);\n+                        final MethodType TTYPE = TRANSFORM_TYPES.get(whichtm);\n+                        final int        TMODS = TRANSFORM_MODS.get(whichtm);\n+                        clb.withMethod(TNAME, methodDesc(TTYPE), (TMODS & ACC_PPP) | ACC_FINAL, new Consumer<MethodBuilder>() {\n+                            @Override\n+                            public void accept(MethodBuilder mb) {\n+                                mb.with(ExceptionsAttribute.ofSymbols(CD_Throwable))\n+                                  .withCode(new Consumer<CodeBuilder>() {\n+                                    @Override\n+                                    public void accept(CodeBuilder cob) {\n+                                        \/\/ return a call to the corresponding \"transform helper\", something like this:\n+                                        \/\/   MY_SPECIES.transformHelper(whichtm).invokeBasic(ctarg, ..., argL0, ..., xarg)\n+                                        cob.getstatic(classDesc, sdFieldName, CD_SPECIES_DATA)\n+                                                .loadConstant(whichtm)\n+                                                .invokevirtual(CD_SPECIES_DATA, \"transformHelper\", MTD_TRANFORM_HELPER);\n+\n+                                        List<Var> targs = AFTER_THIS.fromTypes(TTYPE.parameterList());\n+                                        List<Var> tfields = new ArrayList<>(fields);\n+                                        \/\/ mix them up and load them for the transform helper:\n+                                        List<Var> helperArgs = speciesData.deriveTransformHelperArguments(transformMethods.get(whichtm), whichtm, targs, tfields);\n+                                        ClassDesc[] helperTypes = new ClassDesc[helperArgs.size()];\n+                                        for (int hi = 0; hi < helperTypes.length; hi++) {\n+                                            Var ha = helperArgs.get(hi);\n+                                            helperTypes[hi] = ha.basicType.basicTypeWrapper().basicClassDescriptor();\n+                                            if (ha.isInHeap()) {\n+                                                assert(tfields.contains(ha));\n+                                                cob.aload(0);\n+                                                cob.getfield(classDesc, ha.name, ha.desc);\n+                                            } else {\n+                                                assert(targs.contains(ha));\n+                                                ha.emitLoadInstruction(cob);\n+                                            }\n+                                        }\n+\n+                                        \/\/ jump into the helper (which is probably a factory method)\n+                                        final Class<?> rtype = TTYPE.returnType();\n+                                        if (!rtype.isPrimitive()) {\n+                                            cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", MethodTypeDescImpl.ofValidated(CD_Object, helperTypes))\n+                                                    .checkcast(classDesc(rtype))\n+                                                    .areturn();\n+                                        } else {\n+                                            throw newInternalError(\"NYI: transform of type \"+rtype);\n+                                        }\n+                                    }\n+                                });\n@@ -807,1 +833,1 @@\n-                    });\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":206,"deletions":180,"binary":false,"changes":386,"status":"modified"}]}