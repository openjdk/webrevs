{"files":[{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotGrowableArray.hpp\"\n+#include \"cds\/aotMetaspace.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+void AOTGrowableArrayHelper::deallocate(void* mem) {\n+  if (!AOTMetaspace::in_aot_cache(mem)) {\n+    GrowableArrayCHeapAllocator::deallocate(mem);\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/aotGrowableArray.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_AOT_AOTGROWABLEARRAY_HPP\n+#define SHARE_AOT_AOTGROWABLEARRAY_HPP\n+\n+#include <memory\/metaspaceClosureType.hpp>\n+#include <utilities\/growableArray.hpp>\n+\n+class AOTGrowableArrayHelper {\n+public:\n+  static void deallocate(void* mem);\n+};\n+\n+\/\/ An AOTGrowableArray<T> provides the same functionality as a GrowableArray<T> that\n+\/\/ uses the C heap allocator. In addition, AOTGrowableArray<T> can be iterated with\n+\/\/ MetaspaceClosure. This type should be used for growable arrays that need to be\n+\/\/ stored in the AOT cache. See ModuleEntry::_reads for an example.\n+template <typename E>\n+class AOTGrowableArray : public GrowableArrayWithAllocator<E, AOTGrowableArray<E>> {\n+  friend class VMStructs;\n+  friend class GrowableArrayWithAllocator<E, AOTGrowableArray>;\n+\n+  static E* allocate(int max, MemTag mem_tag) {\n+    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), mem_tag);\n+  }\n+\n+  E* allocate() {\n+    return allocate(this->_capacity, mtClass);\n+  }\n+\n+  void deallocate(E* mem) {\n+#if INCLUDE_CDS\n+    AOTGrowableArrayHelper::deallocate(mem);\n+#else\n+    GrowableArrayCHeapAllocator::deallocate(mem);\n+#endif\n+  }\n+\n+public:\n+  AOTGrowableArray(int initial_capacity, MemTag mem_tag) :\n+      GrowableArrayWithAllocator<E, AOTGrowableArray>(\n+          allocate(initial_capacity, mem_tag),\n+          initial_capacity) {}\n+\n+  AOTGrowableArray() : AOTGrowableArray(0, mtClassShared) {}\n+\n+  \/\/ methods required by MetaspaceClosure\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  int size_in_heapwords() const { return (int)heap_word_size(sizeof(*this)); }\n+  MetaspaceClosureType type() const { return MetaspaceClosureType::GrowableArrayType; }\n+  static bool is_read_only_by_default() { return false; }\n+};\n+\n+#endif \/\/ SHARE_AOT_AOTGROWABLEARRAY_HPP\n","filename":"src\/hotspot\/share\/cds\/aotGrowableArray.hpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTGROWABLEARRAY_INLINE_HPP\n+#define SHARE_CDS_AOTGROWABLEARRAY_INLINE_HPP\n+\n+#include \"cds\/aotGrowableArray.hpp\"\n+\n+#include \"memory\/metaspaceClosure.hpp\"\n+\n+template <typename E>\n+void AOTGrowableArray<E>::metaspace_pointers_do(MetaspaceClosure* it) {\n+  it->push_c_array(AOTGrowableArray<E>::data_addr(), AOTGrowableArray<E>::capacity());\n+}\n+\n+#endif \/\/ SHARE_CDS_AOTGROWABLEARRAY_INLINE_HPP\n","filename":"src\/hotspot\/share\/cds\/aotGrowableArray.inline.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/packageEntry.hpp\"\n@@ -144,1 +146,1 @@\n-      info._type = ref->msotype();\n+      info._type = ref->type();\n@@ -217,1 +219,1 @@\n-      info._type = src_info->msotype();\n+      info._type = src_info->type();\n@@ -335,2 +337,2 @@\n-    MetaspaceObj::Type type = info._type;\n-    const char* type_name = MetaspaceObj::type_name(type);\n+    MetaspaceClosureType type = info._type;\n+    const char* type_name = MetaspaceClosure::type_name(type);\n@@ -341,1 +343,1 @@\n-    case MetaspaceObj::ClassType:\n+    case MetaspaceClosureType::ClassType:\n@@ -344,1 +346,1 @@\n-    case MetaspaceObj::ConstantPoolType:\n+    case MetaspaceClosureType::ConstantPoolType:\n@@ -347,1 +349,1 @@\n-    case MetaspaceObj::ConstantPoolCacheType:\n+    case MetaspaceClosureType::ConstantPoolCacheType:\n@@ -350,1 +352,1 @@\n-    case MetaspaceObj::ConstMethodType:\n+    case MetaspaceClosureType::ConstMethodType:\n@@ -353,1 +355,1 @@\n-    case MetaspaceObj::MethodType:\n+    case MetaspaceClosureType::MethodType:\n@@ -356,1 +358,1 @@\n-    case MetaspaceObj::MethodCountersType:\n+    case MetaspaceClosureType::MethodCountersType:\n@@ -359,1 +361,1 @@\n-    case MetaspaceObj::MethodDataType:\n+    case MetaspaceClosureType::MethodDataType:\n@@ -362,1 +364,10 @@\n-    case MetaspaceObj::SymbolType:\n+    case MetaspaceClosureType::ModuleEntryType:\n+      log_module_entry((ModuleEntry*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceClosureType::PackageEntryType:\n+      log_package_entry((PackageEntry*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceClosureType::GrowableArrayType:\n+      log_growable_array((GrowableArrayBase*)src, requested_addr, type_name, bytes, current);\n+      break;\n+    case MetaspaceClosureType::SymbolType:\n@@ -365,1 +376,1 @@\n-    case MetaspaceObj::KlassTrainingDataType:\n+    case MetaspaceClosureType::KlassTrainingDataType:\n@@ -368,1 +379,1 @@\n-    case MetaspaceObj::MethodTrainingDataType:\n+    case MetaspaceClosureType::MethodTrainingDataType:\n@@ -371,1 +382,1 @@\n-    case MetaspaceObj::CompileTrainingDataType:\n+    case MetaspaceClosureType::CompileTrainingDataType:\n@@ -424,0 +435,21 @@\n+void AOTMapLogger::log_module_entry(ModuleEntry* mod, address requested_addr, const char* type_name,\n+                                   int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s\", p2i(requested_addr), type_name, bytes,\n+                      mod->name_as_C_string());\n+}\n+\n+void AOTMapLogger::log_package_entry(PackageEntry* pkg, address requested_addr, const char* type_name,\n+                                   int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %s - %s\", p2i(requested_addr), type_name, bytes,\n+                      pkg->module()->name_as_C_string(), pkg->name_as_C_string());\n+}\n+\n+void AOTMapLogger::log_growable_array(GrowableArrayBase* arr, address requested_addr, const char* type_name,\n+                                      int bytes, Thread* current) {\n+  ResourceMark rm(current);\n+  log_debug(aot, map)(_LOG_PREFIX \" %d (%d)\", p2i(requested_addr), type_name, bytes,\n+                      arr->length(), arr->capacity());\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.cpp","additions":48,"deletions":16,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"memory\/metaspaceClosureType.hpp\"\n@@ -40,0 +41,1 @@\n+class GrowableArrayBase;\n@@ -41,0 +43,1 @@\n+class MethodCounters;\n@@ -42,0 +45,1 @@\n+class ModuleEntry;\n@@ -43,0 +47,1 @@\n+class PackageEntry;\n@@ -65,1 +70,1 @@\n-    MetaspaceObj::Type _type;\n+    MetaspaceClosureType _type;\n@@ -145,0 +150,3 @@\n+  static void log_module_entry(ModuleEntry* mod, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_package_entry(PackageEntry* pkg, address requested_addr, const char* type_name, int bytes, Thread* current);\n+  static void log_growable_array(GrowableArrayBase* arr, address requested_addr, const char* type_name, int bytes, Thread* current);\n","filename":"src\/hotspot\/share\/cds\/aotMapLogger.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -701,0 +701,3 @@\n+    if (CDSConfig::is_dumping_full_module_graph()) {\n+      ClassLoaderDataShared::iterate_roots(it);\n+    }\n@@ -798,0 +801,4 @@\n+  if (CDSConfig::is_dumping_full_module_graph()) {\n+    ClassLoaderDataShared::remove_unshareable_info();\n+  }\n+\n@@ -1138,0 +1145,1 @@\n+      ClassLoaderDataShared::build_tables(CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,1 +246,1 @@\n-  if (ref->msotype() == MetaspaceObj::ClassType) {\n+  if (ref->type() == MetaspaceClosureType::ClassType) {\n@@ -255,1 +255,1 @@\n-  } else if (ref->msotype() == MetaspaceObj::SymbolType) {\n+  } else if (ref->type() == MetaspaceClosureType::SymbolType) {\n@@ -274,5 +274,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-  if (CDSConfig::is_dumping_full_module_graph()) {\n-    ClassLoaderDataShared::iterate_symbols(&doit);\n-  }\n-#endif\n@@ -449,1 +444,1 @@\n-  if (ref->msotype() == MetaspaceObj::MethodType) {\n+  if (ref->type() == MetaspaceClosureType::MethodType) {\n@@ -456,1 +451,1 @@\n-  if (ref->msotype() == MetaspaceObj::MethodDataType) {\n+  if (ref->type() == MetaspaceClosureType::MethodDataType) {\n@@ -557,5 +552,5 @@\n-  } else if (ref->msotype() == MetaspaceObj::MethodDataType ||\n-             ref->msotype() == MetaspaceObj::MethodCountersType ||\n-             ref->msotype() == MetaspaceObj::KlassTrainingDataType ||\n-             ref->msotype() == MetaspaceObj::MethodTrainingDataType ||\n-             ref->msotype() == MetaspaceObj::CompileTrainingDataType) {\n+  } else if (ref->type() == MetaspaceClosureType::MethodDataType ||\n+             ref->type() == MetaspaceClosureType::MethodCountersType ||\n+             ref->type() == MetaspaceClosureType::KlassTrainingDataType ||\n+             ref->type() == MetaspaceClosureType::MethodTrainingDataType ||\n+             ref->type() == MetaspaceClosureType::CompileTrainingDataType) {\n@@ -563,1 +558,1 @@\n-  } else if (ref->msotype() == MetaspaceObj::AdapterHandlerEntryType) {\n+  } else if (ref->type() == MetaspaceClosureType::AdapterHandlerEntryType) {\n@@ -566,1 +561,1 @@\n-    if (ref->msotype() == MetaspaceObj::ClassType) {\n+    if (ref->type() == MetaspaceClosureType::ClassType) {\n@@ -618,9 +613,0 @@\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  if (CDSConfig::is_dumping_full_module_graph()) {\n-    \/\/ Archive the ModuleEntry's and PackageEntry's of the 3 built-in loaders\n-    char* start = rw_region()->top();\n-    ClassLoaderDataShared::allocate_archived_tables();\n-    alloc_stats()->record_modules(rw_region()->top() - start, \/*read_only*\/false);\n-  }\n-#endif\n@@ -635,9 +621,0 @@\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  if (CDSConfig::is_dumping_full_module_graph()) {\n-    char* start = ro_region()->top();\n-    ClassLoaderDataShared::init_archived_tables();\n-    alloc_stats()->record_modules(ro_region()->top() - start, \/*read_only*\/true);\n-  }\n-#endif\n-\n@@ -661,1 +638,1 @@\n-  if (src_info->msotype() == MetaspaceObj::ClassType) {\n+  if (src_info->type() == MetaspaceClosureType::ClassType) {\n@@ -677,1 +654,1 @@\n-  } else if (src_info->msotype() == MetaspaceObj::SymbolType) {\n+  } else if (src_info->type() == MetaspaceClosureType::SymbolType) {\n@@ -687,1 +664,1 @@\n-  if (CDSConfig::is_dumping_static_archive() && (src_info->msotype() == MetaspaceObj::SymbolType)) {\n+  if (CDSConfig::is_dumping_static_archive() && (src_info->type() == MetaspaceClosureType::SymbolType)) {\n@@ -702,1 +679,1 @@\n-  intptr_t* archived_vtable = CppVtables::get_archived_vtable(src_info->msotype(), (address)dest);\n+  intptr_t* archived_vtable = CppVtables::get_archived_vtable(src_info->type(), (address)dest);\n@@ -712,1 +689,1 @@\n-  _alloc_stats.record(src_info->msotype(), int(newtop - oldtop), src_info->read_only());\n+  _alloc_stats.record(src_info->type(), int(newtop - oldtop), src_info->read_only());\n@@ -997,3 +974,3 @@\n-    if (info.msotype() == MetaspaceObj::KlassTrainingDataType ||\n-        info.msotype() == MetaspaceObj::MethodTrainingDataType ||\n-        info.msotype() == MetaspaceObj::CompileTrainingDataType) {\n+    if (info.type() == MetaspaceClosureType::KlassTrainingDataType ||\n+        info.type() == MetaspaceClosureType::MethodTrainingDataType ||\n+        info.type() == MetaspaceClosureType::CompileTrainingDataType) {\n@@ -1002,1 +979,1 @@\n-    } else if (info.msotype() == MetaspaceObj::MethodDataType) {\n+    } else if (info.type() == MetaspaceClosureType::MethodDataType) {\n@@ -1005,1 +982,1 @@\n-    } else if (info.msotype() == MetaspaceObj::MethodCountersType) {\n+    } else if (info.type() == MetaspaceClosureType::MethodCountersType) {\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":22,"deletions":45,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-    MetaspaceObj::Type _msotype;\n+    MetaspaceClosureType _type;\n@@ -143,1 +143,1 @@\n-      _size_in_bytes(ref->size() * BytesPerWord), _id(0), _msotype(ref->msotype()),\n+      _size_in_bytes(ref->size() * BytesPerWord), _id(0), _type(ref->type()),\n@@ -158,1 +158,1 @@\n-      _size_in_bytes(0), _msotype(renegerated_obj_info->_msotype),\n+      _size_in_bytes(0), _type(renegerated_obj_info->_type),\n@@ -185,1 +185,1 @@\n-    MetaspaceObj::Type msotype() const { return _msotype; }\n+    MetaspaceClosureType type() const { return _type; }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"cds\/aotGrowableArray.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -56,0 +58,13 @@\n+\n+#ifndef PRODUCT\n+\n+\/\/ AOTGrowableArray has a vtable only when in non-product builds (due to\n+\/\/ the virtual printing functions in AnyObj).\n+\n+using GrowableArray_ModuleEntry_ptr = AOTGrowableArray<ModuleEntry*>;\n+\n+#define DEBUG_CPP_VTABLE_TYPES_DO(f) \\\n+  f(GrowableArray_ModuleEntry_ptr) \\\n+\n+#endif\n+\n@@ -71,1 +86,2 @@\n-  f(CompileTrainingData)\n+  f(CompileTrainingData) \\\n+  NOT_PRODUCT(DEBUG_CPP_VTABLE_TYPES_DO(f))\n@@ -89,1 +105,1 @@\n-static inline intptr_t* vtable_of(const Metadata* m) {\n+static inline intptr_t* vtable_of(const void* m) {\n@@ -119,0 +135,1 @@\n+  ResourceMark rm;\n@@ -271,1 +288,1 @@\n-intptr_t* CppVtables::get_archived_vtable(MetaspaceObj::Type msotype, address obj) {\n+intptr_t* CppVtables::get_archived_vtable(MetaspaceClosureType type, address obj) {\n@@ -279,13 +296,17 @@\n-  switch (msotype) {\n-  case MetaspaceObj::SymbolType:\n-  case MetaspaceObj::TypeArrayU1Type:\n-  case MetaspaceObj::TypeArrayU2Type:\n-  case MetaspaceObj::TypeArrayU4Type:\n-  case MetaspaceObj::TypeArrayU8Type:\n-  case MetaspaceObj::TypeArrayOtherType:\n-  case MetaspaceObj::ConstMethodType:\n-  case MetaspaceObj::ConstantPoolCacheType:\n-  case MetaspaceObj::AnnotationsType:\n-  case MetaspaceObj::RecordComponentType:\n-  case MetaspaceObj::AdapterHandlerEntryType:\n-  case MetaspaceObj::AdapterFingerPrintType:\n+  switch (type) {\n+  case MetaspaceClosureType::SymbolType:\n+  case MetaspaceClosureType::TypeArrayU1Type:\n+  case MetaspaceClosureType::TypeArrayU2Type:\n+  case MetaspaceClosureType::TypeArrayU4Type:\n+  case MetaspaceClosureType::TypeArrayU8Type:\n+  case MetaspaceClosureType::TypeArrayOtherType:\n+  case MetaspaceClosureType::CArrayType:\n+  case MetaspaceClosureType::ConstMethodType:\n+  case MetaspaceClosureType::ConstantPoolCacheType:\n+  case MetaspaceClosureType::AnnotationsType:\n+  case MetaspaceClosureType::ModuleEntryType:\n+  case MetaspaceClosureType::PackageEntryType:\n+  case MetaspaceClosureType::RecordComponentType:\n+  case MetaspaceClosureType::AdapterHandlerEntryType:\n+  case MetaspaceClosureType::AdapterFingerPrintType:\n+  PRODUCT_ONLY(case MetaspaceClosureType::GrowableArrayType:)\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":38,"deletions":17,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"memory\/metaspaceClosureType.hpp\"\n@@ -43,1 +44,1 @@\n-  static intptr_t* get_archived_vtable(MetaspaceObj::Type msotype, address obj);\n+  static intptr_t* get_archived_vtable(MetaspaceClosureType type, address obj);\n","filename":"src\/hotspot\/share\/cds\/cppVtables.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"memory\/metaspaceClosureType.hpp\"\n@@ -36,3 +37,2 @@\n-  \/\/ Here's poor man's enum inheritance\n-#define SHAREDSPACE_OBJ_TYPES_DO(f) \\\n-  METASPACE_OBJ_TYPES_DO(f) \\\n+#define DUMPED_OBJ_TYPES_DO(f) \\\n+  METASPACE_CLOSURE_TYPES_DO(f) \\\n@@ -43,1 +43,0 @@\n-  f(ModulesNatives) \\\n@@ -47,0 +46,3 @@\n+#define DUMPED_TYPE_DECLARE(name) name ## Type,\n+#define DUMPED_TYPE_NAME_CASE(name) case name ## Type: return #name;\n+\n@@ -49,1 +51,1 @@\n-    SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_DECLARE)\n+    DUMPED_OBJ_TYPES_DO(DUMPED_TYPE_DECLARE)\n@@ -55,1 +57,1 @@\n-    SHAREDSPACE_OBJ_TYPES_DO(METASPACE_OBJ_TYPE_NAME_CASE)\n+    DUMPED_OBJ_TYPES_DO(DUMPED_TYPE_NAME_CASE)\n@@ -104,8 +106,3 @@\n-  void record(MetaspaceObj::Type type, int byte_size, bool read_only) {\n-    assert(int(type) >= 0 && type < MetaspaceObj::_number_of_types, \"sanity\");\n-    int which = (read_only) ? RO : RW;\n-    _counts[which][type] ++;\n-    _bytes [which][type] += byte_size;\n-  }\n-\n-  void record_modules(int byte_size, bool read_only) {\n+  void record(MetaspaceClosureType type, int byte_size, bool read_only) {\n+    int t = (int)type;\n+    assert(t >= 0 && t < (int)MetaspaceClosureType::_number_of_types, \"sanity\");\n@@ -113,1 +110,2 @@\n-    _bytes [which][ModulesNativesType] += byte_size;\n+    _counts[which][t] ++;\n+    _bytes [which][t] += byte_size;\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":14,"deletions":16,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -951,4 +951,0 @@\n-\n-  if (CDSConfig::is_dumping_full_module_graph()) {\n-    Modules::verify_archived_modules();\n-  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"memory\/metaspaceClosure.hpp\"\n@@ -59,3 +60,3 @@\n-  void iterate_symbols(ClassLoaderData* loader_data, MetaspaceClosure* closure);\n-  void allocate(ClassLoaderData* loader_data);\n-  void init_archived_entries(ClassLoaderData* loader_data);\n+  void iterate_roots(MetaspaceClosure* closure);\n+  void build_tables(ClassLoaderData* loader_data, TRAPS);\n+  void remove_unshareable_info();\n@@ -83,1 +84,1 @@\n-void ArchivedClassLoaderData::iterate_symbols(ClassLoaderData* loader_data, MetaspaceClosure* closure) {\n+void ArchivedClassLoaderData::iterate_roots(MetaspaceClosure* it) {\n@@ -85,6 +86,3 @@\n-  assert_valid(loader_data);\n-  if (loader_data != nullptr) {\n-    loader_data->packages()->iterate_symbols(closure);\n-    loader_data->modules() ->iterate_symbols(closure);\n-    loader_data->unnamed_module()->iterate_symbols(closure);\n-  }\n+  it->push(&_packages);\n+  it->push(&_modules);\n+  it->push(&_unnamed_module);\n@@ -93,1 +91,1 @@\n-void ArchivedClassLoaderData::allocate(ClassLoaderData* loader_data) {\n+void ArchivedClassLoaderData::build_tables(ClassLoaderData* loader_data, TRAPS) {\n@@ -101,3 +99,3 @@\n-    _packages = loader_data->packages()->allocate_archived_entries();\n-    _modules  = loader_data->modules() ->allocate_archived_entries();\n-    _unnamed_module = loader_data->unnamed_module()->allocate_archived_entry();\n+    _packages = loader_data->packages()->build_aot_table(loader_data, CHECK);\n+    _modules  = loader_data->modules()->build_aot_table(loader_data, CHECK);\n+    _unnamed_module = loader_data->unnamed_module();\n@@ -107,7 +105,16 @@\n-void ArchivedClassLoaderData::init_archived_entries(ClassLoaderData* loader_data) {\n-  assert(CDSConfig::is_dumping_full_module_graph(), \"must be\");\n-  assert_valid(loader_data);\n-  if (loader_data != nullptr) {\n-    loader_data->packages()->init_archived_entries(_packages);\n-    loader_data->modules() ->init_archived_entries(_modules);\n-    _unnamed_module->init_as_archived_entry();\n+void ArchivedClassLoaderData::remove_unshareable_info() {\n+  if (_packages != nullptr) {\n+    _packages = ArchiveBuilder::current()->get_buffered_addr(_packages);\n+    for (int i = 0; i < _packages->length(); i++) {\n+      _packages->at(i)->remove_unshareable_info();\n+    }\n+  }\n+  if (_modules != nullptr) {\n+    _modules = ArchiveBuilder::current()->get_buffered_addr(_modules);\n+    for (int i = 0; i < _modules->length(); i++) {\n+      _modules->at(i)->remove_unshareable_info();\n+    }\n+  }\n+  if (_unnamed_module != nullptr) {\n+    _unnamed_module = ArchiveBuilder::current()->get_buffered_addr(_unnamed_module);\n+    _unnamed_module->remove_unshareable_info();\n@@ -156,1 +163,0 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n@@ -181,1 +187,0 @@\n-#endif\n@@ -213,1 +218,1 @@\n-void ClassLoaderDataShared::iterate_symbols(MetaspaceClosure* closure) {\n+void ClassLoaderDataShared::build_tables(TRAPS) {\n@@ -215,3 +220,3 @@\n-  _archived_boot_loader_data.iterate_symbols    (null_class_loader_data(), closure);\n-  _archived_platform_loader_data.iterate_symbols(java_platform_loader_data_or_null(), closure);\n-  _archived_system_loader_data.iterate_symbols  (java_system_loader_data_or_null(), closure);\n+  _archived_boot_loader_data.build_tables(null_class_loader_data(), CHECK);\n+  _archived_platform_loader_data.build_tables(java_platform_loader_data_or_null(), CHECK);\n+  _archived_system_loader_data.build_tables(java_system_loader_data_or_null(), CHECK);\n@@ -220,1 +225,1 @@\n-void ClassLoaderDataShared::allocate_archived_tables() {\n+void ClassLoaderDataShared::iterate_roots(MetaspaceClosure* it) {\n@@ -222,3 +227,3 @@\n-  _archived_boot_loader_data.allocate    (null_class_loader_data());\n-  _archived_platform_loader_data.allocate(java_platform_loader_data_or_null());\n-  _archived_system_loader_data.allocate  (java_system_loader_data_or_null());\n+  _archived_boot_loader_data.iterate_roots(it);\n+  _archived_platform_loader_data.iterate_roots(it);\n+  _archived_system_loader_data.iterate_roots(it);\n@@ -227,1 +232,1 @@\n-void ClassLoaderDataShared::init_archived_tables() {\n+void ClassLoaderDataShared::remove_unshareable_info() {\n@@ -229,0 +234,3 @@\n+  _archived_boot_loader_data.remove_unshareable_info();\n+  _archived_platform_loader_data.remove_unshareable_info();\n+  _archived_system_loader_data.remove_unshareable_info();\n@@ -230,5 +238,1 @@\n-  _archived_boot_loader_data.init_archived_entries    (null_class_loader_data());\n-  _archived_platform_loader_data.init_archived_entries(java_platform_loader_data_or_null());\n-  _archived_system_loader_data.init_archived_entries  (java_system_loader_data_or_null());\n-\n-  _archived_javabase_moduleEntry = ModuleEntry::get_archived_entry(ModuleEntryTable::javabase_moduleEntry());\n+  _archived_javabase_moduleEntry = ArchiveBuilder::current()->get_buffered_addr(ModuleEntryTable::javabase_moduleEntry());\n@@ -274,1 +278,0 @@\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":42,"deletions":39,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,3 @@\n+  static void build_tables(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void iterate_roots(MetaspaceClosure* closure) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void remove_unshareable_info() NOT_CDS_JAVA_HEAP_RETURN;\n@@ -45,3 +48,0 @@\n-  static void allocate_archived_tables();\n-  static void iterate_symbols(MetaspaceClosure* closure);\n-  static void init_archived_tables();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/aotGrowableArray.inline.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"memory\/metadataFactory.hpp\"\n@@ -47,1 +49,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -170,1 +171,1 @@\n-      GrowableArray<ModuleEntry*>* new_reads = new (mtModule) GrowableArray<ModuleEntry*>(MODULE_READS_SIZE, mtModule);\n+      AOTGrowableArray<ModuleEntry*>* new_reads = new (mtModule) AOTGrowableArray<ModuleEntry*>(MODULE_READS_SIZE, mtModule);\n@@ -277,2 +278,1 @@\n-    _is_patched(false)\n-    DEBUG_ONLY(COMMA _reads_is_archived(false)) {\n+    _is_patched(false) {\n@@ -397,1 +397,0 @@\n-\n@@ -405,12 +404,6 @@\n-#if INCLUDE_CDS_JAVA_HEAP\n-typedef HashTable<\n-  const ModuleEntry*,\n-  ModuleEntry*,\n-  557, \/\/ prime number\n-  AnyObj::C_HEAP> ArchivedModuleEntries;\n-static ArchivedModuleEntries* _archive_modules_entries = nullptr;\n-\n-#ifndef PRODUCT\n-static int _num_archived_module_entries = 0;\n-static int _num_inited_module_entries = 0;\n-#endif\n+void ModuleEntry::metaspace_pointers_do(MetaspaceClosure* it) {\n+  it->push(&_name);\n+  it->push(&_reads);\n+  it->push(&_version);\n+  it->push(&_location);\n+}\n@@ -418,0 +411,1 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n@@ -422,5 +416,2 @@\n-ModuleEntry* ModuleEntry::allocate_archived_entry() const {\n-  precond(should_be_archived());\n-  precond(CDSConfig::is_dumping_full_module_graph());\n-  ModuleEntry* archived_entry = (ModuleEntry*)ArchiveBuilder::rw_region_alloc(sizeof(ModuleEntry));\n-  memcpy((void*)archived_entry, (void*)this, sizeof(ModuleEntry));\n+void ModuleEntry::remove_unshareable_info() {\n+  _archived_module_index = HeapShared::append_root(module_oop());\n@@ -428,3 +419,2 @@\n-  archived_entry->_archived_module_index = HeapShared::append_root(module_oop());\n-  if (_archive_modules_entries == nullptr) {\n-    _archive_modules_entries = new (mtClass)ArchivedModuleEntries();\n+  if (_reads != nullptr) {\n+    _reads->set_in_aot_cache();\n@@ -432,3 +422,0 @@\n-  assert(_archive_modules_entries->get(this) == nullptr, \"Each ModuleEntry must not be shared across ModuleEntryTables\");\n-  _archive_modules_entries->put(this, archived_entry);\n-  DEBUG_ONLY(_num_archived_module_entries++);\n@@ -436,0 +423,1 @@\n+  \/\/ Clear handles and restore at run time. Handles cannot be archived.\n@@ -438,1 +426,1 @@\n-    archived_entry->_shared_pd = null_handle;\n+    _shared_pd = null_handle;\n@@ -440,1 +428,1 @@\n-    assert(archived_entry->shared_protection_domain() == nullptr, \"never set during -Xshare:dump\");\n+    assert(shared_protection_domain() == nullptr, \"never set during -Xshare:dump\");\n@@ -443,1 +431,0 @@\n-  \/\/ Clear handles and restore at run time. Handles cannot be archived.\n@@ -445,65 +432,1 @@\n-  archived_entry->_module_handle = null_handle;\n-\n-  \/\/ For verify_archived_module_entries()\n-  DEBUG_ONLY(_num_inited_module_entries++);\n-\n-  if (log_is_enabled(Info, aot, module)) {\n-    ResourceMark rm;\n-    LogStream ls(Log(aot, module)::info());\n-    ls.print(\"Stored in archive: \");\n-    archived_entry->print(&ls);\n-  }\n-  return archived_entry;\n-}\n-\n-bool ModuleEntry::has_been_archived() {\n-  assert(!ArchiveBuilder::current()->is_in_buffer_space(this), \"must be called on original ModuleEntry\");\n-  return _archive_modules_entries->contains(this);\n-}\n-\n-ModuleEntry* ModuleEntry::get_archived_entry(ModuleEntry* orig_entry) {\n-  ModuleEntry** ptr = _archive_modules_entries->get(orig_entry);\n-  assert(ptr != nullptr && *ptr != nullptr, \"must have been allocated\");\n-  return *ptr;\n-}\n-\n-\/\/ This function is used to archive ModuleEntry::_reads and PackageEntry::_qualified_exports.\n-\/\/ GrowableArray cannot be directly archived, as it needs to be expandable at runtime.\n-\/\/ Write it out as an Array, and convert it back to GrowableArray at runtime.\n-Array<ModuleEntry*>* ModuleEntry::write_growable_array(GrowableArray<ModuleEntry*>* array) {\n-  Array<ModuleEntry*>* archived_array = nullptr;\n-  int length = (array == nullptr) ? 0 : array->length();\n-  if (length > 0) {\n-    archived_array = ArchiveBuilder::new_ro_array<ModuleEntry*>(length);\n-    for (int i = 0; i < length; i++) {\n-      ModuleEntry* archived_entry = get_archived_entry(array->at(i));\n-      archived_array->at_put(i, archived_entry);\n-      ArchivePtrMarker::mark_pointer((address*)archived_array->adr_at(i));\n-    }\n-  }\n-\n-  return archived_array;\n-}\n-\n-GrowableArray<ModuleEntry*>* ModuleEntry::restore_growable_array(Array<ModuleEntry*>* archived_array) {\n-  GrowableArray<ModuleEntry*>* array = nullptr;\n-  int length = (archived_array == nullptr) ? 0 : archived_array->length();\n-  if (length > 0) {\n-    array = new (mtModule) GrowableArray<ModuleEntry*>(length, mtModule);\n-    for (int i = 0; i < length; i++) {\n-      ModuleEntry* archived_entry = archived_array->at(i);\n-      array->append(archived_entry);\n-    }\n-  }\n-\n-  return array;\n-}\n-\n-void ModuleEntry::iterate_symbols(MetaspaceClosure* closure) {\n-  closure->push(&_name);\n-  closure->push(&_version);\n-  closure->push(&_location);\n-}\n-\n-void ModuleEntry::init_as_archived_entry() {\n-  set_archived_reads(write_growable_array(reads()));\n+  _module_handle = null_handle;\n@@ -513,3 +436,2 @@\n-    _shared_path_index = AOTClassLocationConfig::dumptime()->get_module_shared_path_index(_location);\n-    _name = ArchiveBuilder::get_buffered_symbol(_name);\n-    ArchivePtrMarker::mark_pointer((address*)&_name);\n+    Symbol* src_location = ArchiveBuilder::current()->get_source_addr(_location);\n+    _shared_path_index = AOTClassLocationConfig::dumptime()->get_module_shared_path_index(src_location);\n@@ -521,6 +443,0 @@\n-  if (_version != nullptr) {\n-    _version = ArchiveBuilder::get_buffered_symbol(_version);\n-  }\n-  if (_location != nullptr) {\n-    _location = ArchiveBuilder::get_buffered_symbol(_location);\n-  }\n@@ -528,4 +444,0 @@\n-\n-  ArchivePtrMarker::mark_pointer((address*)&_reads);\n-  ArchivePtrMarker::mark_pointer((address*)&_version);\n-  ArchivePtrMarker::mark_pointer((address*)&_location);\n@@ -534,8 +446,0 @@\n-#ifndef PRODUCT\n-void ModuleEntry::verify_archived_module_entries() {\n-  assert(_num_archived_module_entries == _num_inited_module_entries,\n-         \"%d ModuleEntries have been archived but %d of them have been properly initialized with archived java.lang.Module objects\",\n-         _num_archived_module_entries, _num_inited_module_entries);\n-}\n-#endif \/\/ PRODUCT\n-\n@@ -545,1 +449,0 @@\n-  set_reads(restore_growable_array(archived_reads()));\n@@ -584,9 +487,3 @@\n-void ModuleEntryTable::iterate_symbols(MetaspaceClosure* closure) {\n-  auto syms = [&] (const SymbolHandle& key, ModuleEntry*& m) {\n-      m->iterate_symbols(closure);\n-  };\n-  _table.iterate_all(syms);\n-}\n-\n-Array<ModuleEntry*>* ModuleEntryTable::allocate_archived_entries() {\n-  Array<ModuleEntry*>* archived_modules = ArchiveBuilder::new_rw_array<ModuleEntry*>(_table.number_of_entries());\n+Array<ModuleEntry*>* ModuleEntryTable::build_aot_table(ClassLoaderData* loader_data, TRAPS) {\n+  Array<ModuleEntry*>* aot_table =\n+    MetadataFactory::new_array<ModuleEntry*>(loader_data, _table.number_of_entries(), nullptr, CHECK_NULL);\n@@ -595,1 +492,8 @@\n-    archived_modules->at_put(n++, m);\n+    m->pack_reads();\n+    aot_table->at_put(n++, m);\n+    if (log_is_enabled(Info, aot, module)) {\n+      ResourceMark rm;\n+      LogStream ls(Log(aot, module)::info());\n+      ls.print(\"Stored in archive: \");\n+      m->print(&ls);\n+    }\n@@ -601,1 +505,1 @@\n-    QuickSort::sort(archived_modules->data(), n, compare_module_by_name);\n+    QuickSort::sort(aot_table->data(), n, compare_module_by_name);\n@@ -603,6 +507,0 @@\n-  for (int i = 0; i < n; i++) {\n-    archived_modules->at_put(i, archived_modules->at(i)->allocate_archived_entry());\n-    ArchivePtrMarker::mark_pointer((address*)archived_modules->adr_at(i));\n-  }\n-  return archived_modules;\n-}\n@@ -610,6 +508,1 @@\n-void ModuleEntryTable::init_archived_entries(Array<ModuleEntry*>* archived_modules) {\n-  assert(CDSConfig::is_dumping_full_module_graph(), \"sanity\");\n-  for (int i = 0; i < archived_modules->length(); i++) {\n-    ModuleEntry* archived_entry = archived_modules->at(i);\n-    archived_entry->init_as_archived_entry();\n-  }\n+  return aot_table;\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":35,"deletions":142,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cds\/aotGrowableArray.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"memory\/metaspaceClosureType.hpp\"\n@@ -71,0 +73,1 @@\n+  AOTGrowableArray<ModuleEntry*>* _reads;  \/\/ list of modules that are readable by this module\n@@ -72,4 +75,0 @@\n-  union {\n-    GrowableArray<ModuleEntry*>* _reads;  \/\/ list of modules that are readable by this module\n-    Array<ModuleEntry*>* _archived_reads; \/\/ List of readable modules stored in the CDS archive\n-  };\n@@ -84,1 +83,0 @@\n-  DEBUG_ONLY(bool _reads_is_archived);\n@@ -123,2 +121,1 @@\n-  GrowableArray<ModuleEntry*>* reads() const {\n-    assert(!_reads_is_archived, \"sanity\");\n+  AOTGrowableArray<ModuleEntry*>* reads() const {\n@@ -127,1 +124,1 @@\n-  void set_reads(GrowableArray<ModuleEntry*>* r) {\n+  void set_reads(AOTGrowableArray<ModuleEntry*>* r) {\n@@ -129,1 +126,0 @@\n-    DEBUG_ONLY(_reads_is_archived = false);\n@@ -131,7 +127,4 @@\n-  Array<ModuleEntry*>* archived_reads() const {\n-    assert(_reads_is_archived, \"sanity\");\n-    return _archived_reads;\n-  }\n-  void set_archived_reads(Array<ModuleEntry*>* r) {\n-    _archived_reads = r;\n-    DEBUG_ONLY(_reads_is_archived = true);\n+  void pack_reads() {\n+    if (_reads != nullptr) {\n+      _reads->shrink_to_fit();\n+    }\n@@ -139,0 +132,1 @@\n+\n@@ -192,0 +186,7 @@\n+\n+  \/\/ methods required by MetaspaceClosure\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  int size_in_heapwords() const { return (int)heap_word_size(sizeof(ModuleEntry)); }\n+  MetaspaceClosureType type() const { return MetaspaceClosureType::ModuleEntryType; }\n+  static bool is_read_only_by_default() { return false; }\n+\n@@ -201,7 +202,1 @@\n-  void iterate_symbols(MetaspaceClosure* closure);\n-  ModuleEntry* allocate_archived_entry() const;\n-  void init_as_archived_entry();\n-  static ModuleEntry* get_archived_entry(ModuleEntry* orig_entry);\n-  bool has_been_archived();\n-  static Array<ModuleEntry*>* write_growable_array(GrowableArray<ModuleEntry*>* array);\n-  static GrowableArray<ModuleEntry*>* restore_growable_array(Array<ModuleEntry*>* archived_array);\n+  void remove_unshareable_info();\n@@ -212,1 +207,0 @@\n-  static void verify_archived_module_entries() PRODUCT_RETURN;\n@@ -278,3 +272,1 @@\n-  void iterate_symbols(MetaspaceClosure* closure);\n-  Array<ModuleEntry*>* allocate_archived_entries();\n-  void init_archived_entries(Array<ModuleEntry*>* archived_modules);\n+  Array<ModuleEntry*>* build_aot_table(ClassLoaderData* loader_data, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":20,"deletions":28,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -508,4 +508,2 @@\n-    if (orig_module_ent->name() != nullptr) {\n-      \/\/ For each named module, we archive both the java.lang.Module oop and the ModuleEntry.\n-      assert(orig_module_ent->has_been_archived(), \"sanity\");\n-    } else {\n+    precond(ArchiveBuilder::current()->has_been_archived(orig_module_ent));\n+    if (orig_module_ent->name() == nullptr) {\n@@ -514,1 +512,0 @@\n-      precond(orig_module_ent->has_been_archived());\n@@ -532,4 +529,0 @@\n-void Modules::verify_archived_modules() {\n-  ModuleEntry::verify_archived_module_entries();\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-  static void verify_archived_modules() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+#include \"cds\/aotGrowableArray.inline.hpp\"\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -34,0 +36,1 @@\n+#include \"memory\/metadataFactory.hpp\"\n@@ -40,1 +43,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -54,1 +56,1 @@\n-  \/\/ name can't be null\n+  \/\/ name can't be null -- a class in the default package gets a PackageEntry of nullptr.\n@@ -84,1 +86,1 @@\n-    _qualified_exports = new (mtModule) GrowableArray<ModuleEntry*>(QUAL_EXP_SIZE, mtModule);\n+    _qualified_exports = new (mtModule) AOTGrowableArray<ModuleEntry*>(QUAL_EXP_SIZE, mtModule);\n@@ -186,1 +188,1 @@\n-  if (_qualified_exports != nullptr) {\n+  if (_qualified_exports != nullptr && !AOTMetaspace::in_aot_cache(_qualified_exports)) {\n@@ -192,0 +194,12 @@\n+void PackageEntry::pack_qualified_exports() {\n+  if (_qualified_exports != nullptr) {\n+    _qualified_exports->shrink_to_fit();\n+  }\n+}\n+\n+void PackageEntry::metaspace_pointers_do(MetaspaceClosure* it) {\n+  it->push(&_name);\n+  it->push(&_module);\n+  it->push(&_qualified_exports);\n+}\n+\n@@ -215,7 +229,0 @@\n-typedef HashTable<\n-  const PackageEntry*,\n-  PackageEntry*,\n-  557, \/\/ prime number\n-  AnyObj::C_HEAP> ArchivedPackageEntries;\n-static ArchivedPackageEntries* _archived_packages_entries = nullptr;\n-\n@@ -226,20 +233,3 @@\n-PackageEntry* PackageEntry::allocate_archived_entry() const {\n-  precond(should_be_archived());\n-  PackageEntry* archived_entry = (PackageEntry*)ArchiveBuilder::rw_region_alloc(sizeof(PackageEntry));\n-  memcpy((void*)archived_entry, (void*)this, sizeof(PackageEntry));\n-\n-  if (_archived_packages_entries == nullptr) {\n-    _archived_packages_entries = new (mtClass)ArchivedPackageEntries();\n-  }\n-  assert(_archived_packages_entries->get(this) == nullptr, \"Each PackageEntry must not be shared across PackageEntryTables\");\n-  _archived_packages_entries->put(this, archived_entry);\n-\n-  return archived_entry;\n-}\n-\n-PackageEntry* PackageEntry::get_archived_entry(PackageEntry* orig_entry) {\n-  PackageEntry** ptr = _archived_packages_entries->get(orig_entry);\n-  if (ptr != nullptr) {\n-    return *ptr;\n-  } else {\n-    return nullptr;\n+void PackageEntry::remove_unshareable_info() {\n+  if (_qualified_exports != nullptr) {\n+    _qualified_exports->set_in_aot_cache();\n@@ -247,12 +237,0 @@\n-}\n-\n-void PackageEntry::iterate_symbols(MetaspaceClosure* closure) {\n-  closure->push(&_name);\n-}\n-\n-void PackageEntry::init_as_archived_entry() {\n-  Array<ModuleEntry*>* archived_qualified_exports = ModuleEntry::write_growable_array(_qualified_exports);\n-\n-  _name = ArchiveBuilder::get_buffered_symbol(_name);\n-  _module = ModuleEntry::get_archived_entry(_module);\n-  _qualified_exports = (GrowableArray<ModuleEntry*>*)archived_qualified_exports;\n@@ -261,10 +239,0 @@\n-\n-  ArchivePtrMarker::mark_pointer((address*)&_name);\n-  ArchivePtrMarker::mark_pointer((address*)&_module);\n-  ArchivePtrMarker::mark_pointer((address*)&_qualified_exports);\n-\n-  LogStreamHandle(Info, aot, package) st;\n-  if (st.is_enabled()) {\n-    st.print(\"archived \");\n-    print(&st);\n-  }\n@@ -274,1 +242,0 @@\n-  _qualified_exports = ModuleEntry::restore_growable_array((Array<ModuleEntry*>*)_qualified_exports);\n@@ -283,8 +250,1 @@\n-void PackageEntryTable::iterate_symbols(MetaspaceClosure* closure) {\n-  auto syms = [&] (const SymbolHandle& key, PackageEntry*& p) {\n-      p->iterate_symbols(closure);\n-  };\n-  _table.iterate_all(syms);\n-}\n-\n-Array<PackageEntry*>* PackageEntryTable::allocate_archived_entries() {\n+Array<PackageEntry*>* PackageEntryTable::build_aot_table(ClassLoaderData* loader_data, TRAPS) {\n@@ -300,1 +260,1 @@\n-  Array<PackageEntry*>* archived_packages = ArchiveBuilder::new_rw_array<PackageEntry*>(n);\n+  Array<PackageEntry*>* archived_packages = MetadataFactory::new_array<PackageEntry*>(loader_data, n, nullptr, CHECK_NULL);\n@@ -305,0 +265,1 @@\n+      p->pack_qualified_exports();\n@@ -306,0 +267,6 @@\n+\n+      LogStreamHandle(Info, aot, package) st;\n+      if (st.is_enabled()) {\n+        st.print(\"archived \");\n+        p->print(&st);\n+      }\n@@ -314,6 +281,0 @@\n-  for (int i = 0; i < n; i++) {\n-    archived_packages->at_put(i, archived_packages->at(i)->allocate_archived_entry());\n-    ArchivePtrMarker::mark_pointer((address*)archived_packages->adr_at(i));\n-  }\n-  return archived_packages;\n-}\n@@ -321,5 +282,1 @@\n-void PackageEntryTable::init_archived_entries(Array<PackageEntry*>* archived_packages) {\n-  for (int i = 0; i < archived_packages->length(); i++) {\n-    PackageEntry* archived_entry = archived_packages->at(i);\n-    archived_entry->init_as_archived_entry();\n-  }\n+  return archived_packages;\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":32,"deletions":75,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cds\/aotGrowableArray.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"memory\/metaspaceClosureType.hpp\"\n@@ -117,1 +119,1 @@\n-  GrowableArray<ModuleEntry*>* _qualified_exports;\n+  AOTGrowableArray<ModuleEntry*>* _qualified_exports;\n@@ -208,0 +210,8 @@\n+  void pack_qualified_exports(); \/\/ used by AOT\n+\n+  \/\/ methods required by MetaspaceClosure\n+  void metaspace_pointers_do(MetaspaceClosure* it);\n+  int size_in_heapwords() const { return (int)heap_word_size(sizeof(PackageEntry)); }\n+  MetaspaceClosureType type() const { return MetaspaceClosureType::PackageEntryType; }\n+  static bool is_read_only_by_default() { return false; }\n+\n@@ -210,0 +220,5 @@\n+  char* name_as_C_string() const {\n+    assert(_name != nullptr, \"name can't be null\");\n+    return name()->as_C_string();\n+  }\n+\n@@ -212,4 +227,1 @@\n-  void iterate_symbols(MetaspaceClosure* closure);\n-  PackageEntry* allocate_archived_entry() const;\n-  void init_as_archived_entry();\n-  static PackageEntry* get_archived_entry(PackageEntry* orig_entry);\n+  void remove_unshareable_info();\n@@ -274,3 +286,1 @@\n-  void iterate_symbols(MetaspaceClosure* closure);\n-  Array<PackageEntry*>* allocate_archived_entries();\n-  void init_archived_entries(Array<PackageEntry*>* archived_packages);\n+  Array<PackageEntry*>* build_aot_table(ClassLoaderData* loader_data, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"cds\/aotMetaspace.hpp\"\n@@ -164,0 +165,15 @@\n+void AnyObj::set_in_aot_cache() {\n+  _allocation_t[0] = 0;\n+  _allocation_t[1] = 0;\n+}\n+\n+bool AnyObj::in_aot_cache() const {\n+  if (AOTMetaspace::in_aot_cache(this)) {\n+    precond(_allocation_t[0] == 0);\n+    precond(_allocation_t[1] == 0);\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -165,0 +181,3 @@\n+  if (in_aot_cache()) {\n+    return STACK_OR_EMBEDDED;\n+  }\n@@ -170,0 +189,3 @@\n+  if (in_aot_cache()) {\n+    return true;\n+  }\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -423,0 +423,1 @@\n+  void set_in_aot_cache() NOT_DEBUG_RETURN;\n@@ -432,0 +433,1 @@\n+  bool in_aot_cache() const;\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+#include \"cds\/aotGrowableArray.hpp\"\n+#include \"classfile\/packageEntry.hpp\"\n@@ -26,0 +28,12 @@\n+#include \"oops\/array.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+\n+\/\/ Sanity checks\n+static_assert(!HAS_METASPACE_POINTERS_DO(int));\n+\n+static_assert(HAS_METASPACE_POINTERS_DO(Array<int>));\n+static_assert(HAS_METASPACE_POINTERS_DO(Array<InstanceKlass*>));\n+static_assert(HAS_METASPACE_POINTERS_DO(InstanceKlass));\n+static_assert(HAS_METASPACE_POINTERS_DO(PackageEntry));\n+static_assert(HAS_METASPACE_POINTERS_DO(AOTGrowableArray<int>));\n+static_assert(HAS_METASPACE_POINTERS_DO(AOTGrowableArray<PackageEntry*>));\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cds\/aotGrowableArray.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"memory\/metaspaceClosureType.hpp\"\n@@ -39,20 +41,12 @@\n-\/\/ The metadata hierarchy is separate from the oop hierarchy\n-  class MetaspaceObj;        \/\/ no C++ vtable\n-\/\/class   Array;             \/\/ no C++ vtable\n-  class   Annotations;       \/\/ no C++ vtable\n-  class   ConstantPoolCache; \/\/ no C++ vtable\n-  class   ConstMethod;       \/\/ no C++ vtable\n-  class   MethodCounters;    \/\/ no C++ vtable\n-  class   Symbol;            \/\/ no C++ vtable\n-  class   Metadata;          \/\/ has C++ vtable (so do all subclasses)\n-  class     ConstantPool;\n-  class     MethodData;\n-  class     Method;\n-  class     Klass;\n-  class       InstanceKlass;\n-  class         InstanceMirrorKlass;\n-  class         InstanceClassLoaderKlass;\n-  class         InstanceRefKlass;\n-  class       ArrayKlass;\n-  class         ObjArrayKlass;\n-  class         TypeArrayKlass;\n+\/\/ This macro just check for the existence of a member with the name \"metaspace_pointers_do\". If the\n+\/\/ parameter list is not (MetaspaceClosure* it), you will get a compilation error.\n+#define HAS_METASPACE_POINTERS_DO(T) HasMetaspacePointersDo<T>::value\n+\n+template<typename T>\n+class HasMetaspacePointersDo {\n+  template<typename U> static void* test(decltype(&U::metaspace_pointers_do));\n+  template<typename> static int test(...);\n+  using test_type = decltype(test<T>(nullptr));\n+public:\n+  static constexpr bool value = std::is_pointer_v<test_type>;\n+};\n@@ -62,1 +56,1 @@\n-\/\/ This class is used for iterating the objects in the HotSpot Metaspaces. It\n+\/\/ This class is used for iterating the class metadata objects. It\n@@ -66,8 +60,2 @@\n-\/\/ Currently it is used for compacting the CDS archive by eliminate temporary\n-\/\/ objects allocated during archive creation time. See ArchiveBuilder for an example.\n-\/\/\n-\/\/ To support MetaspaceClosure, each subclass of MetaspaceObj must provide\n-\/\/ a method of the type void metaspace_pointers_do(MetaspaceClosure*). This method\n-\/\/ should call MetaspaceClosure::push() on every pointer fields of this\n-\/\/ class that points to a MetaspaceObj. See Annotations::metaspace_pointers_do()\n-\/\/ for an example.\n+\/\/ Currently it is used to copy class metadata into the AOT cache.\n+\/\/ See ArchiveBuilder for an example.\n@@ -82,0 +70,11 @@\n+#define METASPACE_CLOSURE_TYPE_NAME_CASE(name) case MetaspaceClosureType::name ## Type: return #name;\n+\n+  static const char* type_name(MetaspaceClosureType type) {\n+    switch(type) {\n+    METASPACE_CLOSURE_TYPES_DO(METASPACE_CLOSURE_TYPE_NAME_CASE)\n+    default:\n+      ShouldNotReachHere();\n+      return nullptr;\n+    }\n+  }\n+\n@@ -84,3 +83,8 @@\n-  \/\/ MetaspaceClosure can be viewed as a very simple type of copying garbage\n-  \/\/ collector. For it to function properly, it requires each subclass of\n-  \/\/ MetaspaceObj to provide two methods:\n+  \/\/ For type X to be iterable by MetaspaceClosure, X (or one of X's supertypes) must have\n+  \/\/ the following public functions:\n+  \/\/         void metaspace_pointers_do(MetaspaceClosure* it);\n+  \/\/         static bool is_read_only_by_default() { return true; }\n+  \/\/\n+  \/\/ In addition, if X is not a subtype of MetaspaceObj, it must have the following function:\n+  \/\/         MetaspaceClosureType type() const;\n+  \/\/         int size_in_heapwords() const;\n@@ -88,2 +92,2 @@\n-  \/\/  size_t size();                                 -- to determine how much data to copy\n-  \/\/  void metaspace_pointers_do(MetaspaceClosure*); -- to locate all the embedded pointers\n+  \/\/ Currently, the iterable types include all subtypes of MetsapceObj, as well\n+  \/\/ as GrowableArray, ModuleEntry and PackageEntry.\n@@ -91,1 +95,1 @@\n-  \/\/ Calling these methods would be trivial if these two were virtual methods.\n+  \/\/ Calling these functions would be trivial if these were virtual functions.\n@@ -100,1 +104,1 @@\n-  \/\/ [1] We don't use polymorphic pointers for MetaspaceObj's that are not subclasses\n+  \/\/ [1] We don't use polymorphic pointers to MetaspaceObj's that are not subclasses\n@@ -133,2 +137,1 @@\n-    virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const = 0;\n-    virtual MetaspaceObj::Type msotype() const = 0;\n+    virtual MetaspaceClosureType type() const = 0;\n@@ -183,1 +186,20 @@\n-  \/\/ MSORef -- iterate an instance of MetaspaceObj\n+  template <typename T, ENABLE_IF(std::is_base_of<MetaspaceObj, T>::value)>\n+  static int get_size(T* obj) {\n+    return obj->size();\n+  }\n+\n+  template <typename T, ENABLE_IF(!std::is_base_of<MetaspaceObj, T>::value)>\n+  static int get_size(T* obj) {\n+    return obj->size_in_heapwords();\n+  }\n+\n+  static MetaspaceClosureType as_type(MetaspaceClosureType t) {\n+    return t;\n+  }\n+\n+  static MetaspaceClosureType as_type(MetaspaceObj::Type msotype) {\n+    precond(msotype < MetaspaceObj::_number_of_types);\n+    return (MetaspaceClosureType)msotype;\n+  }\n+\n+  \/\/ MSORef -- iterate an instance of T, where T::metaspace_pointers_do() exists.\n@@ -199,2 +221,2 @@\n-    virtual int size()                     const { return dereference()->size(); }\n-    virtual MetaspaceObj::Type msotype()   const { return dereference()->type(); }\n+    virtual int size()                     const { return get_size(dereference()); }\n+    virtual MetaspaceClosureType type()    const { return as_type(dereference()->type()); }\n@@ -205,3 +227,0 @@\n-    virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {\n-      ((T*)new_loc)->metaspace_pointers_do(it);\n-    }\n@@ -210,1 +229,6 @@\n-  \/\/ abstract base class for MSOArrayRef, MSOPointerArrayRef and OtherArrayRef\n+  \/\/---------------------\n+  \/\/ Support for Array<T>\n+  \/\/---------------------\n+\n+  \/\/ Abstract base class for MSOArrayRef, MSOPointerArrayRef and OtherArrayRef.\n+  \/\/ These are used for iterating Array<T>.\n@@ -227,1 +251,1 @@\n-    virtual MetaspaceObj::Type msotype()   const { return MetaspaceObj::array_type(sizeof(T)); }\n+    virtual MetaspaceClosureType type()    const { return as_type(MetaspaceObj::array_type(sizeof(T))); }\n@@ -230,1 +254,1 @@\n-  \/\/ OtherArrayRef -- iterate an instance of Array<T>, where T is NOT a subtype of MetaspaceObj.\n+  \/\/ OtherArrayRef -- iterate an instance of Array<T>, where T does NOT have metaspace_pointer_do().\n@@ -241,4 +265,0 @@\n-    virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {\n-      Array<T>* array = (Array<T>*)new_loc;\n-      log_trace(aot)(\"Iter(OtherArray): %p [%d]\", array, array->length());\n-    }\n@@ -247,1 +267,1 @@\n-  \/\/ MSOArrayRef -- iterate an instance of Array<T>, where T is a subtype of MetaspaceObj.\n+  \/\/ MSOArrayRef -- iterate an instance of Array<T>, where T has metaspace_pointer_do().\n@@ -256,3 +276,0 @@\n-    virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {\n-      metaspace_pointers_do_at_impl(it, (Array<T>*)new_loc);\n-    }\n@@ -269,1 +286,1 @@\n-  \/\/ MSOPointerArrayRef -- iterate an instance of Array<T*>, where T is a subtype of MetaspaceObj.\n+  \/\/ MSOPointerArrayRef -- iterate an instance of Array<T*>, where T has metaspace_pointer_do().\n@@ -278,3 +295,0 @@\n-    virtual void metaspace_pointers_do_at(MetaspaceClosure *it, address new_loc) const {\n-      metaspace_pointers_do_at_impl(it, (Array<T*>*)new_loc);\n-    }\n@@ -291,0 +305,96 @@\n+  \/\/--------------------------------\n+  \/\/ Support for AOTGrowableArray<T>\n+  \/\/--------------------------------\n+\n+  \/\/ Abstract base class for MSOCArrayRef, MSOPointerCArrayRef and OtherCArrayRef.\n+  \/\/ These are used for iterating the buffer held by AOTGrowableArray<T>.\n+  template <class T> class CArrayRef : public Ref {\n+    T** _mpp;\n+    int _num_elems; \/\/ Number of elements\n+\n+    int byte_size() const {\n+      return _num_elems * sizeof(T);\n+    }\n+\n+  protected:\n+    \/\/ C pointer arrays don't support tagged pointers.\n+    T* dereference() const {\n+      return *_mpp;\n+    }\n+    virtual void** mpp() const {\n+      return (void**)_mpp;\n+    }\n+    int num_elems() const {\n+      return _num_elems;\n+    }\n+  public:\n+    CArrayRef(T** mpp, int num_elems, Writability w)\n+      : Ref(w), _mpp(mpp), _num_elems(num_elems) {\n+      assert(is_aligned(byte_size(), BytesPerWord), \"must be\");\n+    }\n+\n+    virtual bool is_read_only_by_default() const { return false; }\n+    virtual bool not_null()                const { return dereference() != nullptr; }\n+    virtual int size()                     const { return (int)heap_word_size(byte_size()); }\n+    virtual MetaspaceClosureType type()    const { return MetaspaceClosureType::CArrayType; }\n+  };\n+\n+  \/\/ OtherCArrayRef -- iterate a C array of type T, where T does NOT have metaspace_pointer_do().\n+  \/\/ T can be a primitive type, such as int, or a structure. However, we do not scan\n+  \/\/ the fields inside T, so you should not embed any pointers inside T.\n+  template <class T> class OtherCArrayRef : public CArrayRef<T> {\n+  public:\n+    OtherCArrayRef(T** mpp, int num_elems, Writability w) : CArrayRef<T>(mpp, num_elems, w) {}\n+\n+    virtual void metaspace_pointers_do(MetaspaceClosure *it) const {\n+      T* array = CArrayRef<T>::dereference();\n+      log_trace(aot)(\"Iter(OtherCArray): %p [%d]\", array, CArrayRef<T>::num_elems());\n+    }\n+  };\n+\n+  \/\/ MSOCArrayRef<T> -- iterate a C array of type T, where T has metaspace_pointer_do().\n+  \/\/ We recursively call T::metaspace_pointers_do() for each element in this array.\n+  \/\/ This is for supporting AOTGrowableArray<T>.\n+  \/\/\n+  \/\/ E.g., PackageEntry* _pkg_entry_pointers[2]; \/\/ a buffer that has 2 PackageEntry objects\n+  \/\/       ...\n+  \/\/       it->push(&_pkg_entry_pointers, 2);\n+  \/\/           \/* calls _pkg_entry_pointers[0].metaspace_pointers_do(it); *\/\n+  \/\/           \/* calls _pkg_entry_pointers[1].metaspace_pointers_do(it); *\/\n+  template <class T> class MSOCArrayRef : public CArrayRef<T> {\n+  public:\n+    MSOCArrayRef(T** mpp, int num_elems, Writability w) : CArrayRef<T>(mpp, num_elems, w) {}\n+\n+    virtual void metaspace_pointers_do(MetaspaceClosure *it) const {\n+      T* array = CArrayRef<T>::dereference();\n+      log_trace(aot)(\"Iter(MSOCArray): %p [%d]\", array, CArrayRef<T>::num_elems());\n+      for (int i = 0; i < CArrayRef<T>::num_elems(); i++) {\n+        T* elm = array + i;\n+        elm->metaspace_pointers_do(it);\n+      }\n+    }\n+  };\n+\n+  \/\/ MSOPointerCArrayRef<T> -- iterate a C array of type T*, where T has metaspace_pointer_do().\n+  \/\/ We recursively call MetaspaceClosure::push() for each pointer in this array.\n+  \/\/ This is for supporting AOTGrowableArray<T*>.\n+  \/\/\n+  \/\/ E.g., PackageEntry** _pkg_entry_pointers[2]; \/\/ a buffer that has 2 PackageEntry pointers\n+  \/\/       ...\n+  \/\/       it->push(&_pkg_entry_pointers, 2);\n+  \/\/           \/* calls _pkg_entry_pointers[0]->metaspace_pointers_do(it); *\/\n+  \/\/           \/* calls _pkg_entry_pointers[1]->metaspace_pointers_do(it); *\/\n+  template <class T> class MSOPointerCArrayRef : public CArrayRef<T*> {\n+  public:\n+    MSOPointerCArrayRef(T*** mpp, int num_elems, Writability w) : CArrayRef<T*>(mpp, num_elems, w) {}\n+\n+    virtual void metaspace_pointers_do(MetaspaceClosure *it) const {\n+      T** array = CArrayRef<T*>::dereference();\n+      log_trace(aot)(\"Iter(MSOPointerCArray): %p [%d]\", array, CArrayRef<T*>::num_elems());\n+      for (int i = 0; i < CArrayRef<T*>::num_elems(); i++) {\n+        T** mpp = array + i;\n+        it->push(mpp);\n+      }\n+    }\n+  };\n+\n@@ -333,2 +443,5 @@\n-  \/\/ Note that the following will fail to compile (to prevent you from adding new fields\n-  \/\/ into the MetaspaceObj subtypes that cannot be properly copied by CDS):\n+  \/\/ AOTGrowableArrays have a separate \"C array\" buffer, so they are scanned in two steps:\n+  \/\/\n+  \/\/ AOTGrowableArray<jlong>*      ga1 = ...;  it->push(&ga1);  => MSORef => OtherCArrayRef\n+  \/\/ AOTGrowableArray<Annotation>* ga2 = ...;  it->push(&ga2);  => MSORef => MSOCArrayRef\n+  \/\/ AOTGrowableArray<Klass*>*     ga3 = ...;  it->push(&ga3);  => MSORef => MSOPointerCArrayRef\n@@ -336,3 +449,5 @@\n-  \/\/ MemoryPool*            p  = ...;  it->push(&p);     => MemoryPool is not a subclass of MetaspaceObj\n-  \/\/ Array<MemoryPool*>*    a6 = ...;  it->push(&a6);    => MemoryPool is not a subclass of MetaspaceObj\n-  \/\/ Array<int*>*           a7 = ...;  it->push(&a7);    => int       is not a subclass of MetaspaceObj\n+  \/\/ Note that the following will fail to compile:\n+  \/\/\n+  \/\/ MemoryPool*            p  = ...;  it->push(&p);     => MemoryPool doesn't have metaspace_pointers_do\n+  \/\/ Array<MemoryPool*>*    a6 = ...;  it->push(&a6);    => MemoryPool doesn't have metaspace_pointers_do\n+  \/\/ Array<int*>*           a7 = ...;  it->push(&a7);    => int doesn't have metaspace_pointers_do\n@@ -340,0 +455,1 @@\n+  \/\/ --- Regular iterable objects\n@@ -342,1 +458,1 @@\n-    static_assert(std::is_base_of<MetaspaceObj, T>::value, \"Do not push pointers of arbitrary types\");\n+    static_assert(HAS_METASPACE_POINTERS_DO(T), \"Do not push pointers of arbitrary types\");\n@@ -346,1 +462,2 @@\n-  template <typename T, ENABLE_IF(!std::is_base_of<MetaspaceObj, T>::value)>\n+  \/\/ --- Array<T>\n+  template <typename T, ENABLE_IF(!HAS_METASPACE_POINTERS_DO(T))>\n@@ -351,1 +468,1 @@\n-  template <typename T, ENABLE_IF(std::is_base_of<MetaspaceObj, T>::value)>\n+  template <typename T, ENABLE_IF(HAS_METASPACE_POINTERS_DO(T))>\n@@ -358,1 +475,1 @@\n-    static_assert(std::is_base_of<MetaspaceObj, T>::value, \"Do not push Arrays of arbitrary pointer types\");\n+    static_assert(HAS_METASPACE_POINTERS_DO(T), \"Do not push Arrays of arbitrary pointer types\");\n@@ -361,0 +478,17 @@\n+\n+  \/\/ --- The buffer of AOTGrowableArray<T>\n+  template <typename T, ENABLE_IF(!HAS_METASPACE_POINTERS_DO(T))>\n+  void push_c_array(T** mpp, int num_elems, Writability w = _default) {\n+    push_impl(new OtherCArrayRef<T>(mpp, num_elems, w));\n+  }\n+\n+  template <typename T, ENABLE_IF(HAS_METASPACE_POINTERS_DO(T))>\n+  void push_c_array(T** mpp, int num_elems, Writability w = _default) {\n+    push_impl(new MSOCArrayRef<T>(mpp, num_elems, w));\n+  }\n+\n+  template <typename T>\n+  void push_c_array(T*** mpp, int num_elems, Writability w = _default) {\n+    static_assert(HAS_METASPACE_POINTERS_DO(T), \"Do not push C arrays of arbitrary pointer types\");\n+    push_impl(new MSOPointerCArrayRef<T>(mpp, num_elems, w));\n+  }\n@@ -363,1 +497,1 @@\n-\/\/ This is a special MetaspaceClosure that visits each unique MetaspaceObj once.\n+\/\/ This is a special MetaspaceClosure that visits each unique object once.\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":204,"deletions":70,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_METASPACECLOSURETYPE_HPP\n+#define SHARE_MEMORY_METASPACECLOSURETYPE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+\/\/ MetaspaceClosure is able to iterate on MetaspaceObjs, plus the following classes\n+#define METASPACE_CLOSURE_TYPES_DO(f) \\\n+  METASPACE_OBJ_TYPES_DO(f) \\\n+  f(CArray) \\\n+  f(GrowableArray) \\\n+  f(ModuleEntry) \\\n+  f(PackageEntry) \\\n+\n+#define METASPACE_CLOSURE_TYPE_DECLARE(name) name ## Type,\n+\n+enum class MetaspaceClosureType : int {\n+  METASPACE_CLOSURE_TYPES_DO(METASPACE_CLOSURE_TYPE_DECLARE)\n+  _number_of_types\n+};\n+\n+\n+#endif \/\/ SHARE_MEMORY_METASPACECLOSURETYPE_HPP\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosureType.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+class MetaspaceClosure;\n+\n@@ -160,0 +162,3 @@\n+  \/\/ This function does nothing. The iteration of the elements are done inside metaspaceClosure.hpp\n+  void metaspace_pointers_do(MetaspaceClosure* it) {}\n+\n","filename":"src\/hotspot\/share\/oops\/array.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2696,0 +2696,4 @@\n+\n+  if (CDSConfig::is_dumping_full_module_graph() && !defined_by_other_loaders()) {\n+    it->push(&_package_entry);\n+  }\n@@ -2794,14 +2798,1 @@\n-#if !INCLUDE_CDS_JAVA_HEAP\n-  _package_entry = nullptr;\n-#else\n-  if (CDSConfig::is_dumping_full_module_graph()) {\n-    if (defined_by_other_loaders()) {\n-      _package_entry = nullptr;\n-    } else {\n-      _package_entry = PackageEntry::get_archived_entry(_package_entry);\n-    }\n-  } else if (CDSConfig::is_dumping_dynamic_archive() &&\n-             CDSConfig::is_using_full_module_graph() &&\n-             AOTMetaspace::in_aot_cache(_package_entry)) {\n-    \/\/ _package_entry is an archived package in the base archive. Leave it as is.\n-  } else {\n+  if (!CDSConfig::is_dumping_full_module_graph() || defined_by_other_loaders()) {\n@@ -2810,2 +2801,0 @@\n-  ArchivePtrMarker::mark_pointer((address**)&_package_entry);\n-#endif\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"memory\/metaspaceClosure.hpp\"\n@@ -41,0 +40,1 @@\n+class MetaspaceClosure;\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -300,0 +300,5 @@\n+\n+  \/\/ MetaspaceClosure support.\n+  E** data_addr() {\n+    return &_data;\n+  }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+#include \"cds\/aotGrowableArray.inline.hpp\"\n@@ -61,1 +62,1 @@\n-  MyMetaData* _visited[SIZE];\n+  void* _visited[SIZE];\n@@ -74,1 +75,9 @@\n-    _visited[_count++] = ptr;\n+    for (int i = 0; i < _count; i++) {\n+      if (_visited[i] == (void*)ptr) {\n+        \/\/ We have walked this before.\n+        return false;\n+      }\n+    }\n+\n+    \/\/ Found a new pointer. Let's walk it\n+    _visited[_count++] = (void*)ptr;\n@@ -79,0 +88,3 @@\n+    return has_visited((void*)p);\n+  }\n+  bool has_visited(void* p) {\n@@ -107,0 +119,1 @@\n+  closure.finish();\n@@ -108,0 +121,1 @@\n+  EXPECT_TRUE(closure.has_visited(array)) << \"must be\";\n@@ -133,0 +147,36 @@\n+  closure.finish();\n+\n+  EXPECT_TRUE(closure.has_visited(array)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(&x)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(&y)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(&z)) << \"must be\";\n+}\n+\n+\/\/ iterate an Array<int>\n+TEST_VM(MetaspaceClosure, OtherArrayRef) {\n+  JavaThread* THREAD = JavaThread::current();\n+  ClassLoaderData* cld = ClassLoaderData::the_null_class_loader_data();\n+  Array<int>* array = MetadataFactory::new_array<int>(cld, 4, THREAD);\n+\n+  MyUniqueMetaspaceClosure closure;\n+  closure.push(&array);\n+  closure.finish();\n+\n+  EXPECT_TRUE(closure.has_visited(array)) << \"must be\";\n+}\n+\n+\/\/ iterate an AOTGrowableArray<MyMetaData*>\n+TEST_VM(MetaspaceClosure, GrowableArray_MSOPointer) {\n+  AOTGrowableArray<MyMetaData*>* array = new(mtClass) AOTGrowableArray<MyMetaData*>(2, mtClass);\n+\n+  MyMetaData x;\n+  MyMetaData y;\n+  MyMetaData z;\n+\n+  array->push(&x);\n+  array->push(&y);\n+  y._a = &z;\n+\n+  MyUniqueMetaspaceClosure closure;\n+  closure.push(&array);\n+  closure.finish();\n@@ -134,0 +184,1 @@\n+  EXPECT_TRUE(closure.has_visited(array)) << \"must be\";\n@@ -137,0 +188,42 @@\n+  EXPECT_TRUE(closure.has_visited(*array->data_addr())) << \"must visit buffer inside GrowableArray\";\n+}\n+\n+\/\/ iterate an AOTGrowableArray<MyMetaData>\n+TEST_VM(MetaspaceClosure, GrowableArray_MSO) {\n+  AOTGrowableArray<MyMetaData>* array = new(mtClass) AOTGrowableArray<MyMetaData>(4, mtClass);\n+\n+  for (int i = 0; i < array->length(); i++) {\n+    EXPECT_TRUE(array->at(i)._a == nullptr) << \"should be initialized to null\";\n+    EXPECT_TRUE(array->at(i)._b == nullptr) << \"should be initialized to null\";\n+  }\n+\n+  MyMetaData x;\n+  MyMetaData y;\n+  MyMetaData z;\n+\n+  z._a = &x;\n+  z._b = &y;\n+  y._a = &z;\n+  array->push(z);\n+\n+  MyUniqueMetaspaceClosure closure;\n+  closure.push(&array);\n+  closure.finish();\n+\n+  EXPECT_TRUE(closure.has_visited(array)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(&x)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(&y)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(&z)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(*array->data_addr())) << \"must visit buffer inside GrowableArray\";\n+}\n+\n+\/\/ iterate an AOTGrowableArray<jlong>\n+TEST_VM(MetaspaceClosure, GrowableArray_jlong) {\n+  AOTGrowableArray<jlong>* array = new(mtClass) AOTGrowableArray<jlong>(4, mtClass);\n+\n+  MyUniqueMetaspaceClosure closure;\n+  closure.push(&array);\n+  closure.finish();\n+\n+  EXPECT_TRUE(closure.has_visited(array)) << \"must be\";\n+  EXPECT_TRUE(closure.has_visited(*array->data_addr())) << \"must visit buffer inside GrowableArray\";\n","filename":"test\/hotspot\/gtest\/utilities\/test_metaspaceClosure.cpp","additions":96,"deletions":3,"binary":false,"changes":99,"status":"modified"}]}