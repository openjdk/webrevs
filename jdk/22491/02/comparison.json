{"files":[{"patch":"@@ -90,0 +90,2 @@\n+#define HAVE_PD_C1_IS_INSTANCE_OF_STUB true\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Defs_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1320,0 +1320,5 @@\n+\/\/ Intrinsic for Class::isInstance\n+address LIRGenerator::isInstance_entry() {\n+  return Runtime1::entry_for(C1StubId::is_instance_of_id);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -904,0 +904,49 @@\n+    case C1StubId::is_instance_of_id:\n+      {\n+        \/\/ Mirror: c_rarg0\n+        \/\/ Object: c_rarg1\n+        \/\/ Temps: r3, r4, r5, r6\n+        \/\/ Result: r0\n+\n+        \/\/ Get the Klass* into c_rarg6\n+        Register klass = c_rarg6, obj = c_rarg1, result = r0;\n+        __ ldr(klass, Address(c_rarg0, java_lang_Class::klass_offset()));\n+\n+        Label fail, is_secondary, success;\n+\n+        __ cbz(klass, fail); \/\/ Klass is null\n+        __ cbz(obj, fail); \/\/ obj is null\n+\n+        __ ldrw(r3, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n+        __ cmpw(r3, in_bytes(Klass::secondary_super_cache_offset()));\n+        __ br(Assembler::EQ, is_secondary); \/\/ Klass is a secondary superclass\n+\n+        \/\/ Klass is a concrete class\n+        __ load_klass(r5, obj);\n+        __ ldr(rscratch1, Address(r5, r3));\n+        __ cmp(klass, rscratch1);\n+        __ cset(result, Assembler::EQ);\n+        __ ret(lr);\n+\n+        __ bind(is_secondary);\n+\n+        __ load_klass(obj, obj);\n+\n+        \/\/ This is necessary because I am never in my own secondary_super list.\n+        __ cmp(obj, klass);\n+        __ br(Assembler::EQ, success);\n+\n+        __ lookup_secondary_supers_table_var(obj, klass,\n+                                             \/*temps*\/r3, r4, r5, v0,\n+                                             result,\n+                                             &success);\n+        __ bind(fail);\n+        __ mov(result, 0);\n+        __ ret(lr);\n+\n+        __ bind(success);\n+        __ mov(result, 1);\n+        __ ret(lr);\n+      }\n+      break;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -87,0 +87,2 @@\n+#define HAVE_PD_C1_IS_INSTANCE_OF_STUB true\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_Defs_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1516,0 +1516,5 @@\n+\/\/ Intrinsic for Class::isInstance\n+address LIRGenerator::isInstance_entry() {\n+  return CAST_FROM_FN_PTR(address, Runtime1::is_instance_of);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1321,0 +1321,54 @@\n+    case C1StubId::is_instance_of_id:\n+      {\n+        \/\/ Mirror: c_rarg0  (Windows: rcx, SysV: rdi)\n+        \/\/ Object: c_rarg1  (Windows: rdx, SysV: rsi)\n+        \/\/ ObjClass: r9\n+        \/\/ Temps:  rcx, r8, r10, r11\n+        \/\/ Result: rax\n+\n+        Register klass = r9, obj = c_rarg1, result = rax;\n+        Register temp0 = rcx, temp1 = r8, temp2 = r10, temp3 = r11;\n+\n+        \/\/ Get the Klass* into r9. c_rarg0 is now dead.\n+        __ movptr(klass, Address(c_rarg0, java_lang_Class::klass_offset()));\n+\n+        Label done, is_secondary, same;\n+\n+        __ xorq(result, result);\n+        __ testq(klass, klass);\n+        __ jcc(Assembler::equal, done); \/\/ Klass is null\n+\n+        __ testq(obj, obj);\n+        __ jcc(Assembler::equal, done); \/\/ obj is null\n+\n+        __ movl(temp0, Address(klass, in_bytes(Klass::super_check_offset_offset())));\n+        __ cmpl(temp0, in_bytes(Klass::secondary_super_cache_offset()));\n+        __ jcc(Assembler::equal, is_secondary); \/\/ Klass is a secondary superclass\n+\n+        \/\/ Klass is a concrete class\n+        __ load_klass(temp2, obj, \/*tmp*\/temp1);\n+        __ cmpptr(klass, Address(temp2, temp0));\n+        __ setcc(Assembler::equal, result);\n+        __ ret(0);\n+\n+        __ bind(is_secondary);\n+\n+        __ load_klass(obj, obj, \/*tmp*\/temp1);\n+\n+        \/\/ This is necessary because I am never in my own secondary_super list.\n+        __ cmpptr(obj, klass);\n+        __ jcc(Assembler::equal, same);\n+\n+        __ lookup_secondary_supers_table_var(obj, klass,\n+                                             \/*temps*\/temp0, temp1, temp2, temp3,\n+                                             result);\n+        __ testq(result, result);\n+\n+        __ bind(same);\n+        __ setcc(Assembler::equal, result);\n+\n+        __ bind(done);\n+        __ ret(0);\n+      }\n+      break;\n+\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -527,1 +527,1 @@\n-        \/\/ an InstantOf instruction\n+        \/\/ an InstanceOf instruction\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1235,7 +1235,0 @@\n-  \/\/ TODO could try to substitute this node with an equivalent InstanceOf\n-  \/\/ if clazz is known to be a constant Class. This will pick up newly found\n-  \/\/ constants after HIR construction. I'll leave this to a future change.\n-\n-  \/\/ as a first cut, make a simple leaf call to runtime to stay platform independent.\n-  \/\/ could follow the aastore example in a future change.\n-\n@@ -1254,0 +1247,1 @@\n+  address pd_instanceof_fn = isInstance_entry();\n@@ -1255,1 +1249,1 @@\n-                                     CAST_FROM_FN_PTR(address, Runtime1::is_instance_of),\n+                                     pd_instanceof_fn,\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -541,0 +541,3 @@\n+  \/\/ Intrinsic for Class::isInstance\n+  address isInstance_entry();\n+\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -255,0 +255,1 @@\n+  case C1StubId::is_instance_of_id:\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+  do_blob(is_instance_of)                                              \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}