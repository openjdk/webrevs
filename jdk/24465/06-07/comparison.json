{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -115,1 +116,1 @@\n-        private static final Set<Path> activePaths = new HashSet<>();\n+        private static final List<Path> activePaths = new ArrayList<>();\n@@ -256,5 +257,4 @@\n-                    \/\/ Inside loadFromPath, we have performed symlinks\n-                    \/\/ resolution on currentPath under the rationale that\n-                    \/\/ the original file writer is the one who decided\n-                    \/\/ where the relative includes should resolve.\n-                    path = currentPath.resolveSibling(path);\n+                    \/\/ We perform symlinks resolution on currentPath under the\n+                    \/\/ rationale that the original file writer is the one who\n+                    \/\/ decided where the relative includes should resolve.\n+                    path = resolve(currentPath).resolveSibling(path);\n@@ -269,0 +269,23 @@\n+        private static Path resolve(Path path) {\n+            \/\/ JDK-8352728: we prefer java.io.File::getCanonicalFile over\n+            \/\/ java.nio.file.Path::toRealPath because the former is more\n+            \/\/ fault-tolerant, since the canonical form of a pathname is\n+            \/\/ specified to exist even for nonexistent\/inaccessible files.\n+            try {\n+                return path.toFile().getCanonicalFile().toPath();\n+            } catch (IOException e) {\n+                throw new InternalError(\"Cannot resolve path\", e);\n+            }\n+        }\n+\n+        private static void checkCyclicInclude(Path path) {\n+            for (Path activePath : activePaths) {\n+                try {\n+                    if (Files.isSameFile(path, activePath)) {\n+                        throw new InternalError(\n+                                \"Cyclic include of '\" + resolve(path) + \"'\");\n+                    }\n+                } catch (IOException ignore) {}\n+            }\n+        }\n+\n@@ -275,8 +298,0 @@\n-            \/\/ JDK-8352728: we prefer java.io.File::getCanonicalFile over\n-            \/\/ java.nio.file.Path::toRealPath because the former is more\n-            \/\/ fault-tolerant, since the canonical form of a pathname is\n-            \/\/ specified to exist even for nonexistent\/inaccessible files.\n-            path = path.toFile().getCanonicalFile().toPath();\n-            if (activePaths.contains(path)) {\n-                throw new InternalError(\"Cyclic include of '\" + path + \"'\");\n-            }\n@@ -284,0 +299,1 @@\n+                checkCyclicInclude(path);\n@@ -293,1 +309,1 @@\n-                    activePaths.remove(path);\n+                    activePaths.removeLast();\n@@ -312,0 +328,1 @@\n+                source = source instanceof Path path ? resolve(path) : source;\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":32,"deletions":15,"binary":false,"changes":47,"status":"modified"}]}