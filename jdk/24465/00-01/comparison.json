{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -256,0 +256,4 @@\n+                    \/\/ Inside loadFromPath, we have performed symlinks\n+                    \/\/ resolution on currentFile under the rationale that\n+                    \/\/ the original file writer is the one who decided\n+                    \/\/ where the relative includes should resolve.\n@@ -271,10 +275,5 @@\n-            \/\/ For path canonicalization, we prefer\n-            \/\/ java.io.File::getCanonicalPath over\n-            \/\/ java.nio.file.Path::toRealPath because of the following reasons:\n-            \/\/   1. In Windows, File::getCanonicalPath handles restricted\n-            \/\/      permissions in parent directories. Contrarily,\n-            \/\/      Path::toRealPath fails with AccessDeniedException.\n-            \/\/   2. In Linux, File::getCanonicalPath handles non-regular files\n-            \/\/      (e.g. \/dev\/stdin). Contrarily, Path::toRealPath fails with\n-            \/\/      NoSuchFileException.\n-            path = Path.of(path.toFile().getCanonicalPath());\n+            \/\/ JDK-8352728: we prefer java.io.File::getCanonicalFile over\n+            \/\/ java.nio.file.Path::toRealPath because the former is more\n+            \/\/ fault-tolerant, since the canonical form of a pathname is\n+            \/\/ specified to exist even for nonexistent\/inaccessible files.\n+            path = path.toFile().getCanonicalFile().toPath();\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"}]}