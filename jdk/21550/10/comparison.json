{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.file.Files;\n@@ -31,0 +32,1 @@\n+import java.util.ArrayList;\n@@ -33,0 +35,2 @@\n+import java.util.Objects;\n+import java.util.stream.Stream;\n@@ -38,0 +42,2 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.OUTPUT_DIR;\n+import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n@@ -76,2 +82,15 @@\n-            IOUtils.copyRecursive(SOURCE_DIR.fetchFrom(params),\n-                    appLayout.appDirectory());\n+            inputPath = inputPath.toAbsolutePath();\n+\n+            List<Path> excludes = new ArrayList<>();\n+\n+            for (var path : List.of(TEMP_ROOT.fetchFrom(params), OUTPUT_DIR.fetchFrom(params), root)) {\n+                if (Files.isDirectory(path)) {\n+                    path = path.toAbsolutePath();\n+                    if (path.startsWith(inputPath) && !Files.isSameFile(path, inputPath)) {\n+                        excludes.add(path);\n+                    }\n+                }\n+            }\n+\n+            IOUtils.copyRecursive(inputPath,\n+                    appLayout.appDirectory().toAbsolutePath(), excludes);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AbstractAppImageBuilder.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,3 +92,0 @@\n-    private String input = null;\n-    private Path output = null;\n-\n@@ -138,3 +135,0 @@\n-\n-        output = Paths.get(\"\").toAbsolutePath();\n-        deployParams.setOutput(output);\n@@ -150,2 +144,1 @@\n-            context().input = popArg();\n-            setOptionValue(\"input\", context().input);\n+            setOptionValue(\"input\", popArg());\n@@ -155,2 +148,2 @@\n-            context().output = Path.of(popArg());\n-            context().deployParams.setOutput(context().output);\n+            var path = Path.of(popArg());\n+            setOptionValue(\"dest\", path);\n@@ -714,1 +707,2 @@\n-            Path result = bundler.execute(localParams, deployParams.outdir);\n+            Path result = bundler.execute(localParams,\n+                    StandardBundlerParam.OUTPUT_DIR.fetchFrom(params));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,0 @@\n-    Path outdir = null;\n-\n@@ -57,4 +55,0 @@\n-    public void setOutput(Path output) {\n-        outdir = output;\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DeployParams.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-            final List<String> excludes, CopyOption... options)\n+            final List<Path> excludes, CopyOption... options)\n@@ -126,0 +126,3 @@\n+\n+        List<CopyAction> copyActions = new ArrayList<>();\n+\n@@ -129,2 +132,2 @@\n-                    final BasicFileAttributes attrs) throws IOException {\n-                if (excludes.contains(dir.toFile().getName())) {\n+                    final BasicFileAttributes attrs) {\n+                if (isPathMatch(dir, excludes)) {\n@@ -133,1 +136,2 @@\n-                    Files.createDirectories(dest.resolve(src.relativize(dir)));\n+                    copyActions.add(new CopyAction(null, dest.resolve(src.\n+                            relativize(dir))));\n@@ -140,3 +144,4 @@\n-                    final BasicFileAttributes attrs) throws IOException {\n-                if (!excludes.contains(file.toFile().getName())) {\n-                    Files.copy(file, dest.resolve(src.relativize(file)), options);\n+                    final BasicFileAttributes attrs) {\n+                if (!isPathMatch(file, excludes)) {\n+                    copyActions.add(new CopyAction(file, dest.resolve(src.\n+                            relativize(file))));\n@@ -147,0 +152,18 @@\n+\n+        for (var copyAction : copyActions) {\n+            copyAction.apply(options);\n+        }\n+    }\n+\n+    private static record CopyAction(Path src, Path dest) {\n+        void apply(CopyOption... options) throws IOException {\n+            if (src == null) {\n+                Files.createDirectories(dest);\n+            } else {\n+                Files.copy(src, dest, options);\n+            }\n+        }\n+    }\n+\n+    private static boolean isPathMatch(Path what, List<Path> paths) {\n+        return paths.stream().anyMatch(what::endsWith);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-import java.util.stream.Collectors;\n@@ -103,0 +102,8 @@\n+    static final StandardBundlerParam<Path> OUTPUT_DIR =\n+            new StandardBundlerParam<>(\n+                    Arguments.CLIOptions.OUTPUT.getId(),\n+                    Path.class,\n+                    p -> Path.of(\"\").toAbsolutePath(),\n+                    (s, p) -> Path.of(s)\n+            );\n+\n@@ -599,1 +606,1 @@\n-        final List<String> excludes = Arrays.asList(\"jmods\", \"src.zip\");\n+        final List<Path> excludes = Arrays.asList(Path.of(\"jmods\"), Path.of(\"src.zip\"));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import static java.util.stream.Collectors.toSet;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import jdk.jpackage.test.Annotations.Test;\n+import static jdk.jpackage.test.DirectoryContentVerifierTest.AssertType.CONTAINS;\n+import static jdk.jpackage.test.DirectoryContentVerifierTest.AssertType.EQUALS;\n+import jdk.jpackage.test.TKit.DirectoryContentVerifier;\n+import static jdk.jpackage.test.TKit.assertAssert;\n+\n+\/*\n+ * @test\n+ * @summary Test TKit.DirectoryContentVerifier from jpackage test library\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile DirectoryContentVerifierTest.java\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=jdk.jpackage.test.DirectoryContentVerifierTest\n+ *\/\n+public class DirectoryContentVerifierTest {\n+\n+    enum AssertType {\n+        EQUALS(DirectoryContentVerifier::equals),\n+        CONTAINS(DirectoryContentVerifier::contains),\n+        ;\n+\n+        AssertType(BiConsumer<DirectoryContentVerifier, Set<Path>> assertFunc) {\n+            this.assertFunc = assertFunc;\n+        }\n+\n+        private final BiConsumer<DirectoryContentVerifier, Set<Path>> assertFunc;\n+    }\n+\n+    private static ArgsBuilder buildArgs() {\n+        return new ArgsBuilder();\n+    }\n+\n+    private static class ArgsBuilder {\n+\n+        void applyTo(List<Object[]> data) {\n+            data.add(new Object[]{expectedPaths, actualPaths, assertOp, success});\n+        }\n+\n+        void applyVariantsTo(List<Object[]> data) {\n+            applyTo(data);\n+            boolean pathGroupsEqual = List.of(expectedPaths).equals(List.of(actualPaths));\n+            if (assertOp == EQUALS) {\n+                if (!pathGroupsEqual) {\n+                    data.add(new Object[]{actualPaths, expectedPaths, EQUALS, success});\n+                }\n+                if (success) {\n+                    data.add(new Object[]{expectedPaths, actualPaths, CONTAINS, success});\n+                    if (!pathGroupsEqual) {\n+                        data.add(new Object[]{actualPaths, expectedPaths, CONTAINS, success});\n+                    }\n+                }\n+            }\n+        }\n+\n+        ArgsBuilder expectedPaths(String... paths) {\n+            expectedPaths = paths;\n+            return this;\n+        }\n+\n+        ArgsBuilder actualPaths(String... paths) {\n+            actualPaths = paths;\n+            return this;\n+        }\n+\n+        ArgsBuilder assertOp(AssertType v) {\n+            assertOp = v;\n+            return this;\n+        }\n+\n+        ArgsBuilder expectFail() {\n+            success = false;\n+            return this;\n+        }\n+\n+        private String[] expectedPaths = new String[0];\n+        private String[] actualPaths = new String[0];\n+        private AssertType assertOp = EQUALS;\n+        private boolean success = true;\n+    }\n+\n+    @Parameters\n+    public static Collection input() {\n+        List<Object[]> data = new ArrayList<>();\n+        buildArgs().applyVariantsTo(data);\n+        buildArgs().actualPaths(\"foo\").assertOp(CONTAINS).applyTo(data);\n+        buildArgs().actualPaths(\"zoo\").expectFail().applyVariantsTo(data);\n+        buildArgs().actualPaths(\"boo\").expectedPaths(\"boo\").applyVariantsTo(data);\n+        if (TKit.isWindows()) {\n+            buildArgs().actualPaths(\"moo\").expectedPaths(\"Moo\").applyVariantsTo(data);\n+        } else {\n+            buildArgs().actualPaths(\"moo\").expectedPaths(\"Moo\").expectFail().applyVariantsTo(data);\n+        }\n+        buildArgs().actualPaths(\"hello\").expectedPaths().expectFail().applyVariantsTo(data);\n+        buildArgs().actualPaths(\"123\").expectedPaths(\"456\").expectFail().applyVariantsTo(data);\n+        buildArgs().actualPaths(\"a\", \"b\", \"c\").expectedPaths(\"b\", \"a\", \"c\").applyVariantsTo(data);\n+        buildArgs().actualPaths(\"AA\", \"BB\", \"CC\").expectedPaths(\"BB\", \"AA\").expectFail().applyVariantsTo(data);\n+        buildArgs().actualPaths(\"AA\", \"BB\", \"CC\").expectedPaths(\"BB\", \"AA\").assertOp(CONTAINS).applyTo(data);\n+        buildArgs().actualPaths(\"AA\", \"BB\", \"CC\").expectedPaths(\"BB\", \"DD\", \"AA\").expectFail().assertOp(CONTAINS).applyTo(data);\n+        buildArgs().actualPaths(\"AA\", \"BB\", \"CC\").expectedPaths(\"BB\", \"DD\", \"AA\").expectFail().applyTo(data);\n+        return data;\n+    }\n+\n+    public DirectoryContentVerifierTest(String[] expectedPaths, String[] actualPaths,\n+            AssertType assertOp, Boolean success) {\n+        this.expectedPaths = conv(expectedPaths);\n+        this.actualPaths = conv(actualPaths);\n+        this.assertOp = assertOp;\n+        this.success = success;\n+    }\n+\n+    @Test\n+    public void test() {\n+        TKit.withTempDirectory(\"basedir\", this::test);\n+    }\n+\n+    private void test(Path basedir) throws IOException {\n+        for (var path : actualPaths) {\n+            Files.createFile(basedir.resolve(path));\n+        }\n+\n+        var testee = TKit.assertDirectoryContent(basedir);\n+\n+        assertAssert(success, () -> assertOp.assertFunc.accept(testee, expectedPaths));\n+    }\n+\n+    private static Set<Path> conv(String... paths) {\n+        return Stream.of(paths).map(Path::of).collect(toSet());\n+    }\n+\n+    private final Set<Path> expectedPaths;\n+    private final Set<Path> actualPaths;\n+    private final AssertType assertOp;\n+    private final boolean success;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/DirectoryContentVerifierTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -37,1 +37,6 @@\n-    final public T addArgument(String v) {\n+    public final T clearArguments() {\n+        args.clear();\n+        return (T) this;\n+    }\n+\n+    public final T addArgument(String v) {\n@@ -42,1 +47,1 @@\n-    final public T addArguments(List<String> v) {\n+    public final T addArguments(List<String> v) {\n@@ -47,1 +52,1 @@\n-    final public T addArgument(Path v) {\n+    public final T addArgument(Path v) {\n@@ -51,1 +56,1 @@\n-    final public T addArguments(String... v) {\n+    public final T addArguments(String... v) {\n@@ -55,1 +60,1 @@\n-    final public T addPathArguments(List<Path> v) {\n+    public final T addPathArguments(List<Path> v) {\n@@ -60,1 +65,1 @@\n-    final public List<String> getAllArguments() {\n+    public final List<String> getAllArguments() {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CommandArguments.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import jdk.jpackage.test.Functional.ThrowingRunnable;\n@@ -79,0 +80,2 @@\n+        appLayoutAsserts = cmd.appLayoutAsserts;\n+        executeInDirectory = cmd.executeInDirectory;\n@@ -201,1 +204,4 @@\n-        return getArgumentValue(\"--dest\", () -> Path.of(\".\"), Path::of);\n+        var path = getArgumentValue(\"--dest\", () -> Path.of(\".\"), Path::of);\n+        return Optional.ofNullable(executeInDirectory).map(base -> {\n+            return base.resolve(path);\n+        }).orElse(path);\n@@ -694,0 +700,6 @@\n+    public JPackageCommand setDirectory(Path v) {\n+        verifyMutable();\n+        executeInDirectory = v;\n+        return this;\n+    }\n+\n@@ -736,0 +748,1 @@\n+                .setDirectory(executeInDirectory)\n@@ -758,6 +771,7 @@\n-            if (isImagePackageType()) {\n-                TKit.deleteDirectoryContentsRecursive(outputDir());\n-            } else {\n-                nullableOutputBundle().ifPresent(path -> {\n-                    if (ThrowingSupplier.toSupplier(() -> TKit.deleteIfExists(\n-                            path)).get()) {\n+            nullableOutputBundle().ifPresent(path -> {\n+                ThrowingRunnable.toRunnable(() -> {\n+                    if (Files.isDirectory(path)) {\n+                        TKit.deleteDirectoryRecursive(path, String.format(\n+                                \"Delete [%s] folder before running jpackage\",\n+                                path));\n+                    } else if (TKit.deleteIfExists(path)) {\n@@ -768,2 +782,2 @@\n-                });\n-            }\n+                }).run();\n+            });\n@@ -819,10 +833,19 @@\n-    JPackageCommand assertAppLayout() {\n-        assertAppImageFile();\n-        assertPackageFile();\n-\n-        TKit.assertDirectoryExists(appRuntimeDirectory());\n-\n-        if (!isRuntime()) {\n-            TKit.assertExecutableFileExists(appLauncherPath());\n-            TKit.assertFileExists(appLauncherCfgPath(null));\n-\n+    public static enum AppLayoutAssert {\n+        APP_IMAGE_FILE(JPackageCommand::assertAppImageFile),\n+        PACKAGE_FILE(JPackageCommand::assertPackageFile),\n+        MAIN_LAUNCHER(cmd -> {\n+            if (cmd.isRuntime()) {\n+                TKit.assertPathExists(convertFromRuntime(cmd).appLauncherPath(), false);\n+            } else {\n+                TKit.assertExecutableFileExists(cmd.appLauncherPath());\n+            }\n+        }),\n+        MAIN_LAUNCHER_CFG_FILE(cmd -> {\n+            if (cmd.isRuntime()) {\n+                TKit.assertPathExists(convertFromRuntime(cmd).appLauncherCfgPath(null), false);\n+            } else {\n+                TKit.assertFileExists(cmd.appLauncherCfgPath(null));\n+            }\n+        }),\n+        RUNTIME_DIRECTORY(cmd -> {\n+            TKit.assertDirectoryExists(cmd.appRuntimeDirectory());\n@@ -830,2 +853,6 @@\n-                TKit.assertFileExists(appRuntimeDirectory().resolve(\n-                        \"Contents\/MacOS\/libjli.dylib\"));\n+                var libjliPath = cmd.appRuntimeDirectory().resolve(\"Contents\/MacOS\/libjli.dylib\");\n+                if (cmd.isRuntime()) {\n+                    TKit.assertPathExists(libjliPath, false);\n+                } else {\n+                    TKit.assertFileExists(libjliPath);\n+                }\n@@ -833,0 +860,17 @@\n+        }),\n+        MAC_BUNDLE_STRUCTURE(cmd -> {\n+            if (TKit.isOSX()) {\n+                MacHelper.verifyBundleStructure(cmd);\n+            }\n+        });\n+        ;\n+\n+        AppLayoutAssert(Consumer<JPackageCommand> action) {\n+            this.action = action;\n+        }\n+\n+        private static JPackageCommand convertFromRuntime(JPackageCommand cmd) {\n+            var copy = new JPackageCommand(cmd);\n+            copy.immutable = false;\n+            copy.removeArgumentWithValue(\"--runtime-image\");\n+            return copy;\n@@ -835,0 +879,17 @@\n+        private final Consumer<JPackageCommand> action;\n+    }\n+\n+    public JPackageCommand setAppLayoutAsserts(AppLayoutAssert ... asserts) {\n+        appLayoutAsserts = Set.of(asserts);\n+        return this;\n+    }\n+\n+    public JPackageCommand excludeAppLayoutAsserts(AppLayoutAssert... asserts) {\n+        return setAppLayoutAsserts(Stream.of(asserts).filter(Predicate.not(\n+                appLayoutAsserts::contains)).toArray(AppLayoutAssert[]::new));\n+    }\n+\n+    JPackageCommand assertAppLayout() {\n+        for (var appLayoutAssert : appLayoutAsserts.stream().sorted().toList()) {\n+            appLayoutAssert.action.accept(this);\n+        }\n@@ -1114,0 +1175,2 @@\n+    private Path executeInDirectory;\n+    private Set<AppLayoutAssert> appLayoutAsserts = Set.of(AppLayoutAssert.values());\n@@ -1116,1 +1179,1 @@\n-    private final static Map<String, PackageType> PACKAGE_TYPES = Functional.identity(\n+    private static final Map<String, PackageType> PACKAGE_TYPES = Functional.identity(\n@@ -1125,1 +1188,1 @@\n-    public final static Path DEFAULT_RUNTIME_IMAGE = Functional.identity(() -> {\n+    public static final Path DEFAULT_RUNTIME_IMAGE = Functional.identity(() -> {\n@@ -1138,1 +1201,1 @@\n-    private final static String UNPACKED_PATH_ARGNAME = \"jpt-unpacked-folder\";\n+    private static final String UNPACKED_PATH_ARGNAME = \"jpt-unpacked-folder\";\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":88,"deletions":25,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -219,1 +219,3 @@\n-            desc.setClassName(components[0]);\n+            if (!components[0].isEmpty()) {\n+                desc.setClassName(components[0]);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JavaAppDesc.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import static java.util.stream.Collectors.toSet;\n@@ -260,0 +261,14 @@\n+    static void verifyBundleStructure(JPackageCommand cmd) {\n+        Path bundleRoot;\n+        if (cmd.isImagePackageType()) {\n+            bundleRoot = cmd.outputBundle();\n+        } else {\n+            bundleRoot = cmd.pathToUnpackedPackageFile(\n+                    cmd.appInstallationDirectory());\n+        }\n+\n+        TKit.assertDirectoryContent(bundleRoot).equals(Path.of(\"Contents\"));\n+        TKit.assertDirectoryContent(bundleRoot.resolve(\"Contents\")).equals(\n+                cmd.isRuntime() ? RUNTIME_BUNDLE_CONTENTS : APP_BUNDLE_CONTENTS);\n+    }\n+\n@@ -393,1 +408,15 @@\n-    private final static Method getServicePListFileName = initGetServicePListFileName();\n+    private static final Method getServicePListFileName = initGetServicePListFileName();\n+\n+    private static final Set<Path> APP_BUNDLE_CONTENTS = Stream.of(\n+            \"Info.plist\",\n+            \"MacOS\",\n+            \"app\",\n+            \"runtime\",\n+            \"Resources\",\n+            \"PkgInfo\",\n+            \"_CodeSignature\"\n+    ).map(Path::of).collect(toSet());\n+\n+    private static final Set<Path> RUNTIME_BUNDLE_CONTENTS = Stream.of(\n+            \"Home\"\n+    ).map(Path::of).collect(toSet());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,9 @@\n+    public PackageTest ignoreBundleOutputDir() {\n+        return ignoreBundleOutputDir(true);\n+    }\n+\n+    public PackageTest ignoreBundleOutputDir(boolean v) {\n+        ignoreBundleOutputDir = v;\n+        return this;\n+    }\n+\n@@ -371,1 +380,1 @@\n-    final static class PackageHandlers {\n+    static final class PackageHandlers {\n@@ -531,1 +540,1 @@\n-                if (BUNDLE_OUTPUT_DIR != null) {\n+                if (BUNDLE_OUTPUT_DIR != null && !ignoreBundleOutputDir) {\n@@ -780,0 +789,1 @@\n+    private boolean ignoreBundleOutputDir;\n@@ -781,1 +791,1 @@\n-    private final static File BUNDLE_OUTPUT_DIR;\n+    private static final File BUNDLE_OUTPUT_DIR;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.Arrays;\n@@ -47,0 +48,1 @@\n+import java.util.HashSet;\n@@ -60,0 +62,1 @@\n+import static java.util.stream.Collectors.toSet;\n@@ -66,1 +69,1 @@\n-final public class TKit {\n+public final class TKit {\n@@ -87,1 +90,1 @@\n-    public final static String ICON_SUFFIX = Functional.identity(() -> {\n+    public static final String ICON_SUFFIX = Functional.identity(() -> {\n@@ -276,1 +279,17 @@\n-    private final static String TEMP_FILE_PREFIX = null;\n+    static void assertAssert(boolean expectedSuccess, Runnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (AssertionError err) {\n+            if (expectedSuccess) {\n+                assertUnexpected(\"Assertion failed\");\n+            } else {\n+                return;\n+            }\n+        }\n+\n+        if (!expectedSuccess) {\n+            assertUnexpected(\"Assertion passed\");\n+        }\n+    }\n+\n+    private static final String TEMP_FILE_PREFIX = null;\n@@ -743,0 +762,95 @@\n+    public static DirectoryContentVerifier assertDirectoryContent(Path dir) {\n+        return new DirectoryContentVerifier(dir);\n+    }\n+\n+    public static final class DirectoryContentVerifier {\n+        public DirectoryContentVerifier(Path baseDir) {\n+            this(baseDir, ThrowingSupplier.toSupplier(() -> {\n+                try (var files = Files.list(baseDir)) {\n+                    return files.map(Path::getFileName).collect(toSet());\n+                }\n+            }).get());\n+        }\n+\n+        public void equals(Path ... expected) {\n+            equals(Set.of(expected));\n+        }\n+\n+        public void equals(Set<Path> expected) {\n+            currentTest.notifyAssert();\n+\n+            var comm = Comm.compare(content, expected);\n+            if (!comm.unique1.isEmpty() && !comm.unique2.isEmpty()) {\n+                error(String.format(\n+                        \"assertDirectoryContentEquals(%s): Some expected %s. Unexpected %s. Missing %s\",\n+                        baseDir, format(comm.common), format(comm.unique1), format(comm.unique2)));\n+            } else if (!comm.unique1.isEmpty()) {\n+                error(String.format(\n+                        \"assertDirectoryContentEquals%s: Expected %s. Unexpected %s\",\n+                        baseDir, format(comm.common), format(comm.unique1)));\n+            } else if (!comm.unique2.isEmpty()) {\n+                error(String.format(\n+                        \"assertDirectoryContentEquals(%s): Some expected %s. Missing %s\",\n+                        baseDir, format(comm.common), format(comm.unique2)));\n+            } else {\n+                traceAssert(String.format(\n+                        \"assertDirectoryContentEquals(%s): Expected %s\",\n+                        baseDir, format(expected)));\n+            }\n+        }\n+\n+        public void contains(Path ... expected) {\n+            contains(Set.of(expected));\n+        }\n+\n+        public void contains(Set<Path> expected) {\n+            currentTest.notifyAssert();\n+\n+            var comm = Comm.compare(content, expected);\n+            if (!comm.unique2.isEmpty()) {\n+                error(String.format(\n+                        \"assertDirectoryContentContains(%s): Some expected %s. Missing %s\",\n+                        baseDir, format(comm.common), format(comm.unique2)));\n+            } else {\n+                traceAssert(String.format(\n+                        \"assertDirectoryContentContains(%s): Expected %s\",\n+                        baseDir, format(expected)));\n+            }\n+        }\n+\n+        public DirectoryContentVerifier removeAll(Path ... paths) {\n+            Set<Path> newContent = new HashSet<>(content);\n+            newContent.removeAll(List.of(paths));\n+            return new DirectoryContentVerifier(baseDir, newContent);\n+        }\n+\n+        private DirectoryContentVerifier(Path baseDir, Set<Path> contents) {\n+            this.baseDir = baseDir;\n+            this.content = contents;\n+        }\n+\n+        private static record Comm(Set<Path> common, Set<Path> unique1, Set<Path> unique2) {\n+            static Comm compare(Set<Path> a, Set<Path> b) {\n+                Set<Path> common = new HashSet<>(a);\n+                common.retainAll(b);\n+\n+                Set<Path> unique1 = new HashSet<>(a);\n+                unique1.removeAll(common);\n+\n+                Set<Path> unique2 = new HashSet<>(b);\n+                unique2.removeAll(common);\n+\n+                return new Comm(common, unique1, unique2);\n+            }\n+        }\n+\n+        private static String format(Set<Path> paths) {\n+            return Arrays.toString(\n+                    paths.stream().sorted().map(Path::toString).toArray(\n+                            String[]::new));\n+        }\n+\n+        private final Path baseDir;\n+        private final Set<Path> content;\n+    }\n+\n@@ -820,1 +934,1 @@\n-    public final static class TextStreamVerifier {\n+    public static final class TextStreamVerifier {\n@@ -883,1 +997,1 @@\n-        final private String value;\n+        private final String value;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":119,"deletions":5,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,0 @@\n-import java.nio.file.Path;\n-import java.io.IOException;\n@@ -30,1 +28,0 @@\n-import org.junit.Before;\n@@ -43,5 +40,0 @@\n-    @Before\n-    public void setUp() throws IOException {\n-        testRoot = tempFolder.newFolder().toPath();\n-    }\n-\n@@ -118,1 +110,0 @@\n-        params.setOutput(testRoot);\n@@ -131,1 +122,0 @@\n-    private Path testRoot = null;\n","filename":"test\/jdk\/tools\/jpackage\/junit\/jdk.jpackage\/jdk\/jpackage\/internal\/DeployParamsTest.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,266 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import static java.util.stream.Collectors.toSet;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.AppImageFile;\n+import jdk.jpackage.internal.ApplicationLayout;\n+import jdk.jpackage.internal.PackageFile;\n+import jdk.jpackage.test.Annotations;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Functional.ThrowingConsumer;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.JPackageCommand.AppLayoutAssert;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import static jdk.jpackage.test.RunnablePackageTest.Action.CREATE_AND_UNPACK;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary Test jpackage command line with overlapping input and output paths\n+ * @library ..\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile InOutPathTest.java\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=InOutPathTest\n+ *\/\n+public final class InOutPathTest {\n+\n+    @Annotations.Parameters\n+    public static Collection input() {\n+        List<Object[]> data = new ArrayList<>();\n+\n+        for (var packageTypes : List.of(PackageType.IMAGE.toString(), ALL_NATIVE_PACKAGE_TYPES)) {\n+            data.addAll(List.of(new Object[][]{\n+                {packageTypes, wrap(InOutPathTest::outputDirInInputDir, \"--dest in --input\")},\n+                {packageTypes, wrap(InOutPathTest::outputDirSameAsInputDir, \"--dest same as --input\")},\n+                {packageTypes, wrap(InOutPathTest::tempDirInInputDir, \"--temp in --input\")},\n+                {packageTypes, wrap(cmd -> {\n+                    outputDirInInputDir(cmd);\n+                    tempDirInInputDir(cmd);\n+                }, \"--dest and --temp in --input\")},\n+            }));\n+            data.addAll(additionalContentInput(packageTypes, \"--app-content\"));\n+        }\n+\n+        data.addAll(List.of(new Object[][]{\n+            {PackageType.IMAGE.toString(), wrap(cmd -> {\n+                additionalContent(cmd, \"--app-content\", cmd.outputBundle());\n+            }, \"--app-content same as output bundle\")},\n+        }));\n+\n+        if (TKit.isOSX()) {\n+            data.addAll(additionalContentInput(PackageType.MAC_DMG.toString(),\n+                    \"--mac-dmg-content\"));\n+        }\n+\n+        return data;\n+    }\n+\n+    private static List<Object[]> additionalContentInput(String packageTypes, String argName) {\n+        List<Object[]> data = new ArrayList<>();\n+\n+        data.addAll(List.of(new Object[][]{\n+            {packageTypes, wrap(cmd -> {\n+                additionalContent(cmd, argName, cmd.inputDir());\n+            }, argName + \" same as --input\")},\n+        }));\n+\n+        if (!TKit.isOSX()) {\n+            data.addAll(List.of(new Object[][]{\n+                {packageTypes, wrap(cmd -> {\n+                    additionalContent(cmd, argName, cmd.inputDir().resolve(\"foo\"));\n+                }, argName + \" in --input\")},\n+                {packageTypes, wrap(cmd -> {\n+                    additionalContent(cmd, argName, cmd.outputDir().resolve(\"bar\"));\n+                }, argName + \" in --dest\")},\n+                {packageTypes, wrap(cmd -> {\n+                    additionalContent(cmd, argName, cmd.outputDir());\n+                }, argName + \" same as --dest\")},\n+                {packageTypes, wrap(cmd -> {\n+                    tempDirInInputDir(cmd);\n+                    var tempDir = cmd.getArgumentValue(\"--temp\");\n+                    Files.createDirectories(Path.of(tempDir));\n+                    cmd.addArguments(argName, tempDir);\n+                }, argName + \" as --temp; --temp in --input\")},\n+            }));\n+        }\n+\n+        return data;\n+    }\n+\n+    public InOutPathTest(String packageTypes, Envelope configure) {\n+        if (ALL_NATIVE_PACKAGE_TYPES.equals(packageTypes)) {\n+            this.packageTypes = PackageType.NATIVE;\n+        } else {\n+            this.packageTypes = Stream.of(packageTypes.split(\",\")).map(\n+                    PackageType::valueOf).collect(toSet());\n+        }\n+        this.configure = configure.value;\n+    }\n+\n+    @Test\n+    public void test() throws Throwable {\n+        runTest(packageTypes, configure);\n+    }\n+\n+    private static Envelope wrap(ThrowingConsumer<JPackageCommand> v, String label) {\n+        return new Envelope(v, label);\n+    }\n+\n+    private static boolean isAppImageValid(JPackageCommand cmd) {\n+        return !cmd.hasArgument(\"--app-content\") && !cmd.hasArgument(\"--mac-dmg-content\");\n+    }\n+\n+    private static void runTest(Set<PackageType> packageTypes,\n+            ThrowingConsumer<JPackageCommand> configure) throws Throwable {\n+        ThrowingConsumer<JPackageCommand> configureWrapper = cmd -> {\n+            \/\/ Make sure the input directory is empty in every test run.\n+            \/\/ This is needed because jpackage output directories in this test\n+            \/\/ are subdirectories of the input directory.\n+            cmd.setInputToEmptyDirectory();\n+            configure.accept(cmd);\n+            if (cmd.hasArgument(\"--temp\") && cmd.isImagePackageType()) {\n+                \/\/ Request to build app image wit user supplied temp directory,\n+                \/\/ ignore external runtime if any to make use of the temp directory\n+                \/\/ for runtime generation.\n+                cmd.ignoreDefaultRuntime(true);\n+            } else {\n+                cmd.setFakeRuntime();\n+            }\n+\n+            if (!isAppImageValid(cmd)) {\n+                \/\/ Standard asserts for .jpackage.xml fail in messed up app image. Disable them.\n+                \/\/ Other standard asserts for app image contents should pass.\n+                cmd.excludeAppLayoutAsserts(AppLayoutAssert.APP_IMAGE_FILE);\n+            }\n+        };\n+\n+        if (packageTypes.contains(PackageType.IMAGE)) {\n+            JPackageCommand cmd = JPackageCommand.helloAppImage(JAR_PATH.toString() + \":\");\n+            configureWrapper.accept(cmd);\n+            cmd.executeAndAssertHelloAppImageCreated();\n+            if (isAppImageValid(cmd)) {\n+                verifyAppImage(cmd);\n+            }\n+        } else {\n+            new PackageTest()\n+                    .forTypes(packageTypes)\n+                    .configureHelloApp(JAR_PATH.toString() + \":\")\n+                    .addInitializer(configureWrapper)\n+                    .addInstallVerifier(InOutPathTest::verifyAppImage)\n+                    .run(CREATE_AND_UNPACK);\n+        }\n+    }\n+\n+    private static void outputDirInInputDir(JPackageCommand cmd) throws\n+            IOException {\n+        \/\/ Set output dir as a subdir of input dir\n+        Path outputDir = cmd.inputDir().resolve(\"out\");\n+        TKit.createDirectories(outputDir);\n+        cmd.setArgumentValue(\"--dest\", outputDir);\n+    }\n+\n+    private static void outputDirSameAsInputDir(JPackageCommand cmd) throws\n+            IOException {\n+        \/\/ Set output dir the same as the input dir\n+        cmd.setArgumentValue(\"--dest\", cmd.inputDir());\n+    }\n+\n+    private static void tempDirInInputDir(JPackageCommand cmd) {\n+        \/\/ Set temp dir as a subdir of input dir\n+        Path tmpDir = cmd.inputDir().resolve(\"tmp\");\n+        cmd.setArgumentValue(\"--temp\", tmpDir);\n+    }\n+\n+    private static void additionalContent(JPackageCommand cmd,\n+            String argName, Path base) throws IOException {\n+        Path appContentFile = base.resolve(base.toString().replaceAll(\"[\\\\\\\\\/]\",\n+                \"-\") + \"-foo.txt\");\n+        TKit.createDirectories(appContentFile.getParent());\n+        TKit.createTextFile(appContentFile, List.of(\"Hello Duke!\"));\n+        cmd.addArguments(argName, appContentFile.getParent());\n+    }\n+\n+    private static void verifyAppImage(JPackageCommand cmd) throws IOException {\n+        if (!isAppImageValid(cmd)) {\n+            \/\/ Don't verify the contents of app image as it is invalid.\n+            \/\/ jpackage exited without getting stuck in infinite spiral.\n+            \/\/ No more expectations from the tool for the give arguments.\n+            return;\n+        }\n+\n+        final Path rootDir = cmd.isImagePackageType() ? cmd.outputBundle() : cmd.pathToUnpackedPackageFile(\n+                cmd.appInstallationDirectory());\n+        final Path appDir = ApplicationLayout.platformAppImage().resolveAt(\n+                rootDir).appDirectory();\n+\n+        final var knownFiles = Set.of(\n+                JAR_PATH.getName(0).toString(),\n+                PackageFile.getPathInAppImage(Path.of(\"\")).getFileName().toString(),\n+                AppImageFile.getPathInAppImage(Path.of(\"\")).getFileName().toString(),\n+                cmd.name() + \".cfg\"\n+        );\n+\n+        TKit.assertFileExists(appDir.resolve(JAR_PATH));\n+\n+        try (Stream<Path> actualFilesStream = Files.list(appDir)) {\n+            var unexpectedFiles = actualFilesStream.map(path -> {\n+                return path.getFileName().toString();\n+            }).filter(Predicate.not(knownFiles::contains)).toList();\n+            TKit.assertStringListEquals(List.of(), unexpectedFiles,\n+                    \"Check there are no unexpected files in `app` folder\");\n+        }\n+    }\n+\n+    private static final record Envelope(ThrowingConsumer<JPackageCommand> value, String label) {\n+        @Override\n+        public String toString() {\n+            \/\/ Will produce the same test description for the same label every\n+            \/\/ time it's executed.\n+            \/\/ The test runner will keep the same test output directory.\n+            return label;\n+        }\n+    }\n+\n+    private final Set<PackageType> packageTypes;\n+    private final ThrowingConsumer<JPackageCommand> configure;\n+\n+    \/\/ Placing jar file in the \"Resources\" subdir of the input directory would allow\n+    \/\/ to use the input directory with `--app-content` on OSX.\n+    \/\/ For other platforms it doesn't matter. Keep it the same across\n+    \/\/ all platforms for simplicity.\n+    private static final Path JAR_PATH = Path.of(\"Resources\/duke.jar\");\n+\n+    private static final String ALL_NATIVE_PACKAGE_TYPES = \"NATIVE\";\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":266,"deletions":0,"binary":false,"changes":266,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -44,0 +45,2 @@\n+import jdk.jpackage.test.Functional.ThrowingConsumer;\n+import static jdk.jpackage.test.RunnablePackageTest.Action.CREATE_AND_UNPACK;\n@@ -252,0 +255,57 @@\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testNoOutputDir(boolean appImage) throws Throwable {\n+        var cmd = JPackageCommand.helloAppImage();\n+\n+        final var execDir = cmd.outputDir();\n+\n+        final ThrowingConsumer<JPackageCommand> initializer = cmdNoOutputDir -> {\n+            cmd.executePrerequisiteActions();\n+\n+            final var pkgType = cmdNoOutputDir.packageType();\n+\n+            cmdNoOutputDir\n+                    .clearArguments()\n+                    .addArguments(cmd.getAllArguments())\n+                    \/\/ Restore the value of `--type` parameter.\n+                    .setPackageType(pkgType)\n+                    .removeArgumentWithValue(\"--dest\")\n+                    .setArgumentValue(\"--input\", execDir.relativize(cmd.inputDir()))\n+                    .setDirectory(execDir)\n+                    \/\/ Force to use jpackage as executable because we need to\n+                    \/\/ change the current directory.\n+                    .useToolProvider(false);\n+\n+            Optional.ofNullable(cmdNoOutputDir.getArgumentValue(\"--runtime-image\",\n+                    () -> null, Path::of)).ifPresent(runtimePath -> {\n+                        if (!runtimePath.isAbsolute()) {\n+                            cmdNoOutputDir.setArgumentValue(\"--runtime-image\",\n+                                    execDir.relativize(runtimePath));\n+                        }\n+                    });\n+\n+            \/\/ JPackageCommand.execute() will not do the cleanup if `--dest` parameter\n+            \/\/ is not specified, do it manually.\n+            TKit.createDirectories(execDir);\n+            TKit.deleteDirectoryContentsRecursive(execDir);\n+        };\n+\n+        if (appImage) {\n+            var cmdNoOutputDir = new JPackageCommand()\n+                    .setPackageType(cmd.packageType());\n+            initializer.accept(cmdNoOutputDir);\n+            cmdNoOutputDir.executeAndAssertHelloAppImageCreated();\n+        } else {\n+            \/\/ Save time by packing non-functional runtime.\n+            \/\/ Build the runtime in app image only. This is sufficient coverage.\n+            cmd.setFakeRuntime();\n+            new PackageTest()\n+                    .addInitializer(initializer)\n+                    .addInstallVerifier(HelloApp::executeLauncherAndVerifyOutput)\n+                    \/\/ Prevent adding `--dest` parameter to jpackage command line.\n+                    .ignoreBundleOutputDir()\n+                    .run(CREATE_AND_UNPACK);\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/BasicTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"}]}