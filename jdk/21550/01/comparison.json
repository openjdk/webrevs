{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.Objects;\n+import java.util.stream.Stream;\n@@ -38,0 +40,2 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.OUTPUT_DIR;\n+import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n@@ -76,2 +80,15 @@\n-            IOUtils.copyRecursive(SOURCE_DIR.fetchFrom(params),\n-                    appLayout.appDirectory());\n+            inputPath = inputPath.toAbsolutePath();\n+\n+            final var theInputPath = inputPath;\n+\n+            var excludes = Stream.of(TEMP_ROOT.fetchFrom(params),\n+                    OUTPUT_DIR.fetchFrom(params), root).map(path -> {\n+                path = path.toAbsolutePath();\n+                if (!path.startsWith(theInputPath) || path.equals(theInputPath)) {\n+                    path = null;\n+                }\n+                return path;\n+            }).filter(Objects::nonNull).toList();\n+\n+            IOUtils.copyRecursive(inputPath,\n+                    appLayout.appDirectory().toAbsolutePath(), excludes);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AbstractAppImageBuilder.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,3 +92,0 @@\n-    private String input = null;\n-    private Path output = null;\n-\n@@ -138,3 +135,0 @@\n-\n-        output = Paths.get(\"\").toAbsolutePath();\n-        deployParams.setOutput(output);\n@@ -150,2 +144,1 @@\n-            context().input = popArg();\n-            setOptionValue(\"input\", context().input);\n+            setOptionValue(\"input\", popArg());\n@@ -155,2 +148,2 @@\n-            context().output = Path.of(popArg());\n-            context().deployParams.setOutput(context().output);\n+            var path = Path.of(popArg());\n+            setOptionValue(\"dest\", path);\n@@ -714,1 +707,2 @@\n-            Path result = bundler.execute(localParams, deployParams.outdir);\n+            Path result = bundler.execute(localParams,\n+                    StandardBundlerParam.OUTPUT_DIR.fetchFrom(params));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,0 @@\n-    Path outdir = null;\n-\n@@ -57,4 +55,0 @@\n-    public void setOutput(Path output) {\n-        outdir = output;\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DeployParams.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-            final List<String> excludes, CopyOption... options)\n+            final List<Path> excludes, CopyOption... options)\n@@ -126,0 +126,3 @@\n+\n+        List<CopyAction> copyActions = new ArrayList<>();\n+\n@@ -129,2 +132,2 @@\n-                    final BasicFileAttributes attrs) throws IOException {\n-                if (excludes.contains(dir.toFile().getName())) {\n+                    final BasicFileAttributes attrs) {\n+                if (isPathMatch(dir, excludes)) {\n@@ -133,1 +136,2 @@\n-                    Files.createDirectories(dest.resolve(src.relativize(dir)));\n+                    copyActions.add(new CopyAction(null, dest.resolve(src.\n+                            relativize(dir))));\n@@ -140,3 +144,4 @@\n-                    final BasicFileAttributes attrs) throws IOException {\n-                if (!excludes.contains(file.toFile().getName())) {\n-                    Files.copy(file, dest.resolve(src.relativize(file)), options);\n+                    final BasicFileAttributes attrs) {\n+                if (!isPathMatch(file, excludes)) {\n+                    copyActions.add(new CopyAction(file, dest.resolve(src.\n+                            relativize(file))));\n@@ -147,0 +152,18 @@\n+\n+        for (var copyAction : copyActions) {\n+            copyAction.apply(options);\n+        }\n+    }\n+\n+    private static record CopyAction(Path src, Path dest) {\n+        void apply(CopyOption... options) throws IOException {\n+            if (src == null) {\n+                Files.createDirectories(dest);\n+            } else {\n+                Files.copy(src, dest, options);\n+            }\n+        }\n+    }\n+\n+    private static boolean isPathMatch(Path what, List<Path> paths) {\n+        return paths.stream().anyMatch(what::endsWith);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-import java.util.stream.Collectors;\n@@ -103,0 +102,8 @@\n+    static final StandardBundlerParam<Path> OUTPUT_DIR =\n+            new StandardBundlerParam<>(\n+                    Arguments.CLIOptions.OUTPUT.getId(),\n+                    Path.class,\n+                    p -> Path.of(\"\").toAbsolutePath(),\n+                    (s, p) -> Path.of(s)\n+            );\n+\n@@ -599,1 +606,1 @@\n-        final List<String> excludes = Arrays.asList(\"jmods\", \"src.zip\");\n+        final List<Path> excludes = Arrays.asList(Path.of(\"jmods\"), Path.of(\"src.zip\"));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+    final public T clearArguments() {\n+        args.clear();\n+        return (T) this;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CommandArguments.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import jdk.jpackage.test.Functional.ThrowingRunnable;\n@@ -79,0 +80,1 @@\n+        executeInDirectory = cmd.executeInDirectory;\n@@ -201,1 +203,4 @@\n-        return getArgumentValue(\"--dest\", () -> Path.of(\".\"), Path::of);\n+        var path = getArgumentValue(\"--dest\", () -> Path.of(\".\"), Path::of);\n+        return Optional.ofNullable(executeInDirectory).map(base -> {\n+            return base.resolve(path);\n+        }).orElse(path);\n@@ -694,0 +699,6 @@\n+    public JPackageCommand setDirectory(Path v) {\n+        verifyMutable();\n+        executeInDirectory = v;\n+        return this;\n+    }\n+\n@@ -736,0 +747,1 @@\n+                .setDirectory(executeInDirectory)\n@@ -758,6 +770,7 @@\n-            if (isImagePackageType()) {\n-                TKit.deleteDirectoryContentsRecursive(outputDir());\n-            } else {\n-                nullableOutputBundle().ifPresent(path -> {\n-                    if (ThrowingSupplier.toSupplier(() -> TKit.deleteIfExists(\n-                            path)).get()) {\n+            nullableOutputBundle().ifPresent(path -> {\n+                ThrowingRunnable.toRunnable(() -> {\n+                    if (Files.isDirectory(path)) {\n+                        TKit.deleteDirectoryRecursive(path, String.format(\n+                                \"Delete [%s] folder before running jpackage\",\n+                                path));\n+                    } else if (TKit.deleteIfExists(path)) {\n@@ -768,2 +781,2 @@\n-                });\n-            }\n+                }).run();\n+            });\n@@ -1114,0 +1127,1 @@\n+    private Path executeInDirectory;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -219,1 +219,3 @@\n-            desc.setClassName(components[0]);\n+            if (!components[0].isEmpty()) {\n+                desc.setClassName(components[0]);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JavaAppDesc.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,9 @@\n+    public PackageTest ignoreBundleOutputDir() {\n+        return ignoreBundleOutputDir(true);\n+    }\n+\n+    public PackageTest ignoreBundleOutputDir(boolean v) {\n+        ignoreBundleOutputDir = v;\n+        return this;\n+    }\n+\n@@ -531,1 +540,1 @@\n-                if (BUNDLE_OUTPUT_DIR != null) {\n+                if (BUNDLE_OUTPUT_DIR != null && !ignoreBundleOutputDir) {\n@@ -780,0 +789,1 @@\n+    private boolean ignoreBundleOutputDir;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,0 @@\n-import java.nio.file.Path;\n-import java.io.IOException;\n@@ -30,1 +28,0 @@\n-import org.junit.Before;\n@@ -43,5 +40,0 @@\n-    @Before\n-    public void setUp() throws IOException {\n-        testRoot = tempFolder.newFolder().toPath();\n-    }\n-\n@@ -118,1 +110,0 @@\n-        params.setOutput(testRoot);\n@@ -131,1 +122,0 @@\n-    private Path testRoot = null;\n","filename":"test\/jdk\/tools\/jpackage\/junit\/jdk.jpackage\/jdk\/jpackage\/internal\/DeployParamsTest.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.AppImageFile;\n+import jdk.jpackage.internal.ApplicationLayout;\n+import jdk.jpackage.internal.PackageFile;\n+import jdk.jpackage.test.Annotations;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Functional.ThrowingConsumer;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.PackageTest;\n+import static jdk.jpackage.test.RunnablePackageTest.Action.CREATE_AND_UNPACK;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary Test jpackage command line with overlapping input and output paths\n+ * @library ..\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile InOutPathTest.java\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=InOutPathTest\n+ *\/\n+public final class InOutPathTest {\n+\n+    @Annotations.Parameters\n+    public static Collection input() {\n+        List<Object[]> data = new ArrayList<>();\n+\n+        data.addAll(List.of(new Object[][]{\n+            {wrap(InOutPathTest::outputDirInInputDir, \"--dest:subdir\")},\n+            {wrap(InOutPathTest::outputDirSameAsInputDir, \"--dest:same\")},\n+            {wrap(InOutPathTest::tempDirInInputDir, \"--temp\")},\n+            {wrap(cmd -> {\n+                outputDirInInputDir(cmd);\n+                tempDirInInputDir(cmd);\n+            }, \"--dest:subdir and --temp\")},\n+        }));\n+\n+        return data;\n+    }\n+\n+    public InOutPathTest(Envelope configure) {\n+        this.configure = configure.value;\n+    }\n+\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void test(boolean appImage) throws Throwable {\n+        runTest(appImage, configure);\n+    }\n+\n+    private static Envelope wrap(ThrowingConsumer<JPackageCommand> v, String label) {\n+        return new Envelope(v, label);\n+    }\n+\n+    private static void runTest(boolean appImage,\n+            ThrowingConsumer<JPackageCommand> configure) throws Throwable {\n+        ThrowingConsumer<JPackageCommand> configureWrapper = cmd -> {\n+            \/\/ Make sure the input directory is empty in every test run.\n+            \/\/ This is needed because jpackage output directories in this test\n+            \/\/ are subdirectories of the input directory.\n+            cmd.setInputToEmptyDirectory();\n+            configure.accept(cmd);\n+            if (cmd.hasArgument(\"--temp\")) {\n+                \/\/ If temp directory specified always create Java runtime to\n+                \/\/ make use of it\n+                cmd.ignoreDefaultRuntime(true);\n+            } else {\n+                cmd.setFakeRuntime();\n+            }\n+        };\n+\n+        if (appImage) {\n+            JPackageCommand cmd = JPackageCommand.helloAppImage(JAR_NAME + \":\");\n+            configureWrapper.accept(cmd);\n+            cmd.executeAndAssertHelloAppImageCreated();\n+            verifyAppImage(cmd);\n+        } else {\n+            new PackageTest()\n+                    .configureHelloApp(JAR_NAME + \":\")\n+                    .addInitializer(configureWrapper)\n+                    .addInstallVerifier(InOutPathTest::verifyAppImage)\n+                    .run(CREATE_AND_UNPACK);\n+        }\n+    }\n+\n+    private static void outputDirInInputDir(JPackageCommand cmd) throws\n+            IOException {\n+        \/\/ Set output dir as a subdir of input dir\n+        Path outputDir = cmd.inputDir().resolve(\"out\");\n+        TKit.createDirectories(outputDir);\n+        cmd.setArgumentValue(\"--dest\", outputDir);\n+    }\n+\n+    private static void outputDirSameAsInputDir(JPackageCommand cmd) throws\n+            IOException {\n+        \/\/ Set output dir the same as the input dir\n+        cmd.setArgumentValue(\"--dest\", cmd.inputDir());\n+    }\n+\n+    private static void tempDirInInputDir(JPackageCommand cmd) {\n+        \/\/ Set temp dir as a subdir of input dir\n+        Path tmpDir = cmd.inputDir().resolve(\"tmp\");\n+        cmd.setArgumentValue(\"--temp\", tmpDir);\n+    }\n+\n+    private static void verifyAppImage(JPackageCommand cmd) throws IOException {\n+        final Path rootDir = cmd.isImagePackageType() ? cmd.outputBundle() : cmd.pathToUnpackedPackageFile(\n+                cmd.appInstallationDirectory());\n+        final Path appDir = ApplicationLayout.platformAppImage().resolveAt(\n+                rootDir).appDirectory();\n+\n+        final var knownFiles = Set.of(\n+                JAR_NAME,\n+                PackageFile.getPathInAppImage(Path.of(\"\")).getFileName().toString(),\n+                AppImageFile.getPathInAppImage(Path.of(\"\")).getFileName().toString(),\n+                cmd.name() + \".cfg\"\n+        );\n+\n+        TKit.assertFileExists(appDir.resolve(JAR_NAME));\n+\n+        try (Stream<Path> actualFilesStream = Files.list(appDir)) {\n+            var unexpectedFiles = actualFilesStream.map(path -> {\n+                return path.getFileName().toString();\n+            }).filter(Predicate.not(knownFiles::contains)).toList();\n+            TKit.assertStringListEquals(List.of(), unexpectedFiles,\n+                    \"Check there are no unexpected files in `app` folder\");\n+        }\n+    }\n+\n+    private final static record Envelope(ThrowingConsumer<JPackageCommand> value, String label) {\n+        @Override\n+        public String toString() {\n+            \/\/ Will produce the same test description for the same label every\n+            \/\/ time it's executed.\n+            \/\/ The test runner will keep the same test output directory.\n+            return label;\n+        }\n+    }\n+\n+    private final ThrowingConsumer<JPackageCommand> configure;\n+\n+    private final static String JAR_NAME = \"duke.jar\";\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -45,0 +46,2 @@\n+import jdk.jpackage.test.Functional.ThrowingConsumer;\n+import static jdk.jpackage.test.RunnablePackageTest.Action.CREATE_AND_UNPACK;\n@@ -253,0 +256,57 @@\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testNoOutputDir(boolean appImage) throws Throwable {\n+        var cmd = JPackageCommand.helloAppImage();\n+\n+        final var execDir = cmd.outputDir();\n+\n+        final ThrowingConsumer<JPackageCommand> initializer = cmdNoOutputDir -> {\n+            cmd.executePrerequisiteActions();\n+\n+            final var pkgType = cmdNoOutputDir.packageType();\n+\n+            cmdNoOutputDir\n+                    .clearArguments()\n+                    .addArguments(cmd.getAllArguments())\n+                    \/\/ Restore the value of `--type` parameter.\n+                    .setPackageType(pkgType)\n+                    .removeArgumentWithValue(\"--dest\")\n+                    .setArgumentValue(\"--input\", execDir.relativize(cmd.inputDir()))\n+                    .setDirectory(execDir)\n+                    \/\/ Force to use jpackage as executable because we need to\n+                    \/\/ change the current directory.\n+                    .useToolProvider(false);\n+\n+            Optional.ofNullable(cmdNoOutputDir.getArgumentValue(\"--runtime-image\",\n+                    () -> null, Path::of)).ifPresent(runtimePath -> {\n+                        if (!runtimePath.isAbsolute()) {\n+                            cmdNoOutputDir.setArgumentValue(\"--runtime-image\",\n+                                    execDir.relativize(runtimePath));\n+                        }\n+                    });\n+\n+            \/\/ JPackageCommand.execute() will not do the cleanup if `--dest` parameter\n+            \/\/ is not specified, do it manually.\n+            TKit.createDirectories(execDir);\n+            TKit.deleteDirectoryContentsRecursive(execDir);\n+        };\n+\n+        if (appImage) {\n+            var cmdNoOutputDir = new JPackageCommand()\n+                    .setPackageType(cmd.packageType());\n+            initializer.accept(cmdNoOutputDir);\n+            cmdNoOutputDir.executeAndAssertHelloAppImageCreated();\n+        } else {\n+            \/\/ Save time by packing non-functional runtime.\n+            \/\/ Build the runtime in app image only. This is sufficient coverage.\n+            cmd.setFakeRuntime();\n+            new PackageTest()\n+                    .addInitializer(initializer)\n+                    .addInstallVerifier(HelloApp::executeLauncherAndVerifyOutput)\n+                    \/\/ Prevent adding `--dest` parameter to jpackage command line.\n+                    .ignoreBundleOutputDir()\n+                    .run(CREATE_AND_UNPACK);\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/BasicTest.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"}]}