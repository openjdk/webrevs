{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.nio.file.Files;\n@@ -31,0 +32,1 @@\n+import java.util.ArrayList;\n@@ -33,0 +35,2 @@\n+import java.util.Objects;\n+import java.util.stream.Stream;\n@@ -38,0 +42,2 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.OUTPUT_DIR;\n+import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n@@ -76,2 +82,15 @@\n-            IOUtils.copyRecursive(SOURCE_DIR.fetchFrom(params),\n-                    appLayout.appDirectory());\n+            inputPath = inputPath.toAbsolutePath();\n+\n+            List<Path> excludes = new ArrayList<>();\n+\n+            for (var path : List.of(TEMP_ROOT.fetchFrom(params), OUTPUT_DIR.fetchFrom(params), root)) {\n+                if (Files.isDirectory(path)) {\n+                    path = path.toAbsolutePath();\n+                    if (path.startsWith(inputPath) && !Files.isSameFile(path, inputPath)) {\n+                        excludes.add(path);\n+                    }\n+                }\n+            }\n+\n+            IOUtils.copyRecursive(inputPath,\n+                    appLayout.appDirectory().toAbsolutePath(), excludes);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AbstractAppImageBuilder.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,3 +92,0 @@\n-    private String input = null;\n-    private Path output = null;\n-\n@@ -138,3 +135,0 @@\n-\n-        output = Paths.get(\"\").toAbsolutePath();\n-        deployParams.setOutput(output);\n@@ -150,2 +144,1 @@\n-            context().input = popArg();\n-            setOptionValue(\"input\", context().input);\n+            setOptionValue(\"input\", popArg());\n@@ -155,2 +148,2 @@\n-            context().output = Path.of(popArg());\n-            context().deployParams.setOutput(context().output);\n+            var path = Path.of(popArg());\n+            setOptionValue(\"dest\", path);\n@@ -714,1 +707,2 @@\n-            Path result = bundler.execute(localParams, deployParams.outdir);\n+            Path result = bundler.execute(localParams,\n+                    StandardBundlerParam.OUTPUT_DIR.fetchFrom(params));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,2 +52,0 @@\n-    Path outdir = null;\n-\n@@ -57,4 +55,0 @@\n-    public void setOutput(Path output) {\n-        outdir = output;\n-    }\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DeployParams.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-            final List<String> excludes, CopyOption... options)\n+            final List<Path> excludes, CopyOption... options)\n@@ -126,0 +126,3 @@\n+\n+        List<CopyAction> copyActions = new ArrayList<>();\n+\n@@ -129,2 +132,2 @@\n-                    final BasicFileAttributes attrs) throws IOException {\n-                if (excludes.contains(dir.toFile().getName())) {\n+                    final BasicFileAttributes attrs) {\n+                if (isPathMatch(dir, excludes)) {\n@@ -133,1 +136,2 @@\n-                    Files.createDirectories(dest.resolve(src.relativize(dir)));\n+                    copyActions.add(new CopyAction(null, dest.resolve(src.\n+                            relativize(dir))));\n@@ -140,3 +144,4 @@\n-                    final BasicFileAttributes attrs) throws IOException {\n-                if (!excludes.contains(file.toFile().getName())) {\n-                    Files.copy(file, dest.resolve(src.relativize(file)), options);\n+                    final BasicFileAttributes attrs) {\n+                if (!isPathMatch(file, excludes)) {\n+                    copyActions.add(new CopyAction(file, dest.resolve(src.\n+                            relativize(file))));\n@@ -147,0 +152,18 @@\n+\n+        for (var copyAction : copyActions) {\n+            copyAction.apply(options);\n+        }\n+    }\n+\n+    private static record CopyAction(Path src, Path dest) {\n+        void apply(CopyOption... options) throws IOException {\n+            if (src == null) {\n+                Files.createDirectories(dest);\n+            } else {\n+                Files.copy(src, dest, options);\n+            }\n+        }\n+    }\n+\n+    private static boolean isPathMatch(Path what, List<Path> paths) {\n+        return paths.stream().anyMatch(what::endsWith);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-import java.util.stream.Collectors;\n@@ -103,0 +102,8 @@\n+    static final StandardBundlerParam<Path> OUTPUT_DIR =\n+            new StandardBundlerParam<>(\n+                    Arguments.CLIOptions.OUTPUT.getId(),\n+                    Path.class,\n+                    p -> Path.of(\"\").toAbsolutePath(),\n+                    (s, p) -> Path.of(s)\n+            );\n+\n@@ -599,1 +606,1 @@\n-        final List<String> excludes = Arrays.asList(\"jmods\", \"src.zip\");\n+        final List<Path> excludes = Arrays.asList(Path.of(\"jmods\"), Path.of(\"src.zip\"));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+    final public T clearArguments() {\n+        args.clear();\n+        return (T) this;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CommandArguments.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import jdk.jpackage.test.Functional.ThrowingRunnable;\n@@ -79,0 +80,2 @@\n+        appLayoutAsserts = cmd.appLayoutAsserts;\n+        executeInDirectory = cmd.executeInDirectory;\n@@ -201,1 +204,4 @@\n-        return getArgumentValue(\"--dest\", () -> Path.of(\".\"), Path::of);\n+        var path = getArgumentValue(\"--dest\", () -> Path.of(\".\"), Path::of);\n+        return Optional.ofNullable(executeInDirectory).map(base -> {\n+            return base.resolve(path);\n+        }).orElse(path);\n@@ -694,0 +700,6 @@\n+    public JPackageCommand setDirectory(Path v) {\n+        verifyMutable();\n+        executeInDirectory = v;\n+        return this;\n+    }\n+\n@@ -736,0 +748,1 @@\n+                .setDirectory(executeInDirectory)\n@@ -758,6 +771,7 @@\n-            if (isImagePackageType()) {\n-                TKit.deleteDirectoryContentsRecursive(outputDir());\n-            } else {\n-                nullableOutputBundle().ifPresent(path -> {\n-                    if (ThrowingSupplier.toSupplier(() -> TKit.deleteIfExists(\n-                            path)).get()) {\n+            nullableOutputBundle().ifPresent(path -> {\n+                ThrowingRunnable.toRunnable(() -> {\n+                    if (Files.isDirectory(path)) {\n+                        TKit.deleteDirectoryRecursive(path, String.format(\n+                                \"Delete [%s] folder before running jpackage\",\n+                                path));\n+                    } else if (TKit.deleteIfExists(path)) {\n@@ -768,2 +782,2 @@\n-                });\n-            }\n+                }).run();\n+            });\n@@ -819,3 +833,16 @@\n-    JPackageCommand assertAppLayout() {\n-        assertAppImageFile();\n-        assertPackageFile();\n+    public static enum AppLayoutAssert {\n+        AppImageFile(JPackageCommand::assertAppImageFile),\n+        PackageFile(JPackageCommand::assertPackageFile),\n+        MainLauncher(cmd -> {\n+            TKit.assertExecutableFileExists(cmd.appLauncherPath());\n+        }),\n+        MainLauncherCfgFile(cmd -> {\n+            TKit.assertFileExists(cmd.appLauncherCfgPath(null));\n+        }),\n+        RuntimeDirectory(cmd -> {\n+            TKit.assertDirectoryExists(cmd.appRuntimeDirectory());\n+                if (TKit.isOSX() && !cmd.isRuntime()) {\n+                    TKit.assertFileExists(cmd.appRuntimeDirectory().resolve(\n+                            \"Contents\/MacOS\/libjli.dylib\"));\n+                }\n+        });\n@@ -823,1 +850,3 @@\n-        TKit.assertDirectoryExists(appRuntimeDirectory());\n+        AppLayoutAssert(Consumer<JPackageCommand> action) {\n+            this.action = action;\n+        }\n@@ -825,3 +854,2 @@\n-        if (!isRuntime()) {\n-            TKit.assertExecutableFileExists(appLauncherPath());\n-            TKit.assertFileExists(appLauncherCfgPath(null));\n+        private final Consumer<JPackageCommand> action;\n+    }\n@@ -829,5 +857,4 @@\n-            if (TKit.isOSX()) {\n-                TKit.assertFileExists(appRuntimeDirectory().resolve(\n-                        \"Contents\/MacOS\/libjli.dylib\"));\n-            }\n-        }\n+    public JPackageCommand setAppLayoutAsserts(AppLayoutAssert ... asserts) {\n+        this.appLayoutAsserts = Set.of(asserts);\n+        return this;\n+    }\n@@ -835,0 +862,4 @@\n+    JPackageCommand assertAppLayout() {\n+        for (var appLayoutAssert : appLayoutAsserts.stream().sorted().toList()) {\n+            appLayoutAssert.action.accept(this);\n+        }\n@@ -1114,0 +1145,2 @@\n+    private Path executeInDirectory;\n+    private Set<AppLayoutAssert> appLayoutAsserts = Set.of(AppLayoutAssert.values());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":55,"deletions":22,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -219,1 +219,3 @@\n-            desc.setClassName(components[0]);\n+            if (!components[0].isEmpty()) {\n+                desc.setClassName(components[0]);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JavaAppDesc.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,9 @@\n+    public PackageTest ignoreBundleOutputDir() {\n+        return ignoreBundleOutputDir(true);\n+    }\n+\n+    public PackageTest ignoreBundleOutputDir(boolean v) {\n+        ignoreBundleOutputDir = v;\n+        return this;\n+    }\n+\n@@ -531,1 +540,1 @@\n-                if (BUNDLE_OUTPUT_DIR != null) {\n+                if (BUNDLE_OUTPUT_DIR != null && !ignoreBundleOutputDir) {\n@@ -780,0 +789,1 @@\n+    private boolean ignoreBundleOutputDir;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,0 @@\n-import java.nio.file.Path;\n-import java.io.IOException;\n@@ -30,1 +28,0 @@\n-import org.junit.Before;\n@@ -43,5 +40,0 @@\n-    @Before\n-    public void setUp() throws IOException {\n-        testRoot = tempFolder.newFolder().toPath();\n-    }\n-\n@@ -118,1 +110,0 @@\n-        params.setOutput(testRoot);\n@@ -131,1 +122,0 @@\n-    private Path testRoot = null;\n","filename":"test\/jdk\/tools\/jpackage\/junit\/jdk.jpackage\/jdk\/jpackage\/internal\/DeployParamsTest.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import static java.util.stream.Collectors.toSet;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.AppImageFile;\n+import jdk.jpackage.internal.ApplicationLayout;\n+import jdk.jpackage.internal.PackageFile;\n+import jdk.jpackage.test.Annotations;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Functional.ThrowingConsumer;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import static jdk.jpackage.test.RunnablePackageTest.Action.CREATE_AND_UNPACK;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary Test jpackage command line with overlapping input and output paths\n+ * @library ..\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile InOutPathTest.java\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=InOutPathTest\n+ *\/\n+public final class InOutPathTest {\n+\n+    @Annotations.Parameters\n+    public static Collection input() {\n+        List<Object[]> data = new ArrayList<>();\n+\n+        for (var packageTypes : List.of(PackageType.IMAGE.toString(), ALL_NATIVE_PACKAGE_TYPES)) {\n+            data.addAll(List.of(new Object[][]{\n+                {packageTypes, wrap(InOutPathTest::outputDirInInputDir, \"--dest in --input\")},\n+                {packageTypes, wrap(InOutPathTest::outputDirSameAsInputDir, \"--dest same as --input\")},\n+                {packageTypes, wrap(InOutPathTest::tempDirInInputDir, \"--temp in --input\")},\n+                {packageTypes, wrap(cmd -> {\n+                    outputDirInInputDir(cmd);\n+                    tempDirInInputDir(cmd);\n+                }, \"--dest and --temp in --input\")},\n+            }));\n+            data.addAll(additionalContentInput(packageTypes, \"--app-content\"));\n+        }\n+\n+        data.addAll(List.of(new Object[][]{\n+            {PackageType.IMAGE.toString(), wrap(cmd -> {\n+                additionalContent(cmd, \"--app-content\", cmd.outputBundle());\n+            }, \"--app-content same as output bundle\")},\n+        }));\n+\n+        if (TKit.isOSX()) {\n+            data.addAll(additionalContentInput(PackageType.MAC_DMG.toString(),\n+                    \"--mac-dmg-content\"));\n+        }\n+\n+        return data;\n+    }\n+\n+    private static List<Object[]> additionalContentInput(String packageTypes, String argName) {\n+        return List.of(new Object[][]{\n+            {packageTypes, wrap(cmd -> {\n+                additionalContent(cmd, argName, cmd.inputDir().resolve(\"foo\"));\n+            }, argName + \" in --input\")},\n+            {packageTypes, wrap(cmd -> {\n+                additionalContent(cmd, argName, cmd.inputDir());\n+            }, argName + \" same as --input\")},\n+            {packageTypes, wrap(cmd -> {\n+                additionalContent(cmd, argName, cmd.outputDir().resolve(\"bar\"));\n+            }, argName + \" in --dest\")},\n+            {packageTypes, wrap(cmd -> {\n+                additionalContent(cmd, argName, cmd.outputDir());\n+            }, argName + \" same as --dest\")},\n+            {packageTypes, wrap(cmd -> {\n+                tempDirInInputDir(cmd);\n+                var tempDir = cmd.getArgumentValue(\"--temp\");\n+                Files.createDirectory(Path.of(tempDir));\n+                cmd.addArguments(argName, tempDir);\n+            }, argName + \" as --temp; --temp in --input\")},\n+        });\n+    }\n+\n+    public InOutPathTest(String packageTypes, Envelope configure) {\n+        if (ALL_NATIVE_PACKAGE_TYPES.equals(packageTypes)) {\n+            this.packageTypes = PackageType.NATIVE;\n+        } else {\n+            this.packageTypes = Stream.of(packageTypes.split(\",\")).map(\n+                    PackageType::valueOf).collect(toSet());\n+        }\n+        this.configure = configure.value;\n+    }\n+\n+    @Test\n+    public void test() throws Throwable {\n+        runTest(packageTypes, configure);\n+    }\n+\n+    private static Envelope wrap(ThrowingConsumer<JPackageCommand> v, String label) {\n+        return new Envelope(v, label);\n+    }\n+\n+    private static boolean isAppImageValid(JPackageCommand cmd) {\n+        return !cmd.hasArgument(\"--app-content\") && !cmd.hasArgument(\"--dmg-app-content\");\n+    }\n+\n+    private static void runTest(Set<PackageType> packageTypes,\n+            ThrowingConsumer<JPackageCommand> configure) throws Throwable {\n+        ThrowingConsumer<JPackageCommand> configureWrapper = cmd -> {\n+            \/\/ Make sure the input directory is empty in every test run.\n+            \/\/ This is needed because jpackage output directories in this test\n+            \/\/ are subdirectories of the input directory.\n+            cmd.setInputToEmptyDirectory();\n+            configure.accept(cmd);\n+            if (cmd.hasArgument(\"--temp\")) {\n+                \/\/ If temp directory specified always create Java runtime to\n+                \/\/ make use of it\n+                cmd.ignoreDefaultRuntime(true);\n+            } else {\n+                cmd.setFakeRuntime();\n+            }\n+\n+            if (!isAppImageValid(cmd)) {\n+                cmd.setAppLayoutAsserts(\n+                        JPackageCommand.AppLayoutAssert.MainLauncher,\n+                        JPackageCommand.AppLayoutAssert.MainLauncherCfgFile,\n+                        JPackageCommand.AppLayoutAssert.RuntimeDirectory);\n+            }\n+        };\n+\n+        if (packageTypes.contains(PackageType.IMAGE)) {\n+            JPackageCommand cmd = JPackageCommand.helloAppImage(JAR_NAME + \":\");\n+            configureWrapper.accept(cmd);\n+            cmd.executeAndAssertHelloAppImageCreated();\n+            if (isAppImageValid(cmd)) {\n+                verifyAppImage(cmd);\n+            }\n+        } else {\n+            new PackageTest()\n+                    .forTypes(packageTypes)\n+                    .configureHelloApp(JAR_NAME + \":\")\n+                    .addInitializer(configureWrapper)\n+                    .addInstallVerifier(InOutPathTest::verifyAppImage)\n+                    .run(CREATE_AND_UNPACK);\n+        }\n+    }\n+\n+    private static void outputDirInInputDir(JPackageCommand cmd) throws\n+            IOException {\n+        \/\/ Set output dir as a subdir of input dir\n+        Path outputDir = cmd.inputDir().resolve(\"out\");\n+        TKit.createDirectories(outputDir);\n+        cmd.setArgumentValue(\"--dest\", outputDir);\n+    }\n+\n+    private static void outputDirSameAsInputDir(JPackageCommand cmd) throws\n+            IOException {\n+        \/\/ Set output dir the same as the input dir\n+        cmd.setArgumentValue(\"--dest\", cmd.inputDir());\n+    }\n+\n+    private static void tempDirInInputDir(JPackageCommand cmd) {\n+        \/\/ Set temp dir as a subdir of input dir\n+        Path tmpDir = cmd.inputDir().resolve(\"tmp\");\n+        cmd.setArgumentValue(\"--temp\", tmpDir);\n+    }\n+\n+    private static void additionalContent(JPackageCommand cmd,\n+            String argName, Path base) throws IOException {\n+        Path appContentFile = base.resolve(base.toString().replaceAll(\"[\\\\\\\\\/]\",\n+                \"-\") + \"-foo.txt\");\n+        TKit.createDirectories(appContentFile.getParent());\n+        TKit.createTextFile(appContentFile, List.of(\"Hello Duke!\"));\n+        cmd.addArguments(argName, appContentFile.getParent());\n+    }\n+\n+    private static void verifyAppImage(JPackageCommand cmd) throws IOException {\n+        if (!isAppImageValid(cmd)) {\n+            \/\/ Don't verify the contents of app image as it is invalid.\n+            \/\/ jpackage exited without getting stuck in infinite spiral.\n+            \/\/ No more expectations from the tool for the give arguments.\n+            return;\n+        }\n+\n+        final Path rootDir = cmd.isImagePackageType() ? cmd.outputBundle() : cmd.pathToUnpackedPackageFile(\n+                cmd.appInstallationDirectory());\n+        final Path appDir = ApplicationLayout.platformAppImage().resolveAt(\n+                rootDir).appDirectory();\n+\n+        final var knownFiles = Set.of(\n+                JAR_NAME,\n+                PackageFile.getPathInAppImage(Path.of(\"\")).getFileName().toString(),\n+                AppImageFile.getPathInAppImage(Path.of(\"\")).getFileName().toString(),\n+                cmd.name() + \".cfg\"\n+        );\n+\n+        TKit.assertFileExists(appDir.resolve(JAR_NAME));\n+\n+        try (Stream<Path> actualFilesStream = Files.list(appDir)) {\n+            var unexpectedFiles = actualFilesStream.map(path -> {\n+                return path.getFileName().toString();\n+            }).filter(Predicate.not(knownFiles::contains)).toList();\n+            TKit.assertStringListEquals(List.of(), unexpectedFiles,\n+                    \"Check there are no unexpected files in `app` folder\");\n+        }\n+    }\n+\n+    private final static record Envelope(ThrowingConsumer<JPackageCommand> value, String label) {\n+        @Override\n+        public String toString() {\n+            \/\/ Will produce the same test description for the same label every\n+            \/\/ time it's executed.\n+            \/\/ The test runner will keep the same test output directory.\n+            return label;\n+        }\n+    }\n+\n+    private final Set<PackageType> packageTypes;\n+    private final ThrowingConsumer<JPackageCommand> configure;\n+\n+    private final static String JAR_NAME = \"duke.jar\";\n+\n+    private final static String ALL_NATIVE_PACKAGE_TYPES = \"NATIVE\";\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.util.Optional;\n@@ -45,0 +46,2 @@\n+import jdk.jpackage.test.Functional.ThrowingConsumer;\n+import static jdk.jpackage.test.RunnablePackageTest.Action.CREATE_AND_UNPACK;\n@@ -253,0 +256,57 @@\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testNoOutputDir(boolean appImage) throws Throwable {\n+        var cmd = JPackageCommand.helloAppImage();\n+\n+        final var execDir = cmd.outputDir();\n+\n+        final ThrowingConsumer<JPackageCommand> initializer = cmdNoOutputDir -> {\n+            cmd.executePrerequisiteActions();\n+\n+            final var pkgType = cmdNoOutputDir.packageType();\n+\n+            cmdNoOutputDir\n+                    .clearArguments()\n+                    .addArguments(cmd.getAllArguments())\n+                    \/\/ Restore the value of `--type` parameter.\n+                    .setPackageType(pkgType)\n+                    .removeArgumentWithValue(\"--dest\")\n+                    .setArgumentValue(\"--input\", execDir.relativize(cmd.inputDir()))\n+                    .setDirectory(execDir)\n+                    \/\/ Force to use jpackage as executable because we need to\n+                    \/\/ change the current directory.\n+                    .useToolProvider(false);\n+\n+            Optional.ofNullable(cmdNoOutputDir.getArgumentValue(\"--runtime-image\",\n+                    () -> null, Path::of)).ifPresent(runtimePath -> {\n+                        if (!runtimePath.isAbsolute()) {\n+                            cmdNoOutputDir.setArgumentValue(\"--runtime-image\",\n+                                    execDir.relativize(runtimePath));\n+                        }\n+                    });\n+\n+            \/\/ JPackageCommand.execute() will not do the cleanup if `--dest` parameter\n+            \/\/ is not specified, do it manually.\n+            TKit.createDirectories(execDir);\n+            TKit.deleteDirectoryContentsRecursive(execDir);\n+        };\n+\n+        if (appImage) {\n+            var cmdNoOutputDir = new JPackageCommand()\n+                    .setPackageType(cmd.packageType());\n+            initializer.accept(cmdNoOutputDir);\n+            cmdNoOutputDir.executeAndAssertHelloAppImageCreated();\n+        } else {\n+            \/\/ Save time by packing non-functional runtime.\n+            \/\/ Build the runtime in app image only. This is sufficient coverage.\n+            cmd.setFakeRuntime();\n+            new PackageTest()\n+                    .addInitializer(initializer)\n+                    .addInstallVerifier(HelloApp::executeLauncherAndVerifyOutput)\n+                    \/\/ Prevent adding `--dest` parameter to jpackage command line.\n+                    .ignoreBundleOutputDir()\n+                    .run(CREATE_AND_UNPACK);\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/BasicTest.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"}]}