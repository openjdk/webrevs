{"files":[{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import static java.util.stream.Collectors.toSet;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import jdk.jpackage.test.Annotations.Test;\n+import static jdk.jpackage.test.DirectoryContentVerifierTest.AssertType.CONTAINS;\n+import static jdk.jpackage.test.DirectoryContentVerifierTest.AssertType.EQUALS;\n+import jdk.jpackage.test.TKit.DirectoryContentVerifier;\n+import static jdk.jpackage.test.TKit.assertAssert;\n+\n+\/*\n+ * @test\n+ * @summary Test TKit.DirectoryContentVerifier from jpackage test library\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile DirectoryContentVerifierTest.java\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=jdk.jpackage.test.DirectoryContentVerifierTest\n+ *\/\n+public class DirectoryContentVerifierTest {\n+\n+    enum AssertType {\n+        EQUALS(DirectoryContentVerifier::equals),\n+        CONTAINS(DirectoryContentVerifier::contains),\n+        ;\n+\n+        AssertType(BiConsumer<DirectoryContentVerifier, Set<Path>> assertFunc) {\n+            this.assertFunc = assertFunc;\n+        }\n+\n+        private final BiConsumer<DirectoryContentVerifier, Set<Path>> assertFunc;\n+    }\n+\n+    private static ArgsBuilder buildArgs() {\n+        return new ArgsBuilder();\n+    }\n+\n+    private static class ArgsBuilder {\n+\n+        void applyTo(List<Object[]> data) {\n+            data.add(new Object[]{expectedPaths, actualPaths, assertOp, success});\n+        }\n+\n+        void applyVariantsTo(List<Object[]> data) {\n+            applyTo(data);\n+            boolean pathGroupsEqual = List.of(expectedPaths).equals(List.of(actualPaths));\n+            if (assertOp == EQUALS) {\n+                if (!pathGroupsEqual) {\n+                    data.add(new Object[]{actualPaths, expectedPaths, EQUALS, success});\n+                }\n+                if (success) {\n+                    data.add(new Object[]{expectedPaths, actualPaths, CONTAINS, success});\n+                    if (!pathGroupsEqual) {\n+                        data.add(new Object[]{actualPaths, expectedPaths, CONTAINS, success});\n+                    }\n+                }\n+            }\n+        }\n+\n+        ArgsBuilder expectedPaths(String... paths) {\n+            expectedPaths = paths;\n+            return this;\n+        }\n+\n+        ArgsBuilder actualPaths(String... paths) {\n+            actualPaths = paths;\n+            return this;\n+        }\n+\n+        ArgsBuilder assertOp(AssertType v) {\n+            assertOp = v;\n+            return this;\n+        }\n+\n+        ArgsBuilder expectFail() {\n+            success = false;\n+            return this;\n+        }\n+\n+        private String[] expectedPaths = new String[0];\n+        private String[] actualPaths = new String[0];\n+        private AssertType assertOp = EQUALS;\n+        private boolean success = true;\n+    }\n+\n+    @Parameters\n+    public static Collection input() {\n+        List<Object[]> data = new ArrayList<>();\n+        buildArgs().applyVariantsTo(data);\n+        buildArgs().actualPaths(\"foo\").assertOp(CONTAINS).applyTo(data);\n+        buildArgs().actualPaths(\"zoo\").expectFail().applyVariantsTo(data);\n+        buildArgs().actualPaths(\"boo\").expectedPaths(\"boo\").applyVariantsTo(data);\n+        if (TKit.isWindows()) {\n+            buildArgs().actualPaths(\"moo\").expectedPaths(\"Moo\").applyVariantsTo(data);\n+        } else {\n+            buildArgs().actualPaths(\"moo\").expectedPaths(\"Moo\").expectFail().applyVariantsTo(data);\n+        }\n+        buildArgs().actualPaths(\"hello\").expectedPaths().expectFail().applyVariantsTo(data);\n+        buildArgs().actualPaths(\"123\").expectedPaths(\"456\").expectFail().applyVariantsTo(data);\n+        buildArgs().actualPaths(\"a\", \"b\", \"c\").expectedPaths(\"b\", \"a\", \"c\").applyVariantsTo(data);\n+        buildArgs().actualPaths(\"AA\", \"BB\", \"CC\").expectedPaths(\"BB\", \"AA\").expectFail().applyVariantsTo(data);\n+        buildArgs().actualPaths(\"AA\", \"BB\", \"CC\").expectedPaths(\"BB\", \"AA\").assertOp(CONTAINS).applyTo(data);\n+        buildArgs().actualPaths(\"AA\", \"BB\", \"CC\").expectedPaths(\"BB\", \"DD\", \"AA\").expectFail().assertOp(CONTAINS).applyTo(data);\n+        buildArgs().actualPaths(\"AA\", \"BB\", \"CC\").expectedPaths(\"BB\", \"DD\", \"AA\").expectFail().applyTo(data);\n+        return data;\n+    }\n+\n+    public DirectoryContentVerifierTest(String[] expectedPaths, String[] actualPaths,\n+            AssertType assertOp, Boolean success) {\n+        this.expectedPaths = conv(expectedPaths);\n+        this.actualPaths = conv(actualPaths);\n+        this.assertOp = assertOp;\n+        this.success = success;\n+    }\n+\n+    @Test\n+    public void test() {\n+        TKit.withTempDirectory(\"basedir\", this::test);\n+    }\n+\n+    private void test(Path basedir) throws IOException {\n+        for (var path : actualPaths) {\n+            Files.createFile(basedir.resolve(path));\n+        }\n+\n+        var testee = TKit.assertDirectoryContent(basedir);\n+\n+        assertAssert(success, () -> assertOp.assertFunc.accept(testee, expectedPaths));\n+    }\n+\n+    private static Set<Path> conv(String... paths) {\n+        return Stream.of(paths).map(Path::of).collect(toSet());\n+    }\n+\n+    private final Set<Path> expectedPaths;\n+    private final Set<Path> actualPaths;\n+    private final AssertType assertOp;\n+    private final boolean success;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers-test\/jdk\/jpackage\/test\/DirectoryContentVerifierTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -834,3 +834,3 @@\n-        AppImageFile(JPackageCommand::assertAppImageFile),\n-        PackageFile(JPackageCommand::assertPackageFile),\n-        MainLauncher(cmd -> {\n+        APP_IMAGE_FILE(JPackageCommand::assertAppImageFile),\n+        PACKAGE_FILE(JPackageCommand::assertPackageFile),\n+        MAIN_LAUNCHER(cmd -> {\n@@ -843,1 +843,1 @@\n-        MainLauncherCfgFile(cmd -> {\n+        MAIN_LAUNCHER_CFG_FILE(cmd -> {\n@@ -850,1 +850,1 @@\n-        RuntimeDirectory(cmd -> {\n+        RUNTIME_DIRECTORY(cmd -> {\n@@ -860,0 +860,5 @@\n+        }),\n+        MAC_BUNDLE_STRUCTURE(cmd -> {\n+            if (TKit.isOSX()) {\n+                MacHelper.verifyBundleStructure(cmd);\n+            }\n@@ -861,0 +866,1 @@\n+        ;\n@@ -877,1 +883,1 @@\n-        this.appLayoutAsserts = Set.of(asserts);\n+        appLayoutAsserts = Set.of(asserts);\n@@ -881,0 +887,5 @@\n+    public JPackageCommand excludeAppLayoutAsserts(AppLayoutAssert... asserts) {\n+        return setAppLayoutAsserts(Stream.of(asserts).filter(Predicate.not(\n+                appLayoutAsserts::contains)).toArray(AppLayoutAssert[]::new));\n+    }\n+\n@@ -1168,1 +1179,1 @@\n-    private final static Map<String, PackageType> PACKAGE_TYPES = Functional.identity(\n+    private static final Map<String, PackageType> PACKAGE_TYPES = Functional.identity(\n@@ -1177,1 +1188,1 @@\n-    public final static Path DEFAULT_RUNTIME_IMAGE = Functional.identity(() -> {\n+    public static final Path DEFAULT_RUNTIME_IMAGE = Functional.identity(() -> {\n@@ -1190,1 +1201,1 @@\n-    private final static String UNPACKED_PATH_ARGNAME = \"jpt-unpacked-folder\";\n+    private static final String UNPACKED_PATH_ARGNAME = \"jpt-unpacked-folder\";\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import static java.util.stream.Collectors.toSet;\n@@ -260,0 +261,14 @@\n+    static void verifyBundleStructure(JPackageCommand cmd) {\n+        Path bundleRoot;\n+        if (cmd.isImagePackageType()) {\n+            bundleRoot = cmd.outputBundle();\n+        } else {\n+            bundleRoot = cmd.pathToUnpackedPackageFile(\n+                    cmd.appInstallationDirectory());\n+        }\n+\n+        TKit.assertDirectoryContent(bundleRoot).equals(Path.of(\"Contents\"));\n+        TKit.assertDirectoryContent(bundleRoot.resolve(\"Contents\")).equals(\n+                cmd.isRuntime() ? RUNTIME_BUNDLE_CONTENTS : APP_BUNDLE_CONTENTS);\n+    }\n+\n@@ -393,1 +408,15 @@\n-    private final static Method getServicePListFileName = initGetServicePListFileName();\n+    private static final Method getServicePListFileName = initGetServicePListFileName();\n+\n+    private static final Set<Path> APP_BUNDLE_CONTENTS = Stream.of(\n+            \"Info.plist\",\n+            \"MacOS\",\n+            \"app\",\n+            \"runtime\",\n+            \"Resources\",\n+            \"PkgInfo\",\n+            \"_CodeSignature\"\n+    ).map(Path::of).collect(toSet());\n+\n+    private static final Set<Path> RUNTIME_BUNDLE_CONTENTS = Stream.of(\n+            \"Home\"\n+    ).map(Path::of).collect(toSet());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.Arrays;\n@@ -47,0 +48,1 @@\n+import java.util.HashSet;\n@@ -60,0 +62,1 @@\n+import static java.util.stream.Collectors.toSet;\n@@ -66,1 +69,1 @@\n-final public class TKit {\n+public final class TKit {\n@@ -87,1 +90,1 @@\n-    public final static String ICON_SUFFIX = Functional.identity(() -> {\n+    public static final String ICON_SUFFIX = Functional.identity(() -> {\n@@ -276,1 +279,17 @@\n-    private final static String TEMP_FILE_PREFIX = null;\n+    static void assertAssert(boolean expectedSuccess, Runnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (AssertionError err) {\n+            if (expectedSuccess) {\n+                assertUnexpected(\"Assertion failed\");\n+            } else {\n+                return;\n+            }\n+        }\n+\n+        if (!expectedSuccess) {\n+            assertUnexpected(\"Assertion passed\");\n+        }\n+    }\n+\n+    private static final String TEMP_FILE_PREFIX = null;\n@@ -743,0 +762,95 @@\n+    public static DirectoryContentVerifier assertDirectoryContent(Path dir) {\n+        return new DirectoryContentVerifier(dir);\n+    }\n+\n+    public static final class DirectoryContentVerifier {\n+        public DirectoryContentVerifier(Path baseDir) {\n+            this(baseDir, ThrowingSupplier.toSupplier(() -> {\n+                try (var files = Files.list(baseDir)) {\n+                    return files.map(Path::getFileName).collect(toSet());\n+                }\n+            }).get());\n+        }\n+\n+        public void equals(Path ... expected) {\n+            equals(Set.of(expected));\n+        }\n+\n+        public void equals(Set<Path> expected) {\n+            currentTest.notifyAssert();\n+\n+            var comm = Comm.compare(content, expected);\n+            if (!comm.unique1.isEmpty() && !comm.unique2.isEmpty()) {\n+                error(String.format(\n+                        \"assertDirectoryContentEquals(%s): Some expected %s. Unexpected %s. Missing %s\",\n+                        baseDir, format(comm.common), format(comm.unique1), format(comm.unique2)));\n+            } else if (!comm.unique1.isEmpty()) {\n+                error(String.format(\n+                        \"assertDirectoryContentEquals%s: Expected %s. Unexpected %s\",\n+                        baseDir, format(comm.common), format(comm.unique1)));\n+            } else if (!comm.unique2.isEmpty()) {\n+                error(String.format(\n+                        \"assertDirectoryContentEquals(%s): Some expected %s. Missing %s\",\n+                        baseDir, format(comm.common), format(comm.unique2)));\n+            } else {\n+                traceAssert(String.format(\n+                        \"assertDirectoryContentEquals(%s): Expected %s\",\n+                        baseDir, format(expected)));\n+            }\n+        }\n+\n+        public void contains(Path ... expected) {\n+            contains(Set.of(expected));\n+        }\n+\n+        public void contains(Set<Path> expected) {\n+            currentTest.notifyAssert();\n+\n+            var comm = Comm.compare(content, expected);\n+            if (!comm.unique2.isEmpty()) {\n+                error(String.format(\n+                        \"assertDirectoryContentContains(%s): Some expected %s. Missing %s\",\n+                        baseDir, format(comm.common), format(comm.unique2)));\n+            } else {\n+                traceAssert(String.format(\n+                        \"assertDirectoryContentContains(%s): Expected %s\",\n+                        baseDir, format(expected)));\n+            }\n+        }\n+\n+        public DirectoryContentVerifier removeAll(Path ... paths) {\n+            Set<Path> newContent = new HashSet<>(content);\n+            newContent.removeAll(List.of(paths));\n+            return new DirectoryContentVerifier(baseDir, newContent);\n+        }\n+\n+        private DirectoryContentVerifier(Path baseDir, Set<Path> contents) {\n+            this.baseDir = baseDir;\n+            this.content = contents;\n+        }\n+\n+        private static record Comm(Set<Path> common, Set<Path> unique1, Set<Path> unique2) {\n+            static Comm compare(Set<Path> a, Set<Path> b) {\n+                Set<Path> common = new HashSet<>(a);\n+                common.retainAll(b);\n+\n+                Set<Path> unique1 = new HashSet<>(a);\n+                unique1.removeAll(common);\n+\n+                Set<Path> unique2 = new HashSet<>(b);\n+                unique2.removeAll(common);\n+\n+                return new Comm(common, unique1, unique2);\n+            }\n+        }\n+\n+        private static String format(Set<Path> paths) {\n+            return Arrays.toString(\n+                    paths.stream().sorted().map(Path::toString).toArray(\n+                            String[]::new));\n+        }\n+\n+        private final Path baseDir;\n+        private final Set<Path> content;\n+    }\n+\n@@ -820,1 +934,1 @@\n-    public final static class TextStreamVerifier {\n+    public static final class TextStreamVerifier {\n@@ -883,1 +997,1 @@\n-        final private String value;\n+        private final String value;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":119,"deletions":5,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import jdk.jpackage.test.JPackageCommand.AppLayoutAssert;\n@@ -90,4 +91,3 @@\n-        return List.of(new Object[][]{\n-            {packageTypes, wrap(cmd -> {\n-                additionalContent(cmd, argName, cmd.inputDir().resolve(\"foo\"));\n-            }, argName + \" in --input\")},\n+        List<Object[]> data = new ArrayList<>();\n+\n+        data.addAll(List.of(new Object[][]{\n@@ -97,13 +97,23 @@\n-            {packageTypes, wrap(cmd -> {\n-                additionalContent(cmd, argName, cmd.outputDir().resolve(\"bar\"));\n-            }, argName + \" in --dest\")},\n-            {packageTypes, wrap(cmd -> {\n-                additionalContent(cmd, argName, cmd.outputDir());\n-            }, argName + \" same as --dest\")},\n-            {packageTypes, wrap(cmd -> {\n-                tempDirInInputDir(cmd);\n-                var tempDir = cmd.getArgumentValue(\"--temp\");\n-                Files.createDirectories(Path.of(tempDir));\n-                cmd.addArguments(argName, tempDir);\n-            }, argName + \" as --temp; --temp in --input\")},\n-        });\n+        }));\n+\n+        if (!TKit.isOSX()) {\n+            data.addAll(List.of(new Object[][]{\n+                {packageTypes, wrap(cmd -> {\n+                    additionalContent(cmd, argName, cmd.inputDir().resolve(\"foo\"));\n+                }, argName + \" in --input\")},\n+                {packageTypes, wrap(cmd -> {\n+                    additionalContent(cmd, argName, cmd.outputDir().resolve(\"bar\"));\n+                }, argName + \" in --dest\")},\n+                {packageTypes, wrap(cmd -> {\n+                    additionalContent(cmd, argName, cmd.outputDir());\n+                }, argName + \" same as --dest\")},\n+                {packageTypes, wrap(cmd -> {\n+                    tempDirInInputDir(cmd);\n+                    var tempDir = cmd.getArgumentValue(\"--temp\");\n+                    Files.createDirectories(Path.of(tempDir));\n+                    cmd.addArguments(argName, tempDir);\n+                }, argName + \" as --temp; --temp in --input\")},\n+            }));\n+        }\n+\n+        return data;\n@@ -143,3 +153,4 @@\n-            if (cmd.hasArgument(\"--temp\")) {\n-                \/\/ If temp directory specified always create Java runtime to\n-                \/\/ make use of it\n+            if (cmd.hasArgument(\"--temp\") && cmd.isImagePackageType()) {\n+                \/\/ Request to build app image wit user supplied temp directory,\n+                \/\/ ignore external runtime if any to make use of the temp directory\n+                \/\/ for runtime generation.\n@@ -152,5 +163,3 @@\n-                cmd.setAppLayoutAsserts(\n-                        JPackageCommand.AppLayoutAssert.PackageFile,\n-                        JPackageCommand.AppLayoutAssert.MainLauncher,\n-                        JPackageCommand.AppLayoutAssert.MainLauncherCfgFile,\n-                        JPackageCommand.AppLayoutAssert.RuntimeDirectory);\n+                \/\/ Standard asserts for .jpackage.xml fail in messed up app image. Disable them.\n+                \/\/ Other standard asserts for app image contents should pass.\n+                cmd.excludeAppLayoutAsserts(AppLayoutAssert.APP_IMAGE_FILE);\n@@ -161,1 +170,1 @@\n-            JPackageCommand cmd = JPackageCommand.helloAppImage(JAR_NAME + \":\");\n+            JPackageCommand cmd = JPackageCommand.helloAppImage(JAR_PATH.toString() + \":\");\n@@ -170,1 +179,1 @@\n-                    .configureHelloApp(JAR_NAME + \":\")\n+                    .configureHelloApp(JAR_PATH.toString() + \":\")\n@@ -220,1 +229,1 @@\n-                JAR_NAME,\n+                JAR_PATH.getName(0).toString(),\n@@ -226,1 +235,1 @@\n-        TKit.assertFileExists(appDir.resolve(JAR_NAME));\n+        TKit.assertFileExists(appDir.resolve(JAR_PATH));\n@@ -237,1 +246,1 @@\n-    private final static record Envelope(ThrowingConsumer<JPackageCommand> value, String label) {\n+    private static final record Envelope(ThrowingConsumer<JPackageCommand> value, String label) {\n@@ -250,1 +259,5 @@\n-    private final static String JAR_NAME = \"duke.jar\";\n+    \/\/ Placing jar file in the \"Resources\" subdir of the input directory would allow\n+    \/\/ to use the input directory with `--app-content` on OSX.\n+    \/\/ For other platforms it doesn't matter. Keep it the same across\n+    \/\/ all platforms for simplicity.\n+    private static final Path JAR_PATH = Path.of(\"Resources\/duke.jar\");\n@@ -252,1 +265,1 @@\n-    private final static String ALL_NATIVE_PACKAGE_TYPES = \"NATIVE\";\n+    private static final String ALL_NATIVE_PACKAGE_TYPES = \"NATIVE\";\n","filename":"test\/jdk\/tools\/jpackage\/share\/InOutPathTest.java","additions":45,"deletions":32,"binary":false,"changes":77,"status":"modified"}]}