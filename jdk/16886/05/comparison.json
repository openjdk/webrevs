{"files":[{"patch":"@@ -1107,1 +1107,1 @@\n-    return n->as_If()->dominated_by(prev_dom, phase->is_IterGVN());\n+    return n->as_If()->dominated_by(prev_dom, phase->is_IterGVN(), false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -326,0 +326,9 @@\n+CastIINode* CastIINode::pin_for_array_access() const {\n+  assert(_dependency == RegularDependency, \"already pinned\");\n+  if (has_range_check()) {\n+    return new CastIINode(in(0), in(1), bottom_type(), StrongDependency, has_range_check());\n+  }\n+  return nullptr;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  bool has_range_check() {\n+  bool has_range_check() const {\n@@ -127,0 +127,2 @@\n+  CastIINode* pin_for_array_access() const override;\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -433,1 +433,0 @@\n-  Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn);\n@@ -435,0 +434,1 @@\n+  Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool range_check_smearing);\n@@ -508,0 +508,2 @@\n+  void pin_array_loads(PhaseIterGVN* igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -542,1 +542,1 @@\n-static void adjust_check(Node* proj, Node* range, Node* index,\n+static void adjust_check(IfProjNode* proj, Node* range, Node* index,\n@@ -550,2 +550,2 @@\n-  DEBUG_ONLY( if( !bol->is_Bool() ) { proj->dump(3); fatal(\"Expect projection-->IfNode-->BoolNode\"); } )\n-  if( !bol->is_Bool() ) return;\n+  DEBUG_ONLY( if (!bol->is_Bool()) { proj->dump(3); fatal(\"Expect projection-->IfNode-->BoolNode\"); } )\n+  if (!bol->is_Bool()) return;\n@@ -556,2 +556,2 @@\n-  if( index ) {\n-    new_add = off_lo ? gvn->transform(new AddINode( index, new_add )) : index;\n+  if (index) {\n+    new_add = off_lo ? gvn->transform(new AddINode(index, new_add)) : index;\n@@ -560,2 +560,2 @@\n-    ? new CmpUNode( new_add, range )\n-    : new CmpUNode( range, new_add );\n+    ? new CmpUNode(new_add, range)\n+    : new CmpUNode(range, new_add);\n@@ -564,1 +564,1 @@\n-  if( new_cmp == cmp ) return;\n+  if (new_cmp == cmp) return;\n@@ -566,3 +566,7 @@\n-  Node *new_bol = gvn->transform( new BoolNode( new_cmp, bol->as_Bool()->_test._test ) );\n-  igvn->rehash_node_delayed( iff );\n-  iff->set_req_X( 1, new_bol, igvn );\n+  Node* new_bol = gvn->transform(new BoolNode(new_cmp, bol->as_Bool()->_test._test));\n+  igvn->rehash_node_delayed(iff);\n+  iff->set_req_X(1, new_bol, igvn);\n+  \/\/ Loads and range check Cast nodes that are control dependent on this range check now also depend on a dominating\n+  \/\/ range check and can't float if the range check they are control dependent on is replaced by some dominating range\n+  \/\/ check: pin them.\n+  proj->pin_array_loads(igvn);\n@@ -1421,1 +1425,1 @@\n-  Node* ctl;\n+  IfProjNode* ctl;\n@@ -1489,1 +1493,1 @@\n-    return dominated_by(prev_dom, igvn);\n+    return dominated_by(prev_dom, igvn, false);\n@@ -1496,1 +1500,1 @@\n-Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {\n+Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool range_check_smearing) {\n@@ -1509,9 +1513,0 @@\n-  \/\/ Loop predicates may have depending checks which should not\n-  \/\/ be skipped. For example, range check predicate has two checks\n-  \/\/ for lower and upper bounds.\n-  ProjNode* unc_proj = proj_out(1 - prev_dom->as_Proj()->_con)->as_Proj();\n-  if (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n-      unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr) {\n-    prev_dom = idom;\n-  }\n-\n@@ -1540,0 +1535,10 @@\n+        if (range_check_smearing && data_target != top) {\n+          \/\/ Loads and range check Cast nodes that are control dependent on this range check depend on multiple\n+          \/\/ dominating range checks and can't float even if the range check they'll be control dependent on once this\n+          \/\/ function returns is replaced by a dominating range check: pin them.\n+          Node* clone = s->pin_for_array_access();\n+          if (clone != nullptr) {\n+            clone = igvn->transform(clone);\n+            igvn->replace_node(s, clone);\n+          }\n+        }\n@@ -1784,0 +1789,16 @@\n+void IfProjNode::pin_array_loads(PhaseIterGVN* igvn) {\n+  for (DUIterator i = outs(); has_out(i); i++) {\n+    Node* u = out(i);\n+    if (!u->depends_only_on_test()) {\n+      continue;\n+    }\n+    Node* clone = u->pin_for_array_access();\n+    if (clone != nullptr) {\n+      clone = igvn->transform(clone);\n+      assert(clone != u, \"shouldn't common\");\n+      igvn->replace_node(u, clone);\n+      --i;\n+    }\n+  }\n+}\n+\n@@ -1913,1 +1934,1 @@\n-          prev_checks[nb_checks%NRC].ctl = prev_dom;\n+          prev_checks[nb_checks%NRC].ctl = prev_dom->as_IfProj();\n@@ -1930,0 +1951,5 @@\n+      if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+        phase->C->record_for_post_loop_opts_igvn(this);\n+        return nullptr;\n+      }\n+\n@@ -2003,0 +2029,1 @@\n+      return dominated_by(prev_dom, igvn, true);\n@@ -2013,1 +2040,1 @@\n-  return dominated_by(prev_dom, igvn);\n+  return dominated_by(prev_dom, igvn, false);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":52,"deletions":25,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1182,0 +1182,1 @@\n+  bool range_check_predicate = false;\n@@ -1214,0 +1215,1 @@\n+    range_check_predicate = true;\n@@ -1296,1 +1298,1 @@\n-  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con);\n+  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con, range_check_predicate);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  dominated_by(proj_true->as_IfProj(), unswitch_iff, false, false);\n+  dominated_by(proj_true->as_IfProj(), unswitch_iff);\n@@ -187,1 +187,1 @@\n-  dominated_by(proj_false->as_IfProj(), unswitch_iff_clone, false, false);\n+  dominated_by(proj_false->as_IfProj(), unswitch_iff_clone);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1510,1 +1510,1 @@\n-  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool exclude_loop_predicate = false);\n+  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool range_check_predicate = false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool exclude_loop_predicate) {\n+void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool range_check_predicate) {\n@@ -333,1 +333,1 @@\n-  \/\/ If I dont have a reachable TRUE and FALSE path following the IfNode then\n+  \/\/ If I don't have a reachable TRUE and FALSE path following the IfNode then\n@@ -344,3 +344,0 @@\n-  \/\/ Loop predicates may have depending checks which should not\n-  \/\/ be skipped. For example, range check predicate has two checks\n-  \/\/ for lower and upper bounds.\n@@ -350,12 +347,0 @@\n-  ProjNode* dp_proj  = dp->as_Proj();\n-  ProjNode* unc_proj = iff->proj_out(1 - dp_proj->_con)->as_Proj();\n-  if (exclude_loop_predicate &&\n-      (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n-       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr ||\n-       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check) != nullptr)) {\n-    \/\/ If this is a range check (IfNode::is_range_check), do not\n-    \/\/ reorder because Compile::allow_range_check_smearing might have\n-    \/\/ changed the check.\n-    return; \/\/ Let IGVN transformation change control dependence.\n-  }\n-\n@@ -370,0 +355,13 @@\n+      if (range_check_predicate) {\n+        \/\/ Loads and range check Cast nodes that are control dependent on this range check (that is about to be removed)\n+        \/\/ now depend on multiple dominating range checks. After the removal of this range check, these control\n+        \/\/ dependent nodes end up at the lowest\/nearest dominating check in the graph. To ensure that these Loads\/Casts\n+        \/\/ do not float above any of the dominating checks (even when the lowest dominating check is later replaced by\n+        \/\/ yet another dominating check), we need to pin them at the lowest dominating check.\n+        Node* clone = cd->pin_for_array_access();\n+        if (clone != nullptr) {\n+          clone = _igvn.register_new_node_with_optimizer(clone, cd);\n+          _igvn.replace_node(cd, clone);\n+          cd = clone;\n+        }\n+      }\n@@ -1496,1 +1494,1 @@\n-          dominated_by(prevdom->as_IfProj(), n->as_If(), false, true);\n+          dominated_by(prevdom->as_IfProj(), n->as_If());\n@@ -1589,1 +1587,1 @@\n-        dominated_by(dom_proj_true->as_IfProj(), new_false_region->in(i)->in(0)->as_If(), false, false);\n+        dominated_by(dom_proj_true->as_IfProj(), new_false_region->in(i)->in(0)->as_If());\n@@ -1592,1 +1590,1 @@\n-        dominated_by(dom_proj_false->as_IfProj(), new_false_region->in(i)->in(0)->as_If(), false, false);\n+        dominated_by(dom_proj_false->as_IfProj(), new_false_region->in(i)->in(0)->as_If());\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -848,2 +848,5 @@\n-bool LoadNode::cmp( const Node &n ) const\n-{ return !Type::cmp( _type, ((LoadNode&)n)._type ); }\n+bool LoadNode::cmp( const Node &n ) const {\n+  return !Type::cmp( _type, ((LoadNode&)n)._type ) &&\n+         _control_dependency == ((LoadNode&)n)._control_dependency &&\n+         _mo == ((LoadNode&)n)._mo;\n+}\n@@ -986,0 +989,8 @@\n+LoadNode* LoadNode::pin_for_array_access() const {\n+  const TypePtr* adr_type = this->adr_type();\n+  if (adr_type != nullptr && adr_type->isa_aryptr()) {\n+    return clone_pinned();\n+  }\n+  return nullptr;\n+}\n+\n@@ -1005,1 +1016,2 @@\n-    LoadNode* ld = clone()->as_Load();\n+    \/\/ load depends on the tests that validate the arraycopy\n+    LoadNode* ld = clone_pinned();\n@@ -1047,2 +1059,0 @@\n-    \/\/ load depends on the tests that validate the arraycopy\n-    ld->_control_dependency = UnknownControl;\n@@ -2502,0 +2512,6 @@\n+LoadNode* LoadNode::clone_pinned() const {\n+  LoadNode* ld = clone()->as_Load();\n+  ld->_control_dependency = UnknownControl;\n+  return ld;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -295,0 +295,2 @@\n+  LoadNode* pin_for_array_access() const override;\n+\n@@ -320,0 +322,2 @@\n+\n+  LoadNode* clone_pinned() const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1138,1 +1138,5 @@\n-\/\/----------------- Code Generation\n+  virtual Node* pin_for_array_access() const {\n+    return nullptr;\n+  }\n+\n+  \/\/----------------- Code Generation\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8319793\n+ * @summary Replacing a test with a dominating test can cause an array load to float above a range check that guards it\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:-TieredCompilation TestArrayAccessAboveRCAfterSmearingOrPredication\n+ *\/\n+\n+\n+public class TestArrayAccessAboveRCAfterSmearingOrPredication {\n+    private static int field;\n+    private static int flagField;\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        float[] array = new float[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            testRangeCheckSmearing(array, 0, 1, true, true, true);\n+            testRangeCheckSmearing(array, 0, 1, true, false, true);\n+            testRangeCheckSmearing(array, 0, 1, false, false, true);\n+            testRangeCheckSmearing(array, 0, 1, true, true, false);\n+            testRangeCheckSmearing(array, 0, 1, true, false, false);\n+            testRangeCheckSmearing(array, 0, 1, false, false, false);\n+            testHelper(0);\n+\n+            testLoopPredication(array, 0, 1, true, true, true);\n+            testLoopPredication(array, 0, 1, true, false, true);\n+            testLoopPredication(array, 0, 1, false, false, true);\n+            testLoopPredication(array, 0, 1, true, true, false);\n+            testLoopPredication(array, 0, 1, true, false, false);\n+            testLoopPredication(array, 0, 1, false, false, false);\n+        }\n+        try {\n+            testRangeCheckSmearing(array, Integer.MAX_VALUE, 1, false, false, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            testLoopPredication(array, Integer.MAX_VALUE, 1, false, false, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static float testRangeCheckSmearing(float[] array, int i, int flag, boolean flag2, boolean flag3, boolean flag4) {\n+        if (array == null) {\n+        }\n+        flagField = flag;\n+        int j;\n+        for (j = 0; j < 10; j++) {\n+        }\n+        for (int k = 0; k < 10; k++) {\n+            for (int l = 0; l < 10; l++) {\n+            }\n+        }\n+        testHelper(j);\n+        float v = 0;\n+        if (flag == 1) {\n+            if (flag4) {\n+                v += array[i];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    v += array[i];\n+                }\n+            } else {\n+                v += array[i];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    v += array[i];\n+                }\n+            }\n+        }\n+        return v;\n+    }\n+\n+    private static void testHelper(int j) {\n+        if (j == 10) {\n+            return;\n+        }\n+        flagField = 0;\n+    }\n+\n+    private static float testLoopPredication(float[] array, int i, int flag, boolean flag2, boolean flag3, boolean flag4) {\n+        i = Math.min(i, Integer.MAX_VALUE - 2);\n+        if (array == null) {\n+        }\n+        flagField = flag;\n+        int j;\n+        for (j = 0; j < 10; j++) {\n+            for (int k = 0; k < 10; k++) {\n+            }\n+        }\n+        testHelper(j);\n+\n+        float v = 0;\n+        if (flag == 1) {\n+            if (flag4) {\n+                float dummy = array[i];\n+                dummy = array[i + 2];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    for (int m = 0; m < 3; m++) {\n+                        v += array[i + m];\n+                    }\n+                }\n+                volatileField = 42;\n+            } else {\n+                float dummy = array[i];\n+                dummy = array[i + 2];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    for (int m = 0; m < 3; m++) {\n+                        v += array[i + m];\n+                    }\n+                }\n+                volatileField = 42;\n+            }\n+        }\n+\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterSmearingOrPredication.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8319793\n+ * @summary Replacing a test with a dominating test can cause an array access CastII to float above a range check that guards it\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation TestArrayAccessCastIIAboveRC\n+ *\/\n+\n+public class TestArrayAccessCastIIAboveRC {\n+    static int N = 400;\n+    static int iArrFld[] = new int[N];\n+\n+    static void test() {\n+        float fArr[] = new float[N];\n+        int i9, i10, i12;\n+        long lArr1[] = new long[N];\n+        for (i9 = 7; i9 < 43; i9++) {\n+            try {\n+                i10 = 7 % i9;\n+                iArrFld[i9 + 1] = i9 \/ i10;\n+            } catch (ArithmeticException a_e) {\n+            }\n+            for (i12 = 1; 7 > i12; i12++)\n+                lArr1[i9 - 1] = 42;\n+            iArrFld[i12] = 4;\n+            fArr[i9 - 1] = 0;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 50_000; ++i) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessCastIIAboveRC.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}