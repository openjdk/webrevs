{"files":[{"patch":"@@ -284,1 +284,1 @@\n-CastIINode* CastIINode::pin_for_array_access() const {\n+CastIINode* CastIINode::pin_array_access_node() const {\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  CastIINode* pin_for_array_access() const;\n+  CastIINode* pin_array_access_node() const;\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-  Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool range_check_smearing);\n+  Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool pin_array_nodes);\n@@ -508,1 +508,1 @@\n-  void pin_array_loads(PhaseIterGVN* igvn);\n+  void pin_array_access_nodes(PhaseIterGVN* igvn);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -569,5 +569,6 @@\n-  \/\/ Loads and range check Cast nodes that are control dependent on this range check now depend on multiple dominating\n-  \/\/ range checks. These control dependent nodes end up at the lowest\/nearest dominating check in the graph. To ensure\n-  \/\/ that these Loads\/Casts do not float above any of the dominating checks (even when the lowest dominating check is\n-  \/\/ later replaced by yet another dominating check), we need to pin them at the lowest dominating check.\n-  proj->pin_array_loads(igvn);\n+  \/\/ As part of range check smearing, this range check is widen. Loads and range check Cast nodes that are control\n+  \/\/ dependent on this range check now depend on multiple dominating range checks. These control dependent nodes end up\n+  \/\/ at the lowest\/nearest dominating check in the graph. To ensure that these Loads\/Casts do not float above any of the\n+  \/\/ dominating checks (even when the lowest dominating check is later replaced by yet another dominating check), we\n+  \/\/ need to pin them at the lowest dominating check.\n+  proj->pin_array_access_nodes(igvn);\n@@ -1501,1 +1502,1 @@\n-Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool range_check_smearing) {\n+Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool pin_array_nodes) {\n@@ -1536,7 +1537,8 @@\n-        if (range_check_smearing && data_target != top) {\n-          \/\/ Loads and range check Cast nodes that are control dependent on this range check (that is about to be\n-          \/\/ removed) now depend on multiple dominating range checks. After the removal of this range check, these\n-          \/\/ control dependent nodes end up at the lowest\/nearest dominating check in the graph. To ensure that these\n-          \/\/ Loads\/Casts do not float above any of the dominating checks (even when the lowest dominating check is later\n-          \/\/ replaced by yet another dominating check), we need to pin them at the lowest dominating check.\n-          Node* clone = s->pin_for_array_access();\n+        if (pin_array_nodes && data_target != top) {\n+          \/\/ As a result of range check smearing, Loads and range check Cast nodes that are control dependent on this\n+          \/\/ range check (that is about to be removed) now depend on multiple dominating range checks. After the removal\n+          \/\/ of this range check, these control dependent nodes end up at the lowest\/nearest dominating check in the\n+          \/\/ graph. To ensure that these Loads\/Casts do not float above any of the dominating checks (even when the\n+          \/\/ lowest dominating check is later replaced by yet another dominating check), we need to pin them at the\n+          \/\/ lowest dominating check.\n+          Node* clone = s->pin_array_access_node();\n@@ -1792,1 +1794,1 @@\n-void IfProjNode::pin_array_loads(PhaseIterGVN* igvn) {\n+void IfProjNode::pin_array_access_nodes(PhaseIterGVN* igvn) {\n@@ -1798,1 +1800,1 @@\n-    Node* clone = u->pin_for_array_access();\n+    Node* clone = u->pin_array_access_node();\n@@ -2032,0 +2034,19 @@\n+      \/\/ The last RangeCheck is found to be redundant with a sequence of n (n >= 2) preceding RangeChecks.\n+      \/\/ If an array load is control dependent on the eliminated range check, the array load nodes (CastII and Load)\n+      \/\/ become control dependent on the last range check of the sequence, but they are really dependent on the entire\n+      \/\/ sequence of RangeChecks. If RangeCheck#n is later replaced by a dominating identical check, the array load\n+      \/\/ nodes must not float above the n-1 other RangeCheck in the sequence. We pin the array load nodes here to\n+      \/\/ guarantee it doesn't happen.\n+      \/\/\n+      \/\/ RangeCheck#1                 RangeCheck#1           \n+      \/\/    |      \\                     |      \\            \n+      \/\/    |      uncommon trap         |      uncommon trap\n+      \/\/    ..                           ..                  \n+      \/\/ RangeCheck#n              -> RangeCheck#n           \n+      \/\/    |      \\                     |      \\            \n+      \/\/    |      uncommon trap        CastII  uncommon trap\n+      \/\/ RangeCheck                     Load\n+      \/\/    |      \\\n+      \/\/   CastII  uncommon trap\n+      \/\/   Load\n+      \n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1299,0 +1299,3 @@\n+  \/\/ If a range check is eliminated, data dependent nodes (Load and range check CastII nodes) are now dependent on 2\n+  \/\/ range check predicates (one for the start of the loop, one for the end) but we can only keep track of one control\n+  \/\/ dependency: pin the data dependent nodes.\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1510,1 +1510,1 @@\n-  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool range_check_predicate = false);\n+  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool pin_array_nodes = false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool range_check_predicate) {\n+void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool pin_array_nodes) {\n@@ -355,7 +355,8 @@\n-      if (range_check_predicate) {\n-        \/\/ Loads and range check Cast nodes that are control dependent on this range check (that is about to be removed)\n-        \/\/ now depend on multiple dominating range checks. After the removal of this range check, these control\n-        \/\/ dependent nodes end up at the lowest\/nearest dominating check in the graph. To ensure that these Loads\/Casts\n-        \/\/ do not float above any of the dominating checks (even when the lowest dominating check is later replaced by\n-        \/\/ yet another dominating check), we need to pin them at the lowest dominating check.\n-        Node* clone = cd->pin_for_array_access();\n+      if (pin_array_nodes) {\n+        \/\/ Because of range check predication, Loads and range check Cast nodes that are control dependent on this range\n+        \/\/ check (that is about to be removed) now depend on multiple dominating range check predicates. After the\n+        \/\/ removal of this range check, these control dependent nodes end up at the lowest\/nearest dominating predicate\n+        \/\/ in the graph. To ensure that these Loads\/Casts do not float above any of the dominating checks (even when the\n+        \/\/ lowest dominating check is later replaced by yet another dominating check), we need to pin them at the lowest\n+        \/\/ dominating check.\n+        Node* clone = cd->pin_array_access_node();\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -848,4 +848,5 @@\n-bool LoadNode::cmp( const Node &n ) const {\n-  return !Type::cmp( _type, ((LoadNode&)n)._type ) &&\n-         _control_dependency == ((LoadNode&)n)._control_dependency &&\n-         _mo == ((LoadNode&)n)._mo;\n+bool LoadNode::cmp(const Node &n) const {\n+  LoadNode& load = (LoadNode &)n;\n+  return !Type::cmp(_type, load._type) &&\n+         _control_dependency == load._control_dependency &&\n+         _mo == load._mo;\n@@ -989,1 +990,1 @@\n-LoadNode* LoadNode::pin_for_array_access() const {\n+LoadNode* LoadNode::pin_array_access_node() const {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-  LoadNode* pin_for_array_access() const;\n+  LoadNode* pin_array_access_node() const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1138,1 +1138,4 @@\n-  virtual Node* pin_for_array_access() const {\n+  \/\/ Returns a clone of the current node that's pinned (if the current node is not) for nodes found in array accesses\n+  \/\/ (Load and range check CastII nodes).\n+  \/\/ This is used when an array access is made dependent on 2 or more range checks (range check smearing or predication).\n+  virtual Node* pin_array_access_node() const {\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}