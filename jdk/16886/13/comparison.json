{"files":[{"patch":"@@ -1107,1 +1107,1 @@\n-    return n->as_If()->dominated_by(prev_dom, phase->is_IterGVN());\n+    return n->as_If()->dominated_by(prev_dom, phase->is_IterGVN(), false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -284,0 +284,9 @@\n+CastIINode* CastIINode::pin_array_access_node() const {\n+  assert(_dependency == RegularDependency, \"already pinned\");\n+  if (has_range_check()) {\n+    return new CastIINode(in(0), in(1), bottom_type(), StrongDependency, has_range_check());\n+  }\n+  return nullptr;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  bool has_range_check() {\n+  bool has_range_check() const {\n@@ -126,0 +126,2 @@\n+  CastIINode* pin_array_access_node() const;\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -433,1 +433,0 @@\n-  Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn);\n@@ -435,0 +434,1 @@\n+  Node* dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool pin_array_access_nodes);\n@@ -508,0 +508,2 @@\n+  void pin_array_access_nodes(PhaseIterGVN* igvn);\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -542,1 +542,1 @@\n-static void adjust_check(Node* proj, Node* range, Node* index,\n+static void adjust_check(IfProjNode* proj, Node* range, Node* index,\n@@ -550,2 +550,2 @@\n-  DEBUG_ONLY( if( !bol->is_Bool() ) { proj->dump(3); fatal(\"Expect projection-->IfNode-->BoolNode\"); } )\n-  if( !bol->is_Bool() ) return;\n+  DEBUG_ONLY( if (!bol->is_Bool()) { proj->dump(3); fatal(\"Expect projection-->IfNode-->BoolNode\"); } )\n+  if (!bol->is_Bool()) return;\n@@ -556,2 +556,2 @@\n-  if( index ) {\n-    new_add = off_lo ? gvn->transform(new AddINode( index, new_add )) : index;\n+  if (index) {\n+    new_add = off_lo ? gvn->transform(new AddINode(index, new_add)) : index;\n@@ -560,2 +560,2 @@\n-    ? new CmpUNode( new_add, range )\n-    : new CmpUNode( range, new_add );\n+    ? new CmpUNode(new_add, range)\n+    : new CmpUNode(range, new_add);\n@@ -564,1 +564,1 @@\n-  if( new_cmp == cmp ) return;\n+  if (new_cmp == cmp) return;\n@@ -566,3 +566,9 @@\n-  Node *new_bol = gvn->transform( new BoolNode( new_cmp, bol->as_Bool()->_test._test ) );\n-  igvn->rehash_node_delayed( iff );\n-  iff->set_req_X( 1, new_bol, igvn );\n+  Node* new_bol = gvn->transform(new BoolNode(new_cmp, bol->as_Bool()->_test._test));\n+  igvn->rehash_node_delayed(iff);\n+  iff->set_req_X(1, new_bol, igvn);\n+  \/\/ As part of range check smearing, this range check is widened. Loads and range check Cast nodes that are control\n+  \/\/ dependent on this range check now depend on multiple dominating range checks. These control dependent nodes end up\n+  \/\/ at the lowest\/nearest dominating check in the graph. To ensure that these Loads\/Casts do not float above any of the\n+  \/\/ dominating checks (even when the lowest dominating check is later replaced by yet another dominating check), we\n+  \/\/ need to pin them at the lowest dominating check.\n+  proj->pin_array_access_nodes(igvn);\n@@ -1421,1 +1427,1 @@\n-  Node* ctl;\n+  IfProjNode* ctl;\n@@ -1489,1 +1495,1 @@\n-    return dominated_by(prev_dom, igvn);\n+    return dominated_by(prev_dom, igvn, false);\n@@ -1496,1 +1502,1 @@\n-Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {\n+Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool pin_array_access_nodes) {\n@@ -1509,9 +1515,0 @@\n-  \/\/ Loop predicates may have depending checks which should not\n-  \/\/ be skipped. For example, range check predicate has two checks\n-  \/\/ for lower and upper bounds.\n-  ProjNode* unc_proj = proj_out(1 - prev_dom->as_Proj()->_con)->as_Proj();\n-  if (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n-      unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr) {\n-    prev_dom = idom;\n-  }\n-\n@@ -1540,0 +1537,13 @@\n+        if (pin_array_access_nodes && data_target != top) {\n+          \/\/ As a result of range check smearing, Loads and range check Cast nodes that are control dependent on this\n+          \/\/ range check (that is about to be removed) now depend on multiple dominating range checks. After the removal\n+          \/\/ of this range check, these control dependent nodes end up at the lowest\/nearest dominating check in the\n+          \/\/ graph. To ensure that these Loads\/Casts do not float above any of the dominating checks (even when the\n+          \/\/ lowest dominating check is later replaced by yet another dominating check), we need to pin them at the\n+          \/\/ lowest dominating check.\n+          Node* clone = s->pin_array_access_node();\n+          if (clone != nullptr) {\n+            clone = igvn->transform(clone);\n+            igvn->replace_node(s, clone);\n+          }\n+        }\n@@ -1784,0 +1794,16 @@\n+void IfProjNode::pin_array_access_nodes(PhaseIterGVN* igvn) {\n+  for (DUIterator i = outs(); has_out(i); i++) {\n+    Node* u = out(i);\n+    if (!u->depends_only_on_test()) {\n+      continue;\n+    }\n+    Node* clone = u->pin_array_access_node();\n+    if (clone != nullptr) {\n+      clone = igvn->transform(clone);\n+      assert(clone != u, \"shouldn't common\");\n+      igvn->replace_node(u, clone);\n+      --i;\n+    }\n+  }\n+}\n+\n@@ -1913,1 +1939,1 @@\n-          prev_checks[nb_checks%NRC].ctl = prev_dom;\n+          prev_checks[nb_checks%NRC].ctl = prev_dom->as_IfProj();\n@@ -1930,0 +1956,9 @@\n+      if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+        \/\/ We are about to perform range check smearing (i.e. remove this RangeCheck if it is dominated by\n+        \/\/ a series of RangeChecks which have a range that covers this RangeCheck). This can cause array access nodes to\n+        \/\/ be pinned. We want to avoid that and first allow range check elimination a chance to remove the RangeChecks\n+        \/\/ from loops. Hence, we delay range check smearing until after loop opts.\n+        phase->C->record_for_post_loop_opts_igvn(this);\n+        return nullptr;\n+      }\n+\n@@ -2003,0 +2038,20 @@\n+      \/\/ The last RangeCheck is found to be redundant with a sequence of n (n >= 2) preceding RangeChecks.\n+      \/\/ If an array load is control dependent on the eliminated range check, the array load nodes (CastII and Load)\n+      \/\/ become control dependent on the last range check of the sequence, but they are really dependent on the entire\n+      \/\/ sequence of RangeChecks. If RangeCheck#n is later replaced by a dominating identical check, the array load\n+      \/\/ nodes must not float above the n-1 other RangeCheck in the sequence. We pin the array load nodes here to\n+      \/\/ guarantee it doesn't happen.\n+      \/\/\n+      \/\/ RangeCheck#1                 RangeCheck#1\n+      \/\/    |      \\                     |      \\\n+      \/\/    |      uncommon trap         |      uncommon trap\n+      \/\/    ..                           ..\n+      \/\/ RangeCheck#n              -> RangeCheck#n\n+      \/\/    |      \\                     |      \\\n+      \/\/    |      uncommon trap        CastII  uncommon trap\n+      \/\/ RangeCheck                     Load\n+      \/\/    |      \\\n+      \/\/   CastII  uncommon trap\n+      \/\/   Load\n+\n+      return dominated_by(prev_dom, igvn, true);\n@@ -2013,1 +2068,1 @@\n-  return dominated_by(prev_dom, igvn);\n+  return dominated_by(prev_dom, igvn, false);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":80,"deletions":25,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -1183,0 +1183,1 @@\n+  bool range_check_predicate = false;\n@@ -1215,0 +1216,1 @@\n+    range_check_predicate = true;\n@@ -1297,1 +1299,4 @@\n-  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con);\n+  \/\/ If a range check is eliminated, data dependent nodes (Load and range check CastII nodes) are now dependent on 2\n+  \/\/ Hoisted Check Predicates (one for the start of the loop, one for the end) but we can only keep track of one control\n+  \/\/ dependency: pin the data dependent nodes.\n+  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con, range_check_predicate);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-  dominated_by(proj_true->as_IfProj(), unswitch_iff, false, false);\n+  dominated_by(proj_true->as_IfProj(), unswitch_iff);\n@@ -187,1 +187,1 @@\n-  dominated_by(proj_false->as_IfProj(), unswitch_iff_clone, false, false);\n+  dominated_by(proj_false->as_IfProj(), unswitch_iff_clone);\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1510,1 +1510,1 @@\n-  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool exclude_loop_predicate = false);\n+  void dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip = false, bool pin_array_access_nodes = false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool exclude_loop_predicate) {\n+void PhaseIdealLoop::dominated_by(IfProjNode* prevdom, IfNode* iff, bool flip, bool pin_array_access_nodes) {\n@@ -333,1 +333,1 @@\n-  \/\/ If I dont have a reachable TRUE and FALSE path following the IfNode then\n+  \/\/ If I don't have a reachable TRUE and FALSE path following the IfNode then\n@@ -344,3 +344,0 @@\n-  \/\/ Loop predicates may have depending checks which should not\n-  \/\/ be skipped. For example, range check predicate has two checks\n-  \/\/ for lower and upper bounds.\n@@ -350,12 +347,0 @@\n-  ProjNode* dp_proj  = dp->as_Proj();\n-  ProjNode* unc_proj = iff->proj_out(1 - dp_proj->_con)->as_Proj();\n-  if (exclude_loop_predicate &&\n-      (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n-       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr ||\n-       unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_range_check) != nullptr)) {\n-    \/\/ If this is a range check (IfNode::is_range_check), do not\n-    \/\/ reorder because Compile::allow_range_check_smearing might have\n-    \/\/ changed the check.\n-    return; \/\/ Let IGVN transformation change control dependence.\n-  }\n-\n@@ -370,0 +355,14 @@\n+      if (pin_array_access_nodes) {\n+        \/\/ Because of Loop Predication, Loads and range check Cast nodes that are control dependent on this range\n+        \/\/ check (that is about to be removed) now depend on multiple dominating Hoisted Check Predicates. After the\n+        \/\/ removal of this range check, these control dependent nodes end up at the lowest\/nearest dominating predicate\n+        \/\/ in the graph. To ensure that these Loads\/Casts do not float above any of the dominating checks (even when the\n+        \/\/ lowest dominating check is later replaced by yet another dominating check), we need to pin them at the lowest\n+        \/\/ dominating check.\n+        Node* clone = cd->pin_array_access_node();\n+        if (clone != nullptr) {\n+          clone = _igvn.register_new_node_with_optimizer(clone, cd);\n+          _igvn.replace_node(cd, clone);\n+          cd = clone;\n+        }\n+      }\n@@ -1489,1 +1488,1 @@\n-          dominated_by(prevdom->as_IfProj(), n->as_If(), false, true);\n+          dominated_by(prevdom->as_IfProj(), n->as_If());\n@@ -1582,1 +1581,1 @@\n-        dominated_by(dom_proj_true->as_IfProj(), new_false_region->in(i)->in(0)->as_If(), false, false);\n+        dominated_by(dom_proj_true->as_IfProj(), new_false_region->in(i)->in(0)->as_If());\n@@ -1585,1 +1584,1 @@\n-        dominated_by(dom_proj_false->as_IfProj(), new_false_region->in(i)->in(0)->as_If(), false, false);\n+        dominated_by(dom_proj_false->as_IfProj(), new_false_region->in(i)->in(0)->as_If());\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -848,2 +848,6 @@\n-bool LoadNode::cmp( const Node &n ) const\n-{ return !Type::cmp( _type, ((LoadNode&)n)._type ); }\n+bool LoadNode::cmp(const Node &n) const {\n+  LoadNode& load = (LoadNode &)n;\n+  return !Type::cmp(_type, load._type) &&\n+         _control_dependency == load._control_dependency &&\n+         _mo == load._mo;\n+}\n@@ -986,0 +990,8 @@\n+LoadNode* LoadNode::pin_array_access_node() const {\n+  const TypePtr* adr_type = this->adr_type();\n+  if (adr_type != nullptr && adr_type->isa_aryptr()) {\n+    return clone_pinned();\n+  }\n+  return nullptr;\n+}\n+\n@@ -1005,1 +1017,2 @@\n-    LoadNode* ld = clone()->as_Load();\n+    \/\/ load depends on the tests that validate the arraycopy\n+    LoadNode* ld = clone_pinned();\n@@ -1047,2 +1060,0 @@\n-    \/\/ load depends on the tests that validate the arraycopy\n-    ld->_control_dependency = UnknownControl;\n@@ -2502,0 +2513,6 @@\n+LoadNode* LoadNode::clone_pinned() const {\n+  LoadNode* ld = clone()->as_Load();\n+  ld->_control_dependency = UnknownControl;\n+  return ld;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -295,0 +295,2 @@\n+  LoadNode* pin_array_access_node() const;\n+\n@@ -320,0 +322,2 @@\n+\n+  LoadNode* clone_pinned() const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1138,1 +1138,8 @@\n-\/\/----------------- Code Generation\n+  \/\/ Returns a clone of the current node that's pinned (if the current node is not) for nodes found in array accesses\n+  \/\/ (Load and range check CastII nodes).\n+  \/\/ This is used when an array access is made dependent on 2 or more range checks (range check smearing or Loop Predication).\n+  virtual Node* pin_array_access_node() const {\n+    return nullptr;\n+  }\n+\n+  \/\/----------------- Code Generation\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8319793\n+ * @summary Replacing a test with a dominating test can cause an array load to float above a range check that guards it\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:-TieredCompilation TestArrayAccessAboveRCAfterSmearingOrPredication\n+ *\/\n+\n+\n+public class TestArrayAccessAboveRCAfterSmearingOrPredication {\n+    private static int field;\n+    private static int flagField;\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        float[] array = new float[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            testRangeCheckSmearing(array, 0, 1, true, true, true);\n+            testRangeCheckSmearing(array, 0, 1, true, false, true);\n+            testRangeCheckSmearing(array, 0, 1, false, false, true);\n+            testRangeCheckSmearing(array, 0, 1, true, true, false);\n+            testRangeCheckSmearing(array, 0, 1, true, false, false);\n+            testRangeCheckSmearing(array, 0, 1, false, false, false);\n+            testHelper(0);\n+\n+            testLoopPredication(array, 0, 1, true, true, true);\n+            testLoopPredication(array, 0, 1, true, false, true);\n+            testLoopPredication(array, 0, 1, false, false, true);\n+            testLoopPredication(array, 0, 1, true, true, false);\n+            testLoopPredication(array, 0, 1, true, false, false);\n+            testLoopPredication(array, 0, 1, false, false, false);\n+        }\n+        try {\n+            testRangeCheckSmearing(array, Integer.MAX_VALUE, 1, false, false, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            testLoopPredication(array, Integer.MAX_VALUE, 1, false, false, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static float testRangeCheckSmearing(float[] array, int i, int flag, boolean flag2, boolean flag3, boolean flag4) {\n+        if (array == null) {\n+        }\n+        flagField = flag;\n+        int j;\n+        for (j = 0; j < 10; j++) {\n+        }\n+        for (int k = 0; k < 10; k++) {\n+            for (int l = 0; l < 10; l++) {\n+            }\n+        }\n+        testHelper(j);\n+        float v = 0;\n+        if (flag == 1) {\n+            if (flag4) {\n+                v += array[i];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    v += array[i];\n+                }\n+            } else {\n+                v += array[i];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    v += array[i];\n+                }\n+            }\n+        }\n+        return v;\n+    }\n+\n+    private static void testHelper(int j) {\n+        if (j == 10) {\n+            return;\n+        }\n+        flagField = 0;\n+    }\n+\n+    private static float testLoopPredication(float[] array, int i, int flag, boolean flag2, boolean flag3, boolean flag4) {\n+        i = Math.min(i, Integer.MAX_VALUE - 2);\n+        if (array == null) {\n+        }\n+        flagField = flag;\n+        int j;\n+        for (j = 0; j < 10; j++) {\n+            for (int k = 0; k < 10; k++) {\n+            }\n+        }\n+        testHelper(j);\n+\n+        float v = 0;\n+        if (flag == 1) {\n+            if (flag4) {\n+                float dummy = array[i];\n+                dummy = array[i + 2];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    for (int m = 0; m < 3; m++) {\n+                        v += array[i + m];\n+                    }\n+                }\n+                volatileField = 42;\n+            } else {\n+                float dummy = array[i];\n+                dummy = array[i + 2];\n+                if (flag2) {\n+                    if (flag3) {\n+                        field = 0x42;\n+                    }\n+                }\n+                if (flagField == 1) {\n+                    for (int m = 0; m < 3; m++) {\n+                        v += array[i + m];\n+                    }\n+                }\n+                volatileField = 42;\n+            }\n+        }\n+\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterSmearingOrPredication.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8319793\n+ * @summary Replacing a test with a dominating test can cause an array access CastII to float above a range check that guards it\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation TestArrayAccessCastIIAboveRC\n+ *\/\n+\n+public class TestArrayAccessCastIIAboveRC {\n+    static int N = 400;\n+    static int iArrFld[] = new int[N];\n+\n+    static void test() {\n+        float fArr[] = new float[N];\n+        int i9, i10, i12;\n+        long lArr1[] = new long[N];\n+        for (i9 = 7; i9 < 43; i9++) {\n+            try {\n+                i10 = 7 % i9;\n+                iArrFld[i9 + 1] = i9 \/ i10;\n+            } catch (ArithmeticException a_e) {\n+            }\n+            for (i12 = 1; 7 > i12; i12++)\n+                lArr1[i9 - 1] = 42;\n+            iArrFld[i12] = 4;\n+            fArr[i9 - 1] = 0;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 50_000; ++i) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessCastIIAboveRC.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}