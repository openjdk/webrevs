{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.ArrayList;\n@@ -38,1 +39,0 @@\n-import java.util.Objects;\n@@ -78,1 +78,1 @@\n-    public static final class ListNodeImpl extends AbstractList<Node> implements ListNode {\n+    public static sealed class ListNodeImpl extends AbstractList<Node> implements ListNode {\n@@ -82,1 +82,1 @@\n-        private final Node[] nodes;\n+        protected final List<Node> nodes;\n@@ -87,1 +87,7 @@\n-            this.nodes = nodes.toArray(Node[]::new);\n+            this.nodes = nodes.toList();\n+        }\n+\n+        protected ListNodeImpl(Style style, ConstantDesc name, List<Node> nodes) {\n+            this.style = style;\n+            this.name = name;\n+            this.nodes = nodes;\n@@ -106,2 +112,1 @@\n-            Objects.checkIndex(index, nodes.length);\n-            return nodes[index];\n+            return nodes.get(index);\n@@ -112,1 +117,1 @@\n-            return nodes.length;\n+            return nodes.size();\n@@ -118,0 +123,6 @@\n+        private static final class PrivateListNodeImpl extends ListNodeImpl {\n+            PrivateListNodeImpl(Style style, ConstantDesc name, Node... n) {\n+                super(style, name, new ArrayList<>(List.of(n)));\n+            }\n+        }\n+\n@@ -201,3 +212,13 @@\n-            for (var n : nodes)\n-                if (n != null && map.put(n.name(), n) != null)\n-                    throw new AssertionError(\"Double entry of \" + n.name() + \" into \" + name);\n+            for (var n : nodes) {\n+                if (n != null) {\n+                    var prev = map.putIfAbsent(n.name(), n);\n+                    if (prev != null) {\n+                        \/\/nodes with duplicite keys are joined into a list\n+                        if (prev instanceof PrivateListNodeImpl list) {\n+                            list.nodes.add(n);\n+                        } else {\n+                            map.put(n.name(), new PrivateListNodeImpl(style, n.name(), prev, n));\n+                        }\n+                    }\n+                }\n+            }\n@@ -978,1 +999,1 @@\n-                            .map(rc -> new MapNodeImpl(BLOCK, \"record\")\n+                            .map(rc -> new MapNodeImpl(BLOCK, \"component\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.classfile.impl.verifier;\n+\n+import java.lang.classfile.Annotation;\n+import java.lang.classfile.AnnotationValue;\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.CLASS_INIT_NAME;\n+import static java.lang.constant.ConstantDescs.INIT_NAME;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.lang.classfile.Attribute;\n+import java.lang.classfile.AttributedElement;\n+import java.lang.classfile.Attributes;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassFileElement;\n+import java.lang.classfile.CodeModel;\n+import java.lang.classfile.CompoundElement;\n+import java.lang.classfile.FieldModel;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.impl.BoundAttribute;\n+import jdk.internal.classfile.impl.Util;\n+\n+\/**\n+ * ParserVerifier performs selected checks of the class file format according to\n+ * {@jvms 4.8 Format Checking}\n+ *\n+ * @see <a href=\"https:\/\/raw.githubusercontent.com\/openjdk\/jdk\/master\/src\/hotspot\/share\/classfile\/classFileParser.cpp\">hotspot\/share\/classfile\/classFileParser.cpp<\/a>\n+ *\/\n+public record ParserVerifier(ClassModel classModel) {\n+\n+    List<VerifyError> verify() {\n+        var errors = new ArrayList<VerifyError>();\n+        verifyConstantPool(errors);\n+        verifyInterfaces(errors);\n+        verifyFields(errors);\n+        verifyMethods(errors);\n+        verifyAttributes(classModel, errors);\n+        return errors;\n+    }\n+\n+    private void verifyConstantPool(List<VerifyError> errors) {\n+        for (var cpe : classModel.constantPool()) {\n+            Consumer<Runnable> check = c -> {\n+                try {\n+                    c.run();\n+                } catch (VerifyError|Exception e) {\n+                    errors.add(new VerifyError(\"%s at constant pool index %d in %s\".formatted(e.getMessage(), cpe.index(), toString(classModel))));\n+                }\n+            };\n+            check.accept(switch (cpe) {\n+                case DoubleEntry de -> de::doubleValue;\n+                case FloatEntry fe -> fe::floatValue;\n+                case IntegerEntry ie -> ie::intValue;\n+                case LongEntry le -> le::longValue;\n+                case Utf8Entry ue -> ue::stringValue;\n+                case ConstantDynamicEntry cde -> cde::asSymbol;\n+                case InvokeDynamicEntry ide -> ide::asSymbol;\n+                case ClassEntry ce -> ce::asSymbol;\n+                case StringEntry se -> se::stringValue;\n+                case MethodHandleEntry mhe -> mhe::asSymbol;\n+                case MethodTypeEntry mte -> mte::asSymbol;\n+                case FieldRefEntry fre -> {\n+                    check.accept(fre.owner()::asSymbol);\n+                    check.accept(fre::typeSymbol);\n+                    yield () -> verifyFieldName(fre.name().stringValue());\n+                }\n+                case InterfaceMethodRefEntry imre -> {\n+                    check.accept(imre.owner()::asSymbol);\n+                    check.accept(imre::typeSymbol);\n+                    yield () -> verifyMethodName(imre.name().stringValue());\n+                }\n+                case MethodRefEntry mre -> {\n+                    check.accept(mre.owner()::asSymbol);\n+                    check.accept(mre::typeSymbol);\n+                    yield () -> verifyMethodName(mre.name().stringValue());\n+                }\n+                case ModuleEntry me -> me::asSymbol;\n+                case NameAndTypeEntry nate -> {\n+                    check.accept(nate.name()::stringValue);\n+                    yield () -> nate.type().stringValue();\n+                }\n+                case PackageEntry pe -> pe::asSymbol;\n+            });\n+        }\n+    }\n+\n+    private void verifyFieldName(String name) {\n+        if (name.length() == 0 || name.chars().anyMatch(ch -> switch(ch) {\n+                    case '.', ';', '[', '\/' -> true;\n+                    default -> false;\n+                })) {\n+              throw new VerifyError(\"Illegal field name %s in %s\".formatted(name, toString(classModel)));\n+        }\n+    }\n+\n+    private void verifyMethodName(String name) {\n+        if (!name.equals(INIT_NAME)\n+            && !name.equals(CLASS_INIT_NAME)\n+            && (name.length() == 0 || name.chars().anyMatch(ch -> switch(ch) {\n+                    case '.', ';', '[', '\/', '<', '>' -> true;\n+                    default -> false;\n+                }))) {\n+              throw new VerifyError(\"Illegal method name %s in %s\".formatted(name, toString(classModel)));\n+        }\n+    }\n+\n+    private void verifyInterfaces(List<VerifyError> errors) {\n+        var intfs = new HashSet<ClassEntry>();\n+        for (var intf : classModel.interfaces()) {\n+            if (!intfs.add(intf)) {\n+                errors.add(new VerifyError(\"Duplicate interface %s in %s\".formatted(intf.asSymbol().displayName(), toString(classModel))));\n+            }\n+        }\n+    }\n+\n+    private void verifyFields(List<VerifyError> errors) {\n+        record F(Utf8Entry name, Utf8Entry type) {};\n+        var fields = new HashSet<F>();\n+        for (var f : classModel.fields()) try {\n+            if (!fields.add(new F(f.fieldName(), f.fieldType()))) {\n+                errors.add(new VerifyError(\"Duplicate field name %s with signature %s in %s\".formatted(f.fieldName().stringValue(), f.fieldType().stringValue(), toString(classModel))));\n+            }\n+            verifyFieldName(f.fieldName().stringValue());\n+        } catch (VerifyError ve) {\n+            errors.add(ve);\n+        }\n+    }\n+\n+    private void verifyMethods(List<VerifyError> errors) {\n+        record M(Utf8Entry name, Utf8Entry type) {};\n+        var methods = new HashSet<M>();\n+        for (var m : classModel.methods()) try {\n+            if (!methods.add(new M(m.methodName(), m.methodType()))) {\n+                errors.add(new VerifyError(\"Duplicate method name %s with signature %s in %s\".formatted(m.methodName().stringValue(), m.methodType().stringValue(), toString(classModel))));\n+            }\n+            if (m.methodName().equalsString(CLASS_INIT_NAME)\n+                    && !m.flags().has(AccessFlag.STATIC)) {\n+                errors.add(new VerifyError(\"Method <clinit> is not static in %s\".formatted(toString(classModel))));\n+            }\n+            if (classModel.flags().has(AccessFlag.INTERFACE)\n+                    && m.methodName().equalsString(INIT_NAME)) {\n+                errors.add(new VerifyError(\"Interface cannot have a method named <init> in %s\".formatted(toString(classModel))));\n+            }\n+            verifyMethodName(m.methodName().stringValue());\n+        } catch (VerifyError ve) {\n+            errors.add(ve);\n+        }\n+    }\n+\n+    private void verifyAttributes(ClassFileElement cfe, List<VerifyError> errors) {\n+        if (cfe instanceof AttributedElement ae) {\n+            var attrNames = new HashSet<String>();\n+            for (var a : ae.attributes()) {\n+                if (!a.attributeMapper().allowMultiple() && !attrNames.add(a.attributeName())) {\n+                    errors.add(new VerifyError(\"Multiple %s attributes in %s\".formatted(a.attributeName(), toString(ae))));\n+                }\n+                verifyAttribute(ae, a, errors);\n+            }\n+        }\n+        switch (cfe) {\n+            case CompoundElement<?> comp -> {\n+                for (var e : comp) verifyAttributes(e, errors);\n+            }\n+            case RecordAttribute ra -> {\n+                for(var rc : ra.components()) verifyAttributes(rc, errors);\n+            }\n+            default -> {}\n+        }\n+    }\n+\n+    private void verifyAttribute(AttributedElement ae, Attribute<?> a, List<VerifyError> errors) {\n+        int size = switch (a) {\n+            case AnnotationDefaultAttribute aa ->\n+                valueSize(aa.defaultValue());\n+            case BootstrapMethodsAttribute bma ->\n+                2 + bma.bootstrapMethods().stream().mapToInt(bm -> 4 + 2 * bm.arguments().size()).sum();\n+            case CharacterRangeTableAttribute cra ->\n+                2 + 14 * cra.characterRangeTable().size();\n+            case CodeAttribute ca -> {\n+                MethodModel mm = (MethodModel)ae;\n+                if (mm.flags().has(AccessFlag.NATIVE) || mm.flags().has(AccessFlag.ABSTRACT)) {\n+                    errors.add(new VerifyError(\"Code attribute in native or abstract %s\".formatted(toString(ae))));\n+                }\n+                if (ca.maxLocals() < Util.maxLocals(mm.flags().flagsMask(), mm.methodTypeSymbol())) {\n+                    errors.add(new VerifyError(\"Arguments can't fit into locals in %s\".formatted(toString(ae))));\n+                }\n+                yield 10 + ca.codeLength() + 8 * ca.exceptionHandlers().size() + attributesSize(ca.attributes());\n+            }\n+            case CompilationIDAttribute cida -> {\n+                cida.compilationId();\n+                yield 2;\n+            }\n+            case ConstantValueAttribute cva -> {\n+                ClassDesc type = ((FieldModel)ae).fieldTypeSymbol();\n+                ConstantValueEntry cve = cva.constant();\n+                if (!switch (TypeKind.from(type)) {\n+                    case BooleanType, ByteType, CharType, IntType, ShortType -> cve instanceof IntegerEntry;\n+                    case DoubleType -> cve instanceof DoubleEntry;\n+                    case FloatType -> cve instanceof FloatEntry;\n+                    case LongType -> cve instanceof LongEntry;\n+                    case ReferenceType -> type.equals(ConstantDescs.CD_String) && cve instanceof StringEntry;\n+                    case VoidType -> false;\n+                }) {\n+                    errors.add(new VerifyError(\"Bad constant value type in %s\".formatted(toString(ae))));\n+                }\n+                yield 2;\n+            }\n+            case DeprecatedAttribute _ ->\n+                0;\n+            case EnclosingMethodAttribute ema -> {\n+                ema.enclosingClass();\n+                ema.enclosingMethod();\n+                yield 4;\n+            }\n+            case ExceptionsAttribute ea ->\n+                2 + 2 * ea.exceptions().size();\n+            case InnerClassesAttribute ica -> {\n+                for (var ici : ica.classes()) {\n+                    if (ici.outerClass().isPresent() && ici.outerClass().get().equals(ici.innerClass())) {\n+                        errors.add(new VerifyError(\"Class is both outer and inner class in %s\".formatted(toString(ae))));\n+                    }\n+                }\n+                yield 2 + 8 * ica.classes().size();\n+            }\n+            case LineNumberTableAttribute lta ->\n+                2 + 4 * lta.lineNumbers().size();\n+            case LocalVariableTableAttribute lvta ->\n+                2 + 10 * lvta.localVariables().size();\n+            case LocalVariableTypeTableAttribute lvta ->\n+                2 + 10 * lvta.localVariableTypes().size();\n+            case MethodParametersAttribute mpa ->\n+                1 + 4 * mpa.parameters().size();\n+            case NestHostAttribute nha -> {\n+                nha.nestHost();\n+                yield 2;\n+            }\n+            case NestMembersAttribute nma -> {\n+                if (ae.findAttribute(Attributes.NEST_HOST).isPresent()) {\n+                    errors.add(new VerifyError(\"Conflicting NestHost and NestMembers attributes in %s\".formatted(toString(ae))));\n+                }\n+                yield 2 + 2 * nma.nestMembers().size();\n+            }\n+            case PermittedSubclassesAttribute psa -> {\n+                if (classModel.flags().has(AccessFlag.FINAL)) {\n+                    errors.add(new VerifyError(\"PermittedSubclasses attribute in final %s\".formatted(toString(ae))));\n+                }\n+                yield 2 + 2 * psa.permittedSubclasses().size();\n+            }\n+            case RecordAttribute ra ->\n+                componentsSize(ra.components());\n+            case RuntimeVisibleAnnotationsAttribute aa ->\n+                annotationsSize(aa.annotations());\n+            case RuntimeInvisibleAnnotationsAttribute aa ->\n+                annotationsSize(aa.annotations());\n+            case RuntimeVisibleParameterAnnotationsAttribute aa ->\n+                parameterAnnotationsSize(aa.parameterAnnotations());\n+            case RuntimeInvisibleParameterAnnotationsAttribute aa ->\n+                parameterAnnotationsSize(aa.parameterAnnotations());\n+            case SignatureAttribute sa -> {\n+                sa.signature();\n+                yield 2;\n+            }\n+            case SourceDebugExtensionAttribute sda ->\n+                sda.contents().length;\n+            case SourceFileAttribute sfa -> {\n+                sfa.sourceFile();\n+                yield 2;\n+            }\n+            case SourceIDAttribute sida -> {\n+                sida.sourceId();\n+                yield 2;\n+            }\n+            case SyntheticAttribute _ ->\n+                0;\n+            default ->\n+                -1;\n+        };\n+        if (size >= 0 && size != ((BoundAttribute)a).payloadLen()) {\n+            errors.add(new VerifyError(\"Wrong %s attribute length in %s\".formatted(a.attributeName(), toString(ae))));\n+        }\n+    }\n+\n+    private static int componentsSize(List<RecordComponentInfo> comps) {\n+        int l = 2;\n+        for (var rc : comps) {\n+            l += 4 + attributesSize(rc.attributes());\n+        }\n+        return l;\n+    }\n+\n+    private static int attributesSize(List<Attribute<?>> attrs) {\n+        int l = 2;\n+        for (var a : attrs) {\n+            l += 6 + ((BoundAttribute)a).payloadLen();\n+        }\n+        return l;\n+    }\n+\n+    private static int parameterAnnotationsSize(List<List<Annotation>> pans) {\n+        int l = 1;\n+        for (var ans : pans) {\n+            l += annotationsSize(ans);\n+        }\n+        return l;\n+    }\n+\n+    private static int annotationsSize(List<Annotation> ans) {\n+        int l = 2;\n+        for (var an : ans) {\n+            l += annotationSize(an);\n+        }\n+        return l;\n+    }\n+\n+    private static int annotationSize(Annotation an) {\n+        int l = 4;\n+        for (var el : an.elements()) {\n+            l += 2 + valueSize(el.value());\n+        }\n+        return l;\n+    }\n+\n+    private static int valueSize(AnnotationValue val) {\n+        return 1 + switch (val) {\n+            case AnnotationValue.OfAnnotation oan ->\n+                annotationSize(oan.annotation());\n+            case AnnotationValue.OfArray oar -> {\n+                int l = 2;\n+                for (var v : oar.values()) {\n+                    l += valueSize(v);\n+                }\n+                yield l;\n+            }\n+            case AnnotationValue.OfConstant _, AnnotationValue.OfClass _ -> 2;\n+            case AnnotationValue.OfEnum _ -> 4;\n+        };\n+    }\n+\n+    private String className() {\n+        return classModel.thisClass().asSymbol().displayName();\n+    }\n+\n+    private String toString(AttributedElement ae) {\n+        return switch (ae) {\n+            case CodeModel m -> \"Code attribute for \" + toString(m.parent().get());\n+            case FieldModel m -> \"field %s.%s\".formatted(\n+                    className(),\n+                    m.fieldName().stringValue());\n+            case MethodModel m -> \"method %s::%s(%s)\".formatted(\n+                    className(),\n+                    m.methodName().stringValue(),\n+                    m.methodTypeSymbol().parameterList().stream().map(ClassDesc::displayName).collect(Collectors.joining(\",\")));\n+            case RecordComponentInfo i -> \"Record component %s of class %s\".formatted(\n+                    i.name().stringValue(),\n+                    className());\n+            default -> \"class \" + className();\n+        };\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -36,0 +37,1 @@\n+import java.util.stream.Collectors;\n@@ -132,0 +134,4 @@\n+        String parameters() {\n+            return m.methodTypeSymbol().parameterList().stream().map(ClassDesc::displayName).collect(Collectors.joining(\",\"));\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerificationWrapper.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,0 +44,5 @@\n+ * VerifierImpl performs selected checks and verifications of the class file\n+ * format according to {@jvms 4.8 Format Checking},\n+ * {@jvms 4.9 Constraints on Java Virtual Machine code},\n+ * {@jvms 4.10 Verification of class Files} and {@jvms 6.5 Instructions}\n+ *\n@@ -113,3 +118,0 @@\n-        if (!is_eligible_for_verification(klass)) {\n-            return List.of();\n-        }\n@@ -118,5 +120,11 @@\n-            if (klass.majorVersion() >= STACKMAP_ATTRIBUTE_MAJOR_VERSION) {\n-                var errors = new VerifierImpl(klass, classHierarchyResolver, logger).verify_class();\n-                if (!errors.isEmpty() && klass.majorVersion() < NOFAILOVER_MAJOR_VERSION) {\n-                    log_info(logger, \"Fail over class verification to old verifier for: %s\", klass.thisClassName());\n-                    return inference_verify(klass);\n+            var errors = new ArrayList<VerifyError>();\n+            errors.addAll(new ParserVerifier(classModel).verify());\n+            if (is_eligible_for_verification(klass)) {\n+                if (klass.majorVersion() >= STACKMAP_ATTRIBUTE_MAJOR_VERSION) {\n+                    var verifierErrors = new VerifierImpl(klass, classHierarchyResolver, logger).verify_class();\n+                    if (!verifierErrors.isEmpty() && klass.majorVersion() < NOFAILOVER_MAJOR_VERSION) {\n+                        log_info(logger, \"Fail over class verification to old verifier for: %s\", klass.thisClassName());\n+                        errors.addAll(inference_verify(klass));\n+                    } else {\n+                        errors.addAll(verifierErrors);\n+                    }\n@@ -124,1 +132,1 @@\n-                    return errors;\n+                    errors.addAll(inference_verify(klass));\n@@ -126,2 +134,0 @@\n-            } else {\n-                return inference_verify(klass);\n@@ -129,0 +135,1 @@\n+            return errors;\n@@ -284,1 +291,1 @@\n-            verify_method(m, m.maxLocals(), m.maxStack(), m.stackMapTableRawData());\n+            verify_method(m);\n@@ -294,1 +301,1 @@\n-    void verify_method(VerificationWrapper.MethodWrapper m, int max_locals, int max_stack, byte[] stackmap_data) {\n+    void verify_method(VerificationWrapper.MethodWrapper m) {\n@@ -297,0 +304,5 @@\n+        byte[] codeArray = m.codeArray();\n+        if (codeArray == null) verifyError(\"Missing Code attribute\");\n+        int max_locals = m.maxLocals();\n+        int max_stack = m.maxStack();\n+        byte[] stackmap_data = m.stackMapTableRawData();\n@@ -306,1 +318,1 @@\n-        var code = ByteBuffer.wrap(_method.codeArray(), 0, _method.codeLength());\n+        var code = ByteBuffer.wrap(codeArray, 0, _method.codeLength());\n@@ -1820,1 +1832,1 @@\n-        throw new VerifyError(String.format(\"%s at %s.%s%s @%d %s\", msg, _klass.thisClassName(), _method.name(), _method.descriptor(), bci, errorContext));\n+        throw new VerifyError(String.format(\"%s in %s::%s(%s) @%d %s\", msg, _klass.thisClassName(), _method.name(), _method.parameters(), bci, errorContext).trim());\n@@ -1825,1 +1837,1 @@\n-        throw new VerifyError(String.format(\"%s at %s.%s%s @%d %s%n  while assigning %s%n  to %s\", msg, _klass.thisClassName(), _method.name(), _method.descriptor(), bci, errorContext, from, target));\n+        throw new VerifyError(String.format(\"%s in %s::%s(%s) @%d %s%n  while assigning %s%n  to %s\", msg, _klass.thisClassName(), _method.name(), _method.parameters(), bci, errorContext, from, target));\n@@ -1830,1 +1842,1 @@\n-        throw new ClassFormatError(String.format(\"%s at %s.%s%s\", msg, _klass.thisClassName(), _method.name(), _method.descriptor()));\n+        throw new VerifyError(String.format(\"%s in %s::%s(%s)\", msg, _klass.thisClassName(), _method.name(), _method.parameters()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -733,1 +733,1 @@\n-                        <record>\n+                        <component>\n@@ -739,1 +739,1 @@\n-                                <anno><annotation_class>LBoo;<\/annotation_class><target_info>FIELD<\/target_info><values><\/values><\/anno><\/invisible_type_annotations><\/record><\/record_components>\n+                                <anno><annotation_class>LBoo;<\/annotation_class><target_info>FIELD<\/target_info><values><\/values><\/anno><\/invisible_type_annotations><\/component><\/record_components>\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -30,0 +31,3 @@\n+import java.lang.constant.ClassDesc;\n+import static java.lang.constant.ConstantDescs.*;\n+import java.lang.invoke.MethodHandleInfo;\n@@ -35,0 +39,5 @@\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n@@ -36,4 +45,3 @@\n-import java.lang.classfile.ClassHierarchyResolver;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.CodeModel;\n-import java.lang.classfile.MethodModel;\n+import java.lang.classfile.*;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.components.ClassPrinter;\n@@ -41,0 +49,1 @@\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -86,0 +95,253 @@\n+\n+    @Test\n+    void testParserVerification() {\n+        var cc = ClassFile.of();\n+        var cd_test = ClassDesc.of(\"ParserVerificationTestClass\");\n+        var indexes = new Object[9];\n+        var clm = cc.parse(cc.build(cd_test, clb -> {\n+            clb.withFlags(ClassFile.ACC_INTERFACE | ClassFile.ACC_FINAL);\n+            var cp = clb.constantPool();\n+            var ce_valid = cp.classEntry(cd_test);\n+            var ce_invalid = cp.classEntry(cp.utf8Entry(\"invalid.class.name\"));\n+            indexes[0] = ce_invalid.index();\n+            var nate_invalid_field = cp.nameAndTypeEntry(\"field;\", CD_int);\n+            var nate_invalid_method = cp.nameAndTypeEntry(\"method;\", MTD_void);\n+            var bsme = cp.bsmEntry(BSM_INVOKE, List.of());\n+            indexes[1] = cp.methodTypeEntry(cp.utf8Entry(\"invalid method type\")).index();\n+            indexes[2] = cp.constantDynamicEntry(bsme, nate_invalid_method).index();\n+            indexes[3] = cp.invokeDynamicEntry(bsme, nate_invalid_field).index();\n+            indexes[4] = cp.fieldRefEntry(ce_invalid, nate_invalid_method).index();\n+            indexes[5] = cp.methodRefEntry(ce_invalid, nate_invalid_field).index();\n+            indexes[6] = cp.interfaceMethodRefEntry(ce_invalid, nate_invalid_field).index();\n+            indexes[7] = cp.methodHandleEntry(MethodHandleInfo.REF_getField, cp.methodRefEntry(cd_test, \"method\", MTD_void)).index();\n+            indexes[8] = cp.methodHandleEntry(MethodHandleInfo.REF_invokeVirtual, cp.fieldRefEntry(cd_test, \"field\", CD_int)).index();\n+            patch(clb,\n+                CompilationIDAttribute.of(\"12345\"),\n+                DeprecatedAttribute.of(),\n+                EnclosingMethodAttribute.of(cd_test, Optional.empty(), Optional.empty()),\n+                InnerClassesAttribute.of(InnerClassInfo.of(cd_test, Optional.of(cd_test), Optional.of(\"inner\"), 0)),\n+                NestHostAttribute.of(cd_test),\n+                NestMembersAttribute.ofSymbols(cd_test),\n+                PermittedSubclassesAttribute.ofSymbols(cd_test),\n+                RecordAttribute.of(RecordComponentInfo.of(\"c\", CD_String, patch(\n+                        SignatureAttribute.of(Signature.of(CD_String)),\n+                        RuntimeVisibleAnnotationsAttribute.of(),\n+                        RuntimeInvisibleAnnotationsAttribute.of(),\n+                        RuntimeVisibleTypeAnnotationsAttribute.of(),\n+                        RuntimeInvisibleTypeAnnotationsAttribute.of()))),\n+                RuntimeVisibleAnnotationsAttribute.of(),\n+                RuntimeInvisibleAnnotationsAttribute.of(),\n+                RuntimeVisibleTypeAnnotationsAttribute.of(),\n+                RuntimeInvisibleTypeAnnotationsAttribute.of(),\n+                SignatureAttribute.of(ClassSignature.of(Signature.ClassTypeSig.of(cd_test))),\n+                SourceDebugExtensionAttribute.of(\"sde\".getBytes()),\n+                SourceFileAttribute.of(\"ParserVerificationTestClass.java\"),\n+                SourceIDAttribute.of(\"sID\"),\n+                SyntheticAttribute.of())\n+                    .withInterfaceSymbols(CD_List, CD_List)\n+                    .withField(\"f\", CD_String, fb -> patch(fb,\n+                            ConstantValueAttribute.of(0),\n+                            DeprecatedAttribute.of(),\n+                            RuntimeVisibleAnnotationsAttribute.of(),\n+                            RuntimeInvisibleAnnotationsAttribute.of(),\n+                            RuntimeVisibleTypeAnnotationsAttribute.of(),\n+                            RuntimeInvisibleTypeAnnotationsAttribute.of(),\n+                            SignatureAttribute.of(Signature.of(CD_String)),\n+                            SyntheticAttribute.of()))\n+                    .withField(\"\/\", CD_int, 0)\n+                    .withField(\"\/\", CD_int, 0)\n+                    .withMethod(\"m\", MTD_void, ClassFile.ACC_ABSTRACT | ClassFile.ACC_STATIC, mb -> patch(mb,\n+                            AnnotationDefaultAttribute.of(AnnotationValue.ofInt(0)),\n+                            DeprecatedAttribute.of(),\n+                            ExceptionsAttribute.ofSymbols(CD_Exception),\n+                            MethodParametersAttribute.of(MethodParameterInfo.ofParameter(Optional.empty(), 0)),\n+                            RuntimeVisibleAnnotationsAttribute.of(),\n+                            RuntimeInvisibleAnnotationsAttribute.of(),\n+                            RuntimeVisibleParameterAnnotationsAttribute.of(List.of()),\n+                            RuntimeInvisibleParameterAnnotationsAttribute.of(List.of()),\n+                            SignatureAttribute.of(MethodSignature.of(MTD_void)),\n+                            SyntheticAttribute.of())\n+                            .withCode(cob ->\n+                                cob.return_()\n+                                   .with(new CloneAttribute(CharacterRangeTableAttribute.of(List.of())))\n+                                   .with(new CloneAttribute(LineNumberTableAttribute.of(List.of())))\n+                                   .with(new CloneAttribute(LocalVariableTableAttribute.of(List.of())))\n+                                   .with(new CloneAttribute(LocalVariableTypeTableAttribute.of(List.of())))))\n+                    .withMethod(\"<>\", MTD_void, ClassFile.ACC_NATIVE, mb -> {})\n+                    .withMethod(\"<>\", MTD_void, ClassFile.ACC_NATIVE, mb -> {})\n+                    .withMethod(INIT_NAME, MTD_void, 0, mb -> {})\n+                    .withMethod(CLASS_INIT_NAME, MTD_void, 0, mb -> {});\n+                }));\n+        var found = cc.verify(clm).stream().map(VerifyError::getMessage).collect(Collectors.toCollection(LinkedList::new));\n+        var expected = \"\"\"\n+                Invalid class name: invalid.class.name at constant pool index %1$d in class ParserVerificationTestClass\n+                Bad method descriptor: invalid method type at constant pool index %2$d in class ParserVerificationTestClass\n+                not a valid reference type descriptor: ()V at constant pool index %3$d in class ParserVerificationTestClass\n+                Bad method descriptor: I at constant pool index %4$d in class ParserVerificationTestClass\n+                not a valid reference type descriptor: ()V at constant pool index %5$d in class ParserVerificationTestClass\n+                Invalid class name: invalid.class.name at constant pool index %5$d in class ParserVerificationTestClass\n+                Illegal field name method; in class ParserVerificationTestClass at constant pool index %5$d in class ParserVerificationTestClass\n+                Bad method descriptor: I at constant pool index %6$d in class ParserVerificationTestClass\n+                Invalid class name: invalid.class.name at constant pool index %6$d in class ParserVerificationTestClass\n+                Illegal method name field; in class ParserVerificationTestClass at constant pool index %6$d in class ParserVerificationTestClass\n+                Bad method descriptor: I at constant pool index %7$d in class ParserVerificationTestClass\n+                Invalid class name: invalid.class.name at constant pool index %7$d in class ParserVerificationTestClass\n+                Illegal method name field; in class ParserVerificationTestClass at constant pool index %7$d in class ParserVerificationTestClass\n+                not a valid reference type descriptor: ()V at constant pool index %8$d in class ParserVerificationTestClass\n+                Bad method descriptor: I at constant pool index %9$d in class ParserVerificationTestClass\n+                Duplicate interface List in class ParserVerificationTestClass\n+                Illegal field name \/ in class ParserVerificationTestClass\n+                Duplicate field name \/ with signature I in class ParserVerificationTestClass\n+                Illegal field name \/ in class ParserVerificationTestClass\n+                Illegal method name <> in class ParserVerificationTestClass\n+                Duplicate method name <> with signature ()V in class ParserVerificationTestClass\n+                Illegal method name <> in class ParserVerificationTestClass\n+                Interface cannot have a method named <init> in class ParserVerificationTestClass\n+                Method <clinit> is not static in class ParserVerificationTestClass\n+                Wrong CompilationID attribute length in class ParserVerificationTestClass\n+                Wrong Deprecated attribute length in class ParserVerificationTestClass\n+                Multiple EnclosingMethod attributes in class ParserVerificationTestClass\n+                Wrong EnclosingMethod attribute length in class ParserVerificationTestClass\n+                Class is both outer and inner class in class ParserVerificationTestClass\n+                Multiple InnerClasses attributes in class ParserVerificationTestClass\n+                Class is both outer and inner class in class ParserVerificationTestClass\n+                Wrong InnerClasses attribute length in class ParserVerificationTestClass\n+                Multiple NestHost attributes in class ParserVerificationTestClass\n+                Wrong NestHost attribute length in class ParserVerificationTestClass\n+                Conflicting NestHost and NestMembers attributes in class ParserVerificationTestClass\n+                Multiple NestMembers attributes in class ParserVerificationTestClass\n+                Conflicting NestHost and NestMembers attributes in class ParserVerificationTestClass\n+                Wrong NestMembers attribute length in class ParserVerificationTestClass\n+                PermittedSubclasses attribute in final class ParserVerificationTestClass\n+                Multiple PermittedSubclasses attributes in class ParserVerificationTestClass\n+                PermittedSubclasses attribute in final class ParserVerificationTestClass\n+                Wrong PermittedSubclasses attribute length in class ParserVerificationTestClass\n+                Multiple Record attributes in class ParserVerificationTestClass\n+                Wrong Record attribute length in class ParserVerificationTestClass\n+                Multiple RuntimeVisibleAnnotations attributes in class ParserVerificationTestClass\n+                Wrong RuntimeVisibleAnnotations attribute length in class ParserVerificationTestClass\n+                Multiple RuntimeInvisibleAnnotations attributes in class ParserVerificationTestClass\n+                Wrong RuntimeInvisibleAnnotations attribute length in class ParserVerificationTestClass\n+                Multiple RuntimeVisibleTypeAnnotations attributes in class ParserVerificationTestClass\n+                Multiple RuntimeInvisibleTypeAnnotations attributes in class ParserVerificationTestClass\n+                Multiple Signature attributes in class ParserVerificationTestClass\n+                Wrong Signature attribute length in class ParserVerificationTestClass\n+                Multiple SourceDebugExtension attributes in class ParserVerificationTestClass\n+                Multiple SourceFile attributes in class ParserVerificationTestClass\n+                Wrong SourceFile attribute length in class ParserVerificationTestClass\n+                Multiple SourceID attributes in class ParserVerificationTestClass\n+                Wrong SourceID attribute length in class ParserVerificationTestClass\n+                Wrong Synthetic attribute length in class ParserVerificationTestClass\n+                Bad constant value type in field ParserVerificationTestClass.f\n+                Multiple ConstantValue attributes in field ParserVerificationTestClass.f\n+                Bad constant value type in field ParserVerificationTestClass.f\n+                Wrong ConstantValue attribute length in field ParserVerificationTestClass.f\n+                Wrong Deprecated attribute length in field ParserVerificationTestClass.f\n+                Multiple RuntimeVisibleAnnotations attributes in field ParserVerificationTestClass.f\n+                Wrong RuntimeVisibleAnnotations attribute length in field ParserVerificationTestClass.f\n+                Multiple RuntimeInvisibleAnnotations attributes in field ParserVerificationTestClass.f\n+                Wrong RuntimeInvisibleAnnotations attribute length in field ParserVerificationTestClass.f\n+                Multiple RuntimeVisibleTypeAnnotations attributes in field ParserVerificationTestClass.f\n+                Multiple RuntimeInvisibleTypeAnnotations attributes in field ParserVerificationTestClass.f\n+                Multiple Signature attributes in field ParserVerificationTestClass.f\n+                Wrong Signature attribute length in field ParserVerificationTestClass.f\n+                Wrong Synthetic attribute length in field ParserVerificationTestClass.f\n+                Multiple AnnotationDefault attributes in method ParserVerificationTestClass::m()\n+                Wrong AnnotationDefault attribute length in method ParserVerificationTestClass::m()\n+                Wrong Deprecated attribute length in method ParserVerificationTestClass::m()\n+                Multiple Exceptions attributes in method ParserVerificationTestClass::m()\n+                Wrong Exceptions attribute length in method ParserVerificationTestClass::m()\n+                Multiple MethodParameters attributes in method ParserVerificationTestClass::m()\n+                Wrong MethodParameters attribute length in method ParserVerificationTestClass::m()\n+                Multiple RuntimeVisibleAnnotations attributes in method ParserVerificationTestClass::m()\n+                Wrong RuntimeVisibleAnnotations attribute length in method ParserVerificationTestClass::m()\n+                Multiple RuntimeInvisibleAnnotations attributes in method ParserVerificationTestClass::m()\n+                Wrong RuntimeInvisibleAnnotations attribute length in method ParserVerificationTestClass::m()\n+                Multiple RuntimeVisibleParameterAnnotations attributes in method ParserVerificationTestClass::m()\n+                Wrong RuntimeVisibleParameterAnnotations attribute length in method ParserVerificationTestClass::m()\n+                Multiple RuntimeInvisibleParameterAnnotations attributes in method ParserVerificationTestClass::m()\n+                Wrong RuntimeInvisibleParameterAnnotations attribute length in method ParserVerificationTestClass::m()\n+                Multiple Signature attributes in method ParserVerificationTestClass::m()\n+                Wrong Signature attribute length in method ParserVerificationTestClass::m()\n+                Wrong Synthetic attribute length in method ParserVerificationTestClass::m()\n+                Code attribute in native or abstract method ParserVerificationTestClass::m()\n+                Wrong CharacterRangeTable attribute length in Code attribute for method ParserVerificationTestClass::m()\n+                Wrong LineNumberTable attribute length in Code attribute for method ParserVerificationTestClass::m()\n+                Wrong LocalVariableTable attribute length in Code attribute for method ParserVerificationTestClass::m()\n+                Wrong LocalVariableTypeTable attribute length in Code attribute for method ParserVerificationTestClass::m()\n+                Multiple Signature attributes in Record component c of class ParserVerificationTestClass\n+                Wrong Signature attribute length in Record component c of class ParserVerificationTestClass\n+                Multiple RuntimeVisibleAnnotations attributes in Record component c of class ParserVerificationTestClass\n+                Wrong RuntimeVisibleAnnotations attribute length in Record component c of class ParserVerificationTestClass\n+                Multiple RuntimeInvisibleAnnotations attributes in Record component c of class ParserVerificationTestClass\n+                Wrong RuntimeInvisibleAnnotations attribute length in Record component c of class ParserVerificationTestClass\n+                Multiple RuntimeVisibleTypeAnnotations attributes in Record component c of class ParserVerificationTestClass\n+                Multiple RuntimeInvisibleTypeAnnotations attributes in Record component c of class ParserVerificationTestClass\n+                Multiple Signature attributes in Record component c of class ParserVerificationTestClass\n+                Wrong Signature attribute length in Record component c of class ParserVerificationTestClass\n+                Multiple RuntimeVisibleAnnotations attributes in Record component c of class ParserVerificationTestClass\n+                Wrong RuntimeVisibleAnnotations attribute length in Record component c of class ParserVerificationTestClass\n+                Multiple RuntimeInvisibleAnnotations attributes in Record component c of class ParserVerificationTestClass\n+                Wrong RuntimeInvisibleAnnotations attribute length in Record component c of class ParserVerificationTestClass\n+                Multiple RuntimeVisibleTypeAnnotations attributes in Record component c of class ParserVerificationTestClass\n+                Multiple RuntimeInvisibleTypeAnnotations attributes in Record component c of class ParserVerificationTestClass\n+                Missing Code attribute in ParserVerificationTestClass::<init>() @0\n+                Missing Code attribute in ParserVerificationTestClass::<clinit>() @0\n+                \"\"\".formatted(indexes).lines().filter(exp -> !found.remove(exp)).toList();\n+        if (!found.isEmpty() || !expected.isEmpty()) {\n+            ClassPrinter.toYaml(clm, ClassPrinter.Verbosity.TRACE_ALL, System.out::print);\n+            fail(\"\"\"\n+\n+                 Expected:\n+                   %s\n+\n+                 Found:\n+                   %s\n+                 \"\"\".formatted(expected.stream().collect(Collectors.joining(\"\\n  \")), found.stream().collect(Collectors.joining(\"\\n  \"))));\n+        }\n+    }\n+\n+    private static class CloneAttribute extends CustomAttribute<CloneAttribute> {\n+        CloneAttribute(Attribute a) {\n+            super(new AttributeMapper<CloneAttribute>(){\n+                @Override\n+                public String name() {\n+                    return a.attributeName();\n+                }\n+\n+                @Override\n+                public CloneAttribute readAttribute(AttributedElement enclosing, ClassReader cf, int pos) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                @Override\n+                public void writeAttribute(BufWriter buf, CloneAttribute attr) {\n+                    int start = buf.size();\n+                    a.attributeMapper().writeAttribute(buf, a);\n+                    buf.writeU1(0); \/\/writes additional byte to the attribute payload\n+                    buf.patchInt(start + 2, 4, buf.size() - start - 6);\n+                }\n+\n+                @Override\n+                public AttributeMapper.AttributeStability stability() {\n+                    return a.attributeMapper().stability();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static <B extends ClassFileBuilder> B patch(B b, Attribute... attrs) {\n+        for (var a : attrs) {\n+            b.with(a).with(new CloneAttribute(a));\n+        }\n+        return b;\n+    }\n+\n+    private static List<Attribute<?>> patch(Attribute... attrs) {\n+        var lst = new ArrayList<Attribute<?>>(attrs.length * 2);\n+        for (var a : attrs) {\n+            lst.add(a);\n+            lst.add(new CloneAttribute(a));\n+        }\n+        return lst;\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/VerifierSelfTest.java","additions":266,"deletions":4,"binary":false,"changes":270,"status":"modified"}]}