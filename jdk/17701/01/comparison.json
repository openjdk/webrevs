{"files":[{"patch":"@@ -4268,0 +4268,2 @@\n+    \/\/ Registers v0..v7 are used as data registers.\n+    \/\/ Registers v16..v31 are used as tmp registers.\n@@ -4269,14 +4271,15 @@\n-    ldrq(v1, Address(buf, 0x10));\n-    ldrq(v2, Address(buf, 0x20));\n-    ldrq(v3, Address(buf, 0x30));\n-    ldrq(v4, Address(buf, 0x40));\n-    ldrq(v5, Address(buf, 0x50));\n-    ldrq(v6, Address(buf, 0x60));\n-    ldrq(v7, Address(buf, 0x70));\n-    ldrq(v8, Address(pre(buf, 0x80)));\n-\n-    movi(v25, T4S, 0);\n-    mov(v25, S, 0, crc);\n-    eor(v1, T16B, v1, v25);\n-\n-    ldrq(v0, Address(table));\n+    ldrq(v0, Address(buf, 0x10));\n+    ldrq(v1, Address(buf, 0x20));\n+    ldrq(v2, Address(buf, 0x30));\n+    ldrq(v3, Address(buf, 0x40));\n+    ldrq(v4, Address(buf, 0x50));\n+    ldrq(v5, Address(buf, 0x60));\n+    ldrq(v6, Address(buf, 0x70));\n+    ldrq(v7, Address(pre(buf, 0x80)));\n+\n+    movi(v31, T4S, 0);\n+    mov(v31, S, 0, crc);\n+    eor(v0, T16B, v0, v31);\n+\n+    \/\/ Register v16 contains constants from the crc table.\n+    ldrq(v16, Address(table));\n@@ -4287,39 +4290,41 @@\n-    pmull (v9,  T1Q, v1, v0, T1D);\n-    pmull2(v10, T1Q, v1, v0, T2D);\n-    ldrq(v1, Address(buf, 0x10));\n-    eor3(v1, T16B, v9,  v10, v1);\n-\n-    pmull (v11, T1Q, v2, v0, T1D);\n-    pmull2(v12, T1Q, v2, v0, T2D);\n-    ldrq(v2, Address(buf, 0x20));\n-    eor3(v2, T16B, v11, v12, v2);\n-\n-    pmull (v13, T1Q, v3, v0, T1D);\n-    pmull2(v14, T1Q, v3, v0, T2D);\n-    ldrq(v3, Address(buf, 0x30));\n-    eor3(v3, T16B, v13, v14, v3);\n-\n-    pmull (v15, T1Q, v4, v0, T1D);\n-    pmull2(v16, T1Q, v4, v0, T2D);\n-    ldrq(v4, Address(buf, 0x40));\n-    eor3(v4, T16B, v15, v16, v4);\n-\n-    pmull (v17, T1Q, v5, v0, T1D);\n-    pmull2(v18, T1Q, v5, v0, T2D);\n-    ldrq(v5, Address(buf, 0x50));\n-    eor3(v5, T16B, v17, v18, v5);\n-\n-    pmull (v19, T1Q, v6, v0, T1D);\n-    pmull2(v20, T1Q, v6, v0, T2D);\n-    ldrq(v6, Address(buf, 0x60));\n-    eor3(v6, T16B, v19, v20, v6);\n-\n-    pmull (v21, T1Q, v7, v0, T1D);\n-    pmull2(v22, T1Q, v7, v0, T2D);\n-    ldrq(v7, Address(buf, 0x70));\n-    eor3(v7, T16B, v21, v22, v7);\n-\n-    pmull (v23, T1Q, v8, v0, T1D);\n-    pmull2(v24, T1Q, v8, v0, T2D);\n-    ldrq(v8, Address(pre(buf, 0x80)));\n-    eor3(v8, T16B, v23, v24, v8);\n+    pmull (v17,  T1Q, v0, v16, T1D);\n+    pmull2(v18, T1Q, v0, v16, T2D);\n+    ldrq(v0, Address(buf, 0x10));\n+    eor3(v0, T16B, v17,  v18, v0);\n+\n+    pmull (v19, T1Q, v1, v16, T1D);\n+    pmull2(v20, T1Q, v1, v16, T2D);\n+    ldrq(v1, Address(buf, 0x20));\n+    eor3(v1, T16B, v19, v20, v1);\n+\n+    pmull (v21, T1Q, v2, v16, T1D);\n+    pmull2(v22, T1Q, v2, v16, T2D);\n+    ldrq(v2, Address(buf, 0x30));\n+    eor3(v2, T16B, v21, v22, v2);\n+\n+    pmull (v23, T1Q, v3, v16, T1D);\n+    pmull2(v24, T1Q, v3, v16, T2D);\n+    ldrq(v3, Address(buf, 0x40));\n+    eor3(v3, T16B, v23, v24, v3);\n+\n+    pmull (v25, T1Q, v4, v16, T1D);\n+    pmull2(v26, T1Q, v4, v16, T2D);\n+    ldrq(v4, Address(buf, 0x50));\n+    eor3(v4, T16B, v25, v26, v4);\n+\n+    pmull (v27, T1Q, v5, v16, T1D);\n+    pmull2(v28, T1Q, v5, v16, T2D);\n+    ldrq(v5, Address(buf, 0x60));\n+    eor3(v5, T16B, v27, v28, v5);\n+\n+    pmull (v29, T1Q, v6, v16, T1D);\n+    pmull2(v30, T1Q, v6, v16, T2D);\n+    ldrq(v6, Address(buf, 0x70));\n+    eor3(v6, T16B, v29, v30, v6);\n+\n+    \/\/ Reuse registers v23, v24.\n+    \/\/ Using them won't block the first instruction of the next iteration.\n+    pmull (v23, T1Q, v7, v16, T1D);\n+    pmull2(v24, T1Q, v7, v16, T2D);\n+    ldrq(v7, Address(pre(buf, 0x80)));\n+    eor3(v7, T16B, v23, v24, v7);\n@@ -4331,1 +4336,2 @@\n-    ldrq(v0, Address(table, 0x10));\n+    \/\/ Use v31 for constants because v16 can be still in use.\n+    ldrq(v31, Address(table, 0x10));\n@@ -4333,3 +4339,3 @@\n-    pmull (v10,  T1Q, v1, v0, T1D);\n-    pmull2(v11, T1Q, v1, v0, T2D);\n-    eor3(v1, T16B, v10, v11, v5);\n+    pmull (v17,  T1Q, v0, v31, T1D);\n+    pmull2(v18, T1Q, v0, v31, T2D);\n+    eor3(v0, T16B, v17, v18, v4);\n@@ -4337,3 +4343,3 @@\n-    pmull (v12, T1Q, v2, v0, T1D);\n-    pmull2(v13, T1Q, v2, v0, T2D);\n-    eor3(v2, T16B, v12, v13, v6);\n+    pmull (v19, T1Q, v1, v31, T1D);\n+    pmull2(v20, T1Q, v1, v31, T2D);\n+    eor3(v1, T16B, v19, v20, v5);\n@@ -4341,3 +4347,3 @@\n-    pmull (v14, T1Q, v3, v0, T1D);\n-    pmull2(v15, T1Q, v3, v0, T2D);\n-    eor3(v3, T16B, v14, v15, v7);\n+    pmull (v21, T1Q, v2, v31, T1D);\n+    pmull2(v22, T1Q, v2, v31, T2D);\n+    eor3(v2, T16B, v21, v22, v6);\n@@ -4345,3 +4351,3 @@\n-    pmull (v16, T1Q, v4, v0, T1D);\n-    pmull2(v17, T1Q, v4, v0, T2D);\n-    eor3(v4, T16B, v16, v17, v8);\n+    pmull (v23, T1Q, v3, v31, T1D);\n+    pmull2(v24, T1Q, v3, v31, T2D);\n+    eor3(v3, T16B, v23, v24, v7);\n@@ -4350,14 +4356,17 @@\n-    ldrq(v5, Address(table, 0x20));\n-    pmull (v10, T1Q, v1, v5, T1D);\n-    pmull2(v11, T1Q, v1, v5, T2D);\n-    eor3(v4, T16B, v4, v10, v11);\n-\n-    ldrq(v6, Address(table, 0x30));\n-    pmull (v12, T1Q, v2, v6, T1D);\n-    pmull2(v13, T1Q, v2, v6, T2D);\n-    eor3(v4, T16B, v4, v12, v13);\n-\n-    ldrq(v7, Address(table, 0x40));\n-    pmull (v14, T1Q, v3, v7, T1D);\n-    pmull2(v15, T1Q, v3, v7, T2D);\n-    eor3(v1, T16B, v4, v14, v15);\n+    \/\/ Use v17 for constants because v31 can be still in use.\n+    ldrq(v17, Address(table, 0x20));\n+    pmull (v25, T1Q, v0, v17, T1D);\n+    pmull2(v26, T1Q, v0, v17, T2D);\n+    eor3(v3, T16B, v3, v25, v26);\n+\n+    \/\/ Use v18 for constants because v17 can be still in use.\n+    ldrq(v18, Address(table, 0x30));\n+    pmull (v27, T1Q, v1, v18, T1D);\n+    pmull2(v28, T1Q, v1, v18, T2D);\n+    eor3(v3, T16B, v3, v27, v28);\n+\n+    \/\/ Use v19 for constants because v18 can be still in use.\n+    ldrq(v19, Address(table, 0x40));\n+    pmull (v29, T1Q, v2, v19, T1D);\n+    pmull2(v30, T1Q, v2, v19, T2D);\n+    eor3(v0, T16B, v3, v29, v30);\n@@ -4368,2 +4377,2 @@\n-    mov(tmp0, v1, D, 0);\n-    mov(tmp1, v1, D, 1);\n+    mov(tmp0, v0, D, 0);\n+    mov(tmp1, v0, D, 1);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":91,"deletions":82,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test TestFpRegsABI\n+ * @bug 8324874\n+ * @summary ABI for the Arm 64-bit Architecture requires to preserve registers v8-v15 by a callee across subroutine calls\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch -XX:CompileCommand=inline,*::calcValue compiler.intrinsics.zip.TestFpRegsABI\n+ * @run main\/othervm -XX:-TieredCompilation -Xbatch -XX:CompileCommand=dontinline,*::calcValue compiler.intrinsics.zip.TestFpRegsABI\n+ * @run main\/othervm -XX:+TieredCompilation -XX:TieredStopAtLevel=1 -Xbatch -XX:CompileCommand=inline,*::calcValue compiler.intrinsics.zip.TestFpRegsABI\n+ * @run main\/othervm -XX:+TieredCompilation -XX:TieredStopAtLevel=1 -Xbatch -XX:CompileCommand=dontinline,*::calcValue compiler.intrinsics.zip.TestFpRegsABI\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=inline,*::calcValue compiler.intrinsics.zip.TestFpRegsABI\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=dontinline,*::calcValue compiler.intrinsics.zip.TestFpRegsABI\n+ * @run main\/othervm -Xint compiler.intrinsics.zip.TestFpRegsABI\n+ *\/\n+\n+package compiler.intrinsics.zip;\n+\n+import java.util.zip.Checksum;\n+import java.util.zip.CRC32;\n+import java.util.zip.CRC32C;\n+\n+public class TestFpRegsABI {\n+    private static byte[] buf;\n+\n+    static {\n+        buf = new byte[1024];\n+        for (int i = 0; i < buf.length; ++i) {\n+          buf[i] = (byte)i;\n+        }\n+    }\n+\n+    private static class RegressionTest {\n+        Checksum checksum;\n+\n+        RegressionTest(Checksum checksum) {\n+            this.checksum = checksum;\n+        }\n+\n+        public void run(byte[] buf, long expectedValue) {\n+            for (int i = 0; i < 20_000; ++i) {\n+                runIteration(buf, expectedValue);\n+            }\n+        }\n+\n+        \/\/ If checksum intrinsic does not save fp registers as ABI requires,\n+        \/\/ the second call of calcValue might produce a wrong result.\n+        private void runIteration(byte[] buf, long expectedValue) {\n+            int v1 = calcValue(buf);\n+            checksum.reset();\n+            checksum.update(buf, 0, buf.length);\n+            long checksumValue = checksum.getValue();\n+            if (checksumValue != expectedValue) {\n+                System.err.printf(\"ERROR: checksum = 0x%016x, expected = 0x%016x\\n\",\n+                                  checksumValue, expectedValue);\n+                throw new RuntimeException(\"Checksum Error\");\n+            }\n+            int v2 = calcValue(buf);\n+            if (v1 != v2) {\n+                throw new RuntimeException(\"Expect v2(\" + v2 + \") to equal v1(\" + v1 + \")\");\n+            }\n+        }\n+\n+        private int calcValue(byte[] buf) {\n+            return (int)(2.5 * buf.length);\n+        }\n+    }\n+\n+    private static class TestIntrinsic {\n+        Checksum checksum;\n+\n+        TestIntrinsic(Checksum checksum) {\n+            this.checksum = checksum;\n+        }\n+\n+        public void run(byte[] buf, long expectedValue) {\n+            for (int i = 0; i < 20_000; ++i) {\n+                runIteration(buf, expectedValue);\n+            }\n+        }\n+\n+        \/\/ If checksum intrinsic does not save fp registers as ABI requires,\n+        \/\/ the second call of calcValue might produce a wrong result.\n+        private void runIteration(byte[] buf, long expectedValue) {\n+            int v1 = calcValue(buf);\n+            checksum.reset();\n+            checksum.update(buf, 0, buf.length);\n+            long checksumValue = checksum.getValue();\n+            if (checksumValue != expectedValue) {\n+                System.err.printf(\"ERROR: checksum = 0x%016x, expected = 0x%016x\\n\",\n+                                  checksumValue, expectedValue);\n+                throw new RuntimeException(\"Checksum Error\");\n+            }\n+            int v2 = calcValue(buf);\n+            if (v1 != v2) {\n+                throw new RuntimeException(\"Expect v2(\" + v2 + \") to equal v1(\" + v1 + \")\");\n+            }\n+        }\n+\n+        \/\/ ABI can require some fp registers to be saved by a callee, e.g. v8-15 in ARM64 ABI.\n+        \/\/ We create fp register pressure to get as many fp registers used as possible.\n+        private int calcValue(byte[] buf) {\n+            double v = 0.0;\n+            for (int i = 24; i <= buf.length; i += 24) {\n+                v += buf[i - 1] * ((double)i - 1.0) + (double)i - 1.0;\n+                v += buf[i - 2] * ((double)i - 2.0) + (double)i - 2.0;\n+                v += buf[i - 3] * ((double)i - 3.0) + (double)i - 3.0;\n+                v += buf[i - 4] * ((double)i - 4.0) + (double)i - 4.0;\n+                v += buf[i - 5] * ((double)i - 5.0) + (double)i - 5.0;\n+                v += buf[i - 6] * ((double)i - 6.0) + (double)i - 6.0;\n+                v += buf[i - 7] * ((double)i - 7.0) + (double)i - 7.0;\n+                v += buf[i - 8] * ((double)i - 8.0) + (double)i - 8.0;\n+                v += buf[i - 9] * ((double)i - 9.0) + (double)i - 9.0;\n+                v += buf[i - 10] * ((double)i - 10.0) + (double)i - 10.0;\n+                v += buf[i - 11] * ((double)i - 11.0) + (double)i - 11.0;\n+                v += buf[i - 12] * ((double)i - 12.0) + (double)i - 12.0;\n+                v += buf[i - 13] * ((double)i - 13.0) + (double)i - 13.0;\n+                v += buf[i - 14] * ((double)i - 14.0) + (double)i - 14.0;\n+                v += buf[i - 15] * ((double)i - 15.0) + (double)i - 15.0;\n+                v += buf[i - 16] * ((double)i - 16.0) + (double)i - 16.0;\n+                v += buf[i - 17] * ((double)i - 17.0) + (double)i - 17.0;\n+                v += buf[i - 18] * ((double)i - 18.0) + (double)i - 18.0;\n+                v += buf[i - 19] * ((double)i - 19.0) + (double)i - 19.0;\n+                v += buf[i - 20] * ((double)i - 20.0) + (double)i - 20.0;\n+                v += buf[i - 21] * ((double)i - 21.0) + (double)i - 21.0;\n+                v += buf[i - 22] * ((double)i - 22.0) + (double)i - 22.0;\n+                v += buf[i - 23] * ((double)i - 23.0) + (double)i - 23.0;\n+                v += buf[i - 24] * ((double)i - 24.0) + (double)i - 24.0;\n+            }\n+            return (int)v;\n+        }\n+    }\n+\n+    public static void main(final String[] argv) {\n+        new TestIntrinsic(new CRC32()).run(buf, 0x00000000b70b4c26L);\n+        new TestIntrinsic(new CRC32C()).run(buf, 0x000000002cdf6e8fL);\n+        new RegressionTest(new CRC32()).run(buf, 0x00000000b70b4c26L);\n+        new RegressionTest(new CRC32C()).run(buf, 0x000000002cdf6e8fL);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/zip\/TestFpRegsABI.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"}]}