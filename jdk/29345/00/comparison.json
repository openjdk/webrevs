{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-#include \"runtime\/atomicAccess.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -110,1 +110,1 @@\n-    uint _cur_idx;\n+    Atomic<uint> _cur_idx;\n@@ -113,1 +113,1 @@\n-    bool* _contains;\n+    Atomic<bool>* _contains;\n@@ -120,1 +120,1 @@\n-      _contains(NEW_C_HEAP_ARRAY(bool, max_reserved_regions, mtGC)) {\n+      _contains(NEW_C_HEAP_ARRAY(Atomic<bool>, max_reserved_regions, mtGC)) {\n@@ -127,1 +127,1 @@\n-      FREE_C_HEAP_ARRAY(bool, _contains);\n+      FREE_C_HEAP_ARRAY(Atomic<bool>, _contains);\n@@ -131,2 +131,4 @@\n-      _cur_idx = 0;\n-      ::memset(_contains, false, _max_reserved_regions * sizeof(bool));\n+      _cur_idx.store_relaxed(0);\n+      for (uint i = 0; i < _max_reserved_regions; i++) {\n+        _contains[i].store_relaxed(false);\n+      }\n@@ -135,1 +137,1 @@\n-    uint size() const { return _cur_idx; }\n+    uint size() const { return _cur_idx.load_relaxed(); }\n@@ -138,1 +140,1 @@\n-      assert(idx < _cur_idx, \"Index %u beyond valid regions\", idx);\n+      assert(idx < size(), \"Index %u beyond valid regions\", idx);\n@@ -143,1 +145,1 @@\n-      if (_contains[region]) {\n+      if (_contains[region].load_relaxed()) {\n@@ -147,1 +149,1 @@\n-      bool marked_as_dirty = AtomicAccess::cmpxchg(&_contains[region], false, true) == false;\n+      bool marked_as_dirty = _contains[region].compare_set(false, true);\n@@ -149,1 +151,1 @@\n-        uint allocated = AtomicAccess::fetch_then_add(&_cur_idx, 1u);\n+        uint allocated = _cur_idx.fetch_then_add(1u);\n@@ -158,3 +160,5 @@\n-        if (!_contains[region]) {\n-          _buffer[_cur_idx++] = region;\n-          _contains[region] = true;\n+        if (!_contains[region].load_relaxed()) {\n+          uint cur = _cur_idx.load_relaxed();\n+          _buffer[cur] = region;\n+          _cur_idx.store_relaxed(cur + 1);\n+          _contains[region].store_relaxed(true);\n@@ -176,1 +180,1 @@\n-    uint volatile _cur_dirty_regions;\n+    Atomic<uint> _cur_dirty_regions;\n@@ -213,2 +217,3 @@\n-      while (_cur_dirty_regions < _regions->size()) {\n-        uint next = AtomicAccess::fetch_then_add(&_cur_dirty_regions, num_regions_per_worker);\n+      uint cur = _cur_dirty_regions.load_relaxed();\n+      while (cur < _regions->size()) {\n+        uint next = _cur_dirty_regions.fetch_then_add(num_regions_per_worker);\n@@ -229,0 +234,1 @@\n+        cur = next;\n@@ -1118,1 +1124,1 @@\n-  volatile bool _fast_reclaim_handled;\n+  Atomic<bool> _fast_reclaim_handled;\n@@ -1146,2 +1152,2 @@\n-            !_fast_reclaim_handled &&\n-            !AtomicAccess::cmpxchg(&_fast_reclaim_handled, false, true)) {\n+            !_fast_reclaim_handled.load_relaxed() &&\n+            _fast_reclaim_handled.compare_set(false, true)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"}]}