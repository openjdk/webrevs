{"files":[{"patch":"@@ -56,0 +56,2 @@\n+import jdk.internal.access.JavaUtilFormatterAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -4481,1 +4483,1 @@\n-        return new Formatter().format(format, args).toString();\n+        return StringFormat.JUFA.format(format, args);\n@@ -4522,1 +4524,1 @@\n-        return new Formatter(l).format(format, args).toString();\n+        return StringFormat.JUFA.format(l, format, args);\n@@ -4543,1 +4545,5 @@\n-        return new Formatter().format(this, args).toString();\n+        return StringFormat.JUFA.format(this, args);\n+    }\n+\n+    private static class StringFormat {\n+        static final JavaUtilFormatterAccess JUFA = SharedSecrets.getJavaUtilFormatterAccess();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -64,0 +64,2 @@\n+import jdk.internal.access.JavaUtilFormatterAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -66,0 +68,2 @@\n+import jdk.internal.util.DecimalDigits;\n+import jdk.internal.vm.annotation.Stable;\n@@ -2021,0 +2025,12 @@\n+    static {\n+        SharedSecrets.setJavaUtilFormatterAccess(new JavaUtilFormatterAccess() {\n+            public String format(Locale locale, String format, Object... args) {\n+                return formatImpl(locale, format, args);\n+            }\n+\n+            public String format(String format, Object... args) {\n+                return formatImpl(Locale.getDefault(Locale.Category.FORMAT), format, args);\n+            }\n+        });\n+    }\n+\n@@ -2061,0 +2077,5 @@\n+    \/\/ index of last argument referenced\n+    private int last;\n+    \/\/ last ordinary index\n+    private int lasto;\n+\n@@ -2776,1 +2797,1 @@\n-    public Formatter format(Locale l, String format, Object ... args) {\n+    public Formatter format(Locale l, String format, Object... args) {\n@@ -2778,34 +2799,12 @@\n-\n-        \/\/ index of last argument referenced\n-        int last = -1;\n-        \/\/ last ordinary index\n-        int lasto = -1;\n-\n-        List<FormatString> fsa = parse(format);\n-        for (FormatString fs : fsa) {\n-            int index = fs.index();\n-            try {\n-                switch (index) {\n-                    case -2 ->  \/\/ fixed string, \"%n\", or \"%%\"\n-                        fs.print(this, null, l);\n-                    case -1 -> {  \/\/ relative index\n-                        if (last < 0 || (args != null && last > args.length - 1))\n-                            throw new MissingFormatArgumentException(fs.toString());\n-                        fs.print(this, (args == null ? null : args[last]), l);\n-                    }\n-                    case 0 -> {  \/\/ ordinary index\n-                        lasto++;\n-                        last = lasto;\n-                        if (args != null && lasto > args.length - 1)\n-                            throw new MissingFormatArgumentException(fs.toString());\n-                        fs.print(this, (args == null ? null : args[lasto]), l);\n-                    }\n-                    default -> { \/\/ explicit index\n-                        last = index - 1;\n-                        if (args != null && last > args.length - 1)\n-                            throw new MissingFormatArgumentException(fs.toString());\n-                        fs.print(this, (args == null ? null : args[last]), l);\n-                    }\n-                }\n-            } catch (IOException x) {\n-                lastException = x;\n+        \/\/ format passed by the caller may be a constant, and extracting this allows the optimizer to do more work.\n+        int max = format.length();\n+        int i = format.indexOf('%');\n+        if (i != 0) {\n+            append(format, 0, i < 0 ? max : i);\n+        }\n+        if (i >= 0) {\n+            last = -1;\n+            lasto = -1;\n+            i = formatSpecifier(l, format, i + 1, max, args);\n+            if (i != max) {\n+                format0(l, format, i, max, args);\n@@ -2818,1 +2817,1 @@\n-     * Finds format specifiers in the format string.\n+     * String.format implementation\n@@ -2820,12 +2819,17 @@\n-    static List<FormatString> parse(String s) {\n-        FormatSpecifierParser parser = null;\n-        ArrayList<FormatString> al = new ArrayList<>();\n-        int i = 0;\n-        int max = s.length();\n-        while (i < max) {\n-            int n = s.indexOf('%', i);\n-            if (n < 0) {\n-                \/\/ No more format specifiers, but since\n-                \/\/ i < max there's some trailing text\n-                al.add(new FixedString(s, i, max));\n-                break;\n+    private static String formatImpl(Locale locale, String format, Object... args) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        int max = format.length();\n+        int i = format.indexOf('%');\n+        if (i != 0) {\n+            sb.append(format, 0, i < 0 ? max : i);\n+        }\n+\n+        if (i >= 0) {\n+            Formatter formatter = new Formatter(locale, sb);\n+            formatter.last = -1;\n+            formatter.lasto = -1;\n+\n+            i = formatter.formatSpecifier(locale, format, i + 1, max, args);\n+            if (i != max) {\n+                formatter.format0(locale, format, i, max, args);\n@@ -2833,3 +2837,13 @@\n-            if (i != n) {\n-                \/\/ Previous characters were fixed text\n-                al.add(new FixedString(s, i, n));\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private void format0(Locale l, String format, int i, int max, Object[] args) {\n+        while (i < max) {\n+            int n = format.indexOf('%', i);\n+            if (n < 0 || i != n) {\n+                append(format, i, n < 0 ? max : n);\n+                if (n < 0) {\n+                    break;\n+                }\n@@ -2837,4 +2851,17 @@\n-            i = n + 1;\n-            if (i >= max) {\n-                \/\/ Trailing %\n-                throw new UnknownFormatConversionException(\"%\");\n+            i = formatSpecifier(l, format, n + 1, max, args);\n+        }\n+    }\n+\n+    private int formatSpecifier(Locale l, String s, int i, int max, Object[] args) {\n+        if (i >= max) {\n+            \/\/ Trailing %\n+            throw unknownFormatConversion('%');\n+        }\n+\n+        char c = s.charAt(i);\n+        FormatString fs = Conversion.specifier(c);\n+        if (fs != null) {\n+            i++;\n+        } else {\n+            if (c >= '1' && c <= '9' && i + 1 != max) {\n+                fs = Conversion.specifier(s.charAt(i + 1), c - '0');\n@@ -2842,4 +2869,2 @@\n-            char c = s.charAt(i);\n-            if (Conversion.isValid(c)) {\n-                al.add(new FormatSpecifier(c));\n-                i++;\n+            if (fs != null) {\n+                i += 2;\n@@ -2849,5 +2874,1 @@\n-                if (parser == null) {\n-                    parser = new FormatSpecifierParser(al, c, i, s, max);\n-                } else {\n-                    parser.reset(c, i);\n-                }\n+                FormatSpecifierParser parser = new FormatSpecifierParser(c, i, s, max);\n@@ -2857,0 +2878,1 @@\n+                    fs = parser.formatSpecifier;\n@@ -2858,1 +2880,1 @@\n-                    throw new UnknownFormatConversionException(String.valueOf(c));\n+                    throw unknownFormatConversion(c);\n@@ -2862,1 +2884,41 @@\n-        return al;\n+\n+        Object arg = null;\n+        int index = fs.index();\n+        if (index != -2) { \/\/ -2 : fixed string, \"%n\", or \"%%\"\n+            boolean miss = false;\n+            if (index == -1) { \/\/ relative index\n+                miss = last < 0;\n+            } else {\n+                last = index == 0 ? ++lasto : index - 1;\n+            }\n+            if (miss || (args != null && last > args.length - 1))\n+                throw fs.missingFormatArgument();\n+            arg = args == null ? null : args[last];\n+        }\n+\n+        try {\n+            fs.print(this, arg, l);\n+        } catch (IOException x) {\n+            lastException = x;\n+        }\n+\n+        return i;\n+    }\n+\n+    private static UnknownFormatConversionException unknownFormatConversion(char conv) {\n+        return new UnknownFormatConversionException(String.valueOf(conv));\n+    }\n+\n+    private static void failConversion(char c, Object arg) {\n+        throw new IllegalFormatConversionException(c, arg.getClass());\n+    }\n+\n+    private void append(String str, int start, int end) {\n+        if (start == end) {\n+            return;\n+        }\n+        try {\n+            a.append(str, start, end);\n+        } catch (IOException x) {\n+            lastException = x;\n+        }\n@@ -2866,1 +2928,1 @@\n-        final ArrayList<FormatString> al;\n+        FormatSpecifier formatSpecifier;\n@@ -2869,2 +2931,2 @@\n-        char first;\n-        int start;\n+        final char first;\n+        final int start;\n@@ -2877,3 +2939,1 @@\n-        FormatSpecifierParser(ArrayList<FormatString> al, char first, int start, String s, int max) {\n-            this.al = al;\n-\n+        FormatSpecifierParser(char first, int start, String s, int max) {\n@@ -2889,11 +2949,0 @@\n-        void reset(char first, int start) {\n-            this.first = first;\n-            this.c = first;\n-            this.start = start;\n-            this.off = start;\n-\n-            argSize = 0;\n-            flagSize = 0;\n-            widthSize = 0;\n-        }\n-\n@@ -2901,1 +2950,1 @@\n-         * If a valid format specifier is found, construct a FormatString and add it to {@link #al}.\n+         * If a valid format specifier is found, construct a FormatString and set it to {@link #formatSpecifier}.\n@@ -2954,5 +3003,2 @@\n-                if (al != null) {\n-                    FormatSpecifier formatSpecifier\n-                            = new FormatSpecifier(s, start, argSize, flagSize, widthSize, precisionSize, t, conversion);\n-                    al.add(formatSpecifier);\n-                }\n+                formatSpecifier\n+                        = new FormatSpecifier(s, start, argSize, flagSize, widthSize, precisionSize, t, conversion);\n@@ -3022,10 +3068,2 @@\n-    }\n-\n-    private static class FixedString implements FormatString {\n-        private final String s;\n-        private final int start;\n-        private final int end;\n-        FixedString(String s, int start, int end) {\n-            this.s = s;\n-            this.start = start;\n-            this.end = end;\n+        default MissingFormatArgumentException missingFormatArgument() {\n+            return new MissingFormatArgumentException(toString());\n@@ -3033,4 +3071,0 @@\n-        public int index() { return -2; }\n-        public void print(Formatter fmt, Object arg, Locale l)\n-            throws IOException { fmt.a.append(s, start, end); }\n-        public String toString() { return s.substring(start, end); }\n@@ -3054,1 +3088,254 @@\n-    static class FormatSpecifier implements FormatString {\n+    private static record FormatText1(char conv) implements FormatString {\n+        public void print(Formatter fmt, Object arg, Locale l) throws IOException {\n+            if (conv == '%') {\n+                fmt.a.append('%');\n+            } else {\n+                fmt.a.append(System.lineSeparator());\n+            }\n+        }\n+\n+        public int index() { return -2; }\n+        public String toString() { return Character.toString(conv); }\n+    }\n+\n+    private static record FormatString1(boolean ucase) implements FormatString {\n+        public void print(Formatter fmt, Object arg, Locale l) throws IOException {\n+            if (arg instanceof Formattable fmtArg) {\n+                if (fmt.locale() != l)\n+                    fmt = new Formatter(fmt.out(), l);\n+                fmtArg.formatTo(fmt, Flags.NONE, -1, -1);\n+            } else {\n+                Appendable a = fmt.a;\n+                String str = String.valueOf(arg);\n+                if (ucase) {\n+                    str = str.toUpperCase(l);\n+                }\n+                a.append(str);\n+            }\n+        }\n+\n+        public int index() { return 0; }\n+        public String toString() { return ucase ? \"%S\" : \"%s\"; }\n+    }\n+\n+    private static record FormatStringWidth(boolean ucase, int width) implements FormatString {\n+        public void print(Formatter fmt, Object arg, Locale l) throws IOException {\n+            if (arg instanceof Formattable fmtArg) {\n+                if (fmt.locale() != l)\n+                    fmt = new Formatter(fmt.out(), l);\n+                fmtArg.formatTo(fmt, ucase ? Flags.UPPERCASE : Flags.NONE, width, -1);\n+            } else {\n+                Appendable a = fmt.a;\n+                String str = String.valueOf(arg);\n+                if (ucase) {\n+                    str = str.toUpperCase(l);\n+                }\n+                padding(a, width - str.length());\n+                a.append(str);\n+            }\n+        }\n+\n+        public int index() { return 0; }\n+        public String toString() { return \"%\" + width + (ucase ? \"S\" : \"s\"); }\n+    }\n+\n+    private static void padding(Appendable a, int sp) throws IOException {\n+        if (sp <= 0) {\n+            return;\n+        }\n+\n+        if (a instanceof StringBuilder sb) {\n+            sb.repeat(' ', sp);\n+        } else {\n+            a.append(String.valueOf(' ').repeat(sp));\n+        }\n+    }\n+\n+    private static final record FormatDecimal1() implements FormatString {\n+        public int index() { return 0; }\n+        public String toString() { return \"%d\"; }\n+\n+        public void print(Formatter fmt, Object arg, Locale l) throws IOException {\n+            Appendable a = fmt.a;\n+            if (arg == null) {\n+                a.append(\"null\");\n+                return;\n+            }\n+\n+            char zero = getZero(l);\n+            if (zero == '0'\n+                    && (arg instanceof Integer\n+                    || arg instanceof Long\n+                    || arg instanceof Short\n+                    || arg instanceof Byte)) {\n+                long value = ((Number) arg).longValue();\n+                if (a instanceof StringBuilder sb) {\n+                    sb.append(value);\n+                } else {\n+                    a.append(Long.toString(value));\n+                }\n+                return;\n+            }\n+\n+            print(a, arg, l, zero);\n+        }\n+\n+        public void print(Appendable a, Object arg, Locale l, char zero) throws IOException {\n+            boolean negative = false;\n+            String str;\n+            if (arg instanceof Integer\n+                    || arg instanceof Long\n+                    || arg instanceof Short\n+                    || arg instanceof Byte) {\n+                long value = ((Number) arg).longValue();\n+                if (value < 0) {\n+                    negative = true;\n+                    value = -value;\n+                }\n+                str = Long.toString(value);\n+            } else if (arg instanceof BigInteger) {\n+                if (zero == '0') {\n+                    str = arg.toString();\n+                    a.append(str);\n+                    return;\n+                }\n+                BigInteger bigInt = (BigInteger) arg;\n+                if (bigInt.signum() < 0) {\n+                    negative = true;\n+                    bigInt = bigInt.negate();\n+                }\n+                str = bigInt.toString();\n+            } else {\n+                failConversion('d', arg);\n+                return;\n+            }\n+\n+            if (negative) {\n+                a.append(getMinusSign(l));\n+            }\n+\n+            printDigits(a, str, zero);\n+        }\n+    }\n+\n+    private static final record FormatDecimalWidth(int width) implements FormatString {\n+        public int index() { return 0; }\n+        public String toString() { return \"%\" + width + \"d\"; }\n+\n+        public void print(Formatter fmt, Object arg, Locale l) throws IOException {\n+            Appendable a = fmt.a;\n+            if (arg == null) {\n+                padding(a, width - 4);\n+                a.append(\"null\");\n+                return;\n+            }\n+\n+            char zero = getZero(l);\n+            if (zero == '0'\n+                    && (arg instanceof Integer\n+                    || arg instanceof Long\n+                    || arg instanceof Short\n+                    || arg instanceof Byte)) {\n+                long value = ((Number) arg).longValue();\n+                padding(a, width - DecimalDigits.stringSize(value));\n+                if (a instanceof StringBuilder sb) {\n+                    sb.append(value);\n+                } else {\n+                    a.append(Long.toString(value));\n+                }\n+                return;\n+            }\n+\n+            print(a, arg, l, zero);\n+        }\n+\n+        void print(Appendable a, Object arg, Locale l, char zero) throws IOException {\n+            boolean negative = false;\n+            String str;\n+            if (arg instanceof Integer\n+                    || arg instanceof Long\n+                    || arg instanceof Short\n+                    || arg instanceof Byte) {\n+                long value = ((Number) arg).longValue();\n+                if (value < 0) {\n+                    negative = true;\n+                    value = -value;\n+                }\n+                str = Long.toString(value);\n+            } else if (arg instanceof BigInteger) {\n+                if (zero == '0') {\n+                    str = arg.toString();\n+                    padding(a, width - str.length());\n+                    a.append(str);\n+                    return;\n+                }\n+                BigInteger bigInt = (BigInteger) arg;\n+                if (bigInt.signum() < 0) {\n+                    negative = true;\n+                    bigInt = bigInt.negate();\n+                }\n+                str = bigInt.toString();\n+            } else {\n+                failConversion('d', arg);\n+                return;\n+            }\n+\n+            padding(a, width - str.length() + (negative ? 1 : 0));\n+            if (negative) {\n+                a.append(getMinusSign(l));\n+            }\n+\n+            printDigits(a, str, zero);\n+        }\n+    }\n+\n+    private static void printDigits(Appendable a, String str, char zero) throws IOException {\n+        for (int i = 0, len = str.length(); i < len; i++) {\n+            char c = str.charAt(i);\n+            a.append((char) ((c - '0') + zero));\n+        }\n+    }\n+\n+    private static record FormatHex1(boolean ucase) implements FormatString {\n+        public void print(Formatter fmt, Object arg, Locale l) throws IOException {\n+            Appendable a = fmt.a;\n+            if (arg == null) {\n+                a.append(ucase ? \"NULL\" : \"null\");\n+                return;\n+            }\n+\n+            String str;\n+            if (arg instanceof Byte\n+                    || arg instanceof Short\n+                    || arg instanceof Integer\n+                    || arg instanceof Long\n+            ) {\n+                long v = ((Number) arg).longValue();\n+                if (v < 0) {\n+                    if (arg instanceof Byte) {\n+                        v += (1L << 8);\n+                    } else if (arg instanceof Short) {\n+                        v += (1L << 16);\n+                    } else if (arg instanceof Integer) {\n+                        v += (1L << 32);\n+                    }\n+                }\n+                str = Long.toHexString(v);\n+            } else if (arg instanceof BigInteger) {\n+                str = ((BigInteger) arg).toString(16);\n+            } else {\n+                failConversion('x', arg);\n+                return;\n+            }\n+\n+            if (ucase) {\n+                str = str.toUpperCase(l);\n+            }\n+            a.append(str);\n+        }\n+\n+        public int index() { return 0; }\n+        public String toString() { return ucase ? \"%X\" : \"%x\"; }\n+    }\n+\n+    private static final class FormatSpecifier implements FormatString {\n@@ -3117,1 +3404,1 @@\n-                    throw new UnknownFormatConversionException(String.valueOf(c));\n+                    throw unknownFormatConversion(c);\n@@ -4709,4 +4996,0 @@\n-        private void failConversion(char c, Object arg) {\n-            throw new IllegalFormatConversionException(c, arg.getClass());\n-        }\n-\n@@ -4976,0 +5259,36 @@\n+        static final @Stable FormatString[] SPECIFIERS = new FormatString[128];\n+        static {\n+            for(char c : new char[] {\n+                    BOOLEAN, BOOLEAN_UPPER,\n+                    HASHCODE, HASHCODE_UPPER,\n+                    CHARACTER, CHARACTER_UPPER,\n+                    OCTAL_INTEGER,\n+                    SCIENTIFIC, SCIENTIFIC_UPPER,\n+                    GENERAL,\n+                    GENERAL_UPPER,\n+                    DECIMAL_FLOAT,\n+                    HEXADECIMAL_FLOAT, HEXADECIMAL_FLOAT_UPPER\n+            }) {\n+                SPECIFIERS[c] = new FormatSpecifier(c);\n+            }\n+            SPECIFIERS[DECIMAL_INTEGER          ] = new FormatDecimal1();\n+            SPECIFIERS[HEXADECIMAL_INTEGER      ] = new FormatHex1(false);\n+            SPECIFIERS[HEXADECIMAL_INTEGER_UPPER] = new FormatHex1(true);\n+            SPECIFIERS[LINE_SEPARATOR           ] = new FormatText1(LINE_SEPARATOR);\n+            SPECIFIERS[PERCENT_SIGN             ] = new FormatText1(PERCENT_SIGN);\n+            SPECIFIERS[STRING                   ] = new FormatString1(false);\n+            SPECIFIERS[STRING_UPPER             ] = new FormatString1(true);\n+        }\n+\n+        static FormatString specifier(char c) {\n+            return SPECIFIERS[c & 0x7f];\n+        }\n+\n+        static FormatString specifier(char c, int width) {\n+            return switch (c) {\n+                case DECIMAL_INTEGER      -> new FormatDecimalWidth(width);\n+                case STRING, STRING_UPPER -> new FormatStringWidth(c == STRING_UPPER, width);\n+                default                   -> null;\n+            };\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":428,"deletions":109,"binary":false,"changes":537,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import java.util.Locale;\n+\n+public interface JavaUtilFormatterAccess {\n+    String format(Locale l, String format, Object... args);\n+    String format(String format, Object... args);\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilFormatterAccess.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -50,7 +50,7 @@\n-    calling implementation-private methods in another package without\n-    using reflection. A package-private class implements a public\n-    interface and provides the ability to call package-private methods\n-    within that package; the object implementing that interface is\n-    provided through a third package to which access is restricted.\n-    This framework avoids the primary disadvantage of using reflection\n-    for this purpose, namely the loss of compile-time checking. *\/\n+ calling implementation-private methods in another package without\n+ using reflection. A package-private class implements a public\n+ interface and provides the ability to call package-private methods\n+ within that package; the object implementing that interface is\n+ provided through a third package to which access is restricted.\n+ This framework avoids the primary disadvantage of using reflection\n+ for this purpose, namely the loss of compile-time checking. *\/\n@@ -87,0 +87,1 @@\n+    private static JavaUtilFormatterAccess javaUtilFormatterAccess;\n@@ -376,0 +377,13 @@\n+    public static JavaUtilFormatterAccess getJavaUtilFormatterAccess() {\n+        var access = javaUtilFormatterAccess;\n+        if (access == null) {\n+            ensureClassInitialized(java.util.Formatter.class);\n+            access = javaUtilFormatterAccess;\n+        }\n+        return access;\n+    }\n+\n+    public static void setJavaUtilFormatterAccess(JavaUtilFormatterAccess access) {\n+        javaUtilFormatterAccess = access;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -60,1 +61,1 @@\n-        return \"%s\".formatted(s);\n+        return \"0123456789 %s\".formatted(s);\n@@ -64,2 +65,2 @@\n-    public String stringIntFormat() {\n-        return \"%s %d\".formatted(s, i);\n+    public String stringFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %s\".formatted(s);\n@@ -70,1 +71,6 @@\n-        return \"%3s\".formatted(s);\n+        return \"0123456789 %3s\".formatted(s);\n+    }\n+\n+    @Benchmark\n+    public String widthStringFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %3s\".formatted(s);\n@@ -75,1 +81,116 @@\n-        return \"%3s %d\".formatted(s, i);\n+        return \"0123456789 %3s %d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String widthStringIntFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %3s %d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String lineFormat() {\n+        return \"0123456789 %n\".formatted(i);\n+    }\n+\n+    @Benchmark\n+    public String lineFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %n\".formatted(i);\n+    }\n+\n+    @Benchmark\n+    public String intFormat() {\n+        return \"0123456789 %d\".formatted(i);\n+    }\n+\n+    @Benchmark\n+    public String intFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d\".formatted(i);\n+    }\n+\n+    @Benchmark\n+    public String intIntFormat() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d %d\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intIntFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d %d\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intHexFormat() {\n+        return \"0123456789 is %d %x\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intHexFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d : %x\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intHexUFormat() {\n+        return \"0123456789 is %d %X\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intHexUFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d : %X\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intOctalFormat() {\n+        return \"0123456789 is %d %o\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String intOctalFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %d : %o\".formatted(i, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntFormat() {\n+        return \"0123456789 %s : %d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %s : %d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntRFormat() {\n+        return \"0123456789 %s : %d 0123456789\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntRFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %s : %d \\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringWidthIntFormat() {\n+        return \"0123456789 %s : %3d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringWidthIntFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %s : %3d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntHexFormat() {\n+        return \"0123456789 %s : %x\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntHexUFormat() {\n+        return \"0123456789 %s : %x\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntOctalFormat() {\n+        return \"0123456789 %s : %o\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String stringIntOctalFormatUtf16() {\n+        return \"\\u3007\\u4e00\\u4e8c\\u4e09\\u56db\\u4e94\\u516d\\u4e03\\u516b\\u4e5d %s : %o\".formatted(s, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringFormat.java","additions":127,"deletions":6,"binary":false,"changes":133,"status":"modified"}]}