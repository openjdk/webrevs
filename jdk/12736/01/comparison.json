{"files":[{"patch":"@@ -107,0 +107,9 @@\n+    \/**\n+     * Return a double with its high-order bits of the first argument\n+     * and the low-order bits of the second argument..\n+     *\/\n+    private static double __HI_LO(int high, int low) {\n+        return Double.longBitsToDouble(((long)high << 32) |\n+                                       (low & 0xffff_ffffL));\n+    }\n+\n@@ -507,0 +516,443 @@\n+    \/**\n+     * Return correctly rounded sqrt.\n+     *           ------------------------------------------\n+     *           |  Use the hardware sqrt if you have one |\n+     *           ------------------------------------------\n+     * Method:\n+     *   Bit by bit method using integer arithmetic. (Slow, but portable)\n+     *   1. Normalization\n+     *      Scale x to y in [1,4) with even powers of 2:\n+     *      find an integer k such that  1 <= (y=x*2^(2k)) < 4, then\n+     *              sqrt(x) = 2^k * sqrt(y)\n+     *   2. Bit by bit computation\n+     *      Let q  = sqrt(y) truncated to i bit after binary point (q = 1),\n+     *           i                                                   0\n+     *                                     i+1         2\n+     *          s  = 2*q , and      y  =  2   * ( y - q  ).         (1)\n+     *           i      i            i                 i\n+     *\n+     *      To compute q    from q , one checks whether\n+     *                  i+1       i\n+     *\n+     *                            -(i+1) 2\n+     *                      (q + 2      ) <= y.                     (2)\n+     *                        i\n+     *                                                            -(i+1)\n+     *      If (2) is false, then q   = q ; otherwise q   = q  + 2      .\n+     *                             i+1   i             i+1   i\n+     *\n+     *      With some algebraic manipulation, it is not difficult to see\n+     *      that (2) is equivalent to\n+     *                             -(i+1)\n+     *                      s  +  2       <= y                      (3)\n+     *                       i                i\n+     *\n+     *      The advantage of (3) is that s  and y  can be computed by\n+     *                                    i      i\n+     *      the following recurrence formula:\n+     *          if (3) is false\n+     *\n+     *          s     =  s  ,       y    = y   ;                    (4)\n+     *           i+1      i          i+1    i\n+     *\n+     *          otherwise,\n+     *                         -i                     -(i+1)\n+     *          s     =  s  + 2  ,  y    = y  -  s  - 2             (5)\n+     *           i+1      i          i+1    i     i\n+     *\n+     *      One may easily use induction to prove (4) and (5).\n+     *      Note. Since the left hand side of (3) contain only i+2 bits,\n+     *            it does not necessary to do a full (53-bit) comparison\n+     *            in (3).\n+     *   3. Final rounding\n+     *      After generating the 53 bits result, we compute one more bit.\n+     *      Together with the remainder, we can decide whether the\n+     *      result is exact, bigger than 1\/2ulp, or less than 1\/2ulp\n+     *      (it will never equal to 1\/2ulp).\n+     *      The rounding mode can be detected by checking whether\n+     *      huge + tiny is equal to huge, and whether huge - tiny is\n+     *      equal to huge for some floating point number \"huge\" and \"tiny\".\n+     *\n+     * Special cases:\n+     *      sqrt(+-0) = +-0         ... exact\n+     *      sqrt(inf) = inf\n+     *      sqrt(-ve) = NaN         ... with invalid signal\n+     *      sqrt(NaN) = NaN         ... with invalid signal for signaling NaN\n+     *\n+     * Other methods : see the appended file at the end of the program below.\n+     *---------------\n+     *\/\n+    static class Sqrt {\n+        private Sqrt() {throw new UnsupportedOperationException();}\n+\n+        private static final double tiny = 1.0e-300;\n+\n+        static double compute(double x) {\n+            double z = 0.0;\n+            int sign = 0x8000_0000;\n+            \/*unsigned*\/ int r, t1, s1, ix1, q1;\n+            int ix0, s0, q, m, t, i;\n+\n+            ix0 = __HI(x);  \/\/ high word of x\n+            ix1 = __LO(x);  \/\/ low word of x\n+\n+            \/\/ take care of Inf and NaN\n+            if((ix0 & 0x7ff0_0000) == 0x7ff0_0000) {\n+                return x*x + x; \/\/ sqrt(NaN)=NaN, sqrt(+inf)=+inf, sqrt(-inf)=sNaN\n+            }\n+            \/\/ take care of zero\n+            if (ix0 <= 0) {\n+                if (((ix0 & (~sign)) | ix1) == 0)\n+                    return x; \/\/ sqrt(+-0) = +-0\n+                else if (ix0 < 0)\n+                    return (x-x)\/(x-x); \/\/ sqrt(-ve) = sNaN\n+            }\n+            \/\/ normalize x\n+            m = (ix0 >> 20);\n+            if (m == 0) { \/\/ subnormal x\n+                while (ix0 == 0) {\n+                    m -= 21;\n+                    ix0 |= (ix1 >>> 11); \/\/ unsigned shift\n+                    ix1 <<= 21;\n+                }\n+                for(i = 0; (ix0 & 0x0010_0000) == 0; i++) {\n+                    ix0 <<= 1;\n+                }\n+                m -= i-1;\n+                ix0 |= (ix1 >>> (32 - i)); \/\/ unsigned shift\n+                ix1 <<= i;\n+            }\n+            m -= 1023;      \/\/ unbias exponent *\/\n+            ix0 = (ix0 & 0x000f_ffff) | 0x0010_0000;\n+            if ((m & 1) != 0){        \/\/ odd m, double x to make it even\n+                ix0 += ix0 + ((ix1 & sign) >>> 31); \/\/ unsigned shift\n+                ix1 += ix1;\n+            }\n+            m >>= 1;        \/\/ m = [m\/2]\n+\n+            \/\/ generate sqrt(x) bit by bit\n+            ix0 += ix0 + ((ix1 & sign) >>> 31); \/\/ unsigned shift\n+            ix1 += ix1;\n+            q = q1 = s0 = s1 = 0;   \/\/ [q,q1] = sqrt(x)\n+            r = 0x0020_0000;        \/\/ r = moving bit from right to left\n+\n+            while(r != 0) {\n+                t = s0 + r;\n+                if(t <= ix0) {\n+                    s0   = t + r;\n+                    ix0 -= t;\n+                    q   += r;\n+                }\n+                ix0 += ix0 + ((ix1 & sign) >>> 31); \/\/ unsigned shift\n+                ix1 += ix1;\n+                r >>>= 1; \/\/ unsigned shift\n+            }\n+\n+            r = sign;\n+            while (r != 0) {\n+                t1 = s1 + r;\n+                t  = s0;\n+                if((t < ix0) ||\n+                   ((t == ix0) && (Integer.compareUnsigned(t1, ix1) <= 0 ))) { \/\/ t1 <= ix1\n+                    s1  = t1 + r;\n+                    if (((t1 & sign) == sign) && (s1 & sign) == 0) {\n+                        s0 += 1;\n+                    }\n+                    ix0 -= t;\n+                    if (Integer.compareUnsigned(ix1, t1) < 0) {  \/\/ ix1 < t1\n+                        ix0 -= 1;\n+                    }\n+                    ix1 -= t1;\n+                    q1  += r;\n+                }\n+                ix0 += ix0 + ((ix1 & sign) >>> 31);\n+                ix1 += ix1;\n+                r >>>= 1; \/\/ unsigned shift\n+            }\n+\n+            \/\/ use floating add to find out rounding direction\n+            if ((ix0 | ix1) != 0) {\n+                z = 1.0 - tiny; \/\/ trigger inexact flag\n+                if (z >= 1.0) {\n+                    z = 1.0 + tiny;\n+                    if (q1 == 0xffff_ffff) {\n+                        q1 = 0;\n+                        q += 1;\n+                    } else if (z > 1.0) {\n+                        if (q1 == 0xffff_fffe) {\n+                            q += 1;\n+                        }\n+                        q1 += 2;\n+                    } else {\n+                        q1 += (q1 & 1);\n+                    }\n+                }\n+            }\n+            ix0 = (q >> 1) + 0x3fe0_0000;\n+            ix1 =  q1 >>> 1; \/\/ unsigned shift\n+            if ((q & 1) == 1) {\n+                ix1 |= sign;\n+            }\n+            ix0 += (m << 20);\n+            return __HI_LO(ix0, ix1);\n+        }\n+    }\n+\n+    \/\/ The following comment is supplementary information from the FDLIBM sources.\n+\n+    \/*\n+     * Other methods  (use floating-point arithmetic)\n+     * -------------\n+     * (This is a copy of a drafted paper by Prof W. Kahan\n+     * and K.C. Ng, written in May, 1986)\n+     *\n+     *        Two algorithms are given here to implement sqrt(x)\n+     *        (IEEE double precision arithmetic) in software.\n+     *        Both supply sqrt(x) correctly rounded. The first algorithm (in\n+     *        Section A) uses newton iterations and involves four divisions.\n+     *        The second one uses reciproot iterations to avoid division, but\n+     *        requires more multiplications. Both algorithms need the ability\n+     *        to chop results of arithmetic operations instead of round them,\n+     *        and the INEXACT flag to indicate when an arithmetic operation\n+     *        is executed exactly with no roundoff error, all part of the\n+     *        standard (IEEE 754-1985). The ability to perform shift, add,\n+     *        subtract and logical AND operations upon 32-bit words is needed\n+     *        too, though not part of the standard.\n+     *\n+     * A.  sqrt(x) by Newton Iteration\n+     *\n+     *   (1)  Initial approximation\n+     *\n+     *        Let x0 and x1 be the leading and the trailing 32-bit words of\n+     *        a floating point number x (in IEEE double format) respectively\n+     *\n+     *            1    11                  52                           ...widths\n+     *           ------------------------------------------------------\n+     *        x: |s|    e     |             f                         |\n+     *           ------------------------------------------------------\n+     *              msb    lsb  msb                                 lsb ...order\n+     *\n+     *\n+     *             ------------------------        ------------------------\n+     *        x0:  |s|   e    |    f1     |    x1: |          f2           |\n+     *             ------------------------        ------------------------\n+     *\n+     *        By performing shifts and subtracts on x0 and x1 (both regarded\n+     *        as integers), we obtain an 8-bit approximation of sqrt(x) as\n+     *        follows.\n+     *\n+     *                k  := (x0>>1) + 0x1ff80000;\n+     *                y0 := k - T1[31&(k>>15)].       ... y ~ sqrt(x) to 8 bits\n+     *        Here k is a 32-bit integer and T1[] is an integer array containing\n+     *        correction terms. Now magically the floating value of y (y's\n+     *        leading 32-bit word is y0, the value of its trailing word is 0)\n+     *        approximates sqrt(x) to almost 8-bit.\n+     *\n+     *        Value of T1:\n+     *        static int T1[32]= {\n+     *        0,      1024,   3062,   5746,   9193,   13348,  18162,  23592,\n+     *        29598,  36145,  43202,  50740,  58733,  67158,  75992,  85215,\n+     *        83599,  71378,  60428,  50647,  41945,  34246,  27478,  21581,\n+     *        16499,  12183,  8588,   5674,   3403,   1742,   661,    130,};\n+     *\n+     *    (2) Iterative refinement\n+     *\n+     *        Apply Heron's rule three times to y, we have y approximates\n+     *        sqrt(x) to within 1 ulp (Unit in the Last Place):\n+     *\n+     *                y := (y+x\/y)\/2          ... almost 17 sig. bits\n+     *                y := (y+x\/y)\/2          ... almost 35 sig. bits\n+     *                y := y-(y-x\/y)\/2        ... within 1 ulp\n+     *\n+     *\n+     *        Remark 1.\n+     *            Another way to improve y to within 1 ulp is:\n+     *\n+     *                y := (y+x\/y)            ... almost 17 sig. bits to 2*sqrt(x)\n+     *                y := y - 0x00100006     ... almost 18 sig. bits to sqrt(x)\n+     *\n+     *                                2\n+     *                            (x-y )*y\n+     *                y := y + 2* ----------  ...within 1 ulp\n+     *                               2\n+     *                             3y  + x\n+     *\n+     *\n+     *        This formula has one division fewer than the one above; however,\n+     *        it requires more multiplications and additions. Also x must be\n+     *        scaled in advance to avoid spurious overflow in evaluating the\n+     *        expression 3y*y+x. Hence it is not recommended uless division\n+     *        is slow. If division is very slow, then one should use the\n+     *        reciproot algorithm given in section B.\n+     *\n+     *    (3) Final adjustment\n+     *\n+     *        By twiddling y's last bit it is possible to force y to be\n+     *        correctly rounded according to the prevailing rounding mode\n+     *        as follows. Let r and i be copies of the rounding mode and\n+     *        inexact flag before entering the square root program. Also we\n+     *        use the expression y+-ulp for the next representable floating\n+     *        numbers (up and down) of y. Note that y+-ulp = either fixed\n+     *        point y+-1, or multiply y by nextafter(1,+-inf) in chopped\n+     *        mode.\n+     *\n+     *                I := FALSE;     ... reset INEXACT flag I\n+     *                R := RZ;        ... set rounding mode to round-toward-zero\n+     *                z := x\/y;       ... chopped quotient, possibly inexact\n+     *                If(not I) then {        ... if the quotient is exact\n+     *                    if(z=y) {\n+     *                        I := i;  ... restore inexact flag\n+     *                        R := r;  ... restore rounded mode\n+     *                        return sqrt(x):=y.\n+     *                    } else {\n+     *                        z := z - ulp;   ... special rounding\n+     *                    }\n+     *                }\n+     *                i := TRUE;              ... sqrt(x) is inexact\n+     *                If (r=RN) then z=z+ulp  ... rounded-to-nearest\n+     *                If (r=RP) then {        ... round-toward-+inf\n+     *                    y = y+ulp; z=z+ulp;\n+     *                }\n+     *                y := y+z;               ... chopped sum\n+     *                y0:=y0-0x00100000;      ... y := y\/2 is correctly rounded.\n+     *                I := i;                 ... restore inexact flag\n+     *                R := r;                 ... restore rounded mode\n+     *                return sqrt(x):=y.\n+     *\n+     *    (4) Special cases\n+     *\n+     *        Square root of +inf, +-0, or NaN is itself;\n+     *        Square root of a negative number is NaN with invalid signal.\n+     *\n+     *\n+     * B.  sqrt(x) by Reciproot Iteration\n+     *\n+     *   (1)  Initial approximation\n+     *\n+     *        Let x0 and x1 be the leading and the trailing 32-bit words of\n+     *        a floating point number x (in IEEE double format) respectively\n+     *        (see section A). By performing shifs and subtracts on x0 and y0,\n+     *        we obtain a 7.8-bit approximation of 1\/sqrt(x) as follows.\n+     *\n+     *            k := 0x5fe80000 - (x0>>1);\n+     *            y0:= k - T2[63&(k>>14)].    ... y ~ 1\/sqrt(x) to 7.8 bits\n+     *\n+     *        Here k is a 32-bit integer and T2[] is an integer array\n+     *        containing correction terms. Now magically the floating\n+     *        value of y (y's leading 32-bit word is y0, the value of\n+     *        its trailing word y1 is set to zero) approximates 1\/sqrt(x)\n+     *        to almost 7.8-bit.\n+     *\n+     *        Value of T2:\n+     *        static int T2[64]= {\n+     *        0x1500, 0x2ef8, 0x4d67, 0x6b02, 0x87be, 0xa395, 0xbe7a, 0xd866,\n+     *        0xf14a, 0x1091b,0x11fcd,0x13552,0x14999,0x15c98,0x16e34,0x17e5f,\n+     *        0x18d03,0x19a01,0x1a545,0x1ae8a,0x1b5c4,0x1bb01,0x1bfde,0x1c28d,\n+     *        0x1c2de,0x1c0db,0x1ba73,0x1b11c,0x1a4b5,0x1953d,0x18266,0x16be0,\n+     *        0x1683e,0x179d8,0x18a4d,0x19992,0x1a789,0x1b445,0x1bf61,0x1c989,\n+     *        0x1d16d,0x1d77b,0x1dddf,0x1e2ad,0x1e5bf,0x1e6e8,0x1e654,0x1e3cd,\n+     *        0x1df2a,0x1d635,0x1cb16,0x1be2c,0x1ae4e,0x19bde,0x1868e,0x16e2e,\n+     *        0x1527f,0x1334a,0x11051,0xe951, 0xbe01, 0x8e0d, 0x5924, 0x1edd,};\n+     *\n+     *    (2) Iterative refinement\n+     *\n+     *        Apply Reciproot iteration three times to y and multiply the\n+     *        result by x to get an approximation z that matches sqrt(x)\n+     *        to about 1 ulp. To be exact, we will have\n+     *                -1ulp < sqrt(x)-z<1.0625ulp.\n+     *\n+     *        ... set rounding mode to Round-to-nearest\n+     *           y := y*(1.5-0.5*x*y*y)       ... almost 15 sig. bits to 1\/sqrt(x)\n+     *           y := y*((1.5-2^-30)+0.5*x*y*y)... about 29 sig. bits to 1\/sqrt(x)\n+     *        ... special arrangement for better accuracy\n+     *           z := x*y                     ... 29 bits to sqrt(x), with z*y<1\n+     *           z := z + 0.5*z*(1-z*y)       ... about 1 ulp to sqrt(x)\n+     *\n+     *        Remark 2. The constant 1.5-2^-30 is chosen to bias the error so that\n+     *        (a) the term z*y in the final iteration is always less than 1;\n+     *        (b) the error in the final result is biased upward so that\n+     *                -1 ulp < sqrt(x) - z < 1.0625 ulp\n+     *            instead of |sqrt(x)-z|<1.03125ulp.\n+     *\n+     *    (3) Final adjustment\n+     *\n+     *        By twiddling y's last bit it is possible to force y to be\n+     *        correctly rounded according to the prevailing rounding mode\n+     *        as follows. Let r and i be copies of the rounding mode and\n+     *        inexact flag before entering the square root program. Also we\n+     *        use the expression y+-ulp for the next representable floating\n+     *        numbers (up and down) of y. Note that y+-ulp = either fixed\n+     *        point y+-1, or multiply y by nextafter(1,+-inf) in chopped\n+     *        mode.\n+     *\n+     *        R := RZ;                ... set rounding mode to round-toward-zero\n+     *        switch(r) {\n+     *            case RN:            ... round-to-nearest\n+     *               if(x<= z*(z-ulp)...chopped) z = z - ulp; else\n+     *               if(x<= z*(z+ulp)...chopped) z = z; else z = z+ulp;\n+     *               break;\n+     *            case RZ:case RM:    ... round-to-zero or round-to--inf\n+     *               R:=RP;           ... reset rounding mod to round-to-+inf\n+     *               if(x<z*z ... rounded up) z = z - ulp; else\n+     *               if(x>=(z+ulp)*(z+ulp) ...rounded up) z = z+ulp;\n+     *               break;\n+     *            case RP:            ... round-to-+inf\n+     *               if(x>(z+ulp)*(z+ulp)...chopped) z = z+2*ulp; else\n+     *               if(x>z*z ...chopped) z = z+ulp;\n+     *               break;\n+     *        }\n+     *\n+     *        Remark 3. The above comparisons can be done in fixed point. For\n+     *        example, to compare x and w=z*z chopped, it suffices to compare\n+     *        x1 and w1 (the trailing parts of x and w), regarding them as\n+     *        two's complement integers.\n+     *\n+     *        ...Is z an exact square root?\n+     *        To determine whether z is an exact square root of x, let z1 be the\n+     *        trailing part of z, and also let x0 and x1 be the leading and\n+     *        trailing parts of x.\n+     *\n+     *        If ((z1&0x03ffffff)!=0) ... not exact if trailing 26 bits of z!=0\n+     *            I := 1;             ... Raise Inexact flag: z is not exact\n+     *        else {\n+     *            j := 1 - [(x0>>20)&1]       ... j = logb(x) mod 2\n+     *            k := z1 >> 26;              ... get z's 25-th and 26-th\n+     *                                            fraction bits\n+     *            I := i or (k&j) or ((k&(j+j+1))!=(x1&3));\n+     *        }\n+     *        R:= r           ... restore rounded mode\n+     *        return sqrt(x):=z.\n+     *\n+     *        If multiplication is cheaper then the foregoing red tape, the\n+     *        Inexact flag can be evaluated by\n+     *\n+     *            I := i;\n+     *            I := (z*z!=x) or I.\n+     *\n+     *        Note that z*z can overwrite I; this value must be sensed if it is\n+     *        True.\n+     *\n+     *        Remark 4. If z*z = x exactly, then bit 25 to bit 0 of z1 must be\n+     *        zero.\n+     *\n+     *                    --------------------\n+     *                z1: |        f2        |\n+     *                    --------------------\n+     *                bit 31             bit 0\n+     *\n+     *        Further more, bit 27 and 26 of z1, bit 0 and 1 of x1, and the odd\n+     *        or even of logb(x) have the following relations:\n+     *\n+     *        -------------------------------------------------\n+     *        bit 27,26 of z1         bit 1,0 of x1   logb(x)\n+     *        -------------------------------------------------\n+     *        00                      00              odd and even\n+     *        01                      01              even\n+     *        10                      10              odd\n+     *        10                      00              even\n+     *        11                      01              even\n+     *        -------------------------------------------------\n+     *\n+     *    (4) Special cases (see (4) of Section A).\n+     *\/\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -312,2 +312,4 @@\n-    @IntrinsicCandidate\n-    public static native double sqrt(double a);\n+    \/\/ @IntrinsicCandidate -- Temporarily disable for testing\n+    public static double sqrt(double a) {\n+        return FdLibm.Sqrt.compute(a);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build Tests\n+ * @run main SqrtTests\n+ * @bug 8302040\n+ * @summary Tests for {Math, StrictMath}.sqrt\n+ *\/\n+\n+public class SqrtTests {\n+    private SqrtTests(){}\n+\n+    public static void main(String... argv) {\n+        int failures = 0;\n+\n+        failures += testSqrt();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing sqrt incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static final double InfinityD = Double.POSITIVE_INFINITY;\n+    private static final double NaNd      = Double.NaN;\n+\n+    \/**\n+     * \"Returns the correctly rounded positive square root of a double value. Special cases:\n+     *\n+     * If the argument is NaN or less than zero, then the result is NaN.\n+     *\n+     * If the argument is positive infinity, then the result is positive infinity.\n+     *\n+     * If the argument is positive zero or negative zero, then the\n+     * result is the same as the argument.\n+     *\n+     * Otherwise, the result is the double value closest to the true\n+     * mathematical square root of the argument value.\"\n+     *\/\n+    private static int testSqrt() {\n+        int failures = 0;\n+\n+        for(double nan : Tests.NaNs) {\n+            failures += testSqrtCase(nan, NaNd);\n+        }\n+\n+        double [][] testCases = {\n+            {InfinityD,               InfinityD},\n+\n+            {-Double.MIN_VALUE,       NaNd},\n+            {-Double.MIN_NORMAL,      NaNd},\n+            {-Double.MAX_VALUE,       NaNd},\n+            {-InfinityD,              NaNd},\n+\n+            {+0.0,                   +0.0},\n+            {-0.0,                   -0.0},\n+\n+            \/\/ Test some notable perfect squares\n+            {+0.25,                   +0.5},\n+            {+1.0,                    +1.0},\n+            {+4.0,                    +2.0},\n+            {+9.0,                    +3.0},\n+            {+0x1.ffffff0000002p1023, +0x1.ffffff8p511}\n+        };\n+\n+        for(int i = 0; i < testCases.length; i++) {\n+            failures += testSqrtCase(testCases[i][0], testCases[i][1]);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private static int testSqrtCase(double input, double expected) {\n+        int failures=0;\n+\n+        failures+=Tests.test(\"Math.sqrt\",        input, Math::sqrt,        expected);\n+        failures+=Tests.test(\"StrictMath.sqrt\",  input, StrictMath::sqrt,  expected);\n+\n+        return failures;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/SqrtTests.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301833 8302026 8301444 8302028\n+ * @bug 8301833 8302026 8301444 8302028 8302040\n@@ -69,1 +69,5 @@\n-         \/\/ new UnaryTestCase(\"sqrt\",  FdlibmTranslit::sqrt,  StrictMath::sqrt,  DEFAULT_SHIFT),\n+            \/\/ Since sqrt is correctly rounded and thus for each input\n+            \/\/ there is one well-defined correct result, additional\n+            \/\/ comparison of the transliteration sqrt or StrictMath\n+            \/\/ sqrt could be made against Math::sqrt.\n+            new UnaryTestCase(\"sqrt\",  FdlibmTranslit::sqrt,  StrictMath::sqrt,  DEFAULT_SHIFT),\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExhaustingTests.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -93,0 +93,4 @@\n+    public static double sqrt(double x) {\n+        return Sqrt.compute(x);\n+    }\n+\n@@ -507,0 +511,172 @@\n+    \/**\n+     * Return correctly rounded sqrt.\n+     *           ------------------------------------------\n+     *           |  Use the hardware sqrt if you have one |\n+     *           ------------------------------------------\n+     * Method:\n+     *   Bit by bit method using integer arithmetic. (Slow, but portable)\n+     *   1. Normalization\n+     *      Scale x to y in [1,4) with even powers of 2:\n+     *      find an integer k such that  1 <= (y=x*2^(2k)) < 4, then\n+     *              sqrt(x) = 2^k * sqrt(y)\n+     *   2. Bit by bit computation\n+     *      Let q  = sqrt(y) truncated to i bit after binary point (q = 1),\n+     *           i                                                   0\n+     *                                     i+1         2\n+     *          s  = 2*q , and      y  =  2   * ( y - q  ).         (1)\n+     *           i      i            i                 i\n+     *\n+     *      To compute q    from q , one checks whether\n+     *                  i+1       i\n+     *\n+     *                            -(i+1) 2\n+     *                      (q + 2      ) <= y.                     (2)\n+     *                        i\n+     *                                                            -(i+1)\n+     *      If (2) is false, then q   = q ; otherwise q   = q  + 2      .\n+     *                             i+1   i             i+1   i\n+     *\n+     *      With some algebraic manipulation, it is not difficult to see\n+     *      that (2) is equivalent to\n+     *                             -(i+1)\n+     *                      s  +  2       <= y                      (3)\n+     *                       i                i\n+     *\n+     *      The advantage of (3) is that s  and y  can be computed by\n+     *                                    i      i\n+     *      the following recurrence formula:\n+     *          if (3) is false\n+     *\n+     *          s     =  s  ,       y    = y   ;                    (4)\n+     *           i+1      i          i+1    i\n+     *\n+     *          otherwise,\n+     *                         -i                     -(i+1)\n+     *          s     =  s  + 2  ,  y    = y  -  s  - 2             (5)\n+     *           i+1      i          i+1    i     i\n+     *\n+     *      One may easily use induction to prove (4) and (5).\n+     *      Note. Since the left hand side of (3) contain only i+2 bits,\n+     *            it does not necessary to do a full (53-bit) comparison\n+     *            in (3).\n+     *   3. Final rounding\n+     *      After generating the 53 bits result, we compute one more bit.\n+     *      Together with the remainder, we can decide whether the\n+     *      result is exact, bigger than 1\/2ulp, or less than 1\/2ulp\n+     *      (it will never equal to 1\/2ulp).\n+     *      The rounding mode can be detected by checking whether\n+     *      huge + tiny is equal to huge, and whether huge - tiny is\n+     *      equal to huge for some floating point number \"huge\" and \"tiny\".\n+     *\n+     * Special cases:\n+     *      sqrt(+-0) = +-0         ... exact\n+     *      sqrt(inf) = inf\n+     *      sqrt(-ve) = NaN         ... with invalid signal\n+     *      sqrt(NaN) = NaN         ... with invalid signal for signaling NaN\n+     *\n+     * Other methods : see the appended file at the end of the program below.\n+     *---------------\n+     *\/\n+    static class Sqrt {\n+        private static final double    one     = 1.0, tiny=1.0e-300;\n+\n+        public static double compute(double x) {\n+            double z = 0.0;\n+            int     sign = (int)0x80000000;\n+            \/*unsigned*\/ int r,t1,s1,ix1,q1;\n+            int ix0,s0,q,m,t,i;\n+\n+            ix0 = __HI(x);                  \/* high word of x *\/\n+            ix1 = __LO(x);          \/* low word of x *\/\n+\n+            \/* take care of Inf and NaN *\/\n+            if((ix0&0x7ff00000)==0x7ff00000) {\n+                return x*x+x;               \/* sqrt(NaN)=NaN, sqrt(+inf)=+inf\n+                                               sqrt(-inf)=sNaN *\/\n+            }\n+            \/* take care of zero *\/\n+            if(ix0<=0) {\n+                if(((ix0&(~sign))|ix1)==0) return x;\/* sqrt(+-0) = +-0 *\/\n+                else if(ix0<0)\n+                    return (x-x)\/(x-x);             \/* sqrt(-ve) = sNaN *\/\n+            }\n+            \/* normalize x *\/\n+            m = (ix0>>20);\n+            if(m==0) {                              \/* subnormal x *\/\n+                while(ix0==0) {\n+                    m -= 21;\n+                    ix0 |= (ix1>>>11); ix1 <<= 21; \/\/ unsigned shift\n+                }\n+                for(i=0;(ix0&0x00100000)==0;i++) ix0<<=1;\n+                m -= i-1;\n+                ix0 |= (ix1>>>(32-i)); \/\/ unsigned shift\n+                ix1 <<= i;\n+            }\n+            m -= 1023;      \/* unbias exponent *\/\n+            ix0 = (ix0&0x000fffff)|0x00100000;\n+            if((m&1) != 0){        \/* odd m, double x to make it even *\/\n+                ix0 += ix0 + ((ix1&sign)>>>31); \/\/ unsigned shift\n+                ix1 += ix1;\n+            }\n+            m >>= 1;        \/* m = [m\/2] *\/\n+\n+            \/* generate sqrt(x) bit by bit *\/\n+            ix0 += ix0 + ((ix1&sign)>>>31); \/\/ unsigned shift\n+            ix1 += ix1;\n+            q = q1 = s0 = s1 = 0;   \/* [q,q1] = sqrt(x) *\/\n+            r = 0x00200000;         \/* r = moving bit from right to left *\/\n+\n+            while(r!=0) {\n+                t = s0+r;\n+                if(t<=ix0) {\n+                    s0   = t+r;\n+                    ix0 -= t;\n+                    q   += r;\n+                }\n+                ix0 += ix0 + ((ix1&sign)>>>31); \/\/ unsigned shift\n+                ix1 += ix1;\n+                r>>>=1; \/\/ unsigned shift\n+            }\n+\n+            r = sign;\n+            while(r!=0) {\n+                t1 = s1+r;\n+                t  = s0;\n+                if((t<ix0)||((t==ix0)&&(Integer.compareUnsigned(t1, ix1) <= 0 ))) { \/\/ t1<=ix1\n+                    s1  = t1+r;\n+                    if(((t1&sign)==sign)&&(s1&sign)==0) s0 += 1;\n+                    ix0 -= t;\n+                    if (Integer.compareUnsigned(ix1, t1) < 0) ix0 -= 1; \/\/ ix1 < t1\n+                    ix1 -= t1;\n+                    q1  += r;\n+                }\n+                ix0 += ix0 + ((ix1&sign)>>>31); \/\/ unsigned shift\n+                ix1 += ix1;\n+                r>>>=1; \/\/ unsigned shift\n+            }\n+\n+            \/* use floating add to find out rounding direction *\/\n+            if((ix0|ix1)!=0) {\n+                z = one-tiny; \/* trigger inexact flag *\/\n+                if (z>=one) {\n+                    z = one+tiny;\n+                    if (q1==0xffffffff) { q1=0; q += 1;}\n+                    else if (z>one) {\n+                        if (q1==0xfffffffe) q+=1;\n+                        q1+=2;\n+                    } else\n+                        q1 += (q1&1);\n+                }\n+            }\n+            ix0 = (q>>1)+0x3fe00000;\n+            ix1 =  q1>>>1; \/\/ unsigned shift\n+            if ((q&1)==1) ix1 |= sign;\n+            ix0 += (m <<20);\n+            \/\/ __HI(z) = ix0;\n+            z = __HI(z, ix0);\n+            \/\/ __LO(z) = ix1;\n+            z = __LO(z, ix1);\n+            return z;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8302040\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build SqrtTests\n+ * @run main SqrtTests\n+ * @summary Tests for StrictMath.sqrt\n+ *\/\n+import jdk.test.lib.RandomFactory;\n+\n+\/**\n+ * The tests in ..\/Math\/SqrtTests.java test properties that should\n+ * hold for any sqrt implementation, including the FDLIBM-based one\n+ * required for StrictMath.sqrt.  Therefore, the test cases in\n+ * ..\/Math\/SqrtTests.java are run against both the Math and\n+ * StrictMath versions of sqrt.  The role of this test is to verify\n+ * that the FDLIBM sqrt algorithm is being used by running golden\n+ * file tests on values that may vary from one conforming sqrt\n+ * implementation to another.\n+ *\/\n+\n+public class SqrtTests {\n+    private SqrtTests(){}\n+\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAgainstTranslit();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing sqrt incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test StrictMath.sqrt against transliteration port of sqrt.\n+     *\/\n+    private static int testAgainstTranslit() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Test just above subnormal threshold...\n+        x = Double.MIN_NORMAL;\n+        failures += testRange(x, Math.ulp(x), 1000);\n+\n+        \/\/ ... and just below subnormal threshold ...\n+        x = Math.nextDown(Double.MIN_NORMAL);\n+        failures += testRange(x, -Math.ulp(x), 1000);\n+\n+        \/\/ ... and near 1.0 ...\n+        failures += testRangeMidpoint(1.0, Math.ulp(x), 2000);\n+        \/\/ (Note: probes every-other value less than 1.0 due to\n+        \/\/ change in the size of an ulp at 1.0.\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+            Double.MIN_VALUE,\n+            Double.MAX_VALUE,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000);\n+        }\n+\n+        x = Tests.createRandomDouble(random);\n+\n+        \/\/ Make the increment twice the ulp value in case the random\n+        \/\/ value is near an exponent threshold. Don't worry about test\n+        \/\/ elements overflowing to infinity if the starting value is\n+        \/\/ near Double.MAX_VALUE.\n+        failures += testRange(x, 2.0 * Math.ulp(x), 1000);\n+\n+        return failures;\n+    }\n+\n+    private static int testRange(double start, double increment, int count) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testSqrtCase(x, FdlibmTranslit.sqrt(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeMidpoint(double midpoint, double increment, int count) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testSqrtCase(x, FdlibmTranslit.sqrt(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testSqrtCase(double input, double expected) {\n+        return Tests.test(\"StrictMath.sqrt(double)\", input,\n+                          StrictMath::sqrt, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StrictMath\/SqrtTests.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}