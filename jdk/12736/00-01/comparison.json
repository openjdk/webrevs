{"files":[{"patch":"@@ -107,0 +107,9 @@\n+    \/**\n+     * Return a double with its high-order bits of the first argument\n+     * and the low-order bits of the second argument..\n+     *\/\n+    private static double __HI_LO(int high, int low) {\n+        return Double.longBitsToDouble(((long)high << 32) |\n+                                       (low & 0xffff_ffffL));\n+    }\n+\n@@ -688,3 +697,1 @@\n-            z = __HI(z, ix0);\n-            z = __LO(z, ix1);\n-            return z;\n+            return __HI_LO(ix0, ix1);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -69,3 +69,4 @@\n-            \/\/ Since sqrt is correctly rounded, could additionaly the\n-            \/\/ transliteration or StrictMath sqrt methods to against\n-            \/\/ Math::sqrt.\n+            \/\/ Since sqrt is correctly rounded and thus for each input\n+            \/\/ there is one well-defined correct result, additional\n+            \/\/ comparison of the transliteration sqrt or StrictMath\n+            \/\/ sqrt could be made against Math::sqrt.\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExhaustingTests.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -653,1 +653,1 @@\n-                ix0 += ix0 + ((ix1&sign)>>>31);\n+                ix0 += ix0 + ((ix1&sign)>>>31); \/\/ unsigned shift\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-            Double.MIN_VALUE;\n-            Double.MAX_VALUE;\n+            Double.MIN_VALUE,\n+            Double.MAX_VALUE,\n","filename":"test\/jdk\/java\/lang\/StrictMath\/SqrtTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}