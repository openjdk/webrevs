{"files":[{"patch":"@@ -111,0 +111,24 @@\n+    @ForceInline\n+    @Override\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public final VectorShuffle<E> rearrange(VectorShuffle<E> shuffle) {\n+        Vector v = toBitsVector();\n+        return (VectorShuffle<E>) v.rearrange(shuffle.cast(vspecies().asIntegral()))\n+                .toShuffle()\n+                .cast(vspecies());\n+    }\n+\n+    @ForceInline\n+    @Override\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    public final VectorShuffle<E> wrapIndexes() {\n+        Vector v = toBitsVector();\n+        if ((length() & (length() - 1)) == 0) {\n+            v = v.lanewise(VectorOperators.AND, length() - 1);\n+        } else {\n+            v = v.blend(v.lanewise(VectorOperators.ADD, length()),\n+                    v.compare(VectorOperators.LT, 0));\n+        }\n+        return (VectorShuffle<E>) v.toShuffle().cast(vspecies());\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -193,1 +193,21 @@\n-    abstract AbstractShuffle<E> iotaShuffle(int start, int step, boolean wrap);\n+    @ForceInline\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    final AbstractShuffle<E> iotaShuffle(int start, int step, boolean wrap) {\n+        if ((length() & (length() - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, length())))\n+                    : shuffleFromOp(i -> i * step + start);\n+        }\n+\n+        AbstractSpecies<?> species = vspecies().asIntegral();\n+        Vector iota = species.iota();\n+        iota = iota.lanewise(VectorOperators.MUL, step)\n+                .lanewise(VectorOperators.ADD, start);\n+        Vector wrapped = iota.lanewise(VectorOperators.AND, length() - 1);\n+\n+        if (!wrap) {\n+            Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, length());\n+            VectorMask<?> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return (AbstractShuffle<E>) wrapped.toShuffle().cast(vspecies());\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Byte128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Byte128Vector iota = Byte128Shuffle.IOTA.toBitsVector();\n-        ByteVector.ByteSpecies species = Byte128Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Byte128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Byte128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Byte> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -894,21 +873,0 @@\n-        @ForceInline\n-        @Override\n-        public Byte128Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Byte128Shuffle wrapIndexes() {\n-            Byte128Vector v = toBitsVector();\n-            ByteVector.ByteSpecies species = Byte128Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Byte> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Byte> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Byte256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Byte256Vector iota = Byte256Shuffle.IOTA.toBitsVector();\n-        ByteVector.ByteSpecies species = Byte256Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Byte256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Byte256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Byte> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -926,21 +905,0 @@\n-        @ForceInline\n-        @Override\n-        public Byte256Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Byte256Shuffle wrapIndexes() {\n-            Byte256Vector v = toBitsVector();\n-            ByteVector.ByteSpecies species = Byte256Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Byte> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Byte> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Byte512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Byte512Vector iota = Byte512Shuffle.IOTA.toBitsVector();\n-        ByteVector.ByteSpecies species = Byte512Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Byte512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Byte512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Byte> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -990,21 +969,0 @@\n-        @ForceInline\n-        @Override\n-        public Byte512Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Byte512Shuffle wrapIndexes() {\n-            Byte512Vector v = toBitsVector();\n-            ByteVector.ByteSpecies species = Byte512Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Byte> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Byte> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Byte64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Byte64Vector iota = Byte64Shuffle.IOTA.toBitsVector();\n-        ByteVector.ByteSpecies species = Byte64Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Byte64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Byte64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Byte> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -878,21 +857,0 @@\n-        @ForceInline\n-        @Override\n-        public Byte64Shuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Byte64Shuffle wrapIndexes() {\n-            Byte64Vector v = toBitsVector();\n-            ByteVector.ByteSpecies species = Byte64Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Byte> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Byte> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    ByteMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        ByteMaxVector iota = ByteMaxShuffle.IOTA.toBitsVector();\n-        ByteVector.ByteSpecies species = ByteMaxVector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        ByteMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            ByteMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Byte> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -864,21 +843,0 @@\n-        @ForceInline\n-        @Override\n-        public ByteMaxShuffle rearrange(VectorShuffle<Byte> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public ByteMaxShuffle wrapIndexes() {\n-            ByteMaxVector v = toBitsVector();\n-            ByteVector.ByteSpecies species = ByteMaxVector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Byte> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Byte> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Double128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Long128Vector iota = Double128Shuffle.IOTA.toBitsVector();\n-        LongVector.LongSpecies species = Long128Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Long128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Long128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toFPShuffle();\n-    }\n-\n@@ -850,23 +829,0 @@\n-        @ForceInline\n-        @Override\n-        public Double128Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast(Long128Vector.VSPECIES))\n-                    .toFPShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Double128Shuffle wrapIndexes() {\n-            Long128Vector v = toBitsVector();\n-            LongVector.LongSpecies species = Long128Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toFPShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Double256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Long256Vector iota = Double256Shuffle.IOTA.toBitsVector();\n-        LongVector.LongSpecies species = Long256Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Long256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Long256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toFPShuffle();\n-    }\n-\n@@ -854,23 +833,0 @@\n-        @ForceInline\n-        @Override\n-        public Double256Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast(Long256Vector.VSPECIES))\n-                    .toFPShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Double256Shuffle wrapIndexes() {\n-            Long256Vector v = toBitsVector();\n-            LongVector.LongSpecies species = Long256Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toFPShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Double512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Long512Vector iota = Double512Shuffle.IOTA.toBitsVector();\n-        LongVector.LongSpecies species = Long512Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Long512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Long512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toFPShuffle();\n-    }\n-\n@@ -862,23 +841,0 @@\n-        @ForceInline\n-        @Override\n-        public Double512Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast(Long512Vector.VSPECIES))\n-                    .toFPShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Double512Shuffle wrapIndexes() {\n-            Long512Vector v = toBitsVector();\n-            LongVector.LongSpecies species = Long512Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toFPShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Double64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Long64Vector iota = Double64Shuffle.IOTA.toBitsVector();\n-        LongVector.LongSpecies species = Long64Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Long64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Long64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toFPShuffle();\n-    }\n-\n@@ -842,23 +821,0 @@\n-        @ForceInline\n-        @Override\n-        public Double64Shuffle rearrange(VectorShuffle<Double> shuffle) {\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast(Long64Vector.VSPECIES))\n-                    .toFPShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Double64Shuffle wrapIndexes() {\n-            Long64Vector v = toBitsVector();\n-            LongVector.LongSpecies species = Long64Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toFPShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    DoubleMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        LongMaxVector iota = DoubleMaxShuffle.IOTA.toBitsVector();\n-        LongVector.LongSpecies species = LongMaxVector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        LongMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            LongMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toFPShuffle();\n-    }\n-\n@@ -847,23 +826,0 @@\n-        @ForceInline\n-        @Override\n-        public DoubleMaxShuffle rearrange(VectorShuffle<Double> shuffle) {\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast(LongMaxVector.VSPECIES))\n-                    .toFPShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public DoubleMaxShuffle wrapIndexes() {\n-            LongMaxVector v = toBitsVector();\n-            LongVector.LongSpecies species = LongMaxVector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toFPShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Float128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Int128Vector iota = Float128Shuffle.IOTA.toBitsVector();\n-        IntVector.IntSpecies species = Int128Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Int128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Int128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toFPShuffle();\n-    }\n-\n@@ -848,23 +827,0 @@\n-        @ForceInline\n-        @Override\n-        public Float128Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast(Int128Vector.VSPECIES))\n-                    .toFPShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Float128Shuffle wrapIndexes() {\n-            Int128Vector v = toBitsVector();\n-            IntVector.IntSpecies species = Int128Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toFPShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Float256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Int256Vector iota = Float256Shuffle.IOTA.toBitsVector();\n-        IntVector.IntSpecies species = Int256Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Int256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Int256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toFPShuffle();\n-    }\n-\n@@ -856,23 +835,0 @@\n-        @ForceInline\n-        @Override\n-        public Float256Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast(Int256Vector.VSPECIES))\n-                    .toFPShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Float256Shuffle wrapIndexes() {\n-            Int256Vector v = toBitsVector();\n-            IntVector.IntSpecies species = Int256Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toFPShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Float512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Int512Vector iota = Float512Shuffle.IOTA.toBitsVector();\n-        IntVector.IntSpecies species = Int512Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Int512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Int512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toFPShuffle();\n-    }\n-\n@@ -872,23 +851,0 @@\n-        @ForceInline\n-        @Override\n-        public Float512Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast(Int512Vector.VSPECIES))\n-                    .toFPShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Float512Shuffle wrapIndexes() {\n-            Int512Vector v = toBitsVector();\n-            IntVector.IntSpecies species = Int512Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toFPShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Float64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Int64Vector iota = Float64Shuffle.IOTA.toBitsVector();\n-        IntVector.IntSpecies species = Int64Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Int64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Int64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toFPShuffle();\n-    }\n-\n@@ -844,23 +823,0 @@\n-        @ForceInline\n-        @Override\n-        public Float64Shuffle rearrange(VectorShuffle<Float> shuffle) {\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast(Int64Vector.VSPECIES))\n-                    .toFPShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Float64Shuffle wrapIndexes() {\n-            Int64Vector v = toBitsVector();\n-            IntVector.IntSpecies species = Int64Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toFPShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    FloatMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        IntMaxVector iota = FloatMaxShuffle.IOTA.toBitsVector();\n-        IntVector.IntSpecies species = IntMaxVector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        IntMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            IntMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toFPShuffle();\n-    }\n-\n@@ -841,23 +820,0 @@\n-        @ForceInline\n-        @Override\n-        public FloatMaxShuffle rearrange(VectorShuffle<Float> shuffle) {\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast(IntMaxVector.VSPECIES))\n-                    .toFPShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public FloatMaxShuffle wrapIndexes() {\n-            IntMaxVector v = toBitsVector();\n-            IntVector.IntSpecies species = IntMaxVector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toFPShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Int128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Int128Vector iota = Int128Shuffle.IOTA.toBitsVector();\n-        IntVector.IntSpecies species = Int128Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Int128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Int128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -862,21 +841,0 @@\n-        @ForceInline\n-        @Override\n-        public Int128Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Int128Shuffle wrapIndexes() {\n-            Int128Vector v = toBitsVector();\n-            IntVector.IntSpecies species = Int128Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Int256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Int256Vector iota = Int256Shuffle.IOTA.toBitsVector();\n-        IntVector.IntSpecies species = Int256Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Int256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Int256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -870,21 +849,0 @@\n-        @ForceInline\n-        @Override\n-        public Int256Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Int256Shuffle wrapIndexes() {\n-            Int256Vector v = toBitsVector();\n-            IntVector.IntSpecies species = Int256Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Int512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Int512Vector iota = Int512Shuffle.IOTA.toBitsVector();\n-        IntVector.IntSpecies species = Int512Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Int512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Int512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -886,21 +865,0 @@\n-        @ForceInline\n-        @Override\n-        public Int512Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Int512Shuffle wrapIndexes() {\n-            Int512Vector v = toBitsVector();\n-            IntVector.IntSpecies species = Int512Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Int64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Int64Vector iota = Int64Shuffle.IOTA.toBitsVector();\n-        IntVector.IntSpecies species = Int64Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Int64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Int64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -858,21 +837,0 @@\n-        @ForceInline\n-        @Override\n-        public Int64Shuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Int64Shuffle wrapIndexes() {\n-            Int64Vector v = toBitsVector();\n-            IntVector.IntSpecies species = Int64Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    IntMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        IntMaxVector iota = IntMaxShuffle.IOTA.toBitsVector();\n-        IntVector.IntSpecies species = IntMaxVector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        IntMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            IntMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -867,21 +846,0 @@\n-        @ForceInline\n-        @Override\n-        public IntMaxShuffle rearrange(VectorShuffle<Integer> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public IntMaxShuffle wrapIndexes() {\n-            IntMaxVector v = toBitsVector();\n-            IntVector.IntSpecies species = IntMaxVector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2489,1 +2489,1 @@\n-    abstract VectorShuffle<Float> toFPShuffle();\n+    abstract AbstractShuffle<Float> toFPShuffle();\n@@ -2493,1 +2493,1 @@\n-    VectorShuffle<Float> toFPShuffle0(VectorSpecies<Float> dsp) {\n+    AbstractShuffle<Float> toFPShuffle0(VectorSpecies<Float> dsp) {\n@@ -2499,1 +2499,1 @@\n-        return VectorShuffle.fromArray(dsp, sa, 0);\n+        return (AbstractShuffle<Float>) VectorShuffle.fromArray(dsp, sa, 0);\n@@ -2504,1 +2504,1 @@\n-    VectorShuffle<Float> toFPShuffleTemplate(Class<?> shuffleType, FloatVector.FloatSpecies dsp) {\n+    AbstractShuffle<Float> toFPShuffleTemplate(Class<?> shuffleType, FloatVector.FloatSpecies dsp) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -139,21 +139,0 @@\n-    @ForceInline\n-    Long128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Long128Vector iota = Long128Shuffle.IOTA.toBitsVector();\n-        LongVector.LongSpecies species = Long128Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Long128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Long128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -854,21 +833,0 @@\n-        @ForceInline\n-        @Override\n-        public Long128Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Long128Shuffle wrapIndexes() {\n-            Long128Vector v = toBitsVector();\n-            LongVector.LongSpecies species = Long128Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -139,21 +139,0 @@\n-    @ForceInline\n-    Long256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Long256Vector iota = Long256Shuffle.IOTA.toBitsVector();\n-        LongVector.LongSpecies species = Long256Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Long256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Long256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -858,21 +837,0 @@\n-        @ForceInline\n-        @Override\n-        public Long256Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Long256Shuffle wrapIndexes() {\n-            Long256Vector v = toBitsVector();\n-            LongVector.LongSpecies species = Long256Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -139,21 +139,0 @@\n-    @ForceInline\n-    Long512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Long512Vector iota = Long512Shuffle.IOTA.toBitsVector();\n-        LongVector.LongSpecies species = Long512Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Long512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Long512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -866,21 +845,0 @@\n-        @ForceInline\n-        @Override\n-        public Long512Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Long512Shuffle wrapIndexes() {\n-            Long512Vector v = toBitsVector();\n-            LongVector.LongSpecies species = Long512Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -139,21 +139,0 @@\n-    @ForceInline\n-    Long64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Long64Vector iota = Long64Shuffle.IOTA.toBitsVector();\n-        LongVector.LongSpecies species = Long64Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Long64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Long64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -846,21 +825,0 @@\n-        @ForceInline\n-        @Override\n-        public Long64Shuffle rearrange(VectorShuffle<Long> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Long64Shuffle wrapIndexes() {\n-            Long64Vector v = toBitsVector();\n-            LongVector.LongSpecies species = Long64Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -139,21 +139,0 @@\n-    @ForceInline\n-    LongMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        LongMaxVector iota = LongMaxShuffle.IOTA.toBitsVector();\n-        LongVector.LongSpecies species = LongMaxVector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        LongMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            LongMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -852,21 +831,0 @@\n-        @ForceInline\n-        @Override\n-        public LongMaxShuffle rearrange(VectorShuffle<Long> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public LongMaxShuffle wrapIndexes() {\n-            LongMaxVector v = toBitsVector();\n-            LongVector.LongSpecies species = LongMaxVector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2355,1 +2355,1 @@\n-    abstract VectorShuffle<Double> toFPShuffle();\n+    abstract AbstractShuffle<Double> toFPShuffle();\n@@ -2359,1 +2359,1 @@\n-    VectorShuffle<Double> toFPShuffle0(VectorSpecies<Double> dsp) {\n+    AbstractShuffle<Double> toFPShuffle0(VectorSpecies<Double> dsp) {\n@@ -2365,1 +2365,1 @@\n-        return VectorShuffle.fromArray(dsp, sa, 0);\n+        return (AbstractShuffle<Double>) VectorShuffle.fromArray(dsp, sa, 0);\n@@ -2370,1 +2370,1 @@\n-    VectorShuffle<Double> toFPShuffleTemplate(Class<?> shuffleType, DoubleVector.DoubleSpecies dsp) {\n+    AbstractShuffle<Double> toFPShuffleTemplate(Class<?> shuffleType, DoubleVector.DoubleSpecies dsp) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Short128Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Short128Vector iota = Short128Shuffle.IOTA.toBitsVector();\n-        ShortVector.ShortSpecies species = Short128Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Short128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Short128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Short> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -872,21 +851,0 @@\n-        @ForceInline\n-        @Override\n-        public Short128Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Short128Shuffle wrapIndexes() {\n-            Short128Vector v = toBitsVector();\n-            ShortVector.ShortSpecies species = Short128Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Short> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Short> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Short256Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Short256Vector iota = Short256Shuffle.IOTA.toBitsVector();\n-        ShortVector.ShortSpecies species = Short256Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Short256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Short256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Short> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -888,21 +867,0 @@\n-        @ForceInline\n-        @Override\n-        public Short256Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Short256Shuffle wrapIndexes() {\n-            Short256Vector v = toBitsVector();\n-            ShortVector.ShortSpecies species = Short256Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Short> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Short> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Short512Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Short512Vector iota = Short512Shuffle.IOTA.toBitsVector();\n-        ShortVector.ShortSpecies species = Short512Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Short512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Short512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Short> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -920,21 +899,0 @@\n-        @ForceInline\n-        @Override\n-        public Short512Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Short512Shuffle wrapIndexes() {\n-            Short512Vector v = toBitsVector();\n-            ShortVector.ShortSpecies species = Short512Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Short> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Short> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    Short64Shuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        Short64Vector iota = Short64Shuffle.IOTA.toBitsVector();\n-        ShortVector.ShortSpecies species = Short64Vector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        Short64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            Short64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Short> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -864,21 +843,0 @@\n-        @ForceInline\n-        @Override\n-        public Short64Shuffle rearrange(VectorShuffle<Short> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public Short64Shuffle wrapIndexes() {\n-            Short64Vector v = toBitsVector();\n-            ShortVector.ShortSpecies species = Short64Vector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Short> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Short> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -144,21 +144,0 @@\n-    @ForceInline\n-    ShortMaxShuffle iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        ShortMaxVector iota = ShortMaxShuffle.IOTA.toBitsVector();\n-        ShortVector.ShortSpecies species = ShortMaxVector.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        ShortMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            ShortMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<Short> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-        return wrapped.toShuffle();\n-    }\n-\n@@ -858,21 +837,0 @@\n-        @ForceInline\n-        @Override\n-        public ShortMaxShuffle rearrange(VectorShuffle<Short> shuffle) {\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public ShortMaxShuffle wrapIndexes() {\n-            ShortMaxVector v = toBitsVector();\n-            ShortVector.ShortSpecies species = ShortMaxVector.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<Short> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<Short> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-            return v.toShuffle();\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2884,1 +2884,1 @@\n-    abstract VectorShuffle<$Boxfptype$> toFPShuffle();\n+    abstract AbstractShuffle<$Boxfptype$> toFPShuffle();\n@@ -2888,1 +2888,1 @@\n-    VectorShuffle<$Boxfptype$> toFPShuffle0(VectorSpecies<$Boxfptype$> dsp) {\n+    AbstractShuffle<$Boxfptype$> toFPShuffle0(VectorSpecies<$Boxfptype$> dsp) {\n@@ -2894,1 +2894,1 @@\n-        return VectorShuffle.fromArray(dsp, sa, 0);\n+        return (AbstractShuffle<$Boxfptype$>) VectorShuffle.fromArray(dsp, sa, 0);\n@@ -2899,1 +2899,1 @@\n-    VectorShuffle<$Boxfptype$> toFPShuffleTemplate(Class<?> shuffleType, $Fptype$Vector.$Fptype$Species dsp) {\n+    AbstractShuffle<$Boxfptype$> toFPShuffleTemplate(Class<?> shuffleType, $Fptype$Vector.$Fptype$Species dsp) {\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -146,26 +146,0 @@\n-    @ForceInline\n-    $shuffletype$ iotaShuffle(int start, int step, boolean wrap) {\n-        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n-            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n-                        : shuffleFromOp(i -> i * step + start);\n-        }\n-\n-        $bitsvectortype$ iota = $shuffletype$.IOTA.toBitsVector();\n-        $Bitstype$Vector.$Bitstype$Species species = $bitsvectortype$.VSPECIES;\n-        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n-                .lanewise(VectorOperators.ADD, species.broadcast(start));\n-        $bitsvectortype$ wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-\n-        if (!wrap) {\n-            $bitsvectortype$ wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n-            VectorMask<$Boxbitstype$> mask = wrapped.compare(VectorOperators.EQ, iota);\n-            wrapped = wrappedEx.blend(wrapped, mask);\n-        }\n-#if[!FP]\n-        return wrapped.toShuffle();\n-#end[!FP]\n-#if[FP]\n-        return wrapped.toFPShuffle();\n-#end[FP]\n-    }\n-\n@@ -1204,33 +1178,0 @@\n-        @ForceInline\n-        @Override\n-        public $shuffletype$ rearrange(VectorShuffle<$Boxtype$> shuffle) {\n-#if[!FP]\n-            return toBitsVector().rearrange(shuffle).toShuffle();\n-#end[!FP]\n-#if[FP]\n-            return toBitsVector()\n-                    .rearrange(shuffle.cast($bitsvectortype$.VSPECIES))\n-                    .toFPShuffle();\n-#end[FP]\n-        }\n-\n-        @ForceInline\n-        @Override\n-        public $shuffletype$ wrapIndexes() {\n-            $bitsvectortype$ v = toBitsVector();\n-            $Bitstype$Vector.$Bitstype$Species species = $bitsvectortype$.VSPECIES;\n-            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n-                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n-            } else {\n-                VectorMask<$Boxbitstype$> neg = v.compare(VectorOperators.LT, 0);\n-                Vector<$Boxbitstype$> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n-                v = v.blend(adjusted, neg);\n-            }\n-#if[!FP]\n-            return v.toShuffle();\n-#end[!FP]\n-#if[FP]\n-            return v.toFPShuffle();\n-#end[FP]\n-        }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":0,"deletions":59,"binary":false,"changes":59,"status":"modified"}]}