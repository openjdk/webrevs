{"files":[{"patch":"@@ -310,0 +310,4 @@\n+  const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+    return false;\n+  }\n+\n@@ -6059,35 +6063,0 @@\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffle(vReg dst, vReg src) %{\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"loadshuffle $dst, $src\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    if (bt == T_BYTE) {\n-      if ($dst$$FloatRegister != $src$$FloatRegister) {\n-        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-                 $src$$FloatRegister, $src$$FloatRegister);\n-        } else {\n-          assert(UseSVE > 0, \"must be sve\");\n-          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n-        }\n-      }\n-    } else {\n-      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-        \/\/ 4S\/8S, 4I, 4F\n-        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n-        if (type2aelembytes(bt) == 4) {\n-          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n-        }\n-      } else {\n-        assert(UseSVE > 0, \"must be sve\");\n-        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n-                             $src$$FloatRegister, __ B);\n-      }\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -6116,0 +6085,1 @@\n+\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":5,"deletions":35,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -300,0 +300,4 @@\n+  const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+    return false;\n+  }\n+\n@@ -4412,35 +4416,0 @@\n-\/\/ ------------------------------ Vector shuffle -------------------------------\n-\n-instruct loadshuffle(vReg dst, vReg src) %{\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"loadshuffle $dst, $src\" %}\n-  ins_encode %{\n-    BasicType bt = Matcher::vector_element_basic_type(this);\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this);\n-    if (bt == T_BYTE) {\n-      if ($dst$$FloatRegister != $src$$FloatRegister) {\n-        if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-          __ orr($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-                 $src$$FloatRegister, $src$$FloatRegister);\n-        } else {\n-          assert(UseSVE > 0, \"must be sve\");\n-          __ sve_orr($dst$$FloatRegister, $src$$FloatRegister, $src$$FloatRegister);\n-        }\n-      }\n-    } else {\n-      if (VM_Version::use_neon_for_vector(length_in_bytes)) {\n-        \/\/ 4S\/8S, 4I, 4F\n-        __ uxtl($dst$$FloatRegister, __ T8H, $src$$FloatRegister, __ T8B);\n-        if (type2aelembytes(bt) == 4) {\n-          __ uxtl($dst$$FloatRegister, __ T4S, $dst$$FloatRegister, __ T4H);\n-        }\n-      } else {\n-        assert(UseSVE > 0, \"must be sve\");\n-        __ sve_vector_extend($dst$$FloatRegister,  __ elemType_to_regVariant(bt),\n-                             $src$$FloatRegister, __ B);\n-      }\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -4469,0 +4438,1 @@\n+\/\/ Maybe move the shuffle preparation to VectorLoadShuffle\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":5,"deletions":35,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1028,0 +1028,4 @@\n+const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2192,0 +2192,4 @@\n+const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1875,0 +1875,4 @@\n+const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1532,0 +1532,4 @@\n+const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2174,0 +2174,13 @@\n+\/\/ Do Vector::rearrange needs preparation of the shuffle argument\n+const bool Matcher::vector_needs_load_shuffle(BasicType elem_bt, int vlen) {\n+  if (elem_bt == T_BYTE) {\n+    return false;\n+  } else if (elem_bt == T_SHORT) {\n+    return !VM_Version::supports_avx512bw();\n+  } else if (elem_bt == T_INT || elem_bt == T_FLOAT) {\n+    return !VM_Version::supports_avx2();\n+  } else { \/\/ T_LONG || T_DOUBLE\n+    return vlen < 8 && !VM_Version::supports_avx512vl();\n+  }\n+}\n+\n@@ -8400,11 +8413,0 @@\n-\n-instruct loadShuffleB(vec dst) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n-  match(Set dst (VectorLoadShuffle dst));\n-  format %{ \"vector_load_shuffle $dst, $dst\" %}\n-  ins_encode %{\n-    \/\/ empty\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -8477,1 +8479,1 @@\n-            Matcher::vector_length(n) <= 16 && !VM_Version::supports_avx512bw()); \/\/ NB! aligned with rearrangeS\n+            !VM_Version::supports_avx512bw());\n@@ -8488,1 +8490,1 @@\n-      __ pmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister);\n+      __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8503,2 +8505,1 @@\n-      __ vpmovzxbw($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-      __ vpsllw($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n+      __ vpsllw($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n@@ -8551,15 +8552,0 @@\n-instruct loadShuffleS_evex(vec dst, vec src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_SHORT &&\n-            VM_Version::supports_avx512bw());\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-    int vlen_enc = vector_length_encoding(this);\n-    if (!VM_Version::supports_avx512vl()) {\n-      vlen_enc = Assembler::AVX_512bit;\n-    }\n-    __ vpmovzxbw($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -8596,1 +8582,1 @@\n-    __ pmovzxbd($vtmp$$XMMRegister, $src$$XMMRegister);\n+    __ movdqu($vtmp$$XMMRegister, $src$$XMMRegister);\n@@ -8625,12 +8611,0 @@\n-instruct loadShuffleI_avx(vec dst, vec src) %{\n-  predicate((Matcher::vector_element_basic_type(n) == T_INT || Matcher::vector_element_basic_type(n) == T_FLOAT) &&\n-            UseAVX >= 2);\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-  int vlen_enc = vector_length_encoding(this);\n-    __ vpmovzxbd($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n@@ -8668,2 +8642,1 @@\n-    __ vpmovzxbq($vtmp$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-    __ vpsllq($vtmp$$XMMRegister, $vtmp$$XMMRegister, 1, vlen_enc);\n+    __ vpsllq($vtmp$$XMMRegister, $src$$XMMRegister, 1, vlen_enc);\n@@ -8695,14 +8668,0 @@\n-instruct loadShuffleL_evex(vec dst, vec src) %{\n-  predicate(is_double_word_type(Matcher::vector_element_basic_type(n)) && \/\/ T_LONG, T_DOUBLE\n-            (Matcher::vector_length(n) == 8 || VM_Version::supports_avx512vl()));\n-  match(Set dst (VectorLoadShuffle src));\n-  format %{ \"vector_load_shuffle $dst, $src\" %}\n-  ins_encode %{\n-    assert(UseAVX > 2, \"required\");\n-\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vpmovzxbq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n-  %}\n-  ins_pipe( pipe_slow );\n-%}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":18,"deletions":59,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -961,18 +961,0 @@\n-  do_intrinsic(_VectorShuffleIota, jdk_internal_vm_vector_VectorSupport, vector_shuffle_step_iota_name, vector_shuffle_step_iota_sig, F_S)     \\\n-   do_signature(vector_shuffle_step_iota_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;\"                                          \\\n-                                               \"IIII\"                                                                                          \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$ShuffleIotaOperation;)\"                                  \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\")                                         \\\n-   do_name(vector_shuffle_step_iota_name, \"shuffleIota\")                                                                                       \\\n-                                                                                                                                               \\\n-  do_intrinsic(_VectorShuffleToVector, jdk_internal_vm_vector_VectorSupport, vector_shuffle_to_vector_name, vector_shuffle_to_vector_sig, F_S) \\\n-   do_signature(vector_shuffle_to_vector_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljava\/lang\/Class;\"                                                                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\"                                          \\\n-                                               \"ILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleToVectorOperation;)\"                             \\\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\")                                                \\\n-   do_name(vector_shuffle_to_vector_name, \"shuffleToVector\")                                                                                   \\\n-                                                                                                                                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -752,2 +752,0 @@\n-  case vmIntrinsics::_VectorShuffleIota:\n-  case vmIntrinsics::_VectorShuffleToVector:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -907,1 +907,1 @@\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -688,2 +688,0 @@\n-  case vmIntrinsics::_VectorShuffleIota:\n-    return inline_vector_shuffle_iota();\n@@ -692,2 +690,0 @@\n-  case vmIntrinsics::_VectorShuffleToVector:\n-    return inline_vector_shuffle_to_vector();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -343,2 +343,0 @@\n-  bool inline_vector_shuffle_to_vector();\n-  bool inline_vector_shuffle_iota();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -341,0 +341,2 @@\n+  static const bool vector_needs_load_shuffle(BasicType elem_bt, int vlen);\n+\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,5 +39,0 @@\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n-\n@@ -441,2 +436,0 @@\n-    } else if (is_vector_shuffle(from_kls)) {\n-      bt = T_BYTE;\n@@ -487,3 +480,0 @@\n-    } else if (is_vector_shuffle(from_kls) && !vec_unbox->is_shuffle_to_vector()) {\n-      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect shuffle type consistency\");\n-      vec_val_load = gvn.transform(new VectorLoadShuffleNode(vec_val_load, TypeVect::make(masktype, num_elem)));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,4 +66,0 @@\n-static bool is_vector_shuffle(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n-}\n-\n@@ -163,1 +159,1 @@\n-Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n+Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem) {\n@@ -174,1 +170,1 @@\n-  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory(), shuffle_to_vector));\n+  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory()));\n@@ -585,97 +581,0 @@\n-\/\/ <Sh extends VectorShuffle<E>,  E>\n-\/\/  Sh ShuffleIota(Class<?> E, Class<?> shuffleClass, Vector.Species<E> s, int length,\n-\/\/                  int start, int step, int wrap, ShuffleIotaOperation<Sh, E> defaultImpl)\n-bool LibraryCallKit::inline_vector_shuffle_iota() {\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(1))->isa_instptr();\n-  const TypeInt*     vlen          = gvn().type(argument(3))->isa_int();\n-  const TypeInt*     start_val     = gvn().type(argument(4))->isa_int();\n-  const TypeInt*     step_val      = gvn().type(argument(5))->isa_int();\n-  const TypeInt*     wrap          = gvn().type(argument(6))->isa_int();\n-\n-  Node* start = argument(4);\n-  Node* step  = argument(5);\n-\n-  if (shuffle_klass == nullptr || vlen == nullptr || start_val == nullptr || step_val == nullptr || wrap == nullptr) {\n-    return false; \/\/ dead code\n-  }\n-  if (!vlen->is_con() || !is_power_of_2(vlen->get_con()) ||\n-      shuffle_klass->const_oop() == nullptr || !wrap->is_con()) {\n-    return false; \/\/ not enough info for intrinsification\n-  }\n-  if (!is_klass_initialized(shuffle_klass)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n-    return false;\n-  }\n-\n-  int do_wrap = wrap->get_con();\n-  int num_elem = vlen->get_con();\n-  BasicType elem_bt = T_BYTE;\n-\n-  if (!arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed)) {\n-    return false;\n-  }\n-  if (!arch_supports_vector(Op_AddVB, num_elem, elem_bt, VecMaskNotUsed)) {\n-    return false;\n-  }\n-  if (!arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)) {\n-    return false;\n-  }\n-  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed)) {\n-    return false;\n-  }\n-  if (!arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)) {\n-    return false;\n-  }\n-  if (!arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskUseStore)) {\n-    return false;\n-  }\n-\n-  const Type * type_bt = Type::get_const_basic_type(elem_bt);\n-  const TypeVect * vt  = TypeVect::make(type_bt, num_elem);\n-\n-  Node* res =  gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), vt));\n-\n-  if(!step_val->is_con() || !is_power_of_2(step_val->get_con())) {\n-    Node* bcast_step     = gvn().transform(VectorNode::scalar2vector(step, num_elem, type_bt));\n-    res = gvn().transform(VectorNode::make(Op_MulI, res, bcast_step, num_elem, elem_bt));\n-  } else if (step_val->get_con() > 1) {\n-    Node* cnt = gvn().makecon(TypeInt::make(log2i_exact(step_val->get_con())));\n-    Node* shift_cnt = vector_shift_count(cnt, Op_LShiftI, elem_bt, num_elem);\n-    res = gvn().transform(VectorNode::make(Op_LShiftVB, res, shift_cnt, vt));\n-  }\n-\n-  if (!start_val->is_con() || start_val->get_con() != 0) {\n-    Node* bcast_start    = gvn().transform(VectorNode::scalar2vector(start, num_elem, type_bt));\n-    res = gvn().transform(VectorNode::make(Op_AddI, res, bcast_start, num_elem, elem_bt));\n-  }\n-\n-  Node * mod_val = gvn().makecon(TypeInt::make(num_elem-1));\n-  Node * bcast_mod  = gvn().transform(VectorNode::scalar2vector(mod_val, num_elem, type_bt));\n-  if(do_wrap)  {\n-    \/\/ Wrap the indices greater than lane count.\n-    res = gvn().transform(VectorNode::make(Op_AndI, res, bcast_mod, num_elem, elem_bt));\n-  } else {\n-    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ge));\n-    Node * lane_cnt  = gvn().makecon(TypeInt::make(num_elem));\n-    Node * bcast_lane_cnt = gvn().transform(VectorNode::scalar2vector(lane_cnt, num_elem, type_bt));\n-    const TypeVect* vmask_type = TypeVect::makemask(elem_bt, num_elem);\n-    Node* mask = gvn().transform(new VectorMaskCmpNode(BoolTest::ge, bcast_lane_cnt, res, pred_node, vmask_type));\n-\n-    \/\/ Make the indices greater than lane count as -ve values. This matches the java side implementation.\n-    res = gvn().transform(VectorNode::make(Op_AndI, res, bcast_mod, num_elem, elem_bt));\n-    Node * biased_val = gvn().transform(VectorNode::make(Op_SubI, res, bcast_lane_cnt, num_elem, elem_bt));\n-    res = gvn().transform(new VectorBlendNode(biased_val, res, mask));\n-  }\n-\n-  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n-\n-  \/\/ Wrap it up in VectorBox to keep object type information.\n-  res = box_vector(res, shuffle_box_type, elem_bt, num_elem);\n-  set_result(res);\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n-  return true;\n-}\n-\n@@ -719,1 +618,1 @@\n-  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem, true);\n+  Node* mask_vec = unbox_vector(mask, mask_box_type, elem_bt, num_elem);\n@@ -742,65 +641,0 @@\n-\/\/ public static\n-\/\/ <V,\n-\/\/  Sh extends VectorShuffle<E>,\n-\/\/  E>\n-\/\/ V shuffleToVector(Class<? extends Vector<E>> vclass, Class<E> elementType,\n-\/\/                   Class<? extends Sh> shuffleClass, Sh s, int length,\n-\/\/                   ShuffleToVectorOperation<V, Sh, E> defaultImpl)\n-bool LibraryCallKit::inline_vector_shuffle_to_vector() {\n-  const TypeInstPtr* vector_klass  = gvn().type(argument(0))->isa_instptr();\n-  const TypeInstPtr* elem_klass    = gvn().type(argument(1))->isa_instptr();\n-  const TypeInstPtr* shuffle_klass = gvn().type(argument(2))->isa_instptr();\n-  Node*              shuffle       = argument(3);\n-  const TypeInt*     vlen          = gvn().type(argument(4))->isa_int();\n-\n-  if (vector_klass == nullptr || elem_klass == nullptr || shuffle_klass == nullptr || shuffle->is_top() || vlen == nullptr) {\n-    return false; \/\/ dead code\n-  }\n-  if (!vlen->is_con() || vector_klass->const_oop() == nullptr || shuffle_klass->const_oop() == nullptr) {\n-    return false; \/\/ not enough info for intrinsification\n-  }\n-  if (!is_klass_initialized(shuffle_klass) || !is_klass_initialized(vector_klass) ) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** klass argument not initialized\");\n-    }\n-    return false;\n-  }\n-\n-  int num_elem = vlen->get_con();\n-  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n-  BasicType elem_bt = elem_type->basic_type();\n-\n-  if (num_elem < 4) {\n-    return false;\n-  }\n-\n-  int cast_vopc = VectorCastNode::opcode(-1, T_BYTE); \/\/ from shuffle of type T_BYTE\n-  \/\/ Make sure that cast is implemented to particular type\/size combination.\n-  if (!arch_supports_vector(cast_vopc, num_elem, elem_bt, VecMaskNotUsed)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n-        cast_vopc, num_elem, type2name(elem_bt));\n-    }\n-    return false;\n-  }\n-\n-  ciKlass* sbox_klass = shuffle_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* shuffle_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, sbox_klass);\n-\n-  \/\/ Unbox shuffle with true flag to indicate its load shuffle to vector\n-  \/\/ shuffle is a byte array\n-  Node* shuffle_vec = unbox_vector(shuffle, shuffle_box_type, T_BYTE, num_elem, true);\n-\n-  \/\/ cast byte to target element type\n-  shuffle_vec = gvn().transform(VectorCastNode::make(cast_vopc, shuffle_vec, elem_bt, num_elem));\n-\n-  ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n-  const TypeInstPtr* vec_box_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n-\n-  \/\/ Box vector\n-  Node* res = box_vector(shuffle_vec, vec_box_type, elem_bt, num_elem);\n-  set_result(res);\n-  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n-  return true;\n-}\n-\n@@ -2061,0 +1895,1 @@\n+\n@@ -2063,0 +1898,6 @@\n+  if (shuffle_bt == T_FLOAT) {\n+    shuffle_bt = T_INT;\n+  } else if (shuffle_bt == T_DOUBLE) {\n+    shuffle_bt = T_LONG;\n+  }\n+\n@@ -2064,0 +1905,1 @@\n+  bool need_load_shuffle = Matcher::vector_needs_load_shuffle(shuffle_bt, num_elem);\n@@ -2065,1 +1907,1 @@\n-  if (!arch_supports_vector(Op_VectorLoadShuffle, num_elem, elem_bt, VecMaskNotUsed)) {\n+  if (need_load_shuffle && !arch_supports_vector(Op_VectorLoadShuffle, num_elem, shuffle_bt, VecMaskNotUsed)) {\n@@ -2068,1 +1910,1 @@\n-                    num_elem, type2name(elem_bt));\n+                    num_elem, type2name(shuffle_bt));\n@@ -2105,0 +1947,2 @@\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  const TypeVect* st = TypeVect::make(shuffle_bt, num_elem);\n@@ -2124,0 +1968,4 @@\n+  if (need_load_shuffle) {\n+    shuffle = gvn().transform(new VectorLoadShuffleNode(shuffle, st));\n+  }\n+\n@@ -2130,1 +1978,0 @@\n-      const TypeVect* vt = v1->bottom_type()->is_vect();\n@@ -2424,3 +2271,1 @@\n-  if (is_vector_shuffle(vbox_klass_from)) {\n-    return false; \/\/ vector shuffles aren't supported\n-  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":20,"deletions":175,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -1646,2 +1646,1 @@\n-        bool is_vector_mask    = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n-        bool is_vector_shuffle = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+        bool is_vector_mask = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n@@ -1652,5 +1651,0 @@\n-        } else if (is_vector_shuffle) {\n-          if (!is_shuffle_to_vector()) {\n-            \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorLoadShuffle vshuffle\n-            return new VectorLoadShuffleNode(value, out_vt);\n-          }\n@@ -1658,1 +1652,1 @@\n-          \/\/ Vector type mismatch is only supported for masks and shuffles, but sometimes it happens in pathological cases.\n+          \/\/ Vector type mismatch is only supported for masks, but sometimes it happens in pathological cases.\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1475,3 +1475,1 @@\n-    : VectorNode(in, vt) {\n-    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be BYTE\");\n-  }\n+    : VectorNode(in, vt) {}\n@@ -1479,1 +1477,0 @@\n-  int GetOutShuffleSize() const { return type2aelembytes(vect_type()->element_basic_type()); }\n@@ -1710,2 +1707,0 @@\n- private:\n-  bool _shuffle_to_vector;\n@@ -1715,1 +1710,1 @@\n-  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem, bool shuffle_to_vector)\n+  VectorUnboxNode(Compile* C, const TypeVect* vec_type, Node* obj, Node* mem)\n@@ -1717,1 +1712,0 @@\n-    _shuffle_to_vector = shuffle_to_vector;\n@@ -1728,1 +1722,0 @@\n-  bool is_shuffle_to_vector() { return _shuffle_to_vector; }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -76,4 +76,0 @@\n-bool VectorSupport::is_vector_shuffle(Klass* klass) {\n-  return klass->is_subclass_of(vmClasses::vector_VectorShuffle_klass());\n-}\n-\n@@ -90,3 +86,1 @@\n-  if (is_vector_shuffle(ik)) {\n-    return T_BYTE;\n-  } else if (is_vector_mask(ik)) {\n+  if (is_vector_mask(ik)) {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-  static bool is_vector_shuffle(Klass* klass);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -230,36 +230,0 @@\n-    \/* ============================================================================ *\/\n-    public interface ShuffleIotaOperation<S extends VectorSpecies<?>,\n-                                          SH extends VectorShuffle<?>> {\n-        SH apply(int length, int start, int step, S s);\n-    }\n-\n-    @IntrinsicCandidate\n-    public static\n-    <E,\n-     S extends VectorSpecies<E>,\n-     SH extends VectorShuffle<E>>\n-    SH shuffleIota(Class<E> eClass, Class<? extends SH> shClass, S s,\n-                   int length,\n-                   int start, int step, int wrap,\n-                   ShuffleIotaOperation<S, SH> defaultImpl) {\n-       assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n-       return defaultImpl.apply(length, start, step, s);\n-    }\n-\n-    public interface ShuffleToVectorOperation<V extends Vector<?>,\n-                                              SH extends VectorShuffle<?>> {\n-       V apply(SH sh);\n-    }\n-\n-    @IntrinsicCandidate\n-    public static\n-    <V extends Vector<E>,\n-     SH extends VectorShuffle<E>,\n-     E>\n-    V shuffleToVector(Class<? extends Vector<E>> vClass, Class<E> eClass, Class<? extends SH> shClass, SH sh,\n-                      int length,\n-                      ShuffleToVectorOperation<V, SH> defaultImpl) {\n-      assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n-      return defaultImpl.apply(sh);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    \/\/ Internal representation allows for a maximum index of 256\n+    \/\/ Internal representation allows for a maximum index of E.MAX_VALUE - 1\n@@ -36,40 +36,2 @@\n-    AbstractShuffle(int length, byte[] reorder) {\n-        super(reorder);\n-        assert(length == reorder.length);\n-        assert(indexesInRange(reorder));\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder) {\n-        this(length, reorder, 0);\n-    }\n-\n-    AbstractShuffle(int length, int[] reorder, int offset) {\n-        super(prepare(length, reorder, offset));\n-    }\n-\n-    AbstractShuffle(int length, IntUnaryOperator f) {\n-        super(prepare(length, f));\n-    }\n-\n-    private static byte[] prepare(int length, int[] reorder, int offset) {\n-        byte[] a = new byte[length];\n-        for (int i = 0; i < length; i++) {\n-            int si = reorder[offset + i];\n-            si = partiallyWrapIndex(si, length);\n-            a[i] = (byte) si;\n-        }\n-        return a;\n-    }\n-\n-    private static byte[] prepare(int length, IntUnaryOperator f) {\n-        byte[] a = new byte[length];\n-        for (int i = 0; i < a.length; i++) {\n-            int si = f.applyAsInt(i);\n-            si = partiallyWrapIndex(si, length);\n-            a[i] = (byte) si;\n-        }\n-        return a;\n-    }\n-\n-    byte[] reorder() {\n-        return (byte[])getPayload();\n+    AbstractShuffle(Object indices) {\n+        super(indices);\n@@ -87,0 +49,3 @@\n+    \/*package-private*\/\n+    abstract Vector<?> toBitsVector();\n+\n@@ -89,8 +54,2 @@\n-    public void intoArray(int[] a, int offset) {\n-        byte[] reorder = reorder();\n-        int vlen = reorder.length;\n-        for (int i = 0; i < vlen; i++) {\n-            int sourceIndex = reorder[i];\n-            assert(sourceIndex >= -vlen && sourceIndex < vlen);\n-            a[offset + i] = sourceIndex;\n-        }\n+    public final Vector<E> toVector() {\n+        return toBitsVector().castShape(vspecies(), 0);\n@@ -101,5 +60,4 @@\n-    public int[] toArray() {\n-        byte[] reorder = reorder();\n-        int[] a = new int[reorder.length];\n-        intoArray(a, 0);\n-        return a;\n+    public final int[] toArray() {\n+        int[] res = new int[length()];\n+        intoArray(res, 0);\n+        return res;\n@@ -108,1 +66,1 @@\n-    \/*package-private*\/\n+    @Override\n@@ -110,9 +68,18 @@\n-    final\n-    AbstractVector<E>\n-    toVectorTemplate() {\n-        \/\/ Note that the values produced by laneSource\n-        \/\/ are already clipped.  At this point we convert\n-        \/\/ them from internal ints (or bytes) into the ETYPE.\n-        \/\/ FIXME: Use a conversion intrinsic for this operation.\n-        \/\/ https:\/\/bugs.openjdk.org\/browse\/JDK-8225740\n-        return (AbstractVector<E>) vspecies().fromIntValues(toArray());\n+    @SuppressWarnings(\"unchecked\")\n+    public final <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n+        AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n+        if (length() != species.laneCount()) {\n+            throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n+        }\n+        Vector<?> v = toBitsVector();\n+        if (species.asIntegral() == species) {\n+            return v.castShape(species, 0).toShuffle();\n+        } else if (species.elementType() == float.class) {\n+            return (VectorShuffle<F>)v.castShape(species.asIntegral(), 0)\n+                    .reinterpretAsInts()\n+                    .toFPShuffle();\n+        } else {\n+            return (VectorShuffle<F>)v.castShape(species.asIntegral(), 0)\n+                    .reinterpretAsLongs()\n+                    .toFPShuffle();\n+        }\n@@ -121,0 +88,1 @@\n+    @Override\n@@ -126,13 +94,2 @@\n-        Vector<E> shufvec = this.toVector();\n-        VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());\n-        if (vecmask.anyTrue()) {\n-            byte[] reorder = reorder();\n-            throw checkIndexFailed(reorder[vecmask.firstTrue()], length());\n-        }\n-        return this;\n-    }\n-\n-    @ForceInline\n-    public final VectorShuffle<E> wrapIndexes() {\n-        Vector<E> shufvec = this.toVector();\n-        VectorMask<E> vecmask = shufvec.compare(VectorOperators.LT, vspecies().zero());\n+        Vector<?> shufvec = this.toBitsVector();\n+        VectorMask<?> vecmask = shufvec.compare(VectorOperators.LT, 0);\n@@ -140,3 +97,2 @@\n-            \/\/ FIXME: vectorize this\n-            byte[] reorder = reorder();\n-            return wrapAndRebuild(reorder);\n+            int[] indices = toArray();\n+            throw checkIndexFailed(indices[vecmask.firstTrue()], length());\n@@ -147,19 +103,1 @@\n-    @ForceInline\n-    public final VectorShuffle<E> wrapAndRebuild(byte[] oldReorder) {\n-        int length = oldReorder.length;\n-        byte[] reorder = new byte[length];\n-        for (int i = 0; i < length; i++) {\n-            int si = oldReorder[i];\n-            \/\/ FIXME: This does not work unless it's a power of 2.\n-            if ((length & (length - 1)) == 0) {\n-                si += si & length;  \/\/ power-of-two optimization\n-            } else if (si < 0) {\n-                \/\/ non-POT code requires a conditional add\n-                si += length;\n-            }\n-            assert(si >= 0 && si < length);\n-            reorder[i] = (byte) si;\n-        }\n-        return vspecies().dummyVector().shuffleFromBytes(reorder);\n-    }\n-\n+    @Override\n@@ -168,2 +106,3 @@\n-        Vector<E> shufvec = this.toVector();\n-        return shufvec.compare(VectorOperators.GE, vspecies().zero());\n+        Vector<?> shufvec = this.toBitsVector();\n+        return shufvec.compare(VectorOperators.GE, 0)\n+                .cast(vspecies());\n@@ -223,17 +162,0 @@\n-\n-    static boolean indexesInRange(byte[] reorder) {\n-        int length = reorder.length;\n-        for (byte si : reorder) {\n-            if (si >= length || si < -length) {\n-                boolean assertsEnabled = false;\n-                assert(assertsEnabled = true);\n-                if (assertsEnabled) {\n-                    String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n-                                  java.util.Arrays.toString(reorder));\n-                    throw new AssertionError(msg);\n-                }\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractShuffle.java","additions":40,"deletions":118,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -195,3 +195,0 @@\n-    \/*do not alias this byte array*\/\n-    abstract AbstractShuffle<E> shuffleFromBytes(byte[] reorder);\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Byte128Shuffle)VectorSupport.shuffleIota(ETYPE, Byte128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte128Shuffle)VectorSupport.shuffleIota(ETYPE, Byte128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Byte128Shuffle shuffleFromBytes(byte[] reorder) { return new Byte128Shuffle(reorder); }\n+        Byte128Vector iota = Byte128Shuffle.IOTA.toBitsVector();\n+        ByteVector.ByteSpecies species = Byte128Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Byte128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Byte128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Byte> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Byte128Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte128Shuffle(indexes, i); }\n+    Byte128Shuffle shuffleFromArray(int[] indices, int i) { return new Byte128Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte128Shuffle.class); \/\/ specialize\n+    public Byte128Shuffle toShuffle() {\n+        return (Byte128Shuffle) super.toShuffleTemplate(Byte128Shuffle.class); \/\/ specialize\n@@ -815,2 +822,4 @@\n-        Byte128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte128Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -819,2 +828,2 @@\n-        public Byte128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -823,2 +832,2 @@\n-        public Byte128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -827,2 +836,2 @@\n-        public Byte128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -832,0 +841,1 @@\n+        @ForceInline\n@@ -846,3 +856,11 @@\n-        public Byte128Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte128Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+        Byte128Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Byte128Shuffle.class, byte.class, VLENGTH,\n+                    Byte128Vector.class, byte.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Byte128Vector toBitsVectorHelper(Byte128Shuffle s) {\n+            return (Byte128Vector) Byte128Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -853,6 +871,21 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n@@ -864,7 +897,51 @@\n-            Byte128Shuffle s = (Byte128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Byte128Shuffle wrapIndexes() {\n+            Byte128Vector v = toBitsVector();\n+            ByteVector.ByteSpecies species = Byte128Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Byte> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Byte> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -872,1 +949,1 @@\n-            return new Byte128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":116,"deletions":39,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Byte256Shuffle)VectorSupport.shuffleIota(ETYPE, Byte256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte256Shuffle)VectorSupport.shuffleIota(ETYPE, Byte256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Byte256Shuffle shuffleFromBytes(byte[] reorder) { return new Byte256Shuffle(reorder); }\n+        Byte256Vector iota = Byte256Shuffle.IOTA.toBitsVector();\n+        ByteVector.ByteSpecies species = Byte256Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Byte256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Byte256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Byte> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Byte256Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte256Shuffle(indexes, i); }\n+    Byte256Shuffle shuffleFromArray(int[] indices, int i) { return new Byte256Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte256Shuffle.class); \/\/ specialize\n+    public Byte256Shuffle toShuffle() {\n+        return (Byte256Shuffle) super.toShuffleTemplate(Byte256Shuffle.class); \/\/ specialize\n@@ -847,2 +854,4 @@\n-        Byte256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte256Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -851,2 +860,2 @@\n-        public Byte256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -855,2 +864,2 @@\n-        public Byte256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -859,2 +868,2 @@\n-        public Byte256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -864,0 +873,1 @@\n+        @ForceInline\n@@ -878,3 +888,11 @@\n-        public Byte256Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte256Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+        Byte256Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Byte256Shuffle.class, byte.class, VLENGTH,\n+                    Byte256Vector.class, byte.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Byte256Vector toBitsVectorHelper(Byte256Shuffle s) {\n+            return (Byte256Vector) Byte256Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -885,6 +903,21 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n@@ -896,7 +929,51 @@\n-            Byte256Shuffle s = (Byte256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Byte256Shuffle wrapIndexes() {\n+            Byte256Vector v = toBitsVector();\n+            ByteVector.ByteSpecies species = Byte256Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Byte> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Byte> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -904,1 +981,1 @@\n-            return new Byte256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":116,"deletions":39,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Byte512Shuffle)VectorSupport.shuffleIota(ETYPE, Byte512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte512Shuffle)VectorSupport.shuffleIota(ETYPE, Byte512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Byte512Shuffle shuffleFromBytes(byte[] reorder) { return new Byte512Shuffle(reorder); }\n+        Byte512Vector iota = Byte512Shuffle.IOTA.toBitsVector();\n+        ByteVector.ByteSpecies species = Byte512Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Byte512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Byte512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Byte> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Byte512Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte512Shuffle(indexes, i); }\n+    Byte512Shuffle shuffleFromArray(int[] indices, int i) { return new Byte512Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte512Shuffle.class); \/\/ specialize\n+    public Byte512Shuffle toShuffle() {\n+        return (Byte512Shuffle) super.toShuffleTemplate(Byte512Shuffle.class); \/\/ specialize\n@@ -911,2 +918,4 @@\n-        Byte512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte512Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -915,2 +924,2 @@\n-        public Byte512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -919,2 +928,2 @@\n-        public Byte512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -923,2 +932,2 @@\n-        public Byte512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -928,0 +937,1 @@\n+        @ForceInline\n@@ -942,3 +952,11 @@\n-        public Byte512Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte512Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+        Byte512Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Byte512Shuffle.class, byte.class, VLENGTH,\n+                    Byte512Vector.class, byte.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Byte512Vector toBitsVectorHelper(Byte512Shuffle s) {\n+            return (Byte512Vector) Byte512Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -949,6 +967,21 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n@@ -960,7 +993,51 @@\n-            Byte512Shuffle s = (Byte512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Byte512Shuffle wrapIndexes() {\n+            Byte512Vector v = toBitsVector();\n+            ByteVector.ByteSpecies species = Byte512Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Byte> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Byte> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -968,1 +1045,1 @@\n-            return new Byte512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":116,"deletions":39,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Byte64Shuffle)VectorSupport.shuffleIota(ETYPE, Byte64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Byte64Shuffle)VectorSupport.shuffleIota(ETYPE, Byte64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Byte64Shuffle shuffleFromBytes(byte[] reorder) { return new Byte64Shuffle(reorder); }\n+        Byte64Vector iota = Byte64Shuffle.IOTA.toBitsVector();\n+        ByteVector.ByteSpecies species = Byte64Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Byte64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Byte64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Byte> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Byte64Shuffle shuffleFromArray(int[] indexes, int i) { return new Byte64Shuffle(indexes, i); }\n+    Byte64Shuffle shuffleFromArray(int[] indices, int i) { return new Byte64Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(Byte64Shuffle.class); \/\/ specialize\n+    public Byte64Shuffle toShuffle() {\n+        return (Byte64Shuffle) super.toShuffleTemplate(Byte64Shuffle.class); \/\/ specialize\n@@ -799,2 +806,4 @@\n-        Byte64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte64Shuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -803,2 +812,2 @@\n-        public Byte64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Byte64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -807,2 +816,2 @@\n-        public Byte64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Byte64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -811,2 +820,2 @@\n-        public Byte64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -816,0 +825,1 @@\n+        @ForceInline\n@@ -830,3 +840,11 @@\n-        public Byte64Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Byte64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Byte64Vector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+        Byte64Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Byte64Shuffle.class, byte.class, VLENGTH,\n+                    Byte64Vector.class, byte.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Byte64Vector toBitsVectorHelper(Byte64Shuffle s) {\n+            return (Byte64Vector) Byte64Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -837,6 +855,21 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n@@ -848,7 +881,51 @@\n-            Byte64Shuffle s = (Byte64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Byte64Shuffle wrapIndexes() {\n+            Byte64Vector v = toBitsVector();\n+            ByteVector.ByteSpecies species = Byte64Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Byte> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Byte> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -856,1 +933,1 @@\n-            return new Byte64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":116,"deletions":39,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (ByteMaxShuffle)VectorSupport.shuffleIota(ETYPE, ByteMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    ByteMaxShuffle shuffleFromBytes(byte[] reorder) { return new ByteMaxShuffle(reorder); }\n+        ByteMaxVector iota = ByteMaxShuffle.IOTA.toBitsVector();\n+        ByteVector.ByteSpecies species = ByteMaxVector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        ByteMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            ByteMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Byte> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    ByteMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ByteMaxShuffle(indexes, i); }\n+    ByteMaxShuffle shuffleFromArray(int[] indices, int i) { return new ByteMaxShuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,2 @@\n-    public VectorShuffle<Byte> toShuffle() {\n-        return super.toShuffleTemplate(ByteMaxShuffle.class); \/\/ specialize\n+    public ByteMaxShuffle toShuffle() {\n+        return (ByteMaxShuffle) super.toShuffleTemplate(ByteMaxShuffle.class); \/\/ specialize\n@@ -785,2 +792,4 @@\n-        ByteMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        ByteMaxShuffle(byte[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -789,2 +798,2 @@\n-        public ByteMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        ByteMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -793,2 +802,2 @@\n-        public ByteMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        ByteMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -797,2 +806,2 @@\n-        public ByteMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        byte[] indices() {\n+            return (byte[])getPayload();\n@@ -802,0 +811,1 @@\n+        @ForceInline\n@@ -816,3 +826,11 @@\n-        public ByteMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ByteMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ByteMaxVector)(((AbstractShuffle<Byte>)(s)).toVectorTemplate())));\n+        ByteMaxVector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    ByteMaxShuffle.class, byte.class, VLENGTH,\n+                    ByteMaxVector.class, byte.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static ByteMaxVector toBitsVectorHelper(ByteMaxShuffle s) {\n+            return (ByteMaxVector) ByteMaxVector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -823,6 +841,21 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n@@ -834,7 +867,51 @@\n-            ByteMaxShuffle s = (ByteMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public ByteMaxShuffle wrapIndexes() {\n+            ByteMaxVector v = toBitsVector();\n+            ByteVector.ByteSpecies species = ByteMaxVector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Byte> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Byte> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static byte[] prepare(int[] indices, int offset) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static byte[] prepare(IntUnaryOperator f) {\n+            byte[] a = new byte[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (byte)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(byte[] indices) {\n+            int length = indices.length;\n+            for (byte si : indices) {\n+                if (si >= (byte)length || si < (byte)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -842,1 +919,1 @@\n-            return new ByteMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":116,"deletions":39,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1074,1 +1074,1 @@\n-   \/**\n+    \/**\n@@ -2495,2 +2495,1 @@\n-    final\n-    VectorShuffle<Byte> toShuffleTemplate(Class<?> shuffleType) {\n+    final VectorShuffle<Byte> toShuffleTemplate(Class<?> shuffleType) {\n@@ -2498,1 +2497,1 @@\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n@@ -2505,0 +2504,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Double128Shuffle)VectorSupport.shuffleIota(ETYPE, Double128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double128Shuffle)VectorSupport.shuffleIota(ETYPE, Double128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Double128Shuffle shuffleFromBytes(byte[] reorder) { return new Double128Shuffle(reorder); }\n+        Long128Vector iota = Double128Shuffle.IOTA.toBitsVector();\n+        LongVector.LongSpecies species = Long128Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Long128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Long128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toFPShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Double128Shuffle shuffleFromArray(int[] indexes, int i) { return new Double128Shuffle(indexes, i); }\n+    Double128Shuffle shuffleFromArray(int[] indices, int i) { return new Double128Shuffle(indices, i); }\n@@ -347,0 +353,1 @@\n+    @Override\n@@ -348,2 +355,4 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double128Shuffle.class); \/\/ specialize\n+    public Double128Shuffle toShuffle() {\n+        return (Double128Shuffle) castShape(Long128Vector.VSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .toFPShuffle();\n@@ -774,1 +783,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -776,2 +785,4 @@\n-        Double128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double128Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -780,2 +791,2 @@\n-        public Double128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -784,2 +795,2 @@\n-        public Double128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -788,2 +799,2 @@\n-        public Double128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -793,0 +804,1 @@\n+        @ForceInline\n@@ -800,2 +812,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -807,3 +819,11 @@\n-        public Double128Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double128Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+        Long128Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Double128Shuffle.class, long.class, VLENGTH,\n+                    Long128Vector.class, long.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Long128Vector toBitsVectorHelper(Double128Shuffle s) {\n+            return (Long128Vector) Long128Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -814,6 +834,14 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(length() * Integer.SIZE));\n+            Vector<Long> v = toBitsVector();\n+            v.convertShape(VectorOperators.L2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n@@ -825,7 +853,53 @@\n-            Double128Shuffle s = (Double128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast(Long128Vector.VSPECIES))\n+                    .toFPShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Double128Shuffle wrapIndexes() {\n+            Long128Vector v = toBitsVector();\n+            LongVector.LongSpecies species = Long128Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toFPShuffle();\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -833,1 +907,1 @@\n-            return new Double128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":116,"deletions":42,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Double256Shuffle)VectorSupport.shuffleIota(ETYPE, Double256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double256Shuffle)VectorSupport.shuffleIota(ETYPE, Double256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Double256Shuffle shuffleFromBytes(byte[] reorder) { return new Double256Shuffle(reorder); }\n+        Long256Vector iota = Double256Shuffle.IOTA.toBitsVector();\n+        LongVector.LongSpecies species = Long256Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Long256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Long256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toFPShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Double256Shuffle shuffleFromArray(int[] indexes, int i) { return new Double256Shuffle(indexes, i); }\n+    Double256Shuffle shuffleFromArray(int[] indices, int i) { return new Double256Shuffle(indices, i); }\n@@ -347,0 +353,1 @@\n+    @Override\n@@ -348,2 +355,4 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double256Shuffle.class); \/\/ specialize\n+    public Double256Shuffle toShuffle() {\n+        return (Double256Shuffle) castShape(Long256Vector.VSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .toFPShuffle();\n@@ -778,1 +787,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -780,2 +789,4 @@\n-        Double256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double256Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -784,2 +795,2 @@\n-        public Double256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -788,2 +799,2 @@\n-        public Double256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -792,2 +803,2 @@\n-        public Double256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -797,0 +808,1 @@\n+        @ForceInline\n@@ -804,2 +816,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -811,3 +823,11 @@\n-        public Double256Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double256Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+        Long256Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Double256Shuffle.class, long.class, VLENGTH,\n+                    Long256Vector.class, long.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Long256Vector toBitsVectorHelper(Double256Shuffle s) {\n+            return (Long256Vector) Long256Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -818,6 +838,14 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(length() * Integer.SIZE));\n+            Vector<Long> v = toBitsVector();\n+            v.convertShape(VectorOperators.L2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n@@ -829,7 +857,53 @@\n-            Double256Shuffle s = (Double256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast(Long256Vector.VSPECIES))\n+                    .toFPShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Double256Shuffle wrapIndexes() {\n+            Long256Vector v = toBitsVector();\n+            LongVector.LongSpecies species = Long256Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toFPShuffle();\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -837,1 +911,1 @@\n-            return new Double256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":116,"deletions":42,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Double512Shuffle)VectorSupport.shuffleIota(ETYPE, Double512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double512Shuffle)VectorSupport.shuffleIota(ETYPE, Double512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Double512Shuffle shuffleFromBytes(byte[] reorder) { return new Double512Shuffle(reorder); }\n+        Long512Vector iota = Double512Shuffle.IOTA.toBitsVector();\n+        LongVector.LongSpecies species = Long512Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Long512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Long512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toFPShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Double512Shuffle shuffleFromArray(int[] indexes, int i) { return new Double512Shuffle(indexes, i); }\n+    Double512Shuffle shuffleFromArray(int[] indices, int i) { return new Double512Shuffle(indices, i); }\n@@ -347,0 +353,1 @@\n+    @Override\n@@ -348,2 +355,4 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double512Shuffle.class); \/\/ specialize\n+    public Double512Shuffle toShuffle() {\n+        return (Double512Shuffle) castShape(Long512Vector.VSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .toFPShuffle();\n@@ -786,1 +795,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -788,2 +797,4 @@\n-        Double512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double512Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -792,2 +803,2 @@\n-        public Double512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -796,2 +807,2 @@\n-        public Double512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -800,2 +811,2 @@\n-        public Double512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -805,0 +816,1 @@\n+        @ForceInline\n@@ -812,2 +824,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -819,3 +831,11 @@\n-        public Double512Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double512Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+        Long512Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Double512Shuffle.class, long.class, VLENGTH,\n+                    Long512Vector.class, long.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Long512Vector toBitsVectorHelper(Double512Shuffle s) {\n+            return (Long512Vector) Long512Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -826,6 +846,14 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(length() * Integer.SIZE));\n+            Vector<Long> v = toBitsVector();\n+            v.convertShape(VectorOperators.L2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n@@ -837,7 +865,53 @@\n-            Double512Shuffle s = (Double512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast(Long512Vector.VSPECIES))\n+                    .toFPShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Double512Shuffle wrapIndexes() {\n+            Long512Vector v = toBitsVector();\n+            LongVector.LongSpecies species = Long512Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toFPShuffle();\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -845,1 +919,1 @@\n-            return new Double512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":116,"deletions":42,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Double64Shuffle)VectorSupport.shuffleIota(ETYPE, Double64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Double64Shuffle)VectorSupport.shuffleIota(ETYPE, Double64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Double64Shuffle shuffleFromBytes(byte[] reorder) { return new Double64Shuffle(reorder); }\n+        Long64Vector iota = Double64Shuffle.IOTA.toBitsVector();\n+        LongVector.LongSpecies species = Long64Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Long64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Long64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toFPShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Double64Shuffle shuffleFromArray(int[] indexes, int i) { return new Double64Shuffle(indexes, i); }\n+    Double64Shuffle shuffleFromArray(int[] indices, int i) { return new Double64Shuffle(indices, i); }\n@@ -347,0 +353,1 @@\n+    @Override\n@@ -348,2 +355,4 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(Double64Shuffle.class); \/\/ specialize\n+    public Double64Shuffle toShuffle() {\n+        return (Double64Shuffle) castShape(Long64Vector.VSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .toFPShuffle();\n@@ -772,1 +781,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -774,2 +783,4 @@\n-        Double64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double64Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -778,2 +789,2 @@\n-        public Double64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Double64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -782,2 +793,2 @@\n-        public Double64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Double64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -786,2 +797,2 @@\n-        public Double64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -791,0 +802,1 @@\n+        @ForceInline\n@@ -798,2 +810,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -805,3 +817,11 @@\n-        public Double64Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Double64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Double64Vector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+        Long64Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Double64Shuffle.class, long.class, VLENGTH,\n+                    Long64Vector.class, long.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Long64Vector toBitsVectorHelper(Double64Shuffle s) {\n+            return (Long64Vector) Long64Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -812,6 +832,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            a[offset] = laneSource(0);\n@@ -823,7 +845,53 @@\n-            Double64Shuffle s = (Double64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast(Long64Vector.VSPECIES))\n+                    .toFPShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Double64Shuffle wrapIndexes() {\n+            Long64Vector v = toBitsVector();\n+            LongVector.LongSpecies species = Long64Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toFPShuffle();\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -831,1 +899,1 @@\n-            return new Double64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":110,"deletions":42,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (DoubleMaxShuffle)VectorSupport.shuffleIota(ETYPE, DoubleMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    DoubleMaxShuffle shuffleFromBytes(byte[] reorder) { return new DoubleMaxShuffle(reorder); }\n+        LongMaxVector iota = DoubleMaxShuffle.IOTA.toBitsVector();\n+        LongVector.LongSpecies species = LongMaxVector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        LongMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            LongMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toFPShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    DoubleMaxShuffle shuffleFromArray(int[] indexes, int i) { return new DoubleMaxShuffle(indexes, i); }\n+    DoubleMaxShuffle shuffleFromArray(int[] indices, int i) { return new DoubleMaxShuffle(indices, i); }\n@@ -347,0 +353,1 @@\n+    @Override\n@@ -348,2 +355,4 @@\n-    public VectorShuffle<Double> toShuffle() {\n-        return super.toShuffleTemplate(DoubleMaxShuffle.class); \/\/ specialize\n+    public DoubleMaxShuffle toShuffle() {\n+        return (DoubleMaxShuffle) castShape(LongMaxVector.VSPECIES, 0)\n+                .reinterpretAsLongs()\n+                .toFPShuffle();\n@@ -771,1 +780,1 @@\n-        static final Class<Double> ETYPE = double.class; \/\/ used by the JVM\n+        static final Class<Long> ETYPE = long.class; \/\/ used by the JVM\n@@ -773,2 +782,4 @@\n-        DoubleMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        DoubleMaxShuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -777,2 +788,2 @@\n-        public DoubleMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        DoubleMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -781,2 +792,2 @@\n-        public DoubleMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        DoubleMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -785,2 +796,2 @@\n-        public DoubleMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -790,0 +801,1 @@\n+        @ForceInline\n@@ -797,2 +809,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -804,3 +816,11 @@\n-        public DoubleMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, DoubleMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((DoubleMaxVector)(((AbstractShuffle<Double>)(s)).toVectorTemplate())));\n+        LongMaxVector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    DoubleMaxShuffle.class, long.class, VLENGTH,\n+                    LongMaxVector.class, long.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static LongMaxVector toBitsVectorHelper(DoubleMaxShuffle s) {\n+            return (LongMaxVector) LongMaxVector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -811,6 +831,14 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(length() * Integer.SIZE));\n+            Vector<Long> v = toBitsVector();\n+            v.convertShape(VectorOperators.L2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n@@ -822,7 +850,53 @@\n-            DoubleMaxShuffle s = (DoubleMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast(LongMaxVector.VSPECIES))\n+                    .toFPShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public DoubleMaxShuffle wrapIndexes() {\n+            LongMaxVector v = toBitsVector();\n+            LongVector.LongSpecies species = LongMaxVector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toFPShuffle();\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -830,1 +904,1 @@\n-            return new DoubleMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":116,"deletions":42,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -956,1 +956,1 @@\n-   \/**\n+    \/**\n@@ -2324,10 +2324,0 @@\n-    @ForceInline\n-    private final\n-    VectorShuffle<Double> toShuffle0(DoubleSpecies dsp) {\n-        double[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(dsp, sa, 0);\n-    }\n@@ -2335,11 +2325,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    VectorShuffle<Double> toShuffleTemplate(Class<?> shuffleType) {\n-        DoubleSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), double.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     DoubleVector::toShuffle0);\n-    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Float128Shuffle)VectorSupport.shuffleIota(ETYPE, Float128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float128Shuffle)VectorSupport.shuffleIota(ETYPE, Float128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Float128Shuffle shuffleFromBytes(byte[] reorder) { return new Float128Shuffle(reorder); }\n+        Int128Vector iota = Float128Shuffle.IOTA.toBitsVector();\n+        IntVector.IntSpecies species = Int128Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Int128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Int128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toFPShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Float128Shuffle shuffleFromArray(int[] indexes, int i) { return new Float128Shuffle(indexes, i); }\n+    Float128Shuffle shuffleFromArray(int[] indices, int i) { return new Float128Shuffle(indices, i); }\n@@ -347,0 +353,1 @@\n+    @Override\n@@ -348,2 +355,4 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float128Shuffle.class); \/\/ specialize\n+    public Float128Shuffle toShuffle() {\n+        return (Float128Shuffle) castShape(Int128Vector.VSPECIES, 0)\n+                .reinterpretAsInts()\n+                .toFPShuffle();\n@@ -778,1 +787,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -780,2 +789,4 @@\n-        Float128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float128Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -784,2 +795,2 @@\n-        public Float128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -788,2 +799,2 @@\n-        public Float128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -792,2 +803,2 @@\n-        public Float128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -797,0 +808,1 @@\n+        @ForceInline\n@@ -804,2 +816,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -811,3 +823,11 @@\n-        public Float128Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float128Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+        Int128Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Float128Shuffle.class, int.class, VLENGTH,\n+                    Int128Vector.class, int.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Int128Vector toBitsVectorHelper(Float128Shuffle s) {\n+            return (Int128Vector) Int128Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -818,6 +838,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -829,7 +851,53 @@\n-            Float128Shuffle s = (Float128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast(Int128Vector.VSPECIES))\n+                    .toFPShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Float128Shuffle wrapIndexes() {\n+            Int128Vector v = toBitsVector();\n+            IntVector.IntSpecies species = Int128Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toFPShuffle();\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -837,1 +905,1 @@\n-            return new Float128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":110,"deletions":42,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Float256Shuffle)VectorSupport.shuffleIota(ETYPE, Float256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float256Shuffle)VectorSupport.shuffleIota(ETYPE, Float256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Float256Shuffle shuffleFromBytes(byte[] reorder) { return new Float256Shuffle(reorder); }\n+        Int256Vector iota = Float256Shuffle.IOTA.toBitsVector();\n+        IntVector.IntSpecies species = Int256Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Int256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Int256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toFPShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Float256Shuffle shuffleFromArray(int[] indexes, int i) { return new Float256Shuffle(indexes, i); }\n+    Float256Shuffle shuffleFromArray(int[] indices, int i) { return new Float256Shuffle(indices, i); }\n@@ -347,0 +353,1 @@\n+    @Override\n@@ -348,2 +355,4 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float256Shuffle.class); \/\/ specialize\n+    public Float256Shuffle toShuffle() {\n+        return (Float256Shuffle) castShape(Int256Vector.VSPECIES, 0)\n+                .reinterpretAsInts()\n+                .toFPShuffle();\n@@ -786,1 +795,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -788,2 +797,4 @@\n-        Float256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float256Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -792,2 +803,2 @@\n-        public Float256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -796,2 +807,2 @@\n-        public Float256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -800,2 +811,2 @@\n-        public Float256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -805,0 +816,1 @@\n+        @ForceInline\n@@ -812,2 +824,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -819,3 +831,11 @@\n-        public Float256Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float256Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+        Int256Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Float256Shuffle.class, int.class, VLENGTH,\n+                    Int256Vector.class, int.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Int256Vector toBitsVectorHelper(Float256Shuffle s) {\n+            return (Int256Vector) Int256Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -826,6 +846,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -837,7 +859,53 @@\n-            Float256Shuffle s = (Float256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast(Int256Vector.VSPECIES))\n+                    .toFPShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Float256Shuffle wrapIndexes() {\n+            Int256Vector v = toBitsVector();\n+            IntVector.IntSpecies species = Int256Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toFPShuffle();\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -845,1 +913,1 @@\n-            return new Float256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":110,"deletions":42,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Float512Shuffle)VectorSupport.shuffleIota(ETYPE, Float512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float512Shuffle)VectorSupport.shuffleIota(ETYPE, Float512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Float512Shuffle shuffleFromBytes(byte[] reorder) { return new Float512Shuffle(reorder); }\n+        Int512Vector iota = Float512Shuffle.IOTA.toBitsVector();\n+        IntVector.IntSpecies species = Int512Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Int512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Int512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toFPShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Float512Shuffle shuffleFromArray(int[] indexes, int i) { return new Float512Shuffle(indexes, i); }\n+    Float512Shuffle shuffleFromArray(int[] indices, int i) { return new Float512Shuffle(indices, i); }\n@@ -347,0 +353,1 @@\n+    @Override\n@@ -348,2 +355,4 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float512Shuffle.class); \/\/ specialize\n+    public Float512Shuffle toShuffle() {\n+        return (Float512Shuffle) castShape(Int512Vector.VSPECIES, 0)\n+                .reinterpretAsInts()\n+                .toFPShuffle();\n@@ -802,1 +811,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -804,2 +813,4 @@\n-        Float512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float512Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -808,2 +819,2 @@\n-        public Float512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -812,2 +823,2 @@\n-        public Float512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -816,2 +827,2 @@\n-        public Float512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -821,0 +832,1 @@\n+        @ForceInline\n@@ -828,2 +840,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -835,3 +847,11 @@\n-        public Float512Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float512Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+        Int512Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Float512Shuffle.class, int.class, VLENGTH,\n+                    Int512Vector.class, int.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Int512Vector toBitsVectorHelper(Float512Shuffle s) {\n+            return (Int512Vector) Int512Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -842,6 +862,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -853,7 +875,53 @@\n-            Float512Shuffle s = (Float512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast(Int512Vector.VSPECIES))\n+                    .toFPShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Float512Shuffle wrapIndexes() {\n+            Int512Vector v = toBitsVector();\n+            IntVector.IntSpecies species = Int512Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toFPShuffle();\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -861,1 +929,1 @@\n-            return new Float512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":110,"deletions":42,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Float64Shuffle)VectorSupport.shuffleIota(ETYPE, Float64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Float64Shuffle)VectorSupport.shuffleIota(ETYPE, Float64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Float64Shuffle shuffleFromBytes(byte[] reorder) { return new Float64Shuffle(reorder); }\n+        Int64Vector iota = Float64Shuffle.IOTA.toBitsVector();\n+        IntVector.IntSpecies species = Int64Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Int64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Int64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toFPShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Float64Shuffle shuffleFromArray(int[] indexes, int i) { return new Float64Shuffle(indexes, i); }\n+    Float64Shuffle shuffleFromArray(int[] indices, int i) { return new Float64Shuffle(indices, i); }\n@@ -347,0 +353,1 @@\n+    @Override\n@@ -348,2 +355,4 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(Float64Shuffle.class); \/\/ specialize\n+    public Float64Shuffle toShuffle() {\n+        return (Float64Shuffle) castShape(Int64Vector.VSPECIES, 0)\n+                .reinterpretAsInts()\n+                .toFPShuffle();\n@@ -774,1 +783,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -776,2 +785,4 @@\n-        Float64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float64Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -780,2 +791,2 @@\n-        public Float64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Float64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -784,2 +795,2 @@\n-        public Float64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Float64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -788,2 +799,2 @@\n-        public Float64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -793,0 +804,1 @@\n+        @ForceInline\n@@ -800,2 +812,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -807,3 +819,11 @@\n-        public Float64Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Float64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Float64Vector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+        Int64Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Float64Shuffle.class, int.class, VLENGTH,\n+                    Int64Vector.class, int.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Int64Vector toBitsVectorHelper(Float64Shuffle s) {\n+            return (Int64Vector) Int64Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -814,6 +834,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -825,7 +847,53 @@\n-            Float64Shuffle s = (Float64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast(Int64Vector.VSPECIES))\n+                    .toFPShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Float64Shuffle wrapIndexes() {\n+            Int64Vector v = toBitsVector();\n+            IntVector.IntSpecies species = Int64Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toFPShuffle();\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -833,1 +901,1 @@\n-            return new Float64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":110,"deletions":42,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (FloatMaxShuffle)VectorSupport.shuffleIota(ETYPE, FloatMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    FloatMaxShuffle shuffleFromBytes(byte[] reorder) { return new FloatMaxShuffle(reorder); }\n+        IntMaxVector iota = FloatMaxShuffle.IOTA.toBitsVector();\n+        IntVector.IntSpecies species = IntMaxVector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        IntMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            IntMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toFPShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    FloatMaxShuffle shuffleFromArray(int[] indexes, int i) { return new FloatMaxShuffle(indexes, i); }\n+    FloatMaxShuffle shuffleFromArray(int[] indices, int i) { return new FloatMaxShuffle(indices, i); }\n@@ -347,0 +353,1 @@\n+    @Override\n@@ -348,2 +355,4 @@\n-    public VectorShuffle<Float> toShuffle() {\n-        return super.toShuffleTemplate(FloatMaxShuffle.class); \/\/ specialize\n+    public FloatMaxShuffle toShuffle() {\n+        return (FloatMaxShuffle) castShape(IntMaxVector.VSPECIES, 0)\n+                .reinterpretAsInts()\n+                .toFPShuffle();\n@@ -771,1 +780,1 @@\n-        static final Class<Float> ETYPE = float.class; \/\/ used by the JVM\n+        static final Class<Integer> ETYPE = int.class; \/\/ used by the JVM\n@@ -773,2 +782,4 @@\n-        FloatMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        FloatMaxShuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -777,2 +788,2 @@\n-        public FloatMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        FloatMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -781,2 +792,2 @@\n-        public FloatMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        FloatMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -785,2 +796,2 @@\n-        public FloatMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -790,0 +801,1 @@\n+        @ForceInline\n@@ -797,2 +809,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -804,3 +816,11 @@\n-        public FloatMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, FloatMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((FloatMaxVector)(((AbstractShuffle<Float>)(s)).toVectorTemplate())));\n+        IntMaxVector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    FloatMaxShuffle.class, int.class, VLENGTH,\n+                    IntMaxVector.class, int.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static IntMaxVector toBitsVectorHelper(FloatMaxShuffle s) {\n+            return (IntMaxVector) IntMaxVector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -811,6 +831,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -822,7 +844,53 @@\n-            FloatMaxShuffle s = (FloatMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast(IntMaxVector.VSPECIES))\n+                    .toFPShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public FloatMaxShuffle wrapIndexes() {\n+            IntMaxVector v = toBitsVector();\n+            IntVector.IntSpecies species = IntMaxVector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toFPShuffle();\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -830,1 +898,1 @@\n-            return new FloatMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":110,"deletions":42,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -956,1 +956,1 @@\n-   \/**\n+    \/**\n@@ -2336,10 +2336,0 @@\n-    @ForceInline\n-    private final\n-    VectorShuffle<Float> toShuffle0(FloatSpecies dsp) {\n-        float[] a = toArray();\n-        int[] sa = new int[a.length];\n-        for (int i = 0; i < a.length; i++) {\n-            sa[i] = (int) a[i];\n-        }\n-        return VectorShuffle.fromArray(dsp, sa, 0);\n-    }\n@@ -2347,11 +2337,0 @@\n-    \/*package-private*\/\n-    @ForceInline\n-    final\n-    VectorShuffle<Float> toShuffleTemplate(Class<?> shuffleType) {\n-        FloatSpecies vsp = vspecies();\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n-                                     getClass(), float.class, length(),\n-                                     shuffleType, byte.class, length(),\n-                                     this, vsp,\n-                                     FloatVector::toShuffle0);\n-    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":2,"deletions":23,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Int128Shuffle)VectorSupport.shuffleIota(ETYPE, Int128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int128Shuffle)VectorSupport.shuffleIota(ETYPE, Int128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Int128Shuffle shuffleFromBytes(byte[] reorder) { return new Int128Shuffle(reorder); }\n+        Int128Vector iota = Int128Shuffle.IOTA.toBitsVector();\n+        IntVector.IntSpecies species = Int128Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Int128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Int128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Int128Shuffle shuffleFromArray(int[] indexes, int i) { return new Int128Shuffle(indexes, i); }\n+    Int128Shuffle shuffleFromArray(int[] indices, int i) { return new Int128Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,7 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int128Shuffle.class); \/\/ specialize\n+    public Int128Shuffle toShuffle() {\n+        return (Int128Shuffle) super.toShuffleTemplate(Int128Shuffle.class); \/\/ specialize\n+    }\n+    @Override\n+    @ForceInline\n+    Float128Vector.Float128Shuffle toFPShuffle() {\n+        return (Float128Vector.Float128Shuffle) super.toFPShuffleTemplate(Float128Vector.Float128Shuffle.class, Float128Vector.VSPECIES);\n@@ -791,2 +803,4 @@\n-        Int128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int128Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -795,2 +809,2 @@\n-        public Int128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -799,2 +813,2 @@\n-        public Int128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -803,2 +817,2 @@\n-        public Int128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -808,0 +822,1 @@\n+        @ForceInline\n@@ -815,2 +830,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -822,3 +837,11 @@\n-        public Int128Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int128Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+        Int128Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Int128Shuffle.class, int.class, VLENGTH,\n+                    Int128Vector.class, int.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Int128Vector toBitsVectorHelper(Int128Shuffle s) {\n+            return (Int128Vector) Int128Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -829,6 +852,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -840,7 +865,51 @@\n-            Int128Shuffle s = (Int128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Int128Shuffle wrapIndexes() {\n+            Int128Vector v = toBitsVector();\n+            IntVector.IntSpecies species = Int128Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -848,1 +917,1 @@\n-            return new Int128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":110,"deletions":41,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Int256Shuffle)VectorSupport.shuffleIota(ETYPE, Int256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int256Shuffle)VectorSupport.shuffleIota(ETYPE, Int256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Int256Shuffle shuffleFromBytes(byte[] reorder) { return new Int256Shuffle(reorder); }\n+        Int256Vector iota = Int256Shuffle.IOTA.toBitsVector();\n+        IntVector.IntSpecies species = Int256Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Int256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Int256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Int256Shuffle shuffleFromArray(int[] indexes, int i) { return new Int256Shuffle(indexes, i); }\n+    Int256Shuffle shuffleFromArray(int[] indices, int i) { return new Int256Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,7 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int256Shuffle.class); \/\/ specialize\n+    public Int256Shuffle toShuffle() {\n+        return (Int256Shuffle) super.toShuffleTemplate(Int256Shuffle.class); \/\/ specialize\n+    }\n+    @Override\n+    @ForceInline\n+    Float256Vector.Float256Shuffle toFPShuffle() {\n+        return (Float256Vector.Float256Shuffle) super.toFPShuffleTemplate(Float256Vector.Float256Shuffle.class, Float256Vector.VSPECIES);\n@@ -799,2 +811,4 @@\n-        Int256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int256Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -803,2 +817,2 @@\n-        public Int256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -807,2 +821,2 @@\n-        public Int256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -811,2 +825,2 @@\n-        public Int256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -816,0 +830,1 @@\n+        @ForceInline\n@@ -823,2 +838,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -830,3 +845,11 @@\n-        public Int256Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int256Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+        Int256Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Int256Shuffle.class, int.class, VLENGTH,\n+                    Int256Vector.class, int.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Int256Vector toBitsVectorHelper(Int256Shuffle s) {\n+            return (Int256Vector) Int256Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -837,6 +860,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -848,7 +873,51 @@\n-            Int256Shuffle s = (Int256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Int256Shuffle wrapIndexes() {\n+            Int256Vector v = toBitsVector();\n+            IntVector.IntSpecies species = Int256Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -856,1 +925,1 @@\n-            return new Int256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":110,"deletions":41,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Int512Shuffle)VectorSupport.shuffleIota(ETYPE, Int512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int512Shuffle)VectorSupport.shuffleIota(ETYPE, Int512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Int512Shuffle shuffleFromBytes(byte[] reorder) { return new Int512Shuffle(reorder); }\n+        Int512Vector iota = Int512Shuffle.IOTA.toBitsVector();\n+        IntVector.IntSpecies species = Int512Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Int512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Int512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Int512Shuffle shuffleFromArray(int[] indexes, int i) { return new Int512Shuffle(indexes, i); }\n+    Int512Shuffle shuffleFromArray(int[] indices, int i) { return new Int512Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,7 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int512Shuffle.class); \/\/ specialize\n+    public Int512Shuffle toShuffle() {\n+        return (Int512Shuffle) super.toShuffleTemplate(Int512Shuffle.class); \/\/ specialize\n+    }\n+    @Override\n+    @ForceInline\n+    Float512Vector.Float512Shuffle toFPShuffle() {\n+        return (Float512Vector.Float512Shuffle) super.toFPShuffleTemplate(Float512Vector.Float512Shuffle.class, Float512Vector.VSPECIES);\n@@ -815,2 +827,4 @@\n-        Int512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int512Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -819,2 +833,2 @@\n-        public Int512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -823,2 +837,2 @@\n-        public Int512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -827,2 +841,2 @@\n-        public Int512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -832,0 +846,1 @@\n+        @ForceInline\n@@ -839,2 +854,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -846,3 +861,11 @@\n-        public Int512Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int512Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+        Int512Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Int512Shuffle.class, int.class, VLENGTH,\n+                    Int512Vector.class, int.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Int512Vector toBitsVectorHelper(Int512Shuffle s) {\n+            return (Int512Vector) Int512Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -853,6 +876,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -864,7 +889,51 @@\n-            Int512Shuffle s = (Int512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Int512Shuffle wrapIndexes() {\n+            Int512Vector v = toBitsVector();\n+            IntVector.IntSpecies species = Int512Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -872,1 +941,1 @@\n-            return new Int512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":110,"deletions":41,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Int64Shuffle)VectorSupport.shuffleIota(ETYPE, Int64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Int64Shuffle)VectorSupport.shuffleIota(ETYPE, Int64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Int64Shuffle shuffleFromBytes(byte[] reorder) { return new Int64Shuffle(reorder); }\n+        Int64Vector iota = Int64Shuffle.IOTA.toBitsVector();\n+        IntVector.IntSpecies species = Int64Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Int64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Int64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Int64Shuffle shuffleFromArray(int[] indexes, int i) { return new Int64Shuffle(indexes, i); }\n+    Int64Shuffle shuffleFromArray(int[] indices, int i) { return new Int64Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,7 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(Int64Shuffle.class); \/\/ specialize\n+    public Int64Shuffle toShuffle() {\n+        return (Int64Shuffle) super.toShuffleTemplate(Int64Shuffle.class); \/\/ specialize\n+    }\n+    @Override\n+    @ForceInline\n+    Float64Vector.Float64Shuffle toFPShuffle() {\n+        return (Float64Vector.Float64Shuffle) super.toFPShuffleTemplate(Float64Vector.Float64Shuffle.class, Float64Vector.VSPECIES);\n@@ -787,2 +799,4 @@\n-        Int64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int64Shuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -791,2 +805,2 @@\n-        public Int64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Int64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -795,2 +809,2 @@\n-        public Int64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Int64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -799,2 +813,2 @@\n-        public Int64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -804,0 +818,1 @@\n+        @ForceInline\n@@ -811,2 +826,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -818,3 +833,11 @@\n-        public Int64Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Int64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Int64Vector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+        Int64Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Int64Shuffle.class, int.class, VLENGTH,\n+                    Int64Vector.class, int.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Int64Vector toBitsVectorHelper(Int64Shuffle s) {\n+            return (Int64Vector) Int64Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -825,6 +848,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -836,7 +861,51 @@\n-            Int64Shuffle s = (Int64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Int64Shuffle wrapIndexes() {\n+            Int64Vector v = toBitsVector();\n+            IntVector.IntSpecies species = Int64Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -844,1 +913,1 @@\n-            return new Int64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":110,"deletions":41,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (IntMaxShuffle)VectorSupport.shuffleIota(ETYPE, IntMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    IntMaxShuffle shuffleFromBytes(byte[] reorder) { return new IntMaxShuffle(reorder); }\n+        IntMaxVector iota = IntMaxShuffle.IOTA.toBitsVector();\n+        IntVector.IntSpecies species = IntMaxVector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        IntMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            IntMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Integer> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    IntMaxShuffle shuffleFromArray(int[] indexes, int i) { return new IntMaxShuffle(indexes, i); }\n+    IntMaxShuffle shuffleFromArray(int[] indices, int i) { return new IntMaxShuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,7 @@\n-    public VectorShuffle<Integer> toShuffle() {\n-        return super.toShuffleTemplate(IntMaxShuffle.class); \/\/ specialize\n+    public IntMaxShuffle toShuffle() {\n+        return (IntMaxShuffle) super.toShuffleTemplate(IntMaxShuffle.class); \/\/ specialize\n+    }\n+    @Override\n+    @ForceInline\n+    FloatMaxVector.FloatMaxShuffle toFPShuffle() {\n+        return (FloatMaxVector.FloatMaxShuffle) super.toFPShuffleTemplate(FloatMaxVector.FloatMaxShuffle.class, FloatMaxVector.VSPECIES);\n@@ -796,2 +808,4 @@\n-        IntMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        IntMaxShuffle(int[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -800,2 +814,2 @@\n-        public IntMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        IntMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -804,2 +818,2 @@\n-        public IntMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        IntMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -808,2 +822,2 @@\n-        public IntMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        int[] indices() {\n+            return (int[])getPayload();\n@@ -813,0 +827,1 @@\n+        @ForceInline\n@@ -820,2 +835,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Integer.MAX_VALUE);\n+            assert(Integer.MIN_VALUE <= -VLENGTH);\n@@ -827,3 +842,11 @@\n-        public IntMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, IntMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((IntMaxVector)(((AbstractShuffle<Integer>)(s)).toVectorTemplate())));\n+        IntMaxVector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    IntMaxShuffle.class, int.class, VLENGTH,\n+                    IntMaxVector.class, int.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static IntMaxVector toBitsVectorHelper(IntMaxShuffle s) {\n+            return (IntMaxVector) IntMaxVector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -834,6 +857,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            toBitsVector().intoArray(a, offset);\n@@ -845,7 +870,51 @@\n-            IntMaxShuffle s = (IntMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public IntMaxShuffle wrapIndexes() {\n+            IntMaxVector v = toBitsVector();\n+            IntVector.IntSpecies species = IntMaxVector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Integer> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Integer> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static int[] prepare(int[] indices, int offset) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static int[] prepare(IntUnaryOperator f) {\n+            int[] a = new int[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (int)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(int[] indices) {\n+            int length = indices.length;\n+            for (int si : indices) {\n+                if (si >= (int)length || si < (int)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -853,1 +922,1 @@\n-            return new IntMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":110,"deletions":41,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1077,1 +1077,1 @@\n-   \/**\n+    \/**\n@@ -2480,2 +2480,1 @@\n-    final\n-    VectorShuffle<Integer> toShuffleTemplate(Class<?> shuffleType) {\n+    final VectorShuffle<Integer> toShuffleTemplate(Class<?> shuffleType) {\n@@ -2483,1 +2482,1 @@\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n@@ -2485,1 +2484,1 @@\n-                                     shuffleType, byte.class, length(),\n+                                     shuffleType, int.class, length(),\n@@ -2489,0 +2488,23 @@\n+\n+    abstract VectorShuffle<Float> toFPShuffle();\n+\n+    @ForceInline\n+    private final\n+    VectorShuffle<Float> toFPShuffle0(VectorSpecies<Float> dsp) {\n+        int[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    @ForceInline\n+    final\n+    VectorShuffle<Float> toFPShuffleTemplate(Class<?> shuffleType, FloatVector.FloatSpecies dsp) {\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                                     getClass(), int.class, length(),\n+                                     shuffleType, int.class, length(),\n+                                     this, dsp,\n+                                     IntVector::toFPShuffle0);\n+    }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -141,8 +141,4 @@\n-      if (wrap) {\n-        return (Long128Shuffle)VectorSupport.shuffleIota(ETYPE, Long128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long128Shuffle)VectorSupport.shuffleIota(ETYPE, Long128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -150,3 +146,13 @@\n-    @Override\n-    @ForceInline\n-    Long128Shuffle shuffleFromBytes(byte[] reorder) { return new Long128Shuffle(reorder); }\n+        Long128Vector iota = Long128Shuffle.IOTA.toBitsVector();\n+        LongVector.LongSpecies species = Long128Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Long128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Long128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -156,1 +162,1 @@\n-    Long128Shuffle shuffleFromArray(int[] indexes, int i) { return new Long128Shuffle(indexes, i); }\n+    Long128Shuffle shuffleFromArray(int[] indices, int i) { return new Long128Shuffle(indices, i); }\n@@ -355,0 +361,1 @@\n+    @Override\n@@ -356,2 +363,7 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long128Shuffle.class); \/\/ specialize\n+    public Long128Shuffle toShuffle() {\n+        return (Long128Shuffle) super.toShuffleTemplate(Long128Shuffle.class); \/\/ specialize\n+    }\n+    @Override\n+    @ForceInline\n+    Double128Vector.Double128Shuffle toFPShuffle() {\n+        return (Double128Vector.Double128Shuffle) super.toFPShuffleTemplate(Double128Vector.Double128Shuffle.class, Double128Vector.VSPECIES);\n@@ -777,2 +789,4 @@\n-        Long128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long128Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -781,2 +795,2 @@\n-        public Long128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -785,2 +799,2 @@\n-        public Long128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -789,2 +803,2 @@\n-        public Long128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -794,0 +808,1 @@\n+        @ForceInline\n@@ -801,2 +816,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -808,3 +823,11 @@\n-        public Long128Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long128Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+        Long128Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Long128Shuffle.class, long.class, VLENGTH,\n+                    Long128Vector.class, long.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Long128Vector toBitsVectorHelper(Long128Shuffle s) {\n+            return (Long128Vector) Long128Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -815,6 +838,14 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(length() * Integer.SIZE));\n+            Vector<Long> v = toBitsVector();\n+            v.convertShape(VectorOperators.L2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n@@ -826,7 +857,51 @@\n-            Long128Shuffle s = (Long128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Long128Shuffle wrapIndexes() {\n+            Long128Vector v = toBitsVector();\n+            LongVector.LongSpecies species = Long128Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -834,1 +909,1 @@\n-            return new Long128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":116,"deletions":41,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -141,8 +141,4 @@\n-      if (wrap) {\n-        return (Long256Shuffle)VectorSupport.shuffleIota(ETYPE, Long256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long256Shuffle)VectorSupport.shuffleIota(ETYPE, Long256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -150,3 +146,13 @@\n-    @Override\n-    @ForceInline\n-    Long256Shuffle shuffleFromBytes(byte[] reorder) { return new Long256Shuffle(reorder); }\n+        Long256Vector iota = Long256Shuffle.IOTA.toBitsVector();\n+        LongVector.LongSpecies species = Long256Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Long256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Long256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -156,1 +162,1 @@\n-    Long256Shuffle shuffleFromArray(int[] indexes, int i) { return new Long256Shuffle(indexes, i); }\n+    Long256Shuffle shuffleFromArray(int[] indices, int i) { return new Long256Shuffle(indices, i); }\n@@ -355,0 +361,1 @@\n+    @Override\n@@ -356,2 +363,7 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long256Shuffle.class); \/\/ specialize\n+    public Long256Shuffle toShuffle() {\n+        return (Long256Shuffle) super.toShuffleTemplate(Long256Shuffle.class); \/\/ specialize\n+    }\n+    @Override\n+    @ForceInline\n+    Double256Vector.Double256Shuffle toFPShuffle() {\n+        return (Double256Vector.Double256Shuffle) super.toFPShuffleTemplate(Double256Vector.Double256Shuffle.class, Double256Vector.VSPECIES);\n@@ -781,2 +793,4 @@\n-        Long256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long256Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -785,2 +799,2 @@\n-        public Long256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -789,2 +803,2 @@\n-        public Long256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -793,2 +807,2 @@\n-        public Long256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -798,0 +812,1 @@\n+        @ForceInline\n@@ -805,2 +820,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -812,3 +827,11 @@\n-        public Long256Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long256Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+        Long256Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Long256Shuffle.class, long.class, VLENGTH,\n+                    Long256Vector.class, long.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Long256Vector toBitsVectorHelper(Long256Shuffle s) {\n+            return (Long256Vector) Long256Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -819,6 +842,14 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(length() * Integer.SIZE));\n+            Vector<Long> v = toBitsVector();\n+            v.convertShape(VectorOperators.L2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n@@ -830,7 +861,51 @@\n-            Long256Shuffle s = (Long256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Long256Shuffle wrapIndexes() {\n+            Long256Vector v = toBitsVector();\n+            LongVector.LongSpecies species = Long256Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -838,1 +913,1 @@\n-            return new Long256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":116,"deletions":41,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -141,8 +141,4 @@\n-      if (wrap) {\n-        return (Long512Shuffle)VectorSupport.shuffleIota(ETYPE, Long512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long512Shuffle)VectorSupport.shuffleIota(ETYPE, Long512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -150,3 +146,13 @@\n-    @Override\n-    @ForceInline\n-    Long512Shuffle shuffleFromBytes(byte[] reorder) { return new Long512Shuffle(reorder); }\n+        Long512Vector iota = Long512Shuffle.IOTA.toBitsVector();\n+        LongVector.LongSpecies species = Long512Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Long512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Long512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -156,1 +162,1 @@\n-    Long512Shuffle shuffleFromArray(int[] indexes, int i) { return new Long512Shuffle(indexes, i); }\n+    Long512Shuffle shuffleFromArray(int[] indices, int i) { return new Long512Shuffle(indices, i); }\n@@ -355,0 +361,1 @@\n+    @Override\n@@ -356,2 +363,7 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long512Shuffle.class); \/\/ specialize\n+    public Long512Shuffle toShuffle() {\n+        return (Long512Shuffle) super.toShuffleTemplate(Long512Shuffle.class); \/\/ specialize\n+    }\n+    @Override\n+    @ForceInline\n+    Double512Vector.Double512Shuffle toFPShuffle() {\n+        return (Double512Vector.Double512Shuffle) super.toFPShuffleTemplate(Double512Vector.Double512Shuffle.class, Double512Vector.VSPECIES);\n@@ -789,2 +801,4 @@\n-        Long512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long512Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -793,2 +807,2 @@\n-        public Long512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -797,2 +811,2 @@\n-        public Long512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -801,2 +815,2 @@\n-        public Long512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -806,0 +820,1 @@\n+        @ForceInline\n@@ -813,2 +828,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -820,3 +835,11 @@\n-        public Long512Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long512Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+        Long512Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Long512Shuffle.class, long.class, VLENGTH,\n+                    Long512Vector.class, long.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Long512Vector toBitsVectorHelper(Long512Shuffle s) {\n+            return (Long512Vector) Long512Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -827,6 +850,14 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(length() * Integer.SIZE));\n+            Vector<Long> v = toBitsVector();\n+            v.convertShape(VectorOperators.L2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n@@ -838,7 +869,51 @@\n-            Long512Shuffle s = (Long512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Long512Shuffle wrapIndexes() {\n+            Long512Vector v = toBitsVector();\n+            LongVector.LongSpecies species = Long512Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -846,1 +921,1 @@\n-            return new Long512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":116,"deletions":41,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -141,8 +141,4 @@\n-      if (wrap) {\n-        return (Long64Shuffle)VectorSupport.shuffleIota(ETYPE, Long64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Long64Shuffle)VectorSupport.shuffleIota(ETYPE, Long64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -150,3 +146,13 @@\n-    @Override\n-    @ForceInline\n-    Long64Shuffle shuffleFromBytes(byte[] reorder) { return new Long64Shuffle(reorder); }\n+        Long64Vector iota = Long64Shuffle.IOTA.toBitsVector();\n+        LongVector.LongSpecies species = Long64Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Long64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Long64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -156,1 +162,1 @@\n-    Long64Shuffle shuffleFromArray(int[] indexes, int i) { return new Long64Shuffle(indexes, i); }\n+    Long64Shuffle shuffleFromArray(int[] indices, int i) { return new Long64Shuffle(indices, i); }\n@@ -355,0 +361,1 @@\n+    @Override\n@@ -356,2 +363,7 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(Long64Shuffle.class); \/\/ specialize\n+    public Long64Shuffle toShuffle() {\n+        return (Long64Shuffle) super.toShuffleTemplate(Long64Shuffle.class); \/\/ specialize\n+    }\n+    @Override\n+    @ForceInline\n+    Double64Vector.Double64Shuffle toFPShuffle() {\n+        return (Double64Vector.Double64Shuffle) super.toFPShuffleTemplate(Double64Vector.Double64Shuffle.class, Double64Vector.VSPECIES);\n@@ -775,2 +787,4 @@\n-        Long64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long64Shuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -779,2 +793,2 @@\n-        public Long64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Long64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -783,2 +797,2 @@\n-        public Long64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Long64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -787,2 +801,2 @@\n-        public Long64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -792,0 +806,1 @@\n+        @ForceInline\n@@ -799,2 +814,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -806,3 +821,11 @@\n-        public Long64Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Long64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Long64Vector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+        Long64Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Long64Shuffle.class, long.class, VLENGTH,\n+                    Long64Vector.class, long.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Long64Vector toBitsVectorHelper(Long64Shuffle s) {\n+            return (Long64Vector) Long64Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -813,6 +836,8 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            a[offset] = laneSource(0);\n@@ -824,7 +849,51 @@\n-            Long64Shuffle s = (Long64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Long64Shuffle wrapIndexes() {\n+            Long64Vector v = toBitsVector();\n+            LongVector.LongSpecies species = Long64Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -832,1 +901,1 @@\n-            return new Long64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":110,"deletions":41,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -141,8 +141,4 @@\n-      if (wrap) {\n-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (LongMaxShuffle)VectorSupport.shuffleIota(ETYPE, LongMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -150,3 +146,13 @@\n-    @Override\n-    @ForceInline\n-    LongMaxShuffle shuffleFromBytes(byte[] reorder) { return new LongMaxShuffle(reorder); }\n+        LongMaxVector iota = LongMaxShuffle.IOTA.toBitsVector();\n+        LongVector.LongSpecies species = LongMaxVector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        LongMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            LongMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Long> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -156,1 +162,1 @@\n-    LongMaxShuffle shuffleFromArray(int[] indexes, int i) { return new LongMaxShuffle(indexes, i); }\n+    LongMaxShuffle shuffleFromArray(int[] indices, int i) { return new LongMaxShuffle(indices, i); }\n@@ -355,0 +361,1 @@\n+    @Override\n@@ -356,2 +363,7 @@\n-    public VectorShuffle<Long> toShuffle() {\n-        return super.toShuffleTemplate(LongMaxShuffle.class); \/\/ specialize\n+    public LongMaxShuffle toShuffle() {\n+        return (LongMaxShuffle) super.toShuffleTemplate(LongMaxShuffle.class); \/\/ specialize\n+    }\n+    @Override\n+    @ForceInline\n+    DoubleMaxVector.DoubleMaxShuffle toFPShuffle() {\n+        return (DoubleMaxVector.DoubleMaxShuffle) super.toFPShuffleTemplate(DoubleMaxVector.DoubleMaxShuffle.class, DoubleMaxVector.VSPECIES);\n@@ -775,2 +787,4 @@\n-        LongMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        LongMaxShuffle(long[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -779,2 +793,2 @@\n-        public LongMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        LongMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -783,2 +797,2 @@\n-        public LongMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        LongMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -787,2 +801,2 @@\n-        public LongMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        long[] indices() {\n+            return (long[])getPayload();\n@@ -792,0 +806,1 @@\n+        @ForceInline\n@@ -799,2 +814,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Long.MAX_VALUE);\n+            assert(Long.MIN_VALUE <= -VLENGTH);\n@@ -806,3 +821,11 @@\n-        public LongMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, LongMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((LongMaxVector)(((AbstractShuffle<Long>)(s)).toVectorTemplate())));\n+        LongMaxVector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    LongMaxShuffle.class, long.class, VLENGTH,\n+                    LongMaxVector.class, long.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static LongMaxVector toBitsVectorHelper(LongMaxShuffle s) {\n+            return (LongMaxVector) LongMaxVector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -813,6 +836,14 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(length() * Integer.SIZE));\n+            Vector<Long> v = toBitsVector();\n+            v.convertShape(VectorOperators.L2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n@@ -824,7 +855,51 @@\n-            LongMaxShuffle s = (LongMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public LongMaxShuffle wrapIndexes() {\n+            LongMaxVector v = toBitsVector();\n+            LongVector.LongSpecies species = LongMaxVector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Long> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Long> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static long[] prepare(int[] indices, int offset) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static long[] prepare(IntUnaryOperator f) {\n+            long[] a = new long[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (long)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(long[] indices) {\n+            int length = indices.length;\n+            for (long si : indices) {\n+                if (si >= (long)length || si < (long)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -832,1 +907,1 @@\n-            return new LongMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":116,"deletions":41,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -990,1 +990,1 @@\n-   \/**\n+    \/**\n@@ -2346,2 +2346,1 @@\n-    final\n-    VectorShuffle<Long> toShuffleTemplate(Class<?> shuffleType) {\n+    final VectorShuffle<Long> toShuffleTemplate(Class<?> shuffleType) {\n@@ -2349,1 +2348,1 @@\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n@@ -2351,1 +2350,1 @@\n-                                     shuffleType, byte.class, length(),\n+                                     shuffleType, long.class, length(),\n@@ -2356,0 +2355,23 @@\n+    abstract VectorShuffle<Double> toFPShuffle();\n+\n+    @ForceInline\n+    private final\n+    VectorShuffle<Double> toFPShuffle0(VectorSpecies<Double> dsp) {\n+        long[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    @ForceInline\n+    final\n+    VectorShuffle<Double> toFPShuffleTemplate(Class<?> shuffleType, DoubleVector.DoubleSpecies dsp) {\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                                     getClass(), long.class, length(),\n+                                     shuffleType, long.class, length(),\n+                                     this, dsp,\n+                                     LongVector::toFPShuffle0);\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Short128Shuffle)VectorSupport.shuffleIota(ETYPE, Short128Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short128Shuffle)VectorSupport.shuffleIota(ETYPE, Short128Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Short128Shuffle shuffleFromBytes(byte[] reorder) { return new Short128Shuffle(reorder); }\n+        Short128Vector iota = Short128Shuffle.IOTA.toBitsVector();\n+        ShortVector.ShortSpecies species = Short128Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Short128Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Short128Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Short> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Short128Shuffle shuffleFromArray(int[] indexes, int i) { return new Short128Shuffle(indexes, i); }\n+    Short128Shuffle shuffleFromArray(int[] indices, int i) { return new Short128Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short128Shuffle.class); \/\/ specialize\n+    public Short128Shuffle toShuffle() {\n+        return (Short128Shuffle) super.toShuffleTemplate(Short128Shuffle.class); \/\/ specialize\n@@ -799,2 +806,4 @@\n-        Short128Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short128Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -803,2 +812,2 @@\n-        public Short128Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short128Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -807,2 +816,2 @@\n-        public Short128Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short128Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -811,2 +820,2 @@\n-        public Short128Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -816,0 +825,1 @@\n+        @ForceInline\n@@ -823,2 +833,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -830,3 +840,11 @@\n-        public Short128Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short128Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short128Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+        Short128Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Short128Shuffle.class, short.class, VLENGTH,\n+                    Short128Vector.class, short.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Short128Vector toBitsVectorHelper(Short128Shuffle s) {\n+            return (Short128Vector) Short128Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -837,6 +855,15 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_128;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n@@ -848,7 +875,51 @@\n-            Short128Shuffle s = (Short128Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Short128Shuffle wrapIndexes() {\n+            Short128Vector v = toBitsVector();\n+            ShortVector.ShortSpecies species = Short128Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Short> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Short> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -856,1 +927,1 @@\n-            return new Short128Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":112,"deletions":41,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Short256Shuffle)VectorSupport.shuffleIota(ETYPE, Short256Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short256Shuffle)VectorSupport.shuffleIota(ETYPE, Short256Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Short256Shuffle shuffleFromBytes(byte[] reorder) { return new Short256Shuffle(reorder); }\n+        Short256Vector iota = Short256Shuffle.IOTA.toBitsVector();\n+        ShortVector.ShortSpecies species = Short256Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Short256Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Short256Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Short> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Short256Shuffle shuffleFromArray(int[] indexes, int i) { return new Short256Shuffle(indexes, i); }\n+    Short256Shuffle shuffleFromArray(int[] indices, int i) { return new Short256Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short256Shuffle.class); \/\/ specialize\n+    public Short256Shuffle toShuffle() {\n+        return (Short256Shuffle) super.toShuffleTemplate(Short256Shuffle.class); \/\/ specialize\n@@ -815,2 +822,4 @@\n-        Short256Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short256Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -819,2 +828,2 @@\n-        public Short256Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short256Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -823,2 +832,2 @@\n-        public Short256Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short256Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -827,2 +836,2 @@\n-        public Short256Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -832,0 +841,1 @@\n+        @ForceInline\n@@ -839,2 +849,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -846,3 +856,11 @@\n-        public Short256Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short256Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short256Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+        Short256Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Short256Shuffle.class, short.class, VLENGTH,\n+                    Short256Vector.class, short.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Short256Vector toBitsVectorHelper(Short256Shuffle s) {\n+            return (Short256Vector) Short256Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -853,6 +871,15 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_256;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n@@ -864,7 +891,51 @@\n-            Short256Shuffle s = (Short256Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Short256Shuffle wrapIndexes() {\n+            Short256Vector v = toBitsVector();\n+            ShortVector.ShortSpecies species = Short256Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Short> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Short> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -872,1 +943,1 @@\n-            return new Short256Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":112,"deletions":41,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Short512Shuffle)VectorSupport.shuffleIota(ETYPE, Short512Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short512Shuffle)VectorSupport.shuffleIota(ETYPE, Short512Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Short512Shuffle shuffleFromBytes(byte[] reorder) { return new Short512Shuffle(reorder); }\n+        Short512Vector iota = Short512Shuffle.IOTA.toBitsVector();\n+        ShortVector.ShortSpecies species = Short512Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Short512Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Short512Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Short> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Short512Shuffle shuffleFromArray(int[] indexes, int i) { return new Short512Shuffle(indexes, i); }\n+    Short512Shuffle shuffleFromArray(int[] indices, int i) { return new Short512Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short512Shuffle.class); \/\/ specialize\n+    public Short512Shuffle toShuffle() {\n+        return (Short512Shuffle) super.toShuffleTemplate(Short512Shuffle.class); \/\/ specialize\n@@ -847,2 +854,4 @@\n-        Short512Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short512Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -851,2 +860,2 @@\n-        public Short512Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short512Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -855,2 +864,2 @@\n-        public Short512Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short512Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -859,2 +868,2 @@\n-        public Short512Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -864,0 +873,1 @@\n+        @ForceInline\n@@ -871,2 +881,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -878,3 +888,11 @@\n-        public Short512Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short512Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short512Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+        Short512Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Short512Shuffle.class, short.class, VLENGTH,\n+                    Short512Vector.class, short.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Short512Vector toBitsVectorHelper(Short512Shuffle s) {\n+            return (Short512Vector) Short512Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -885,6 +903,15 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_512;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n@@ -896,7 +923,51 @@\n-            Short512Shuffle s = (Short512Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Short512Shuffle wrapIndexes() {\n+            Short512Vector v = toBitsVector();\n+            ShortVector.ShortSpecies species = Short512Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Short> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Short> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -904,1 +975,1 @@\n-            return new Short512Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":112,"deletions":41,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (Short64Shuffle)VectorSupport.shuffleIota(ETYPE, Short64Shuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (Short64Shuffle)VectorSupport.shuffleIota(ETYPE, Short64Shuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    Short64Shuffle shuffleFromBytes(byte[] reorder) { return new Short64Shuffle(reorder); }\n+        Short64Vector iota = Short64Shuffle.IOTA.toBitsVector();\n+        ShortVector.ShortSpecies species = Short64Vector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        Short64Vector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            Short64Vector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Short> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    Short64Shuffle shuffleFromArray(int[] indexes, int i) { return new Short64Shuffle(indexes, i); }\n+    Short64Shuffle shuffleFromArray(int[] indices, int i) { return new Short64Shuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(Short64Shuffle.class); \/\/ specialize\n+    public Short64Shuffle toShuffle() {\n+        return (Short64Shuffle) super.toShuffleTemplate(Short64Shuffle.class); \/\/ specialize\n@@ -791,2 +798,4 @@\n-        Short64Shuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short64Shuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -795,2 +804,2 @@\n-        public Short64Shuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        Short64Shuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -799,2 +808,2 @@\n-        public Short64Shuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        Short64Shuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -803,2 +812,2 @@\n-        public Short64Shuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -808,0 +817,1 @@\n+        @ForceInline\n@@ -815,2 +825,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -822,3 +832,11 @@\n-        public Short64Vector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, Short64Shuffle.class, this, VLENGTH,\n-                                                    (s) -> ((Short64Vector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+        Short64Vector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    Short64Shuffle.class, short.class, VLENGTH,\n+                    Short64Vector.class, short.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static Short64Vector toBitsVectorHelper(Short64Shuffle s) {\n+            return (Short64Vector) Short64Vector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -829,6 +847,15 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_64;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n@@ -840,7 +867,51 @@\n-            Short64Shuffle s = (Short64Shuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public Short64Shuffle wrapIndexes() {\n+            Short64Vector v = toBitsVector();\n+            ShortVector.ShortSpecies species = Short64Vector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Short> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Short> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -848,1 +919,1 @@\n-            return new Short64Shuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":112,"deletions":41,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -146,8 +146,4 @@\n-      if (wrap) {\n-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return (ShortMaxShuffle)VectorSupport.shuffleIota(ETYPE, ShortMaxShuffle.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -155,3 +151,13 @@\n-    @Override\n-    @ForceInline\n-    ShortMaxShuffle shuffleFromBytes(byte[] reorder) { return new ShortMaxShuffle(reorder); }\n+        ShortMaxVector iota = ShortMaxShuffle.IOTA.toBitsVector();\n+        ShortVector.ShortSpecies species = ShortMaxVector.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        ShortMaxVector wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            ShortMaxVector wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<Short> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+        return wrapped.toShuffle();\n+    }\n@@ -161,1 +167,1 @@\n-    ShortMaxShuffle shuffleFromArray(int[] indexes, int i) { return new ShortMaxShuffle(indexes, i); }\n+    ShortMaxShuffle shuffleFromArray(int[] indices, int i) { return new ShortMaxShuffle(indices, i); }\n@@ -360,0 +366,1 @@\n+    @Override\n@@ -361,2 +368,2 @@\n-    public VectorShuffle<Short> toShuffle() {\n-        return super.toShuffleTemplate(ShortMaxShuffle.class); \/\/ specialize\n+    public ShortMaxShuffle toShuffle() {\n+        return (ShortMaxShuffle) super.toShuffleTemplate(ShortMaxShuffle.class); \/\/ specialize\n@@ -785,2 +792,4 @@\n-        ShortMaxShuffle(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        ShortMaxShuffle(short[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -789,2 +798,2 @@\n-        public ShortMaxShuffle(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        ShortMaxShuffle(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -793,2 +802,2 @@\n-        public ShortMaxShuffle(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        ShortMaxShuffle(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -797,2 +806,2 @@\n-        public ShortMaxShuffle(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        short[] indices() {\n+            return (short[])getPayload();\n@@ -802,0 +811,1 @@\n+        @ForceInline\n@@ -809,2 +819,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < Short.MAX_VALUE);\n+            assert(Short.MIN_VALUE <= -VLENGTH);\n@@ -816,3 +826,11 @@\n-        public ShortMaxVector toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, ShortMaxShuffle.class, this, VLENGTH,\n-                                                    (s) -> ((ShortMaxVector)(((AbstractShuffle<Short>)(s)).toVectorTemplate())));\n+        ShortMaxVector toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    ShortMaxShuffle.class, short.class, VLENGTH,\n+                    ShortMaxVector.class, short.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static ShortMaxVector toBitsVectorHelper(ShortMaxShuffle s) {\n+            return (ShortMaxVector) ShortMaxVector.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -823,6 +841,15 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+            VectorSpecies<Integer> species = IntVector.SPECIES_MAX;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n@@ -834,7 +861,51 @@\n-            ShortMaxShuffle s = (ShortMaxShuffle) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public ShortMaxShuffle wrapIndexes() {\n+            ShortMaxVector v = toBitsVector();\n+            ShortVector.ShortSpecies species = ShortMaxVector.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<Short> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<Short> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+            return v.toShuffle();\n+        }\n+\n+        private static short[] prepare(int[] indices, int offset) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static short[] prepare(IntUnaryOperator f) {\n+            short[] a = new short[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = (short)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange(short[] indices) {\n+            int length = indices.length;\n+            for (short si : indices) {\n+                if (si >= (short)length || si < (short)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -842,1 +913,1 @@\n-            return new ShortMaxShuffle(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":112,"deletions":41,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1074,1 +1074,1 @@\n-   \/**\n+    \/**\n@@ -2496,2 +2496,1 @@\n-    final\n-    VectorShuffle<Short> toShuffleTemplate(Class<?> shuffleType) {\n+    final VectorShuffle<Short> toShuffleTemplate(Class<?> shuffleType) {\n@@ -2499,1 +2498,1 @@\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n@@ -2501,1 +2500,1 @@\n-                                     shuffleType, byte.class, length(),\n+                                     shuffleType, short.class, length(),\n@@ -2506,0 +2505,1 @@\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+    @ForceInline\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShape.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,2 +136,2 @@\n-    VectorShuffle(byte[] reorder) {\n-        super(reorder);\n+    VectorShuffle(Object indices) {\n+        super(indices);\n@@ -559,1 +559,1 @@\n-    public int laneSource(int i) { return toArray()[i]; }\n+    public abstract int laneSource(int i);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorShuffle.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1207,1 +1207,1 @@\n-   \/**\n+    \/**\n@@ -2859,0 +2859,1 @@\n+#if[!FP]\n@@ -2872,2 +2873,1 @@\n-    final\n-    VectorShuffle<$Boxtype$> toShuffleTemplate(Class<?> shuffleType) {\n+    final VectorShuffle<$Boxtype$> toShuffleTemplate(Class<?> shuffleType) {\n@@ -2875,1 +2875,1 @@\n-        return VectorSupport.convert(VectorSupport.VECTOR_OP_CAST,\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n@@ -2877,1 +2877,1 @@\n-                                     shuffleType, byte.class, length(),\n+                                     shuffleType, $type$.class, length(),\n@@ -2881,0 +2881,26 @@\n+#end[!FP]\n+\n+#if[intOrLong]\n+    abstract VectorShuffle<$Boxfptype$> toFPShuffle();\n+\n+    @ForceInline\n+    private final\n+    VectorShuffle<$Boxfptype$> toFPShuffle0(VectorSpecies<$Boxfptype$> dsp) {\n+        $type$[] a = toArray();\n+        int[] sa = new int[a.length];\n+        for (int i = 0; i < a.length; i++) {\n+            sa[i] = (int) a[i];\n+        }\n+        return VectorShuffle.fromArray(dsp, sa, 0);\n+    }\n+\n+    @ForceInline\n+    final\n+    VectorShuffle<$Boxfptype$> toFPShuffleTemplate(Class<?> shuffleType, $Fptype$Vector.$Fptype$Species dsp) {\n+        return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                                     getClass(), $type$.class, length(),\n+                                     shuffleType, $type$.class, length(),\n+                                     this, dsp,\n+                                     $Type$Vector::toFPShuffle0);\n+    }\n+#end[intOrLong]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":32,"deletions":6,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -148,8 +148,4 @@\n-      if (wrap) {\n-        return ($shuffletype$)VectorSupport.shuffleIota(ETYPE, $shuffletype$.class, VSPECIES, VLENGTH, start, step, 1,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i*lstep + lstart, l))));\n-      } else {\n-        return ($shuffletype$)VectorSupport.shuffleIota(ETYPE, $shuffletype$.class, VSPECIES, VLENGTH, start, step, 0,\n-                (l, lstart, lstep, s) -> s.shuffleFromOp(i -> (i*lstep + lstart)));\n-      }\n-    }\n+        if ((VLENGTH & (VLENGTH - 1)) != 0) {\n+            return wrap ? shuffleFromOp(i -> (VectorIntrinsics.wrapToRange(i * step + start, VLENGTH)))\n+                        : shuffleFromOp(i -> i * step + start);\n+        }\n@@ -157,3 +153,18 @@\n-    @Override\n-    @ForceInline\n-    $shuffletype$ shuffleFromBytes(byte[] reorder) { return new $shuffletype$(reorder); }\n+        $bitsvectortype$ iota = $shuffletype$.IOTA.toBitsVector();\n+        $Bitstype$Vector.$Bitstype$Species species = $bitsvectortype$.VSPECIES;\n+        iota = iota.lanewise(VectorOperators.MUL, species.broadcast(step))\n+                .lanewise(VectorOperators.ADD, species.broadcast(start));\n+        $bitsvectortype$ wrapped = iota.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+\n+        if (!wrap) {\n+            $bitsvectortype$ wrappedEx = wrapped.lanewise(VectorOperators.SUB, species.broadcast(VLENGTH));\n+            VectorMask<$Boxbitstype$> mask = wrapped.compare(VectorOperators.EQ, iota);\n+            wrapped = wrappedEx.blend(wrapped, mask);\n+        }\n+#if[!FP]\n+        return wrapped.toShuffle();\n+#end[!FP]\n+#if[FP]\n+        return wrapped.toFPShuffle();\n+#end[FP]\n+    }\n@@ -163,1 +174,1 @@\n-    $shuffletype$ shuffleFromArray(int[] indexes, int i) { return new $shuffletype$(indexes, i); }\n+    $shuffletype$ shuffleFromArray(int[] indices, int i) { return new $shuffletype$(indices, i); }\n@@ -364,0 +375,18 @@\n+#if[!FP]\n+    @Override\n+    @ForceInline\n+    public $shuffletype$ toShuffle() {\n+        return ($shuffletype$) super.toShuffleTemplate($shuffletype$.class); \/\/ specialize\n+    }\n+#end[!FP]\n+#if[FP]\n+    @Override\n+    @ForceInline\n+    public $shuffletype$ toShuffle() {\n+        return ($shuffletype$) castShape($bitsvectortype$.VSPECIES, 0)\n+                .reinterpretAs$Bitstype$s()\n+                .toFPShuffle();\n+    }\n+#end[FP]\n+#if[intOrLong]\n+    @Override\n@@ -365,2 +394,2 @@\n-    public VectorShuffle<$Boxtype$> toShuffle() {\n-        return super.toShuffleTemplate($shuffletype$.class); \/\/ specialize\n+    $fpvectortype$.$Fptype$$bits$Shuffle toFPShuffle() {\n+        return ($fpvectortype$.$Fptype$$bits$Shuffle) super.toFPShuffleTemplate($fpvectortype$.$Fptype$$bits$Shuffle.class, $fpvectortype$.VSPECIES);\n@@ -368,0 +397,1 @@\n+#end[intOrLong]\n@@ -1071,1 +1101,1 @@\n-        static final Class<$Boxtype$> ETYPE = $type$.class; \/\/ used by the JVM\n+        static final Class<$Boxbitstype$> ETYPE = $bitstype$.class; \/\/ used by the JVM\n@@ -1073,2 +1103,4 @@\n-        $shuffletype$(byte[] reorder) {\n-            super(VLENGTH, reorder);\n+        $shuffletype$($bitstype$[] indices) {\n+            super(indices);\n+            assert(VLENGTH == indices.length);\n+            assert(indicesInRange(indices));\n@@ -1077,2 +1109,2 @@\n-        public $shuffletype$(int[] reorder) {\n-            super(VLENGTH, reorder);\n+        $shuffletype$(int[] indices, int i) {\n+            this(prepare(indices, i));\n@@ -1081,2 +1113,2 @@\n-        public $shuffletype$(int[] reorder, int i) {\n-            super(VLENGTH, reorder, i);\n+        $shuffletype$(IntUnaryOperator fn) {\n+            this(prepare(fn));\n@@ -1085,2 +1117,2 @@\n-        public $shuffletype$(IntUnaryOperator fn) {\n-            super(VLENGTH, fn);\n+        $bitstype$[] indices() {\n+            return ($bitstype$[])getPayload();\n@@ -1090,0 +1122,1 @@\n+        @ForceInline\n@@ -1097,2 +1130,2 @@\n-            assert(VLENGTH < Byte.MAX_VALUE);\n-            assert(Byte.MIN_VALUE <= -VLENGTH);\n+            assert(VLENGTH < $Boxbitstype$.MAX_VALUE);\n+            assert($Boxbitstype$.MIN_VALUE <= -VLENGTH);\n@@ -1104,3 +1137,11 @@\n-        public $vectortype$ toVector() {\n-            return VectorSupport.shuffleToVector(VCLASS, ETYPE, $shuffletype$.class, this, VLENGTH,\n-                                                    (s) -> (($vectortype$)(((AbstractShuffle<$Boxtype$>)(s)).toVectorTemplate())));\n+        $bitsvectortype$ toBitsVector() {\n+            return VectorSupport.convert(VectorSupport.VECTOR_OP_REINTERPRET,\n+                    $shuffletype$.class, $bitstype$.class, VLENGTH,\n+                    $bitsvectortype$.class, $bitstype$.class, VLENGTH,\n+                    this, vspecies().asIntegral(),\n+                    (v, s) -> toBitsVectorHelper(v));\n+        }\n+\n+        private static $bitsvectortype$ toBitsVectorHelper($shuffletype$ s) {\n+            return ($bitsvectortype$) $bitsvectortype$.VSPECIES.dummyVector()\n+                    .vectorFactory(s.indices());\n@@ -1111,6 +1152,50 @@\n-        public <F> VectorShuffle<F> cast(VectorSpecies<F> s) {\n-            AbstractSpecies<F> species = (AbstractSpecies<F>) s;\n-            if (length() != species.laneCount())\n-                throw new IllegalArgumentException(\"VectorShuffle length and species length differ\");\n-            int[] shuffleArray = toArray();\n-            return s.shuffleFromArray(shuffleArray, 0).check(s);\n+        public int laneSource(int i) {\n+            return (int)toBitsVector().lane(i);\n+        }\n+\n+        @Override\n+        @ForceInline\n+        public void intoArray(int[] a, int offset) {\n+#if[byte]\n+            VectorSpecies<Integer> species = IntVector.SPECIES_$BITS$;\n+            Vector<Byte> v = toBitsVector();\n+            v.convertShape(VectorOperators.B2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.B2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+            v.convertShape(VectorOperators.B2I, species, 2)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 2);\n+            v.convertShape(VectorOperators.B2I, species, 3)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length() * 3);\n+#end[byte]\n+#if[short]\n+            VectorSpecies<Integer> species = IntVector.SPECIES_$BITS$;\n+            Vector<Short> v = toBitsVector();\n+            v.convertShape(VectorOperators.S2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+            v.convertShape(VectorOperators.S2I, species, 1)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset + species.length());\n+#end[short]\n+#if[intOrFloat]\n+            toBitsVector().intoArray(a, offset);\n+#end[intOrFloat]\n+#if[longOrDouble]\n+#if[!1L]\n+            VectorSpecies<Integer> species = VectorSpecies.of(\n+                    int.class,\n+                    VectorShape.forBitSize(length() * Integer.SIZE));\n+            Vector<Long> v = toBitsVector();\n+            v.convertShape(VectorOperators.L2I, species, 0)\n+                    .reinterpretAsInts()\n+                    .intoArray(a, offset);\n+#end[!1L]\n+#if[1L]\n+            a[offset] = laneSource(0);\n+#end[1L]\n+#end[longOrDouble]\n@@ -1122,7 +1207,63 @@\n-            $shuffletype$ s = ($shuffletype$) shuffle;\n-            byte[] reorder1 = reorder();\n-            byte[] reorder2 = s.reorder();\n-            byte[] r = new byte[reorder1.length];\n-            for (int i = 0; i < reorder1.length; i++) {\n-                int ssi = reorder2[i];\n-                r[i] = reorder1[ssi];  \/\/ throws on exceptional index\n+#if[!FP]\n+            return toBitsVector().rearrange(shuffle).toShuffle();\n+#end[!FP]\n+#if[FP]\n+            return toBitsVector()\n+                    .rearrange(shuffle.cast($bitsvectortype$.VSPECIES))\n+                    .toFPShuffle();\n+#end[FP]\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public $shuffletype$ wrapIndexes() {\n+            $bitsvectortype$ v = toBitsVector();\n+            $Bitstype$Vector.$Bitstype$Species species = $bitsvectortype$.VSPECIES;\n+            if ((VLENGTH & (VLENGTH - 1)) == 0) {\n+                v = v.lanewise(VectorOperators.AND, species.broadcast(VLENGTH - 1));\n+            } else {\n+                VectorMask<$Boxbitstype$> neg = v.compare(VectorOperators.LT, 0);\n+                Vector<$Boxbitstype$> adjusted = v.lanewise(VectorOperators.ADD, VLENGTH);\n+                v = v.blend(adjusted, neg);\n+            }\n+#if[!FP]\n+            return v.toShuffle();\n+#end[!FP]\n+#if[FP]\n+            return v.toFPShuffle();\n+#end[FP]\n+        }\n+\n+        private static $bitstype$[] prepare(int[] indices, int offset) {\n+            $bitstype$[] a = new $bitstype$[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = indices[offset + i];\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = ($bitstype$)si;\n+            }\n+            return a;\n+        }\n+\n+        private static $bitstype$[] prepare(IntUnaryOperator f) {\n+            $bitstype$[] a = new $bitstype$[VLENGTH];\n+            for (int i = 0; i < VLENGTH; i++) {\n+                int si = f.applyAsInt(i);\n+                si = partiallyWrapIndex(si, VLENGTH);\n+                a[i] = ($bitstype$)si;\n+            }\n+            return a;\n+        }\n+\n+        private static boolean indicesInRange($bitstype$[] indices) {\n+            int length = indices.length;\n+            for ($bitstype$ si : indices) {\n+                if (si >= ($bitstype$)length || si < ($bitstype$)(-length)) {\n+                    boolean assertsEnabled = false;\n+                    assert(assertsEnabled = true);\n+                    if (assertsEnabled) {\n+                        String msg = (\"index \"+si+\"out of range [\"+length+\"] in \"+\n+                                  java.util.Arrays.toString(indices));\n+                        throw new AssertionError(msg);\n+                    }\n+                    return false;\n+                }\n@@ -1130,1 +1271,1 @@\n-            return new $shuffletype$(r);\n+            return true;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":183,"deletions":42,"binary":false,"changes":225,"status":"modified"}]}