{"files":[{"patch":"@@ -35,1 +35,1 @@\n-class AsyncLogWriter::AsyncLogLocker : public StackObj {\n+class AsyncLogWriter::OuterLocker : public StackObj {\n@@ -37,1 +37,1 @@\n-  AsyncLogLocker() {\n+  OuterLocker() {\n@@ -39,1 +39,1 @@\n-    _instance->_lock.lock();\n+    _instance->_outer_lock.lock();\n@@ -42,2 +42,14 @@\n-  ~AsyncLogLocker() {\n-    _instance->_lock.unlock();\n+  ~OuterLocker() {\n+    _instance->_outer_lock.unlock();\n+  }\n+};\n+\n+class AsyncLogWriter::InnerLocker : public StackObj {\n+ public:\n+  InnerLocker() {\n+    assert(_instance != nullptr, \"AsyncLogWriter::_lock is unavailable\");\n+    _instance->_inner_lock.lock();\n+  }\n+\n+  ~InnerLocker() {\n+    _instance->_inner_lock.unlock();\n@@ -51,2 +63,2 @@\n-bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n-  const size_t len = strlen(msg);\n+bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msg_len) {\n+  const size_t len = msg_len;\n@@ -68,1 +80,1 @@\n-  bool result = push_back(nullptr, AsyncLogWriter::None, \"\");\n+  bool result = push_back(nullptr, AsyncLogWriter::None, \"\", 0);\n@@ -77,1 +89,17 @@\n-  if (!_buffer->push_back(output, decorations, msg)) {\n+  size_t msg_len = strlen(msg);\n+\n+  if (_buffer->push_back(output, decorations, msg, msg_len)) {\n+    _data_available = true;\n+    _inner_lock.notify();\n+    return;\n+  }\n+\n+  if (LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall) {\n+    void* ptr = os::malloc(Message::calc_size(msg_len), mtLogging);\n+    new (ptr) Message(output, decorations, msg, msg_len);\n+    _stalled_message = (Message*)ptr;\n+    while (_stalled_message != nullptr) {\n+      _inner_lock.wait(0 \/* no timeout *\/);\n+    }\n+    os::free((Message*)ptr);\n+  } else {\n@@ -81,1 +109,0 @@\n-    return;\n@@ -83,3 +110,0 @@\n-\n-  _data_available = true;\n-  _lock.notify();\n@@ -89,1 +113,2 @@\n-  AsyncLogLocker locker;\n+  OuterLocker locker;\n+  InnerLocker ilocker;\n@@ -96,2 +121,2 @@\n-  AsyncLogLocker locker;\n-\n+  OuterLocker locker;\n+  InnerLocker ilocker;\n@@ -104,1 +129,4 @@\n-  : _flush_sem(0), _lock(), _data_available(false),\n+  : _flush_sem(0),\n+    _outer_lock(),\n+    _inner_lock(),\n+    _data_available(false),\n@@ -106,1 +134,2 @@\n-    _stats() {\n+    _stats(),\n+    _stalled_message(nullptr) {\n@@ -156,1 +185,1 @@\n-      AsyncLogLocker locker;\n+      InnerLocker ilocker;\n@@ -158,2 +187,2 @@\n-      while (!_data_available) {\n-        _lock.wait(0\/* no timeout *\/);\n+      while (!_data_available && _stalled_message == nullptr) {\n+        _inner_lock.wait(0\/* no timeout *\/);\n@@ -177,0 +206,1 @@\n+\n@@ -178,0 +208,9 @@\n+\n+    if (_stalled_message != nullptr) {\n+      assert(LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall, \"must be\");\n+      InnerLocker ilocker;\n+      Message* m = (Message*)_stalled_message;\n+      m->output()->write_blocking(m->decorations(), m->message());\n+      _stalled_message = nullptr;\n+      _inner_lock.notify();\n+    }\n@@ -215,1 +254,2 @@\n-      AsyncLogLocker locker;\n+      OuterLocker locker;\n+      InnerLocker ilocker;\n@@ -219,1 +259,1 @@\n-      _instance->_lock.notify();\n+      _instance->_inner_lock.notify();\n@@ -227,1 +267,1 @@\n-  AsyncLogLocker locker;\n+  InnerLocker locker;\n@@ -241,1 +281,1 @@\n-    AsyncLogLocker locker;\n+    InnerLocker locker;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":65,"deletions":25,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-  class AsyncLogLocker;\n+  class OuterLocker;\n+  class InnerLocker;\n@@ -128,1 +129,1 @@\n-    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n+    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msg_len);\n@@ -162,1 +163,6 @@\n-  PlatformMonitor _lock;\n+  \/\/ Producers take both locks in the order 0. _outer_lock 1. _inner_lock\n+  \/\/ The consumer thread only takes the _inner_lock.\n+  \/\/ The _inner_lock protects the buffers and performs all communication between producer and consumer via wait\/notify.\n+  \/\/ This allows a producer to await progress from the consumer thread (by only releasing the _inner_lock)), whilst preventing all other consumers from progressing.\n+  PlatformMonitor _outer_lock;\n+  PlatformMonitor _inner_lock;\n@@ -171,0 +177,6 @@\n+  \/\/ Stalled message\n+  \/\/ Stalling is implemented by the producer writing to _stalled_message, notifying the _inner_lock and releasing it.\n+  \/\/ The consumer will then write all of the current buffers' content and then write the stalled message, at the end notifying the _inner_lock and releasing it for the\n+  \/\/ owning producer thread of the stalled message. This thread will finally release both locks in order, allowing for other producers to continue.\n+  volatile Message* _stalled_message;\n+\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -640,1 +640,1 @@\n-  out->print_cr(\" -Xlog:async\");\n+  out->print_cr(\" -Xlog:async[:[mode]]\");\n@@ -644,0 +644,5 @@\n+  out->print_cr(\" A mode, either 'drop' or 'stall', may be provided. If 'drop' is provided then\"\n+                \" messages will be dropped if there is no room in the intermediate buffer,\"\n+                \" if 'stall' is provided then the log operation will wait for room to be made by the output thread.\"\n+                \" The default mode is 'drop'.\");\n+\n@@ -719,1 +724,1 @@\n-bool LogConfiguration::_async_mode = false;\n+LogConfiguration::AsyncMode LogConfiguration::_async_mode = AsyncMode::Off;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -65,1 +65,8 @@\n-  static bool                       _async_mode;\n+\n+public:\n+  enum class AsyncMode {\n+    Off, Stall, Drop\n+  };\n+\n+private:\n+  static AsyncMode _async_mode;\n@@ -132,3 +139,4 @@\n-  static bool is_async_mode() { return _async_mode; }\n-  static void set_async_mode(bool value) {\n-    _async_mode = value;\n+  static AsyncMode async_mode() { return _async_mode; }\n+  static bool is_async_mode() { return _async_mode != AsyncMode::Off; }\n+  static void set_async_mode(AsyncMode mode) {\n+    _async_mode = mode;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2596,2 +2596,1 @@\n-      } else if (strcmp(tail, \":async\") == 0) {\n-        LogConfiguration::set_async_mode(true);\n+      } else if (strncmp(tail, \":async\", strlen(\":async\")) == 0) {\n@@ -2599,0 +2598,12 @@\n+        const char* async_tail = tail + strlen(\":async\");\n+         if (*async_tail == '\\0') {\n+          \/\/ Default is to drop.\n+          LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+        } else if (strcmp(async_tail, \":stall\") == 0) {\n+          LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Stall);\n+        } else if (strcmp(async_tail, \":drop\") == 0) {\n+          LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+        } else {\n+          \/\/ User provided unknown async option\n+          ret = false;\n+        }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/logConfiguration.hpp\"\n@@ -177,1 +178,1 @@\n-  res = buffer->push_back(output, Default, \"a log line\");\n+  res = buffer->push_back(output, Default, \"a log line\", strlen(\"a log line\"));\n@@ -180,1 +181,1 @@\n-  res = buffer->push_back(output, Default, \"yet another\");\n+  res = buffer->push_back(output, Default, \"yet another\", strlen(\"yet another\"));\n@@ -205,1 +206,1 @@\n-  while (buffer->push_back(output, Default, \"0123456789abcdef\")) {\n+  while (buffer->push_back(output, Default, \"0123456789abcdef\", strlen(\"0123456789abcdef\"))) {\n@@ -256,0 +257,12 @@\n+TEST_VM_F(AsyncLogTest, StallingModePreventsDroppedMessages) {\n+  if (AsyncLogWriter::instance() == nullptr) {\n+    return;\n+  }\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+  LogConfiguration::AsyncMode prev_mode = LogConfiguration::async_mode();\n+  LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Off);\n+  test_asynclog_drop_messages();\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+  LogConfiguration::set_async_mode(prev_mode);\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"}]}