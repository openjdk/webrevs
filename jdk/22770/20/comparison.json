{"files":[{"patch":"@@ -29,1 +29,1 @@\n-#include \"logging\/logHandle.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -32,2 +32,0 @@\n-#include \"runtime\/os.inline.hpp\"\n-#include \"runtime\/globals.hpp\"\n@@ -35,0 +33,3 @@\n+class AsyncLogWriter::Locker : public StackObj {\n+  Thread*& _holder;\n+  PlatformMonitor& _lock;\n@@ -36,2 +37,0 @@\n-class AsyncLogWriter::AsyncLogLocker : public StackObj {\n-  static Thread* _holder;\n@@ -39,4 +38,4 @@\n-  static Thread* current_holder() { return _holder; }\n-  AsyncLogLocker() {\n-    assert(_instance != nullptr, \"AsyncLogWriter::_lock is unavailable\");\n-    _instance->_lock.lock();\n+  Locker(Thread*& holder, PlatformMonitor& lock)\n+  : _holder(holder),\n+    _lock(lock) {\n+    _lock.lock();\n@@ -46,1 +45,1 @@\n-  ~AsyncLogLocker() {\n+  ~Locker() {\n@@ -49,1 +48,5 @@\n-    _instance->_lock.unlock();\n+    _lock.unlock();\n+  }\n+\n+  void notify() {\n+    _lock.notify();\n@@ -55,1 +58,1 @@\n-    _instance->_lock.wait(0\/* no timeout *\/);\n+    _lock.wait(0 \/* no timeout *\/);\n@@ -60,1 +63,16 @@\n-Thread* AsyncLogWriter::AsyncLogLocker::_holder = nullptr;\n+class AsyncLogWriter::ProducerLocker : public Locker {\n+  static Thread* _holder;\n+public:\n+  static Thread* current_holder() { return _holder; }\n+  ProducerLocker() : Locker(_holder, _instance->_producer_lock) {}\n+};\n+\n+class AsyncLogWriter::ConsumerLocker : public Locker {\n+  static Thread* _holder;\n+public:\n+  static Thread* current_holder() { return _holder; }\n+  ConsumerLocker() : Locker(_holder, _instance->_consumer_lock) {}\n+};\n+\n+Thread* AsyncLogWriter::ProducerLocker::_holder = nullptr;\n+Thread* AsyncLogWriter::ConsumerLocker::_holder = nullptr;\n@@ -66,2 +84,2 @@\n-bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n-  const size_t len = strlen(msg);\n+bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msg_len) {\n+  const size_t len = msg_len;\n@@ -83,1 +101,1 @@\n-  bool result = push_back(nullptr, AsyncLogWriter::None, \"\");\n+  bool result = push_back(nullptr, AsyncLogWriter::None, \"\", 0);\n@@ -92,6 +110,9 @@\n-  if (!_buffer->push_back(output, decorations, msg)) {\n-    bool p_created;\n-    uint32_t* counter = _stats.put_if_absent(output, 0, &p_created);\n-    *counter = *counter + 1;\n-    return;\n-  }\n+  size_t msg_len = strlen(msg);\n+  void* stalled_message = nullptr;\n+  {\n+    ConsumerLocker clocker;\n+    if (_buffer->push_back(output, decorations, msg, msg_len)) {\n+      _data_available = true;\n+      clocker.notify();\n+      return;\n+    }\n@@ -99,2 +120,22 @@\n-  _data_available = true;\n-  _lock.notify();\n+    if (LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall) {\n+      size_t size = Message::calc_size(msg_len);\n+      stalled_message = os::malloc(size, mtLogging);\n+      if (stalled_message == nullptr) {\n+        \/\/ Out of memory. We bail without any notice.\n+        \/\/ Some other part of the system will probably fail later.\n+        return;\n+      }\n+      _stalled_message = new (stalled_message) Message(output, decorations, msg, msg_len);\n+      _data_available = true;\n+      clocker.notify();\n+      \/\/ Note: we still hold the producer lock so cannot race against other threads trying to log a message\n+      while (_stalled_message != nullptr) {\n+        clocker.wait();\n+      }\n+    } else {\n+      bool p_created;\n+      uint32_t* counter = _stats.put_if_absent(output, 0, &p_created);\n+      *counter = *counter + 1;\n+    }\n+  } \/\/ ConsumerLocker out of scope\n+  os::free(stalled_message);\n@@ -107,1 +148,1 @@\n-  Thread* holding_thread = AsyncLogWriter::AsyncLogLocker::current_holder();\n+  Thread* holding_thread = AsyncLogWriter::ProducerLocker::current_holder();\n@@ -145,1 +186,1 @@\n-  AsyncLogLocker locker;\n+  ProducerLocker plocker;\n@@ -165,1 +206,1 @@\n-  AsyncLogLocker locker;\n+  ProducerLocker plocker;\n@@ -173,3 +214,7 @@\n-  : _flush_sem(0), _lock(), _data_available(false),\n-    _initialized(false),\n-    _stats() {\n+: _flush_sem(0),\n+  _producer_lock(),\n+  _consumer_lock(),\n+  _data_available(false),\n+  _initialized(false),\n+  _stats(),\n+  _stalled_message(nullptr) {\n@@ -188,1 +233,1 @@\n-void AsyncLogWriter::write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot) {\n+bool AsyncLogWriter::write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot) {\n@@ -216,1 +261,1 @@\n-    _flush_sem.signal(req);\n+    return true;\n@@ -218,0 +263,1 @@\n+  return false;\n@@ -225,2 +271,1 @@\n-      AsyncLogLocker locker;\n-\n+      ConsumerLocker clocker;\n@@ -228,1 +273,1 @@\n-        locker.wait();\n+        clocker.wait();\n@@ -230,0 +275,1 @@\n+\n@@ -246,1 +292,17 @@\n-    write(snapshot);\n+\n+    bool saw_flush_token = write(snapshot);\n+\n+    \/\/ Any stalled message must be written *after* the buffer has been written.\n+    \/\/ This is because we try hard to output messages in program-order.\n+    if (_stalled_message != nullptr) {\n+      assert(LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall, \"must be\");\n+      ConsumerLocker clocker;\n+      Message* m = (Message*)_stalled_message;\n+      m->output()->write_blocking(m->decorations(), m->message());\n+      _stalled_message = nullptr;\n+      clocker.notify();\n+    }\n+\n+    if (saw_flush_token) {\n+      _flush_sem.signal(1);\n+    }\n@@ -284,1 +346,2 @@\n-      AsyncLogLocker locker;\n+      ProducerLocker plocker;\n+      ConsumerLocker clocker;\n@@ -288,1 +351,1 @@\n-      _instance->_lock.notify();\n+      clocker.notify();\n@@ -296,1 +359,1 @@\n-  AsyncLogLocker locker;\n+  ConsumerLocker clocker;\n@@ -310,1 +373,1 @@\n-    AsyncLogLocker locker;\n+    ConsumerLocker clocker;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":103,"deletions":40,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -62,1 +63,3 @@\n-  class AsyncLogLocker;\n+  class Locker;\n+  class ProducerLocker;\n+  class ConsumerLocker;\n@@ -128,1 +131,1 @@\n-    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n+    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msg_len);\n@@ -162,1 +165,5 @@\n-  PlatformMonitor _lock;\n+  \/\/ Producers take both locks in the order producer lock and then consumer lock.\n+  \/\/ The consumer protects the buffers and performs all communication between producer and consumer via wait\/notify.\n+  \/\/ This allows a producer to await progress from the consumer thread (by only releasing the producer lock)), whilst preventing all other producers from progressing.\n+  PlatformMonitor _producer_lock;\n+  PlatformMonitor _consumer_lock;\n@@ -164,0 +171,1 @@\n+  \/\/ _initialized is set to true if the constructor succeeds\n@@ -171,0 +179,6 @@\n+  \/\/ Stalled message\n+  \/\/ Stalling is implemented by the producer writing to _stalled_message, notifying the consumer lock and releasing it.\n+  \/\/ The consumer will then write all of the current buffers' content and then write the stalled message, at the end notifying the consumer lock and releasing it for the\n+  \/\/ owning producer thread of the stalled message. This thread will finally release both locks in order, allowing for other producers to continue.\n+  volatile Message* _stalled_message;\n+\n@@ -175,1 +189,1 @@\n-  void write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot);\n+  bool write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -639,1 +639,1 @@\n-  out->print_cr(\" -Xlog:async\");\n+  out->print_cr(\" -Xlog:async[:[mode]]\");\n@@ -643,0 +643,5 @@\n+  out->print_cr(\" A mode, either 'drop' or 'stall', may be provided. If 'drop' is provided then\"\n+                \" messages will be dropped if there is no room in the intermediate buffer.\"\n+                \" If 'stall' is provided then the log operation will wait for room to be made by the output thread, without dropping any messages.\"\n+                \" The default mode is 'drop'.\");\n+\n@@ -718,1 +723,17 @@\n-bool LogConfiguration::_async_mode = false;\n+LogConfiguration::AsyncMode LogConfiguration::_async_mode = AsyncMode::Off;\n+\n+bool LogConfiguration::parse_async_argument(const char* async_tail) {\n+  bool ret = true;\n+  if (*async_tail == '\\0') {\n+    \/\/ Default is to drop.\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+  } else if (strcmp(async_tail, \":stall\") == 0) {\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Stall);\n+  } else if (strcmp(async_tail, \":drop\") == 0) {\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+  } else {\n+    \/\/ User provided unknown async option\n+    ret = false;\n+  }\n+  return ret;\n+}\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -65,1 +65,8 @@\n-  static bool                       _async_mode;\n+\n+public:\n+  enum class AsyncMode {\n+    Off, Stall, Drop\n+  };\n+\n+private:\n+  static AsyncMode _async_mode;\n@@ -123,0 +130,2 @@\n+  static bool parse_async_argument(const char* async_tail);\n+\n@@ -132,3 +141,4 @@\n-  static bool is_async_mode() { return _async_mode; }\n-  static void set_async_mode(bool value) {\n-    _async_mode = value;\n+  static AsyncMode async_mode() { return _async_mode; }\n+  static bool is_async_mode() { return _async_mode != AsyncMode::Off; }\n+  static void set_async_mode(AsyncMode mode) {\n+    _async_mode = mode;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2600,3 +2600,3 @@\n-      } else if (strcmp(tail, \":async\") == 0) {\n-        LogConfiguration::set_async_mode(true);\n-        ret = true;\n+      } else if (strncmp(tail, \":async\", strlen(\":async\")) == 0) {\n+        const char* async_tail = tail + strlen(\":async\");\n+        ret = LogConfiguration::parse_async_argument(async_tail);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1874,1 +1874,1 @@\n-          range(100*K, 50*M)                                                \\\n+          range(DEBUG_ONLY(96) NOT_DEBUG(100*K), 50*M)                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"logging\/logConfiguration.hpp\"\n@@ -176,1 +177,1 @@\n-  res = buffer->push_back(output, Default, \"a log line\");\n+  res = buffer->push_back(output, Default, \"a log line\", strlen(\"a log line\"));\n@@ -179,1 +180,1 @@\n-  res = buffer->push_back(output, Default, \"yet another\");\n+  res = buffer->push_back(output, Default, \"yet another\", strlen(\"yet another\"));\n@@ -204,1 +205,1 @@\n-  while (buffer->push_back(output, Default, \"0123456789abcdef\")) {\n+  while (buffer->push_back(output, Default, \"0123456789abcdef\", strlen(\"0123456789abcdef\"))) {\n@@ -255,0 +256,12 @@\n+TEST_VM_F(AsyncLogTest, StallingModePreventsDroppedMessages) {\n+  if (AsyncLogWriter::instance() == nullptr) {\n+    return;\n+  }\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+  LogConfiguration::AsyncMode prev_mode = LogConfiguration::async_mode();\n+  LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Off);\n+  test_asynclog_drop_messages();\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+  LogConfiguration::set_async_mode(prev_mode);\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test async UL in dropping and stalling mode\n+ * @requires vm.flagless\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run driver StressAsyncUL\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class StressAsyncUL {\n+    static void analyze_output(String... args) throws Exception {\n+        ProcessBuilder pb =\n+            ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+    }\n+    public static void main(String[] args) throws Exception {\n+        analyze_output(\"-Xlog:async:drop\", \"-Xlog:all=trace\", InnerClass.class.getName());\n+        analyze_output(\"-Xlog:async:stall\", \"-Xlog:all=trace\", InnerClass.class.getName());\n+        \/\/ Stress test with a very small buffer. Note: Any valid buffer size must be able to hold a flush token.\n+        \/\/ Therefore the size of the buffer cannot be zero.\n+        analyze_output(\"-Xlog:async:drop\", \"-Xlog:all=trace\", \"-XX:AsyncLogBufferSize=192\", InnerClass.class.getName());\n+        analyze_output(\"-Xlog:async:stall\", \"-Xlog:all=trace\", \"-XX:AsyncLogBufferSize=192\", InnerClass.class.getName());\n+    }\n+\n+    public static class InnerClass {\n+        public static void main(String[] args) {\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/StressAsyncUL.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}