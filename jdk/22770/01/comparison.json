{"files":[{"patch":"@@ -30,1 +30,1 @@\n-#include \"logging\/logHandle.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"runtime\/os.inline.hpp\"\n@@ -35,1 +34,1 @@\n-class AsyncLogWriter::AsyncLogLocker : public StackObj {\n+class AsyncLogWriter::ProducerLocker : public StackObj {\n@@ -37,1 +36,1 @@\n-  AsyncLogLocker() {\n+  ProducerLocker() {\n@@ -39,1 +38,1 @@\n-    _instance->_lock.lock();\n+    _instance->_producer_lock.lock();\n@@ -42,2 +41,2 @@\n-  ~AsyncLogLocker() {\n-    _instance->_lock.unlock();\n+  ~ProducerLocker() {\n+    _instance->_producer_lock.unlock();\n@@ -45,0 +44,18 @@\n+\n+  void notify() { _instance->_consumer_lock.notify(); }\n+  void wait() { _instance->_consumer_lock.wait(0); }\n+};\n+\n+class AsyncLogWriter::ConsumerLocker : public StackObj {\n+ public:\n+  ConsumerLocker() {\n+    assert(_instance != nullptr, \"AsyncLogWriter::_lock is unavailable\");\n+    _instance->_consumer_lock.lock();\n+  }\n+\n+  ~ConsumerLocker() {\n+    _instance->_consumer_lock.unlock();\n+  }\n+\n+  void notify() { _instance->_consumer_lock.notify(); }\n+  void wait() { _instance->_consumer_lock.wait(0); }\n@@ -51,2 +68,2 @@\n-bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n-  const size_t len = strlen(msg);\n+bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msg_len) {\n+  const size_t len = msg_len;\n@@ -68,1 +85,1 @@\n-  bool result = push_back(nullptr, AsyncLogWriter::None, \"\");\n+  bool result = push_back(nullptr, AsyncLogWriter::None, \"\", 0);\n@@ -72,1 +89,1 @@\n-void AsyncLogWriter::enqueue_locked(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n+void AsyncLogWriter::enqueue_locked(ConsumerLocker& clocker, LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n@@ -77,1 +94,23 @@\n-  if (!_buffer->push_back(output, decorations, msg)) {\n+  size_t msg_len = strlen(msg);\n+\n+  if (_buffer->push_back(output, decorations, msg, msg_len)) {\n+    _data_available = true;\n+    clocker.notify();\n+    return;\n+  }\n+\n+  if (LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall) {\n+    size_t size = Message::calc_size(msg_len);\n+    void* ptr = os::malloc(size, mtLogging);\n+    if (ptr == nullptr) {\n+      \/\/ Out of memory. We bail without any notice.\n+      \/\/ Some other part of the system will probably fail later.\n+      return;\n+    }\n+    new (ptr) Message(output, decorations, msg, msg_len);\n+    _stalled_message = (Message*)ptr;\n+    while (_stalled_message != nullptr) {\n+      clocker.wait();\n+    }\n+    os::free(ptr);\n+  } else {\n@@ -81,1 +120,0 @@\n-    return;\n@@ -83,3 +121,0 @@\n-\n-  _data_available = true;\n-  _lock.notify();\n@@ -89,2 +124,3 @@\n-  AsyncLogLocker locker;\n-  enqueue_locked(&output, decorations, msg);\n+  ProducerLocker plocker;\n+  ConsumerLocker clocker;\n+  enqueue_locked(clocker, &output, decorations, msg);\n@@ -96,2 +132,2 @@\n-  AsyncLogLocker locker;\n-\n+  ProducerLocker plocker;\n+  ConsumerLocker clocker;\n@@ -99,1 +135,1 @@\n-    enqueue_locked(&output, msg_iterator.decorations(), msg_iterator.message());\n+    enqueue_locked(clocker, &output, msg_iterator.decorations(), msg_iterator.message());\n@@ -104,1 +140,4 @@\n-  : _flush_sem(0), _lock(), _data_available(false),\n+  : _flush_sem(0),\n+    _producer_lock(),\n+    _consumer_lock(),\n+    _data_available(false),\n@@ -106,1 +145,2 @@\n-    _stats() {\n+    _stats(),\n+    _stalled_message(nullptr) {\n@@ -156,1 +196,1 @@\n-      AsyncLogLocker locker;\n+      ConsumerLocker clocker;\n@@ -158,2 +198,2 @@\n-      while (!_data_available) {\n-        _lock.wait(0\/* no timeout *\/);\n+      while (!_data_available && _stalled_message == nullptr) {\n+        clocker.wait();\n@@ -177,0 +217,1 @@\n+\n@@ -178,0 +219,9 @@\n+\n+    if (_stalled_message != nullptr) {\n+      assert(LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall, \"must be\");\n+      ConsumerLocker clocker;\n+      Message* m = (Message*)_stalled_message;\n+      m->output()->write_blocking(m->decorations(), m->message());\n+      _stalled_message = nullptr;\n+      clocker.notify();\n+    }\n@@ -215,1 +265,2 @@\n-      AsyncLogLocker locker;\n+      ProducerLocker plocker;\n+      ConsumerLocker clocker;\n@@ -219,1 +270,1 @@\n-      _instance->_lock.notify();\n+      clocker.notify();\n@@ -227,1 +278,1 @@\n-  AsyncLogLocker locker;\n+  ConsumerLocker clocker;\n@@ -241,1 +292,1 @@\n-    AsyncLogLocker locker;\n+    ConsumerLocker clocker;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":81,"deletions":30,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-  class AsyncLogLocker;\n+  class ProducerLocker;\n+  class ConsumerLocker;\n@@ -128,1 +129,1 @@\n-    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n+    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msg_len);\n@@ -162,1 +163,5 @@\n-  PlatformMonitor _lock;\n+  \/\/ Producers take both locks in the order producer lock and then consumer lock.\n+  \/\/ The consumer protects the buffers and performs all communication between producer and consumer via wait\/notify.\n+  \/\/ This allows a producer to await progress from the consumer thread (by only releasing the producer lock)), whilst preventing all other producers from progressing.\n+  PlatformMonitor _producer_lock;\n+  PlatformMonitor _consumer_lock;\n@@ -171,0 +176,6 @@\n+  \/\/ Stalled message\n+  \/\/ Stalling is implemented by the producer writing to _stalled_message, notifying the consumer lock and releasing it.\n+  \/\/ The consumer will then write all of the current buffers' content and then write the stalled message, at the end notifying the consumer lock and releasing it for the\n+  \/\/ owning producer thread of the stalled message. This thread will finally release both locks in order, allowing for other producers to continue.\n+  volatile Message* _stalled_message;\n+\n@@ -174,1 +185,1 @@\n-  void enqueue_locked(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n+  void enqueue_locked(ConsumerLocker& clocker, LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -640,1 +640,1 @@\n-  out->print_cr(\" -Xlog:async\");\n+  out->print_cr(\" -Xlog:async[:[mode]]\");\n@@ -644,0 +644,5 @@\n+  out->print_cr(\" A mode, either 'drop' or 'stall', may be provided. If 'drop' is provided then\"\n+                \" messages will be dropped if there is no room in the intermediate buffer,\"\n+                \" if 'stall' is provided then the log operation will wait for room to be made by the output thread.\"\n+                \" The default mode is 'drop'.\");\n+\n@@ -719,1 +724,17 @@\n-bool LogConfiguration::_async_mode = false;\n+LogConfiguration::AsyncMode LogConfiguration::_async_mode = AsyncMode::Off;\n+\n+bool LogConfiguration::parse_async_argument(const char* async_tail) {\n+  bool ret = true;\n+  if (*async_tail == '\\0') {\n+    \/\/ Default is to drop.\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+  } else if (strcmp(async_tail, \":stall\") == 0) {\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Stall);\n+  } else if (strcmp(async_tail, \":drop\") == 0) {\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+  } else {\n+    \/\/ User provided unknown async option\n+    ret = false;\n+  }\n+  return ret;\n+}\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -65,1 +65,8 @@\n-  static bool                       _async_mode;\n+\n+public:\n+  enum class AsyncMode {\n+    Off, Stall, Drop\n+  };\n+\n+private:\n+  static AsyncMode _async_mode;\n@@ -123,0 +130,2 @@\n+  static bool parse_async_argument(const char* async_tail);\n+\n@@ -132,3 +141,4 @@\n-  static bool is_async_mode() { return _async_mode; }\n-  static void set_async_mode(bool value) {\n-    _async_mode = value;\n+  static AsyncMode async_mode() { return _async_mode; }\n+  static bool is_async_mode() { return _async_mode != AsyncMode::Off; }\n+  static void set_async_mode(AsyncMode mode) {\n+    _async_mode = mode;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2596,3 +2596,3 @@\n-      } else if (strcmp(tail, \":async\") == 0) {\n-        LogConfiguration::set_async_mode(true);\n-        ret = true;\n+      } else if (strncmp(tail, \":async\", strlen(\":async\")) == 0) {\n+        const char* async_tail = tail + strlen(\":async\");\n+        ret = LogConfiguration::parse_async_argument(async_tail);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/logConfiguration.hpp\"\n@@ -177,1 +178,1 @@\n-  res = buffer->push_back(output, Default, \"a log line\");\n+  res = buffer->push_back(output, Default, \"a log line\", strlen(\"a log line\"));\n@@ -180,1 +181,1 @@\n-  res = buffer->push_back(output, Default, \"yet another\");\n+  res = buffer->push_back(output, Default, \"yet another\", strlen(\"yet another\"));\n@@ -205,1 +206,1 @@\n-  while (buffer->push_back(output, Default, \"0123456789abcdef\")) {\n+  while (buffer->push_back(output, Default, \"0123456789abcdef\", strlen(\"0123456789abcdef\"))) {\n@@ -256,0 +257,12 @@\n+TEST_VM_F(AsyncLogTest, StallingModePreventsDroppedMessages) {\n+  if (AsyncLogWriter::instance() == nullptr) {\n+    return;\n+  }\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+  LogConfiguration::AsyncMode prev_mode = LogConfiguration::async_mode();\n+  LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Off);\n+  test_asynclog_drop_messages();\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+  LogConfiguration::set_async_mode(prev_mode);\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"}]}