{"files":[{"patch":"@@ -30,1 +30,1 @@\n-#include \"logging\/logHandle.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"runtime\/os.inline.hpp\"\n@@ -35,1 +34,1 @@\n-class AsyncLogWriter::AsyncLogLocker : public StackObj {\n+class AsyncLogWriter::ProducerLocker : public StackObj {\n@@ -37,1 +36,1 @@\n-  AsyncLogLocker() {\n+  ProducerLocker() {\n@@ -39,1 +38,1 @@\n-    _instance->_lock.lock();\n+    _instance->_producer_lock.lock();\n@@ -42,2 +41,2 @@\n-  ~AsyncLogLocker() {\n-    _instance->_lock.unlock();\n+  ~ProducerLocker() {\n+    _instance->_producer_lock.unlock();\n@@ -45,0 +44,18 @@\n+\n+  void notify() { _instance->_consumer_lock.notify(); }\n+  void wait() { _instance->_consumer_lock.wait(0); }\n+};\n+\n+class AsyncLogWriter::ConsumerLocker : public StackObj {\n+ public:\n+  ConsumerLocker() {\n+    assert(_instance != nullptr, \"AsyncLogWriter::_lock is unavailable\");\n+    _instance->_consumer_lock.lock();\n+  }\n+\n+  ~ConsumerLocker() {\n+    _instance->_consumer_lock.unlock();\n+  }\n+\n+  void notify() { _instance->_consumer_lock.notify(); }\n+  void wait() { _instance->_consumer_lock.wait(0); }\n@@ -51,2 +68,2 @@\n-bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n-  const size_t len = strlen(msg);\n+bool AsyncLogWriter::Buffer::push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msg_len) {\n+  const size_t len = msg_len;\n@@ -68,1 +85,1 @@\n-  bool result = push_back(nullptr, AsyncLogWriter::None, \"\");\n+  bool result = push_back(nullptr, AsyncLogWriter::None, \"\", 0);\n@@ -77,1 +94,25 @@\n-  if (!_buffer->push_back(output, decorations, msg)) {\n+  size_t msg_len = strlen(msg);\n+\n+  ConsumerLocker clocker;\n+  if (_buffer->push_back(output, decorations, msg, msg_len)) {\n+    _data_available = true;\n+    clocker.notify();\n+    return;\n+  }\n+\n+  if (LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall) {\n+    size_t size = Message::calc_size(msg_len);\n+    void* ptr = os::malloc(size, mtLogging);\n+    if (ptr == nullptr) {\n+      \/\/ Out of memory. We bail without any notice.\n+      \/\/ Some other part of the system will probably fail later.\n+      return;\n+    }\n+    new (ptr) Message(output, decorations, msg, msg_len);\n+    _stalled_message = (Message*)ptr;\n+    clocker.notify();\n+    while (_stalled_message != nullptr) {\n+      clocker.wait();\n+    }\n+    os::free(ptr);\n+  } else {\n@@ -81,1 +122,0 @@\n-    return;\n@@ -83,3 +123,0 @@\n-\n-  _data_available = true;\n-  _lock.notify();\n@@ -89,1 +126,1 @@\n-  AsyncLogLocker locker;\n+  ProducerLocker plocker;\n@@ -96,2 +133,1 @@\n-  AsyncLogLocker locker;\n-\n+  ProducerLocker plocker;\n@@ -104,1 +140,4 @@\n-  : _flush_sem(0), _lock(), _data_available(false),\n+  : _flush_sem(0),\n+    _producer_lock(),\n+    _consumer_lock(),\n+    _data_available(false),\n@@ -106,1 +145,2 @@\n-    _stats() {\n+    _stats(),\n+    _stalled_message(nullptr) {\n@@ -119,1 +159,1 @@\n-void AsyncLogWriter::write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot) {\n+bool AsyncLogWriter::write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot) {\n@@ -147,1 +187,1 @@\n-    _flush_sem.signal(req);\n+    return true;\n@@ -149,0 +189,1 @@\n+  return false;\n@@ -156,4 +197,3 @@\n-      AsyncLogLocker locker;\n-\n-      while (!_data_available) {\n-        _lock.wait(0\/* no timeout *\/);\n+      ConsumerLocker clocker;\n+      while (!_data_available && _stalled_message == nullptr) {\n+        clocker.wait();\n@@ -161,0 +201,1 @@\n+\n@@ -177,1 +218,14 @@\n-    write(snapshot);\n+\n+    bool saw_flush_token = write(snapshot);\n+\n+    if (_stalled_message != nullptr) {\n+      assert(LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall, \"must be\");\n+      ConsumerLocker clocker;\n+      Message* m = (Message*)_stalled_message;\n+      m->output()->write_blocking(m->decorations(), m->message());\n+      _stalled_message = nullptr;\n+      clocker.notify();\n+    }\n+    if (saw_flush_token) {\n+      _flush_sem.signal(1);\n+    }\n@@ -215,1 +269,2 @@\n-      AsyncLogLocker locker;\n+      ProducerLocker plocker;\n+      ConsumerLocker clocker;\n@@ -219,1 +274,1 @@\n-      _instance->_lock.notify();\n+      clocker.notify();\n@@ -227,1 +282,1 @@\n-  AsyncLogLocker locker;\n+  ConsumerLocker clocker;\n@@ -241,1 +296,1 @@\n-    AsyncLogLocker locker;\n+    ConsumerLocker clocker;\n@@ -249,0 +304,32 @@\n+\n+bool AsyncLogWriter::enqueue_if_initialized(LogFileStreamOutput& output,\n+                                            const LogDecorations& decorations, const char* msg) {\n+  AsyncLogWriter* instance = AsyncLogWriter::instance();\n+  if (instance != nullptr) {\n+    if ((uintptr_t)instance == (uintptr_t)Thread::current_or_null()) {\n+      \/\/ If logging from the consuming thread then fall back on synchronous logging.\n+      \/\/ Otherwise, the consuming thread may wait on itself to print the message,\n+      \/\/ this obviously leads to a deadlocked system.\n+      return false;\n+    }\n+    instance->enqueue(output, decorations, msg);\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool AsyncLogWriter::enqueue_if_initialized(LogFileStreamOutput& output,\n+                                            LogMessageBuffer::Iterator msg_iterator) {\n+  AsyncLogWriter* instance = AsyncLogWriter::instance();\n+  if (instance != nullptr) {\n+    if ((uintptr_t)instance == (uintptr_t)Thread::current_or_null()) {\n+      \/\/ If logging from the consuming thread then fall back on synchronous logging.\n+      \/\/ Otherwise, the consuming thread may wait on itself to print the message,\n+      \/\/ this obviously leads to a deadlocked system.\n+      return false;\n+    }\n+    instance->enqueue(output, msg_iterator);\n+    return true;\n+  }\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":118,"deletions":31,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -62,1 +63,2 @@\n-  class AsyncLogLocker;\n+  class ProducerLocker;\n+  class ConsumerLocker;\n@@ -128,1 +130,1 @@\n-    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n+    bool push_back(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg, const size_t msg_len);\n@@ -162,1 +164,5 @@\n-  PlatformMonitor _lock;\n+  \/\/ Producers take both locks in the order producer lock and then consumer lock.\n+  \/\/ The consumer protects the buffers and performs all communication between producer and consumer via wait\/notify.\n+  \/\/ This allows a producer to await progress from the consumer thread (by only releasing the producer lock)), whilst preventing all other producers from progressing.\n+  PlatformMonitor _producer_lock;\n+  PlatformMonitor _consumer_lock;\n@@ -164,0 +170,1 @@\n+  \/\/ _initialized is set to true if the constructor succeeds\n@@ -171,0 +178,6 @@\n+  \/\/ Stalled message\n+  \/\/ Stalling is implemented by the producer writing to _stalled_message, notifying the consumer lock and releasing it.\n+  \/\/ The consumer will then write all of the current buffers' content and then write the stalled message, at the end notifying the consumer lock and releasing it for the\n+  \/\/ owning producer thread of the stalled message. This thread will finally release both locks in order, allowing for other producers to continue.\n+  volatile Message* _stalled_message;\n+\n@@ -175,1 +188,1 @@\n-  void write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot);\n+  bool write(AsyncLogMap<AnyObj::RESOURCE_AREA>& snapshot);\n@@ -204,0 +217,5 @@\n+  \/\/ Returns true if initialized, otherwise false\n+  static bool enqueue_if_initialized(LogFileStreamOutput& output, const LogDecorations& decorations,\n+                                     const char* msg);\n+  static bool enqueue_if_initialized(LogFileStreamOutput& output,\n+                                     LogMessageBuffer::Iterator msg_iterator);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -640,1 +640,1 @@\n-  out->print_cr(\" -Xlog:async\");\n+  out->print_cr(\" -Xlog:async[:[mode]]\");\n@@ -644,0 +644,5 @@\n+  out->print_cr(\" A mode, either 'drop' or 'stall', may be provided. If 'drop' is provided then\"\n+                \" messages will be dropped if there is no room in the intermediate buffer.\"\n+                \" If 'stall' is provided then the log operation will wait for room to be made by the output thread, without dropping any messages.\"\n+                \" The default mode is 'drop'.\");\n+\n@@ -719,1 +724,17 @@\n-bool LogConfiguration::_async_mode = false;\n+LogConfiguration::AsyncMode LogConfiguration::_async_mode = AsyncMode::Off;\n+\n+bool LogConfiguration::parse_async_argument(const char* async_tail) {\n+  bool ret = true;\n+  if (*async_tail == '\\0') {\n+    \/\/ Default is to drop.\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+  } else if (strcmp(async_tail, \":stall\") == 0) {\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Stall);\n+  } else if (strcmp(async_tail, \":drop\") == 0) {\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+  } else {\n+    \/\/ User provided unknown async option\n+    ret = false;\n+  }\n+  return ret;\n+}\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -65,1 +65,8 @@\n-  static bool                       _async_mode;\n+\n+public:\n+  enum class AsyncMode {\n+    Off, Stall, Drop\n+  };\n+\n+private:\n+  static AsyncMode _async_mode;\n@@ -123,0 +130,2 @@\n+  static bool parse_async_argument(const char* async_tail);\n+\n@@ -132,3 +141,4 @@\n-  static bool is_async_mode() { return _async_mode; }\n-  static void set_async_mode(bool value) {\n-    _async_mode = value;\n+  static AsyncMode async_mode() { return _async_mode; }\n+  static bool is_async_mode() { return _async_mode != AsyncMode::Off; }\n+  static void set_async_mode(AsyncMode mode) {\n+    _async_mode = mode;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -296,3 +296,2 @@\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, decorations, msg);\n+  bool did_write = AsyncLogWriter::enqueue_if_initialized(*this, decorations, msg);\n+  if (did_write) {\n@@ -311,3 +310,2 @@\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, msg_iterator);\n+  bool did_write = AsyncLogWriter::enqueue_if_initialized(*this, msg_iterator);\n+  if (did_write) {\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -177,3 +177,2 @@\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, decorations, msg);\n+  bool did_write = AsyncLogWriter::enqueue_if_initialized(*this, decorations, msg);\n+  if (did_write) {\n@@ -190,3 +189,2 @@\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, msg_iterator);\n+  bool did_write = AsyncLogWriter::enqueue_if_initialized(*this, msg_iterator);\n+  if (did_write) {\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2596,3 +2596,3 @@\n-      } else if (strcmp(tail, \":async\") == 0) {\n-        LogConfiguration::set_async_mode(true);\n-        ret = true;\n+      } else if (strncmp(tail, \":async\", strlen(\":async\")) == 0) {\n+        const char* async_tail = tail + strlen(\":async\");\n+        ret = LogConfiguration::parse_async_argument(async_tail);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1870,1 +1870,1 @@\n-          range(100*K, 50*M)                                                \\\n+          range(DEBUG_ONLY(96) NOT_DEBUG(100*K), 50*M)                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/logConfiguration.hpp\"\n@@ -177,1 +178,1 @@\n-  res = buffer->push_back(output, Default, \"a log line\");\n+  res = buffer->push_back(output, Default, \"a log line\", strlen(\"a log line\"));\n@@ -180,1 +181,1 @@\n-  res = buffer->push_back(output, Default, \"yet another\");\n+  res = buffer->push_back(output, Default, \"yet another\", strlen(\"yet another\"));\n@@ -205,1 +206,1 @@\n-  while (buffer->push_back(output, Default, \"0123456789abcdef\")) {\n+  while (buffer->push_back(output, Default, \"0123456789abcdef\", strlen(\"0123456789abcdef\"))) {\n@@ -256,0 +257,12 @@\n+TEST_VM_F(AsyncLogTest, StallingModePreventsDroppedMessages) {\n+  if (AsyncLogWriter::instance() == nullptr) {\n+    return;\n+  }\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+  LogConfiguration::AsyncMode prev_mode = LogConfiguration::async_mode();\n+  LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Off);\n+  test_asynclog_drop_messages();\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+  LogConfiguration::set_async_mode(prev_mode);\n+}\n+\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test async UL in dropping and stalling mode\n+ * @requires vm.flagless\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run driver StressAsyncUL\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class StressAsyncUL {\n+    static void analyze_output(String... args) throws Exception {\n+        ProcessBuilder pb =\n+            ProcessTools.createLimitedTestJavaProcessBuilder(args);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+    }\n+    public static void main(String[] args) throws Exception {\n+        analyze_output(\"-Xlog:async:drop\", \"-Xlog:all=trace\", InnerClass.class.getName());\n+        analyze_output(\"-Xlog:async:stall\", \"-Xlog:all=trace\", InnerClass.class.getName());\n+        \/\/ Stress test with a very small buffer. Note: Any valid buffer size must be able to hold a flush token.\n+        \/\/ Therefore the size of the buffer cannot be zero.\n+        analyze_output(\"-Xlog:async:drop\", \"-Xlog:all=trace\", \"-XX:AsyncLogBufferSize=192\", InnerClass.class.getName());\n+        analyze_output(\"-Xlog:async:stall\", \"-Xlog:all=trace\", \"-XX:AsyncLogBufferSize=192\", InnerClass.class.getName());\n+    }\n+\n+    public static class InnerClass {\n+        public static void main(String[] args) {\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/StressAsyncUL.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}