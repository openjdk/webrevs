{"files":[{"patch":"@@ -34,0 +34,2 @@\n+#include <new>\n+\n@@ -38,0 +40,1 @@\n+    assert(_instance->_producer_lock_holder != Thread::current(), \"Recursive locking not allowed\");\n@@ -39,0 +42,1 @@\n+    _instance->_producer_lock_holder = Thread::current();\n@@ -42,0 +46,2 @@\n+    assert(_instance->_producer_lock_holder != Thread::current(), \"Must be\");\n+    _instance->_producer_lock_holder = nullptr;\n@@ -95,14 +101,6 @@\n-\n-  ConsumerLocker clocker;\n-  if (_buffer->push_back(output, decorations, msg, msg_len)) {\n-    _data_available = true;\n-    clocker.notify();\n-    return;\n-  }\n-\n-  if (LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall) {\n-    size_t size = Message::calc_size(msg_len);\n-    void* ptr = os::malloc(size, mtLogging);\n-    if (ptr == nullptr) {\n-      \/\/ Out of memory. We bail without any notice.\n-      \/\/ Some other part of the system will probably fail later.\n+  void* stalled_message_ptr = nullptr;\n+  {\n+    ConsumerLocker clocker;\n+    if (_buffer->push_back(output, decorations, msg, msg_len)) {\n+      _data_available = true;\n+      clocker.notify();\n@@ -111,5 +109,19 @@\n-    new (ptr) Message(output, decorations, msg, msg_len);\n-    _stalled_message = (Message*)ptr;\n-    clocker.notify();\n-    while (_stalled_message != nullptr) {\n-      clocker.wait();\n+\n+    if (LogConfiguration::async_mode() == LogConfiguration::AsyncMode::Stall) {\n+      size_t size = Message::calc_size(msg_len);\n+      stalled_message_ptr = os::malloc(size, mtLogging);\n+      if (stalled_message_ptr == nullptr) {\n+        \/\/ Out of memory. We bail without any notice.\n+        \/\/ Some other part of the system will probably fail later.\n+        return;\n+      }\n+      new (stalled_message_ptr) Message(output, decorations, msg, msg_len);\n+      _stalled_message = (Message*)stalled_message_ptr;\n+      clocker.notify();\n+      while (_stalled_message != nullptr) {\n+        clocker.wait();\n+      }\n+    } else {\n+      bool p_created;\n+      uint32_t* counter = _stats.put_if_absent(output, 0, &p_created);\n+      *counter = *counter + 1;\n@@ -117,6 +129,2 @@\n-    os::free(ptr);\n-  } else {\n-    bool p_created;\n-    uint32_t* counter = _stats.put_if_absent(output, 0, &p_created);\n-    *counter = *counter + 1;\n-  }\n+  } \/\/ ConsumerLocker out of scope\n+  os::free(stalled_message_ptr);\n@@ -141,0 +149,1 @@\n+    _producer_lock_holder(nullptr),\n@@ -308,0 +317,1 @@\n+  Thread* current = Thread::current();\n@@ -309,1 +319,2 @@\n-    if ((uintptr_t)instance == (uintptr_t)Thread::current_or_null()) {\n+    if (static_cast<Thread*>(instance) == current ||\n+        instance->_producer_lock_holder == current) {\n@@ -313,0 +324,3 @@\n+\n+      \/\/ If the producer lock holder is set to the current thread, then this is a recursive log then fall back on synchronous logging.\n+      \/\/ This avoids recursive locking and (possibly) infinite log recursion.\n@@ -324,0 +338,1 @@\n+  Thread* current = Thread::current();\n@@ -325,1 +340,2 @@\n-    if ((uintptr_t)instance == (uintptr_t)Thread::current_or_null()) {\n+    if (static_cast<Thread*>(instance) == current ||\n+        instance->_producer_lock_holder == current) {\n@@ -329,0 +345,3 @@\n+\n+      \/\/ If the producer lock holder is set to the current thread, then this is a recursive log then fall back on synchronous logging.\n+      \/\/ This avoids recursive locking and (possibly) infinite log recursion.\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":46,"deletions":27,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -167,0 +167,3 @@\n+  \/\/ The _producer_lock_holder allows us to gracefully degrade to synchronous logging in the case of recursive logging inside\n+  \/\/ of a producer's critical section.\n+  Thread* _producer_lock_holder;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}