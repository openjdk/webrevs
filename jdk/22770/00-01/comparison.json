{"files":[{"patch":"@@ -30,1 +30,1 @@\n-#include \"logging\/logHandle.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -33,1 +33,0 @@\n-#include \"runtime\/os.inline.hpp\"\n@@ -35,1 +34,1 @@\n-class AsyncLogWriter::OuterLocker : public StackObj {\n+class AsyncLogWriter::ProducerLocker : public StackObj {\n@@ -37,1 +36,1 @@\n-  OuterLocker() {\n+  ProducerLocker() {\n@@ -39,1 +38,1 @@\n-    _instance->_outer_lock.lock();\n+    _instance->_producer_lock.lock();\n@@ -42,2 +41,2 @@\n-  ~OuterLocker() {\n-    _instance->_outer_lock.unlock();\n+  ~ProducerLocker() {\n+    _instance->_producer_lock.unlock();\n@@ -45,0 +44,3 @@\n+\n+  void notify() { _instance->_consumer_lock.notify(); }\n+  void wait() { _instance->_consumer_lock.wait(0); }\n@@ -47,1 +49,1 @@\n-class AsyncLogWriter::InnerLocker : public StackObj {\n+class AsyncLogWriter::ConsumerLocker : public StackObj {\n@@ -49,1 +51,1 @@\n-  InnerLocker() {\n+  ConsumerLocker() {\n@@ -51,1 +53,1 @@\n-    _instance->_inner_lock.lock();\n+    _instance->_consumer_lock.lock();\n@@ -54,2 +56,2 @@\n-  ~InnerLocker() {\n-    _instance->_inner_lock.unlock();\n+  ~ConsumerLocker() {\n+    _instance->_consumer_lock.unlock();\n@@ -57,0 +59,3 @@\n+\n+  void notify() { _instance->_consumer_lock.notify(); }\n+  void wait() { _instance->_consumer_lock.wait(0); }\n@@ -84,1 +89,1 @@\n-void AsyncLogWriter::enqueue_locked(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n+void AsyncLogWriter::enqueue_locked(ConsumerLocker& clocker, LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg) {\n@@ -93,1 +98,1 @@\n-    _inner_lock.notify();\n+    clocker.notify();\n@@ -98,1 +103,7 @@\n-    void* ptr = os::malloc(Message::calc_size(msg_len), mtLogging);\n+    size_t size = Message::calc_size(msg_len);\n+    void* ptr = os::malloc(size, mtLogging);\n+    if (ptr == nullptr) {\n+      \/\/ Out of memory. We bail without any notice.\n+      \/\/ Some other part of the system will probably fail later.\n+      return;\n+    }\n@@ -102,1 +113,1 @@\n-      _inner_lock.wait(0 \/* no timeout *\/);\n+      clocker.wait();\n@@ -104,1 +115,1 @@\n-    os::free((Message*)ptr);\n+    os::free(ptr);\n@@ -113,3 +124,3 @@\n-  OuterLocker locker;\n-  InnerLocker ilocker;\n-  enqueue_locked(&output, decorations, msg);\n+  ProducerLocker plocker;\n+  ConsumerLocker clocker;\n+  enqueue_locked(clocker, &output, decorations, msg);\n@@ -121,2 +132,2 @@\n-  OuterLocker locker;\n-  InnerLocker ilocker;\n+  ProducerLocker plocker;\n+  ConsumerLocker clocker;\n@@ -124,1 +135,1 @@\n-    enqueue_locked(&output, msg_iterator.decorations(), msg_iterator.message());\n+    enqueue_locked(clocker, &output, msg_iterator.decorations(), msg_iterator.message());\n@@ -130,2 +141,2 @@\n-    _outer_lock(),\n-    _inner_lock(),\n+    _producer_lock(),\n+    _consumer_lock(),\n@@ -185,1 +196,1 @@\n-      InnerLocker ilocker;\n+      ConsumerLocker clocker;\n@@ -188,1 +199,1 @@\n-        _inner_lock.wait(0\/* no timeout *\/);\n+        clocker.wait();\n@@ -211,1 +222,1 @@\n-      InnerLocker ilocker;\n+      ConsumerLocker clocker;\n@@ -215,1 +226,1 @@\n-      _inner_lock.notify();\n+      clocker.notify();\n@@ -254,2 +265,2 @@\n-      OuterLocker locker;\n-      InnerLocker ilocker;\n+      ProducerLocker plocker;\n+      ConsumerLocker clocker;\n@@ -259,1 +270,1 @@\n-      _instance->_inner_lock.notify();\n+      clocker.notify();\n@@ -267,1 +278,1 @@\n-  InnerLocker locker;\n+  ConsumerLocker clocker;\n@@ -281,1 +292,1 @@\n-    InnerLocker locker;\n+    ConsumerLocker clocker;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":45,"deletions":34,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-  class OuterLocker;\n-  class InnerLocker;\n+  class ProducerLocker;\n+  class ConsumerLocker;\n@@ -163,6 +163,5 @@\n-  \/\/ Producers take both locks in the order 0. _outer_lock 1. _inner_lock\n-  \/\/ The consumer thread only takes the _inner_lock.\n-  \/\/ The _inner_lock protects the buffers and performs all communication between producer and consumer via wait\/notify.\n-  \/\/ This allows a producer to await progress from the consumer thread (by only releasing the _inner_lock)), whilst preventing all other consumers from progressing.\n-  PlatformMonitor _outer_lock;\n-  PlatformMonitor _inner_lock;\n+  \/\/ Producers take both locks in the order producer lock and then consumer lock.\n+  \/\/ The consumer protects the buffers and performs all communication between producer and consumer via wait\/notify.\n+  \/\/ This allows a producer to await progress from the consumer thread (by only releasing the producer lock)), whilst preventing all other producers from progressing.\n+  PlatformMonitor _producer_lock;\n+  PlatformMonitor _consumer_lock;\n@@ -178,2 +177,2 @@\n-  \/\/ Stalling is implemented by the producer writing to _stalled_message, notifying the _inner_lock and releasing it.\n-  \/\/ The consumer will then write all of the current buffers' content and then write the stalled message, at the end notifying the _inner_lock and releasing it for the\n+  \/\/ Stalling is implemented by the producer writing to _stalled_message, notifying the consumer lock and releasing it.\n+  \/\/ The consumer will then write all of the current buffers' content and then write the stalled message, at the end notifying the consumer lock and releasing it for the\n@@ -186,1 +185,1 @@\n-  void enqueue_locked(LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n+  void enqueue_locked(ConsumerLocker& clocker, LogFileStreamOutput* output, const LogDecorations& decorations, const char* msg);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -725,0 +725,16 @@\n+\n+bool LogConfiguration::parse_async_argument(const char* async_tail) {\n+  bool ret = true;\n+  if (*async_tail == '\\0') {\n+    \/\/ Default is to drop.\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+  } else if (strcmp(async_tail, \":stall\") == 0) {\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Stall);\n+  } else if (strcmp(async_tail, \":drop\") == 0) {\n+    LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n+  } else {\n+    \/\/ User provided unknown async option\n+    ret = false;\n+  }\n+  return ret;\n+}\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  static bool parse_async_argument(const char* async_tail);\n+\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2597,1 +2597,0 @@\n-        ret = true;\n@@ -2599,11 +2598,1 @@\n-         if (*async_tail == '\\0') {\n-          \/\/ Default is to drop.\n-          LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n-        } else if (strcmp(async_tail, \":stall\") == 0) {\n-          LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Stall);\n-        } else if (strcmp(async_tail, \":drop\") == 0) {\n-          LogConfiguration::set_async_mode(LogConfiguration::AsyncMode::Drop);\n-        } else {\n-          \/\/ User provided unknown async option\n-          ret = false;\n-        }\n+        ret = LogConfiguration::parse_async_argument(async_tail);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"}]}