[{"commit":{"message":"Merge branch 'master' into cleanup_indoff"},"files":[{"filename":"src\/hotspot\/cpu\/arm\/arm.ad"},{"filename":"src\/hotspot\/cpu\/ppc\/ppc.ad"},{"filename":"src\/hotspot\/cpu\/riscv\/riscv.ad"},{"filename":"src\/hotspot\/cpu\/x86\/x86.ad"},{"filename":"src\/hotspot\/share\/opto\/output.cpp"}],"sha":"b76cae363a00aeefaf6a2c600886fa6e76672b2b"},{"commit":{"message":"Update the copyright year and code comments"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad"},{"filename":"src\/hotspot\/cpu\/arm\/arm.ad"},{"filename":"src\/hotspot\/cpu\/ppc\/ppc.ad"},{"filename":"src\/hotspot\/cpu\/riscv\/riscv.ad"},{"filename":"src\/hotspot\/cpu\/s390\/s390.ad"},{"filename":"src\/hotspot\/cpu\/x86\/x86.ad"},{"filename":"src\/hotspot\/share\/opto\/matcher.hpp"},{"filename":"src\/hotspot\/share\/opto\/output.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnalignedAccess.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestImplicitNullCheckWithLargeOffset.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestZGCLoadStoreWithLargeOffset.java"}],"sha":"3f12b1c8a84040923ff8c26f1ab58714458e2af9"},{"commit":{"message":"Merge branch 'master' into cleanup_indoff"},"files":[],"sha":"bfa90fde941c366b0e5e2968f9a096e76839ddd7"},{"commit":{"message":"8341611: [REDO] AArch64: Clean up IndOffXX type and let legitimize_address() fix out-of-range operands\n\nIndOffXX types don't do us any good. It would be simpler and\nfaster to match a general-purpose IndOff type then let\nlegitimize_address() fix any out-of-range operands. That'd\nreduce the size of the match rules and the time to run them.\n\nThis patch simplifies the definitions of `immXOffset` with an\nestimated range. Whether an immediate can be encoded in a\nLDR\/STR instructions as an offset will be determined in the phase\nof code-emitting. Meanwhile, we add necessary\n`legitimize_address()` in the phase of matcher for all LDR\/STR\ninstructions using the new `IndOff` memory operands\n(fix JDK-8341437).\n\nAfter this clean-up, memory operands matched with `IndOff` may\nrequire extra code emission (effectively a lea) before the address\ncan be used. So we also modify the code about looking up precise\noffset of load\/store instruction for implicit null check\n(fix JDK-8340646). On aarch64 platform, we will use the beginning\noffset of the last instruction in the instruction clause emitted\nfor a load\/store machine node. Because LDR\/STR is always the last\none emitted, no matter what addressing mode the load\/store\noperations finally use.\n\nTier 1 - 3 passed on Macos-aarch64 with or without the vm option\n\"-XX:+UseZGC\""},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"src\/hotspot\/cpu\/aarch64\/ad_encode.m4"},{"filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad"},{"filename":"src\/hotspot\/cpu\/arm\/arm.ad"},{"filename":"src\/hotspot\/cpu\/ppc\/ppc.ad"},{"filename":"src\/hotspot\/cpu\/riscv\/riscv.ad"},{"filename":"src\/hotspot\/cpu\/s390\/s390.ad"},{"filename":"src\/hotspot\/cpu\/x86\/x86.ad"},{"filename":"src\/hotspot\/share\/opto\/matcher.hpp"},{"filename":"src\/hotspot\/share\/opto\/output.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnalignedAccess.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestImplicitNullCheckWithLargeOffset.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestZGCLoadStoreWithLargeOffset.java"}],"sha":"699417f896e6767aa308c6d5408ac2e0109b7738"}]