{"files":[{"patch":"@@ -36,1 +36,1 @@\n-public class HierarchicalLayoutManager extends LayoutManager {\n+public class HierarchicalLayoutManager extends LayoutManager implements LayoutMover {\n@@ -80,0 +80,56 @@\n+    @Override\n+    public void moveLink(Point linkPos, int shiftX) {\n+        int layerNr = graph.findLayer(linkPos.y);\n+        for (LayoutNode node : graph.getLayer(layerNr)) {\n+            if (node.isDummy() && linkPos.x == node.getX()) {\n+                LayoutLayer layer = graph.getLayer(layerNr);\n+                if (layer.contains(node)) {\n+                    node.setX(linkPos.x + shiftX);\n+                    layer.sortNodesByX();\n+                    break;\n+                }\n+            }\n+        }\n+        writeBack();\n+    }\n+\n+    @Override\n+    public void moveVertices(Set<? extends Vertex> movedVertices) {\n+        for (Vertex vertex : movedVertices) {\n+            moveVertex(vertex);\n+        }\n+        writeBack();\n+    }\n+\n+    private void writeBack() {\n+        graph.optimizeBackEdgeCrossings();\n+        graph.updateLayerMinXSpacing();\n+        graph.straightenEdges();\n+        WriteResult.apply(graph);\n+    }\n+\n+    @Override\n+    public void moveVertex(Vertex movedVertex) {\n+        Point newLoc = movedVertex.getPosition();\n+        LayoutNode movedNode = graph.getLayoutNode(movedVertex);\n+        assert !movedNode.isDummy();\n+\n+        int layerNr = graph.findLayer(newLoc.y + movedNode.getOuterHeight() \/ 2);\n+        if (movedNode.getLayer() == layerNr) { \/\/ we move the node in the same layer\n+            LayoutLayer layer = graph.getLayer(layerNr);\n+            if (layer.contains(movedNode)) {\n+                movedNode.setX(newLoc.x);\n+                layer.sortNodesByX();\n+            }\n+        } else { \/\/ only remove edges if we moved the node to a new layer\n+            if (maxLayerLength > 0) return; \/\/ TODO: not implemented\n+            graph.removeNodeAndEdges(movedNode);\n+            layerNr = graph.insertNewLayerIfNeeded(movedNode, layerNr);\n+            graph.addNodeToLayer(movedNode, layerNr);\n+            movedNode.setX(newLoc.x);\n+            graph.getLayer(layerNr).sortNodesByX();\n+            graph.removeEmptyLayers();\n+            graph.addEdges(movedNode, maxLayerLength);\n+        }\n+    }\n+  \n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -172,0 +172,18 @@\n+    \/**\n+     * Gets the absolute x-coordinate of the source node's connection point for this edge.\n+     *\n+     * @return The x-coordinate of the source node's connection point.\n+     *\/\n+    public int getFromX() {\n+        return from.getX() + getRelativeFromX();\n+    }\n+\n+    \/**\n+     * Gets the absolute x-coordinate of the target node's connection point for this edge.\n+     *\n+     * @return The x-coordinate of the target node's connection point.\n+     *\/\n+    public int getToX() {\n+        return to.getX() + getRelativeToX();\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutEdge.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutNode.NODE_POS_COMPARATOR;\n@@ -55,0 +56,2 @@\n+    private final LinkedHashMap<Vertex, Set<Port>> outputPorts;\n+    private final LinkedHashMap<Port, Set<Link>> portLinks;\n@@ -72,1 +75,1 @@\n-        LinkedHashMap<Port, Set<Link>> portLinks = new LinkedHashMap<>(links.size());\n+        portLinks = new LinkedHashMap<>(links.size());\n@@ -74,1 +77,1 @@\n-        LinkedHashMap<Vertex, Set<Port>> outputPorts = new LinkedHashMap<>(links.size());\n+        outputPorts = new LinkedHashMap<>(links.size());\n@@ -178,0 +181,108 @@\n+    \/**\n+     * Creates a new layer at the specified index in the layers list.\n+     * Adjusts the layer numbers of existing nodes in layers below the inserted layer.\n+     *\n+     * @param layerNr The index at which to insert the new layer.\n+     * @return The newly created LayoutLayer.\n+     *\/\n+    private LayoutLayer createNewLayer(int layerNr) {\n+        LayoutLayer layer = new LayoutLayer();\n+        layers.add(layerNr, layer);\n+\n+        \/\/ update layer field in nodes below layerNr\n+        for (int l = layerNr + 1; l < getLayerCount(); l++) {\n+            for (LayoutNode layoutNode : getLayer(l)) {\n+                layoutNode.setLayer(l);\n+            }\n+        }\n+        return layer;\n+    }\n+\n+    \/**\n+     * Deletes the layer at the specified index.\n+     * Adjusts the layer numbers of existing nodes in layers below the deleted layer.\n+     *\n+     * @param layerNr The index of the layer to delete.\n+     *\/\n+    private void deleteLayer(int layerNr) {\n+        layers.remove(layerNr);\n+\n+        \/\/ Update the layer field in nodes below the deleted layer\n+        for (int l = layerNr; l < getLayerCount(); l++) {\n+            for (LayoutNode layoutNode : getLayer(l)) {\n+                layoutNode.setLayer(l);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Ensures that no neighboring nodes of the specified node are in the same layer.\n+     * If any neighbor is found in the specified layer, inserts a new layer to avoid conflicts.\n+     * Returns the adjusted layer number where the node can be safely inserted.\n+     *\n+     * @param node    The LayoutNode to check and possibly reposition.\n+     * @param layerNr The proposed layer number for the node.\n+     * @return The layer number where the node can be safely inserted after adjustments.\n+     *\/\n+    public int insertNewLayerIfNeeded(LayoutNode node, int layerNr) {\n+        for (Link inputLink : getInputLinks(node.getVertex())) {\n+            if (inputLink.getFrom().getVertex() == inputLink.getTo().getVertex()) continue;\n+            LayoutNode fromNode = getLayoutNode(inputLink.getFrom().getVertex());\n+            if (fromNode.getLayer() == layerNr) {\n+                moveExpandLayerDown(layerNr + 1);\n+                return layerNr + 1;\n+            }\n+        }\n+        for (Link outputLink : getOutputLinks(node.getVertex())) {\n+            if (outputLink.getFrom().getVertex() == outputLink.getTo().getVertex()) continue;\n+            LayoutNode toNode = getLayoutNode(outputLink.getTo().getVertex());\n+            if (toNode.getLayer() == layerNr) {\n+                moveExpandLayerDown(layerNr);\n+                return layerNr;\n+            }\n+        }\n+        return layerNr;\n+\n+    }\n+\n+    \/**\n+     * Inserts a new layer at the specified index and adjusts nodes and edges accordingly.\n+     * Moves existing nodes and their successors down to accommodate the new layer.\n+     *\n+     * @param layerNr The index at which to insert the new layer.\n+     *\/\n+    private void moveExpandLayerDown(int layerNr) {\n+        LayoutLayer newLayer = createNewLayer(layerNr);\n+\n+        if (layerNr == 0) return;\n+        LayoutLayer layerAbove = getLayer(layerNr - 1);\n+\n+        for (LayoutNode fromNode : layerAbove) {\n+            int fromX = fromNode.getX();\n+            Map<Integer, List<LayoutEdge>> successorsByX = fromNode.groupSuccessorsByX();\n+            fromNode.clearSuccessors();\n+\n+            for (Map.Entry<Integer, List<LayoutEdge>> entry : successorsByX.entrySet()) {\n+                Integer relativeFromX = entry.getKey();\n+                List<LayoutEdge> edges = entry.getValue();\n+                LayoutNode dummyNode = new LayoutNode();\n+                dummyNode.setX(fromX + relativeFromX);\n+                dummyNode.setLayer(layerNr);\n+                for (LayoutEdge edge : edges) {\n+                    dummyNode.addSuccessor(edge);\n+                }\n+                LayoutEdge dummyEdge = new LayoutEdge(fromNode, dummyNode, relativeFromX, 0, edges.get(0).getLink());\n+                if (edges.get(0).isReversed()) dummyEdge.reverse();\n+\n+                fromNode.addSuccessor(dummyEdge);\n+                dummyNode.addPredecessor(dummyEdge);\n+                for (LayoutEdge edge : edges) {\n+                    edge.setFrom(dummyNode);\n+                }\n+                addDummyToLayer(dummyNode, layerNr);\n+            }\n+        }\n+\n+        newLayer.sortNodesByX();\n+    }\n+\n@@ -196,0 +307,25 @@\n+    \/**\n+     * Retrieves the LayoutNode associated with the specified Vertex.\n+     *\n+     * @param vertex The vertex whose LayoutNode is to be retrieved.\n+     * @return The LayoutNode corresponding to the given vertex, or null if not found.\n+     *\/\n+    public LayoutNode getLayoutNode(Vertex vertex) {\n+        return layoutNodes.get(vertex);\n+    }\n+\n+    \/**\n+     * Adds a LayoutNode to the specified layer and registers it in the graph.\n+     *\n+     * @param node        The LayoutNode to add to the layer.\n+     * @param layerNumber The index of the layer to which the node will be added.\n+     *\/\n+    public void addNodeToLayer(LayoutNode node, int layerNumber) {\n+        assert !node.isDummy();\n+        node.setLayer(layerNumber);\n+        getLayer(layerNumber).add(node);\n+        if (!layoutNodes.containsKey(node.getVertex())) {\n+            layoutNodes.put(node.getVertex(), node);\n+        }\n+    }\n+\n@@ -286,0 +422,142 @@\n+    \/**\n+     * Retrieves all incoming links to the specified vertex.\n+     *\n+     * @param vertex The vertex whose incoming links are to be retrieved.\n+     * @return A set of links that are incoming to the vertex.\n+     *\/\n+    public List<Link> getInputLinks(Vertex vertex) {\n+        List<Link> inputLinks = new ArrayList<>();\n+        for (Port inputPort : inputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            inputLinks.addAll(portLinks.getOrDefault(inputPort, Collections.emptySet()));\n+        }\n+        return inputLinks;\n+    }\n+\n+    \/**\n+     * Retrieves all outgoing links from the specified vertex.\n+     *\n+     * @param vertex The vertex whose outgoing links are to be retrieved.\n+     * @return A set of links that are outgoing from the vertex.\n+     *\/\n+    public List<Link> getOutputLinks(Vertex vertex) {\n+        List<Link> outputLinks = new ArrayList<>();\n+        for (Port outputPort : outputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            outputLinks.addAll(portLinks.getOrDefault(outputPort, Collections.emptySet()));\n+        }\n+        return outputLinks;\n+    }\n+\n+    public List<Link> getAllLinks(Vertex vertex) {\n+        List<Link> allLinks = new ArrayList<>();\n+\n+        for (Port inputPort : inputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            allLinks.addAll(portLinks.getOrDefault(inputPort, Collections.emptySet()));\n+        }\n+\n+        for (Port outputPort : outputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            allLinks.addAll(portLinks.getOrDefault(outputPort, Collections.emptySet()));\n+        }\n+\n+        return allLinks;\n+    }\n+\n+    \/**\n+     * Removes the specified LayoutNode and all its connected edges from the graph.\n+     *\n+     * @param node The LayoutNode to remove along with its edges.\n+     *\/\n+    public void removeNodeAndEdges(LayoutNode node) {\n+        assert !node.isDummy();\n+        removeEdges(node); \/\/ a node can only be removed together with its edges\n+        int layer = node.getLayer();\n+        layers.get(layer).remove(node);\n+        layers.get(layer).updateNodeIndices();\n+        layoutNodes.remove(node.getVertex());\n+    }\n+\n+    \/**\n+     * Removes all edges connected to the specified LayoutNode.\n+     * Handles the removal of associated dummy nodes if they are no longer needed.\n+     * Updates the graph structure accordingly after node movement.\n+     *\n+     * @param node The LayoutNode whose connected edges are to be removed.\n+     *\/\n+    public void removeEdges(LayoutNode node) {\n+        assert !node.isDummy();\n+        for (Link link : getAllLinks(node.getVertex())) {\n+            removeEdge(link);\n+        }\n+    }\n+\n+    public void removeEdge(Link link) {\n+        Vertex from = link.getFrom().getVertex();\n+        Vertex to = link.getTo().getVertex();\n+        LayoutNode toNode = getLayoutNode(to);\n+        LayoutNode fromNode = getLayoutNode(from);\n+\n+        if (toNode.getLayer() < fromNode.getLayer()) {\n+            \/\/ Reversed edge\n+            toNode = fromNode;\n+        }\n+\n+        \/\/ Remove preds-edges bottom up, starting at \"to\" node\n+        \/\/ Cannot start from \"from\" node since there might be joint edges\n+        List<LayoutEdge> toNodePredsEdges = List.copyOf(toNode.getPredecessors());\n+        for (LayoutEdge edge : toNodePredsEdges) {\n+            LayoutNode predNode = edge.getFrom();\n+            LayoutEdge edgeToRemove;\n+\n+            if (edge.getLink() != null && edge.getLink().equals(link)) {\n+                toNode.removePredecessor(edge);\n+                edgeToRemove = edge;\n+            } else {\n+                \/\/ Wrong edge, look at next\n+                continue;\n+            }\n+\n+            if (!predNode.isDummy() && predNode.getVertex().equals(from)) {\n+                \/\/ No dummy nodes inbetween 'from' and 'to' vertex\n+                predNode.removeSuccessor(edgeToRemove);\n+                break;\n+            } else {\n+                \/\/ Must remove edges between dummy nodes\n+                boolean found = true;\n+                LayoutNode succNode = toNode;\n+                while (predNode.isDummy() && found) {\n+                    found = false;\n+\n+                    if (predNode.getSuccessors().size() <= 1 && predNode.getPredecessors().size() <= 1) {\n+                        \/\/ Dummy node used only for this link, remove if not already removed\n+                        assert predNode.isDummy();\n+                        int layer = predNode.getLayer();\n+                        layers.get(layer).remove(predNode);\n+                        layers.get(layer).updateNodeIndices();\n+                        dummyNodes.remove(predNode);\n+                    } else {\n+                        \/\/ anchor node, should not be removed\n+                        break;\n+                    }\n+\n+                    if (predNode.getPredecessors().size() == 1) {\n+                        predNode.removeSuccessor(edgeToRemove);\n+                        succNode = predNode;\n+                        edgeToRemove = predNode.getPredecessors().get(0);\n+                        predNode = edgeToRemove.getFrom();\n+                        found = true;\n+                    }\n+                }\n+\n+                predNode.removeSuccessor(edgeToRemove);\n+                succNode.removePredecessor(edgeToRemove);\n+            }\n+            break;\n+        }\n+\n+        if (fromNode.getReversedLinkStartPoints().containsKey(link)) {\n+            fromNode.computeReversedLinkPoints(false);\n+        }\n+        if (toNode.getReversedLinkStartPoints().containsKey(link)) {\n+            toNode.computeReversedLinkPoints(false);\n+        }\n+    }\n+\n@@ -296,0 +574,24 @@\n+    \/**\n+     * Finds the layer closest to the given y-coordinate.\n+     *\n+     * @param y the y-coordinate to check\n+     * @return the index of the optimal layer, or -1 if no layers are found\n+     *\/\n+    public int findLayer(int y) {\n+        int optimalLayer = -1;\n+        int minDistance = Integer.MAX_VALUE;\n+        for (int l = 0; l < getLayerCount(); l++) {\n+            \/\/ Check if y is within this layer's bounds\n+            if (y >= getLayer(l).getTop() && y <= getLayer(l).getBottom()) {\n+                return l;\n+            }\n+\n+            int distance = Math.abs(getLayer(l).getCenter() - y);\n+            if (distance < minDistance) {\n+                minDistance = distance;\n+                optimalLayer = l;\n+            }\n+        }\n+        return optimalLayer;\n+    }\n+\n@@ -317,0 +619,374 @@\n+    \/**\n+     * Optimizes routing of reversed (back) edges to reduce crossings.\n+     *\/\n+    public void optimizeBackEdgeCrossings() {\n+        for (LayoutNode node : getLayoutNodes()) {\n+            node.optimizeBackEdgeCrossing();\n+        }\n+    }\n+\n+    \/**\n+     * Removes empty layers from the graph.\n+     * Iteratively checks for and removes layers that contain only dummy nodes.\n+     *\/\n+    public void removeEmptyLayers() {\n+        int i = 0;\n+        while (i < getLayerCount()) {\n+            LayoutLayer layer = getLayer(i);\n+            if (layer.containsOnlyDummyNodes()) {\n+                removeEmptyLayer(i);\n+            } else {\n+                i++; \/\/ Move to the next layer only if no removal occurred\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Removes the layer at the specified index if it is empty or contains only dummy nodes.\n+     * Adjusts the positions of nodes and edges accordingly.\n+     *\n+     * @param layerNr The index of the layer to remove.\n+     *\/\n+    private void removeEmptyLayer(int layerNr) {\n+        LayoutLayer layer = getLayer(layerNr);\n+        if (!layer.containsOnlyDummyNodes()) return;\n+\n+        for (LayoutNode dummyNode : layer) {\n+            if (dummyNode.getSuccessors().isEmpty()) {\n+                dummyNode.setLayer(layerNr + 1);\n+                getLayer(layerNr + 1).add(dummyNode);\n+                dummyNode.setX(dummyNode.calculateOptimalXFromPredecessors(true));\n+                getLayer(layerNr + 1).sortNodesByX();\n+                continue;\n+            } else if (dummyNode.getPredecessors().isEmpty()) {\n+                dummyNode.setLayer(layerNr - 1);\n+                dummyNode.setX(dummyNode.calculateOptimalXFromSuccessors(true));\n+                getLayer(layerNr - 1).add(dummyNode);\n+                getLayer(layerNr - 1).sortNodesByX();\n+                continue;\n+            }\n+            LayoutEdge layoutEdge = dummyNode.getPredecessors().get(0);\n+\n+            \/\/ remove the layoutEdge\n+            LayoutNode fromNode = layoutEdge.getFrom();\n+            fromNode.removeSuccessor(layoutEdge);\n+\n+            List<LayoutEdge> successorEdges = dummyNode.getSuccessors();\n+            for (LayoutEdge successorEdge : successorEdges) {\n+                successorEdge.setRelativeFromX(layoutEdge.getRelativeFromX());\n+                successorEdge.setFrom(fromNode);\n+                fromNode.addSuccessor(successorEdge);\n+            }\n+            dummyNode.clearPredecessors();\n+            dummyNode.clearSuccessors();\n+            dummyNodes.remove(dummyNode);\n+        }\n+\n+        deleteLayer(layerNr);\n+    }\n+\n+    \/**\n+     * Repositions the specified LayoutNode horizontally within its layer to the new x-coordinate.\n+     * Ensures no overlap with adjacent nodes and maintains minimum spacing.\n+     *\n+     * @param layoutNode The LayoutNode to reposition.\n+     * @param newX       The new x-coordinate to set for the node.\n+     *\/\n+    private void repositionLayoutNodeX(LayoutNode layoutNode, int newX) {\n+        int currentX = layoutNode.getX();\n+\n+        \/\/ Early exit if the desired position is the same as the current position\n+        if (newX == currentX) {\n+            return;\n+        }\n+\n+        LayoutLayer layer = getLayer(layoutNode.getLayer());\n+        if (newX > currentX) {\n+            layer.tryShiftNodeRight(layoutNode, newX);\n+        } else {\n+            layer.tryShiftNodeLeft(layoutNode, newX);\n+        }\n+    }\n+\n+    \/**\n+     * Aligns the x-coordinate of a single dummy successor node for the given LayoutNode.\n+     * If the node has exactly one successor and that successor is a dummy node,\n+     * sets the dummy node's x-coordinate to align with the current node or the edge's starting point.\n+     *\n+     * @param node The LayoutNode whose dummy successor is to be aligned.\n+     *\/\n+    private void alignSingleSuccessorDummyNodeX(LayoutNode node) {\n+        \/\/ Retrieve the list of successor edges\n+        List<LayoutEdge> successors = node.getSuccessors();\n+\n+        \/\/ Proceed only if there is exactly one successor\n+        if (successors.size() != 1) {\n+            return;\n+        }\n+\n+        LayoutEdge successorEdge = successors.get(0);\n+        LayoutNode successorNode = successorEdge.getTo();\n+\n+        \/\/ Proceed only if the successor node is a dummy node\n+        if (!successorNode.isDummy()) {\n+            return;\n+        }\n+\n+        \/\/ Determine the target x-coordinate based on whether the current node is a dummy\n+        int targetX = node.isDummy() ? node.getX() : successorEdge.getStartX();\n+\n+        \/\/ Align the successor dummy node to the target x-coordinate\n+        repositionLayoutNodeX(successorNode, targetX);\n+    }\n+\n+    \/**\n+     * Aligns the x-coordinates of dummy successor nodes within the specified layer.\n+     * Performs alignment in both forward and backward directions to ensure consistency.\n+     *\n+     * @param layer The LayoutLayer whose nodes' dummy successors need alignment.\n+     *\/\n+    private void alignLayerDummySuccessors(LayoutLayer layer) {\n+        \/\/ Forward pass: Align dummy successors from the first node to the last.\n+        for (LayoutNode node : layer) {\n+            alignSingleSuccessorDummyNodeX(node);\n+        }\n+\n+        \/\/ Backward pass: Align dummy successors from the last node to the first.\n+        for (int i = layer.size() - 1; i >= 0; i--) {\n+            LayoutNode node = layer.get(i);\n+            alignSingleSuccessorDummyNodeX(node);\n+        }\n+    }\n+\n+    \/**\n+     * Straightens edges in the graph by aligning dummy nodes to reduce bends.\n+     * Processes all layers to align dummy successor nodes.\n+     *\/\n+    public void straightenEdges() {\n+        \/\/ Forward pass: Align dummy successors from the first layer to the last.\n+        for (int i = 0; i < getLayerCount(); i++) {\n+            alignLayerDummySuccessors(getLayer(i));\n+        }\n+\n+        \/\/ Backward pass: Align dummy successors from the last layer to the first.\n+        for (int i = getLayerCount() - 1; i >= 0; i--) {\n+            alignLayerDummySuccessors(getLayer(i));\n+        }\n+    }\n+\n+    \/**\n+     * Updates the minimum X spacing for all layers in the graph.\n+     *\/\n+    public void updateLayerMinXSpacing() {\n+        for (LayoutLayer layer : this.getLayers()) {\n+            layer.updateMinXSpacing(false);\n+        }\n+    }\n+\n+    \/**\n+     * Calculates the optimal horizontal position (index) for the specified node within the given layer,\n+     * aiming to minimize the number of edge crossings.\n+     *\n+     * @param node    The node to position.\n+     * @param layerNr The index of the layer in which to position the node.\n+     * @return The optimal position index within the layer for the node.\n+     *\/\n+    private int optimalPosition(LayoutNode node, int layerNr) {\n+        getLayer(layerNr).sort(NODE_POS_COMPARATOR);\n+        int edgeCrossings = Integer.MAX_VALUE;\n+        int optimalPos = -1;\n+\n+        \/\/ Try each possible position in the layerNr\n+        for (int i = 0; i < getLayer(layerNr).size() + 1; i++) {\n+            int xCoord;\n+            if (i == 0) {\n+                xCoord = getLayer(layerNr).get(i).getX() - node.getWidth() - 1;\n+            } else {\n+                xCoord = getLayer(layerNr).get(i - 1).getX() + getLayer(layerNr).get(i - 1).getWidth() + 1;\n+            }\n+\n+            int currentCrossings = 0;\n+\n+            if (0 <= layerNr - 1) {\n+                \/\/ For each link with an end point in vertex, check how many edges cross it\n+                for (LayoutEdge edge : node.getPredecessors()) {\n+                    if (edge.getFrom().getLayer() == layerNr - 1) {\n+                        int fromNodeXCoord = edge.getFromX();\n+                        int toNodeXCoord = xCoord;\n+                        if (!node.isDummy()) {\n+                            toNodeXCoord += edge.getRelativeToX();\n+                        }\n+                        for (LayoutNode n : getLayer(layerNr - 1)) {\n+                            for (LayoutEdge e : n.getSuccessors()) {\n+                                if (e.getTo() == null) {\n+                                    continue;\n+                                }\n+                                int compFromXCoord = e.getFromX();\n+                                int compToXCoord = e.getToX();\n+                                if ((fromNodeXCoord > compFromXCoord && toNodeXCoord < compToXCoord)\n+                                        || (fromNodeXCoord < compFromXCoord\n+                                        && toNodeXCoord > compToXCoord)) {\n+                                    currentCrossings += 1;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            \/\/ Edge crossings across current layerNr and layerNr below\n+            if (layerNr + 1 < getLayerCount()) {\n+                \/\/ For each link with an end point in vertex, check how many edges cross it\n+                for (LayoutEdge edge : node.getSuccessors()) {\n+                    if (edge.getTo().getLayer() == layerNr + 1) {\n+                        int toNodeXCoord = edge.getToX();\n+                        int fromNodeXCoord = xCoord;\n+                        if (!node.isDummy()) {\n+                            fromNodeXCoord += edge.getRelativeFromX();\n+                        }\n+                        for (LayoutNode n : getLayer(layerNr + 1)) {\n+                            for (LayoutEdge e : n.getPredecessors()) {\n+                                if (e.getFrom() == null) {\n+                                    continue;\n+                                }\n+                                int compFromXCoord = e.getFromX();\n+                                int compToXCoord = e.getToX();\n+                                if ((fromNodeXCoord > compFromXCoord && toNodeXCoord < compToXCoord)\n+                                        || (fromNodeXCoord < compFromXCoord\n+                                        && toNodeXCoord > compToXCoord)) {\n+                                    currentCrossings += 1;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if (currentCrossings <= edgeCrossings) {\n+                edgeCrossings = currentCrossings;\n+                optimalPos = i;\n+            }\n+        }\n+        return optimalPos;\n+    }\n+\n+    \/**\n+     * Creates layout edges for the specified node and reverses edges as needed.\n+     * Reverses edges that go from lower to higher layers to maintain proper layering.\n+     *\n+     * @param node The LayoutNode for which to create and reverse edges.\n+     *\/\n+    public void createAndReverseLayoutEdges(LayoutNode node) {\n+        List<Link> nodeLinks = new ArrayList<>(getInputLinks(node.getVertex()));\n+        nodeLinks.addAll(getOutputLinks(node.getVertex()));\n+        nodeLinks.sort(LINK_COMPARATOR);\n+\n+        List<LayoutNode> reversedLayoutNodes = new ArrayList<>();\n+        for (Link link : nodeLinks) {\n+            if (link.getFrom().getVertex() == link.getTo().getVertex()) continue;\n+            LayoutEdge layoutEdge = createLayoutEdge(link);\n+\n+            LayoutNode fromNode = layoutEdge.getFrom();\n+            LayoutNode toNode = layoutEdge.getTo();\n+\n+            if (fromNode.getLayer() > toNode.getLayer()) {\n+                HierarchicalLayoutManager.ReverseEdges.reverseEdge(layoutEdge);\n+                reversedLayoutNodes.add(fromNode);\n+                reversedLayoutNodes.add(toNode);\n+            }\n+        }\n+\n+        \/\/ ReverseEdges\n+        for (LayoutNode layoutNode : reversedLayoutNodes) {\n+            layoutNode.computeReversedLinkPoints(false);\n+        }\n+    }\n+\n+    \/**\n+     * Inserts dummy nodes along the edges from predecessors of the specified node,\n+     * for edges that span more than one layer.\n+     *\n+     * @param layoutNode The node for which to create predecessor dummy nodes.\n+     *\/\n+    public void createDummiesForNodePredecessor(LayoutNode layoutNode) {\n+        for (LayoutEdge predEdge : layoutNode.getPredecessors()) {\n+            LayoutNode fromNode = predEdge.getFrom();\n+            LayoutNode toNode = predEdge.getTo();\n+            if (Math.abs(toNode.getLayer() - fromNode.getLayer()) <= 1) continue;\n+\n+            boolean hasEdgeFromSamePort = false;\n+            LayoutEdge edgeFromSamePort = new LayoutEdge(fromNode, toNode, predEdge.getLink());\n+            if (predEdge.isReversed()) edgeFromSamePort.reverse();\n+\n+            for (LayoutEdge succEdge : fromNode.getSuccessors()) {\n+                if (succEdge.getRelativeFromX() == predEdge.getRelativeFromX() && succEdge.getTo().isDummy()) {\n+                    edgeFromSamePort = succEdge;\n+                    hasEdgeFromSamePort = true;\n+                    break;\n+                }\n+            }\n+\n+            if (hasEdgeFromSamePort) {\n+                LayoutEdge curEdge = edgeFromSamePort;\n+                boolean newEdge = true;\n+                while (curEdge.getTo().getLayer() < toNode.getLayer() - 1 && curEdge.getTo().isDummy() && newEdge) {\n+                    \/\/ Traverse down the chain of dummy nodes linking together the edges originating\n+                    \/\/ from the same port\n+                    newEdge = false;\n+                    if (curEdge.getTo().getSuccessors().size() == 1) {\n+                        curEdge = curEdge.getTo().getSuccessors().get(0);\n+                        newEdge = true;\n+                    } else {\n+                        for (LayoutEdge e : curEdge.getTo().getSuccessors()) {\n+                            if (e.getTo().isDummy()) {\n+                                curEdge = e;\n+                                newEdge = true;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                LayoutNode prevDummy;\n+                if (!curEdge.getTo().isDummy()) {\n+                    prevDummy = curEdge.getFrom();\n+                } else {\n+                    prevDummy = curEdge.getTo();\n+                }\n+\n+                predEdge.setFrom(prevDummy);\n+                predEdge.setRelativeFromX(prevDummy.getWidth() \/ 2);\n+                fromNode.removeSuccessor(predEdge);\n+                prevDummy.addSuccessor(predEdge);\n+            }\n+\n+            LayoutNode layoutNode1 = predEdge.getTo();\n+            if (predEdge.getTo().getLayer() - 1 > predEdge.getFrom().getLayer()) {\n+                LayoutEdge prevEdge = predEdge;\n+                for (int l = layoutNode1.getLayer() - 1; l > prevEdge.getFrom().getLayer(); l--) {\n+                    LayoutNode dummyNode = new LayoutNode();\n+                    dummyNode.addSuccessor(prevEdge);\n+                    LayoutEdge result = new LayoutEdge(prevEdge.getFrom(), dummyNode, prevEdge.getRelativeFromX(), 0, prevEdge.getLink());\n+                    if (prevEdge.isReversed()) result.reverse();\n+                    dummyNode.addPredecessor(result);\n+                    prevEdge.setRelativeFromX(0);\n+                    prevEdge.getFrom().removeSuccessor(prevEdge);\n+                    prevEdge.getFrom().addSuccessor(result);\n+                    prevEdge.setFrom(dummyNode);\n+                    dummyNode.setLayer(l);\n+                    List<LayoutNode> layerNodes = getLayer(l);\n+                    if (layerNodes.isEmpty()) {\n+                        dummyNode.setPos(0);\n+                    } else {\n+                        dummyNode.setPos(optimalPosition(dummyNode, l));\n+                    }\n+                    for (LayoutNode n : layerNodes) {\n+                        if (n.getPos() >= dummyNode.getPos()) {\n+                            n.setPos(n.getPos() + 1);\n+                        }\n+                    }\n+                    addDummyToLayer(dummyNode, l);\n+                    prevEdge = dummyNode.getPredecessors().get(0);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -433,0 +1109,16 @@\n+\n+    \/**\n+     * Adds edges connected to the specified node, including any necessary dummy nodes.\n+     * Handles edge reversal, dummy node insertion for both predecessors and successors,\n+     * and updates node positions accordingly.\n+     *\n+     * @param node           The LayoutNode to which edges will be added.\n+     * @param maxLayerLength The maximum number of layers an edge can span without splitting it\n+     *\/\n+    public void addEdges(LayoutNode node, int maxLayerLength) {\n+        assert !node.isDummy();\n+        createAndReverseLayoutEdges(node);\n+        createDummiesForNodeSuccessor(node, maxLayerLength);\n+        createDummiesForNodePredecessor(node);\n+        updatePositions();\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutGraph.java","additions":695,"deletions":3,"binary":false,"changes":698,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,0 +157,4 @@\n+    public int getCenter() {\n+        return y + height \/ 2;\n+    }\n+\n@@ -184,0 +188,47 @@\n+    \/**\n+     * Checks if this layer contains only dummy nodes.\n+     *\n+     * @return true if all nodes in the layer are dummy nodes; false otherwise.\n+     *\/\n+    public boolean containsOnlyDummyNodes() {\n+        for (LayoutNode node : this) {\n+            if (!node.isDummy()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Sorts the nodes in this layer by their X-coordinate in increasing order.\n+     * Assigns position indices to nodes based on the sorted order.\n+     * Adjusts the X-coordinates of nodes to ensure minimum spacing between them.\n+     *\/\n+    public void sortNodesByX() {\n+        if (isEmpty()) return;\n+\n+        sort(NODE_X_COMPARATOR); \/\/ Sort nodes in the layer increasingly by x\n+\n+        updateNodeIndices();\n+        updateMinXSpacing(false);\n+    }\n+\n+    \/**\n+     * Ensures nodes have minimum horizontal spacing by adjusting their X positions.\n+     *\n+     * @param startFromZero if true, starts positioning from X = 0; otherwise, uses the first node's current X.\n+     *\/\n+    public void updateMinXSpacing(boolean startFromZero) {\n+        if (isEmpty()) {\n+            return; \/\/ No nodes to adjust.\n+        }\n+\n+        int minX = startFromZero ? 0 : this.get(0).getX();\n+\n+        for (LayoutNode node : this) {\n+            int x = Math.max(node.getX(), minX);\n+            node.setX(x);\n+            minX = x + node.getOuterWidth() + NODE_OFFSET;\n+        }\n+    }\n+\n@@ -206,0 +257,56 @@\n+\n+    \/**\n+     * Attempts to move the specified node to the right within the layer to the given X-coordinate.\n+     * Ensures that the node does not overlap with its right neighbor by checking required spacing.\n+     * If movement is possible without causing overlap, the node's X-coordinate is updated.\n+     *\n+     * @param layoutNode The node to move.\n+     * @param newX       The desired new X-coordinate for the node.\n+     *\/\n+    public void tryShiftNodeRight(LayoutNode layoutNode, int newX) {\n+        int currentX = layoutNode.getX();\n+        int shiftAmount = newX - currentX;\n+        int rightPos = layoutNode.getPos() + 1;\n+\n+        if (rightPos < size()) {\n+            \/\/ There is a right neighbor\n+            LayoutNode rightNeighbor = get(rightPos);\n+            int proposedRightEdge = layoutNode.getRight() + shiftAmount;\n+            int requiredLeftEdge = rightNeighbor.getOuterLeft() - NODE_OFFSET;\n+\n+            if (proposedRightEdge <= requiredLeftEdge) {\n+                layoutNode.setX(newX);\n+            }\n+        } else {\n+            \/\/ No right neighbor; safe to move freely to the right\n+            layoutNode.setX(newX);\n+        }\n+    }\n+\n+    \/**\n+     * Attempts to move the specified node to the left within the layer to the given X-coordinate.\n+     * Ensures that the node does not overlap with its left neighbor by checking required spacing.\n+     * If movement is possible without causing overlap, the node's X-coordinate is updated.\n+     *\n+     * @param layoutNode The node to move.\n+     * @param newX       The desired new X-coordinate for the node.\n+     *\/\n+    public void tryShiftNodeLeft(LayoutNode layoutNode, int newX) {\n+        int currentX = layoutNode.getX();\n+        int shiftAmount = currentX - newX;\n+        int leftPos = layoutNode.getPos() - 1;\n+\n+        if (leftPos >= 0) {\n+            \/\/ There is a left neighbor\n+            LayoutNode leftNeighbor = get(leftPos);\n+            int proposedLeftEdge = layoutNode.getLeft() - shiftAmount;\n+            int requiredRightEdge = leftNeighbor.getOuterRight() + NODE_OFFSET;\n+\n+            if (requiredRightEdge <= proposedLeftEdge) {\n+                layoutNode.setX(newX);\n+            }\n+        } else {\n+            \/\/ No left neighbor; safe to move freely to the left\n+            layoutNode.setX(newX);\n+        }\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutLayer.java","additions":108,"deletions":1,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.awt.Point;\n+import java.util.Set;\n+\n+public interface LayoutMover {\n+    \/**\n+     * Moves a link by shifting its position along the X-axis.\n+     *\n+     * @param linkPos The current position of the link.\n+     * @param shiftX  The amount to shift the link along the X-axis.\n+     *\/\n+    void moveLink(Point linkPos, int shiftX);\n+\n+    \/**\n+     * Moves a set of vertices.\n+     *\n+     * @param movedVertices A set of vertices to be moved.\n+     *\/\n+    void moveVertices(Set<? extends Vertex> movedVertices);\n+\n+    \/**\n+     * Moves a single vertex.\n+     *\n+     * @param movedVertex The vertex to be moved.\n+     *\/\n+    void moveVertex(Vertex movedVertex);\n+}\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutMover.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -72,0 +72,1 @@\n+    private boolean reverseLeft = false;\n@@ -253,0 +254,67 @@\n+    \/**\n+     * Gets the outer left boundary (including left margin) of the node.\n+     *\n+     * @return The x-coordinate of the outer left boundary.\n+     *\/\n+    public int getOuterLeft() {\n+        return x;\n+    }\n+\n+    \/**\n+     * Gets the total width of the node, including left and right margins.\n+     *\n+     * @return The total outer width.\n+     *\/\n+    public int getOuterWidth() {\n+        return leftMargin + width + rightMargin;\n+    }\n+\n+    \/**\n+     * Gets the total height of the node, including top and bottom margins.\n+     *\n+     * @return The total outer height.\n+     *\/\n+    public int getOuterHeight() {\n+        return topMargin + height + bottomMargin;\n+    }\n+\n+    public int getHeight() {\n+        return height;\n+    }\n+\n+    \/**\n+     * Gets the right boundary (excluding right margin) of the node.\n+     *\n+     * @return The x-coordinate of the right boundary.\n+     *\/\n+    public int getRight() {\n+        return x + leftMargin + width;\n+    }\n+\n+    \/**\n+     * Gets the outer right boundary (including right margin) of the node.\n+     *\n+     * @return The x-coordinate of the outer right boundary.\n+     *\/\n+    public int getOuterRight() {\n+        return x + leftMargin + width + rightMargin;\n+    }\n+\n+    \/**\n+     * Calculates the total degree of the node (sum of in-degree and out-degree).\n+     *\n+     * @return The total degree of the node.\n+     *\/\n+    public int getDegree() {\n+        return preds.size() + succs.size();\n+    }\n+\n+    \/**\n+     * Gets the left boundary (excluding left margin) of the node.\n+     *\n+     * @return The x-coordinate of the left boundary.\n+     *\/\n+    public int getLeft() {\n+        return x + leftMargin;\n+    }\n+\n@@ -439,0 +507,44 @@\n+    \/**\n+     * Groups the successor edges by their relative x-coordinate from the current node.\n+     *\n+     * @return A map of relative x-coordinate to list of successor edges.\n+     *\/\n+    public Map<Integer, List<LayoutEdge>> groupSuccessorsByX() {\n+        Map<Integer, List<LayoutEdge>> result = new HashMap<>();\n+        for (LayoutEdge succEdge : succs) {\n+            result.computeIfAbsent(succEdge.getRelativeFromX(), k -> new ArrayList<>()).add(succEdge);\n+        }\n+        return result;\n+    }\n+\n+    private int getBackedgeCrossingScore() {\n+        int score = 0;\n+        for (LayoutEdge predEdge : preds) {\n+            if (predEdge.isReversed()) {\n+                List<Point> points = reversedLinkEndPoints.get(predEdge.getLink());\n+                if (points != null) {\n+                    int x0 = points.get(points.size() - 1).x;\n+                    int xn = points.get(0).x;\n+                    int startPoint = predEdge.getStartX();\n+                    int endPoint = predEdge.getEndX();\n+                    int win = (x0 < xn) ? (startPoint - endPoint) : (endPoint - startPoint);\n+                    score += win;\n+                }\n+            }\n+        }\n+        for (LayoutEdge succEdge : succs) {\n+            if (succEdge.isReversed()) {\n+                List<Point> points = reversedLinkStartPoints.get(succEdge.getLink());\n+                if (points != null) {\n+                    int x0 = points.get(points.size() - 1).x;\n+                    int xn = points.get(0).x;\n+                    int startPoint = succEdge.getStartX();\n+                    int endPoint = succEdge.getEndX();\n+                    int win = (x0 > xn) ? (startPoint - endPoint) : (endPoint - startPoint);\n+                    score += win;\n+                }\n+            }\n+        }\n+        return score;\n+    }\n+\n@@ -521,1 +633,3 @@\n-        initSize();\n+        this.reverseLeft = reverseLeft;\n+\n+      initSize();\n@@ -526,0 +640,15 @@\n+        boolean hasReversedUP = computeReversedEndPoints(hasReversedDown != reverseLeft);\n+    }\n+\n+    public boolean isReverseRight() {\n+        return !reverseLeft;\n+    }\n+\n+    public void optimizeBackEdgeCrossing() {\n+        if (reversedLinkStartPoints.isEmpty() && reversedLinkEndPoints.isEmpty()) return;\n+        int orig_score = getBackedgeCrossingScore();\n+        computeReversedLinkPoints(isReverseRight());\n+        int reverse_score = getBackedgeCrossingScore();\n+        if (orig_score > reverse_score) {\n+            computeReversedLinkPoints(isReverseRight());\n+        }\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutNode.java","additions":130,"deletions":1,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+    private final Widget shadowWidget;\n+    private final Widget pointerWidget;\n@@ -88,0 +90,2 @@\n+    private final Map<OutputSlot, Set<LineWidget>> outputSlotToLineWidget = new HashMap<>();\n+    private final Map<InputSlot, Set<LineWidget>> inputSlotToLineWidget = new HashMap<>();\n@@ -90,1 +94,1 @@\n-\n+    private LayoutMover layoutMover;\n@@ -344,0 +348,6 @@\n+        pointerWidget = new Widget(DiagramScene.this);\n+        addChild(pointerWidget);\n+\n+        shadowWidget = new Widget(DiagramScene.this);\n+        addChild(shadowWidget);\n+\n@@ -599,0 +609,157 @@\n+    private MoveProvider getFigureMoveProvider() {\n+        return new MoveProvider() {\n+\n+            private boolean hasMoved = false; \/\/ Flag to track movement\n+            private int startLayerY;\n+\n+            private void setFigureShadow(Figure f) {\n+                FigureWidget fw = getWidget(f);\n+                Color c = f.getColor();\n+                Border border = new FigureWidget.RoundedBorder(new Color(0,0,0, 50), 1);\n+                shadowWidget.setBorder(border);\n+                shadowWidget.setBackground(new Color(c.getRed(), c.getGreen(), c.getBlue(), 50));\n+                shadowWidget.setPreferredLocation(fw.getPreferredLocation());\n+                shadowWidget.setPreferredSize(f.getSize());\n+                shadowWidget.setVisible(true);\n+                shadowWidget.setOpaque(true);\n+                shadowWidget.revalidate();\n+                shadowWidget.repaint();\n+            }\n+\n+            private void setMovePointer(Figure f) {\n+                Border border = new FigureWidget.RoundedBorder(Color.RED, 1);\n+                pointerWidget.setBorder(border);\n+                pointerWidget.setBackground(Color.RED);\n+                pointerWidget.setPreferredBounds(new Rectangle(0, 0, 3, f.getSize().height));\n+                pointerWidget.setVisible(false);\n+                pointerWidget.setOpaque(true);\n+            }\n+\n+\n+            @Override\n+            public void movementStarted(Widget widget) {\n+                if (layoutMover == null) return; \/\/ Do nothing if layoutMover is not available\n+\n+                widget.bringToFront();\n+                startLayerY = widget.getLocation().y;\n+                hasMoved = false; \/\/ Reset the movement flag\n+                Set<Figure> selectedFigures = model.getSelectedFigures();\n+                if (selectedFigures.size() == 1) {\n+                    Figure selectedFigure = selectedFigures.iterator().next();\n+                    setFigureShadow(selectedFigure);\n+                    setMovePointer(selectedFigure);\n+                }\n+            }\n+\n+            @Override\n+            public void movementFinished(Widget widget) {\n+                shadowWidget.setVisible(false);\n+                pointerWidget.setVisible(false);\n+                if (layoutMover == null || !hasMoved) return; \/\/ Do nothing if layoutMover is not available or no movement occurred\n+                rebuilding = true;\n+\n+                Set<Figure> movedFigures = new HashSet<>(model.getSelectedFigures());\n+                for (Figure figure : movedFigures) {\n+                    FigureWidget fw = getWidget(figure);\n+                    figure.setPosition(new Point(fw.getLocation().x, fw.getLocation().y));\n+                }\n+\n+                layoutMover.moveVertices(movedFigures);\n+                rebuildConnectionLayer();\n+\n+                for (FigureWidget fw : getVisibleFigureWidgets()) {\n+                    fw.updatePosition();\n+                }\n+\n+                validateAll();\n+                addUndo();\n+                rebuilding = false;\n+            }\n+\n+            private static final int MAGNET_SIZE = 5;\n+\n+            private int magnetToStartLayerY(Widget widget, Point location) {\n+                int shiftY = location.y - widget.getLocation().y;\n+                if (Math.abs(location.y - startLayerY) <= MAGNET_SIZE) {\n+                    if (Math.abs(widget.getLocation().y - startLayerY) > MAGNET_SIZE) {\n+                        shiftY = startLayerY - widget.getLocation().y;\n+                    } else {\n+                        shiftY = 0;\n+                    }\n+                }\n+                return shiftY;\n+            }\n+\n+            @Override\n+            public Point getOriginalLocation(Widget widget) {\n+                if (layoutMover == null) return widget.getLocation(); \/\/ default behavior\n+                return ActionFactory.createDefaultMoveProvider().getOriginalLocation(widget);\n+            }\n+\n+            @Override\n+            public void setNewLocation(Widget widget, Point location) {\n+                if (layoutMover == null) return; \/\/ Do nothing if layoutMover is not available\n+                hasMoved = true; \/\/ Mark that a movement occurred\n+\n+                int shiftX = location.x - widget.getLocation().x;\n+                int shiftY = magnetToStartLayerY(widget, location);\n+\n+                List<Figure> selectedFigures = new ArrayList<>( model.getSelectedFigures());\n+                selectedFigures.sort(Comparator.comparingInt(f -> f.getPosition().x));\n+                for (Figure figure : selectedFigures) {\n+                    FigureWidget fw = getWidget(figure);\n+                    for (InputSlot inputSlot : figure.getInputSlots()) {\n+                        assert inputSlot != null;\n+                        if (inputSlotToLineWidget.containsKey(inputSlot)) {\n+                            for (LineWidget lw : inputSlotToLineWidget.get(inputSlot)) {\n+                                assert lw != null;\n+                                Point toPt = lw.getTo();\n+                                Point fromPt = lw.getFrom();\n+                                if (toPt != null && fromPt != null) {\n+                                    int xTo = toPt.x + shiftX;\n+                                    int yTo = toPt.y + shiftY;\n+                                    lw.setTo(new Point(xTo, yTo));\n+                                    lw.setFrom(new Point(fromPt.x + shiftX, fromPt.y));\n+                                    LineWidget pred = lw.getPredecessor();\n+                                    pred.setTo(new Point(pred.getTo().x + shiftX, pred.getTo().y));\n+                                    pred.revalidate();\n+                                    lw.revalidate();\n+                                }\n+                            }\n+                        }\n+                    }\n+                    for (OutputSlot outputSlot : figure.getOutputSlots()) {\n+                        assert outputSlot != null;\n+                        if (outputSlotToLineWidget.containsKey(outputSlot)) {\n+                            for (LineWidget lw : outputSlotToLineWidget.get(outputSlot)) {\n+                                assert lw != null;\n+                                Point fromPt = lw.getFrom();\n+                                Point toPt = lw.getTo();\n+                                if (toPt != null && fromPt != null) {\n+                                    int xFrom = fromPt.x + shiftX;\n+                                    int yFrom = fromPt.y + shiftY;\n+                                    lw.setFrom(new Point(xFrom, yFrom));\n+                                    lw.setTo(new Point(toPt.x + shiftX, toPt.y));\n+                                    for (LineWidget succ : lw.getSuccessors()) {\n+                                        succ.setFrom(new Point(succ.getFrom().x + shiftX, succ.getFrom().y));\n+                                        succ.revalidate();\n+                                    }\n+                                    lw.revalidate();\n+                                }\n+                            }\n+                        }\n+                    }\n+                    Point newLocation = new Point(fw.getLocation().x + shiftX, fw.getLocation().y + shiftY);\n+                    ActionFactory.createDefaultMoveProvider().setNewLocation(fw, newLocation);\n+                }\n+\n+                FigureWidget fw = getWidget(selectedFigures.iterator().next());\n+                pointerWidget.setVisible(true);\n+                Point newLocation = new Point(fw.getLocation().x + shiftX -3, fw.getLocation().y + shiftY);\n+                ActionFactory.createDefaultMoveProvider().setNewLocation(pointerWidget, newLocation);\n+                connectionLayer.revalidate();\n+                connectionLayer.repaint();\n+            }\n+        };\n+    }\n+\n@@ -607,0 +774,1 @@\n+            figureWidget.getActions().addAction(ActionFactory.createMoveAction(null, getFigureMoveProvider()));\n@@ -665,1 +833,0 @@\n-        validateAll();\n@@ -667,2 +834,0 @@\n-        Set<Figure> visibleFigures = getVisibleFigures();\n-        Set<Connection> visibleConnections = getVisibleConnections();\n@@ -678,5 +843,1 @@\n-        rebuildConnectionLayer();\n-\n-        updateFigureWidgetLocations(oldVisibleFigureWidgets);\n-        updateBlockWidgetBounds(oldVisibleBlockWidgets);\n-        validateAll();\n+      \n@@ -740,0 +901,1 @@\n+        layoutMover = null;\n@@ -752,0 +914,1 @@\n+        layoutMover = seaLayoutManager;\n@@ -757,0 +920,1 @@\n+        layoutMover = null;\n@@ -763,0 +927,1 @@\n+        layoutMover = null;\n@@ -780,0 +945,78 @@\n+    private MoveProvider getFigureConnectionMoveProvider() {\n+        return new MoveProvider() {\n+\n+            Point startLocation;\n+            Point originalPosition;\n+\n+            @Override\n+            public void movementStarted(Widget widget) {\n+                if (layoutMover == null) return; \/\/ Do nothing if layoutMover is not available\n+                LineWidget lw = (LineWidget) widget;\n+                startLocation = lw.getClientAreaLocation();\n+                originalPosition = lw.getFrom();\n+            }\n+\n+            @Override\n+            public void movementFinished(Widget widget) {\n+                if (layoutMover == null) return; \/\/ Do nothing if layoutMover is not available\n+                LineWidget lineWidget = (LineWidget) widget;\n+                if (lineWidget.getPredecessor() == null) return;\n+                if (lineWidget.getSuccessors().isEmpty()) return;\n+                if (lineWidget.getFrom().x != lineWidget.getTo().x) return;\n+\n+                int shiftX = lineWidget.getClientAreaLocation().x - startLocation.x;\n+                if (shiftX == 0) return;\n+\n+                rebuilding = true;\n+                layoutMover.moveLink(originalPosition, shiftX);\n+                rebuildConnectionLayer();\n+                for (FigureWidget fw : getVisibleFigureWidgets()) {\n+                    fw.updatePosition();\n+                }\n+                validateAll();\n+                addUndo();\n+                rebuilding = false;\n+            }\n+\n+            @Override\n+            public Point getOriginalLocation(Widget widget) {\n+                if (layoutMover == null) return widget.getLocation(); \/\/ default behavior\n+                LineWidget lineWidget = (LineWidget) widget;\n+                return lineWidget.getClientAreaLocation();\n+            }\n+\n+            @Override\n+            public void setNewLocation(Widget widget, Point location) {\n+                if (layoutMover == null) return; \/\/ Do nothing if layoutMover is not available\n+                LineWidget lineWidget = (LineWidget) widget;\n+                if (lineWidget.getPredecessor() == null) return;\n+                if (lineWidget.getSuccessors().isEmpty()) return;\n+                if (lineWidget.getFrom().x != lineWidget.getTo().x) return;\n+\n+                int shiftX = location.x - lineWidget.getClientAreaLocation().x;\n+                if (shiftX == 0) return;\n+\n+                Point oldFrom = lineWidget.getFrom();\n+                Point newFrom = new Point(oldFrom.x + shiftX, oldFrom.y);\n+\n+                Point oldTo = lineWidget.getTo();\n+                Point newTo = new Point(oldTo.x + shiftX, oldTo.y);\n+\n+                lineWidget.setTo(newTo);\n+                lineWidget.setFrom(newFrom);\n+                lineWidget.revalidate();\n+\n+                LineWidget predecessor = lineWidget.getPredecessor();\n+                Point toPt = predecessor.getTo();\n+                predecessor.setTo(new Point(toPt.x + shiftX, toPt.y));\n+                predecessor.revalidate();\n+\n+                for (LineWidget successor : lineWidget.getSuccessors()) {\n+                    Point fromPt = successor.getFrom();\n+                    successor.setFrom(new Point(fromPt.x + shiftX, fromPt.y));\n+                    successor.revalidate();\n+                }\n+            }\n+        };\n+    }\n+\n@@ -827,0 +1070,1 @@\n+                    assert outputSlot != null;\n@@ -837,0 +1081,1 @@\n+                newPredecessor.getActions().addAction(ActionFactory.createMoveAction(null, getFigureConnectionMoveProvider()));\n@@ -846,4 +1091,7 @@\n-                    if (inputSlotToLineWidget.containsKey(inputSlot)) {\n-                        inputSlotToLineWidget.get(inputSlot).add(predecessor);\n-                    } else {\n-                        inputSlotToLineWidget.put(inputSlot, new HashSet<>(Collections.singleton(predecessor)));\n+                    if (predecessor != null) {\n+                        assert inputSlot != null;\n+                        if (inputSlotToLineWidget.containsKey(inputSlot)) {\n+                            inputSlotToLineWidget.get(inputSlot).add(predecessor);\n+                        } else {\n+                            inputSlotToLineWidget.put(inputSlot, new HashSet<>(Collections.singleton(predecessor)));\n+                        }\n@@ -1215,3 +1463,0 @@\n-    Map<OutputSlot, Set<LineWidget>> outputSlotToLineWidget = new HashMap<>();\n-    Map<InputSlot, Set<LineWidget>> inputSlotToLineWidget = new HashMap<>();\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":261,"deletions":16,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -188,0 +188,4 @@\n+    public void updatePosition() {\n+        setPreferredLocation(figure.getPosition());\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/FigureWidget.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-    private final Point from;\n-    private final Point to;\n+    private Point from;\n+    private Point to;\n@@ -128,0 +128,4 @@\n+    public Point getClientAreaLocation() {\n+        return clientArea.getLocation();\n+    }\n+\n@@ -161,0 +165,10 @@\n+    public void setFrom(Point from) {\n+        this.from = from;\n+        computeClientArea();\n+    }\n+\n+    public void setTo(Point to) {\n+        this.to= to;\n+        computeClientArea();\n+    }\n+\n@@ -169,0 +183,8 @@\n+    public LineWidget getPredecessor() {\n+        return predecessor;\n+    }\n+\n+    public List<LineWidget> getSuccessors() {\n+        return Collections.unmodifiableList(successors);\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"}]}