{"files":[{"patch":"@@ -0,0 +1,395 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.crypto.provider;\n+\n+import sun.security.jca.JCAUtil;\n+import sun.security.ssl.HKDF;\n+import sun.security.util.*;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.interfaces.*;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+\/\/ Implementing DHKEM defined inside https:\/\/www.rfc-editor.org\/rfc\/rfc9180.html,\n+\/\/ without the AuthEncap and AuthDecap functions\n+public class DHKEM implements KEMSpi {\n+\n+    private static final byte[] KEM = new byte[]\n+            {'K', 'E', 'M'};\n+    private static final byte[] EAE_PRK = new byte[]\n+            {'e', 'a', 'e', '_', 'p', 'r', 'k'};\n+    private static final byte[] SHARED_SECRET = new byte[]\n+            {'s', 'h', 'a', 'r', 'e', 'd', '_', 's', 'e', 'c', 'r', 'e', 't'};\n+    private static final byte[] DKP_PRK = new byte[]\n+            {'d', 'k', 'p', '_', 'p', 'r', 'k'};\n+    private static final byte[] CANDIDATE = new byte[]\n+            {'c', 'a', 'n', 'd', 'i', 'd', 'a', 't', 'e'};\n+    private static final byte[] SK = new byte[]\n+            {'s', 'k'};\n+    private static final byte[] HPKE_V1 = new byte[]\n+            {'H', 'P', 'K', 'E', '-', 'v', '1'};\n+    private static final byte[] EMPTY = new byte[0];\n+\n+    private record Handler(Params params, SecureRandom secureRandom,\n+                           PrivateKey skR, PublicKey pkR)\n+                implements EncapsulatorSpi, DecapsulatorSpi {\n+\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm) {\n+            Objects.checkFromToIndex(from, to, params.Nsecret);\n+            Objects.requireNonNull(algorithm, \"null algorithm\");\n+            KeyPair kpE = params.generateKeyPair(secureRandom);\n+            PrivateKey skE = kpE.getPrivate();\n+            PublicKey pkE = kpE.getPublic();\n+            byte[] pkEm = params.SerializePublicKey(pkE);\n+            byte[] pkRm = params.SerializePublicKey(pkR);\n+            byte[] kem_context = concat(pkEm, pkRm);\n+            try {\n+                byte[] dh = params.DH(skE, pkR);\n+                byte[] key = params.ExtractAndExpand(dh, kem_context);\n+                return new KEM.Encapsulated(\n+                        new SecretKeySpec(key, from, to - from, algorithm),\n+                        pkEm, null);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation,\n+                int from, int to, String algorithm) throws DecapsulateException {\n+            Objects.checkFromToIndex(from, to, params.Nsecret);\n+            Objects.requireNonNull(algorithm, \"null algorithm\");\n+            Objects.requireNonNull(encapsulation, \"null encapsulation\");\n+            if (encapsulation.length != params.Npk) {\n+                throw new DecapsulateException(\"incorrect encapsulation size\");\n+            }\n+            try {\n+                PublicKey pkE = params.DeserializePublicKey(encapsulation);\n+                byte[] dh = params.DH(skR, pkE);\n+                byte[] pkRm = params.SerializePublicKey(pkR);\n+                byte[] kem_context = concat(encapsulation, pkRm);\n+                byte[] key = params.ExtractAndExpand(dh, kem_context);\n+                return new SecretKeySpec(key, from, to - from, algorithm);\n+            } catch (IOException | InvalidKeyException e) {\n+                throw new DecapsulateException(\"Cannot decapsulate\", e);\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            return params.Nsecret;\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            return params.Npk;\n+        }\n+    }\n+\n+    \/\/ Not really a random. For KAT test only. It generates key pair from ikm.\n+    public static class RFC9180DeriveKeyPairSR extends SecureRandom {\n+\n+        static final long serialVersionUID = 0L;\n+\n+        private final byte[] ikm;\n+\n+        public RFC9180DeriveKeyPairSR(byte[] ikm) {\n+            super(null, null); \/\/ lightest constructor\n+            this.ikm = ikm;\n+        }\n+\n+        public KeyPair derive(Params params) {\n+            try {\n+                return params.deriveKeyPair(ikm);\n+            } catch (Exception e) {\n+                throw new UnsupportedOperationException(e);\n+            }\n+        }\n+\n+        public KeyPair derive(int kem_id) {\n+            Params params = Arrays.stream(Params.values())\n+                    .filter(p -> p.kem_id == kem_id)\n+                    .findFirst()\n+                    .orElseThrow();\n+            return derive(params);\n+        }\n+    }\n+\n+    private enum Params {\n+\n+        P256(0x10, 32, 32, 2 * 32 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_256, \"SHA-256\"),\n+\n+        P384(0x11, 48, 48, 2 * 48 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_384, \"SHA-384\"),\n+\n+        P521(0x12, 64, 66, 2 * 66 + 1,\n+                \"ECDH\", \"EC\", CurveDB.P_521, \"SHA-512\"),\n+\n+        X25519(0x20, 32, 32, 32,\n+                \"XDH\", \"XDH\", NamedParameterSpec.X25519, \"SHA-256\"),\n+\n+        X448(0x21, 64, 56, 56,\n+                \"XDH\", \"XDH\", NamedParameterSpec.X448, \"SHA-512\"),\n+        ;\n+\n+        private final int kem_id;\n+        private final int Nsecret;\n+        private final int Nsk;\n+        private final int Npk;\n+        private final String kaAlgorithm;\n+        private final String keyAlgorithm;\n+        private final AlgorithmParameterSpec spec;\n+        private final String hkdfAlgorithm;\n+\n+        private final byte[] suiteId;\n+\n+        Params(int kem_id, int Nsecret, int Nsk, int Npk,\n+                String kaAlgorithm, String keyAlgorithm, AlgorithmParameterSpec spec,\n+                String hkdfAlgorithm) {\n+            this.kem_id = kem_id;\n+            this.spec = spec;\n+            this.Nsecret = Nsecret;\n+            this.Nsk = Nsk;\n+            this.Npk = Npk;\n+            this.kaAlgorithm = kaAlgorithm;\n+            this.keyAlgorithm = keyAlgorithm;\n+            this.hkdfAlgorithm = hkdfAlgorithm;\n+            suiteId = concat(KEM, I2OSP(kem_id, 2));\n+        }\n+\n+        private boolean isEC() {\n+            return this == P256 || this == P384 || this == P521;\n+        }\n+\n+        private KeyPair generateKeyPair(SecureRandom sr) {\n+            if (sr instanceof RFC9180DeriveKeyPairSR r9) {\n+                return r9.derive(this);\n+            }\n+            try {\n+                KeyPairGenerator g = KeyPairGenerator.getInstance(keyAlgorithm);\n+                g.initialize(spec, sr);\n+                return g.generateKeyPair();\n+            } catch (Exception e) {\n+                throw new ProviderException(\"internal error\", e);\n+            }\n+        }\n+\n+        private byte[] SerializePublicKey(PublicKey k) {\n+            if (isEC()) {\n+                ECPoint w = ((ECPublicKey) k).getW();\n+                return ECUtil.encodePoint(w, ((NamedCurve) spec).getCurve());\n+            } else {\n+                byte[] uArray = ((XECPublicKey) k).getU().toByteArray();\n+                ArrayUtil.reverse(uArray);\n+                return Arrays.copyOf(uArray, Npk);\n+            }\n+        }\n+\n+        private PublicKey DeserializePublicKey(byte[] data)\n+                throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\n+            KeySpec keySpec;\n+            if (isEC()) {\n+                NamedCurve curve = (NamedCurve) this.spec;\n+                keySpec = new ECPublicKeySpec(\n+                        ECUtil.decodePoint(data, curve.getCurve()), curve);\n+            } else {\n+                data = data.clone();\n+                ArrayUtil.reverse(data);\n+                keySpec = new XECPublicKeySpec(\n+                        this.spec, new BigInteger(1, data));\n+            }\n+            return KeyFactory.getInstance(keyAlgorithm).generatePublic(keySpec);\n+        }\n+\n+        private byte[] DH(PrivateKey skE, PublicKey pkR)\n+                throws NoSuchAlgorithmException, InvalidKeyException {\n+            KeyAgreement ka = KeyAgreement.getInstance(kaAlgorithm);\n+            ka.init(skE);\n+            ka.doPhase(pkR, true);\n+            return ka.generateSecret();\n+        }\n+\n+        private byte[] ExtractAndExpand(byte[] dh, byte[] kem_context)\n+                throws NoSuchAlgorithmException, InvalidKeyException {\n+            HKDF kdf = new HKDF(hkdfAlgorithm);\n+            SecretKey eae_prk = LabeledExtract(kdf, suiteId, null, EAE_PRK, dh);\n+            return LabeledExpand(kdf, suiteId, eae_prk, SHARED_SECRET,\n+                    kem_context, Nsecret);\n+        }\n+\n+        private PublicKey getPublicKey(PrivateKey sk)\n+                throws InvalidKeyException {\n+            if (!(sk instanceof InternalPrivateKey)) {\n+                try {\n+                    KeyFactory kf = KeyFactory.getInstance(keyAlgorithm, \"SunEC\");\n+                    sk = (PrivateKey) kf.translateKey(sk);\n+                } catch (Exception e) {\n+                    throw new InvalidKeyException(\"Error translating key\", e);\n+                }\n+            }\n+            if (sk instanceof InternalPrivateKey ik) {\n+                try {\n+                    return ik.calculatePublicKey();\n+                } catch (UnsupportedOperationException e) {\n+                    throw new InvalidKeyException(\"Error retrieving key\", e);\n+                }\n+            } else {\n+                \/\/ Should not happen, unless SunEC goes wrong\n+                throw new ProviderException(\"Unknown key\");\n+            }\n+        }\n+\n+        \/\/ For KAT tests only. See RFC9180DeriveKeyPairSR.\n+        public KeyPair deriveKeyPair(byte[] ikm) throws Exception {\n+            HKDF kdf = new HKDF(hkdfAlgorithm);\n+            SecretKey dkp_prk = LabeledExtract(kdf, suiteId, null, DKP_PRK, ikm);\n+            if (isEC()) {\n+                NamedCurve curve = (NamedCurve) spec;\n+                BigInteger sk = BigInteger.ZERO;\n+                int counter = 0;\n+                while (sk.signum() == 0 || sk.compareTo(curve.getOrder()) >= 0) {\n+                    if (counter > 255) {\n+                        throw new RuntimeException();\n+                    }\n+                    byte[] bytes = LabeledExpand(kdf, suiteId, dkp_prk,\n+                            CANDIDATE, I2OSP(counter, 1), Nsk);\n+                    \/\/ bitmask is defined to be 0xFF for P-256 and P-384, and 0x01 for P-521\n+                    if (this == Params.P521) {\n+                        bytes[0] = (byte) (bytes[0] & 0x01);\n+                    }\n+                    sk = new BigInteger(1, (bytes));\n+                    counter = counter + 1;\n+                }\n+                PrivateKey k = DeserializePrivateKey(sk.toByteArray());\n+                return new KeyPair(getPublicKey(k), k);\n+            } else {\n+                byte[] sk = LabeledExpand(kdf, suiteId, dkp_prk, SK, EMPTY, Nsk);\n+                PrivateKey k = DeserializePrivateKey(sk);\n+                return new KeyPair(getPublicKey(k), k);\n+            }\n+        }\n+\n+        private PrivateKey DeserializePrivateKey(byte[] data) throws Exception {\n+            KeySpec keySpec = isEC()\n+                    ? new ECPrivateKeySpec(new BigInteger(1, (data)), (NamedCurve) spec)\n+                    : new XECPrivateKeySpec(spec, data);\n+            return KeyFactory.getInstance(keyAlgorithm).generatePrivate(keySpec);\n+        }\n+    }\n+\n+    private static SecureRandom getSecureRandom(SecureRandom userSR) {\n+        return userSR != null ? userSR : JCAUtil.getSecureRandom();\n+    }\n+\n+    @Override\n+    public EncapsulatorSpi engineNewEncapsulator(\n+            PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (pk == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(pk);\n+        return new Handler(params, getSecureRandom(secureRandom), null, pk);\n+    }\n+\n+    @Override\n+    public DecapsulatorSpi engineNewDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (sk == null) {\n+            throw new InvalidKeyException(\"input key is null\");\n+        }\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"no spec needed\");\n+        }\n+        Params params = paramsFromKey(sk);\n+        return new Handler(params, null, sk, params.getPublicKey(sk));\n+    }\n+\n+    private Params paramsFromKey(Key k) throws InvalidKeyException {\n+        if (k instanceof ECKey eckey) {\n+            if (ECUtil.equals(eckey.getParams(), CurveDB.P_256)) {\n+                return Params.P256;\n+            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_384)) {\n+                return Params.P384;\n+            } else if (ECUtil.equals(eckey.getParams(), CurveDB.P_521)) {\n+                return Params.P521;\n+            }\n+        } else if (k instanceof XECKey xkey\n+                && xkey.getParams() instanceof NamedParameterSpec ns) {\n+            if (ns.getName().equals(\"X25519\")) {\n+                return Params.X25519;\n+            } else if (ns.getName().equals(\"X448\")) {\n+                return Params.X448;\n+            }\n+        }\n+        throw new InvalidKeyException(\"Unsupported key\");\n+    }\n+\n+    private static byte[] concat(byte[]... inputs) {\n+        ByteArrayOutputStream o = new ByteArrayOutputStream();\n+        Arrays.stream(inputs).forEach(o::writeBytes);\n+        return o.toByteArray();\n+    }\n+\n+    private static byte[] I2OSP(int n, int w) {\n+        assert n < 256;\n+        assert w == 1 || w == 2;\n+        if (w == 1) {\n+            return new byte[] { (byte) n };\n+        } else {\n+            return new byte[] { (byte) (n >> 8), (byte) n };\n+        }\n+    }\n+\n+    private static SecretKey LabeledExtract(HKDF kdf, byte[] suite_id,\n+            byte[] salt, byte[] label, byte[] ikm) throws InvalidKeyException {\n+        return kdf.extract(salt,\n+                new SecretKeySpec(concat(HPKE_V1, suite_id, label, ikm), \"IKM\"),\n+                    \"HKDF-PRK\");\n+    }\n+\n+    private static byte[] LabeledExpand(HKDF kdf, byte[] suite_id,\n+            SecretKey prk, byte[] label, byte[] info, int L)\n+            throws InvalidKeyException {\n+        byte[] labeled_info = concat(I2OSP(L, 2), HPKE_V1,\n+                suite_id, label, info);\n+        return kdf.expand(prk, labeled_info, L, \"NONE\").getEncoded();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKEM.java","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -746,0 +746,9 @@\n+        \/*\n+         * KEMs\n+         *\/\n+        attrs.clear();\n+        attrs.put(\"ImplementedIn\", \"Software\");\n+        attrs.put(\"SupportedKeyClasses\", \"java.security.interfaces.ECKey\" +\n+                \"|java.security.interfaces.XECKey\");\n+        ps(\"KEM\", \"DHKEM\", \"com.sun.crypto.provider.DHKEM\", null, attrs);\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1602,0 +1602,1 @@\n+        addEngine(\"KEM\",                                true,  null);\n","filename":"src\/java.base\/share\/classes\/java\/security\/Provider.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto;\n+\n+import java.security.GeneralSecurityException;\n+\n+\/**\n+ * An exception that is thrown by the\n+ * {@link javax.crypto.KEM.Decapsulator#decapsulate} method to denote an\n+ * error during decapsulation.\n+ *\n+ * @since 21\n+ *\/\n+public class DecapsulateException extends GeneralSecurityException {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = 21L;\n+\n+    \/**\n+     * Creates a {@code DecapsulateException} with the specified\n+     * detail message.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link #getMessage()} method).\n+     *\/\n+    public DecapsulateException(String message) {\n+        super(message);\n+    }\n+\n+    \/**\n+     * Creates a {@code DecapsulateException} with the specified\n+     * detail message and cause.\n+     *\n+     * @param message the detail message (which is saved for later retrieval\n+     *        by the {@link #getMessage()} method).\n+     * @param cause the cause (which is saved for later retrieval by the\n+     *        {@link #getCause()} method).  (A {@code null} value is permitted,\n+     *        and indicates that the cause is nonexistent or unknown.)\n+     *\/\n+    public DecapsulateException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/DecapsulateException.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,737 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto;\n+\n+import sun.security.jca.GetInstance;\n+\n+import java.security.*;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * This class provides the functionality of a Key Encapsulation Mechanism (KEM).\n+ * A KEM can be used to secure symmetric keys using asymmetric or public key\n+ * cryptography between two parties. The sender calls the encapsulate method\n+ * to generate a secret key and a key encapsulation message, and the receiver\n+ * calls the decapsulate method to recover the same secret key from\n+ * the key encapsulation message.\n+ * <p>\n+ * The {@code getInstance} method creates a new {@code KEM} object that\n+ * implements the specified algorithm.\n+ * <p>\n+ * A {@code KEM} object is immutable. It is safe to call multiple\n+ * {@code newEncapsulator} and {@code newDecapsulator} methods on the\n+ * same {@code KEM} object at the same time.\n+ * <p>\n+ * If a provider is not specified in the {@code getInstance} method when\n+ * instantiating a {@code KEM} object, the {@code newEncapsulator} and\n+ * {@code newDecapsulator} methods may return encapsulators or decapsulators\n+ * from different providers. The provider selected is based on the parameters\n+ * passed to the {@code newEncapsulator} or {@code newDecapsulator} methods:\n+ * the private or public key and the optional {@code AlgorithmParameterSpec}.\n+ * The {@link Encapsulator#providerName} and {@link Decapsulator#providerName}\n+ * methods return the name of the selected provider.\n+ * <p>\n+ * {@code Encapsulator} and {@code Decapsulator} objects are also immutable.\n+ * It is safe to invoke multiple {@code encapsulate} and {@code decapsulate}\n+ * methods on the same {@code Encapsulator} or {@code Decapsulator} object\n+ * at the same time. Each invocation of {@code encapsulate} will generate a\n+ * new shared secret and key encapsulation message.\n+ * <p>\n+ *\n+ * Example:\n+ * {@snippet lang = java:\n+ *    \/\/ Receiver side\n+ *    var kpg = KeyPairGenerator.getInstance(\"X25519\");\n+ *    var kp = kpg.generateKeyPair();\n+ *\n+ *    \/\/ Sender side\n+ *    var kem1 = KEM.getInstance(\"DHKEM\");\n+ *    var sender = kem1.newEncapsulator(kp.getPublic());\n+ *    var encapsulated = sender.encapsulate();\n+ *    var k1 = encapsulated.key();\n+ *\n+ *    \/\/ Receiver side\n+ *    var kem2 = KEM.getInstance(\"DHKEM\");\n+ *    var receiver = kem2.newDecapsulator(kp.getPrivate());\n+ *    var k2 = receiver.decapsulate(encapsulated.encapsulation());\n+ *\n+ *    assert Arrays.equals(k1.getEncoded(), k2.getEncoded());\n+ * }\n+ *\n+ * @since 21\n+ *\/\n+public final class KEM {\n+\n+    \/**\n+     * This class specifies the return value of the encapsulate method of\n+     * a Key Encapsulation Mechanism (KEM), which includes the shared secret\n+     * (as a {@code SecretKey}), the key encapsulation message,\n+     * and optional parameters.\n+     * <p>\n+     * Note: the key encapsulation message can be also referred to as ciphertext.\n+     *\n+     * @see #newEncapsulator(PublicKey, AlgorithmParameterSpec, SecureRandom)\n+     * @see Encapsulator#encapsulate(int, int, String)\n+     *\n+     * @since 21\n+     *\/\n+    public static final class Encapsulated {\n+        private final SecretKey key;\n+        private final byte[] encapsulation;\n+        private final byte[] params;\n+\n+        \/**\n+         * Constructs an {@code Encapsulated} object.\n+         *\n+         * @param key the shared secret as a key, must not be {@code null}.\n+         * @param encapsulation the key encapsulation message, must not\n+         *          be {@code null}. The contents of the array are copied\n+         *          to protect against subsequent modification.\n+         * @param params optional parameters, can be {@code null}.\n+         *          The contents of the array are copied to protect\n+         *          against subsequent modification.\n+         * @throws NullPointerException if {@code key} or {@code encapsulation}\n+         *          is {@code null}\n+         *\/\n+        public Encapsulated(SecretKey key, byte[] encapsulation, byte[] params) {\n+            Objects.requireNonNull(key);\n+            Objects.requireNonNull(encapsulation);\n+            this.key = key;\n+            this.encapsulation = encapsulation.clone();\n+            this.params = params == null ? null : params.clone();\n+        }\n+\n+        \/**\n+         * Returns the {@code SecretKey}.\n+         *\n+         * @return the secret key\n+         *\/\n+        public SecretKey key() {\n+            return key;\n+        }\n+\n+        \/**\n+         * Returns the key encapsulation message.\n+         *\n+         * @return the key encapsulation message. A new copy of the byte array\n+         *      is returned.\n+         *\/\n+        public byte[] encapsulation() {\n+            return encapsulation.clone();\n+        }\n+\n+        \/**\n+         * Returns the optional parameters in a byte array.\n+         *\n+         * @return the optional parameters in a byte array or {@code null}\n+         *      if not specified. A new copy of the byte array is returned.\n+         *\/\n+        public byte[] params() {\n+            return params == null ? null : params.clone();\n+        }\n+    }\n+\n+    \/**\n+     * An encapsulator, generated by {@link #newEncapsulator} on the KEM\n+     * sender side.\n+     * <p>\n+     * This class represents the key encapsulation function of a KEM.\n+     * Each invocation of the {@code encapsulate} method generates a\n+     * new secret key and key encapsulation message that is returned\n+     * in an {@link Encapsulated} object.\n+     *\n+     * @since 21\n+     *\/\n+    public static final class Encapsulator {\n+\n+        private final KEMSpi.EncapsulatorSpi e;\n+        private final Provider p;\n+\n+        private Encapsulator(KEMSpi.EncapsulatorSpi e, Provider p) {\n+            assert e != null;\n+            assert p != null;\n+            this.e = e;\n+            this.p = p;\n+        }\n+\n+        \/**\n+         * Returns the name of the provider.\n+         *\n+         * @return the name of the provider\n+         *\/\n+        public String providerName() {\n+            return p.getName();\n+        }\n+\n+        \/**\n+         * The key encapsulation function.\n+         * <p>\n+         * This method is equivalent to\n+         * {@code encapsulate(0, secretSize(), \"Generic\")}. This combination\n+         * of arguments must be supported by every implementation.\n+         * <p>\n+         * The generated secret key is usually passed to a key derivation\n+         * function (KDF) as the input keying material.\n+         *\n+         * @return a {@link Encapsulated} object containing the shared\n+         *          secret, key encapsulation message, and optional parameters.\n+         *          The shared secret is a {@code SecretKey} containing all of\n+         *          the bytes of the secret, and an algorithm name of \"Generic\".\n+         *\/\n+        public Encapsulated encapsulate() {\n+            return encapsulate(0, secretSize(), \"Generic\");\n+        }\n+\n+        \/**\n+         * The key encapsulation function.\n+         * <p>\n+         * Each invocation of this method generates a new secret key and key\n+         * encapsulation message that is returned in an {@link Encapsulated} object.\n+         * <p>\n+         * An implementation may choose to not support arbitrary combinations\n+         * of {@code from}, {@code to}, and {@code algorithm}.\n+         *\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return a {@link Encapsulated} object containing a portion of\n+         *          the shared secret, key encapsulation message, and optional\n+         *          parameters. The portion of the shared secret is a\n+         *          {@code SecretKey} containing the bytes of the secret\n+         *          ranging from {@code from} to {@code to}, exclusive,\n+         *          and an algorithm name as specified. For example,\n+         *          {@code encapsulate(0, 16, \"AES\")} uses the first 16 bytes\n+         *          of the shared secret as a 128-bit AES key.\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *     {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the encapsulator\n+         *\/\n+        public Encapsulated encapsulate(int from, int to, String algorithm) {\n+            return e.engineEncapsulate(from, to, algorithm);\n+        }\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         * <p>\n+         * This method can be called to find out the length of the shared secret\n+         * before {@code encapsulate} is called or if the obtained\n+         * {@code SecretKey} is not extractable.\n+         *\n+         * @return the size of the shared secret\n+         *\/\n+        public int secretSize() {\n+            int result = e.engineSecretSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineSecretSize result\";\n+            return result;\n+        }\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         * <p>\n+         * This method can be called to find out the length of the encapsulation\n+         * message before {@code encapsulate} is called.\n+         *\n+         * @return the size of the key encapsulation message\n+         *\/\n+        public int encapsulationSize() {\n+            int result = e.engineEncapsulationSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineEncapsulationSize result\";\n+            return result;\n+        }\n+    }\n+\n+    \/**\n+     * A decapsulator, generated by {@link #newDecapsulator} on the KEM\n+     * receiver side.\n+     * <p>\n+     * This class represents the key decapsulation function of a KEM.\n+     * An invocation of the {@code decapsulate} method recovers the\n+     * secret key from the key encapsulation message.\n+     *\n+     * @since 21\n+     *\/\n+    public static final class Decapsulator {\n+        private final KEMSpi.DecapsulatorSpi d;\n+        private final Provider p;\n+\n+        private Decapsulator(KEMSpi.DecapsulatorSpi d, Provider p) {\n+            assert d != null;\n+            assert p != null;\n+            this.d = d;\n+            this.p = p;\n+        }\n+\n+        \/**\n+         * Returns the name of the provider.\n+         *\n+         * @return the name of the provider\n+         *\/\n+        public String providerName() {\n+            return p.getName();\n+        }\n+\n+        \/**\n+         * The key decapsulation function.\n+         * <p>\n+         * This method is equivalent to\n+         * {@code decapsulate(encapsulation, 0, secretSize(), \"Generic\")}. This\n+         * combination of arguments must be supported by every implementation.\n+         * <p>\n+         * The generated secret key is usually passed to a key derivation\n+         * function (KDF) as the input keying material.\n+         *\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #encapsulationSize()}, or a {@code DecapsulateException}\n+         *          will be thrown.\n+         * @return the shared secret as a {@code SecretKey} with\n+         *          an algorithm name of \"Generic\"\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n+         * @throws NullPointerException if {@code encapsulation} is {@code null}\n+         *\/\n+        public SecretKey decapsulate(byte[] encapsulation) throws DecapsulateException {\n+            return decapsulate(encapsulation, 0, secretSize(), \"Generic\");\n+        }\n+\n+        \/**\n+         * The key decapsulation function.\n+         * <p>\n+         * An invocation of this method recovers the secret key from the key\n+         * encapsulation message.\n+         * <p>\n+         * An implementation may choose to not support arbitrary combinations\n+         * of {@code from}, {@code to}, and {@code algorithm}.\n+         *\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #encapsulationSize()}, or a {@code DecapsulateException}\n+         *          will be thrown.\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return a portion of the shared secret as a {@code SecretKey}\n+         *          containing the bytes of the secret ranging from {@code from}\n+         *          to {@code to}, exclusive, and an algorithm name as specified.\n+         *          For example, {@code decapsulate(encapsulation, secretSize()\n+         *          - 16, secretSize(), \"AES\")} uses the last 16 bytes\n+         *          of the shared secret as a 128-bit AES key.\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *          {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code encapsulation} or\n+         *          {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the decapsulator\n+         *\/\n+        public SecretKey decapsulate(byte[] encapsulation,\n+                int from, int to, String algorithm)\n+                throws DecapsulateException {\n+            return d.engineDecapsulate(\n+                    encapsulation,\n+                    from, to,\n+                    algorithm);\n+        }\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         * <p>\n+         * This method can be called to find out the length of the shared secret\n+         * before {@code decapsulate} is called or if the obtained\n+         * {@code SecretKey} is not extractable.\n+         *\n+         * @return the size of the shared secret\n+         *\/\n+        public int secretSize() {\n+            int result = d.engineSecretSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineSecretSize result\";\n+            return result;\n+        }\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         * <p>\n+         * This method can be used to extract the encapsulation message\n+         * from a longer byte array if no length information is provided\n+         * by a higher level protocol.\n+         *\n+         * @return the size of the key encapsulation message\n+         *\/\n+        public int encapsulationSize() {\n+            int result = d.engineEncapsulationSize();\n+            assert result >= 0 && result != Integer.MAX_VALUE\n+                    : \"invalid engineEncapsulationSize result\";\n+            return result;\n+        }\n+    }\n+\n+    private static final class DelayedKEM {\n+\n+        private final Provider.Service[] list; \/\/ non empty array\n+\n+        private DelayedKEM(Provider.Service[] list) {\n+            this.list = list;\n+        }\n+\n+        private Encapsulator newEncapsulator(PublicKey publicKey,\n+                AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (publicKey == null) {\n+                throw new InvalidKeyException(\"input key is null\");\n+            }\n+            RuntimeException re = null;\n+            InvalidAlgorithmParameterException iape = null;\n+            InvalidKeyException ike = null;\n+            NoSuchAlgorithmException nsae = null;\n+            for (Provider.Service service : list) {\n+                if (!service.supportsParameter(publicKey)) {\n+                    continue;\n+                }\n+                try {\n+                    KEMSpi spi = (KEMSpi) service.newInstance(null);\n+                    return new Encapsulator(\n+                            spi.engineNewEncapsulator(publicKey, spec, secureRandom),\n+                            service.getProvider());\n+                } catch (NoSuchAlgorithmException e) {\n+                    nsae = merge(nsae, e);\n+                } catch (InvalidAlgorithmParameterException e) {\n+                    iape = merge(iape, e);\n+                } catch (InvalidKeyException e) {\n+                    ike = merge(ike, e);\n+                } catch (RuntimeException e) {\n+                    re = merge(re, e);\n+                }\n+            }\n+            if (iape != null) throw iape;\n+            if (ike != null) throw ike;\n+            if (nsae != null) {\n+                throw new InvalidKeyException(\"No installed provider found\", nsae);\n+            }\n+            throw new InvalidKeyException(\"No installed provider supports this key: \"\n+                            + publicKey.getClass().getName(), re);\n+        }\n+\n+        private static <T extends Exception> T merge(T e1, T e2) {\n+            if (e1 == null) {\n+                return e2;\n+            } else {\n+                e1.addSuppressed(e2);\n+                return e1;\n+            }\n+        }\n+\n+        private Decapsulator newDecapsulator(PrivateKey privateKey, AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (privateKey == null) {\n+                throw new InvalidKeyException(\"input key is null\");\n+            }\n+            RuntimeException re = null;\n+            InvalidAlgorithmParameterException iape = null;\n+            InvalidKeyException ike = null;\n+            NoSuchAlgorithmException nsae = null;\n+            for (Provider.Service service : list) {\n+                if (!service.supportsParameter(privateKey)) {\n+                    continue;\n+                }\n+                try {\n+                    KEMSpi spi = (KEMSpi) service.newInstance(null);\n+                    return new Decapsulator(\n+                            spi.engineNewDecapsulator(privateKey, spec),\n+                            service.getProvider());\n+                } catch (NoSuchAlgorithmException e) {\n+                    nsae = merge(nsae, e);\n+                } catch (InvalidAlgorithmParameterException e) {\n+                    iape = merge(iape, e);\n+                } catch (InvalidKeyException e) {\n+                    ike = merge(ike, e);\n+                } catch (RuntimeException e) {\n+                    re = merge(re, e);\n+                }\n+            }\n+            if (iape != null) throw iape;\n+            if (ike != null) throw ike;\n+            if (nsae != null) {\n+                throw new InvalidKeyException(\"No installed provider found\", nsae);\n+            }\n+            throw new InvalidKeyException(\"No installed provider supports this key: \"\n+                    + privateKey.getClass().getName(), re);\n+        }\n+    }\n+\n+    \/\/ If delayed provider selection is needed\n+    private final DelayedKEM delayed;\n+\n+    \/\/ otherwise\n+    private final KEMSpi spi;\n+    private final Provider provider;\n+\n+    private final String algorithm;\n+\n+    private KEM(String algorithm, KEMSpi spi, Provider provider) {\n+        assert spi != null;\n+        assert provider != null;\n+        this.delayed = null;\n+        this.spi = spi;\n+        this.provider = provider;\n+        this.algorithm = algorithm;\n+    }\n+\n+    private KEM(String algorithm, DelayedKEM delayed) {\n+        assert delayed != null;\n+        this.delayed = delayed;\n+        this.spi = null;\n+        this.provider = null;\n+        this.algorithm = algorithm;\n+    }\n+\n+    \/**\n+     * Returns a {@code KEM} object that implements the specified algorithm.\n+     *\n+     * @param algorithm the name of the KEM algorithm.\n+     *          See the {@code KEM} section in the <a href=\n+     *          \"{@docRoot}\/..\/specs\/security\/standard-names.html#kem-algorithms\">\n+     *          Java Security Standard Algorithm Names Specification<\/a>\n+     *          for information about standard KEM algorithm names.\n+     * @return the new {@code KEM} object\n+     * @throws NoSuchAlgorithmException if no {@code Provider} supports a\n+     *         {@code KEM} implementation for the specified algorithm\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n+     *\/\n+    public static KEM getInstance(String algorithm)\n+            throws NoSuchAlgorithmException {\n+        List<Provider.Service> list = GetInstance.getServices(\n+                \"KEM\",\n+                Objects.requireNonNull(algorithm, \"null algorithm name\"));\n+        if (list.isEmpty()) {\n+            throw new NoSuchAlgorithmException(algorithm + \" KEM not available\");\n+        }\n+        return new KEM(algorithm, new DelayedKEM(list.toArray(new Provider.Service[0])));\n+    }\n+\n+    \/**\n+     * Returns a {@code KEM} object that implements the specified algorithm\n+     * from the specified security provider.\n+     *\n+     * @param algorithm the name of the KEM algorithm.\n+     *          See the {@code KEM} section in the <a href=\n+     *          \"{@docRoot}\/..\/specs\/security\/standard-names.html#kem-algorithms\">\n+     *          Java Security Standard Algorithm Names Specification<\/a>\n+     *          for information about standard KEM algorithm names.\n+     * @param provider the provider. If {@code null}, this method is equivalent\n+     *                 to {@link #getInstance(String)}.\n+     * @return the new {@code KEM} object\n+     * @throws NoSuchAlgorithmException if a {@code provider} is specified and\n+     *          it does not support the specified KEM algorithm,\n+     *          or if {@code provider} is {@code null} and there is no provider\n+     *          that supports a KEM implementation of the specified algorithm\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n+     *\/\n+    public static KEM getInstance(String algorithm, Provider provider)\n+            throws NoSuchAlgorithmException {\n+        if (provider == null) {\n+            return getInstance(algorithm);\n+        }\n+        GetInstance.Instance instance = GetInstance.getInstance(\n+                \"KEM\",\n+                KEMSpi.class,\n+                Objects.requireNonNull(algorithm, \"null algorithm name\"),\n+                provider);\n+        return new KEM(algorithm, (KEMSpi) instance.impl, instance.provider);\n+    }\n+\n+    \/**\n+     * Returns a {@code KEM} object that implements the specified algorithm\n+     * from the specified security provider.\n+     *\n+     * @param algorithm the name of the KEM algorithm.\n+     *          See the {@code KEM} section in the <a href=\n+     *          \"{@docRoot}\/..\/specs\/security\/standard-names.html#kem-algorithms\">\n+     *          Java Security Standard Algorithm Names Specification<\/a>\n+     *          for information about standard KEM algorithm names.\n+     * @param provider the provider. If {@code null}, this method is equivalent\n+     *                 to {@link #getInstance(String)}.\n+     * @return the new {@code KEM} object\n+     * @throws NoSuchAlgorithmException if a {@code provider} is specified and\n+     *          it does not support the specified KEM algorithm,\n+     *          or if {@code provider} is {@code null} and there is no provider\n+     *          that supports a KEM implementation of the specified algorithm\n+     * @throws NoSuchProviderException if the specified provider is not\n+     *         registered in the security provider list\n+     * @throws NullPointerException if {@code algorithm} is {@code null}\n+     *\/\n+    public static KEM getInstance(String algorithm, String provider)\n+            throws NoSuchAlgorithmException, NoSuchProviderException {\n+        if (provider == null) {\n+            return getInstance(algorithm);\n+        }\n+        GetInstance.Instance instance = GetInstance.getInstance(\n+                \"KEM\",\n+                KEMSpi.class,\n+                Objects.requireNonNull(algorithm, \"null algorithm name\"),\n+                provider);\n+        return new KEM(algorithm, (KEMSpi) instance.impl, instance.provider);\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     * <p>\n+     * This method is equivalent to {@code newEncapsulator(publicKey, null, null)}.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @return the encapsulator for this key\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *          because an {@code AlgorithmParameterSpec} must be provided\n+     *\/\n+    public Encapsulator newEncapsulator(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        try {\n+            return newEncapsulator(publicKey, null, null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new UnsupportedOperationException(\n+                    \"AlgorithmParameterSpec must be provided\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     * <p>\n+     * This method is equivalent to {@code newEncapsulator(publicKey, null, secureRandom)}.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @param secureRandom the source of randomness for encapsulation.\n+     *                     If {@code} null, a default one from the\n+     *                     implementation will be used.\n+     * @return the encapsulator for this key\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *          because an {@code AlgorithmParameterSpec} must be provided\n+     *\/\n+    public Encapsulator newEncapsulator(PublicKey publicKey, SecureRandom secureRandom)\n+            throws InvalidKeyException {\n+        try {\n+            return newEncapsulator(publicKey, null, secureRandom);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new UnsupportedOperationException(\n+                    \"AlgorithmParameterSpec must be provided\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     * <p>\n+     * An algorithm can define an {@code AlgorithmParameterSpec} child class to\n+     * provide extra information in this method. This is especially useful if\n+     * the same key can be used to derive shared secrets in different ways.\n+     * If any extra information inside this object needs to be transmitted along\n+     * with the key encapsulation message so that the receiver is able to create\n+     * a matching decapsulator, it will be included as a byte array in the\n+     * {@link Encapsulated#params} field inside the encapsulation output.\n+     * In this case, the security provider should provide an\n+     * {@code AlgorithmParameters} implementation using the same algorithm name\n+     * as the KEM. The receiver can initiate such an {@code AlgorithmParameters}\n+     * instance with the {@code params} byte array received and recover\n+     * an {@code AlgorithmParameterSpec} object to be used in its\n+     * {@link #newDecapsulator(PrivateKey, AlgorithmParameterSpec)} call.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @param spec the optional parameter, can be {@code null}\n+     * @param secureRandom the source of randomness for encapsulation.\n+     *                     If {@code} null, a default one from the\n+     *                     implementation will be used.\n+     * @return the encapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     *\/\n+    public Encapsulator newEncapsulator(PublicKey publicKey,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        return delayed != null\n+                ? delayed.newEncapsulator(publicKey, spec, secureRandom)\n+                : new Encapsulator(spi.engineNewEncapsulator(publicKey, spec, secureRandom), provider);\n+    }\n+\n+    \/**\n+     * Creates a KEM decapsulator on the KEM receiver side.\n+     * <p>\n+     * This method is equivalent to {@code newDecapsulator(privateKey, null)}.\n+     *\n+     * @param privateKey the receiver's private key, must not be {@code null}\n+     * @return the decapsulator for this key\n+     * @throws InvalidKeyException if {@code privateKey} is {@code null} or invalid\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *          because an {@code AlgorithmParameterSpec} must be provided\n+     *\/\n+    public Decapsulator newDecapsulator(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        try {\n+            return newDecapsulator(privateKey, null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new UnsupportedOperationException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a KEM decapsulator on the KEM receiver side.\n+     *\n+     * @param privateKey the receiver's private key, must not be {@code null}\n+     * @param spec the parameter, can be {@code null}\n+     * @return the decapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code privateKey} is {@code null} or invalid\n+     *\/\n+    public Decapsulator newDecapsulator(PrivateKey privateKey, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        return delayed != null\n+                ? delayed.newDecapsulator(privateKey, spec)\n+                : new Decapsulator(spi.engineNewDecapsulator(privateKey, spec), provider);\n+    }\n+\n+    \/**\n+     * Returns the name of the algorithm for this {@code KEM} object.\n+     *\n+     * @return the name of the algorithm for this {@code KEM} object.\n+     *\/\n+    public String getAlgorithm() {\n+        return this.algorithm;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEM.java","additions":737,"deletions":0,"binary":false,"changes":737,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javax.crypto;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+\/**\n+ * This class defines the Service Provider Interface (SPI) for the {@link KEM}\n+ * class. A security provider implements this interface to provide an\n+ * implementation of a Key Encapsulation Mechanism (KEM) algorithm.\n+ * <p>\n+ * A KEM algorithm may support a family of configurations. Each configuration\n+ * may accept different types of keys, cryptographic primitives, and sizes of\n+ * shared secrets and key encapsulation messages. A configuration is defined\n+ * by the KEM algorithm name, the key it uses, and an optional\n+ * {@code AlgorithmParameterSpec} argument that is specified when creating\n+ * an encapsulator or decapsulator. The result of calling\n+ * {@link #engineNewEncapsulator} or {@link #engineNewDecapsulator} must return\n+ * an encapsulator or decapsulator that maps to a single configuration,\n+ * where its {@code engineSecretSize()} and {@code engineEncapsulationSize()}\n+ * methods return constant values.\n+ * <p>\n+ * A {@code KEMSpi} implementation must be immutable. It must be safe to\n+ * call multiple {@code engineNewEncapsulator} and {@code engineNewDecapsulator}\n+ * methods at the same time.\n+ * <p>\n+ * {@code EncapsulatorSpi} and {@code DecapsulatorSpi} implementations must also\n+ * be immutable. It must be safe to invoke multiple {@code encapsulate} and\n+ * {@code decapsulate} methods at the same time. Each invocation of\n+ * {@code encapsulate} should generate a new shared secret and key\n+ * encapsulation message.\n+ * <p>\n+ * For example,\n+ * {@snippet lang = java:\n+ * public static class MyKEMImpl implements KEMSpi {\n+ *\n+ *     @Override\n+ *     public KEMSpi.EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+ *             AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+ *             throws InvalidAlgorithmParameterException, InvalidKeyException {\n+ *         if (!checkPublicKey(publicKey)) {\n+ *             throw new InvalidKeyException(\"unsupported key\");\n+ *         }\n+ *         if (!checkParameters(spec)) {\n+ *             throw new InvalidAlgorithmParameterException(\"unsupported params\");\n+ *         }\n+ *         return new MyEncapsulator(publicKey, spec, secureRandom);\n+ *     }\n+ *\n+ *     class MyEncapsulator implements KEMSpi.EncapsulatorSpi {\n+ *         MyEncapsulator(PublicKey publicKey, AlgorithmParameterSpec spec,\n+ *                 SecureRandom secureRandom){\n+ *             this.spec = spec != null ? spec : getDefaultParameters();\n+ *             this.secureRandom = secureRandom != null\n+ *                     ? secureRandom\n+ *                     : getDefaultSecureRandom();\n+ *             this.publicKey = publicKey;\n+ *         }\n+ *\n+ *         @Override\n+ *         public KEM.Encapsulated encapsulate(int from, int to, String algorithm) {\n+ *             byte[] encapsulation;\n+ *             byte[] secret;\n+ *             \/\/ calculating...\n+ *             return new KEM.Encapsulated(\n+ *                     new SecretKeySpec(secret, from, to - from, algorithm),\n+ *                     encapsulation, null);\n+ *         }\n+ *\n+ *         \/\/ ...\n+ *     }\n+ *\n+ *     \/\/ ...\n+ * }\n+ * }\n+ *\n+ * @see KEM\n+ * @since 21\n+ *\/\n+public interface KEMSpi {\n+\n+    \/**\n+     * The KEM encapsulator implementation, generated by\n+     * {@link #engineNewEncapsulator} on the KEM sender side.\n+     *\n+     * @see KEM.Encapsulator\n+     *\n+     * @since 21\n+     *\/\n+    interface EncapsulatorSpi {\n+        \/**\n+         * The key encapsulation function.\n+         * <p>\n+         * Each invocation of this method must generate a new secret key and key\n+         * encapsulation message that is returned in an {@link KEM.Encapsulated} object.\n+         * <p>\n+         * An implementation must support the case where {@code from} is 0,\n+         * {@code to} is the same as the return value of {@code secretSize()},\n+         * and {@code algorithm} is \"Generic\".\n+         *\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return an {@link KEM.Encapsulated} object containing a portion of\n+         *          the shared secret as a key with the specified algorithm,\n+         *          key encapsulation message, and optional parameters.\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *     {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the encapsulator\n+         * @see KEM.Encapsulated\n+         * @see KEM.Encapsulator#encapsulate(int, int, String)\n+         *\/\n+        KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm);\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         *\n+         * @return the size of the shared secret as a finite non-negative integer\n+         * @see KEM.Encapsulator#secretSize()\n+         *\/\n+        int engineSecretSize();\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         *\n+         * @return the size of the key encapsulation message as a finite non-negative integer\n+         * @see KEM.Encapsulator#encapsulationSize()\n+         *\/\n+        int engineEncapsulationSize();\n+    }\n+\n+    \/**\n+     * The KEM decapsulator implementation, generated by\n+     * {@link #engineNewDecapsulator} on the KEM receiver side.\n+     *\n+     * @see KEM.Decapsulator\n+     *\n+     * @since 21\n+     *\/\n+    interface DecapsulatorSpi {\n+        \/**\n+         * The key decapsulation function.\n+         * <p>\n+         * An invocation of this method recovers the secret key from the key\n+         * encapsulation message.\n+         * <p>\n+         * An implementation must support the case where {@code from} is 0,\n+         * {@code to} is the same as the return value of {@code secretSize()},\n+         * and {@code algorithm} is \"Generic\".\n+         *\n+         * @param encapsulation the key encapsulation message from the sender.\n+         *          The size must be equal to the value returned by\n+         *          {@link #engineEncapsulationSize()} ()}, or a\n+         *          {@code DecapsulateException} must be thrown.\n+         * @param from the initial index of the shared secret byte array\n+         *          to be returned, inclusive\n+         * @param to the final index of the shared secret byte array\n+         *          to be returned, exclusive\n+         * @param algorithm the algorithm name for the secret key that is returned\n+         * @return a portion of the shared secret as a {@code SecretKey} with\n+         *          the specified algorithm\n+         * @throws DecapsulateException if an error occurs during the\n+         *          decapsulation process\n+         * @throws IndexOutOfBoundsException if {@code from < 0},\n+         *          {@code from > to}, or {@code to > secretSize()}\n+         * @throws NullPointerException if {@code encapsulation} or\n+         *          {@code algorithm} is {@code null}\n+         * @throws UnsupportedOperationException if the combination of\n+         *          {@code from}, {@code to}, and {@code algorithm}\n+         *          is not supported by the decapsulator\n+         * @see KEM.Decapsulator#decapsulate(byte[], int, int, String)\n+         *\/\n+        SecretKey engineDecapsulate(byte[] encapsulation, int from, int to, String algorithm)\n+                throws DecapsulateException;\n+\n+        \/**\n+         * Returns the size of the shared secret.\n+         *\n+         * @return the size of the shared secret as a finite non-negative integer\n+         * @see KEM.Decapsulator#secretSize()\n+         *\/\n+        int engineSecretSize();\n+\n+        \/**\n+         * Returns the size of the key encapsulation message.\n+         *\n+         * @return the size of the key encapsulation message as a finite non-negative integer\n+         * @see KEM.Decapsulator#encapsulationSize()\n+         *\/\n+        int engineEncapsulationSize();\n+    }\n+\n+    \/**\n+     * Creates a KEM encapsulator on the KEM sender side.\n+     *\n+     * @param publicKey the receiver's public key, must not be {@code null}\n+     * @param spec the optional parameter, can be {@code null}\n+     * @param secureRandom the source of randomness for encapsulation.\n+     *                     If {@code null}, the implementation must provide\n+     *                     a default one.\n+     * @return the encapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code publicKey} is {@code null} or invalid\n+     * @see KEM#newEncapsulator(PublicKey, AlgorithmParameterSpec, SecureRandom)\n+     *\/\n+    EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException;\n+\n+    \/**\n+     * Creates a KEM decapsulator on the KEM receiver side.\n+     *\n+     * @param privateKey the receiver's private key, must not be {@code null}\n+     * @param spec the optional parameter, can be {@code null}\n+     * @return the decapsulator for this key\n+     * @throws InvalidAlgorithmParameterException if {@code spec} is invalid\n+     *          or one is required but {@code spec} is {@code null}\n+     * @throws InvalidKeyException if {@code privateKey} is {@code null} or invalid\n+     * @see KEM#newDecapsulator(PrivateKey, AlgorithmParameterSpec)\n+     *\/\n+    DecapsulatorSpi engineNewDecapsulator(PrivateKey privateKey, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException;\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/KEMSpi.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-final class HKDF {\n+public final class HKDF {\n@@ -60,1 +60,1 @@\n-    HKDF(String hashAlg) throws NoSuchAlgorithmException {\n+    public HKDF(String hashAlg) throws NoSuchAlgorithmException {\n@@ -85,1 +85,1 @@\n-    SecretKey extract(SecretKey salt, SecretKey inputKey, String keyAlg)\n+    public SecretKey extract(SecretKey salt, SecretKey inputKey, String keyAlg)\n@@ -113,1 +113,1 @@\n-    SecretKey extract(byte[] salt, SecretKey inputKey, String keyAlg)\n+    public SecretKey extract(byte[] salt, SecretKey inputKey, String keyAlg)\n@@ -136,1 +136,1 @@\n-    SecretKey expand(SecretKey pseudoRandKey, byte[] info, int outLen,\n+    public SecretKey expand(SecretKey pseudoRandKey, byte[] info, int outLen,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/HKDF.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,5 @@\n+\n+    public static final NamedCurve P_256;\n+    public static final NamedCurve P_384;\n+    public static final NamedCurve P_521;\n+\n@@ -112,1 +117,1 @@\n-    private static void add(KnownOIDs o, int type, String sfield,\n+    private static NamedCurve add(KnownOIDs o, int type, String sfield,\n@@ -146,0 +151,2 @@\n+\n+        return params;\n@@ -258,1 +265,1 @@\n-        add(KnownOIDs.secp256r1, PD,\n+        P_256 = add(KnownOIDs.secp256r1, PD,\n@@ -267,1 +274,1 @@\n-        add(KnownOIDs.secp384r1, PD,\n+        P_384 = add(KnownOIDs.secp384r1, PD,\n@@ -276,1 +283,1 @@\n-        add(KnownOIDs.secp521r1, PD,\n+        P_521 = add(KnownOIDs.secp521r1, PD,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/CurveDB.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -544,1 +544,1 @@\n-                    CurveDB.lookup(\"secp256r1\").getGenerator();\n+                    CurveDB.P_256.getGenerator();\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECOperations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,5 +215,2 @@\n-        for (NamedCurve namedCurve :\n-            List.of(\n-                CurveDB.lookup(\"secp256r1\"),\n-                CurveDB.lookup(\"secp384r1\"),\n-                CurveDB.lookup(\"secp521r1\"))) {\n+        for (NamedCurve namedCurve : List.of(\n+                CurveDB.P_256, CurveDB.P_384, CurveDB.P_521)) {\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/SunEC.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297878\n+ * @summary Key Encapsulation Mechanism API\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.*;\n+import java.security.interfaces.ECPublicKey;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.function.Consumer;\n+\n+import com.sun.crypto.provider.DHKEM;\n+\n+public class Compliance {\n+\n+    public static void main(String[] args) throws Exception {\n+        basic();\n+        conform();\n+        determined();\n+        try {\n+            Security.insertProviderAt(new ProviderImpl(), 1);\n+            delayed();\n+        } finally {\n+            Security.removeProvider(\"XP\");\n+        }\n+    }\n+\n+    \/\/ Encapsulated conformance checks\n+    private static void conform() {\n+        new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), new byte[0], new byte[0]);\n+        new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), new byte[0], null);\n+        Utils.runAndCheckException(\n+                () -> new KEM.Encapsulated(null, new byte[0], null),\n+                NullPointerException.class);\n+        Utils.runAndCheckException(\n+                () -> new KEM.Encapsulated(new SecretKeySpec(new byte[1], \"X\"), null, null),\n+                NullPointerException.class);\n+    }\n+\n+    \/\/ basic should and shouldn't behaviors\n+    static void basic() throws Exception {\n+        KeyPair kpRSA = KeyPairGenerator.getInstance(\"RSA\").generateKeyPair();\n+        KeyPair kpX = KeyPairGenerator.getInstance(\"X25519\").generateKeyPair();\n+\n+        KeyPairGenerator ecg = KeyPairGenerator.getInstance(\"EC\");\n+        ecg.initialize(new ECGenParameterSpec(\"secp256r1\"));\n+        KeyPair kpEC = ecg.generateKeyPair();\n+\n+        KEM.getInstance(\"DHKEM\", (String) null);\n+        KEM.getInstance(\"DHKEM\", (Provider) null);\n+        KEM kem = KEM.getInstance(\"DHKEM\");\n+        Utils.runAndCheckException(\n+                () -> KEM.getInstance(\"OLALA\"),\n+                NoSuchAlgorithmException.class);\n+        Utils.runAndCheckException(\n+                () -> KEM.getInstance(\"DHKEM\", \"NoWhere\"),\n+                NoSuchProviderException.class);\n+        Utils.runAndCheckException(\n+                () -> KEM.getInstance(\"DHKEM\", \"SunRsaSign\"),\n+                NoSuchAlgorithmException.class);\n+\n+        Utils.runAndCheckException(\n+                () -> kem.newEncapsulator(null),\n+                InvalidKeyException.class);\n+        Utils.runAndCheckException(\n+                () -> kem.newDecapsulator(null),\n+                InvalidKeyException.class);\n+\n+        \/\/ Still an EC key, rejected by implementation\n+        Utils.runAndCheckException(\n+                () -> kem.newEncapsulator(badECKey()),\n+                ExChecker.of(InvalidKeyException.class).by(DHKEM.class));\n+\n+        \/\/ Not an EC key at all, rejected by framework coz it's not\n+        \/\/ listed in \"SupportedKeyClasses\" in SunJCE.java.\n+        Utils.runAndCheckException(\n+                () -> kem.newEncapsulator(kpRSA.getPublic()),\n+                ExChecker.of(InvalidKeyException.class).by(KEM.class.getName() + \"$DelayedKEM\"));\n+\n+        Utils.runAndCheckException(\n+                () -> kem.newDecapsulator(kpRSA.getPrivate()),\n+                InvalidKeyException.class);\n+\n+        kem.newEncapsulator(kpX.getPublic(), null);\n+        kem.newEncapsulator(kpX.getPublic(), null, null);\n+        KEM.Encapsulator e2 = kem.newEncapsulator(kpX.getPublic());\n+        KEM.Encapsulated enc1 = e2.encapsulate(0, e2.secretSize(), \"AES\");\n+        Asserts.assertEQ(enc1.key().getEncoded().length, e2.secretSize());\n+        Asserts.assertEQ(enc1.key().getAlgorithm(), \"AES\");\n+\n+        Utils.runAndCheckException(\n+                () -> e2.encapsulate(-1, 12, \"AES\"),\n+                IndexOutOfBoundsException.class);\n+        Utils.runAndCheckException(\n+                () -> e2.encapsulate(0, e2.secretSize() + 1, \"AES\"),\n+                IndexOutOfBoundsException.class);\n+        Utils.runAndCheckException(\n+                () -> e2.encapsulate(0, e2.secretSize(), null),\n+                NullPointerException.class);\n+\n+        KEM.Encapsulated enc = e2.encapsulate();\n+        Asserts.assertEQ(enc.key().getEncoded().length, e2.secretSize());\n+        Asserts.assertEQ(enc.key().getAlgorithm(), \"Generic\");\n+\n+        kem.newDecapsulator(kpX.getPrivate(), null);\n+        KEM.Decapsulator d = kem.newDecapsulator(kpX.getPrivate());\n+        d.decapsulate(enc.encapsulation());\n+        SecretKey dec = d.decapsulate(enc.encapsulation());\n+        Asserts.assertTrue(Arrays.equals(enc.key().getEncoded(), dec.getEncoded()));\n+\n+        dec = d.decapsulate(enc.encapsulation(), 0, d.secretSize(), \"AES\");\n+        Asserts.assertTrue(Arrays.equals(enc.key().getEncoded(), dec.getEncoded()));\n+\n+        KEM.Encapsulated encHead = e2.encapsulate(0, 16, \"AES\");\n+        Asserts.assertEQ(encHead.key().getEncoded().length, 16);\n+        Asserts.assertEQ(encHead.key().getAlgorithm(), \"AES\");\n+        SecretKey decHead = d.decapsulate(encHead.encapsulation(), 0, 16, \"AES\");\n+        Asserts.assertEQ(encHead.key(), decHead);\n+\n+        KEM.Encapsulated encTail = e2.encapsulate(\n+                e2.secretSize() - 16, e2.secretSize(), \"AES\");\n+        Asserts.assertEQ(encTail.key().getEncoded().length, 16);\n+        Asserts.assertEQ(encTail.key().getAlgorithm(), \"AES\");\n+        SecretKey decTail = d.decapsulate(encTail.encapsulation(),\n+                d.secretSize() - 16, d.secretSize(), \"AES\");\n+        Asserts.assertEQ(encTail.key(), decTail);\n+\n+        Utils.runAndCheckException(\n+                () -> d.decapsulate(null),\n+                NullPointerException.class);\n+        Utils.runAndCheckException(\n+                () -> d.decapsulate(enc.encapsulation(), -1, 12, \"AES\"),\n+                IndexOutOfBoundsException.class);\n+        Utils.runAndCheckException(\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize() + 1, \"AES\"),\n+                IndexOutOfBoundsException.class);\n+        Utils.runAndCheckException(\n+                () -> d.decapsulate(enc.encapsulation(), 0, d.secretSize(), null),\n+                NullPointerException.class);\n+\n+        KEM.Encapsulator e3 = kem.newEncapsulator(kpEC.getPublic());\n+        KEM.Encapsulated enc2 = e3.encapsulate();\n+        KEM.Decapsulator d3 = kem.newDecapsulator(kpX.getPrivate());\n+        Utils.runAndCheckException(\n+                () -> d3.decapsulate(enc2.encapsulation()),\n+                DecapsulateException.class);\n+\n+        Utils.runAndCheckException(\n+                () -> d3.decapsulate(new byte[100]),\n+                DecapsulateException.class);\n+    }\n+\n+    static class MySecureRandom extends SecureRandom {\n+        final Random ran;\n+\n+        MySecureRandom(long seed) {\n+            ran = new Random(seed);\n+        }\n+\n+        @Override\n+        public void nextBytes(byte[] bytes) {\n+            ran.nextBytes(bytes);\n+        }\n+    }\n+\n+    \/\/ Same random should generate same key encapsulation messages\n+    static void determined() throws Exception {\n+        long seed = new Random().nextLong();\n+        byte[] enc1 = calcDetermined(seed);\n+        byte[] enc2 = calcDetermined(seed);\n+        Asserts.assertTrue(Arrays.equals(enc1, enc2),\n+                \"Undetermined for \" + seed);\n+    }\n+\n+    static byte[] calcDetermined(long seed) throws Exception {\n+        SecureRandom random = new MySecureRandom(seed);\n+        KeyPairGenerator g = KeyPairGenerator.getInstance(\"XDH\");\n+        g.initialize(NamedParameterSpec.X25519, random);\n+        PublicKey pk = g.generateKeyPair().getPublic();\n+        KEM kem = KEM.getInstance(\"DHKEM\");\n+        kem.newEncapsulator(pk, random); \/\/ skip one\n+        KEM.Encapsulator e = kem.newEncapsulator(pk, random);\n+        byte[] enc1 = e.encapsulate().encapsulation();\n+        byte[] enc2 = e.encapsulate().encapsulation();\n+        Asserts.assertFalse(Arrays.equals(enc1, enc2));\n+        return enc2;\n+    }\n+\n+    public static class ProviderImpl extends Provider {\n+        ProviderImpl() {\n+            super(\"XP\", \"1\", \"XP\");\n+            put(\"KEM.DHKEM\", \"Compliance$KEMImpl\");\n+        }\n+    }\n+\n+    static boolean isEven(Key k) {\n+        return Arrays.hashCode(k.getEncoded()) % 2 == 0;\n+    }\n+\n+    public static class KEMImpl extends DHKEM {\n+\n+        @Override\n+        public EncapsulatorSpi engineNewEncapsulator(PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (!isEven(pk)) throw new InvalidKeyException(\"Only accept even keys\");\n+            return super.engineNewEncapsulator(pk, spec, secureRandom);\n+        }\n+\n+        @Override\n+        public DecapsulatorSpi engineNewDecapsulator(PrivateKey sk, AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (!isEven(sk)) throw new InvalidKeyException(\"Only accept even keys\");\n+            return super.engineNewDecapsulator(sk, spec);\n+        }\n+    }\n+\n+    \/\/ Ensure delayed provider selection\n+    static void delayed() throws Exception {\n+        KeyPairGenerator g = KeyPairGenerator.getInstance(\"X25519\");\n+        PublicKey even = null, odd = null;\n+        while (even == null || odd == null) {\n+            KeyPair kp = g.generateKeyPair();\n+            if (isEven(kp.getPublic())) {\n+                even = kp.getPublic();\n+            }\n+            if (!isEven(kp.getPublic())) {\n+                odd = kp.getPublic();\n+            }\n+        }\n+        KEM kem = KEM.getInstance(\"DHKEM\");\n+\n+        KEM.Encapsulator eodd = kem.newEncapsulator(odd);\n+        KEM.Encapsulator eeven = kem.newEncapsulator(even);\n+        Asserts.assertEQ(eodd.providerName(), \"SunJCE\");\n+        Asserts.assertEQ(eeven.providerName(), \"XP\");\n+    }\n+\n+    static ECPublicKey badECKey() {\n+        return new ECPublicKey() {\n+            @Override\n+            public ECPoint getW() {\n+                return null;\n+            }\n+\n+            @Override\n+            public String getAlgorithm() {\n+                return null;\n+            }\n+\n+            @Override\n+            public String getFormat() {\n+                return null;\n+            }\n+\n+            @Override\n+            public byte[] getEncoded() {\n+                return new byte[0];\n+            }\n+\n+            @Override\n+            public ECParameterSpec getParams() {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    \/\/ Used by Utils.runAndCheckException. Checks for type and final thrower.\n+    record ExChecker(Class<? extends Throwable> ex, String caller)\n+            implements Consumer<Throwable> {\n+        ExChecker {\n+            Objects.requireNonNull(ex);\n+        }\n+        static ExChecker of(Class<? extends Throwable> ex) {\n+            return new ExChecker(ex, null);\n+        }\n+        ExChecker by(String caller) {\n+            return new ExChecker(ex(), caller);\n+        }\n+        ExChecker by(Class<?> caller) {\n+            return new ExChecker(ex(), caller.getName());\n+        }\n+        @Override\n+        public void accept(Throwable t) {\n+            if (t == null) {\n+                throw new AssertionError(\"no exception thrown\");\n+            } else if (!ex.isAssignableFrom(t.getClass())) {\n+                throw new AssertionError(\"exception thrown is \" + t.getClass());\n+            } else if (caller == null) {\n+                return;\n+            } else if (t.getStackTrace()[0].getClassName().equals(caller)) {\n+                return;\n+            } else {\n+                throw new AssertionError(\"thrown by \" + t.getStackTrace()[0].getClassName());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/DHKEM\/Compliance.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -0,0 +1,501 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297878\n+ * @summary RSA_KEM example\n+ * @modules java.base\/sun.security.jca\n+ *          java.base\/sun.security.rsa\n+ *          java.base\/sun.security.util\n+ *\/\n+import sun.security.jca.JCAUtil;\n+import sun.security.rsa.RSACore;\n+import sun.security.util.*;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPublicKey;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+\/\/ This test implements RSA-KEM as described in RFC 5990. In this KEM, the\n+\/\/ sender configures the encapsulator with an RSAKEMParameterSpec object.\n+\/\/ This object is encoded as a byte array and included in the Encapsulated\n+\/\/ output. The receiver is then able to recover the same RSAKEMParameterSpec\n+\/\/ object from the encoding using an AlgorithmParameters implementation\n+\/\/ and use the object to configure the decapsulator.\n+public class RSA_KEM {\n+    public static void main(String[] args) throws Exception {\n+        Provider p = new ProviderImpl();\n+        RSAKEMParameterSpec[] kspecs = new RSAKEMParameterSpec[] {\n+                RSAKEMParameterSpec.kdf1(\"SHA-256\", \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf1(\"SHA-512\", \"AES_256\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf2(\"SHA-256\", \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf2(\"SHA-512\", \"AES_256\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf3(\"SHA-256\", new byte[10], \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf3(\"SHA-256\", new byte[0], \"AES_128\/KW\/NoPadding\"),\n+                RSAKEMParameterSpec.kdf3(\"SHA-512\", new byte[0], \"AES_128\/KW\/NoPadding\"),\n+        };\n+        for (RSAKEMParameterSpec kspec : kspecs) {\n+            System.err.println(\"---------\");\n+            System.err.println(kspec);\n+            AlgorithmParameters d = AlgorithmParameters.getInstance(\"RSA-KEM\", p);\n+            d.init(kspec);\n+            AlgorithmParameters s = AlgorithmParameters.getInstance(\"RSA-KEM\", p);\n+            s.init(d.getEncoded());\n+            AlgorithmParameterSpec spec = s.getParameterSpec(AlgorithmParameterSpec.class);\n+            if (!spec.toString().equals(kspec.toString())) {\n+                throw new RuntimeException(spec.toString());\n+            }\n+        }\n+        byte[] msg = \"hello\".getBytes(StandardCharsets.UTF_8);\n+        byte[] iv = new byte[16];\n+        for (int size : List.of(1024, 2048)) {\n+            KeyPairGenerator g = KeyPairGenerator.getInstance(\"RSA\");\n+            g.initialize(size);\n+            KeyPair kp = g.generateKeyPair();\n+            for (RSAKEMParameterSpec kspec : kspecs) {\n+                SecretKey cek = KeyGenerator.getInstance(\"AES\").generateKey();\n+                KEM kem1 = KEM.getInstance(\"RSA-KEM\", p);\n+                Cipher c = Cipher.getInstance(\"AES\/CBC\/PKCS5Padding\");\n+                c.init(Cipher.ENCRYPT_MODE, cek, new IvParameterSpec(iv));\n+                byte[] ciphertext = c.doFinal(msg);\n+\n+                KEM.Encapsulator e = kem1.newEncapsulator(kp.getPublic(), kspec, null);\n+                KEM.Encapsulated enc = e.encapsulate(0, e.secretSize(), \"AES\");\n+                Cipher c2 = Cipher.getInstance(kspec.encAlg);\n+                c2.init(Cipher.WRAP_MODE, enc.key());\n+                byte[] ek = c2.wrap(cek);\n+\n+                AlgorithmParameters a = AlgorithmParameters.getInstance(\"RSA-KEM\", p);\n+                a.init(enc.params());\n+                KEM kem2 = KEM.getInstance(\"RSA-KEM\", p);\n+                KEM.Decapsulator d = kem2.newDecapsulator(kp.getPrivate(), a.getParameterSpec(AlgorithmParameterSpec.class));\n+                SecretKey k = d.decapsulate(enc.encapsulation(), 0, d.secretSize(), \"AES\");\n+                Cipher c3 = Cipher.getInstance(kspec.encAlg);\n+                c3.init(Cipher.UNWRAP_MODE, k);\n+                cek = (SecretKey) c3.unwrap(ek, \"AES\", Cipher.SECRET_KEY);\n+                Cipher c4 = Cipher.getInstance(\"AES\/CBC\/PKCS5Padding\");\n+                c4.init(Cipher.DECRYPT_MODE, cek, new IvParameterSpec(iv));\n+                byte[] cleartext = c4.doFinal(ciphertext);\n+\n+                if (!Arrays.equals(cleartext, msg)) {\n+                    throw new RuntimeException();\n+                }\n+                System.out.printf(\"%4d %20s - %11d %11d %11d %11d %s\\n\",\n+                        size, kspec,\n+                        e.secretSize(), e.encapsulationSize(),\n+                        d.secretSize(), d.encapsulationSize(), k.getAlgorithm());\n+            }\n+        }\n+    }\n+\n+    static final String RSA_KEM = \"1.2.840.113549.1.9.16.3.14\";\n+    static final String KEM_RSA = \"1.0.18033.2.2.4\";\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"MYKEM\", \"1\", \"RSA-KEM\");\n+            List<String> alias = List.of(RSA_KEM, \"OID.\" + RSA_KEM);\n+            Map<String, String> attrs = Map.of(\n+                    \"SupportedKeyClasses\", \"java.security.interfaces.RSAKey\");\n+            putService(new Service(this, \"KEM\", \"RSA-KEM\",\n+                    \"RSA_KEM$KEMImpl\", alias, attrs));\n+            putService(new Service(this, \"AlgorithmParameters\", \"RSA-KEM\",\n+                    \"RSA_KEM$AlgorithmParametersImpl\", alias, attrs));\n+        }\n+    }\n+\n+    public static class AlgorithmParametersImpl extends AlgorithmParametersSpi {\n+        RSAKEMParameterSpec spec;\n+        @Override\n+        protected void engineInit(AlgorithmParameterSpec paramSpec)\n+                throws InvalidParameterSpecException {\n+            if (paramSpec instanceof RSAKEMParameterSpec rspec) {\n+                spec = rspec;\n+            } else {\n+                throw new InvalidParameterSpecException();\n+            }\n+        }\n+\n+        @Override\n+        protected void engineInit(byte[] params) throws IOException {\n+            spec = decode(params);\n+        }\n+\n+        @Override\n+        protected void engineInit(byte[] params, String format) throws IOException {\n+            spec = decode(params);\n+        }\n+\n+        @Override\n+        protected <T extends AlgorithmParameterSpec> T engineGetParameterSpec(\n+                Class<T> paramSpec) throws InvalidParameterSpecException {\n+            if (paramSpec.isAssignableFrom(RSAKEMParameterSpec.class)) {\n+                return paramSpec.cast(spec);\n+            } else {\n+                throw new InvalidParameterSpecException();\n+            }\n+        }\n+\n+        @Override\n+        protected byte[] engineGetEncoded() {\n+            return encode(spec);\n+        }\n+\n+        @Override\n+        protected byte[] engineGetEncoded(String format) {\n+            return encode(spec);\n+        }\n+\n+        @Override\n+        protected String engineToString() {\n+            return spec == null ? \"<null>\" : spec.toString();\n+        }\n+\n+        static final ObjectIdentifier id_rsa_kem;\n+        static final ObjectIdentifier id_kem_rsa;\n+        static final ObjectIdentifier id_kdf1;\n+        static final ObjectIdentifier id_kdf2;\n+        static final ObjectIdentifier id_kdf3;\n+\n+        static {\n+            try {\n+                id_rsa_kem = ObjectIdentifier.of(\"1.2.840.113549.1.9.16.3.14\");\n+                id_kem_rsa = ObjectIdentifier.of(\"1.0.18033.2.2.4\");\n+                id_kdf1 = ObjectIdentifier.of(\"1.3.133.16.840.9.44.1.0\"); \/\/ fake\n+                id_kdf2 = ObjectIdentifier.of(\"1.3.133.16.840.9.44.1.1\");\n+                id_kdf3 = ObjectIdentifier.of(\"1.3.133.16.840.9.44.1.2\");\n+            } catch (IOException e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        static byte[] encode(RSAKEMParameterSpec spec) {\n+            DerOutputStream kdf = new DerOutputStream()\n+                    .write(DerValue.tag_Sequence, new DerOutputStream()\n+                        .putOID(oid4(spec.kdfAlg))\n+                        .write(DerValue.tag_Sequence, new DerOutputStream()\n+                            .putOID(oid4(spec.hashAlg))))\n+                    .putInteger(spec.kdfLen());\n+            \/\/ The next line is not in RFC 5990\n+            if (spec.fixedInfo != null) {\n+                kdf.putOctetString(spec.fixedInfo);\n+            }\n+            return new DerOutputStream()\n+                    .write(DerValue.tag_Sequence, new DerOutputStream()\n+                            .write(DerValue.tag_Sequence, new DerOutputStream()\n+                                    .putOID(id_kem_rsa)\n+                                    .write(DerValue.tag_Sequence, kdf))\n+                            .write(DerValue.tag_Sequence, new DerOutputStream()\n+                                    .putOID(oid4(spec.encAlg)))).toByteArray();\n+        }\n+\n+        static RSAKEMParameterSpec decode(byte[] der) throws IOException {\n+            String kdfAlg, encAlg, hashAlg;\n+            int kdfLen;\n+            byte[] fixedInfo;\n+            DerInputStream d2 = new DerValue(der).toDerInputStream();\n+            DerInputStream d3 = d2.getDerValue().toDerInputStream();\n+            if (!d3.getOID().equals(id_kem_rsa)) {\n+                throw new IOException(\"not id_kem_rsa\");\n+            }\n+            DerInputStream d4 = d3.getDerValue().toDerInputStream();\n+            DerInputStream d5 = d4.getDerValue().toDerInputStream();\n+            kdfLen = d4.getInteger();\n+            fixedInfo = d4.available() > 0 ? d4.getOctetString() : null;\n+            d4.atEnd();\n+            ObjectIdentifier kdfOid = d5.getOID();\n+            if (kdfOid.equals(id_kdf1)) {\n+                kdfAlg = \"kdf1\";\n+            } else if (kdfOid.equals(id_kdf2)) {\n+                kdfAlg = \"kdf2\";\n+            } else if (kdfOid.equals(id_kdf3)) {\n+                kdfAlg = \"kdf3\";\n+            } else {\n+                throw new IOException(\"unknown kdf\");\n+            }\n+            DerInputStream d6 = d5.getDerValue().toDerInputStream();\n+            String hashOID = d6.getOID().toString();\n+            KnownOIDs k = KnownOIDs.findMatch(hashOID);\n+            hashAlg = k == null ? hashOID : k.stdName();\n+            d6.atEnd();\n+            d5.atEnd();\n+\n+            d3.atEnd();\n+            DerInputStream d7 = d2.getDerValue().toDerInputStream();\n+            String encOID = d7.getOID().toString();\n+            KnownOIDs e = KnownOIDs.findMatch(encOID);\n+            encAlg = e == null ? encOID : e.stdName();\n+            d7.atEnd();\n+            d2.atEnd();\n+            if (kdfLen != RSAKEMParameterSpec.kdfLen(encAlg)) {\n+                throw new IOException(\"kdfLen does not match encAlg\");\n+            }\n+            return new RSAKEMParameterSpec(kdfAlg, hashAlg, fixedInfo, encAlg);\n+        }\n+\n+        static ObjectIdentifier oid4(String s) {\n+            return switch (s) {\n+                case \"kdf1\" -> id_kdf1;\n+                case \"kdf2\" -> id_kdf2;\n+                case \"kdf3\" -> id_kdf3;\n+                default -> {\n+                    KnownOIDs k = KnownOIDs.findMatch(s);\n+                    if (k == null) throw new UnsupportedOperationException();\n+                    yield ObjectIdentifier.of(k);\n+                }\n+            };\n+        }\n+    }\n+\n+    public static class RSAKEMParameterSpec implements AlgorithmParameterSpec {\n+        private final String kdfAlg;\n+        private final String hashAlg;\n+        private final byte[] fixedInfo;\n+        private final String encAlg;\n+\n+        private RSAKEMParameterSpec(String kdfAlg, String hashAlg, byte[] fixedInfo, String encAlg) {\n+            this.hashAlg = hashAlg;\n+            this.kdfAlg = kdfAlg;\n+            this.fixedInfo = fixedInfo == null ? null : fixedInfo.clone();\n+            this.encAlg = encAlg;\n+        }\n+\n+        public static RSAKEMParameterSpec kdf1(String hashAlg, String encAlg) {\n+            return new RSAKEMParameterSpec(\"kdf1\", hashAlg, null, encAlg);\n+        }\n+        public static RSAKEMParameterSpec kdf2(String hashAlg, String encAlg) {\n+            return new RSAKEMParameterSpec(\"kdf2\", hashAlg, null, encAlg);\n+        }\n+        public static RSAKEMParameterSpec kdf3(String hashAlg, byte[] fixedInfo, String encAlg) {\n+            return new RSAKEMParameterSpec(\"kdf3\", hashAlg, fixedInfo, encAlg);\n+        }\n+\n+        public int kdfLen() {\n+            return RSAKEMParameterSpec.kdfLen(encAlg);\n+        }\n+\n+        public static int kdfLen(String encAlg) {\n+            return Integer.parseInt(encAlg, 4, 7, 10) \/ 8;\n+        }\n+\n+        public String hashAlgorithm() {\n+            return hashAlg;\n+        }\n+        public String kdfAlgorithm() {\n+            return kdfAlg;\n+        }\n+        public byte[] fixedInfo() {\n+            return fixedInfo == null ? null : fixedInfo.clone();\n+        }\n+\n+        public String getEncAlg() {\n+            return encAlg;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"[%s,%s,%s]\", kdfAlg, hashAlg, encAlg);\n+        }\n+    }\n+\n+    public static class KEMImpl implements KEMSpi {\n+\n+        @Override\n+        public KEMSpi.EncapsulatorSpi engineNewEncapsulator(\n+                PublicKey pk, AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (!(pk instanceof RSAPublicKey rpk)) {\n+                throw new InvalidKeyException(\"Not an RSA key\");\n+            }\n+            return Handler.newEncapsulator(spec, rpk, secureRandom);\n+        }\n+\n+        @Override\n+        public KEMSpi.DecapsulatorSpi engineNewDecapsulator(\n+                PrivateKey sk, AlgorithmParameterSpec spec)\n+                throws InvalidAlgorithmParameterException, InvalidKeyException {\n+            if (!(sk instanceof RSAPrivateCrtKey rsk)) {\n+                throw new InvalidKeyException(\"Not an RSA key\");\n+            }\n+            return Handler.newDecapsulator(spec, rsk);\n+        }\n+\n+        static class Handler implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+\n+            private final RSAPublicKey rpk; \/\/ not null for encapsulator\n+            private final RSAPrivateKey rsk; \/\/ not null for decapsulator\n+            private final RSAKEMParameterSpec kspec; \/\/ not null\n+            private final SecureRandom sr; \/\/ not null for encapsulator\n+\n+            Handler(AlgorithmParameterSpec spec, RSAPublicKey rpk, RSAPrivateCrtKey rsk, SecureRandom sr)\n+                    throws InvalidAlgorithmParameterException {\n+                this.rpk = rpk;\n+                this.rsk = rsk;\n+                this.sr = sr;\n+                if (spec != null) {\n+                    if (spec instanceof RSAKEMParameterSpec rs) {\n+                        this.kspec = rs;\n+                    } else {\n+                        throw new InvalidAlgorithmParameterException();\n+                    }\n+                } else {\n+                    this.kspec = RSAKEMParameterSpec\n+                            .kdf2(\"SHA-256\", \"AES_256\/KW\/NoPadding\");\n+                }\n+            }\n+\n+            static Handler newEncapsulator(AlgorithmParameterSpec spec, RSAPublicKey rpk, SecureRandom sr)\n+                    throws InvalidAlgorithmParameterException {\n+                if (sr == null) {\n+                    sr = JCAUtil.getDefSecureRandom();\n+                }\n+                return new Handler(spec, rpk, null, sr);\n+            }\n+\n+            static Handler newDecapsulator(AlgorithmParameterSpec spec, RSAPrivateCrtKey rsk)\n+                    throws InvalidAlgorithmParameterException {\n+                return new Handler(spec, null, rsk, null);\n+            }\n+\n+            @Override\n+            public SecretKey engineDecapsulate(byte[] encapsulation,\n+                    int from, int to, String algorithm)\n+                    throws DecapsulateException {\n+                Objects.checkFromToIndex(from, to, kspec.kdfLen());\n+                Objects.requireNonNull(algorithm, \"null algorithm\");\n+                Objects.requireNonNull(encapsulation, \"null encapsulation\");\n+                if (encapsulation.length != KeyUtil.getKeySize(rsk) \/ 8) {\n+                    throw new DecapsulateException(\"incorrect encapsulation size\");\n+                }\n+                try {\n+                    byte[] Z = RSACore.rsa(encapsulation, rsk, false);\n+                    return new SecretKeySpec(kdf(Z), from, to - from, algorithm);\n+                } catch (BadPaddingException e) {\n+                    throw new DecapsulateException(\"cannot decrypt\", e);\n+                }\n+            }\n+\n+            @Override\n+            public KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm) {\n+                Objects.checkFromToIndex(from, to, kspec.kdfLen());\n+                Objects.requireNonNull(algorithm, \"null algorithm\");\n+                int nLen = rpk.getModulus().bitLength();\n+                int nSize = (nLen + 7) \/ 8;\n+                BigInteger z;\n+                int tried = 0;\n+                while (true) {\n+                    z = new BigInteger(nLen, sr);\n+                    if (z.compareTo(rpk.getModulus()) < 0) {\n+                        break;\n+                    }\n+                    if (tried++ > 20) {\n+                        throw new ProviderException(\"Cannot get good random number\");\n+                    }\n+                }\n+                byte[] Z = z.toByteArray();\n+                if (Z.length > nSize) {\n+                    Z = Arrays.copyOfRange(Z, Z.length - nSize, Z.length);\n+                } else if (Z.length < nSize) {\n+                    byte[] tmp = new byte[nSize];\n+                    System.arraycopy(Z, 0, tmp, nSize - Z.length, Z.length);\n+                    Z = tmp;\n+                }\n+                byte[] c;\n+                try {\n+                    c = RSACore.rsa(Z, rpk);\n+                } catch (BadPaddingException e) {\n+                    throw new AssertionError(e);\n+                }\n+                return new KEM.Encapsulated(\n+                        new SecretKeySpec(kdf(Z), from, to - from, algorithm),\n+                        c, AlgorithmParametersImpl.encode(kspec));\n+            }\n+\n+            byte[] kdf(byte[] input) {\n+                String hashAlg = kspec.hashAlgorithm();\n+                MessageDigest md;\n+                try {\n+                    md = MessageDigest.getInstance(hashAlg);\n+                } catch (NoSuchAlgorithmException e) {\n+                    throw new ProviderException(e);\n+                }\n+                String kdfAlg = kspec.kdfAlgorithm();\n+                byte[] fixedInput = kspec.fixedInfo();\n+                int length = kspec.kdfLen();\n+\n+                ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+                int n = kdfAlg.equals(\"kdf1\") ? 0 : 1;\n+                while (true) {\n+                    switch (kdfAlg) {\n+                        case \"kdf1\", \"kdf2\" -> {\n+                            md.update(input);\n+                            md.update(u32str(n));\n+                        }\n+                        case \"kdf3\" -> {\n+                            md.update(u32str(n));\n+                            md.update(input);\n+                            md.update(fixedInput);\n+                        }\n+                        default -> throw new ProviderException();\n+                    }\n+                    bout.writeBytes(md.digest());\n+                    if (bout.size() > length) break;\n+                    n++;\n+                }\n+                byte[] result = bout.toByteArray();\n+                return result.length == length\n+                        ? result\n+                        : Arrays.copyOf(result, length);\n+            }\n+\n+            @Override\n+            public int engineSecretSize() {\n+                return kspec.kdfLen();\n+            }\n+\n+            @Override\n+            public int engineEncapsulationSize() {\n+                return KeyUtil.getKeySize(rsk == null ? rpk : rsk) \/ 8;\n+            }\n+        }\n+    }\n+\n+    static byte[] u32str(int i) {\n+        return new byte[] {\n+                (byte)(i >> 24), (byte)(i >> 16), (byte)(i >> 8), (byte)i };\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/KEM\/RSA_KEM.java","additions":501,"deletions":0,"binary":false,"changes":501,"status":"added"}]}