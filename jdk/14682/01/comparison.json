{"files":[{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @bug 4512215 4818420 4819436\n- * @summary Updated currency data.\n- *\/\n-\n-import java.util.Currency;\n-import java.util.Locale;\n-\n-public class Bug4512215 {\n-\n-    public static void main(String[] args) throws Exception {\n-        testCurrencyDefined(\"XBD\", -1);\n-        testCountryCurrency(\"TJ\", \"TJS\", 2);\n-        testCountryCurrency(\"FO\", \"DKK\", 2);\n-        testCountryCurrency(\"FK\", \"FKP\", 2);\n-\n-        testCountryCurrency(\"AF\", \"AFN\", 2);    \/\/ changed from \"AFA\"\n-\n-        \/\/ Newsletter V-5 on ISO 3166-1 (2002-05-20)\n-        testCountryCurrency(\"TL\", \"USD\", 2);    \/\/ successor to TP\/TPE\n-\n-        \/\/ Newsletter V-8 on ISO 3166-1 (2003-07-23)\n-        testCountryCurrency(\"CS\", \"CSD\", 2);    \/\/ successor to YU\/YUM\n-    }\n-\n-    private static void testCountryCurrency(String country, String currencyCode,\n-            int digits) {\n-        testCurrencyDefined(currencyCode, digits);\n-        Currency currency = Currency.getInstance(Locale.of(\"\", country));\n-        if (!currency.getCurrencyCode().equals(currencyCode)) {\n-            throw new RuntimeException(\"[\" + country\n-                    + \"] expected: \" + currencyCode\n-                    + \"; got: \" + currency.getCurrencyCode());\n-        }\n-    }\n-\n-    private static void testCurrencyDefined(String currencyCode, int digits) {\n-        Currency currency = Currency.getInstance(currencyCode);\n-        if (currency.getDefaultFractionDigits() != digits) {\n-            throw new RuntimeException(\"[\" + currencyCode\n-                    + \"] expected: \" + digits\n-                    + \"; got: \" + currency.getDefaultFractionDigits());\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Currency\/Bug4512215.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n- * @test\n- * @bug 6807534\n- * @summary check whether the default implementation of\n- *    CurrencNameProvider.getDisplayName(String, Locale) throws appropriate\n- *    exceptions when necessary.\n- *\/\n-\n-import java.util.Locale;\n-import java.util.spi.CurrencyNameProvider;\n-\n-public class Bug6807534 {\n-\n-    static final CurrencyNameProvider cnp = new CurrencyNameProviderImpl();\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ test for NullPointerException (currencyCode)\n-        try {\n-            cnp.getDisplayName(null, Locale.US);\n-            throwException(\"NPE was not thrown with null currencyCode\");\n-        } catch (NullPointerException npe) {}\n-\n-        \/\/ test for NullPointerException (locale)\n-        try {\n-            cnp.getDisplayName(\"USD\", null);\n-            throwException(\"NPE was not thrown with null locale\");\n-        } catch (NullPointerException npe) {}\n-\n-        \/\/ test for IllegalArgumentException (illegal currencyCode)\n-        try {\n-            cnp.getDisplayName(\"INVALID\", Locale.US);\n-            throwException(\"IllegalArgumentException was not thrown with invalid currency code\");\n-        } catch (IllegalArgumentException iae) {}\n-        try {\n-            cnp.getDisplayName(\"inv\", Locale.US);\n-            throwException(\"IllegalArgumentException was not thrown with invalid currency code\");\n-        } catch (IllegalArgumentException iae) {}\n-\n-        \/\/ test for IllegalArgumentException (non-supported locale)\n-        try {\n-            cnp.getDisplayName(\"USD\", Locale.JAPAN);\n-            throwException(\"IllegalArgumentException was not thrown with non-supported locale\");\n-        } catch (IllegalArgumentException iae) {}\n-    }\n-\n-    static void throwException(String msg) {\n-        throw new RuntimeException(\"test failed. \"+msg);\n-    }\n-\n-    static class CurrencyNameProviderImpl extends CurrencyNameProvider {\n-        \/\/ dummy implementation\n-        public String getSymbol(String currencyCode, Locale locale) {\n-            return \"\";\n-        }\n-\n-        public Locale[] getAvailableLocales() {\n-            Locale[] avail = new Locale[1];\n-            avail[0] = Locale.US;\n-            return avail;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/Currency\/Bug6807534.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -27,0 +28,1 @@\n+ * @run junit Bug8154295\n@@ -30,0 +32,1 @@\n+import java.util.stream.Stream;\n@@ -31,3 +34,3 @@\n-public class Bug8154295 {\n-\n-    public static void main(String[] args) {\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -35,5 +38,1 @@\n-        String numericCode = Currency.getInstance(\"AFA\").getNumericCodeAsString();\n-        if (!numericCode.equals(\"004\")) { \/\/should return \"004\" (a 3 digit string)\n-           throw new RuntimeException(\"[Expected 004, \"\n-                + \"found \"+numericCode+\" for AFA]\");\n-        }\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -41,11 +40,1 @@\n-        numericCode = Currency.getInstance(\"AUD\").getNumericCodeAsString();\n-        if (!numericCode.equals(\"036\")) { \/\/should return \"036\" (a 3 digit string)\n-            throw new RuntimeException(\"[Expected 036, \"\n-                + \"found \"+numericCode+\" for AUD]\");\n-        }\n-\n-        numericCode = Currency.getInstance(\"USD\").getNumericCodeAsString();\n-        if (!numericCode.equals(\"840\")) {\/\/ should return \"840\" (a 3 digit string)\n-            throw new RuntimeException(\"[Expected 840, \"\n-                + \"found \"+numericCode+\" for USD]\");\n-        }\n+public class Bug8154295 {\n@@ -53,0 +42,10 @@\n+    \/**\n+     * Ensure getNumericCodeAsString() returns the correct 3-digit numeric code\n+     * for the associated currency Code.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"codeProvider\")\n+    public void checkNumCodeTest(String currCode, String expectedNumCode) {\n+        String actualNumCode = Currency.getInstance(currCode).getNumericCodeAsString();\n+        assertEquals(expectedNumCode, actualNumCode, String.format(\n+                \"Expected: %s, but got: %s, for %s\", expectedNumCode, actualNumCode, currCode));\n@@ -55,0 +54,7 @@\n+    private static Stream<Arguments> codeProvider() {\n+        return Stream.of(\n+                Arguments.of(\"AFA\", \"004\"),\n+                Arguments.of(\"AUD\", \"036\"),\n+                Arguments.of(\"USD\", \"840\")\n+        );\n+    }\n","filename":"test\/jdk\/java\/util\/Currency\/Bug8154295.java","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,4 +23,5 @@\n-\/**\n- *\n- *\n- * Check the consistency between the regression tests and the currency data in the JRE\n+\n+\n+\/*\n+  Check the consistency between the regression tests and the currency\n+  data in the JRE. This class is used by other test classes.\n@@ -29,3 +30,8 @@\n-import java.io.*;\n-import java.lang.reflect.*;\n-import java.security.*;\n+import java.io.BufferedReader;\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n","filename":"test\/jdk\/java\/util\/Currency\/CheckDataVersion.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6807534\n+ * @summary check whether the default implementation of\n+ *    CurrencyNameProvider.getDisplayName(String, Locale) throws appropriate\n+ *    exceptions when necessary.\n+ * @run junit CurrencyNameProviderTest\n+ *\/\n+\n+import java.util.Locale;\n+import java.util.spi.CurrencyNameProvider;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class CurrencyNameProviderTest {\n+\n+    static final CurrencyNameProvider cnp = new CurrencyNameProviderImpl();\n+\n+    \/**\n+     * Tests that the currency name provider throws a NullPointerException\n+     * under the expected circumstances.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"nullArgProvider\")\n+    public void NPETest(String currencyCode, Locale locale, String err) {\n+        assertThrows(NullPointerException.class,\n+                () -> cnp.getDisplayName(currencyCode, locale), err);\n+    }\n+\n+    \/**\n+     * Tests that the currency name provider throws a IllegalArgumentException\n+     * under the expected circumstances.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"illegalArgProvider\")\n+    public void IAETest(String currencyCode, Locale locale, String err) {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> cnp.getDisplayName(currencyCode, locale), err);\n+    }\n+\n+    private static Stream<Arguments> nullArgProvider() {\n+        return Stream.of(\n+                Arguments.of(null, Locale.US,\n+                        \"NPE was not thrown with null currencyCode\"),\n+                Arguments.of(\"USD\", null,\n+                        \"NPE was not thrown with null locale\")\n+        );\n+    }\n+\n+    private static Stream<Arguments> illegalArgProvider() {\n+        return Stream.of(\n+                Arguments.of(\"INVALID\", Locale.US,\n+                        \"IAE was not thrown with invalid currency code\"),\n+                Arguments.of(\"inv\", Locale.US,\n+                        \"IAE was not thrown with invalid currency code\"),\n+                Arguments.of(\"USD\", Locale.JAPAN,\n+                        \"IllegalArgumentException was not thrown with non-supported locale\")\n+        );\n+    }\n+\n+    static class CurrencyNameProviderImpl extends CurrencyNameProvider {\n+        \/\/ dummy implementation\n+        public String getSymbol(String currencyCode, Locale locale) {\n+            return \"\";\n+        }\n+\n+        public Locale[] getAvailableLocales() {\n+            Locale[] avail = new Locale[1];\n+            avail[0] = Locale.US;\n+            return avail;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Currency\/CurrencyNameProviderTest.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -31,0 +32,1 @@\n+ * @run junit CurrencyTest\n@@ -41,0 +43,1 @@\n+import java.util.ArrayList;\n@@ -42,0 +45,1 @@\n+import java.util.List;\n@@ -43,0 +47,11 @@\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n@@ -47,1 +62,3 @@\n-    public static void main(String[] args) throws Exception {\n+    \/\/ 'tablea1.txt' should be up-to-date before testing\n+    @Test\n+    public void dataVersionTest() {\n@@ -49,7 +66,0 @@\n-        testCurrencyCodeValidation();\n-        testLocaleMapping();\n-        testSymbols();\n-        testFractionDigits();\n-        testSerialization();\n-        testDisplayNames();\n-        testFundsCodes();\n@@ -58,14 +68,8 @@\n-    static void testCurrencyCodeValidation() {\n-        \/\/ test creation of some valid currencies\n-        testValidCurrency(\"USD\");\n-        testValidCurrency(\"EUR\");\n-        testValidCurrency(\"GBP\");\n-        testValidCurrency(\"JPY\");\n-        testValidCurrency(\"CNY\");\n-        testValidCurrency(\"CHF\");\n-\n-        \/\/ test creation of some fictitious currencies\n-        testInvalidCurrency(\"AQD\");\n-        testInvalidCurrency(\"US$\");\n-        testInvalidCurrency(\"\\u20AC\");\n-    }\n+    @Nested\n+    class CodeValidationTests {\n+        \/\/ Calling getInstance() on equal currency codes should return equal currencies\n+        @ParameterizedTest\n+        @MethodSource(\"validCurrencies\")\n+        public void validCurrencyTest(String currencyCode) {\n+            compareCurrencies(currencyCode);\n+        }\n@@ -73,5 +77,2 @@\n-    static void testValidCurrency(String currencyCode) {\n-        Currency currency1 = Currency.getInstance(currencyCode);\n-        Currency currency2 = Currency.getInstance(currencyCode);\n-        if (currency1 != currency2) {\n-            throw new RuntimeException(\"Didn't get same instance for same currency code\");\n+        private static Stream<String> validCurrencies() {\n+            return Stream.of(\"USD\", \"EUR\", \"GBP\", \"JPY\", \"CNY\", \"CHF\");\n@@ -79,2 +80,11 @@\n-        if (!currency1.getCurrencyCode().equals(currencyCode)) {\n-            throw new RuntimeException(\"Currency code changed\");\n+\n+        \/\/ Calling getInstance() with an illegal name should throw an IAE\n+        @ParameterizedTest\n+        @MethodSource(\"invalidCurrencies\")\n+        public void invalidCurrencyTest(String currencyCode) {\n+            assertThrows(IllegalArgumentException.class, () ->\n+                    Currency.getInstance(currencyCode), \"getInstance() did not throw IAE\");\n+        }\n+\n+        private static Stream<String> invalidCurrencies() {\n+            return Stream.of(\"AQD\", \"US$\", \"\\u20AC\");\n@@ -84,6 +94,24 @@\n-    static void testInvalidCurrency(String currencyCode) {\n-        boolean gotException = false;\n-        try {\n-            Currency currency = Currency.getInstance(currencyCode);\n-        } catch (IllegalArgumentException e) {\n-            gotException = true;\n+    @Nested\n+    class FundsCodesTests {\n+        \/\/ Calling getInstance() on equal currency codes should return equal currencies\n+        @ParameterizedTest\n+        @MethodSource(\"fundsCodes\")\n+        public void validCurrencyTest(String currencyCode) {\n+            compareCurrencies(currencyCode);\n+        }\n+\n+        \/\/ Verify a currency has the expected fractional digits\n+        @ParameterizedTest\n+        @MethodSource(\"fundsCodes\")\n+        public void fractionDigitTest(String currencyCode, int expectedFractionDigits) {\n+            compareFractionDigits(currencyCode, expectedFractionDigits);\n+        }\n+\n+        \/\/ Verify a currency has the expected numeric code\n+        @ParameterizedTest\n+        @MethodSource(\"fundsCodes\")\n+        public void numericCodeTest(String currencyCode, int ignored, int expectedNumeric) {\n+            int numeric = Currency.getInstance(currencyCode).getNumericCode();\n+            assertEquals(numeric, expectedNumeric, String.format(\n+                    \"Wrong numeric code for currency %s, expected %s, got %s\",\n+                    currencyCode, expectedNumeric, numeric));\n@@ -91,2 +119,8 @@\n-        if (!gotException) {\n-            throw new RuntimeException(\"didn't get specified exception\");\n+\n+        private static Stream<Arguments> fundsCodes() {\n+            return Stream.of(\n+                    Arguments.of(\"BOV\", 2, 984), Arguments.of(\"CHE\", 2, 947),\n+                    Arguments.of(\"CHW\", 2, 948), Arguments.of(\"CLF\", 4, 990),\n+                    Arguments.of(\"COU\", 2, 970), Arguments.of(\"MXV\", 2, 979),\n+                    Arguments.of(\"USN\", 2, 997), Arguments.of(\"UYI\", 0, 940)\n+            );\n@@ -96,1 +130,3 @@\n-    static void testLocaleMapping() {\n+    @Nested\n+    class LocaleMappingTests {\n+\n@@ -99,25 +135,19 @@\n-        Locale[] locales = Locale.getAvailableLocales();\n-        int goodCountries = 0;\n-        int ownCurrencies = 0;\n-        for (int i = 0; i < locales.length; i++) {\n-            Locale locale = locales[i];\n-            String ctryCode = locale.getCountry();\n-            int ctryLength = ctryCode.length();\n-            if (ctryLength == 0 ||\n-                ctryLength == 3 || \/\/ UN M.49 code\n-                ctryCode.matches(\"AA|Q[M-Z]|X[A-JL-Z]|ZZ\" + \/\/ user defined codes, excluding \"XK\" (Kosovo)\n-                                 \"AC|CP|DG|EA|EU|FX|IC|SU|TA|UK\")) { \/\/ exceptional reservation codes\n-                boolean gotException = false;\n-                try {\n-                    Currency.getInstance(locale);\n-                } catch (IllegalArgumentException e) {\n-                    gotException = true;\n-                }\n-                if (!gotException) {\n-                    throw new RuntimeException(\"didn't get specified exception\");\n-                }\n-            } else {\n-                goodCountries++;\n-                Currency currency = Currency.getInstance(locale);\n-                if (currency.getCurrencyCode().indexOf(locale.getCountry()) == 0) {\n-                    ownCurrencies++;\n+        @Test\n+        public void localeMappingTest() {\n+            Locale[] locales = Locale.getAvailableLocales();\n+            int goodCountries = 0;\n+            int ownCurrencies = 0;\n+            for (Locale locale : locales) {\n+                String ctryCode = locale.getCountry();\n+                int ctryLength = ctryCode.length();\n+                if (ctryLength == 0 ||\n+                        ctryLength == 3 || \/\/ UN M.49 code\n+                        ctryCode.matches(\"AA|Q[M-Z]|X[A-JL-Z]|ZZ\" + \/\/ user defined codes, excluding \"XK\" (Kosovo)\n+                                \"AC|CP|DG|EA|EU|FX|IC|SU|TA|UK\")) { \/\/ exceptional reservation codes\n+                    assertThrows(IllegalArgumentException.class, () -> Currency.getInstance(locale), \"Did not throw IAE\");\n+                } else {\n+                    goodCountries++;\n+                    Currency currency = Currency.getInstance(locale);\n+                    if (currency.getCurrencyCode().indexOf(locale.getCountry()) == 0) {\n+                        ownCurrencies++;\n+                    }\n@@ -126,0 +156,5 @@\n+            System.out.println(\"Countries tested: \" + goodCountries +\n+                    \", own currencies: \" + ownCurrencies);\n+            if (ownCurrencies < (goodCountries \/ 2 + 1)) {\n+                throw new RuntimeException(\"suspicious: not enough countries have their own currency.\");\n+            }\n@@ -127,4 +162,6 @@\n-        System.out.println(\"Countries tested: \" + goodCountries +\n-                \", own currencies: \" + ownCurrencies);\n-        if (ownCurrencies < (goodCountries \/ 2 + 1)) {\n-            throw new RuntimeException(\"suspicious: not enough countries have their own currency.\");\n+\n+        \/\/ Check an invalid country code\n+        @Test\n+        public void invalidCountryTest() {\n+            assertThrows(IllegalArgumentException.class, ()->\n+                    Currency.getInstance(Locale.of(\"\", \"EU\")), \"Did not throw IAE\");\n@@ -133,5 +170,9 @@\n-        \/\/ check a few countries that don't change their currencies too often\n-        String[] country1 = {\"US\", \"CA\", \"JP\", \"CN\", \"SG\", \"CH\"};\n-        String[] currency1 = {\"USD\", \"CAD\", \"JPY\", \"CNY\", \"SGD\", \"CHF\"};\n-        for (int i = 0; i < country1.length; i++) {\n-            checkCountryCurrency(country1[i], currency1[i]);\n+        \/\/ Ensure a selection of countries have the expected currency\n+        @ParameterizedTest\n+        @MethodSource({\"countryProvider\", \"switchedOverCountries\"})\n+        public void countryCurrencyTest(String countryCode, String expected) {\n+            Locale locale = Locale.of(\"\", countryCode);\n+            Currency currency = Currency.getInstance(locale);\n+            String code = (currency != null) ? currency.getCurrencyCode() : null;\n+            assertEquals(expected, code, generateErrMsg(\n+                    \"currency for\", locale.getDisplayCountry(), expected, code));\n@@ -140,21 +181,12 @@\n-        \/*\n-        * check currency changes\n-        * In current implementation, there is no data of old currency and transition date at jdk\/src\/java.base\/share\/data\/currency\/CurrencyData.properties.\n-        * So, all the switch data arrays are empty. In the future, if data of old currency and transition date are necessary for any country, the\n-        * arrays here can be updated so that the program can check the currency switch.\n-        *\/\n-        String[] switchOverCtry = {};\n-        String[] switchOverOld = {};\n-        String[] switchOverNew = {};\n-        String[] switchOverTZ = {};\n-        int[] switchOverYear = {};\n-        int[] switchOverMonth = {}; \/\/ java.time APIs accept month starting from 1 i.e. 01 for January\n-        int[] switchOverDay = {};\n-\n-        for (int i = 0; i < switchOverCtry.length; i++) {\n-            ZoneId zoneId = ZoneId.of(switchOverTZ[i]);\n-            ZonedDateTime zonedDateAndTime  = ZonedDateTime.of(LocalDate.of(switchOverYear[i], switchOverMonth[i], switchOverDay[i]),\n-                                                  LocalTime.MIDNIGHT, zoneId);\n-            ZonedDateTime currentZonedDateAndTime =  ZonedDateTime.now(zoneId);\n-            checkCountryCurrency(switchOverCtry[i], (currentZonedDateAndTime.isAfter(zonedDateAndTime) ||\n-                        currentZonedDateAndTime.isEqual(zonedDateAndTime)) ? switchOverNew[i] : switchOverOld[i]);\n+        private static Stream<Arguments> countryProvider() {\n+            return Stream.of(\n+                    \/\/ Check country that does not have a currency\n+                    Arguments.of(\"AQ\", null),\n+                    \/\/ Check some countries that don't change their currencies often\n+                    Arguments.of(\"US\", \"USD\"),\n+                    Arguments.of(\"CA\", \"CAD\"),\n+                    Arguments.of(\"JP\", \"JPY\"),\n+                    Arguments.of(\"CN\", \"CNY\"),\n+                    Arguments.of(\"SG\", \"SGD\"),\n+                    Arguments.of(\"CH\", \"CHF\")\n+            );\n@@ -163,2 +195,17 @@\n-        \/\/ check a country code which doesn't have a currency\n-        checkCountryCurrency(\"AQ\", null);\n+        \/*\n+         * Check Currency Changes\n+         * In the current implementation, there is no data of old currency and transition\n+         * date at jdk\/src\/java.base\/share\/data\/currency\/CurrencyData.properties.\n+         * So, all the switch data arrays are empty. In the future, if data of old\n+         * currency and transition date are necessary for any country, the\n+         * arrays here can be updated so that the program can check the currency switch.\n+         *\/\n+        private static List<Arguments> switchedOverCountries() {\n+            List<Arguments> switched = new ArrayList<Arguments>();\n+            String[] switchOverCtry = {};\n+            String[] switchOverOld = {};\n+            String[] switchOverNew = {};\n+            String[] switchOverTZ = {};\n+            int[] switchOverYear = {};\n+            int[] switchOverMonth = {}; \/\/ java.time APIs accept month starting from 1 i.e. 01 for January\n+            int[] switchOverDay = {};\n@@ -166,9 +213,9 @@\n-        \/\/ check an invalid country code\n-        boolean gotException = false;\n-        try {\n-            Currency.getInstance(Locale.of(\"\", \"EU\"));\n-        } catch (IllegalArgumentException e) {\n-            gotException = true;\n-        }\n-        if (!gotException) {\n-            throw new RuntimeException(\"didn't get specified exception.\");\n+            for (int i = 0; i < switchOverCtry.length; i++) {\n+                ZoneId zoneId = ZoneId.of(switchOverTZ[i]);\n+                ZonedDateTime zonedDateAndTime  = ZonedDateTime.of(LocalDate.of(\n+                        switchOverYear[i], switchOverMonth[i], switchOverDay[i]), LocalTime.MIDNIGHT, zoneId);\n+                ZonedDateTime currentZonedDateAndTime =  ZonedDateTime.now(zoneId);\n+                switched.add(Arguments.of(switchOverCtry[i], (currentZonedDateAndTime.isAfter(zonedDateAndTime)\n+                        || currentZonedDateAndTime.isEqual(zonedDateAndTime)) ? switchOverNew[i] : switchOverOld[i]));\n+            }\n+            return switched;\n@@ -178,10 +225,1 @@\n-    static void checkCountryCurrency(String countryCode, String expected) {\n-        Locale locale = Locale.of(\"\", countryCode);\n-        Currency currency = Currency.getInstance(locale);\n-        String code = (currency != null) ? currency.getCurrencyCode() : null;\n-        if (!(expected == null ? code == null : expected.equals(code))) {\n-            throw new RuntimeException(\"Wrong currency for \" +\n-                    locale.getDisplayCountry() +\n-                    \": expected \" + expected + \", got \" + code);\n-        }\n-    }\n+    \/\/ NON-NESTED TESTS\n@@ -189,4 +227,5 @@\n-    static void testSymbols() {\n-        testSymbol(\"USD\", Locale.US, \"$\");\n-        testSymbol(\"EUR\", Locale.GERMANY, \"\\u20AC\");\n-        testSymbol(\"USD\", Locale.PRC, \"US$\");\n+    \/\/ Ensure selection of currencies have the correct fractional digits\n+    @ParameterizedTest\n+    @MethodSource(\"expectedFractionsProvider\")\n+    public void fractionDigitsTest(String currencyCode, int expectedFractionDigits) {\n+        compareFractionDigits(currencyCode, expectedFractionDigits);\n@@ -195,7 +234,10 @@\n-    static void testSymbol(String currencyCode, Locale locale, String expectedSymbol) {\n-        String symbol = Currency.getInstance(currencyCode).getSymbol(locale);\n-        if (!symbol.equals(expectedSymbol)) {\n-            throw new RuntimeException(\"Wrong symbol for currency \" +\n-                    currencyCode +\": expected \" + expectedSymbol +\n-                    \", got \" + symbol);\n-        }\n+    private static Stream<Arguments> expectedFractionsProvider() {\n+        return Stream.of(\n+                Arguments.of(\"USD\", 2), Arguments.of(\"EUR\", 2),\n+                Arguments.of(\"JPY\", 0), Arguments.of(\"XDR\", -1),\n+                Arguments.of(\"BHD\", 3), Arguments.of(\"IQD\", 3),\n+                Arguments.of(\"JOD\", 3), Arguments.of(\"KWD\", 3),\n+                Arguments.of(\"LYD\", 3), Arguments.of(\"OMR\", 3),\n+                Arguments.of(\"TND\", 3), Arguments.of(\"TRL\", 0), \/\/ Turkish Lira\n+                Arguments.of(\"TRY\", 2)\n+        );\n@@ -204,17 +246,7 @@\n-    static void testFractionDigits() {\n-        testFractionDigits(\"USD\", 2);\n-        testFractionDigits(\"EUR\", 2);\n-        testFractionDigits(\"JPY\", 0);\n-        testFractionDigits(\"XDR\", -1);\n-\n-        testFractionDigits(\"BHD\", 3);\n-        testFractionDigits(\"IQD\", 3);\n-        testFractionDigits(\"JOD\", 3);\n-        testFractionDigits(\"KWD\", 3);\n-        testFractionDigits(\"LYD\", 3);\n-        testFractionDigits(\"OMR\", 3);\n-        testFractionDigits(\"TND\", 3);\n-\n-        \/\/ Turkish Lira\n-        testFractionDigits(\"TRL\", 0);\n-        testFractionDigits(\"TRY\", 2);\n+    \/\/ Ensure selection of currencies have the expected symbol\n+    @ParameterizedTest\n+    @MethodSource(\"symbolProvider\")\n+    public void symbolTest(String currencyCode, Locale locale, String expectedSymbol) {\n+        String symbol = Currency.getInstance(currencyCode).getSymbol(locale);\n+        assertEquals(symbol, expectedSymbol, generateErrMsg(\n+                \"symbol for\", currencyCode, expectedSymbol, symbol));\n@@ -223,7 +255,6 @@\n-    static void testFractionDigits(String currencyCode, int expectedFractionDigits) {\n-        int digits = Currency.getInstance(currencyCode).getDefaultFractionDigits();\n-        if (digits != expectedFractionDigits) {\n-            throw new RuntimeException(\"Wrong number of fraction digits for currency \" +\n-                    currencyCode +\": expected \" + expectedFractionDigits +\n-                    \", got \" + digits);\n-        }\n+    private static Stream<Arguments> symbolProvider() {\n+        return Stream.of(\n+                Arguments.of(\"USD\", Locale.US, \"$\"),\n+                Arguments.of(\"EUR\", Locale.GERMANY, \"\\u20AC\"),\n+                Arguments.of(\"USD\", Locale.PRC, \"US$\")\n+        );\n@@ -232,1 +263,4 @@\n-    static void testSerialization() throws Exception {\n+    \/\/ Ensure serialization does not break class invariant.\n+    \/\/ Currency should be able to round-trip and remain the same value.\n+    @Test\n+    public void serializationTest() throws Exception {\n@@ -244,4 +278,1 @@\n-\n-        if (currency1 != currency2) {\n-            throw new RuntimeException(\"serialization breaks class invariant\");\n-        }\n+        assertEquals(currency1, currency2, \"serialization breaks class invariant\");\n@@ -250,17 +281,5 @@\n-    static void testDisplayNames() {\n-        \/\/ null argument test\n-        try {\n-            testDisplayName(\"USD\", null, \"\");\n-            throw new RuntimeException(\"getDisplayName(NULL) did not throw an NPE.\");\n-        } catch (NullPointerException npe) {}\n-\n-        testDisplayName(\"USD\", Locale.ENGLISH, \"US Dollar\");\n-        testDisplayName(\"FRF\", Locale.FRENCH, \"franc fran\\u00e7ais\");\n-        testDisplayName(\"DEM\", Locale.GERMAN, \"Deutsche Mark\");\n-        testDisplayName(\"ESP\", Locale.of(\"es\"), \"peseta espa\\u00f1ola\");\n-        testDisplayName(\"ITL\", Locale.ITALIAN, \"lira italiana\");\n-        testDisplayName(\"JPY\", Locale.JAPANESE, \"\\u65e5\\u672c\\u5186\");\n-        testDisplayName(\"KRW\", Locale.KOREAN, \"\\ub300\\ud55c\\ubbfc\\uad6d \\uc6d0\");\n-        testDisplayName(\"SEK\", Locale.of(\"sv\"), \"svensk krona\");\n-        testDisplayName(\"CNY\", Locale.SIMPLIFIED_CHINESE, \"\\u4eba\\u6c11\\u5e01\");\n-        testDisplayName(\"TWD\", Locale.TRADITIONAL_CHINESE, \"\\u65b0\\u53f0\\u5e63\");\n+    \/\/ Ensure getInstance() throws null when passed a null locale\n+    @Test\n+    public void nullDisplayNameTest() {\n+        assertThrows(NullPointerException.class, ()->\n+                Currency.getInstance(\"USD\").getDisplayName(null));\n@@ -269,1 +288,4 @@\n-    static void testDisplayName(String currencyCode, Locale locale, String expectedName) {\n+    \/\/ Ensure a selection of currencies\/locale combos have the correct display name\n+    @ParameterizedTest\n+    @MethodSource(\"displayNameProvider\")\n+    public void displayNameTest(String currencyCode, Locale locale, String expectedName) {\n@@ -271,5 +293,2 @@\n-        if (!name.equals(expectedName)) {\n-            throw new RuntimeException(\"Wrong display name for currency \" +\n-                    currencyCode +\": expected '\" + expectedName +\n-                    \"', got '\" + name + \"'\");\n-        }\n+        assertEquals(name, expectedName, generateErrMsg(\n+                \"display name for\", currencyCode, expectedName, name));\n@@ -277,27 +296,14 @@\n-    static void testFundsCodes() {\n-        testValidCurrency(\"BOV\");\n-        testValidCurrency(\"CHE\");\n-        testValidCurrency(\"CHW\");\n-        testValidCurrency(\"CLF\");\n-        testValidCurrency(\"COU\");\n-        testValidCurrency(\"MXV\");\n-        testValidCurrency(\"USN\");\n-        testValidCurrency(\"UYI\");\n-\n-        testFractionDigits(\"BOV\", 2);\n-        testFractionDigits(\"CHE\", 2);\n-        testFractionDigits(\"CHW\", 2);\n-        testFractionDigits(\"CLF\", 4);\n-        testFractionDigits(\"COU\", 2);\n-        testFractionDigits(\"MXV\", 2);\n-        testFractionDigits(\"USN\", 2);\n-        testFractionDigits(\"UYI\", 0);\n-\n-        testNumericCode(\"BOV\", 984);\n-        testNumericCode(\"CHE\", 947);\n-        testNumericCode(\"CHW\", 948);\n-        testNumericCode(\"CLF\", 990);\n-        testNumericCode(\"COU\", 970);\n-        testNumericCode(\"MXV\", 979);\n-        testNumericCode(\"USN\", 997);\n-        testNumericCode(\"UYI\", 940);\n+\n+    private static Stream<Arguments> displayNameProvider() {\n+        return Stream.of(\n+                Arguments.of(\"USD\", Locale.ENGLISH, \"US Dollar\"),\n+                Arguments.of(\"FRF\", Locale.FRENCH, \"franc fran\\u00e7ais\"),\n+                Arguments.of(\"DEM\", Locale.GERMAN, \"Deutsche Mark\"),\n+                Arguments.of(\"ESP\", Locale.of(\"es\"), \"peseta espa\\u00f1ola\"),\n+                Arguments.of(\"ITL\", Locale.ITALIAN, \"lira italiana\"),\n+                Arguments.of(\"JPY\", Locale.JAPANESE, \"\\u65e5\\u672c\\u5186\"),\n+                Arguments.of(\"KRW\", Locale.KOREAN, \"\\ub300\\ud55c\\ubbfc\\uad6d \\uc6d0\"),\n+                Arguments.of(\"SEK\", Locale.of(\"sv\"), \"svensk krona\"),\n+                Arguments.of(\"CNY\", Locale.SIMPLIFIED_CHINESE, \"\\u4eba\\u6c11\\u5e01\"),\n+                Arguments.of(\"TWD\", Locale.TRADITIONAL_CHINESE, \"\\u65b0\\u53f0\\u5e63\")\n+        );\n@@ -306,7 +312,26 @@\n-    static void testNumericCode(String currencyCode, int expectedNumeric) {\n-        int numeric = Currency.getInstance(currencyCode).getNumericCode();\n-        if (numeric != expectedNumeric) {\n-            throw new RuntimeException(\"Wrong numeric code for currency \" +\n-                    currencyCode +\": expected \" + expectedNumeric +\n-                    \", got \" + numeric);\n-        }\n+    \/\/ HELPER FUNCTIONS\n+\n+    \/\/ A Currency instance returned from getInstance() should always be\n+    \/\/ equal if supplied the same currencyCode. getCurrencyCode() should\n+    \/\/ always be equal to the currencyCode used to create the Currency.\n+    private static void compareCurrencies(String currencyCode) {\n+        Currency currency1 = Currency.getInstance(currencyCode);\n+        Currency currency2 = Currency.getInstance(currencyCode);\n+        assertEquals(currency1, currency2, \"Didn't get same instance for same currency code\");\n+        assertEquals(currency1.getCurrencyCode(), currencyCode, \"Currency code changed\");\n+    }\n+\n+    \/\/ Ensures the getDefaultFractionDigits() method returns the expected amount\n+    private static void compareFractionDigits(String currencyCode,\n+                                              int expectedFractionDigits) {\n+        int digits = Currency.getInstance(currencyCode).getDefaultFractionDigits();\n+        assertEquals(digits, expectedFractionDigits, generateErrMsg(\n+                \"number of fraction digits for currency\",\n+                currencyCode, Integer.toString(expectedFractionDigits), Integer.toString(digits)));\n+    }\n+\n+    \/\/ Used for logging on failing tests\n+    private static String generateErrMsg(String subject, String currency,\n+                                         String expected, String got) {\n+        return String.format(\"Wrong %s %s: expected '%s', got '%s'\",\n+                subject, currency, expected, got);\n","filename":"test\/jdk\/java\/util\/Currency\/CurrencyTest.java","additions":237,"deletions":212,"binary":false,"changes":449,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4512215 4818420 4819436 8310923\n+ * @summary Test some minor undefined currencies.\n+ * @run junit MinorUndefinedCodes\n+ *\/\n+\n+import java.util.Currency;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class MinorUndefinedCodes {\n+\n+    \/**\n+     * Spot check some minor undefined codes and ensure their default fraction\n+     * digits are not 2.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"minorUndefined\")\n+    public void checkFractionDigits(String currencyCode, int digits) {\n+        Currency currency = Currency.getInstance(currencyCode);\n+        assertEquals(currency.getCurrencyCode(), currencyCode);\n+        assertEquals(currency.getDefaultFractionDigits(), digits, String.format(\n+                \"[%s] expected: %s; got: %s\", currencyCode, digits, currency.getDefaultFractionDigits()));\n+    }\n+\n+    private static Stream<Arguments> minorUndefined() {\n+        return Stream.of(\n+                Arguments.of(\"XBD\", -1),\n+                Arguments.of(\"XAG\", -1),\n+                Arguments.of(\"XAU\", -1),\n+                Arguments.of(\"XBA\", -1),\n+                Arguments.of(\"XBB\", -1)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/Currency\/MinorUndefinedCodes.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -31,0 +32,1 @@\n+ * @run junit ValidateISO4217\n@@ -33,21 +35,34 @@\n-\/*\n- * ############################################################################\n- *\n- *  ValidateISO4217 is a tool to detect differences between the latest ISO 4217\n- *  data and Java's currency data which is based on ISO 4217.\n- *  If there is a difference, the following file which includes currency data\n- *  may need to be updated.\n- *      src\/share\/classes\/java\/util\/CurrencyData.properties\n- *\n- * ############################################################################\n- *\n- * 1) Make a golden-data file.\n- *      From BSi's ISO4217 data (TABLE A1.doc), extract four (or eight, if currency is changing)\n- *      fields and save as .\/tablea1.txt.\n- *        <Country code>\\t<Currency code>\\t<Numeric code>\\t<Minor unit>[\\t<Cutover Date>\\t<new Currency code>\\t<new Numeric code>\\t<new Minor unit>]\n- *      The Cutover Date is given in SimpleDateFormat's 'yyyy-MM-dd-HH-mm-ss' format in the GMT time zone.\n- *\n- * 2) Compile ValidateISO4217.java\n- *\n- * 3) Execute ValidateISO4217 as follows:\n- *      java ValidateISO4217\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Currency;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Set;\n+import java.util.StringTokenizer;\n+import java.util.TimeZone;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/**\n+ * This class tests the latest ISO 4217 data and Java's currency data which is\n+ * based on ISO 4217. The golden-data file (ISO 4217 data) 'tablea1.txt' has the following\n+ * format: <Country code>\\t<Currency code>\\t<Numeric code>\\t<Minor unit>[\\t<Cutover Date>\\t<new Currency code>\\t<new Numeric code>\\t<new Minor unit>]\n+ * The Cutover Date is given in SimpleDateFormat's 'yyyy-MM-dd-HH-mm-ss' format in the GMT time zone.\n@@ -55,5 +70,0 @@\n-\n-import java.io.*;\n-import java.text.*;\n-import java.util.*;\n-\n@@ -62,59 +72,28 @@\n-    static final int ALPHA_NUM = 26;\n-\n-    static final byte UNDEFINED = 0;\n-    static final byte DEFINED = 1;\n-    static final byte SKIPPED = 2;\n-\n-    \/* input files *\/\n-    static final String datafile = \"tablea1.txt\";\n-\n-    \/* alpha2-code table *\/\n-    static byte[] codes = new byte[ALPHA_NUM * ALPHA_NUM];\n-\n-    static final String[][] additionalCodes = {\n-        \/* Defined in ISO 4217 list, but don't have code and minor unit info. *\/\n-        {\"AQ\", \"\", \"\", \"0\"},    \/\/ Antarctica\n-\n-        \/*\n-         * Defined in ISO 4217 list, but don't have code and minor unit info in\n-         * it. On the other hand, both code and minor unit are defined in\n-         * .properties file. I don't know why, though.\n-         *\/\n-        {\"GS\", \"GBP\", \"826\", \"2\"},      \/\/ South Georgia And The South Sandwich Islands\n-\n-        \/* Not defined in ISO 4217 list, but defined in .properties file. *\/\n-        {\"AX\", \"EUR\", \"978\", \"2\"},      \/\/ \\u00c5LAND ISLANDS\n-        {\"PS\", \"ILS\", \"376\", \"2\"},      \/\/ Palestinian Territory, Occupied\n-\n-        \/* Not defined in ISO 4217 list, but added in ISO 3166 country code list *\/\n-        {\"JE\", \"GBP\", \"826\", \"2\"},      \/\/ Jersey\n-        {\"GG\", \"GBP\", \"826\", \"2\"},      \/\/ Guernsey\n-        {\"IM\", \"GBP\", \"826\", \"2\"},      \/\/ Isle of Man\n-        {\"BL\", \"EUR\", \"978\", \"2\"},      \/\/ Saint Barthelemy\n-        {\"MF\", \"EUR\", \"978\", \"2\"},      \/\/ Saint Martin\n-\n-        \/* Defined neither in ISO 4217 nor ISO 3166 list *\/\n-        {\"XK\", \"EUR\", \"978\", \"2\"},      \/\/ Kosovo\n-    };\n-\n-    \/* Codes that are obsolete, do not have related country, extra currency *\/\n-    static final String otherCodes =\n-        \"ADP-AFA-ATS-AYM-AZM-BEF-BGL-BOV-BYB-BYR-CHE-CHW-CLF-COU-CUC-CYP-\"\n-        + \"DEM-EEK-ESP-FIM-FRF-GHC-GRD-GWP-IEP-ITL-LTL-LUF-LVL-MGF-MRO-MTL-MXV-MZM-NLG-\"\n-        + \"PTE-ROL-RUR-SDD-SIT-SLL-SKK-SRG-STD-TMM-TPE-TRL-VEF-UYI-USN-USS-VEB-VED-\"\n-        + \"XAG-XAU-XBA-XBB-XBC-XBD-XDR-XFO-XFU-XPD-XPT-XSU-XTS-XUA-XXX-\"\n-        + \"YUM-ZMK-ZWD-ZWN-ZWR\";\n-\n-    static boolean err = false;\n-\n-    static Set<Currency> testCurrencies = new HashSet<Currency>();\n-\n-    public static void main(String[] args) throws Exception {\n-        CheckDataVersion.check();\n-        test1();\n-        test2();\n-        getAvailableCurrenciesTest();\n-\n-        if (err) {\n-            throw new RuntimeException(\"Failed: Validation ISO 4217 data\");\n-        }\n+    \/\/ Input golden-data file\n+    private static final File dataFile = new File(System.getProperty(\n+            \"test.src\", \".\"), \"tablea1.txt\");\n+    \/\/ Code statuses\n+    private static final byte UNDEFINED = 0;\n+    private static final byte DEFINED = 1;\n+    private static final byte SKIPPED = 2;\n+    private static final byte TESTED = 4;\n+    private static final int ALPHA_NUM = 26;\n+    \/\/ An alpha2 code table which maps the status of a country\n+    private static final byte[] codes = new byte[ALPHA_NUM * ALPHA_NUM];\n+    \/\/ Codes derived from ISO4217 golden-data file\n+    private static final List<Arguments> ISO4217Codes = new ArrayList<Arguments>();\n+    \/\/ Additional codes not from the ISO4217 golden-data file\n+    private static final List<Arguments> additionalCodes = new ArrayList<Arguments>();\n+    \/\/ Currencies to test (derived from ISO4217Codes and additionalCodes)\n+    private static final Set<Currency> testCurrencies = new HashSet<>();\n+    private static SimpleDateFormat format = null;\n+\n+    \/\/ Sets up the following test data:\n+    \/\/ ISO4217Codes, additionalCodes, testCurrencies, codes\n+    @BeforeAll\n+    static void setUpTestingData() throws Exception {\n+        \/\/ These functions laterally setup 'testCurrencies' and 'codes'\n+        \/\/ at the same time\n+        setUpISO4217Codes();\n+        setUpAdditionalCodes();\n+        finishTestCurrencies();\n@@ -123,3 +102,3 @@\n-    static void test1() throws Exception {\n-\n-        try (FileReader fr = new FileReader(new File(System.getProperty(\"test.src\", \".\"), datafile));\n+    \/\/ Parse the ISO4217 file and populate ISO4217Codes and testCurrencies.\n+    private static void setUpISO4217Codes() throws Exception{\n+        try (FileReader fr = new FileReader(dataFile);\n@@ -129,2 +108,0 @@\n-            SimpleDateFormat format = null;\n-\n@@ -133,0 +110,1 @@\n+                    \/\/ Skip comments and empty lines\n@@ -135,1 +113,0 @@\n-\n@@ -139,0 +116,1 @@\n+                    \/\/ Skip invalid countries\n@@ -141,0 +119,5 @@\n+                \/\/ If the country is valid, process the additional columns\n+                processColumns(tokens, country);\n+            }\n+        }\n+    }\n@@ -142,9 +125,23 @@\n-                String currency;\n-                String numeric;\n-                String minorUnit;\n-                int tokensCount = tokens.countTokens();\n-                if (tokensCount < 3) {\n-                    currency = \"\";\n-                    numeric = \"0\";\n-                    minorUnit = \"0\";\n-                } else {\n+    private static void processColumns(StringTokenizer tokens, String country) throws ParseException {\n+        String currency;\n+        String numeric;\n+        String minorUnit;\n+        int tokensCount = tokens.countTokens();\n+        if (tokensCount < 3) {\n+            \/\/ Ill-defined columns\n+            currency = \"\";\n+            numeric = \"0\";\n+            minorUnit = \"0\";\n+        } else {\n+            \/\/ Fully defined columns\n+            currency = tokens.nextToken();\n+            numeric = tokens.nextToken();\n+            minorUnit = tokens.nextToken();\n+            testCurrencies.add(Currency.getInstance(currency));\n+            \/\/ Check for the cut-over if a currency is changing\n+            if (tokensCount > 3) {\n+                if (format == null) {\n+                    createDateFormat();\n+                }\n+                \/\/ If the cut-over already passed, test the changed data too\n+                if (format.parse(tokens.nextToken()).getTime() < System.currentTimeMillis()) {\n@@ -155,16 +152,0 @@\n-\n-                    \/\/ check for the cutover\n-                    if (tokensCount > 3) {\n-                        if (format == null) {\n-                            format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n-                            format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-                            format.setLenient(false);\n-                        }\n-                        if (format.parse(tokens.nextToken()).getTime() <\n-                            System.currentTimeMillis()) {\n-                            currency = tokens.nextToken();\n-                            numeric = tokens.nextToken();\n-                            minorUnit = tokens.nextToken();\n-                            testCurrencies.add(Currency.getInstance(currency));\n-                        }\n-                    }\n@@ -172,3 +153,0 @@\n-                int index = toIndex(country);\n-                testCountryCurrency(country, currency, Integer.parseInt(numeric),\n-                    Integer.parseInt(minorUnit), index);\n@@ -177,0 +155,10 @@\n+        int index = toIndex(country);\n+        ISO4217Codes.add(Arguments.of(country, currency, Integer.parseInt(numeric),\n+                Integer.parseInt(minorUnit), index));\n+        codes[index] = DEFINED;\n+    }\n+\n+    \/\/ Generates a unique index for an alpha-2 country\n+    private static int toIndex(String country) {\n+        return ((country.charAt(0) - 'A') * ALPHA_NUM + country.charAt(1) - 'A');\n+    }\n@@ -178,7 +166,36 @@\n-        for (int i = 0; i < additionalCodes.length; i++) {\n-            int index = toIndex(additionalCodes[i][0]);\n-            if (additionalCodes[i][1].length() != 0) {\n-                testCountryCurrency(additionalCodes[i][0], additionalCodes[i][1],\n-                    Integer.parseInt(additionalCodes[i][2]),\n-                    Integer.parseInt(additionalCodes[i][3]), index);\n-                testCurrencies.add(Currency.getInstance(additionalCodes[i][1]));\n+    private static void createDateFormat() {\n+        format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n+        format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+        format.setLenient(false);\n+    }\n+\n+    \/\/ Process 'extraCodes', turning them into JUnit arguments and populate\n+    \/\/ both additionalCodes and testCurrencies.\n+    private static void setUpAdditionalCodes() {\n+        String[][] extraCodes = {\n+                \/* Defined in ISO 4217 list, but don't have code and minor unit info. *\/\n+                {\"AQ\", \"\", \"\", \"0\"},    \/\/ Antarctica\n+                \/*\n+                 * Defined in ISO 4217 list, but don't have code and minor unit info in\n+                 * it. On the other hand, both code and minor unit are defined in\n+                 * .properties file. I don't know why, though.\n+                 *\/\n+                {\"GS\", \"GBP\", \"826\", \"2\"},      \/\/ South Georgia And The South Sandwich Islands\n+                \/* Not defined in ISO 4217 list, but defined in .properties file. *\/\n+                {\"AX\", \"EUR\", \"978\", \"2\"},      \/\/ \\u00c5LAND ISLANDS\n+                {\"PS\", \"ILS\", \"376\", \"2\"},      \/\/ Palestinian Territory, Occupied\n+                \/* Not defined in ISO 4217 list, but added in ISO 3166 country code list *\/\n+                {\"JE\", \"GBP\", \"826\", \"2\"},      \/\/ Jersey\n+                {\"GG\", \"GBP\", \"826\", \"2\"},      \/\/ Guernsey\n+                {\"IM\", \"GBP\", \"826\", \"2\"},      \/\/ Isle of Man\n+                {\"BL\", \"EUR\", \"978\", \"2\"},      \/\/ Saint Barthelemy\n+                {\"MF\", \"EUR\", \"978\", \"2\"},      \/\/ Saint Martin\n+                \/* Defined neither in ISO 4217 nor ISO 3166 list *\/\n+                {\"XK\", \"EUR\", \"978\", \"2\"},      \/\/ Kosovo\n+        };\n+        for (String[] extraCode : extraCodes) {\n+            int index = toIndex(extraCode[0]);\n+            if (extraCode[1].length() != 0) {\n+                additionalCodes.add(Arguments.of(extraCode[0], extraCode[1],\n+                        Integer.parseInt(extraCode[2]), Integer.parseInt(extraCode[3]), index));\n+                testCurrencies.add(Currency.getInstance(extraCode[1]));\n@@ -186,1 +203,1 @@\n-                codes[index] = SKIPPED;\n+                codes[index] = SKIPPED; \/\/ For example, Antarctica\n@@ -191,2 +208,15 @@\n-    static int toIndex(String s) {\n-        return ((s.charAt(0) - 'A') * ALPHA_NUM + s.charAt(1) - 'A');\n+    \/\/ The previous set-up method populated most of testCurrencies. This\n+    \/\/ method finishes populating the list with 'otherCodes'.\n+    private static void finishTestCurrencies() {\n+        \/\/ Codes that are obsolete, do not have related country, extra currency\n+        final String otherCodes =\n+                \"ADP-AFA-ATS-AYM-AZM-BEF-BGL-BOV-BYB-BYR-CHE-CHW-CLF-COU-CUC-CYP-\"\n+                        + \"DEM-EEK-ESP-FIM-FRF-GHC-GRD-GWP-IEP-ITL-LTL-LUF-LVL-MGF-MRO-MTL-MXV-MZM-NLG-\"\n+                        + \"PTE-ROL-RUR-SDD-SIT-SLL-SKK-SRG-STD-TMM-TPE-TRL-VEF-UYI-USN-USS-VEB-VED-\"\n+                        + \"XAG-XAU-XBA-XBB-XBC-XBD-XDR-XFO-XFU-XPD-XPT-XSU-XTS-XUA-XXX-\"\n+                        + \"YUM-ZMK-ZWD-ZWN-ZWR\";\n+        \/\/ Add otherCodes\n+        StringTokenizer st = new StringTokenizer(otherCodes, \"-\");\n+        while (st.hasMoreTokens()) {\n+            testCurrencies.add(Currency.getInstance(st.nextToken()));\n+        }\n@@ -195,6 +225,14 @@\n-    static void testCountryCurrency(String country, String currencyCode,\n-                                int numericCode, int digits, int index) {\n-        if (currencyCode.length() == 0) {\n-            return;\n-        }\n-        testCurrencyDefined(currencyCode, numericCode, digits);\n+    \/**\n+     * Tests the JDK's ISO4217 data and ensures the values for getNumericCode(),\n+     * getDefaultFractionDigits(), and getCurrencyCode() are as expected.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource({\"ISO4217CodesProvider\", \"additionalCodesProvider\"})\n+    public void countryCurrencyTest(String country, String currencyCode,\n+                                    int numericCode, int digits, int index) {\n+        currencyTest(currencyCode, numericCode, digits);\n+        countryTest(country, currencyCode);\n+        assertNotEquals(codes[index], TESTED,\n+                \"Error: Re-testing a previously defined code, possible duplication\");\n+        codes[index] = TESTED;\n+    }\n@@ -202,9 +240,6 @@\n-        Locale loc = Locale.of(\"\", country);\n-        try {\n-            Currency currency = Currency.getInstance(loc);\n-            if (!currency.getCurrencyCode().equals(currencyCode)) {\n-                System.err.println(\"Error: [\" + country + \":\" +\n-                    loc.getDisplayCountry() + \"] expected: \" + currencyCode +\n-                    \", got: \" + currency.getCurrencyCode());\n-                err = true;\n-            }\n+    \/\/ Test a Currency built from currencyCode\n+    private static void currencyTest(String currencyCode, int numericCode, int digits) {\n+        Currency currency = Currency.getInstance(currencyCode);\n+        assertEquals(currency.getNumericCode(), numericCode);\n+        assertEquals(currency.getDefaultFractionDigits(), digits);\n+    }\n@@ -212,11 +247,5 @@\n-            if (codes[index] != UNDEFINED) {\n-                System.out.println(\"Warning: [\" + country + \":\" +\n-                    loc.getDisplayCountry() +\n-                    \"] multiple definitions. currency code=\" + currencyCode);\n-            }\n-            codes[index] = DEFINED;\n-        }\n-        catch (Exception e) {\n-            System.err.println(\"Error: \" + e + \": Country=\" + country);\n-            err = true;\n-        }\n+    \/\/ Test a Currency built from country\n+    private static void countryTest(String country, String currencyCode) {\n+        Locale loc = Locale.of(\"\", country);\n+        Currency currency = Currency.getInstance(loc);\n+        assertEquals(currency.getCurrencyCode(), currencyCode);\n@@ -225,3 +254,3 @@\n-    static void testCurrencyDefined(String currencyCode, int numericCode, int digits) {\n-        try {\n-            Currency currency = currency = Currency.getInstance(currencyCode);\n+    private static List<Arguments> ISO4217CodesProvider() {\n+        return ISO4217Codes;\n+    }\n@@ -229,5 +258,3 @@\n-            if (currency.getNumericCode() != numericCode) {\n-                System.err.println(\"Error: [\" + currencyCode + \"] expected: \" +\n-                    numericCode + \"; got: \" + currency.getNumericCode());\n-                err = true;\n-            }\n+    private static List<Arguments> additionalCodesProvider() {\n+        return additionalCodes;\n+    }\n@@ -235,10 +262,19 @@\n-            if (currency.getDefaultFractionDigits() != digits) {\n-                System.err.println(\"Error: [\" + currencyCode + \"] expected: \" +\n-                    digits + \"; got: \" + currency.getDefaultFractionDigits());\n-                err = true;\n-            }\n-        }\n-        catch (Exception e) {\n-            System.err.println(\"Error: \" + e + \": Currency code=\" +\n-                currencyCode);\n-            err = true;\n+    \/**\n+     * Tests trying to create a Currency from an invalid alpha-2 country either\n+     * throws an IllegalArgumentException or returns null. The test data\n+     * supplied is every possible combination of AA -> ZZ.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"codeCombos\")\n+    public void twoLetterCodesTest(String country) {\n+        if (codes[toIndex(country)] == UNDEFINED) {\n+            \/\/ if a code is undefined \/ 0, creating a Currency from it\n+            \/\/ should throw an IllegalArgumentException\n+            assertThrows(IllegalArgumentException.class,\n+                    ()-> Currency.getInstance(Locale.of(\"\", country)),\n+                    \"Error: This should be an undefined code and throw IllegalArgumentException: \" + country);\n+        } else if (codes[toIndex(country)] == SKIPPED) {\n+            \/\/ if a code is marked as skipped \/ 2, creating a Currency from it\n+            \/\/ should return null\n+            assertNull(Currency.getInstance(Locale.of(\"\", country)),\n+                    \"Error: Currency.getInstance() for this locale should return null: \" + country);\n@@ -248,1 +284,3 @@\n-    static void test2() {\n+    \/\/ This method generates code combos from AA to ZZ\n+    private static List<String> codeCombos() {\n+        List<String> codeCombos = new ArrayList<>();\n@@ -252,34 +290,3 @@\n-                code[0] = (char)('A'+ i);\n-                code[1] = (char)('A'+ j);\n-                String country = new String(code);\n-                boolean ex;\n-\n-                if (codes[toIndex(country)] == UNDEFINED) {\n-                    ex = false;\n-                    try {\n-                        Currency.getInstance(Locale.of(\"\", country));\n-                    }\n-                    catch (IllegalArgumentException e) {\n-                        ex = true;\n-                    }\n-                    if (!ex) {\n-                        System.err.println(\"Error: This should be an undefined code and throw IllegalArgumentException: \" +\n-                            country);\n-                        err = true;\n-                    }\n-                } else if (codes[toIndex(country)] == SKIPPED) {\n-                    Currency cur = null;\n-                    try {\n-                        cur = Currency.getInstance(Locale.of(\"\", country));\n-                    }\n-                    catch (Exception e) {\n-                        System.err.println(\"Error: \" + e + \": Country=\" +\n-                            country);\n-                        err = true;\n-                    }\n-                    if (cur != null) {\n-                        System.err.println(\"Error: Currency.getInstance() for an this locale should return null: \" +\n-                            country);\n-                        err = true;\n-                    }\n-                }\n+                code[0] = (char) ('A' + i);\n+                code[1] = (char) ('A' + j);\n+                codeCombos.add(new String(code));\n@@ -288,0 +295,1 @@\n+        return codeCombos;\n@@ -290,4 +298,4 @@\n-    \/**\n-     * This test depends on test1(), where 'testCurrencies' set is constructed\n-     *\/\n-    static void getAvailableCurrenciesTest() {\n+    \/\/ This method ensures that getAvailableCurrencies() returns\n+    \/\/ the expected amount of currencies.\n+    @Test\n+    public void getAvailableCurrenciesTest() {\n@@ -295,0 +303,4 @@\n+        \/\/ Ensure that testCurrencies has all the JRE currency codes\n+        assertTrue(testCurrencies.containsAll(jreCurrencies),\n+                getSetDiffs(jreCurrencies, testCurrencies));\n+    }\n@@ -296,14 +308,6 @@\n-        \/\/ add otherCodes\n-        StringTokenizer st = new StringTokenizer(otherCodes, \"-\");\n-        while (st.hasMoreTokens()) {\n-            testCurrencies.add(Currency.getInstance(st.nextToken()));\n-        }\n-\n-        if (!testCurrencies.containsAll(jreCurrencies)) {\n-            System.err.print(\"Error: getAvailableCurrencies() returned extra currencies than expected: \");\n-            jreCurrencies.removeAll(testCurrencies);\n-            for (Currency c : jreCurrencies) {\n-                System.err.print(\" \"+c);\n-            }\n-            System.err.println();\n-            err = true;\n+    private static String getSetDiffs(Set<Currency> jreCurrencies, Set<Currency> testCurrencies) {\n+        StringBuilder bldr = new StringBuilder();\n+        bldr.append(\"Error: getAvailableCurrencies() returned unexpected currencies: \");\n+        jreCurrencies.removeAll(testCurrencies);\n+        for (Currency curr : jreCurrencies) {\n+            bldr.append(\" \" + curr);\n@@ -311,0 +315,2 @@\n+        bldr.append(\"\\n\");\n+        return bldr.toString();\n","filename":"test\/jdk\/java\/util\/Currency\/ValidateISO4217.java","additions":233,"deletions":227,"binary":false,"changes":460,"status":"modified"}]}