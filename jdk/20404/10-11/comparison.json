{"files":[{"patch":"@@ -789,0 +789,3 @@\n+  void set_offset(unsigned int offset) {\n+    _offset = offset;\n+  }\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -798,0 +798,321 @@\n+const uint max_reg_capacity = 2048;\n+const uint iterations = 50000;\n+\n+static uint r;\n+static uint next_random() {\n+  r = os::next_random(r);\n+  return r;\n+}\n+\n+static void print(const char* name, const RegMask& mask) {\n+  tty->print(\"%s: \", name);\n+  mask.print();\n+  tty->print_cr(\", size: %u, offset: %u, all_stack: %u\", mask.rm_size_bits(),\n+                mask.offset_bits(), mask.is_AllStack());\n+}\n+\n+static void assert_equivalent(const RegMask& mask,\n+                              const ResourceBitMap& mask_ref,\n+                              bool all_stack_ref) {\n+  ASSERT_EQ(mask_ref.count_one_bits(), mask.Size());\n+  RegMaskIterator it(mask);\n+  OptoReg::Name reg = OptoReg::Bad;\n+  while (it.has_next()) {\n+    reg = it.next();\n+    ASSERT_TRUE(OptoReg::is_valid(reg));\n+    ASSERT_TRUE(mask_ref.at(reg));\n+  }\n+  ASSERT_EQ(all_stack_ref, mask.is_AllStack());\n+}\n+\n+static void populate_auxiliary_sets(RegMask& mask_aux,\n+                                    ResourceBitMap& mask_aux_ref,\n+                                    uint reg_capacity, uint offset,\n+                                    bool random_offset) {\n+  mask_aux.Clear();\n+  mask_aux_ref.clear();\n+  if (random_offset) {\n+    uint offset_in_words = offset \/ BitsPerWord;\n+    uint capacity_in_words = reg_capacity \/ BitsPerWord;\n+    uint new_offset_in_words;\n+    uint offset_target = next_random() % 3;\n+    switch (offset_target) {\n+    case 0: \/\/ before\n+      if (offset_in_words == 0) {\n+        new_offset_in_words = 0;\n+      } else {\n+        new_offset_in_words = next_random() % offset_in_words;\n+      }\n+      break;\n+    case 1: \/\/ within\n+      new_offset_in_words =\n+          (next_random() % capacity_in_words) + offset_in_words;\n+      break;\n+    case 2: \/\/ after\n+      new_offset_in_words = offset_in_words + capacity_in_words +\n+                            (next_random() % (capacity_in_words));\n+      break;\n+    default:\n+      FAIL();\n+    }\n+    offset = new_offset_in_words * BitsPerWord;\n+    if (offset + max_reg_capacity > mask_aux_ref.size()) {\n+      \/\/ Ensure that there is space in the reference mask.\n+      offset = 0;\n+    }\n+  }\n+  mask_aux.set_offset(offset \/ BitsPerWord);\n+  assert_equivalent(mask_aux, mask_aux_ref, false);\n+  uint max_size;\n+  uint size_target = next_random() % 3;\n+  switch (size_target) {\n+  case 0: \/\/ smaller\n+    max_size = reg_capacity \/ 2;\n+    break;\n+  case 1: \/\/ equal\n+    max_size = reg_capacity;\n+    break;\n+  case 2: \/\/ larger (if possible)\n+    max_size = max_reg_capacity;\n+    break;\n+  default:\n+    FAIL();\n+  }\n+  uint regs;\n+  uint regs_target = next_random() % 3;\n+  switch (regs_target) {\n+  case 0: \/\/ sparse\n+    regs = next_random() % 8;\n+    break;\n+  case 1: \/\/ medium\n+    regs = next_random() % (max_size \/ 8);\n+    break;\n+  case 2: \/\/ dense\n+    regs = next_random() % max_size;\n+    break;\n+  default:\n+    FAIL();\n+  }\n+  for (uint i = 0; i < regs; i++) {\n+    uint reg = (next_random() % max_size) + offset;\n+    mask_aux.Insert(reg);\n+    mask_aux_ref.set_bit(reg);\n+  }\n+  mask_aux.set_AllStack(next_random() % 2);\n+  assert_equivalent(mask_aux, mask_aux_ref, mask_aux.is_AllStack());\n+\n+  if (Verbose) {\n+    print(\"mask_aux\", mask_aux);\n+  }\n+}\n+\n+static void stack_extend_ref_masks(ResourceBitMap& mask1, bool all_stack1,\n+                                   uint size_bits1, uint offset1,\n+                                   ResourceBitMap& mask2, bool all_stack2,\n+                                   uint size_bits2, uint offset2) {\n+  uint size_bits_after = MAX2(size_bits1, size_bits2);\n+  if (all_stack1) {\n+    mask1.set_range(size_bits1 + offset1, size_bits_after + offset1);\n+  }\n+  if (all_stack2) {\n+    mask2.set_range(size_bits2 + offset2, size_bits_after + offset2);\n+  }\n+}\n+\n+TEST_VM(RegMask, random) {\n+  ResourceMark rm;\n+  RegMask mask(arena());\n+  ResourceBitMap mask_ref(std::numeric_limits<short>::max() + 1);\n+  bool all_stack_ref = false;\n+  uint offset_ref = 0;\n+  if (StressSeed == 0) {\n+    r = static_cast<uint>(Ticks::now().nanoseconds());\n+    tty->print_cr(\"seed: %u\", r);\n+  } else {\n+    r = StressSeed;\n+  }\n+\n+  for (uint i = 0; i < iterations; i++) {\n+    if (Verbose) {\n+      print(\"mask    \", mask);\n+      tty->print(\"%u. \", i);\n+    }\n+    uint action = next_random() % 13;\n+    uint reg;\n+    uint size_bits_before = mask.rm_size_bits();\n+    \/\/ This copy is used for stack-extension in overlap.\n+    ResourceBitMap mask_ref_copy(std::numeric_limits<short>::max() + 1);\n+    mask_ref_copy.clear();\n+    mask_ref.iterate([&](BitMap::idx_t index) {\n+      mask_ref_copy.set_bit(index);\n+      return true;\n+    });\n+    ResourceBitMap mask_aux_ref(std::numeric_limits<short>::max() + 1);\n+    RegMask mask_aux(arena());\n+    switch (action) {\n+    case 0:\n+      reg = (next_random() % max_reg_capacity) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Insert\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Insert(reg);\n+      mask_ref.set_bit(reg);\n+      if (mask.is_AllStack() && reg >= size_bits_before) {\n+        \/\/ Stack-extend reference bitset.\n+        mask_ref.set_range(size_bits_before + offset_ref,\n+                           mask.rm_size_bits() + offset_ref);\n+      }\n+      break;\n+    case 1:\n+      reg = (next_random() % size_bits_before) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Remove\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Remove(reg);\n+      mask_ref.clear_bit(reg);\n+      break;\n+    case 2:\n+      if (Verbose) {\n+        tty->print_cr(\"action: Clear\");\n+      }\n+      mask.Clear();\n+      mask_ref.clear();\n+      all_stack_ref = false;\n+      break;\n+    case 3:\n+      if (offset_ref > 0) {\n+        \/\/ Set_All expects a zero-offset.\n+        break;\n+      }\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All\");\n+      }\n+      mask.Set_All();\n+      mask_ref.set_range(0, size_bits_before);\n+      all_stack_ref = true;\n+      break;\n+    case 4:\n+      if (Verbose) {\n+        tty->print_cr(\"action: AND\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.AND(mask_aux);\n+      stack_extend_ref_masks(mask_ref, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      mask_ref.set_intersection(mask_aux_ref);\n+      all_stack_ref = all_stack_ref && mask_aux.is_AllStack();\n+      break;\n+    case 5:\n+      if (Verbose) {\n+        tty->print_cr(\"action: OR\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.OR(mask_aux);\n+      stack_extend_ref_masks(mask_ref, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      mask_ref.set_union(mask_aux_ref);\n+      all_stack_ref = all_stack_ref || mask_aux.is_AllStack();\n+      break;\n+    case 6:\n+      if (Verbose) {\n+        tty->print_cr(\"action: SUBTRACT\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.SUBTRACT(mask_aux);\n+      stack_extend_ref_masks(mask_ref, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      mask_ref.set_difference(mask_aux_ref);\n+      if (mask_aux.is_AllStack()) {\n+        all_stack_ref = false;\n+      }\n+      break;\n+    case 7:\n+      if (Verbose) {\n+        tty->print_cr(\"action: SUBTRACT_inner\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ true);\n+      \/\/ SUBTRACT_inner expects an argument register mask with all_stack =\n+      \/\/ false.\n+      mask_aux.set_AllStack(false);\n+      mask.SUBTRACT_inner(mask_aux);\n+      \/\/ SUBTRACT_inner does not have \"stack-extension semantics\".\n+      mask_ref.set_difference(mask_aux_ref);\n+      break;\n+    case 8:\n+      if (Verbose) {\n+        tty->print_cr(\"action: overlap\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      \/\/ Stack-extend a copy of mask_ref to avoid mutating the original.\n+      stack_extend_ref_masks(mask_ref_copy, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      ASSERT_EQ(mask_ref_copy.intersects(mask_aux_ref) ||\n+                    (all_stack_ref && mask_aux.is_AllStack()),\n+                mask.overlap(mask_aux));\n+      break;\n+    case 9:\n+      if (Verbose) {\n+        tty->print_cr(\"action: rollover\");\n+      }\n+      \/\/ rollover expects the mask to be cleared and with all_stack = true\n+      mask.Clear();\n+      mask.set_AllStack(true);\n+      mask_ref.clear();\n+      all_stack_ref = true;\n+      if (mask.rollover()) {\n+        offset_ref += size_bits_before;\n+        mask_ref.set_range(offset_ref, offset_ref + size_bits_before);\n+      }\n+      break;\n+    case 10:\n+      if (Verbose) {\n+        tty->print_cr(\"action: reset\");\n+      }\n+      mask.set_offset(0);\n+      mask.Clear();\n+      mask_ref.clear();\n+      all_stack_ref = false;\n+      offset_ref = 0;\n+      break;\n+    case 11:\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All_From_Offset\");\n+      }\n+      mask.Set_All_From_Offset();\n+      mask_ref.set_range(offset_ref, offset_ref + size_bits_before);\n+      all_stack_ref = true;\n+      break;\n+    case 12:\n+      reg = (next_random() % size_bits_before) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All_From\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Set_All_From(reg);\n+      mask_ref.set_range(reg, offset_ref + size_bits_before);\n+      all_stack_ref = true;\n+      break;\n+    default:\n+      FAIL() << \"Unimplemented action\";\n+    }\n+    ASSERT_NO_FATAL_FAILURE(assert_equivalent(mask, mask_ref, all_stack_ref));\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":321,"deletions":0,"binary":false,"changes":321,"status":"modified"}]}