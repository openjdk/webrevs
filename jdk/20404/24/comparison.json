{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,0 +165,5 @@\n+\/\/ Compute the least number of words required for registers in register masks.\n+int RegisterForm::words_for_regs() {\n+  return (_reg_ctr + 31) >> 5;\n+}\n+\n@@ -167,6 +172,3 @@\n-  \/\/ Need at least this many words\n-  int words_for_regs = (_reg_ctr + 31)>>5;\n-  \/\/ The array of Register Mask bits should be large enough to cover\n-  \/\/ all the machine registers and all parameters that need to be passed\n-  \/\/ on the stack (stack registers) up to some interesting limit.  Methods\n-  \/\/ that need more parameters will NOT be compiled.  On Intel, the limit\n+  \/\/ The array of Register Mask bits should be large enough to cover all the\n+  \/\/ machine registers and usually all parameters that need to be passed on the\n+  \/\/ stack (stack registers) up to some interesting limit. On Intel, the limit\n@@ -180,1 +182,1 @@\n-  return (words_for_regs + 3 + 1 + 1) & ~1;\n+  return (words_for_regs() + 3 + 1 + 1) & ~1;\n@@ -372,1 +374,1 @@\n-  fprintf(fp,\" 0x%x );\\n\", regs_in_word(i, false));\n+  fprintf(fp, \" 0x%x, false );\\n\", regs_in_word(i, false));\n@@ -379,1 +381,1 @@\n-    fprintf(fp,\" 0x%x );\\n\", regs_in_word(i, true));\n+    fprintf(fp, \" 0x%x, true );\\n\", regs_in_word(i, true));\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,2 @@\n+  static int  words_for_regs(); \/\/ Compute the least number of words required for\n+                                \/\/ registers in register masks.\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  fprintf(fp_hpp, \"\/\/ Minimum size of register-mask in ints\\n\");\n+  fprintf(fp_hpp, \"#define RM_SIZE_MIN %d\\n\", RegisterForm::words_for_regs());\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1223,1 +1223,1 @@\n-    if (new_live.is_NotEmpty()) {\n+    if (!new_live.is_Empty()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  FN(regmask,     C2 Short-Lived Register Mask Arena) \\\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -563,0 +563,3 @@\n+  if (C->failing()) {\n+    return;\n+  }\n@@ -640,0 +643,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -770,1 +776,1 @@\n-      _lrg_map.map(n->_idx, rm.is_NotEmpty() ? lr_counter++ : 0);\n+      _lrg_map.map(n->_idx, !rm.is_Empty() ? lr_counter++ : 0);\n@@ -791,1 +797,1 @@\n-      _lrg_map.map(n->_idx, rm.is_NotEmpty() ? n->_idx : 0);\n+      _lrg_map.map(n->_idx, !rm.is_Empty() ? n->_idx : 0);\n@@ -1401,3 +1407,2 @@\n-static bool is_legal_reg(LRG &lrg, OptoReg::Name reg, int chunk) {\n-  if (reg >= chunk && reg < (chunk + RegMask::CHUNK_SIZE) &&\n-      lrg.mask().Member(OptoReg::add(reg,-chunk))) {\n+static bool is_legal_reg(LRG& lrg, OptoReg::Name reg) {\n+  if (lrg.mask().can_represent(reg) && lrg.mask().Member(reg)) {\n@@ -1426,1 +1431,1 @@\n-static OptoReg::Name find_first_set(LRG &lrg, RegMask mask, int chunk) {\n+static OptoReg::Name find_first_set(LRG& lrg, RegMask& mask) {\n@@ -1432,1 +1437,3 @@\n-    if (chunk == 0 && OptoReg::is_reg(assigned)) {\n+    if (OptoReg::is_reg(assigned)) {\n+      assert(!lrg.mask().is_offset(),\n+             \"offset register masks can only contain stack slots\");\n@@ -1448,1 +1455,2 @@\n-      while (OptoReg::is_valid(assigned) && RegMask::can_represent(assigned)) {\n+      while (OptoReg::is_valid(assigned)) {\n+        assert(mask.can_represent(assigned), \"sanity\");\n@@ -1472,1 +1480,1 @@\n-OptoReg::Name PhaseChaitin::bias_color( LRG &lrg, int chunk ) {\n+OptoReg::Name PhaseChaitin::bias_color(LRG& lrg) {\n@@ -1486,1 +1494,1 @@\n-      if (is_legal_reg(lrg, reg, chunk))\n+      if (is_legal_reg(lrg, reg)) {\n@@ -1488,0 +1496,1 @@\n+      }\n@@ -1497,1 +1506,1 @@\n-      if (is_legal_reg(lrg, reg, chunk))\n+      if (is_legal_reg(lrg, reg)) {\n@@ -1499,1 +1508,2 @@\n-    } else if( chunk == 0 ) {\n+      }\n+    } else if (!lrg.mask().is_offset()) {\n@@ -1501,1 +1511,2 @@\n-      RegMask tempmask = lrg.mask();\n+      ResourceMark rm(C->regmask_arena());\n+      RegMask tempmask(lrg.mask(), C->regmask_arena());\n@@ -1504,1 +1515,1 @@\n-      OptoReg::Name reg = find_first_set(lrg, tempmask, chunk);\n+      OptoReg::Name reg = find_first_set(lrg, tempmask);\n@@ -1513,1 +1524,3 @@\n-    return OptoReg::add(find_first_set(lrg, lrg.mask(), chunk), chunk);\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask tempmask(lrg.mask(), C->regmask_arena());\n+    return find_first_set(lrg, tempmask);\n@@ -1526,1 +1539,1 @@\n-    if( OptoReg::is_reg(reg2))\n+    if (OptoReg::is_reg(reg2)) {\n@@ -1528,0 +1541,1 @@\n+    }\n@@ -1529,1 +1543,1 @@\n-  return OptoReg::add( reg, chunk );\n+  return reg;\n@@ -1533,3 +1547,3 @@\n-OptoReg::Name PhaseChaitin::choose_color( LRG &lrg, int chunk ) {\n-  assert( C->in_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP-1)), \"must not allocate stack0 (inside preserve area)\");\n-  assert(C->out_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP+0)), \"must not allocate stack0 (inside preserve area)\");\n+OptoReg::Name PhaseChaitin::choose_color(LRG& lrg) {\n+  assert(C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP - 1)), \"must not allocate stack0 (inside preserve area)\");\n+  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP + 0)), \"must not allocate stack0 (inside preserve area)\");\n@@ -1540,1 +1554,1 @@\n-    return bias_color(lrg, chunk);\n+    return bias_color(lrg);\n@@ -1548,1 +1562,1 @@\n-  assert( !chunk, \"always color in 1st chunk\" );\n+  assert(!lrg.mask().is_offset(), \"always color in 1st chunk\");\n@@ -1588,1 +1602,0 @@\n-    int chunk = 0;              \/\/ Current chunk is first chunk\n@@ -1593,1 +1606,4 @@\n-    DEBUG_ONLY(RegMask orig_mask = lrg->mask();)\n+#ifndef PRODUCT\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask orig_mask(lrg->mask(), C->regmask_arena());\n+#endif\n@@ -1599,6 +1615,0 @@\n-        \/\/ Note that neighbor might be a spill_reg.  In this case, exclusion\n-        \/\/ of its color will be a no-op, since the spill_reg chunk is in outer\n-        \/\/ space.  Also, if neighbor is in a different chunk, this exclusion\n-        \/\/ will be a no-op.  (Later on, if lrg runs out of possible colors in\n-        \/\/ its chunk, a new chunk of color may be tried, in which case\n-        \/\/ examination of neighbors is started again, at retry_next_chunk.)\n@@ -1607,2 +1617,7 @@\n-        \/\/ Only subtract masks in the same chunk\n-        if (nreg >= chunk && nreg < chunk + RegMask::CHUNK_SIZE) {\n+        \/\/ The neighbor might be a spill_reg. In this case, exclusion of its\n+        \/\/ color will be a no-op, since the spill_reg is in outer space. In\n+        \/\/ this case, do not exclude the corresponding mask. Later on, if lrg\n+        \/\/ runs out of possible colors in its chunk, a new chunk of color may\n+        \/\/ be tried, in which case examination of neighbors is started again,\n+        \/\/ at retry_next_chunk.\n+        if (nreg < LRG::SPILL_REG) {\n@@ -1611,1 +1626,2 @@\n-          RegMask rm = lrg->mask();\n+          ResourceMark rm(C->regmask_arena());\n+          RegMask trace_mask(lrg->mask(), C->regmask_arena());\n@@ -1613,1 +1629,1 @@\n-          lrg->SUBTRACT(nlrg.mask());\n+          lrg->SUBTRACT_inner(nlrg.mask());\n@@ -1618,1 +1634,1 @@\n-            rm.dump();\n+            trace_mask.dump();\n@@ -1622,2 +1638,2 @@\n-            rm.SUBTRACT(lrg->mask());\n-            rm.dump();\n+            trace_mask.SUBTRACT(lrg->mask());\n+            trace_mask.dump();\n@@ -1640,1 +1656,1 @@\n-    OptoReg::Name reg = choose_color( *lrg, chunk );\n+    OptoReg::Name reg = choose_color(*lrg);\n@@ -1645,1 +1661,1 @@\n-    if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) && is_allstack) {\n+    if (!OptoReg::is_valid(reg) && is_allstack) {\n@@ -1647,2 +1663,10 @@\n-      chunk += RegMask::CHUNK_SIZE;\n-      lrg->Set_All();\n+      bool success = lrg->rollover();\n+      if (!success) {\n+        \/\/ We should never get here in practice. Bail out in product,\n+        \/\/ assert in debug.\n+        assert(false, \"the next available stack slots should be within the \"\n+                      \"OptoRegPair range\");\n+        C->record_method_not_compilable(\n+            \"chunk-rollover outside of OptoRegPair range\");\n+        return -1;\n+      }\n@@ -1654,1 +1678,1 @@\n-    else if( OptoReg::is_valid(reg)) {\n+    else if (OptoReg::is_valid(reg)) {\n@@ -1656,1 +1680,2 @@\n-      RegMask avail_rm = lrg->mask();\n+      ResourceMark rm(C->regmask_arena());\n+      RegMask avail_rm(lrg->mask(), C->regmask_arena());\n@@ -1662,4 +1687,3 @@\n-      if( reg >= _max_reg )     \/\/ Compute max register limit\n-        _max_reg = OptoReg::add(reg,1);\n-      \/\/ Fold reg back into normal space\n-      reg = OptoReg::add(reg,-chunk);\n+      if (reg >= _max_reg) { \/\/ Compute max register limit\n+        _max_reg = OptoReg::add(reg, 1);\n+      }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":71,"deletions":47,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+  void init_mask(Arena* arena) {\n+    new (&_mask) RegMask(arena);\n+  }\n@@ -134,0 +137,4 @@\n+  void SUBTRACT_inner(const RegMask& rm) {\n+    _mask.SUBTRACT_inner(rm);\n+    DEBUG_ONLY(_msize_valid = 0;)\n+  }\n@@ -135,1 +142,10 @@\n-  void Set_All() { _mask.Set_All(); DEBUG_ONLY(_msize_valid=1); _mask_size = RegMask::CHUNK_SIZE; }\n+  void Set_All() {\n+    _mask.Set_All();\n+    DEBUG_ONLY(_msize_valid = 1);\n+    _mask_size = _mask.rm_size_bits();\n+  }\n+  bool rollover() {\n+    DEBUG_ONLY(_msize_valid = 1);\n+    _mask_size = _mask.rm_size_bits();\n+    return _mask.rollover();\n+  }\n@@ -700,1 +716,1 @@\n-  OptoReg::Name choose_color( LRG &lrg, int chunk );\n+  OptoReg::Name choose_color(LRG& lrg);\n@@ -702,1 +718,1 @@\n-  OptoReg::Name bias_color( LRG &lrg, int chunk );\n+  OptoReg::Name bias_color(LRG& lrg);\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -696,2 +696,3 @@\n-  RegMask rm = lrgs(lr1).mask();\n-  rm.AND(lrgs(lr2).mask());\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask mask(lrgs(lr1).mask(), C->regmask_arena());\n+  mask.AND(lrgs(lr2).mask());\n@@ -699,1 +700,1 @@\n-  uint rm_size = rm.Size();\n+  uint rm_size = mask.Size();\n@@ -701,1 +702,1 @@\n-  if (UseFPUForSpilling && rm.is_AllStack() ) {\n+  if (UseFPUForSpilling && mask.is_AllStack() ) {\n@@ -710,1 +711,1 @@\n-  if( rm.is_AllStack() ) rm_size += 1000000;\n+  if( mask.is_AllStack() ) rm_size += 1000000;\n@@ -733,1 +734,1 @@\n-  uint reg_degree = _ulr.lrg_union( lr1, lr2, rm_size, _phc._ifg, rm );\n+  uint reg_degree = _ulr.lrg_union( lr1, lr2, rm_size, _phc._ifg, mask );\n@@ -746,1 +747,1 @@\n-    reg_degree = compute_separating_interferences(dst_copy, src_copy, b, bindex, rm, rm_size, reg_degree, lr1, lr2 );\n+    reg_degree = compute_separating_interferences(dst_copy, src_copy, b, bindex, mask, rm_size, reg_degree, lr1, lr2 );\n@@ -793,1 +794,1 @@\n-  lrgs(lr1).set_mask(rm);\n+  lrgs(lr1).set_mask(mask);\n","filename":"src\/hotspot\/share\/opto\/coalesce.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -696,0 +696,1 @@\n+      _FIRST_STACK_mask(comp_arena()),\n@@ -697,0 +698,1 @@\n+      _regmask_arena(mtCompiler, Arena::Tag::tag_regmask),\n@@ -957,0 +959,1 @@\n+      _FIRST_STACK_mask(comp_arena()),\n@@ -958,0 +961,1 @@\n+      _regmask_arena(mtCompiler, Arena::Tag::tag_regmask),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -529,0 +529,6 @@\n+  \/\/ Holds dynamically allocated extensions of short-lived register masks. Such\n+  \/\/ extensions are potentially quite large and need tight resource marks which\n+  \/\/ may conflict with other allocations in the default resource area.\n+  \/\/ Therefore, we use a dedicated resource area for register masks.\n+  ResourceArea          _regmask_arena;\n+\n@@ -1116,0 +1122,1 @@\n+  ResourceArea*     regmask_arena()             { return &_regmask_arena; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1452,1 +1452,1 @@\n-  if (mach && mach->out_RegMask().is_bound1() && mach->out_RegMask().is_NotEmpty())\n+  if (mach != nullptr && mach->out_RegMask().is_bound1() && !mach->out_RegMask().is_Empty())\n@@ -1485,1 +1485,1 @@\n-    if (mach && LCA == root_block)\n+    if (mach != nullptr && LCA == root_block)\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    _lrgs[i].init_mask(_arena);\n@@ -655,1 +656,2 @@\n-  RegMask mask_tmp = lrg.mask();\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask mask_tmp(lrg.mask(), C->regmask_arena());\n@@ -712,1 +714,4 @@\n-  const RegMask& rm = lrg.mask();\n+  const RegMask& mask = lrg.mask();\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask old(C->regmask_arena());\n+  RegMask r2mask(C->regmask_arena());\n@@ -727,1 +732,1 @@\n-    RegMask old = interfering_lrg.mask();\n+    old = interfering_lrg.mask();\n@@ -730,2 +735,2 @@\n-    \/\/ Remove the bits from LRG 'rm' from LRG 'l' so 'l' no\n-    \/\/ longer interferes with 'rm'.  If 'l' requires aligned\n+    \/\/ Remove the bits from LRG 'mask' from LRG 'l' so 'l' no\n+    \/\/ longer interferes with 'mask'.  If 'l' requires aligned\n@@ -736,1 +741,1 @@\n-      RegMask r2mask = rm;\n+      r2mask = mask;\n@@ -744,1 +749,1 @@\n-      interfering_lrg.SUBTRACT(rm);\n+      interfering_lrg.SUBTRACT(mask);\n@@ -748,1 +753,1 @@\n-      OptoReg::Name r_reg = rm.find_first_elem();\n+      OptoReg::Name r_reg = mask.find_first_elem();\n@@ -931,1 +936,1 @@\n-        if (lrg.is_bound() && !n->rematerialize() && lrg.mask().is_NotEmpty()) {\n+        if (lrg.is_bound() && !n->rematerialize() && !lrg.mask().is_Empty()) {\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -872,1 +872,2 @@\n-  RegMask regs;\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask regs(C->regmask_arena());\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"opto\/regmask.hpp\"\n@@ -41,7 +42,10 @@\n-BoxLockNode::BoxLockNode( int slot ) : Node( Compile::current()->root() ),\n-                                       _slot(slot), _kind(BoxLockNode::Regular) {\n-  init_class_id(Class_BoxLock);\n-  init_flags(Flag_rematerialize);\n-  OptoReg::Name reg = OptoReg::stack2reg(_slot);\n-  if (!RegMask::can_represent(reg, Compile::current()->sync_stack_slots())) {\n-    Compile::current()->record_method_not_compilable(\"must be able to represent all monitor slots in reg mask\");\n+BoxLockNode::BoxLockNode(int slot)\n+    : Node(Compile::current()->root()), _slot(slot),\n+      \/\/ In debug mode, signal that the register mask is constant.\n+      _inmask(OptoReg::stack2reg(_slot),\n+              Compile::current()->comp_arena()\n+              DEBUG_ONLY(COMMA \/*read_only*\/ true)),\n+      _kind(BoxLockNode::Regular) {\n+  if (_slot > BoxLockNode_SLOT_LIMIT) {\n+    Compile::current()->record_method_not_compilable(\n+        \"reached BoxLockNode slot limit\");\n@@ -50,1 +54,2 @@\n-  _inmask.Insert(reg);\n+  init_class_id(Class_BoxLock);\n+  init_flags(Flag_rematerialize);\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-  const int     _slot; \/\/ stack slot\n-  RegMask     _inmask; \/\/ OptoReg corresponding to stack slot\n+  const int _slot;       \/\/ stack slot\n+  const RegMask _inmask; \/\/ OptoReg corresponding to stack slot\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -528,1 +528,1 @@\n-    if (rm.is_NotEmpty() && rm.is_bound(ideal_reg())) {\n+    if (!rm.is_Empty() && rm.is_bound(ideal_reg())) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -757,1 +757,3 @@\n-  MachProjNode( Node *multi, uint con, const RegMask &out, uint ideal_reg ) : ProjNode(multi,con), _rout(out), _ideal_reg(ideal_reg) {\n+  MachProjNode(Node* multi, uint con, const RegMask& out, uint ideal_reg)\n+      : ProjNode(multi, con), _rout(out, Compile::current()->comp_arena()),\n+        _ideal_reg(ideal_reg) {\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,2 @@\n-  _register_save_type(register_save_type) {\n+  _register_save_type(register_save_type),\n+  _return_addr_mask(C->comp_arena()) {\n@@ -143,6 +144,0 @@\n-    if (!RegMask::can_represent_arg(warped)) {\n-      \/\/ the compiler cannot represent this method's calling sequence\n-      \/\/ Bailout. We do not have space to represent all arguments.\n-      C->record_method_not_compilable(\"unsupported incoming calling sequence\");\n-      return OptoReg::Bad;\n-    }\n@@ -201,1 +196,3 @@\n-  _return_addr_mask = return_addr();\n+  assert(_return_addr_mask.is_Empty(),\n+         \"return address mask must be empty initially\");\n+  _return_addr_mask.Insert(return_addr());\n@@ -238,0 +235,1 @@\n+    new (_calling_convention_mask + i) RegMask(C->comp_arena());\n@@ -294,3 +292,0 @@\n-    if (C->failing()) {\n-      return;\n-    }\n@@ -301,3 +296,0 @@\n-    if (C->failing()) {\n-      return;\n-    }\n@@ -324,8 +316,0 @@\n-  if (!RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1))) {\n-    \/\/ the compiler cannot represent this method's calling sequence\n-    \/\/ Bailout. We do not have space to represent all arguments.\n-    C->record_method_not_compilable(\"must be able to represent all call arguments in reg mask\");\n-  }\n-\n-  if (C->failing())  return;  \/\/ bailed out on incoming arg failure\n-\n@@ -454,0 +438,3 @@\n+  for (unsigned int i = 0; i < size; ++i) {\n+    new (rms + i) RegMask(Compile::current()->comp_arena());\n+  }\n@@ -493,1 +480,1 @@\n-    new (rms + i) RegMask();\n+    new (rms + i) RegMask(C->comp_arena());\n@@ -542,2 +529,0 @@\n-  OptoReg::Name i;\n-\n@@ -549,1 +534,1 @@\n-  for (i = init_in; i < _in_arg_limit; i = OptoReg::add(i,1)) {\n+  for (OptoReg::Name i = init_in; i < _in_arg_limit; i = OptoReg::add(i, 1)) {\n@@ -553,8 +538,1 @@\n-  guarantee(RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1)),\n-            \"must be able to represent all call arguments in reg mask\");\n-  OptoReg::Name init = _out_arg_limit;\n-  for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1)) {\n-    C->FIRST_STACK_mask().Insert(i);\n-  }\n-  \/\/ Finally, set the \"infinite stack\" bit.\n-  C->FIRST_STACK_mask().set_AllStack();\n+  C->FIRST_STACK_mask().Set_All_From(_out_arg_limit);\n@@ -563,1 +541,1 @@\n-  RegMask aligned_stack_mask = C->FIRST_STACK_mask();\n+  RegMask aligned_stack_mask(C->FIRST_STACK_mask(), C->comp_arena());\n@@ -567,1 +545,1 @@\n-  RegMask scalable_stack_mask = aligned_stack_mask;\n+  RegMask scalable_stack_mask(aligned_stack_mask, C->comp_arena());\n@@ -995,1 +973,0 @@\n-  OptoReg::Name init = OptoReg::stack2reg(0);\n@@ -997,5 +974,1 @@\n-  OptoReg::Name i;\n-  for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1))\n-    STACK_ONLY_mask.Insert(i);\n-  \/\/ Also set the \"infinite stack\" bit.\n-  STACK_ONLY_mask.set_AllStack();\n+  STACK_ONLY_mask.Set_All_From(OptoReg::stack2reg(0));\n@@ -1003,1 +976,2 @@\n-  for (i = OptoReg::Name(0); i < OptoReg::Name(_last_Mach_Reg); i = OptoReg::add(i, 1)) {\n+  for (OptoReg::Name i = OptoReg::Name(0); i < OptoReg::Name(_last_Mach_Reg);\n+       i = OptoReg::add(i, 1)) {\n@@ -1280,6 +1254,2 @@\n-    if( warped >= out_arg_limit_per_call )\n-      out_arg_limit_per_call = OptoReg::add(warped,1);\n-    if (!RegMask::can_represent_arg(warped)) {\n-      \/\/ Bailout. For example not enough space on stack for all arguments. Happens for methods with too many arguments.\n-      C->record_method_not_compilable(\"unsupported calling sequence\");\n-      return OptoReg::Bad;\n+    if (warped >= out_arg_limit_per_call) {\n+      out_arg_limit_per_call = OptoReg::add(warped, 1);\n@@ -1369,1 +1339,3 @@\n-  for (uint i = 0; i < cnt; i++) ::new (&(msfpt->_in_rms[i])) RegMask();\n+  for (uint i = 0; i < cnt; i++) {\n+    ::new (msfpt->_in_rms + i) RegMask(C->comp_arena());\n+  }\n@@ -1452,3 +1424,0 @@\n-      if (C->failing()) {\n-        return nullptr;\n-      }\n@@ -1459,3 +1428,0 @@\n-      if (C->failing()) {\n-        return nullptr;\n-      }\n@@ -1481,6 +1447,2 @@\n-    if (!RegMask::can_represent_arg(OptoReg::Name(out_arg_limit_per_call-1))) {\n-      \/\/ Bailout. We do not have space to represent all arguments.\n-      C->record_method_not_compilable(\"unsupported outgoing calling sequence\");\n-    } else {\n-      for (int i = begin_out_arg_area; i < out_arg_limit_per_call; i++)\n-        proj->_rout.Insert(OptoReg::Name(i));\n+    for (int i = begin_out_arg_area; i < out_arg_limit_per_call; i++) {\n+      proj->_rout.Insert(OptoReg::Name(i));\n@@ -1488,1 +1450,1 @@\n-    if (proj->_rout.is_NotEmpty()) {\n+    if (!proj->_rout.is_Empty()) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":25,"deletions":63,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -552,0 +552,8 @@\n+  if (this->is_MachProj()) {\n+    \/\/ MachProjNodes contain register masks that may contain pointers to\n+    \/\/ externally allocated memory. Make sure to use a proper constructor\n+    \/\/ instead of just shallowly copying.\n+    MachProjNode* mach = n->as_MachProj();\n+    MachProjNode* mthis = this->as_MachProj();\n+    new (&mach->_rout) RegMask(mthis->_rout);\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -186,2 +187,4 @@\n-  short _second;\n-  short _first;\n+  typedef short Name;\n+  Name _second;\n+  Name _first;\n+\n@@ -189,5 +192,25 @@\n-  void set_bad (                   ) { _second = OptoReg::Bad; _first = OptoReg::Bad; }\n-  void set1    ( OptoReg::Name n  ) { _second = OptoReg::Bad; _first = n; }\n-  void set2    ( OptoReg::Name n  ) { _second = n + 1;       _first = n; }\n-  void set_pair( OptoReg::Name second, OptoReg::Name first    ) { _second= second;    _first= first; }\n-  void set_ptr ( OptoReg::Name ptr ) {\n+  static constexpr bool can_fit(OptoReg::Name n) {\n+    return n <= std::numeric_limits<OptoRegPair::Name>::max();\n+  }\n+  void set_bad() {\n+    _second = OptoReg::Bad;\n+    _first = OptoReg::Bad;\n+  }\n+  void set1(OptoReg::Name n) {\n+    assert(can_fit(n), \"overflow\");\n+    _second = OptoReg::Bad;\n+    _first = n;\n+  }\n+  void set2(OptoReg::Name n) {\n+    assert(can_fit(n + 1), \"overflow\");\n+    assert(can_fit(n), \"overflow\");\n+    _second = n + 1;\n+    _first = n;\n+  }\n+  void set_pair(OptoReg::Name second, OptoReg::Name first) {\n+    assert(can_fit(second), \"overflow\");\n+    assert(can_fit(first), \"overflow\");\n+    _second = second;\n+    _first = first;\n+  }\n+  void set_ptr(OptoReg::Name ptr) {\n@@ -195,1 +218,2 @@\n-    _second = ptr+1;\n+    assert(can_fit(ptr + 1), \"overflow\");\n+    _second = ptr + 1;\n@@ -199,0 +223,1 @@\n+    assert(can_fit(ptr), \"overflow\");\n@@ -204,3 +229,6 @@\n-  OptoRegPair(OptoReg::Name second, OptoReg::Name first) {  _second = second; _first = first; }\n-  OptoRegPair(OptoReg::Name f) { _second = OptoReg::Bad; _first = f; }\n-  OptoRegPair() { _second = OptoReg::Bad; _first = OptoReg::Bad; }\n+  OptoRegPair(OptoReg::Name second, OptoReg::Name first) {\n+    assert(can_fit(second), \"overflow\");\n+    assert(can_fit(first), \"overflow\");\n+    _second = second;\n+    _first = first;\n+  }\n","filename":"src\/hotspot\/share\/opto\/optoreg.hpp","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -176,2 +176,1 @@\n-  bool can_use = ( RegMask::can_represent(def_reg) ? (use_mask.Member(def_reg) != 0)\n-                                                   : (use_mask.is_AllStack() != 0));\n+  bool can_use = use_mask.Member(def_reg);\n@@ -682,3 +681,5 @@\n-              if (!value[ureg_lo] &&\n-                  (!RegMask::can_represent(ureg_lo) ||\n-                   lrgs(useidx).mask().Member(ureg_lo))) { \/\/ Nearly always adjacent\n+              bool is_reg = OptoReg::is_reg(ureg_lo);\n+              bool is_adjacent = lrgs(useidx).mask().Member(ureg_lo);\n+              assert(is_adjacent || is_reg,\n+                     \"only registers can be non-adjacent\");\n+              if (!value[ureg_lo] && is_adjacent) { \/\/ Nearly always adjacent\n@@ -765,2 +766,4 @@\n-        if( RegMask::can_represent(nreg_lo) &&     \/\/ Either a spill slot, or\n-            !lrgs(lidx).mask().Member(nreg_lo) ) { \/\/ Nearly always adjacent\n+        bool is_reg = OptoReg::is_reg(nreg_lo);\n+        bool is_adjacent = lrgs(lidx).mask().Member(nreg_lo);\n+        assert(is_adjacent || is_reg, \"only registers can be non-adjacent\");\n+        if (!is_adjacent) { \/\/ Nearly always adjacent\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -479,1 +479,1 @@\n-    if (n->out_RegMask().is_NotEmpty()) {\n+    if (!n->out_RegMask().is_Empty()) {\n@@ -1129,1 +1129,2 @@\n-                  RegMask tmp_rm(umask);\n+                  ResourceMark rm(C->regmask_arena());\n+                  RegMask tmp_rm(umask, C->regmask_arena());\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/population_count.hpp\"\n@@ -55,1 +54,1 @@\n-  FORALL_BODY\n+    FORALL_BODY\n@@ -57,2 +56,1 @@\n-  0\n-);\n+    true);\n@@ -122,1 +120,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = rm_up(i);\n@@ -125,1 +123,1 @@\n-    _RM_UP[i] = bits;\n+    rm_up(i) = bits;\n@@ -138,1 +136,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = rm_up(i);\n@@ -157,1 +155,1 @@\n-    uintptr_t v = _RM_UP[i];\n+    uintptr_t v = rm_up(i);\n@@ -166,1 +164,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (rm_up(i) != 0) {\n@@ -184,2 +182,2 @@\n-    if (_RM_UP[i] != 0) {               \/\/ Found some bits\n-      unsigned int bit_index = find_lowest_bit(_RM_UP[i]);\n+    if (rm_up(i) != 0) {               \/\/ Found some bits\n+      unsigned int bit_index = find_lowest_bit(rm_up(i));\n@@ -188,1 +186,1 @@\n-        if ((bit | (bit << 1U)) != _RM_UP[i]) {\n+        if ((bit | (bit << 1U)) != rm_up(i)) {\n@@ -192,1 +190,1 @@\n-        assert(is_power_of_2(_RM_UP[i]), \"invariant\");\n+        assert(is_power_of_2(rm_up(i)), \"invariant\");\n@@ -194,1 +192,1 @@\n-        if (i > _hwm || _RM_UP[i] != 1) {\n+        if (i > _hwm || rm_up(i) != 1) {\n@@ -201,1 +199,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (rm_up(i) != 0) {\n@@ -247,1 +245,1 @@\n-    if (_RM_UP[i]) {                \/\/ Found some bits\n+    if (rm_up(i) != 0) {                \/\/ Found some bits\n@@ -249,1 +247,2 @@\n-      return OptoReg::Name((i<<_LogWordBits) + find_lowest_bit(_RM_UP[i]) + (size - 1));\n+      return OptoReg::Name(offset_bits() + (i << _LogWordBits) +\n+                           find_lowest_bit(rm_up(i)) + (size - 1));\n@@ -263,1 +262,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = rm_up(i);\n@@ -278,1 +277,1 @@\n-    _RM_UP[i] = sets;\n+    rm_up(i) = sets;\n@@ -291,1 +290,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = rm_up(i);\n@@ -307,1 +306,1 @@\n-    _RM_UP[i] = sets;\n+    rm_up(i) = sets;\n@@ -320,2 +319,2 @@\n-    uintptr_t bits = _RM_UP[i];\n-    while (bits) {              \/\/ Check bits for pairing\n+    uintptr_t bits = rm_up(i);\n+    while (bits != 0) {              \/\/ Check bits for pairing\n@@ -347,2 +346,2 @@\n-    if (_RM_UP[i] != 0) {       \/\/ Found some bits\n-      unsigned bit_index = find_lowest_bit(_RM_UP[i]);\n+    if (rm_up(i) != 0) {       \/\/ Found some bits\n+      unsigned bit_index = find_lowest_bit(rm_up(i));\n@@ -353,1 +352,1 @@\n-        if (set != _RM_UP[i]) {\n+        if (set != rm_up(i)) {\n@@ -358,1 +357,1 @@\n-        if ((all & ~(bit-1)) != _RM_UP[i]) {\n+        if ((all & ~(bit - 1)) != rm_up(i)) {\n@@ -364,1 +363,1 @@\n-        if (i > _hwm || _RM_UP[i] != set) {\n+        if (i > _hwm || rm_up(i) != set) {\n@@ -371,1 +370,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (rm_up(i) != 0) {\n@@ -395,6 +394,15 @@\n-\/\/ Compute size of register mask in bits\n-uint RegMask::Size() const {\n-  uint sum = 0;\n-  assert(valid_watermarks(), \"sanity\");\n-  for (unsigned i = _lwm; i <= _hwm; i++) {\n-    sum += population_count(_RM_UP[i]);\n+#ifndef PRODUCT\n+bool RegMask::dump_end_run(outputStream* st, OptoReg::Name start,\n+                           OptoReg::Name last) const {\n+  bool last_is_end = last == (int)offset_bits() + (int)rm_size_bits() - 1;\n+  if (is_AllStack() && last_is_end) {\n+    st->print(\"-...\");\n+    return true;\n+  }\n+  if (start == last) { \/\/ 1-register run; no special printing\n+  } else if (start + 1 == last) {\n+    st->print(\",\"); \/\/ 2-register run; print as \"rX,rY\"\n+    OptoReg::dump(last, st);\n+  } else { \/\/ Multi-register run; print as \"rX-rZ\"\n+    st->print(\"-\");\n+    OptoReg::dump(last, st);\n@@ -402,1 +410,1 @@\n-  return sum;\n+  return false;\n@@ -405,1 +413,0 @@\n-#ifndef PRODUCT\n@@ -410,0 +417,1 @@\n+  bool printed_all_stack = false;\n@@ -426,8 +434,2 @@\n-        if (start == last) {    \/\/ 1-register run; no special printing\n-        } else if (start+1 == last) {\n-          st->print(\",\");       \/\/ 2-register run; print as \"rX,rY\"\n-          OptoReg::dump(last, st);\n-        } else {                \/\/ Multi-register run; print as \"rX-rZ\"\n-          st->print(\"-\");\n-          OptoReg::dump(last, st);\n-        }\n+        printed_all_stack = dump_end_run(st, start, last);\n+        assert(!printed_all_stack, \"\");\n@@ -439,8 +441,12 @@\n-\n-    if (start == last) {        \/\/ 1-register run; no special printing\n-    } else if (start+1 == last) {\n-      st->print(\",\");           \/\/ 2-register run; print as \"rX,rY\"\n-      OptoReg::dump(last, st);\n-    } else {                    \/\/ Multi-register run; print as \"rX-rZ\"\n-      st->print(\"-\");\n-      OptoReg::dump(last, st);\n+    printed_all_stack = dump_end_run(st, start, last);\n+    \/\/ Print all_stack if not already done.\n+    if (is_AllStack() && !printed_all_stack) {\n+      st->print(\",\");\n+      OptoReg::dump(offset_bits() + rm_size_bits(), st);\n+      st->print(\"-...\");\n+    }\n+  } else {\n+    \/\/ Mask is all_stack only.\n+    if (is_AllStack() && !printed_all_stack) {\n+      OptoReg::dump(offset_bits() + rm_size_bits(), st);\n+      st->print(\"-...\");\n@@ -448,1 +454,0 @@\n-    if (is_AllStack()) st->print(\"...\");\n@@ -452,0 +457,11 @@\n+\n+void RegMask::dump_hex(outputStream* st) const {\n+  st->print(\"...%x|\", is_AllStack() ? 0xf : 0x0);\n+  for (int i = rm_max(); i >= 0; i--) {\n+    st->print(LP64_ONLY(\"%0*lx\") NOT_LP64(\"%0*x\"),\n+              (int)sizeof(uintptr_t) * CHAR_BIT \/ 4, rm_up(i));\n+    if (i != 0) {\n+      st->print(\"|\");\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":70,"deletions":54,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -36,0 +37,8 @@\n+\/\/ To avoid unbounded RegMask growth and to be able to statically compute a\n+\/\/ register mask size upper bound (see RM_SIZE_MAX below), we need to set some\n+\/\/ form of limit on the number of stack slots used by BoxLockNodes. The limit\n+\/\/ below is rather arbitrary but should be quite generous and cover all\n+\/\/ practical cases. We reach this limit by, e.g., deeply nesting synchronized\n+\/\/ statements in Java.\n+const int BoxLockNode_SLOT_LIMIT = 200;\n+\n@@ -51,2 +60,4 @@\n-\/\/ The ADLC defines 2 macros, RM_SIZE and FORALL_BODY.\n-\/\/ RM_SIZE is the size of a register mask in 32-bit words.\n+\/\/ The ADLC defines 3 macros, RM_SIZE, RM_SIZE_MIN, and FORALL_BODY.\n+\/\/ RM_SIZE is the base size of a register mask in 32-bit words.\n+\/\/ RM_SIZE_MIN is the theoretical minimum size of a register mask in 32-bit\n+\/\/ words.\n@@ -67,0 +78,2 @@\n+\n+  \/\/ RM_SIZE, but in number of machine words\n@@ -68,0 +81,7 @@\n+\n+  \/\/ RM_SIZE_MIN, but in number of machine words\n+  static const unsigned int _RM_SIZE_MIN =\n+      LP64_ONLY(((RM_SIZE_MIN + 1) & ~1) >> 1) NOT_LP64(RM_SIZE_MIN);\n+\n+  \/\/ The last index (in machine words) of the (static) array of register mask\n+  \/\/ bits\n@@ -70,0 +90,22 @@\n+  \/\/ Compute a best-effort (statically known) upper bound for register mask\n+  \/\/ size in 32-bit words. When extending\/growing register masks, we should\n+  \/\/ never grow past this size.\n+  static const unsigned int RM_SIZE_MAX =\n+      (((RM_SIZE_MIN << 5) +                \/\/ Slots for machine registers\n+        (max_method_parameter_length * 2) + \/\/ Slots for incoming arguments\n+        (max_method_parameter_length * 2) + \/\/ Slots for outgoing arguments\n+        BoxLockNode_SLOT_LIMIT +            \/\/ Slots for locks\n+        64                                  \/\/ Padding, reserved words, etc.\n+        ) + 31) >> 5; \/\/ Number of bits -> number of 32-bit words\n+\n+  \/\/ RM_SIZE_MAX, but in number of machine words\n+  static const unsigned int _RM_SIZE_MAX =\n+      LP64_ONLY(((RM_SIZE_MAX + 1) & ~1) >> 1) NOT_LP64(RM_SIZE_MAX);\n+\n+  \/\/ Sanity check\n+  STATIC_ASSERT(RM_SIZE <= RM_SIZE_MAX);\n+\n+  \/\/ Ensure that register masks cannot grow beyond the point at which\n+  \/\/ OptoRegPair can no longer index the whole mask\n+  STATIC_ASSERT(OptoRegPair::can_fit((RM_SIZE_MAX << 5) - 1));\n+\n@@ -71,5 +113,6 @@\n-    \/\/ Array of Register Mask bits.  This array is large enough to cover\n-    \/\/ all the machine registers and all parameters that need to be passed\n-    \/\/ on the stack (stack registers) up to some interesting limit.  Methods\n-    \/\/ that need more parameters will NOT be compiled.  On Intel, the limit\n-    \/\/ is something like 90+ parameters.\n+    \/\/ Array of Register Mask bits.  This array is large enough to cover all\n+    \/\/ the machine registers and usually all parameters that need to be passed\n+    \/\/ on the stack (stack registers) up to some interesting limit. On Intel,\n+    \/\/ the limit is something like 90+ parameters.\n+\n+    \/\/ Viewed as an array of 32-bit words\n@@ -77,0 +120,2 @@\n+\n+    \/\/ Viewed as an array of machine words\n@@ -80,4 +125,58 @@\n-  \/\/ The low and high water marks represents the lowest and highest word\n-  \/\/ that might contain set register mask bits, respectively. We guarantee\n-  \/\/ that there are no bits in words outside this range, but any word at\n-  \/\/ and between the two marks can still be 0.\n+  \/\/ In rare situations (e.g., \"more than 90+ parameters on Intel\"), we need to\n+  \/\/ extend the register mask with dynamically allocated memory. We keep the\n+  \/\/ base statically allocated _RM_UP, and arena allocate the extended mask\n+  \/\/ (_RM_UP_EXT) separately. Another, perhaps more elegant, option would be to\n+  \/\/ have two subclasses of RegMask, where one is statically allocated and one\n+  \/\/ is (entirely) dynamically allocated. Given that register mask extension is\n+  \/\/ rare, we decided to use the current approach (_RM_UP and _RM_UP_EXT) to\n+  \/\/ keep the common case fast. Most of the time, we will then not need to\n+  \/\/ dynamically allocate anything.\n+  \/\/\n+  \/\/ We could use a GrowableArray here, but there are currently some\n+  \/\/ GrowableArray limitations that have a negative performance impact for our\n+  \/\/ use case:\n+  \/\/\n+  \/\/ - There is no efficient copy\/clone operation.\n+  \/\/ - GrowableArray construction currently default-initializes everything\n+  \/\/   within the array's initial capacity, which is unnecessary in our case.\n+  \/\/\n+  \/\/ After addressing these limitations, we should consider using a\n+  \/\/ GrowableArray here.\n+  uintptr_t* _RM_UP_EXT = nullptr;\n+\n+#ifdef ASSERT\n+  \/\/ Register masks may get shallowly copied without the use of constructors,\n+  \/\/ which is problematic when dealing with the externally allocated memory for\n+  \/\/ _RM_UP_EXT. Therefore, we need some sanity checks to ensure we have not\n+  \/\/ missed any such cases. The below variables enable such checks.\n+  \/\/\n+  \/\/ The original address of the _RM_UP_EXT variable, set when using\n+  \/\/ constructors. If we get copied\/cloned, &_RM_UP_EXT will no longer equal\n+  \/\/ _original_ext_address.\n+  uintptr_t** _original_ext_address = &_RM_UP_EXT;\n+  \/\/\n+  \/\/ If the original version, of which we may be a clone, is read-only. In such\n+  \/\/ cases, we can allow read-only sharing.\n+  bool _read_only = false;\n+#endif\n+\n+  \/\/ Current total register mask size in machine words\n+  unsigned int _rm_size;\n+\n+  \/\/ We support offsetting register masks to present different views of the\n+  \/\/ register space, mainly for use in PhaseChaitin::Select. The _offset\n+  \/\/ variable indicates how many words we offset with. We consider all\n+  \/\/ registers before the offset to not be included in the register mask.\n+  unsigned int _offset;\n+\n+  \/\/ If _all_stack = true, we consider all registers beyond what the register\n+  \/\/ mask can currently represent to be included. If _all_stack = false, we\n+  \/\/ consider the registers not included.\n+  bool _all_stack = false;\n+\n+  \/\/ The low and high watermarks represent the lowest and highest word that\n+  \/\/ might contain set register mask bits, respectively. We guarantee that\n+  \/\/ there are no bits in words outside this range, but any word at and between\n+  \/\/ the two marks can still be 0. We do not guarantee that the watermarks are\n+  \/\/ optimal. If _hwm < _lwm, the register mask is necessarily empty. Indeed,\n+  \/\/ when we construct empty register masks, we set _hwm = 0 and _lwm = max.\n@@ -87,2 +186,186 @@\n- public:\n-  enum { CHUNK_SIZE = _RM_SIZE * BitsPerWord };\n+  \/\/ The following diagram illustrates the internal representation of a RegMask\n+  \/\/ (with _offset = 0, for a made-up platform with 10 registers and 4-bit\n+  \/\/ words) that has been extended with two additional words to represent more\n+  \/\/ stack locations:\n+  \/\/                                            _hwm=3\n+  \/\/                     _lwm=1                RM_SIZE=3                _rm_size=5\n+  \/\/                       |                       |                        |\n+  \/\/            r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 s0 s1   s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 ...\n+  \/\/ Content:  [0  0  0  0 |0  1  1  0 |0  0  1  0 ] [1  1  0  1 |0  0  0  0] as  as  as\n+  \/\/   Index: [0]         [1]         [2]           [0]         [1]\n+  \/\/\n+  \/\/          \\____________________________________\/ \\______________________\/\n+  \/\/                                 |                           |\n+  \/\/                               RM_UP                     RM_UP_EXT\n+  \/\/          \\_____________________________________________________________\/\n+  \/\/                                          |\n+  \/\/                                      _rm_size\n+  \/\/\n+  \/\/ In this example, registers {r5, r6} and stack locations {s0, s2, s3, s5}\n+  \/\/ are included in the register mask. Depending on the value of _all_stack\n+  \/\/ (denoted with as), {s10, s11, ...} are all included (as = 1) or excluded\n+  \/\/ (as = 0). Note that all registers\/stack locations under _lwm and over _hwm\n+  \/\/ are excluded. The exception is {s10, s11, ...}, where the value is decided\n+  \/\/ solely by _all_stack, regardless of the value of _hwm.\n+  \/\/\n+  \/\/ The only operation that may update the _offset attribute is\n+  \/\/ RegMask::rollover(). This operation requires the register mask to be\n+  \/\/ clean\/empty (all zeroes), except for _all_stack, which must be true, and\n+  \/\/ has the effect of increasing _offset by _rm_size and setting all bits (now\n+  \/\/ necessarily representing stack locations) to 1. Here is how the above\n+  \/\/ register mask looks like after clearing, setting _all_stack to true, and\n+  \/\/ successfully rolling over:\n+  \/\/\n+  \/\/          _lwm=0                                      RM_SIZE=3           _hwm=3      _rm_size=5\n+  \/\/           |                                              |                 |             |\n+  \/\/            s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 s20 s21  s22 s23 s24 s25 s26 s27 s28 s29 s30 s31 ...\n+  \/\/ Content:  [1   1   1   1  |1   1   1   1  |1   1   1   1 ] [1   1   1   1  |1   1   1   1]  1   1   1\n+  \/\/   Index: [0]             [1]             [2]              [0]             [1]\n+  \/\/\n+  \/\/          \\_______________________________________________\/ \\_____________________________\/\n+  \/\/                                    |                                     |\n+  \/\/                                  RM_UP                               RM_UP_EXT\n+  \/\/          \\_______________________________________________________________________________\/\n+  \/\/                                                  |\n+  \/\/                                              _rm_size\n+\n+  \/\/ Access word i in the register mask.\n+  const uintptr_t& rm_up(unsigned int i) const {\n+    assert(_read_only || _original_ext_address == &_RM_UP_EXT, \"clone sanity check\");\n+    assert(i < _rm_size, \"sanity\");\n+    if (i < _RM_SIZE) {\n+      return _RM_UP[i];\n+    } else {\n+      assert(_RM_UP_EXT != nullptr, \"sanity\");\n+      return _RM_UP_EXT[i - _RM_SIZE];\n+    }\n+  }\n+\n+  \/\/ Non-const version of the above.\n+  uintptr_t& rm_up(unsigned int i) {\n+    assert(_original_ext_address == &_RM_UP_EXT, \"clone sanity check\");\n+    return const_cast<uintptr_t&>(const_cast<const RegMask*>(this)->rm_up(i));\n+  }\n+\n+  \/\/ The maximum word index\n+  unsigned int rm_max() const {\n+    return _rm_size - 1U;\n+  }\n+\n+  \/\/ Where to extend the register mask\n+  Arena* _arena;\n+\n+  \/\/ Grow the register mask to ensure it can fit at least min_size words.\n+  void grow(unsigned int min_size, bool init = true) {\n+    if (min_size > _rm_size) {\n+      assert(min_size <= _RM_SIZE_MAX, \"unexpected register mask growth\");\n+      assert(_arena != nullptr, \"register mask not growable\");\n+      min_size = MIN2(_RM_SIZE_MAX, round_up_power_of_2(min_size));\n+      unsigned int old_size = _rm_size;\n+      unsigned int old_ext_size = old_size - _RM_SIZE;\n+      unsigned int new_ext_size = min_size - _RM_SIZE;\n+      _rm_size = min_size;\n+      if (_RM_UP_EXT == nullptr) {\n+        assert(old_ext_size == 0, \"sanity\");\n+        _RM_UP_EXT = NEW_ARENA_ARRAY(_arena, uintptr_t, new_ext_size);\n+      } else {\n+        assert(_original_ext_address == &_RM_UP_EXT, \"clone sanity check\");\n+        _RM_UP_EXT = REALLOC_ARENA_ARRAY(_arena, uintptr_t, _RM_UP_EXT,\n+                                         old_ext_size, new_ext_size);\n+      }\n+      if (init) {\n+        int fill = 0;\n+        if (is_AllStack()) {\n+          fill = 0xFF;\n+          _hwm = rm_max();\n+        }\n+        set_range(old_size, fill, _rm_size - old_size);\n+      }\n+    }\n+  }\n+\n+  \/\/ Make us a copy of src\n+  void copy(const RegMask& src) {\n+    assert(_offset == src._offset, \"offset mismatch\");\n+    _hwm = src._hwm;\n+    _lwm = src._lwm;\n+\n+    \/\/ Copy base mask\n+    memcpy(_RM_UP, src._RM_UP, sizeof(uintptr_t) * _RM_SIZE);\n+    _all_stack = src._all_stack;\n+\n+    \/\/ Copy extension\n+    if (src._RM_UP_EXT != nullptr) {\n+      assert(src._rm_size > _RM_SIZE, \"sanity\");\n+      assert(_original_ext_address == &_RM_UP_EXT, \"clone sanity check\");\n+      grow(src._rm_size, false);\n+      memcpy(_RM_UP_EXT, src._RM_UP_EXT,\n+             sizeof(uintptr_t) * (src._rm_size - _RM_SIZE));\n+    }\n+\n+    \/\/ If the source is smaller than us, we need to set the gap according to\n+    \/\/ the sources all_stack flag.\n+    if (src._rm_size < _rm_size) {\n+      int value = 0;\n+      if (src.is_AllStack()) {\n+        value = 0xFF;\n+        _hwm = rm_max();\n+      }\n+      set_range(src._rm_size, value, _rm_size - src._rm_size);\n+    }\n+\n+    assert(valid_watermarks(), \"post-condition\");\n+  }\n+\n+  void trim_watermarks() {\n+    if (_hwm < _lwm) {\n+      return;\n+    }\n+    while ((_hwm > _lwm) && rm_up(_hwm) == 0) {\n+      _hwm--;\n+    }\n+    while ((_lwm < _hwm) && rm_up(_lwm) == 0) {\n+      _lwm++;\n+    }\n+    if ((_lwm == _hwm) && rm_up(_lwm) == 0) {\n+      _lwm = rm_max();\n+      _hwm = 0;\n+    }\n+  }\n+\n+  \/\/ Set a span of words in the register mask to a given value.\n+  void set_range(unsigned int start, int value, unsigned int length) {\n+    if (start < _RM_SIZE) {\n+      memset(_RM_UP + start, value,\n+             sizeof(uintptr_t) * MIN2((int)length, (int)_RM_SIZE - (int)start));\n+    }\n+    if (start + length > _RM_SIZE) {\n+      assert(_RM_UP_EXT != nullptr, \"sanity\");\n+      assert(_original_ext_address == &_RM_UP_EXT, \"clone sanity check\");\n+      memset(_RM_UP_EXT + MAX2((int)start - (int)_RM_SIZE, 0), value,\n+             sizeof(uintptr_t) *\n+                 MIN2((int)length, (int)length - ((int)_RM_SIZE - (int)start)));\n+    }\n+  }\n+\n+public:\n+  unsigned int rm_size() const {\n+    return _rm_size;\n+  }\n+  unsigned int rm_size_bits() const {\n+    return _rm_size * BitsPerWord;\n+  }\n+\n+  bool is_offset() const {\n+    return _offset > 0;\n+  }\n+  unsigned int offset_bits() const {\n+    return _offset * BitsPerWord;\n+  };\n+\n+  bool is_AllStack() const {\n+    return _all_stack;\n+  }\n+  void set_AllStack(bool value) {\n+    _all_stack = value;\n+  }\n@@ -116,1 +399,1 @@\n-    FORALL_BODY\n+      FORALL_BODY\n@@ -118,1 +401,2 @@\n-    int dummy = 0) {\n+      bool all_stack)\n+      : _rm_size(_RM_SIZE), _offset(0), _all_stack(all_stack), _arena(nullptr) {\n@@ -134,7 +418,4 @@\n-  \/\/ Handy copying constructor\n-  RegMask(RegMask *rm) {\n-    _hwm = rm->_hwm;\n-    _lwm = rm->_lwm;\n-    for (unsigned i = 0; i < _RM_SIZE; i++) {\n-      _RM_UP[i] = rm->_RM_UP[i];\n-    }\n+  \/\/ Construct an empty mask\n+  RegMask(Arena* arena DEBUG_ONLY(COMMA bool read_only = false))\n+      : _RM_UP() DEBUG_ONLY(COMMA _read_only(read_only)), _rm_size(_RM_SIZE),\n+        _offset(0), _all_stack(false), _lwm(_RM_MAX), _hwm(0), _arena(arena) {\n@@ -143,3 +424,1 @@\n-\n-  \/\/ Construct an empty mask\n-  RegMask() : _RM_UP(), _lwm(_RM_MAX), _hwm(0) {\n+  RegMask() : RegMask(nullptr) {\n@@ -150,1 +429,3 @@\n-  RegMask(OptoReg::Name reg) : RegMask() {\n+  RegMask(OptoReg::Name reg,\n+          Arena* arena DEBUG_ONLY(COMMA bool read_only = false))\n+      : RegMask(arena DEBUG_ONLY(COMMA read_only)) {\n@@ -153,0 +434,1 @@\n+  RegMask(OptoReg::Name reg) : RegMask(reg, nullptr) {}\n@@ -154,6 +436,4 @@\n-  \/\/ Check for register being in mask\n-  bool Member(OptoReg::Name reg) const {\n-    assert(reg < CHUNK_SIZE, \"\");\n-\n-    unsigned r = (unsigned)reg;\n-    return _RM_UP[r >> _LogWordBits] & (uintptr_t(1) << (r & _WordBitMask));\n+  \/\/ Deep copying\n+  RegMask(const RegMask& rm, Arena* arena)\n+      : _rm_size(_RM_SIZE), _offset(rm._offset), _arena(arena) {\n+    copy(rm);\n@@ -162,5 +442,6 @@\n-  \/\/ The last bit in the register mask indicates that the mask should repeat\n-  \/\/ indefinitely with ONE bits.  Returns TRUE if mask is infinite or\n-  \/\/ unbounded in size.  Returns FALSE if mask is finite size.\n-  bool is_AllStack() const {\n-    return (_RM_UP[_RM_MAX] & (uintptr_t(1) << _WordBitMask)) != 0;\n+  RegMask(const RegMask& rm) : RegMask(rm, nullptr) {}\n+\n+  \/\/ Deep copying\n+  RegMask& operator=(const RegMask& rm) {\n+    copy(rm);\n+    return *this;\n@@ -169,2 +450,10 @@\n-  void set_AllStack() {\n-    _RM_UP[_RM_MAX] |= (uintptr_t(1) << _WordBitMask);\n+  bool Member(OptoReg::Name reg) const {\n+    reg = reg - offset_bits();\n+    if (reg < 0) {\n+      return false;\n+    }\n+    if (reg >= (int)rm_size_bits()) {\n+      return is_AllStack();\n+    }\n+    unsigned int r = (unsigned int)reg;\n+    return rm_up(r >> _LogWordBits) & (uintptr_t(1) << (r & _WordBitMask));\n@@ -173,2 +462,2 @@\n-  \/\/ Test for being a not-empty mask.\n-  bool is_NotEmpty() const {\n+  \/\/ Empty mask check. Ignores registers included through the all_stack flag.\n+  bool is_Empty() const {\n@@ -176,1 +465,0 @@\n-    uintptr_t tmp = 0;\n@@ -178,1 +466,3 @@\n-      tmp |= _RM_UP[i];\n+      if (rm_up(i) != 0) {\n+        return false;\n+      }\n@@ -180,1 +470,1 @@\n-    return tmp;\n+    return true;\n@@ -187,3 +477,4 @@\n-      uintptr_t bits = _RM_UP[i];\n-      if (bits) {\n-        return OptoReg::Name((i << _LogWordBits) + find_lowest_bit(bits));\n+      uintptr_t bits = rm_up(i);\n+      if (bits != 0) {\n+        return OptoReg::Name(offset_bits() + (i << _LogWordBits) +\n+                             find_lowest_bit(bits));\n@@ -195,1 +486,2 @@\n-  \/\/ Get highest-numbered register from mask, or BAD if mask is empty.\n+  \/\/ Get highest-numbered register from mask, or BAD if mask is empty. Ignores\n+  \/\/ registers included through the all_stack flag.\n@@ -201,3 +493,4 @@\n-      uintptr_t bits = _RM_UP[--i];\n-      if (bits) {\n-        return OptoReg::Name((i << _LogWordBits) + find_highest_bit(bits));\n+      uintptr_t bits = rm_up(--i);\n+      if (bits != 0) {\n+        return OptoReg::Name(offset_bits() + (i << _LogWordBits) +\n+                             find_highest_bit(bits));\n@@ -216,2 +509,2 @@\n-    assert(_hwm < _RM_SIZE, \"_hwm out of range: %d\", _hwm);\n-    assert(_lwm < _RM_SIZE, \"_lwm out of range: %d\", _lwm);\n+    assert(_hwm < _rm_size, \"_hwm out of range: %d\", _hwm);\n+    assert(_lwm < _rm_size, \"_lwm out of range: %d\", _lwm);\n@@ -219,1 +512,1 @@\n-      assert(_RM_UP[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n+      assert(rm_up(i) == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n@@ -221,2 +514,16 @@\n-    for (unsigned i = _hwm + 1; i < _RM_SIZE; i++) {\n-      assert(_RM_UP[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n+    for (unsigned i = _hwm + 1; i < _rm_size; i++) {\n+      assert(rm_up(i) == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n+    }\n+    return true;\n+  }\n+\n+  bool is_AllStack_only() const {\n+    assert(valid_watermarks(), \"sanity\");\n+    if (!is_AllStack()) {\n+      return false;\n+    }\n+    uintptr_t tmp = 0;\n+    for (unsigned int i = _lwm; i <= _hwm; i++) {\n+      if (rm_up(i) != 0) {\n+        return false;\n+      }\n@@ -263,1 +570,1 @@\n-  \/\/ Fast overlap test.  Non-zero if any registers in common.\n+  \/\/ Overlap test. Non-zero if any registers in common, including all_stack.\n@@ -265,0 +572,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -266,0 +574,3 @@\n+\n+    \/\/ Very common overlap case: _rm_up overlap. Check first to reduce\n+    \/\/ execution time.\n@@ -268,1 +579,0 @@\n-    uintptr_t result = 0;\n@@ -270,1 +580,19 @@\n-      result |= _RM_UP[i] & rm._RM_UP[i];\n+      if ((rm_up(i) & rm.rm_up(i)) != 0) {\n+        return true;\n+      }\n+    }\n+\n+    \/\/ Very rare overlap cases below.\n+\n+    \/\/ We are both all_stack\n+    if (is_AllStack() && rm.is_AllStack()) {\n+      return true;\n+    }\n+\n+    \/\/ We are all_stack and rm _hwm is bigger than us\n+    if (is_AllStack() && rm._hwm >= _rm_size) {\n+      for (unsigned i = MAX2(rm._lwm, _rm_size); i <= rm._hwm; i++) {\n+        if (rm.rm_up(i) != 0) {\n+          return true;\n+        }\n+      }\n@@ -272,1 +600,12 @@\n-    return result;\n+\n+    \/\/ rm is all_stack and our _hwm is bigger than rm\n+    if (rm.is_AllStack() && _hwm >= rm._rm_size) {\n+      for (unsigned i = MAX2(_lwm, rm._rm_size); i <= _hwm; i++) {\n+        if (rm_up(i) != 0) {\n+          return true;\n+        }\n+      }\n+    }\n+\n+    \/\/ No overlap (also very common)\n+    return false;\n@@ -279,1 +618,1 @@\n-  \/\/ Clear a register mask\n+  \/\/ Clear a register mask. Does not clear any offset.\n@@ -281,1 +620,1 @@\n-    _lwm = _RM_MAX;\n+    _lwm = rm_max();\n@@ -283,1 +622,2 @@\n-    memset(_RM_UP, 0, sizeof(uintptr_t) * _RM_SIZE);\n+    set_range(0, 0, _rm_size);\n+    set_AllStack(false);\n@@ -289,0 +629,6 @@\n+    assert(_offset == 0, \"offset non-zero\");\n+    Set_All_From_Offset();\n+  }\n+\n+  \/\/ Fill a register mask with 1's from the current offset.\n+  void Set_All_From_Offset() {\n@@ -290,2 +636,3 @@\n-    _hwm = _RM_MAX;\n-    memset(_RM_UP, 0xFF, sizeof(uintptr_t) * _RM_SIZE);\n+    _hwm = rm_max();\n+    set_range(0, 0xFF, _rm_size);\n+    set_AllStack(true);\n@@ -295,0 +642,23 @@\n+  \/\/ Fill a register mask with 1's starting from the given register.\n+  void Set_All_From(OptoReg::Name reg) {\n+    reg = reg - offset_bits();\n+    assert(reg != OptoReg::Bad, \"sanity\");\n+    assert(reg != OptoReg::Special, \"sanity\");\n+    assert(reg >= 0, \"register outside mask\");\n+    assert(valid_watermarks(), \"pre-condition\");\n+    unsigned int r = (unsigned int)reg;\n+    unsigned int index = r >> _LogWordBits;\n+    unsigned int min_size = index + 1;\n+    grow(min_size);\n+    rm_up(index) |= (uintptr_t(-1) << (r & _WordBitMask));\n+    if (index < rm_max()) {\n+      set_range(index + 1, 0xFF, rm_max() - index);\n+    }\n+    if (index < _lwm) {\n+      _lwm = index;\n+    }\n+    _hwm = rm_max();\n+    set_AllStack(true);\n+    assert(valid_watermarks(), \"post-condition\");\n+  }\n+\n@@ -297,0 +667,1 @@\n+    reg = reg - offset_bits();\n@@ -299,1 +670,1 @@\n-    assert(reg < CHUNK_SIZE, \"sanity\");\n+    assert(reg >= 0, \"register outside mask\");\n@@ -301,2 +672,4 @@\n-    unsigned r = (unsigned)reg;\n-    unsigned index = r >> _LogWordBits;\n+    unsigned int r = (unsigned int)reg;\n+    unsigned int index = r >> _LogWordBits;\n+    unsigned int min_size = index + 1;\n+    grow(min_size);\n@@ -305,1 +678,1 @@\n-    _RM_UP[index] |= (uintptr_t(1) << (r & _WordBitMask));\n+    rm_up(index) |= (uintptr_t(1) << (r & _WordBitMask));\n@@ -311,3 +684,5 @@\n-    assert(reg < CHUNK_SIZE, \"\");\n-    unsigned r = (unsigned)reg;\n-    _RM_UP[r >> _LogWordBits] &= ~(uintptr_t(1) << (r & _WordBitMask));\n+    reg = reg - offset_bits();\n+    assert(reg >= 0, \"register outside mask\");\n+    assert(reg < (int)rm_size_bits(), \"register outside mask\");\n+    unsigned int r = (unsigned int)reg;\n+    rm_up(r >> _LogWordBits) &= ~(uintptr_t(1) << (r & _WordBitMask));\n@@ -318,0 +693,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -319,0 +695,1 @@\n+    grow(rm._rm_size);\n@@ -322,2 +699,9 @@\n-    for (unsigned i = _lwm; i <= _hwm; i++) {\n-      _RM_UP[i] |= rm._RM_UP[i];\n+    \/\/ Compute OR with all words from rm\n+    for (unsigned int i = _lwm; i <= _hwm && i < rm._rm_size; i++) {\n+      rm_up(i) |= rm.rm_up(i);\n+    }\n+    \/\/ If rm is smaller than us and has the all_stack flag set, we need to set\n+    \/\/ all bits in the gap to 1.\n+    if (rm.is_AllStack() && rm._rm_size < _rm_size) {\n+      set_range(rm._rm_size, 0xFF, _rm_size - rm._rm_size);\n+      _hwm = rm_max();\n@@ -325,0 +709,1 @@\n+    set_AllStack(is_AllStack() || rm.is_AllStack());\n@@ -330,0 +715,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -331,4 +717,22 @@\n-    \/\/ Do not evaluate words outside the current watermark range, as they are\n-    \/\/ already zero and an &= would not change that\n-    for (unsigned i = _lwm; i <= _hwm; i++) {\n-      _RM_UP[i] &= rm._RM_UP[i];\n+    grow(rm._rm_size);\n+    \/\/ Compute AND with all words from rm. Do not evaluate words outside the\n+    \/\/ current watermark range, as they are already zero and an &= would not\n+    \/\/ change that\n+    for (unsigned int i = _lwm; i <= _hwm && i < rm._rm_size; i++) {\n+      rm_up(i) &= rm.rm_up(i);\n+    }\n+    \/\/ If rm is smaller than our high watermark and has the all_stack flag not\n+    \/\/ set, we need to set all bits in the gap to 0.\n+    if (!rm.is_AllStack() && _hwm > rm.rm_max()) {\n+      set_range(rm._rm_size, 0, _hwm - rm.rm_max());\n+      _hwm = rm.rm_max();\n+    }\n+    \/\/ Narrow the watermarks if rm spans a narrower range. Update after to\n+    \/\/ ensure non-overlapping words are zeroed out. If rm has the all_stack\n+    \/\/ flag set and is smaller than our high watermark, take care not to\n+    \/\/ incorrectly lower the high watermark according to rm.\n+    if (_lwm < rm._lwm) {\n+      _lwm = rm._lwm;\n+    }\n+    if (_hwm > rm._hwm && !(rm.is_AllStack() && _hwm > rm.rm_max())) {\n+      _hwm = rm._hwm;\n@@ -336,4 +740,2 @@\n-    \/\/ Narrow the watermarks if &rm spans a narrower range.\n-    \/\/ Update after to ensure non-overlapping words are zeroed out.\n-    if (_lwm < rm._lwm) _lwm = rm._lwm;\n-    if (_hwm > rm._hwm) _hwm = rm._hwm;\n+    set_AllStack(is_AllStack() && rm.is_AllStack());\n+    assert(valid_watermarks(), \"sanity\");\n@@ -342,1 +744,1 @@\n-  \/\/ Subtract 'rm' from 'this'\n+  \/\/ Subtract 'rm' from 'this'.\n@@ -344,0 +746,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -345,4 +748,35 @@\n-    unsigned hwm = MIN2(_hwm, rm._hwm);\n-    unsigned lwm = MAX2(_lwm, rm._lwm);\n-    for (unsigned i = lwm; i <= hwm; i++) {\n-      _RM_UP[i] &= ~rm._RM_UP[i];\n+    grow(rm._rm_size);\n+    unsigned int hwm = MIN2(_hwm, rm._hwm);\n+    unsigned int lwm = MAX2(_lwm, rm._lwm);\n+    for (unsigned int i = lwm; i <= hwm; i++) {\n+      rm_up(i) &= ~rm.rm_up(i);\n+    }\n+    \/\/ If rm is smaller than our high watermark and has the all_stack flag set,\n+    \/\/ we need to set all bits in the gap to 0.\n+    if (rm.is_AllStack() && _hwm > rm.rm_max()) {\n+      set_range(rm.rm_size(), 0, _hwm - rm.rm_max());\n+      _hwm = rm.rm_max();\n+    }\n+    set_AllStack(is_AllStack() && !rm.is_AllStack());\n+    trim_watermarks();\n+    assert(valid_watermarks(), \"sanity\");\n+  }\n+\n+  \/\/ Subtract 'rm' from 'this', but ignore everything in 'rm' that does not\n+  \/\/ overlap with us and do not modify our all_stack flag. Supports masks of\n+  \/\/ differing offsets. Does not support 'rm' with the all_stack flag set.\n+  void SUBTRACT_inner(const RegMask& rm) {\n+    assert(valid_watermarks() && rm.valid_watermarks(), \"sanity\");\n+    assert(!rm.is_AllStack(), \"not supported\");\n+    \/\/ Various translations due to differing offsets\n+    int rm_index_diff = _offset - rm._offset;\n+    int rm_hwm_tr = (int)rm._hwm - rm_index_diff;\n+    int rm_lwm_tr = (int)rm._lwm - rm_index_diff;\n+    int rm_rm_max_tr = (int)rm.rm_max() - rm_index_diff;\n+    int rm_rm_size_tr = (int)rm._rm_size - rm_index_diff;\n+    int hwm = MIN2((int)_hwm, rm_hwm_tr);\n+    int lwm = MAX2((int)_lwm, rm_lwm_tr);\n+    for (int i = lwm; i <= hwm; i++) {\n+      assert(i + rm_index_diff < (int)rm._rm_size, \"sanity\");\n+      assert(i + rm_index_diff >= 0, \"sanity\");\n+      rm_up(i) &= ~rm.rm_up(i + rm_index_diff);\n@@ -350,0 +784,16 @@\n+    trim_watermarks();\n+    assert(valid_watermarks(), \"sanity\");\n+  }\n+\n+  \/\/ Roll over the register mask. The main use is to expose a new set of stack\n+  \/\/ slots for the register allocator. Return if the rollover succeeded or not.\n+  bool rollover() {\n+    assert(is_AllStack_only(), \"rolling over non-empty mask\");\n+    if (!OptoRegPair::can_fit((_rm_size + _offset + _rm_size) * BitsPerWord - 1)) {\n+      \/\/ Ensure that register masks cannot roll over beyond the point at which\n+      \/\/ OptoRegPair can no longer index the whole mask.\n+      return false;\n+    }\n+    _offset += _rm_size;\n+    Set_All_From_Offset();\n+    return true;\n@@ -353,1 +803,8 @@\n-  uint Size() const;\n+  uint Size() const {\n+    uint sum = 0;\n+    assert(valid_watermarks(), \"sanity\");\n+    for (unsigned i = _lwm; i <= _hwm; i++) {\n+      sum += population_count(rm_up(i));\n+    }\n+    return sum;\n+  }\n@@ -356,0 +813,44 @@\n+private:\n+  bool dump_end_run(outputStream* st, OptoReg::Name start,\n+                    OptoReg::Name last) const;\n+\n+public:\n+\n+  \/\/ Used to publically expose _RM_SIZE for testing purposes.\n+  unsigned int static basic_rm_size() {\n+    return _RM_SIZE;\n+  }\n+\n+  unsigned int static rm_size_max_bits() {\n+    return _RM_SIZE_MAX * BitsPerWord;\n+  }\n+  bool equals(const RegMask& rm) const {\n+    assert(_offset == rm._offset, \"offset mismatch\");\n+    if (_all_stack != rm._all_stack) {\n+      return false;\n+    }\n+    \/\/ Shared segment\n+    for (unsigned int i = 0; i < MIN2(_rm_size, rm._rm_size); i++) {\n+      if (rm_up(i) != rm.rm_up(i)) {\n+        return false;\n+      }\n+    }\n+    \/\/ If there is a size difference, check the protruding segment against\n+    \/\/ all_stack.\n+    const unsigned int start = MIN2(_rm_size, rm._rm_size);\n+    const uintptr_t value = _all_stack ? uintptr_t(-1) : 0;\n+    for (unsigned int i = start; i < _rm_size; i++) {\n+      if (rm_up(i) != value) {\n+        return false;\n+      }\n+    }\n+    for (unsigned int i = start; i < rm._rm_size; i++) {\n+      if (rm.rm_up(i) != value) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+  void set_offset(unsigned int offset) {\n+    _offset = offset;\n+  }\n@@ -358,0 +859,1 @@\n+  void dump_hex(outputStream* st = tty) const; \/\/ Print a mask (raw hex)\n@@ -363,9 +865,3 @@\n-  static bool can_represent(OptoReg::Name reg, unsigned int size = 1) {\n-    \/\/ NOTE: MAX2(1U,size) in computation reflects the usage of the last\n-    \/\/       bit of the regmask as an infinite stack flag.\n-    return (int)reg < (int)(CHUNK_SIZE - MAX2(1U,size));\n-  }\n-  static bool can_represent_arg(OptoReg::Name reg) {\n-    \/\/ NOTE: SlotsPerVecZ in computation reflects the need\n-    \/\/       to keep mask aligned for largest value (VecZ).\n-    return can_represent(reg, SlotsPerVecZ);\n+  bool can_represent(OptoReg::Name reg, unsigned int size = 1) const {\n+    reg = reg - offset_bits();\n+    return reg >= 0 && reg <= (int)(rm_size_bits() - size);\n@@ -418,1 +914,1 @@\n-      _current_bits = _rm._RM_UP[_next_index++];\n+      _current_bits = _rm.rm_up(_next_index++);\n@@ -426,1 +922,3 @@\n-        _reg = OptoReg::Name(((_next_index - 1) << RegMask::_LogWordBits) + next_bit);\n+        _reg = OptoReg::Name(_rm.offset_bits() +\n+                             ((_next_index - 1) << RegMask::_LogWordBits) +\n+                             next_bit);\n@@ -437,1 +935,1 @@\n-\/\/ Do not use this constant directly in client code!\n+\/\/ Do not use these constants directly in client code!\n@@ -439,0 +937,1 @@\n+#undef RM_SIZE_MIN\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":600,"deletions":101,"binary":false,"changes":701,"status":"modified"},{"patch":"@@ -536,0 +536,1 @@\n+const int max_method_parameter_length = 255; \/\/ JVM spec, 22nd ed. section 4.3.3 (p.83)\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"opto\/chaitin.hpp\"\n@@ -29,1 +30,3 @@\n-\/\/ Sanity tests for RegMask and RegMaskIterator\n+\/\/ Sanity tests for RegMask and RegMaskIterator. The file tests operations on\n+\/\/ combinations of different RegMask versions (\"basic\", i.e. only statically\n+\/\/ allocated and \"extended\", i.e. extended with dynamically allocated memory).\n@@ -35,1 +38,1 @@\n-    ASSERT_TRUE(rm.is_NotEmpty());\n+    ASSERT_TRUE(!rm.is_Empty());\n@@ -37,1 +40,1 @@\n-    ASSERT_TRUE(!rm.is_NotEmpty());\n+    ASSERT_TRUE(rm.is_Empty());\n@@ -82,1 +85,1 @@\n-  \/\/ Check that Set_All doesn't add bits outside of CHUNK_SIZE\n+  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits()\n@@ -85,2 +88,2 @@\n-  ASSERT_TRUE(rm.Size() == RegMask::CHUNK_SIZE);\n-  ASSERT_TRUE(rm.is_NotEmpty());\n+  ASSERT_TRUE(rm.Size() == rm.rm_size_bits());\n+  ASSERT_TRUE(!rm.is_Empty());\n@@ -89,1 +92,1 @@\n-  contains_expected_num_of_registers(rm, RegMask::CHUNK_SIZE);\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits());\n@@ -135,1 +138,1 @@\n-  for (int i = 17; i < RegMask::CHUNK_SIZE; i++) {\n+  for (int i = 17; i < (int)rm1.rm_size_bits(); i++) {\n@@ -138,0 +141,1 @@\n+  rm1.set_AllStack(true);\n@@ -140,1 +144,13 @@\n-  contains_expected_num_of_registers(rm1, RegMask::CHUNK_SIZE - 17);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_bits() - 17);\n+  contains_expected_num_of_registers(rm2, 17);\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  rm2.Set_All();\n+  for (int i = 17; i < (int)rm1.rm_size_bits(); i++) {\n+    rm1.Insert(i);\n+  }\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_bits() - 17);\n@@ -147,1 +163,1 @@\n-  for (int i = 0; i < RegMask::CHUNK_SIZE - 1; i++) {\n+  for (int i = 0; i < (int)rm.rm_size_bits() - 1; i++) {\n@@ -155,1 +171,1 @@\n-  rm.set_AllStack();\n+  rm.set_AllStack(true);\n@@ -162,1 +178,1 @@\n-  for (int i = 0; i < RegMask::CHUNK_SIZE - 2; i++) {\n+  for (int i = 0; i < (int)rm.rm_size_bits() - 2; i++) {\n@@ -173,2 +189,3 @@\n-  rm.Insert(RegMask::CHUNK_SIZE - 2);\n-  rm.Insert(RegMask::CHUNK_SIZE - 1);\n+  rm.Insert(rm.rm_size_bits() - 2);\n+  rm.Insert(rm.rm_size_bits() - 1);\n+  rm.set_AllStack(true);\n@@ -182,1 +199,1 @@\n-    for (int i = 0; i < RegMask::CHUNK_SIZE - size; i++) {\n+    for (int i = 0; i < (int)rm.rm_size_bits() - size; i++) {\n@@ -191,2 +208,2 @@\n-    for (int j = RegMask::CHUNK_SIZE - size; j < RegMask::CHUNK_SIZE; j++) {\n-        rm.Insert(j);\n+    for (int j = rm.rm_size_bits() - size; j < (int)rm.rm_size_bits(); j++) {\n+      rm.Insert(j);\n@@ -194,0 +211,1 @@\n+    rm.set_AllStack(true);\n@@ -197,1 +215,1008 @@\n-}\n\\ No newline at end of file\n+}\n+\n+TEST_VM(RegMask, external_member) {\n+  RegMask rm;\n+  rm.set_AllStack(false);\n+  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+  rm.set_AllStack(true);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+}\n+\n+TEST_VM(RegMask, find_element) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(44));\n+  rm.Insert(OptoReg::Name(30));\n+  rm.Insert(OptoReg::Name(54));\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Name(30));\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Name(54));\n+  rm.set_AllStack(true);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Name(54));\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Bad);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Bad);\n+}\n+\n+TEST_VM(RegMask, find_first_set) {\n+  RegMask rm;\n+  LRG lrg;\n+  lrg._is_scalable = 0;\n+  lrg._is_vector = 0;\n+  ASSERT_EQ(rm.find_first_set(lrg, 2), OptoReg::Bad);\n+  rm.Insert(OptoReg::Name(24));\n+  rm.Insert(OptoReg::Name(25));\n+  rm.Insert(OptoReg::Name(26));\n+  rm.Insert(OptoReg::Name(27));\n+  rm.Insert(OptoReg::Name(16));\n+  rm.Insert(OptoReg::Name(17));\n+  rm.Insert(OptoReg::Name(18));\n+  rm.Insert(OptoReg::Name(19));\n+  ASSERT_EQ(rm.find_first_set(lrg, 4), OptoReg::Name(19));\n+}\n+\n+TEST_VM(RegMask, alignment) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(30));\n+  rm.Insert(OptoReg::Name(31));\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  rm.Insert(OptoReg::Name(32));\n+  rm.Insert(OptoReg::Name(37));\n+  rm.Insert(OptoReg::Name(62));\n+  rm.Insert(OptoReg::Name(71));\n+  rm.Insert(OptoReg::Name(74));\n+  rm.Insert(OptoReg::Name(75));\n+  ASSERT_FALSE(rm.is_aligned_pairs());\n+  rm.clear_to_pairs();\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  ASSERT_TRUE(rm.is_aligned_pairs());\n+  contains_expected_num_of_registers(rm, 4);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(30)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(31)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(74)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(75)));\n+  ASSERT_FALSE(rm.is_misaligned_pair());\n+  rm.Remove(OptoReg::Name(30));\n+  rm.Remove(OptoReg::Name(74));\n+  ASSERT_TRUE(rm.is_misaligned_pair());\n+}\n+\n+TEST_VM(RegMask, clear_to_sets) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(20));\n+  rm.Insert(OptoReg::Name(21));\n+  rm.Insert(OptoReg::Name(22));\n+  rm.Insert(OptoReg::Name(23));\n+  rm.Insert(OptoReg::Name(25));\n+  rm.Insert(OptoReg::Name(26));\n+  rm.Insert(OptoReg::Name(27));\n+  rm.Insert(OptoReg::Name(40));\n+  rm.Insert(OptoReg::Name(42));\n+  rm.Insert(OptoReg::Name(43));\n+  rm.Insert(OptoReg::Name(44));\n+  rm.Insert(OptoReg::Name(45));\n+  rm.clear_to_sets(2);\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  contains_expected_num_of_registers(rm, 10);\n+  rm.clear_to_sets(4);\n+  ASSERT_TRUE(rm.is_aligned_sets(4));\n+  contains_expected_num_of_registers(rm, 4);\n+  rm.clear_to_sets(8);\n+  ASSERT_TRUE(rm.is_aligned_sets(8));\n+  contains_expected_num_of_registers(rm, 0);\n+}\n+\n+TEST_VM(RegMask, smear_to_sets) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(3));\n+  rm.smear_to_sets(2);\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  contains_expected_num_of_registers(rm, 2);\n+  rm.smear_to_sets(4);\n+  ASSERT_TRUE(rm.is_aligned_sets(4));\n+  contains_expected_num_of_registers(rm, 4);\n+  rm.smear_to_sets(8);\n+  ASSERT_TRUE(rm.is_aligned_sets(8));\n+  contains_expected_num_of_registers(rm, 8);\n+  rm.smear_to_sets(16);\n+  ASSERT_TRUE(rm.is_aligned_sets(16));\n+  contains_expected_num_of_registers(rm, 16);\n+}\n+\n+TEST_VM(RegMask, overlap) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(23));\n+  rm1.Insert(OptoReg::Name(2));\n+  rm1.Insert(OptoReg::Name(12));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(4));\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(4));\n+  ASSERT_TRUE(rm1.overlap(rm2));\n+  ASSERT_TRUE(rm2.overlap(rm1));\n+}\n+\n+TEST_VM(RegMask, valid_reg) {\n+  RegMask rm;\n+  ASSERT_FALSE(rm.is_valid_reg(OptoReg::Name(42), 1));\n+  rm.Insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(5));\n+  rm.Insert(OptoReg::Name(6));\n+  rm.Insert(OptoReg::Name(7));\n+  ASSERT_FALSE(rm.is_valid_reg(OptoReg::Name(7), 4));\n+  ASSERT_TRUE(rm.is_valid_reg(OptoReg::Name(7), 2));\n+}\n+\n+TEST_VM(RegMask, rollover_and_insert_remove) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  OptoReg::Name reg2(rm.rm_size_bits() * 2 + 42);\n+  rm.set_AllStack(true);\n+  ASSERT_TRUE(rm.Member(reg1));\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg1);\n+  ASSERT_TRUE(rm.Member(reg1));\n+  rm.Remove(reg1);\n+  ASSERT_FALSE(rm.Member(reg1));\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg2);\n+  ASSERT_FALSE(rm.Member(reg1));\n+  ASSERT_TRUE(rm.Member(reg2));\n+}\n+\n+TEST_VM(RegMask, rollover_and_find) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  OptoReg::Name reg2(rm.rm_size_bits() + 7);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Bad);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Bad);\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  ASSERT_EQ(rm.find_first_elem(), reg2);\n+  ASSERT_EQ(rm.find_last_elem(), reg1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_find_first_set) {\n+  LRG lrg;\n+  lrg._is_scalable = 0;\n+  lrg._is_vector = 0;\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 24);\n+  OptoReg::Name reg2(rm.rm_size_bits() + 25);\n+  OptoReg::Name reg3(rm.rm_size_bits() + 26);\n+  OptoReg::Name reg4(rm.rm_size_bits() + 27);\n+  OptoReg::Name reg5(rm.rm_size_bits() + 16);\n+  OptoReg::Name reg6(rm.rm_size_bits() + 17);\n+  OptoReg::Name reg7(rm.rm_size_bits() + 18);\n+  OptoReg::Name reg8(rm.rm_size_bits() + 19);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_set(lrg, 2), OptoReg::Bad);\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  rm.Insert(reg3);\n+  rm.Insert(reg4);\n+  rm.Insert(reg5);\n+  rm.Insert(reg6);\n+  rm.Insert(reg7);\n+  rm.Insert(reg8);\n+  ASSERT_EQ(rm.find_first_set(lrg, 4), reg8);\n+}\n+\n+TEST_VM(RegMask, rollover_and_Set_All_From) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Set_All_From(reg1);\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits() - 42);\n+}\n+\n+TEST_VM(RegMask, rollover_and_Set_All_From_Offset) {\n+  RegMask rm;\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Set_All_From_Offset();\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits());\n+}\n+\n+TEST_VM(RegMask, rollover_and_iterate) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 2);\n+  OptoReg::Name reg2(rm.rm_size_bits() + 6);\n+  OptoReg::Name reg3(rm.rm_size_bits() + 17);\n+  OptoReg::Name reg4(rm.rm_size_bits() + 43);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  rm.Insert(reg3);\n+  rm.Insert(reg4);\n+  RegMaskIterator rmi(rm);\n+  ASSERT_EQ(rmi.next(), reg1);\n+  ASSERT_EQ(rmi.next(), reg2);\n+  ASSERT_EQ(rmi.next(), reg3);\n+  ASSERT_EQ(rmi.next(), reg4);\n+  ASSERT_FALSE(rmi.has_next());\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  rm1.set_AllStack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(42);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  rm1.set_AllStack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm2.set_AllStack(true);\n+  rm2.rollover();\n+  rm2.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(reg1);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm1.Insert(reg1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+#ifndef PRODUCT\n+\n+Arena* arena() {\n+  return Thread::current()->resource_area();\n+}\n+\n+static void is_basic(const RegMask& rm) {\n+  ASSERT_EQ(rm.rm_size(), RegMask::basic_rm_size());\n+}\n+\n+static void is_extended(const RegMask& rm) {\n+  ASSERT_TRUE(rm.rm_size() > RegMask::basic_rm_size());\n+}\n+\n+static int first_extended() {\n+  return RegMask::basic_rm_size() * BitsPerWord;\n+}\n+\n+static void extend(RegMask& rm, unsigned int n = 4) {\n+  \/\/ Extend the given RegMask with at least n dynamically-allocated words.\n+  rm.Insert(OptoReg::Name(first_extended() + (BitsPerWord * n) - 1));\n+  rm.Clear();\n+  ASSERT_TRUE(rm.rm_size() >= RegMask::basic_rm_size() + n);\n+}\n+\n+TEST_VM(RegMask, static_by_default) {\n+  \/\/ Check that a freshly created RegMask does not allocate dynamic memory.\n+  RegMask rm;\n+  is_basic(rm);\n+}\n+\n+TEST_VM(RegMask, iteration_extended) {\n+  RegMask rm(arena());\n+  rm.Insert(30);\n+  rm.Insert(31);\n+  rm.Insert(33);\n+  rm.Insert(62);\n+  rm.Insert(first_extended());\n+  rm.Insert(first_extended() + 42);\n+  rm.Insert(first_extended() + 55);\n+  rm.Insert(first_extended() + 456);\n+\n+  RegMaskIterator rmi(rm);\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(30));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(31));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(33));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(62));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended()));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 42));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 55));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 456));\n+  ASSERT_FALSE(rmi.has_next());\n+}\n+\n+TEST_VM(RegMask, Set_ALL_extended) {\n+  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits() on\n+  \/\/ extended RegMasks.\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.Set_All();\n+  ASSERT_EQ(rm.Size(), rm.rm_size_bits());\n+  ASSERT_TRUE(!rm.is_Empty());\n+  \/\/ Set_All sets AllStack bit\n+  ASSERT_TRUE(rm.is_AllStack());\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits());\n+}\n+\n+TEST_VM(RegMask, Set_ALL_From_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.Set_All_From(OptoReg::Name(42));\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits() - 42);\n+}\n+\n+TEST_VM(RegMask, Set_ALL_From_extended_grow) {\n+  RegMask rm(arena());\n+  rm.Set_All_From(first_extended() + OptoReg::Name(42));\n+  is_extended(rm);\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits() - first_extended() - 42);\n+}\n+\n+TEST_VM(RegMask, Clear_extended) {\n+  \/\/ Check that Clear doesn't leave any stray bits on extended RegMasks.\n+  RegMask rm(arena());\n+  rm.Insert(first_extended());\n+  is_extended(rm);\n+  rm.Set_All();\n+  rm.Clear();\n+  contains_expected_num_of_registers(rm, 0);\n+}\n+\n+TEST_VM(RegMask, AND_extended_basic) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.AND(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2;\n+  is_basic(rm2);\n+  rm1.AND(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, AND_extended_extended) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.AND(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  rm1.AND(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, OR_extended_basic) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.OR(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2;\n+  is_basic(rm2);\n+  rm1.OR(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, OR_extended_extended) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.OR(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  rm1.OR(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_extended) {\n+  RegMask rm1(arena());\n+  extend(rm1);\n+  RegMask rm2(arena());\n+  extend(rm2);\n+\n+  rm2.Set_All();\n+  ASSERT_TRUE(rm2.is_AllStack());\n+  for (int i = first_extended() + 17; i < (int)rm1.rm_size_bits(); i++) {\n+    rm1.Insert(i);\n+  }\n+  rm1.set_AllStack(true);\n+  ASSERT_TRUE(rm1.is_AllStack());\n+  rm2.SUBTRACT(rm1);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_bits() - first_extended() - 17);\n+  contains_expected_num_of_registers(rm2, first_extended() + 17);\n+}\n+\n+TEST_VM(RegMask, external_member_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.set_AllStack(false);\n+  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+  rm.set_AllStack(true);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+}\n+\n+TEST_VM(RegMask, overlap_extended) {\n+  RegMask rm1(arena());\n+  extend(rm1);\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(23));\n+  rm1.Insert(OptoReg::Name(2));\n+  rm1.Insert(OptoReg::Name(first_extended() + 12));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(first_extended() + 4));\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(first_extended() + 4));\n+  ASSERT_TRUE(rm1.overlap(rm2));\n+  ASSERT_TRUE(rm2.overlap(rm1));\n+}\n+\n+TEST_VM(RegMask, up_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  ASSERT_TRUE(rm.is_UP());\n+  rm.Insert(OptoReg::Name(1));\n+  ASSERT_TRUE(rm.is_UP());\n+  rm.Insert(OptoReg::Name(first_extended()));\n+  ASSERT_FALSE(rm.is_UP());\n+  rm.Clear();\n+  rm.set_AllStack(true);\n+  ASSERT_FALSE(rm.is_UP());\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner_basic_extended) {\n+  RegMask rm1;\n+  RegMask rm2(arena());\n+  rm1.Insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(42));\n+  is_basic(rm1);\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(first_extended() + 20));\n+  is_extended(rm2);\n+  rm1.SUBTRACT_inner(rm2);\n+  is_basic(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner_extended_basic) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  rm1.Insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(42));\n+  rm1.Insert(OptoReg::Name(first_extended() + 20));\n+  is_extended(rm1);\n+  rm2.Insert(OptoReg::Name(1));\n+  is_basic(rm2);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 2);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended() + 20)));\n+}\n+\n+TEST_VM(RegMask, rollover_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  is_extended(rm);\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Insert(reg1);\n+  ASSERT_TRUE(rm.Member(reg1));\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint_extended) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  extend(rm1);\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  rm1.set_AllStack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(42);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap_extended) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  extend(rm1);\n+  rm2.set_AllStack(true);\n+  rm2.rollover();\n+  rm2.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(reg1);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm1.Insert(reg1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+const uint iterations = 50000;\n+\n+static uint r;\n+static uint next_random() {\n+  r = os::next_random(r);\n+  return r;\n+}\n+static void init_random() {\n+  if (StressSeed == 0) {\n+    r = static_cast<uint>(Ticks::now().nanoseconds());\n+    tty->print_cr(\"seed: %u\", r);\n+  } else {\n+    r = StressSeed;\n+  }\n+}\n+\n+static void print(const char* name, const RegMask& mask) {\n+  tty->print(\"%s: \", name);\n+  mask.print();\n+  tty->print_cr(\", size: %u, offset: %u, all_stack: %u\", mask.rm_size_bits(),\n+                mask.offset_bits(), mask.is_AllStack());\n+}\n+\n+static void assert_equivalent(const RegMask& mask,\n+                              const ResourceBitMap& mask_ref,\n+                              bool all_stack_ref) {\n+  ASSERT_EQ(mask_ref.count_one_bits(), mask.Size());\n+  RegMaskIterator it(mask);\n+  OptoReg::Name reg = OptoReg::Bad;\n+  while (it.has_next()) {\n+    reg = it.next();\n+    ASSERT_TRUE(OptoReg::is_valid(reg));\n+    ASSERT_TRUE(mask_ref.at(reg));\n+  }\n+  ASSERT_EQ(all_stack_ref, mask.is_AllStack());\n+}\n+\n+static void populate_auxiliary_sets(RegMask& mask_aux,\n+                                    ResourceBitMap& mask_aux_ref,\n+                                    uint reg_capacity, uint offset,\n+                                    bool random_offset) {\n+  mask_aux.Clear();\n+  mask_aux_ref.clear();\n+  if (random_offset) {\n+    uint offset_in_words = offset \/ BitsPerWord;\n+    uint capacity_in_words = reg_capacity \/ BitsPerWord;\n+    uint new_offset_in_words;\n+    uint offset_target = next_random() % 3;\n+    switch (offset_target) {\n+    case 0: \/\/ before\n+      if (offset_in_words == 0) {\n+        new_offset_in_words = 0;\n+      } else {\n+        new_offset_in_words = next_random() % offset_in_words;\n+      }\n+      break;\n+    case 1: \/\/ within\n+      new_offset_in_words =\n+          (next_random() % capacity_in_words) + offset_in_words;\n+      break;\n+    case 2: \/\/ after\n+      new_offset_in_words = offset_in_words + capacity_in_words +\n+                            (next_random() % (capacity_in_words));\n+      break;\n+    default:\n+      FAIL();\n+    }\n+    offset = new_offset_in_words * BitsPerWord;\n+    if (offset + RegMask::rm_size_max_bits() > mask_aux_ref.size()) {\n+      \/\/ Ensure that there is space in the reference mask.\n+      offset = 0;\n+    }\n+  }\n+  mask_aux.set_offset(offset \/ BitsPerWord);\n+  assert_equivalent(mask_aux, mask_aux_ref, false);\n+  uint max_size;\n+  uint size_target = next_random() % 3;\n+  switch (size_target) {\n+  case 0: \/\/ smaller\n+    max_size = reg_capacity \/ 2;\n+    break;\n+  case 1: \/\/ equal\n+    max_size = reg_capacity;\n+    break;\n+  case 2: \/\/ larger (if possible)\n+    max_size = RegMask::rm_size_max_bits();\n+    break;\n+  default:\n+    FAIL();\n+  }\n+  uint regs;\n+  uint regs_target = next_random() % 3;\n+  switch (regs_target) {\n+  case 0: \/\/ sparse\n+    regs = next_random() % 8;\n+    break;\n+  case 1: \/\/ medium\n+    regs = next_random() % (max_size \/ 8);\n+    break;\n+  case 2: \/\/ dense\n+    regs = next_random() % max_size;\n+    break;\n+  default:\n+    FAIL();\n+  }\n+  for (uint i = 0; i < regs; i++) {\n+    uint reg = (next_random() % max_size) + offset;\n+    mask_aux.Insert(reg);\n+    mask_aux_ref.set_bit(reg);\n+  }\n+  mask_aux.set_AllStack(next_random() % 2);\n+  assert_equivalent(mask_aux, mask_aux_ref, mask_aux.is_AllStack());\n+\n+  if (Verbose) {\n+    print(\"mask_aux\", mask_aux);\n+  }\n+}\n+\n+static void stack_extend_ref_masks(ResourceBitMap& mask1, bool all_stack1,\n+                                   uint size_bits1, uint offset1,\n+                                   ResourceBitMap& mask2, bool all_stack2,\n+                                   uint size_bits2, uint offset2) {\n+  uint size_bits_after = MAX2(size_bits1, size_bits2);\n+  if (all_stack1) {\n+    mask1.set_range(size_bits1 + offset1, size_bits_after + offset1);\n+  }\n+  if (all_stack2) {\n+    mask2.set_range(size_bits2 + offset2, size_bits_after + offset2);\n+  }\n+}\n+\n+TEST_VM(RegMask, random) {\n+  ResourceMark rm;\n+  RegMask mask(arena());\n+  ResourceBitMap mask_ref(std::numeric_limits<short>::max() + 1);\n+  bool all_stack_ref = false;\n+  uint offset_ref = 0;\n+  init_random();\n+\n+  for (uint i = 0; i < iterations; i++) {\n+    if (Verbose) {\n+      print(\"mask    \", mask);\n+      tty->print(\"%u. \", i);\n+    }\n+    uint action = next_random() % 13;\n+    uint reg;\n+    uint size_bits_before = mask.rm_size_bits();\n+    \/\/ This copy is used for stack-extension in overlap.\n+    ResourceBitMap mask_ref_copy(std::numeric_limits<short>::max() + 1);\n+    mask_ref_copy.clear();\n+    mask_ref.iterate([&](BitMap::idx_t index) {\n+      mask_ref_copy.set_bit(index);\n+      return true;\n+    });\n+    ResourceBitMap mask_aux_ref(std::numeric_limits<short>::max() + 1);\n+    RegMask mask_aux(arena());\n+    switch (action) {\n+    case 0:\n+      reg = (next_random() % RegMask::rm_size_max_bits()) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Insert\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Insert(reg);\n+      mask_ref.set_bit(reg);\n+      if (mask.is_AllStack() && reg >= size_bits_before) {\n+        \/\/ Stack-extend reference bitset.\n+        mask_ref.set_range(size_bits_before + offset_ref,\n+                           mask.rm_size_bits() + offset_ref);\n+      }\n+      break;\n+    case 1:\n+      reg = (next_random() % size_bits_before) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Remove\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Remove(reg);\n+      mask_ref.clear_bit(reg);\n+      break;\n+    case 2:\n+      if (Verbose) {\n+        tty->print_cr(\"action: Clear\");\n+      }\n+      mask.Clear();\n+      mask_ref.clear();\n+      all_stack_ref = false;\n+      break;\n+    case 3:\n+      if (offset_ref > 0) {\n+        \/\/ Set_All expects a zero-offset.\n+        break;\n+      }\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All\");\n+      }\n+      mask.Set_All();\n+      mask_ref.set_range(0, size_bits_before);\n+      all_stack_ref = true;\n+      break;\n+    case 4:\n+      if (Verbose) {\n+        tty->print_cr(\"action: AND\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.AND(mask_aux);\n+      stack_extend_ref_masks(mask_ref, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      mask_ref.set_intersection(mask_aux_ref);\n+      all_stack_ref = all_stack_ref && mask_aux.is_AllStack();\n+      break;\n+    case 5:\n+      if (Verbose) {\n+        tty->print_cr(\"action: OR\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.OR(mask_aux);\n+      stack_extend_ref_masks(mask_ref, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      mask_ref.set_union(mask_aux_ref);\n+      all_stack_ref = all_stack_ref || mask_aux.is_AllStack();\n+      break;\n+    case 6:\n+      if (Verbose) {\n+        tty->print_cr(\"action: SUBTRACT\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.SUBTRACT(mask_aux);\n+      stack_extend_ref_masks(mask_ref, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      mask_ref.set_difference(mask_aux_ref);\n+      if (mask_aux.is_AllStack()) {\n+        all_stack_ref = false;\n+      }\n+      break;\n+    case 7:\n+      if (Verbose) {\n+        tty->print_cr(\"action: SUBTRACT_inner\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ true);\n+      \/\/ SUBTRACT_inner expects an argument register mask with all_stack =\n+      \/\/ false.\n+      mask_aux.set_AllStack(false);\n+      mask.SUBTRACT_inner(mask_aux);\n+      \/\/ SUBTRACT_inner does not have \"stack-extension semantics\".\n+      mask_ref.set_difference(mask_aux_ref);\n+      break;\n+    case 8:\n+      if (Verbose) {\n+        tty->print_cr(\"action: overlap\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      \/\/ Stack-extend a copy of mask_ref to avoid mutating the original.\n+      stack_extend_ref_masks(mask_ref_copy, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      ASSERT_EQ(mask_ref_copy.intersects(mask_aux_ref) ||\n+                    (all_stack_ref && mask_aux.is_AllStack()),\n+                mask.overlap(mask_aux));\n+      break;\n+    case 9:\n+      if (Verbose) {\n+        tty->print_cr(\"action: rollover\");\n+      }\n+      \/\/ rollover expects the mask to be cleared and with all_stack = true\n+      mask.Clear();\n+      mask.set_AllStack(true);\n+      mask_ref.clear();\n+      all_stack_ref = true;\n+      if (mask.rollover()) {\n+        offset_ref += size_bits_before;\n+        mask_ref.set_range(offset_ref, offset_ref + size_bits_before);\n+      }\n+      break;\n+    case 10:\n+      if (Verbose) {\n+        tty->print_cr(\"action: reset\");\n+      }\n+      mask.set_offset(0);\n+      mask.Clear();\n+      mask_ref.clear();\n+      all_stack_ref = false;\n+      offset_ref = 0;\n+      break;\n+    case 11:\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All_From_Offset\");\n+      }\n+      mask.Set_All_From_Offset();\n+      mask_ref.set_range(offset_ref, offset_ref + size_bits_before);\n+      all_stack_ref = true;\n+      break;\n+    case 12:\n+      reg = (next_random() % size_bits_before) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All_From\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Set_All_From(reg);\n+      mask_ref.set_range(reg, offset_ref + size_bits_before);\n+      all_stack_ref = true;\n+      break;\n+    default:\n+      FAIL() << \"Unimplemented action\";\n+    }\n+    ASSERT_NO_FATAL_FAILURE(assert_equivalent(mask, mask_ref, all_stack_ref));\n+  }\n+}\n+\n+\/\/ Randomly sets register mask contents. Does not change register mask size.\n+static void randomize(RegMask& rm) {\n+  rm.Clear();\n+  \/\/ Uniform distribution over number of registers.\n+  uint regs = next_random() % (rm.rm_size_bits() + 1);\n+  for (uint i = 0; i < regs; i++) {\n+    uint reg = (next_random() % rm.rm_size_bits()) + rm.offset_bits();\n+    rm.Insert(reg);\n+  }\n+  rm.set_AllStack(next_random() % 2);\n+}\n+\n+static uint grow_randomly(RegMask& rm, uint min_growth = 1,\n+                          uint max_growth = 3) {\n+  \/\/ Grow between min_growth and max_growth times.\n+  uint grow = min_growth + (max_growth > 0 ? next_random() % max_growth : 0);\n+  for (uint i = 0; i < grow; ++i) {\n+    uint reg = rm.rm_size_bits();\n+    if (reg >= RegMask::rm_size_max_bits()) {\n+      \/\/ Cannot grow more\n+      break;\n+    }\n+    \/\/ Force grow\n+    rm.Insert(reg);\n+    if (!rm.is_AllStack()) {\n+      \/\/ Restore\n+      rm.Remove(reg);\n+    }\n+  }\n+  \/\/ Return how many times we grew\n+  return grow;\n+}\n+\n+TEST_VM(RegMask, random_copy) {\n+  init_random();\n+\n+  auto print_failure = [&](const RegMask& src, const RegMask& dst) {\n+    tty->print_cr(\"Failure, src and dst not equal\");\n+    tty->print(\"src: \");\n+    src.dump_hex();\n+    tty->cr();\n+    tty->print(\"dst: \");\n+    dst.dump_hex();\n+    tty->cr();\n+  };\n+\n+  \/\/ Test copying a larger register mask\n+  for (uint i = 0; i < iterations; i++) {\n+    ResourceMark rm;\n+\n+    \/\/ Create source RegMask\n+    RegMask src(arena());\n+\n+    \/\/ Grow source randomly\n+    grow_randomly(src);\n+\n+    \/\/ Randomly initialize source\n+    randomize(src);\n+\n+    \/\/ Copy construct source to destination\n+    RegMask dst(src, arena());\n+\n+    \/\/ Check equality\n+    bool passed = src.equals(dst);\n+    if (Verbose && !passed) {\n+      print_failure(src, dst);\n+    }\n+    ASSERT_TRUE(passed);\n+  }\n+\n+  \/\/ Test copying a smaller register mask\n+  for (uint i = 0; i < iterations; i++) {\n+    ResourceMark rm;\n+\n+    \/\/ Create destination RegMask\n+    RegMask dst(arena());\n+\n+    \/\/ Grow destination arbitrarily (1-3 times)\n+    uint growth = grow_randomly(dst, 1, 3);\n+\n+    \/\/ Create source RegMask\n+    RegMask src(arena());\n+\n+    \/\/ Grow source arbitrarily, but not as much as destination\n+    grow_randomly(src, 0, growth - 1);\n+\n+    \/\/ Randomly initialize source\n+    randomize(src);\n+\n+    \/\/ Copy source to destination\n+    dst = src;\n+\n+    \/\/ Check equality\n+    bool passed = src.equals(dst);\n+    if (Verbose && !passed) {\n+      print_failure(src, dst);\n+    }\n+    ASSERT_TRUE(passed);\n+  }\n+}\n+\n+#endif \/\/ !PRODUCT\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":1043,"deletions":18,"binary":false,"changes":1061,"status":"modified"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325467\n+ * @requires vm.opt.DeoptimizeALot == null | vm.opt.DeoptimizeALot == false\n+ * @summary Ensure C2 can compile methods with the maximum number of parameters\n+ *          (according to the JVM spec).\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.arguments.TestMaxMethodArguments::test\n+ *                   -Xcomp\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AbortVMOnCompilationFailure\n+ *                   compiler.arguments.TestMaxMethodArguments\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325467\n+ * @summary Same test as above but do not enforce that compilation succeeds\n+ *          (first run) or that the test method is compiled at all (second\n+ *          run).\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.arguments.TestMaxMethodArguments::test\n+ *                   -Xcomp compiler.arguments.TestMaxMethodArguments\n+ * @run main compiler.arguments.TestMaxMethodArguments\n+ *\/\n+\n+package compiler.arguments;\n+\n+public class TestMaxMethodArguments {\n+\n+    static class TestException extends Exception {}\n+\n+    public static void main(String[] args) {\n+        try {\n+            test(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255);\n+        } catch (TestException e) {\n+            \/\/ Fine\n+        }\n+    }\n+\n+    public static int test(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8, int x9, int x10, int x11, int x12, int x13, int x14, int x15, int x16, int x17, int x18, int x19, int x20, int x21, int x22, int x23, int x24, int x25, int x26, int x27, int x28, int x29, int x30, int x31, int x32, int x33, int x34, int x35, int x36, int x37, int x38, int x39, int x40, int x41, int x42, int x43, int x44, int x45, int x46, int x47, int x48, int x49, int x50, int x51, int x52, int x53, int x54, int x55, int x56, int x57, int x58, int x59, int x60, int x61, int x62, int x63, int x64, int x65, int x66, int x67, int x68, int x69, int x70, int x71, int x72, int x73, int x74, int x75, int x76, int x77, int x78, int x79, int x80, int x81, int x82, int x83, int x84, int x85, int x86, int x87, int x88, int x89, int x90, int x91, int x92, int x93, int x94, int x95, int x96, int x97, int x98, int x99, int x100, int x101, int x102, int x103, int x104, int x105, int x106, int x107, int x108, int x109, int x110, int x111, int x112, int x113, int x114, int x115, int x116, int x117, int x118, int x119, int x120, int x121, int x122, int x123, int x124, int x125, int x126, int x127, int x128, int x129, int x130, int x131, int x132, int x133, int x134, int x135, int x136, int x137, int x138, int x139, int x140, int x141, int x142, int x143, int x144, int x145, int x146, int x147, int x148, int x149, int x150, int x151, int x152, int x153, int x154, int x155, int x156, int x157, int x158, int x159, int x160, int x161, int x162, int x163, int x164, int x165, int x166, int x167, int x168, int x169, int x170, int x171, int x172, int x173, int x174, int x175, int x176, int x177, int x178, int x179, int x180, int x181, int x182, int x183, int x184, int x185, int x186, int x187, int x188, int x189, int x190, int x191, int x192, int x193, int x194, int x195, int x196, int x197, int x198, int x199, int x200, int x201, int x202, int x203, int x204, int x205, int x206, int x207, int x208, int x209, int x210, int x211, int x212, int x213, int x214, int x215, int x216, int x217, int x218, int x219, int x220, int x221, int x222, int x223, int x224, int x225, int x226, int x227, int x228, int x229, int x230, int x231, int x232, int x233, int x234, int x235, int x236, int x237, int x238, int x239, int x240, int x241, int x242, int x243, int x244, int x245, int x246, int x247, int x248, int x249, int x250, int x251, int x252, int x253, int x254, int x255) throws TestException {\n+        \/\/ Exceptions after every definition of a temporary forces the\n+        \/\/ evaluation order.\n+        int t1 = x1 % 101; if(t1 == 0) { throw new TestException(); }\n+        int t2 = x2 % 102; if(t2 == 0) { throw new TestException(); }\n+        int t3 = x3 % 103; if(t3 == 0) { throw new TestException(); }\n+        int t4 = x4 % 104; if(t4 == 0) { throw new TestException(); }\n+        int t5 = x5 % 105; if(t5 == 0) { throw new TestException(); }\n+        int t6 = x6 % 106; if(t6 == 0) { throw new TestException(); }\n+        int t7 = x7 % 107; if(t7 == 0) { throw new TestException(); }\n+        int t8 = x8 % 108; if(t8 == 0) { throw new TestException(); }\n+        int t9 = x9 % 109; if(t9 == 0) { throw new TestException(); }\n+        int t10 = x10 % 110; if(t10 == 0) { throw new TestException(); }\n+        int t11 = x11 % 111; if(t11 == 0) { throw new TestException(); }\n+        int t12 = x12 % 112; if(t12 == 0) { throw new TestException(); }\n+        int t13 = x13 % 113; if(t13 == 0) { throw new TestException(); }\n+        int t14 = x14 % 114; if(t14 == 0) { throw new TestException(); }\n+        int t15 = x15 % 115; if(t15 == 0) { throw new TestException(); }\n+        int t16 = x16 % 116; if(t16 == 0) { throw new TestException(); }\n+        int t17 = x17 % 117; if(t17 == 0) { throw new TestException(); }\n+        int t18 = x18 % 118; if(t18 == 0) { throw new TestException(); }\n+        int t19 = x19 % 119; if(t19 == 0) { throw new TestException(); }\n+        int t20 = x20 % 120; if(t20 == 0) { throw new TestException(); }\n+        int t21 = x21 % 121; if(t21 == 0) { throw new TestException(); }\n+        int t22 = x22 % 122; if(t22 == 0) { throw new TestException(); }\n+        int t23 = x23 % 123; if(t23 == 0) { throw new TestException(); }\n+        int t24 = x24 % 124; if(t24 == 0) { throw new TestException(); }\n+        int t25 = x25 % 125; if(t25 == 0) { throw new TestException(); }\n+        int t26 = x26 % 126; if(t26 == 0) { throw new TestException(); }\n+        int t27 = x27 % 127; if(t27 == 0) { throw new TestException(); }\n+        int t28 = x28 % 128; if(t28 == 0) { throw new TestException(); }\n+        int t29 = x29 % 129; if(t29 == 0) { throw new TestException(); }\n+        int t30 = x30 % 130; if(t30 == 0) { throw new TestException(); }\n+        int t31 = x31 % 131; if(t31 == 0) { throw new TestException(); }\n+        int t32 = x32 % 132; if(t32 == 0) { throw new TestException(); }\n+        int t33 = x33 % 133; if(t33 == 0) { throw new TestException(); }\n+        int t34 = x34 % 134; if(t34 == 0) { throw new TestException(); }\n+        int t35 = x35 % 135; if(t35 == 0) { throw new TestException(); }\n+        int t36 = x36 % 136; if(t36 == 0) { throw new TestException(); }\n+        int t37 = x37 % 137; if(t37 == 0) { throw new TestException(); }\n+        int t38 = x38 % 138; if(t38 == 0) { throw new TestException(); }\n+        int t39 = x39 % 139; if(t39 == 0) { throw new TestException(); }\n+        int t40 = x40 % 140; if(t40 == 0) { throw new TestException(); }\n+        int t41 = x41 % 141; if(t41 == 0) { throw new TestException(); }\n+        int t42 = x42 % 142; if(t42 == 0) { throw new TestException(); }\n+        int t43 = x43 % 143; if(t43 == 0) { throw new TestException(); }\n+        int t44 = x44 % 144; if(t44 == 0) { throw new TestException(); }\n+        int t45 = x45 % 145; if(t45 == 0) { throw new TestException(); }\n+        int t46 = x46 % 146; if(t46 == 0) { throw new TestException(); }\n+        int t47 = x47 % 147; if(t47 == 0) { throw new TestException(); }\n+        int t48 = x48 % 148; if(t48 == 0) { throw new TestException(); }\n+        int t49 = x49 % 149; if(t49 == 0) { throw new TestException(); }\n+        int t50 = x50 % 150; if(t50 == 0) { throw new TestException(); }\n+        int t51 = x51 % 151; if(t51 == 0) { throw new TestException(); }\n+        int t52 = x52 % 152; if(t52 == 0) { throw new TestException(); }\n+        int t53 = x53 % 153; if(t53 == 0) { throw new TestException(); }\n+        int t54 = x54 % 154; if(t54 == 0) { throw new TestException(); }\n+        int t55 = x55 % 155; if(t55 == 0) { throw new TestException(); }\n+        int t56 = x56 % 156; if(t56 == 0) { throw new TestException(); }\n+        int t57 = x57 % 157; if(t57 == 0) { throw new TestException(); }\n+        int t58 = x58 % 158; if(t58 == 0) { throw new TestException(); }\n+        int t59 = x59 % 159; if(t59 == 0) { throw new TestException(); }\n+        int t60 = x60 % 160; if(t60 == 0) { throw new TestException(); }\n+        int t61 = x61 % 161; if(t61 == 0) { throw new TestException(); }\n+        int t62 = x62 % 162; if(t62 == 0) { throw new TestException(); }\n+        int t63 = x63 % 163; if(t63 == 0) { throw new TestException(); }\n+        int t64 = x64 % 164; if(t64 == 0) { throw new TestException(); }\n+        int t65 = x65 % 165; if(t65 == 0) { throw new TestException(); }\n+        int t66 = x66 % 166; if(t66 == 0) { throw new TestException(); }\n+        int t67 = x67 % 167; if(t67 == 0) { throw new TestException(); }\n+        int t68 = x68 % 168; if(t68 == 0) { throw new TestException(); }\n+        int t69 = x69 % 169; if(t69 == 0) { throw new TestException(); }\n+        int t70 = x70 % 170; if(t70 == 0) { throw new TestException(); }\n+        int t71 = x71 % 171; if(t71 == 0) { throw new TestException(); }\n+        int t72 = x72 % 172; if(t72 == 0) { throw new TestException(); }\n+        int t73 = x73 % 173; if(t73 == 0) { throw new TestException(); }\n+        int t74 = x74 % 174; if(t74 == 0) { throw new TestException(); }\n+        int t75 = x75 % 175; if(t75 == 0) { throw new TestException(); }\n+        int t76 = x76 % 176; if(t76 == 0) { throw new TestException(); }\n+        int t77 = x77 % 177; if(t77 == 0) { throw new TestException(); }\n+        int t78 = x78 % 178; if(t78 == 0) { throw new TestException(); }\n+        int t79 = x79 % 179; if(t79 == 0) { throw new TestException(); }\n+        int t80 = x80 % 180; if(t80 == 0) { throw new TestException(); }\n+        int t81 = x81 % 181; if(t81 == 0) { throw new TestException(); }\n+        int t82 = x82 % 182; if(t82 == 0) { throw new TestException(); }\n+        int t83 = x83 % 183; if(t83 == 0) { throw new TestException(); }\n+        int t84 = x84 % 184; if(t84 == 0) { throw new TestException(); }\n+        int t85 = x85 % 185; if(t85 == 0) { throw new TestException(); }\n+        int t86 = x86 % 186; if(t86 == 0) { throw new TestException(); }\n+        int t87 = x87 % 187; if(t87 == 0) { throw new TestException(); }\n+        int t88 = x88 % 188; if(t88 == 0) { throw new TestException(); }\n+        int t89 = x89 % 189; if(t89 == 0) { throw new TestException(); }\n+        int t90 = x90 % 190; if(t90 == 0) { throw new TestException(); }\n+        int t91 = x91 % 191; if(t91 == 0) { throw new TestException(); }\n+        int t92 = x92 % 192; if(t92 == 0) { throw new TestException(); }\n+        int t93 = x93 % 193; if(t93 == 0) { throw new TestException(); }\n+        int t94 = x94 % 194; if(t94 == 0) { throw new TestException(); }\n+        int t95 = x95 % 195; if(t95 == 0) { throw new TestException(); }\n+        int t96 = x96 % 196; if(t96 == 0) { throw new TestException(); }\n+        int t97 = x97 % 197; if(t97 == 0) { throw new TestException(); }\n+        int t98 = x98 % 198; if(t98 == 0) { throw new TestException(); }\n+        int t99 = x99 % 199; if(t99 == 0) { throw new TestException(); }\n+        int t100 = x100 % 200; if(t100 == 0) { throw new TestException(); }\n+        int t101 = x101 % 201; if(t101 == 0) { throw new TestException(); }\n+        int t102 = x102 % 202; if(t102 == 0) { throw new TestException(); }\n+        int t103 = x103 % 203; if(t103 == 0) { throw new TestException(); }\n+        int t104 = x104 % 204; if(t104 == 0) { throw new TestException(); }\n+        int t105 = x105 % 205; if(t105 == 0) { throw new TestException(); }\n+        int t106 = x106 % 206; if(t106 == 0) { throw new TestException(); }\n+        int t107 = x107 % 207; if(t107 == 0) { throw new TestException(); }\n+        int t108 = x108 % 208; if(t108 == 0) { throw new TestException(); }\n+        int t109 = x109 % 209; if(t109 == 0) { throw new TestException(); }\n+        int t110 = x110 % 210; if(t110 == 0) { throw new TestException(); }\n+        int t111 = x111 % 211; if(t111 == 0) { throw new TestException(); }\n+        int t112 = x112 % 212; if(t112 == 0) { throw new TestException(); }\n+        int t113 = x113 % 213; if(t113 == 0) { throw new TestException(); }\n+        int t114 = x114 % 214; if(t114 == 0) { throw new TestException(); }\n+        int t115 = x115 % 215; if(t115 == 0) { throw new TestException(); }\n+        int t116 = x116 % 216; if(t116 == 0) { throw new TestException(); }\n+        int t117 = x117 % 217; if(t117 == 0) { throw new TestException(); }\n+        int t118 = x118 % 218; if(t118 == 0) { throw new TestException(); }\n+        int t119 = x119 % 219; if(t119 == 0) { throw new TestException(); }\n+        int t120 = x120 % 220; if(t120 == 0) { throw new TestException(); }\n+        int t121 = x121 % 221; if(t121 == 0) { throw new TestException(); }\n+        int t122 = x122 % 222; if(t122 == 0) { throw new TestException(); }\n+        int t123 = x123 % 223; if(t123 == 0) { throw new TestException(); }\n+        int t124 = x124 % 224; if(t124 == 0) { throw new TestException(); }\n+        int t125 = x125 % 225; if(t125 == 0) { throw new TestException(); }\n+        int t126 = x126 % 226; if(t126 == 0) { throw new TestException(); }\n+        int t127 = x127 % 227; if(t127 == 0) { throw new TestException(); }\n+        int t128 = x128 % 228; if(t128 == 0) { throw new TestException(); }\n+        int t129 = x129 % 229; if(t129 == 0) { throw new TestException(); }\n+        int t130 = x130 % 230; if(t130 == 0) { throw new TestException(); }\n+        int t131 = x131 % 231; if(t131 == 0) { throw new TestException(); }\n+        int t132 = x132 % 232; if(t132 == 0) { throw new TestException(); }\n+        int t133 = x133 % 233; if(t133 == 0) { throw new TestException(); }\n+        int t134 = x134 % 234; if(t134 == 0) { throw new TestException(); }\n+        int t135 = x135 % 235; if(t135 == 0) { throw new TestException(); }\n+        int t136 = x136 % 236; if(t136 == 0) { throw new TestException(); }\n+        int t137 = x137 % 237; if(t137 == 0) { throw new TestException(); }\n+        int t138 = x138 % 238; if(t138 == 0) { throw new TestException(); }\n+        int t139 = x139 % 239; if(t139 == 0) { throw new TestException(); }\n+        int t140 = x140 % 240; if(t140 == 0) { throw new TestException(); }\n+        int t141 = x141 % 241; if(t141 == 0) { throw new TestException(); }\n+        int t142 = x142 % 242; if(t142 == 0) { throw new TestException(); }\n+        int t143 = x143 % 243; if(t143 == 0) { throw new TestException(); }\n+        int t144 = x144 % 244; if(t144 == 0) { throw new TestException(); }\n+        int t145 = x145 % 245; if(t145 == 0) { throw new TestException(); }\n+        int t146 = x146 % 246; if(t146 == 0) { throw new TestException(); }\n+        int t147 = x147 % 247; if(t147 == 0) { throw new TestException(); }\n+        int t148 = x148 % 248; if(t148 == 0) { throw new TestException(); }\n+        int t149 = x149 % 249; if(t149 == 0) { throw new TestException(); }\n+        int t150 = x150 % 250; if(t150 == 0) { throw new TestException(); }\n+        int t151 = x151 % 251; if(t151 == 0) { throw new TestException(); }\n+        int t152 = x152 % 252; if(t152 == 0) { throw new TestException(); }\n+        int t153 = x153 % 253; if(t153 == 0) { throw new TestException(); }\n+        int t154 = x154 % 254; if(t154 == 0) { throw new TestException(); }\n+        int t155 = x155 % 255; if(t155 == 0) { throw new TestException(); }\n+        int t156 = x156 % 256; if(t156 == 0) { throw new TestException(); }\n+        int t157 = x157 % 257; if(t157 == 0) { throw new TestException(); }\n+        int t158 = x158 % 258; if(t158 == 0) { throw new TestException(); }\n+        int t159 = x159 % 259; if(t159 == 0) { throw new TestException(); }\n+        int t160 = x160 % 260; if(t160 == 0) { throw new TestException(); }\n+        int t161 = x161 % 261; if(t161 == 0) { throw new TestException(); }\n+        int t162 = x162 % 262; if(t162 == 0) { throw new TestException(); }\n+        int t163 = x163 % 263; if(t163 == 0) { throw new TestException(); }\n+        int t164 = x164 % 264; if(t164 == 0) { throw new TestException(); }\n+        int t165 = x165 % 265; if(t165 == 0) { throw new TestException(); }\n+        int t166 = x166 % 266; if(t166 == 0) { throw new TestException(); }\n+        int t167 = x167 % 267; if(t167 == 0) { throw new TestException(); }\n+        int t168 = x168 % 268; if(t168 == 0) { throw new TestException(); }\n+        int t169 = x169 % 269; if(t169 == 0) { throw new TestException(); }\n+        int t170 = x170 % 270; if(t170 == 0) { throw new TestException(); }\n+        int t171 = x171 % 271; if(t171 == 0) { throw new TestException(); }\n+        int t172 = x172 % 272; if(t172 == 0) { throw new TestException(); }\n+        int t173 = x173 % 273; if(t173 == 0) { throw new TestException(); }\n+        int t174 = x174 % 274; if(t174 == 0) { throw new TestException(); }\n+        int t175 = x175 % 275; if(t175 == 0) { throw new TestException(); }\n+        int t176 = x176 % 276; if(t176 == 0) { throw new TestException(); }\n+        int t177 = x177 % 277; if(t177 == 0) { throw new TestException(); }\n+        int t178 = x178 % 278; if(t178 == 0) { throw new TestException(); }\n+        int t179 = x179 % 279; if(t179 == 0) { throw new TestException(); }\n+        int t180 = x180 % 280; if(t180 == 0) { throw new TestException(); }\n+        int t181 = x181 % 281; if(t181 == 0) { throw new TestException(); }\n+        int t182 = x182 % 282; if(t182 == 0) { throw new TestException(); }\n+        int t183 = x183 % 283; if(t183 == 0) { throw new TestException(); }\n+        int t184 = x184 % 284; if(t184 == 0) { throw new TestException(); }\n+        int t185 = x185 % 285; if(t185 == 0) { throw new TestException(); }\n+        int t186 = x186 % 286; if(t186 == 0) { throw new TestException(); }\n+        int t187 = x187 % 287; if(t187 == 0) { throw new TestException(); }\n+        int t188 = x188 % 288; if(t188 == 0) { throw new TestException(); }\n+        int t189 = x189 % 289; if(t189 == 0) { throw new TestException(); }\n+        int t190 = x190 % 290; if(t190 == 0) { throw new TestException(); }\n+        int t191 = x191 % 291; if(t191 == 0) { throw new TestException(); }\n+        int t192 = x192 % 292; if(t192 == 0) { throw new TestException(); }\n+        int t193 = x193 % 293; if(t193 == 0) { throw new TestException(); }\n+        int t194 = x194 % 294; if(t194 == 0) { throw new TestException(); }\n+        int t195 = x195 % 295; if(t195 == 0) { throw new TestException(); }\n+        int t196 = x196 % 296; if(t196 == 0) { throw new TestException(); }\n+        int t197 = x197 % 297; if(t197 == 0) { throw new TestException(); }\n+        int t198 = x198 % 298; if(t198 == 0) { throw new TestException(); }\n+        int t199 = x199 % 299; if(t199 == 0) { throw new TestException(); }\n+        int t200 = x200 % 300; if(t200 == 0) { throw new TestException(); }\n+        int t201 = x201 % 301; if(t201 == 0) { throw new TestException(); }\n+        int t202 = x202 % 302; if(t202 == 0) { throw new TestException(); }\n+        int t203 = x203 % 303; if(t203 == 0) { throw new TestException(); }\n+        int t204 = x204 % 304; if(t204 == 0) { throw new TestException(); }\n+        int t205 = x205 % 305; if(t205 == 0) { throw new TestException(); }\n+        int t206 = x206 % 306; if(t206 == 0) { throw new TestException(); }\n+        int t207 = x207 % 307; if(t207 == 0) { throw new TestException(); }\n+        int t208 = x208 % 308; if(t208 == 0) { throw new TestException(); }\n+        int t209 = x209 % 309; if(t209 == 0) { throw new TestException(); }\n+        int t210 = x210 % 310; if(t210 == 0) { throw new TestException(); }\n+        int t211 = x211 % 311; if(t211 == 0) { throw new TestException(); }\n+        int t212 = x212 % 312; if(t212 == 0) { throw new TestException(); }\n+        int t213 = x213 % 313; if(t213 == 0) { throw new TestException(); }\n+        int t214 = x214 % 314; if(t214 == 0) { throw new TestException(); }\n+        int t215 = x215 % 315; if(t215 == 0) { throw new TestException(); }\n+        int t216 = x216 % 316; if(t216 == 0) { throw new TestException(); }\n+        int t217 = x217 % 317; if(t217 == 0) { throw new TestException(); }\n+        int t218 = x218 % 318; if(t218 == 0) { throw new TestException(); }\n+        int t219 = x219 % 319; if(t219 == 0) { throw new TestException(); }\n+        int t220 = x220 % 320; if(t220 == 0) { throw new TestException(); }\n+        int t221 = x221 % 321; if(t221 == 0) { throw new TestException(); }\n+        int t222 = x222 % 322; if(t222 == 0) { throw new TestException(); }\n+        int t223 = x223 % 323; if(t223 == 0) { throw new TestException(); }\n+        int t224 = x224 % 324; if(t224 == 0) { throw new TestException(); }\n+        int t225 = x225 % 325; if(t225 == 0) { throw new TestException(); }\n+        int t226 = x226 % 326; if(t226 == 0) { throw new TestException(); }\n+        int t227 = x227 % 327; if(t227 == 0) { throw new TestException(); }\n+        int t228 = x228 % 328; if(t228 == 0) { throw new TestException(); }\n+        int t229 = x229 % 329; if(t229 == 0) { throw new TestException(); }\n+        int t230 = x230 % 330; if(t230 == 0) { throw new TestException(); }\n+        int t231 = x231 % 331; if(t231 == 0) { throw new TestException(); }\n+        int t232 = x232 % 332; if(t232 == 0) { throw new TestException(); }\n+        int t233 = x233 % 333; if(t233 == 0) { throw new TestException(); }\n+        int t234 = x234 % 334; if(t234 == 0) { throw new TestException(); }\n+        int t235 = x235 % 335; if(t235 == 0) { throw new TestException(); }\n+        int t236 = x236 % 336; if(t236 == 0) { throw new TestException(); }\n+        int t237 = x237 % 337; if(t237 == 0) { throw new TestException(); }\n+        int t238 = x238 % 338; if(t238 == 0) { throw new TestException(); }\n+        int t239 = x239 % 339; if(t239 == 0) { throw new TestException(); }\n+        int t240 = x240 % 340; if(t240 == 0) { throw new TestException(); }\n+        int t241 = x241 % 341; if(t241 == 0) { throw new TestException(); }\n+        int t242 = x242 % 342; if(t242 == 0) { throw new TestException(); }\n+        int t243 = x243 % 343; if(t243 == 0) { throw new TestException(); }\n+        int t244 = x244 % 344; if(t244 == 0) { throw new TestException(); }\n+        int t245 = x245 % 345; if(t245 == 0) { throw new TestException(); }\n+        int t246 = x246 % 346; if(t246 == 0) { throw new TestException(); }\n+        int t247 = x247 % 347; if(t247 == 0) { throw new TestException(); }\n+        int t248 = x248 % 348; if(t248 == 0) { throw new TestException(); }\n+        int t249 = x249 % 349; if(t249 == 0) { throw new TestException(); }\n+        int t250 = x250 % 350; if(t250 == 0) { throw new TestException(); }\n+        int t251 = x251 % 351; if(t251 == 0) { throw new TestException(); }\n+        int t252 = x252 % 352; if(t252 == 0) { throw new TestException(); }\n+        int t253 = x253 % 353; if(t253 == 0) { throw new TestException(); }\n+        int t254 = x254 % 354; if(t254 == 0) { throw new TestException(); }\n+        int t255 = x255 % 355; if(t255 == 0) { throw new TestException(); }\n+        \/\/ All temporaries are live here, stressing the register allocator.\n+        return t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17 + t18 + t19 + t20 + t21 + t22 + t23 + t24 + t25 + t26 + t27 + t28 + t29 + t30 + t31 + t32 + t33 + t34 + t35 + t36 + t37 + t38 + t39 + t40 + t41 + t42 + t43 + t44 + t45 + t46 + t47 + t48 + t49 + t50 + t51 + t52 + t53 + t54 + t55 + t56 + t57 + t58 + t59 + t60 + t61 + t62 + t63 + t64 + t65 + t66 + t67 + t68 + t69 + t70 + t71 + t72 + t73 + t74 + t75 + t76 + t77 + t78 + t79 + t80 + t81 + t82 + t83 + t84 + t85 + t86 + t87 + t88 + t89 + t90 + t91 + t92 + t93 + t94 + t95 + t96 + t97 + t98 + t99 + t100 + t101 + t102 + t103 + t104 + t105 + t106 + t107 + t108 + t109 + t110 + t111 + t112 + t113 + t114 + t115 + t116 + t117 + t118 + t119 + t120 + t121 + t122 + t123 + t124 + t125 + t126 + t127 + t128 + t129 + t130 + t131 + t132 + t133 + t134 + t135 + t136 + t137 + t138 + t139 + t140 + t141 + t142 + t143 + t144 + t145 + t146 + t147 + t148 + t149 + t150 + t151 + t152 + t153 + t154 + t155 + t156 + t157 + t158 + t159 + t160 + t161 + t162 + t163 + t164 + t165 + t166 + t167 + t168 + t169 + t170 + t171 + t172 + t173 + t174 + t175 + t176 + t177 + t178 + t179 + t180 + t181 + t182 + t183 + t184 + t185 + t186 + t187 + t188 + t189 + t190 + t191 + t192 + t193 + t194 + t195 + t196 + t197 + t198 + t199 + t200 + t201 + t202 + t203 + t204 + t205 + t206 + t207 + t208 + t209 + t210 + t211 + t212 + t213 + t214 + t215 + t216 + t217 + t218 + t219 + t220 + t221 + t222 + t223 + t224 + t225 + t226 + t227 + t228 + t229 + t230 + t231 + t232 + t233 + t234 + t235 + t236 + t237 + t238 + t239 + t240 + t241 + t242 + t243 + t244 + t245 + t246 + t247 + t248 + t249 + t250 + t251 + t252 + t253 + t254 + t255;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestMaxMethodArguments.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,8 @@\n- * @bug 8322996\n- * @summary Ensure no assert error in C2 with deeply nested synchronize\n- *          statements.\n- * @run main\/othervm -XX:CompileCommand=compileonly,compiler.locks.TestNestedSynchronize::test\n+ * @bug 8322996 8324839 8325467\n+ * @summary Ensure C2 can compile deeply nested synchronize statements.\n+ *          Exercises C2 register masks, in particular. We incrementally\n+ *          increase the level of nesting (up to 100) to trigger potential edge\n+ *          cases.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:CompileCommand=compileonly,Test::test*\n@@ -31,0 +35,2 @@\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AbortVMOnCompilationFailure\n@@ -32,0 +38,1 @@\n+ * @run main compiler.locks.TestNestedSynchronize\n@@ -36,0 +43,3 @@\n+import compiler.lib.compile_framework.*;\n+import java.util.LinkedList;\n+\n@@ -37,0 +47,4 @@\n+    static int min = 1;\n+    static int max = 100;\n+    static String test_class_name = \"Test\";\n+    static String test_method_name = \"test\";\n@@ -38,2 +52,57 @@\n-    public static void main(String[] args) {\n-        test();\n+    \/\/ The below method generates a program of the form:\n+    \/\/\n+    \/\/ public class Test {\n+    \/\/     public static void test1() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         }\n+    \/\/     }\n+    \/\/\n+    \/\/     public static void test2() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         }\n+    \/\/         }\n+    \/\/     }\n+    \/\/\n+    \/\/     public static void test3() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         }\n+    \/\/         }\n+    \/\/         }\n+    \/\/     }\n+    \/\/\n+    \/\/     ...\n+    \/\/\n+    \/\/     public static void test100() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         ...\n+    \/\/         }\n+    \/\/         }\n+    \/\/         }\n+    \/\/     }\n+    \/\/ }\n+    \/\/\n+    \/\/ The above is a massive program. Therefore, we do not directly inline the\n+    \/\/ program in TestNestedSynchronize and instead compile and run it via the\n+    \/\/ CompileFramework.\n+    public static String generate_test() {\n+        LinkedList<String> acc = new LinkedList<String>();\n+        for (int i = min; i <= max; i++) {\n+            LinkedList<String> method = new LinkedList<String>();\n+            for (int j = 0; j < i; j++) {\n+                method.addFirst(String.format(\n+                    \"        synchronized (%s.class) {\", test_class_name));\n+                method.addLast(\"        }\");\n+            }\n+            method.addFirst(String.format(\n+                \"    public static void %s%d() {\", test_method_name, i));\n+            method.addLast(\"    }\");\n+            acc.addAll(method);\n+        }\n+        acc.addFirst(String.format(\"public class %s {\", test_class_name));\n+        acc.addLast(\"}\");\n+        return String.join(\"\\n\", acc);\n@@ -42,194 +111,6 @@\n-    public static void test() {\n-\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n+    public static void main(String[] args) {\n+        CompileFramework comp = new CompileFramework();\n+        comp.addJavaSourceCode(test_class_name, generate_test());\n+        comp.compile();\n+        for (int i = min; i <= max; i++) {\n+            comp.invoke(test_class_name, test_method_name + i, new Object[] {});\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestNestedSynchronize.java","additions":82,"deletions":201,"binary":false,"changes":283,"status":"modified"}]}