{"files":[{"patch":"@@ -165,0 +165,3 @@\n+\/\/ Compute the least number of words required for registers in register masks.\n+int RegisterForm::words_for_regs() { return (_reg_ctr + 31) >> 5; }\n+\n@@ -167,2 +170,0 @@\n-  \/\/ Need at least this many words\n-  int words_for_regs = (_reg_ctr + 31)>>5;\n@@ -171,3 +172,1 @@\n-  \/\/ on the stack (stack registers) up to some interesting limit.  Methods\n-  \/\/ that need more parameters will NOT be compiled.  On Intel, the limit\n-  \/\/ is something like 90+ parameters.\n+  \/\/ on the stack (stack registers) up to some interesting limit.\n@@ -176,1 +175,1 @@\n-  return (words_for_regs + 3 + 1) & ~1;\n+  return (words_for_regs() + 3 + 1) & ~1;\n@@ -368,1 +367,1 @@\n-  fprintf(fp,\" 0x%x, false );\\n\", regs_in_word(i, false));\n+  fprintf(fp, \" 0x%x, false );\\n\", regs_in_word(i, false));\n@@ -375,1 +374,1 @@\n-    fprintf(fp,\" 0x%x, true );\\n\", regs_in_word(i, true));\n+    fprintf(fp, \" 0x%x, true );\\n\", regs_in_word(i, true));\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -96,0 +96,2 @@\n+  static int  words_for_regs(); \/\/ Compute the least number of words required for\n+                                \/\/ registers in register masks.\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  fprintf(fp_hpp, \"\/\/ Minimum size of register-mask in ints\\n\");\n+  fprintf(fp_hpp, \"#define RM_SIZE_MIN %d\\n\", RegisterForm::words_for_regs());\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -539,0 +539,3 @@\n+  if (C->failing()) {\n+    return;\n+  }\n@@ -602,0 +605,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -1356,2 +1362,2 @@\n-static bool is_legal_reg(LRG &lrg, OptoReg::Name reg) {\n-  if (reg < LRG::SPILL_REG && lrg.mask().Member(reg)) {\n+static bool is_legal_reg(LRG& lrg, OptoReg::Name reg) {\n+  if (lrg.mask().can_represent(reg) && lrg.mask().Member(reg)) {\n@@ -1380,1 +1386,1 @@\n-static OptoReg::Name find_first_set(LRG &lrg, RegMask mask) {\n+static OptoReg::Name find_first_set(LRG& lrg, RegMask& mask) {\n@@ -1428,1 +1434,1 @@\n-OptoReg::Name PhaseChaitin::bias_color( LRG &lrg ) {\n+OptoReg::Name PhaseChaitin::bias_color(LRG& lrg) {\n@@ -1442,1 +1448,1 @@\n-      if (is_legal_reg(lrg, reg))\n+      if (is_legal_reg(lrg, reg)) {\n@@ -1444,0 +1450,1 @@\n+      }\n@@ -1453,1 +1460,1 @@\n-      if (is_legal_reg(lrg, reg))\n+      if (is_legal_reg(lrg, reg)) {\n@@ -1455,1 +1462,2 @@\n-    } else if( !lrg.mask().is_offset() ) {\n+      }\n+    } else if (!lrg.mask().is_offset()) {\n@@ -1457,1 +1465,2 @@\n-      RegMask tempmask = lrg.mask();\n+      ResourceMark rm(C->regmask_arena());\n+      RegMask tempmask(lrg.mask(), C->regmask_arena());\n@@ -1469,1 +1478,3 @@\n-    return find_first_set(lrg, lrg.mask());\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask tempmask(lrg.mask(), C->regmask_arena());\n+    return find_first_set(lrg, tempmask);\n@@ -1489,2 +1500,1 @@\n-    if(OptoReg::is_valid(reg2)\n-         && OptoReg::is_reg(reg2 - lrg.mask().offset_bits())) {\n+    if (OptoReg::is_valid(reg2) && OptoReg::is_reg(reg2 - lrg.mask().offset_bits())) {\n@@ -1498,3 +1508,3 @@\n-OptoReg::Name PhaseChaitin::choose_color( LRG &lrg ) {\n-  assert( C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP-1)), \"must not allocate stack0 (inside preserve area)\");\n-  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP+0)), \"must not allocate stack0 (inside preserve area)\");\n+OptoReg::Name PhaseChaitin::choose_color(LRG& lrg) {\n+  assert(C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP - 1)), \"must not allocate stack0 (inside preserve area)\");\n+  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP + 0)), \"must not allocate stack0 (inside preserve area)\");\n@@ -1513,1 +1523,1 @@\n-  assert( !lrg.mask().is_offset(), \"always color in 1st chunk\" );\n+  assert(!lrg.mask().is_offset(), \"always color in 1st chunk\");\n@@ -1548,6 +1558,6 @@\n-    \/\/ Yeah, yeah, yeah, I know, I know.  I can refactor this\n-    \/\/ to avoid the GOTO, although the refactored code will not\n-    \/\/ be much clearer.  We arrive here IFF we have a stack-based\n-    \/\/ live range that cannot color in the current chunk, and it\n-    \/\/ has to move into the next free stack chunk.\n-    retry_next_chunk:\n+  \/\/ Yeah, yeah, yeah, I know, I know.  I can refactor this\n+  \/\/ to avoid the GOTO, although the refactored code will not\n+  \/\/ be much clearer.  We arrive here IFF we have a stack-based\n+  \/\/ live range that cannot color in the current chunk, and it\n+  \/\/ has to move into the next free stack chunk.\n+  retry_next_chunk:\n@@ -1557,1 +1567,4 @@\n-    debug_only(RegMask orig_mask = lrg->mask();)\n+#ifndef PRODUCT\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask orig_mask(lrg->mask(), C->regmask_arena());\n+#endif\n@@ -1571,1 +1584,2 @@\n-          RegMask rm = lrg->mask();\n+          ResourceMark r(C->regmask_arena());\n+          RegMask rm(lrg->mask(), C->regmask_arena());\n@@ -1582,1 +1596,1 @@\n-            rm.SUBTRACT_inner(lrg->mask());\n+            rm.SUBTRACT(lrg->mask());\n@@ -1600,1 +1614,1 @@\n-    OptoReg::Name reg = choose_color( *lrg );\n+    OptoReg::Name reg = choose_color(*lrg);\n@@ -1605,1 +1619,1 @@\n-    if(!OptoReg::is_valid(reg) && is_allstack) {\n+    if (!OptoReg::is_valid(reg) && is_allstack) {\n@@ -1607,1 +1621,7 @@\n-      lrg->rollover();\n+      bool success = lrg->rollover();\n+      if (!success) {\n+        \/\/ We very rarely, if ever, reach this bailout in practice.\n+        C->record_method_not_compilable(\n+            \"chunk-rollover outside of OptoReg range\");\n+        return -1;\n+      }\n@@ -1613,1 +1633,1 @@\n-    else if( OptoReg::is_valid(reg)) {\n+    else if (OptoReg::is_valid(reg)) {\n@@ -1615,1 +1635,2 @@\n-      RegMask avail_rm = lrg->mask();\n+      ResourceMark rm(C->regmask_arena());\n+      RegMask avail_rm(lrg->mask(), C->regmask_arena());\n@@ -1621,2 +1642,3 @@\n-      if( reg >= _max_reg )     \/\/ Compute max register limit\n-        _max_reg = OptoReg::add(reg,1);\n+      if( reg >= _max_reg ) {     \/\/ Compute max register limit\n+        _max_reg = OptoReg::add(reg, 1);\n+      }\n@@ -1685,1 +1707,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":53,"deletions":32,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  void init_mask() { new(&_mask) RegMask(); }\n+  void init_mask(Arena* arena) { new (&_mask) RegMask(arena); }\n@@ -136,1 +136,4 @@\n-  void SUBTRACT_inner( const RegMask &rm ) { _mask.SUBTRACT_inner(rm); debug_only(_msize_valid=0;)}\n+  void SUBTRACT_inner(const RegMask& rm) {\n+    _mask.SUBTRACT_inner(rm);\n+    debug_only(_msize_valid = 0;)\n+  }\n@@ -138,2 +141,10 @@\n-  void Set_All() { _mask.Set_All(); debug_only(_msize_valid=1); _mask_size = _mask.rm_size_bits(); }\n-  void rollover() { _mask.rollover(); debug_only(_msize_valid=1); _mask_size = _mask.rm_size_bits(); }\n+  void Set_All() {\n+    _mask.Set_All();\n+    debug_only(_msize_valid = 1);\n+    _mask_size = _mask.rm_size_bits();\n+  }\n+  bool rollover() {\n+    debug_only(_msize_valid = 1);\n+    _mask_size = _mask.rm_size_bits();\n+    return _mask.rollover();\n+  }\n@@ -703,1 +714,1 @@\n-  OptoReg::Name choose_color( LRG &lrg );\n+  OptoReg::Name choose_color(LRG& lrg);\n@@ -705,1 +716,1 @@\n-  OptoReg::Name bias_color( LRG &lrg );\n+  OptoReg::Name bias_color(LRG& lrg);\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -697,1 +697,2 @@\n-  RegMask rm = lrgs(lr1).mask();\n+  ResourceMark r(C->regmask_arena());\n+  RegMask rm(lrgs(lr1).mask(), C->regmask_arena());\n","filename":"src\/hotspot\/share\/opto\/coalesce.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -681,0 +681,2 @@\n+                  _FIRST_STACK_mask(&_comp_arena),\n+                  _regmask_arena(mtCompiler),\n@@ -949,0 +951,2 @@\n+    _FIRST_STACK_mask(&_comp_arena),\n+    _regmask_arena(mtCompiler),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -559,0 +559,1 @@\n+  ResourceArea          _regmask_arena;         \/\/ Holds dynamically allocated extensions of short-lived register masks\n@@ -1110,0 +1111,1 @@\n+  ResourceArea*     regmask_arena()             { return &_regmask_arena; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    _lrgs[i].init_mask();\n+    _lrgs[i].init_mask(_arena);\n@@ -642,1 +642,2 @@\n-  RegMask mask_tmp = lrg.mask();\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask mask_tmp(lrg.mask(), C->regmask_arena());\n@@ -700,0 +701,3 @@\n+  ResourceMark r(C->regmask_arena());\n+  RegMask old(C->regmask_arena());\n+  RegMask r2mask(C->regmask_arena());\n@@ -714,1 +718,1 @@\n-    RegMask old = interfering_lrg.mask();\n+    old = interfering_lrg.mask();\n@@ -723,1 +727,1 @@\n-      RegMask r2mask = rm;\n+      r2mask = rm;\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -843,1 +843,2 @@\n-  RegMask regs;\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask regs(C->regmask_arena());\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,5 +42,15 @@\n-BoxLockNode::BoxLockNode( int slot ) : Node( Compile::current()->root() ),\n-                                       _slot(slot),\n-                                       \/\/ In debug mode, signal that the register mask is constant.\n-                                       _inmask(OptoReg::stack2reg(_slot) DEBUG_ONLY(COMMA true)),\n-                                       _kind(BoxLockNode::Regular) {\n+BoxLockNode::BoxLockNode(int slot)\n+    : Node(Compile::current()->root()), _slot(slot),\n+#ifdef ASSERT\n+      \/\/ In debug mode, signal that the register mask is constant.\n+      _inmask(OptoReg::stack2reg(_slot), Compile::current()->comp_arena(),\n+              true),\n+#else\n+      _inmask(OptoReg::stack2reg(_slot), Compile::current()->comp_arena()),\n+#endif\n+      _kind(BoxLockNode::Regular) {\n+  if (_slot > BoxLockNode_slot_limit) {\n+    Compile::current()->record_method_not_compilable(\n+        \"reached BoxLockNode slot limit\");\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -741,1 +741,3 @@\n-  MachProjNode( Node *multi, uint con, const RegMask &out, uint ideal_reg ) : ProjNode(multi,con), _rout(out), _ideal_reg(ideal_reg) {\n+  MachProjNode(Node* multi, uint con, const RegMask& out, uint ideal_reg)\n+      : ProjNode(multi, con), _rout(out, Compile::current()->comp_arena()),\n+        _ideal_reg(ideal_reg) {\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,1 +84,2 @@\n-  _register_save_type(register_save_type) {\n+  _register_save_type(register_save_type),\n+  _return_addr_mask(C->comp_arena()) {\n@@ -191,1 +192,1 @@\n-  _return_addr_mask = return_addr();\n+  _return_addr_mask.Insert(return_addr());\n@@ -225,1 +226,0 @@\n-  new(_calling_convention_mask) RegMask[argcnt];\n@@ -229,0 +229,1 @@\n+    new (_calling_convention_mask + i) RegMask(C->comp_arena());\n@@ -431,1 +432,3 @@\n-  new(rms) RegMask[size];\n+  for (unsigned int i = 0; i < size; ++i) {\n+    new (rms + i) RegMask(Compile::current()->comp_arena());\n+  }\n@@ -471,1 +474,1 @@\n-    new (rms + i) RegMask();\n+    new (rms + i) RegMask(C->comp_arena());\n@@ -534,1 +537,1 @@\n-  RegMask aligned_stack_mask = C->FIRST_STACK_mask();\n+  RegMask aligned_stack_mask(C->FIRST_STACK_mask(), C->comp_arena());\n@@ -538,1 +541,1 @@\n-  RegMask scalable_stack_mask = aligned_stack_mask;\n+  RegMask scalable_stack_mask(aligned_stack_mask, C->comp_arena());\n@@ -1234,2 +1237,3 @@\n-    if( warped >= out_arg_limit_per_call )\n-      out_arg_limit_per_call = OptoReg::add(warped,1);\n+    if( warped >= out_arg_limit_per_call ) {\n+      out_arg_limit_per_call = OptoReg::add(warped, 1);\n+    }\n@@ -1318,1 +1322,3 @@\n-  for (uint i = 0; i < cnt; i++) ::new (&(msfpt->_in_rms[i])) RegMask();\n+  for (uint i = 0; i < cnt; i++) {\n+    ::new (&(msfpt->_in_rms[i])) RegMask(C->comp_arena());\n+  }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -548,2 +548,2 @@\n-    MachProjNode *mach  = n->as_MachProj();\n-    MachProjNode *mthis = this->as_MachProj();\n+    MachProjNode* mach = n->as_MachProj();\n+    MachProjNode* mthis = this->as_MachProj();\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  bool can_use = use_mask.Member_including_AllStack(def_reg);\n+  bool can_use = use_mask.Member(def_reg);\n@@ -683,1 +683,6 @@\n-              assert(lrgs(useidx).mask().can_represent(ureg_lo), \"sanity\");\n+              \/\/ If the below assert fails, there is a potential difference in\n+              \/\/ behavior compared to an older version (before RegMasks could\n+              \/\/ grow)\n+              assert(!(!value[ureg_lo] && lrgs(useidx).mask().is_offset() &&\n+                       !lrgs(useidx).mask().Member(ureg_lo)),\n+                     \"invalid assumption\");\n@@ -766,2 +771,7 @@\n-        assert(lrgs(lidx).mask().can_represent(nreg_lo), \"sanity\");\n-        if( !lrgs(lidx).mask().Member(nreg_lo) ) { \/\/ Nearly always adjacent\n+        \/\/ If the below assert fails, there is a potential difference in\n+        \/\/ behavior compared to an older version (before RegMasks could\n+        \/\/ grow)\n+        assert(!(lrgs(lidx).mask().is_offset() &&\n+                 !lrgs(lidx).mask().Member(nreg_lo)),\n+               \"invalid assumption\");\n+        if (!lrgs(lidx).mask().Member(nreg_lo)) { \/\/ Nearly always adjacent\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1130,1 +1130,2 @@\n-                  RegMask tmp_rm(umask);\n+                  ResourceMark rm(C->regmask_arena());\n+                  RegMask tmp_rm(umask, C->regmask_arena());\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"utilities\/population_count.hpp\"\n@@ -56,1 +55,1 @@\n-  FORALL_BODY\n+    FORALL_BODY\n@@ -58,2 +57,1 @@\n-  0\n-);\n+    true);\n@@ -62,4 +60,0 @@\n-Arena* RegMask::_get_arena() {\n-  return Compile::current()->comp_arena();\n-}\n-\n@@ -400,6 +394,15 @@\n-\/\/ Compute size of register mask in bits\n-uint RegMask::Size() const {\n-  uint sum = 0;\n-  assert(valid_watermarks(), \"sanity\");\n-  for (unsigned i = _lwm; i <= _hwm; i++) {\n-    sum += population_count(_rm_up(i));\n+#ifndef PRODUCT\n+bool RegMask::_dump_end_run(outputStream* st, OptoReg::Name start,\n+                            OptoReg::Name last) const {\n+  bool last_is_end = last == (int)offset_bits() + (int)rm_size_bits() - 1;\n+  if (is_AllStack() && last_is_end) {\n+    st->print(\"-...\");\n+    return true;\n+  }\n+  if (start == last) { \/\/ 1-register run; no special printing\n+  } else if (start + 1 == last) {\n+    st->print(\",\"); \/\/ 2-register run; print as \"rX,rY\"\n+    OptoReg::dump(last, st);\n+  } else { \/\/ Multi-register run; print as \"rX-rZ\"\n+    st->print(\"-\");\n+    OptoReg::dump(last, st);\n@@ -407,1 +410,1 @@\n-  return sum;\n+  return false;\n@@ -410,1 +413,0 @@\n-#ifndef PRODUCT\n@@ -415,0 +417,1 @@\n+  bool printed_all_stack = false;\n@@ -431,8 +434,2 @@\n-        if (start == last) {    \/\/ 1-register run; no special printing\n-        } else if (start+1 == last) {\n-          st->print(\",\");       \/\/ 2-register run; print as \"rX,rY\"\n-          OptoReg::dump(last, st);\n-        } else {                \/\/ Multi-register run; print as \"rX-rZ\"\n-          st->print(\"-\");\n-          OptoReg::dump(last, st);\n-        }\n+        printed_all_stack = _dump_end_run(st, start, last);\n+        assert(!printed_all_stack, \"\");\n@@ -444,8 +441,12 @@\n-\n-    if (start == last) {        \/\/ 1-register run; no special printing\n-    } else if (start+1 == last) {\n-      st->print(\",\");           \/\/ 2-register run; print as \"rX,rY\"\n-      OptoReg::dump(last, st);\n-    } else {                    \/\/ Multi-register run; print as \"rX-rZ\"\n-      st->print(\"-\");\n-      OptoReg::dump(last, st);\n+    printed_all_stack = _dump_end_run(st, start, last);\n+    \/\/ Print all-stack if not already done.\n+    if (is_AllStack() && !printed_all_stack) {\n+      st->print(\",\");\n+      OptoReg::dump(offset_bits() + rm_size_bits(), st);\n+      st->print(\"-...\");\n+    }\n+  } else {\n+    \/\/ Mask is all-stack only.\n+    if (is_AllStack() && !printed_all_stack) {\n+      OptoReg::dump(offset_bits() + rm_size_bits(), st);\n+      st->print(\"-...\");\n@@ -453,5 +454,0 @@\n-    if (is_AllStack()) { st->print(\",\"); }\n-  }\n-  if (is_AllStack()) {\n-    OptoReg::dump(offset_bits() + rm_size_bits(), st);\n-    st->print(\"...\");\n@@ -461,0 +457,10 @@\n+\n+void RegMask::dump_hex(outputStream* st) const {\n+  st->print(\"...%x|\", is_AllStack() ? 0xf : 0x0);\n+  for (int i = _rm_max(); i >= 0; i--) {\n+    st->print(LP64_ONLY(\"%0*lx\") NOT_LP64(\"%0*x\"), (int)sizeof(uintptr_t) * CHAR_BIT \/ 4, _rm_up(i));\n+    if (i != 0) {\n+      st->print(\"|\");\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":43,"deletions":37,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-\/\/ The ADLC defines 2 macros, RM_SIZE and FORALL_BODY.\n+\/\/ The ADLC defines 3 macros, RM_SIZE, RM_SIZE_MIN, and FORALL_BODY.\n@@ -54,0 +54,2 @@\n+\/\/ RM_SIZE_MIN is the theoretical minimum size of a register mask in 32-bit\n+\/\/ words.\n@@ -69,0 +71,2 @@\n+  static const unsigned int _RM_SIZE_MIN =\n+      LP64_ONLY(((RM_SIZE_MIN + 1) & ~1) >> 1) NOT_LP64(RM_SIZE_MIN);\n@@ -71,0 +75,16 @@\n+  \/\/ Compute a best-effort (statically known) upper bound for register mask\n+  \/\/ size in 32-bit words. When extending\/growing register masks, we should\n+  \/\/ never grow past this size.\n+  static const unsigned int RM_SIZE_MAX =\n+      (((RM_SIZE_MIN << 5) +                \/\/ Slots for machine registers\n+        (max_method_parameter_length * 2) + \/\/ Slots for incoming arguments\n+        (max_method_parameter_length * 2) + \/\/ Slots for outgoing arguments\n+        BoxLockNode_slot_limit +            \/\/ Slots for locks\n+        64                                  \/\/ Padding, reserved words, etc.\n+        ) + 31) >> 5; \/\/ Number of bits -> number of 32-bit words\n+  static const unsigned int _RM_SIZE_MAX =\n+      LP64_ONLY(((RM_SIZE_MAX + 1) & ~1) >> 1) NOT_LP64(RM_SIZE_MAX);\n+  \/\/ The maximum OptoReg size is SHRT_MAX. Ensure that register masks cannot\n+  \/\/ grow beyond that.\n+  STATIC_ASSERT((RM_SIZE_MAX << 5) < SHRT_MAX);\n+\n@@ -81,3 +101,12 @@\n-  \/\/ extend the register mask with dynamically allocated memory. We could use a\n-  \/\/ GrowableArray here, but there are currently some GrowableArray limitations\n-  \/\/ that have a negative performance impact for our use case:\n+  \/\/ extend the register mask with dynamically allocated memory. We keep the\n+  \/\/ base statically allocated _RM_UP, and arena-allocate the extended mask\n+  \/\/ (RM_UP_EXT) separately. Another, perhaps more elegant, option would be to\n+  \/\/ have two subclasses of RegMask, where one is statically allocated and one\n+  \/\/ is (entirely) dynamically allocated. Given that register mask extension is\n+  \/\/ rare, we decided to use the current approach (_RM_UP and _RM_UP_EXT) to\n+  \/\/ keep the common case fast. Most of the time, we will then not need to\n+  \/\/ dynamically allocate anything.\n+  \/\/\n+  \/\/ We could use a GrowableArray here, but there are currently some\n+  \/\/ GrowableArray limitations that have a negative performance impact for our\n+  \/\/ use case:\n@@ -104,4 +133,3 @@\n-  \/\/ If the original version is read-only. In such cases, we can allow\n-  \/\/ read-only sharing.\n-  public: bool orig_const = false;\n-  private:\n+  \/\/ If the original version, of which we may be a clone, is read-only. In such\n+  \/\/ cases, we can allow read-only sharing.\n+  bool orig_const = false;\n@@ -124,4 +152,6 @@\n-  \/\/ The low and high watermarks represent the lowest and highest word\n-  \/\/ that might contain set register mask bits, respectively. We guarantee\n-  \/\/ that there are no bits in words outside this range, but any word at\n-  \/\/ and between the two marks can still be 0.\n+  \/\/ The low and high watermarks represent the lowest and highest word that\n+  \/\/ might contain set register mask bits, respectively. We guarantee that\n+  \/\/ there are no bits in words outside this range, but any word at and between\n+  \/\/ the two marks can still be 0. We do not guarantee that the watermarks are\n+  \/\/ optimal. If _hwm < _lwm, the register mask is necessarily empty. Indeed,\n+  \/\/ when we construct empty register masks, we set _hwm = 0 and _lwm = max.\n@@ -159,0 +189,1 @@\n+    assert(i < _rm_size, \"sanity\");\n@@ -176,2 +207,2 @@\n-  \/\/ Return a suitable arena for (extended) register mask allocation.\n-  static Arena* _get_arena();\n+  \/\/ Where to extend the register mask\n+  Arena* _arena;\n@@ -182,1 +213,3 @@\n-      Arena* _arena = _get_arena();\n+      assert(min_size <= round_up_power_of_2(_RM_SIZE_MAX),\n+             \"unexpected register mask growth\");\n+      assert(_arena != nullptr, \"register mask not growable\");\n@@ -220,1 +253,0 @@\n-      _grow(src._rm_size, false);\n@@ -222,0 +254,1 @@\n+      _grow(src._rm_size, false);\n@@ -223,1 +256,1 @@\n-          sizeof(uintptr_t) * (src._rm_size - _RM_SIZE));\n+             sizeof(uintptr_t) * (src._rm_size - _RM_SIZE));\n@@ -244,1 +277,1 @@\n-             sizeof(uintptr_t) * MIN2((int)length,(int)_RM_SIZE-(int)start));\n+             sizeof(uintptr_t) * MIN2((int)length, (int)_RM_SIZE - (int)start));\n@@ -249,1 +282,1 @@\n-      memset(_RM_UP_EXT + MAX2((int)start-(int)_RM_SIZE,0), value,\n+      memset(_RM_UP_EXT + MAX2((int)start - (int)_RM_SIZE, 0), value,\n@@ -251,1 +284,1 @@\n-                                      (int)length-((int)_RM_SIZE-(int)start)));\n+                                      (int)length - ((int)_RM_SIZE - (int)start)));\n@@ -255,2 +288,1 @@\n- public:\n-\n+public:\n@@ -261,1 +293,0 @@\n-  unsigned int offset() const { return _offset; }\n@@ -293,1 +324,1 @@\n-    FORALL_BODY\n+      FORALL_BODY\n@@ -295,1 +326,2 @@\n-    bool all_stack): _rm_size(_RM_SIZE), _offset(0), _all_stack(all_stack) {\n+      bool all_stack)\n+      : _rm_size(_RM_SIZE), _offset(0), _all_stack(all_stack), _arena(nullptr) {\n@@ -312,2 +344,3 @@\n-  RegMask(): _RM_UP(), _rm_size(_RM_SIZE), _offset(0),\n-             _all_stack(false), _lwm(_RM_MAX), _hwm(0) {\n+  RegMask(Arena* arena)\n+      : _RM_UP(), _rm_size(_RM_SIZE), _offset(0), _all_stack(false),\n+        _lwm(_RM_MAX), _hwm(0), _arena(arena) {\n@@ -316,0 +349,1 @@\n+  RegMask() : RegMask(nullptr) { assert(valid_watermarks(), \"post-condition\"); }\n@@ -318,1 +352,3 @@\n-  RegMask(OptoReg::Name reg DEBUG_ONLY(COMMA bool orig_const = false)): RegMask() {\n+#ifdef ASSERT\n+  RegMask(OptoReg::Name reg, Arena* arena, bool orig_const = false)\n+      : RegMask(arena) {\n@@ -320,1 +356,1 @@\n-    DEBUG_ONLY(this->orig_const = orig_const;)\n+    this->orig_const = orig_const;\n@@ -322,0 +358,4 @@\n+#else\n+  RegMask(OptoReg::Name reg, Arena* arena) : RegMask(arena) { Insert(reg); }\n+#endif\n+  RegMask(OptoReg::Name reg) : RegMask(reg, nullptr) {}\n@@ -323,1 +363,2 @@\n-  RegMask(const RegMask& rm): _rm_size(_RM_SIZE), _offset(rm._offset) {\n+  RegMask(const RegMask& rm, Arena* arena)\n+      : _rm_size(_RM_SIZE), _offset(rm._offset), _arena(arena) {\n@@ -327,1 +368,3 @@\n-  RegMask& operator= (const RegMask& rm) {\n+  RegMask(const RegMask& rm) : RegMask(rm, nullptr) {}\n+\n+  RegMask& operator=(const RegMask& rm) {\n@@ -332,2 +375,1 @@\n-  \/\/ Check for register being in mask.\n-  bool Member(OptoReg::Name reg, bool include_all_stack = false) const {\n+  bool Member(OptoReg::Name reg) const {\n@@ -335,1 +377,3 @@\n-    if (reg < 0) { return false; }\n+    if (reg < 0) {\n+      return false;\n+    }\n@@ -337,1 +381,1 @@\n-      return include_all_stack ? is_AllStack() : false;\n+      return is_AllStack();\n@@ -343,4 +387,0 @@\n-  bool Member_including_AllStack(OptoReg::Name reg) const {\n-    return Member(reg, true);\n-  }\n-\n@@ -411,5 +451,0 @@\n-\n-  bool can_represent(OptoReg::Name reg, unsigned int size = 1) const {\n-    reg = reg - offset_bits();\n-    return (int)reg <= (int)(rm_size_bits() - size) && (int)reg >= 0;\n-  }\n@@ -453,2 +488,1 @@\n-  \/\/ Fast overlap test. Non-zero if any registers in common. Ignores registers\n-  \/\/ included through the all-stack flag.\n+  \/\/ Overlap test. Non-zero if any registers in common, including all-stack.\n@@ -458,0 +492,2 @@\n+\n+    \/\/ Case 1 (very common): _rm_up overlap\n@@ -465,0 +501,24 @@\n+\n+    \/\/ Case 2 (very rare): we are both all-stack\n+    if (is_AllStack() && rm.is_AllStack()) {\n+      return true;\n+    }\n+\n+    \/\/ Case 3 (very rare): we are all-stack and rm _hwm is bigger than us\n+    if (is_AllStack() && rm._hwm >= _rm_size) {\n+      for (unsigned i = MAX2(rm._lwm, _rm_size); i <= rm._hwm; i++) {\n+        if (rm._rm_up(i)) {\n+          return true;\n+        }\n+      }\n+    }\n+\n+    \/\/ Case 4 (very rare): rm is all-stack and our _hwm is bigger than rm\n+    if (rm.is_AllStack() && _hwm >= rm._rm_size) {\n+      for (unsigned i = MAX2(_lwm, rm._rm_size); i <= _hwm; i++) {\n+        if (_rm_up(i)) {\n+          return true;\n+        }\n+      }\n+    }\n+\n@@ -511,1 +571,3 @@\n-    if (index < _lwm) _lwm = index;\n+    if (index < _lwm) {\n+      _lwm = index;\n+    }\n@@ -617,3 +679,3 @@\n-  \/\/ overlap with us. Supports masks of differing offsets. Ignores all_stack\n-  \/\/ flags and treats them as false.\n-  void SUBTRACT_inner(const RegMask &rm) {\n+  \/\/ overlap with us and to not modify our all-stack flag. Supports masks of\n+  \/\/ differing offsets. Does not support 'rm' with the all-stack flag set.\n+  void SUBTRACT_inner(const RegMask& rm) {\n@@ -621,0 +683,1 @@\n+    assert(!rm.is_AllStack(), \"not supported\");\n@@ -638,3 +701,8 @@\n-  \/\/ slots for the register allocator.\n-  void rollover() {\n-    assert(is_AllStack_only(),\"rolling over non-empty mask\");\n+  \/\/ slots for the register allocator. Return if the rollover succeeded or not.\n+  bool rollover() {\n+    assert(is_AllStack_only(), \"rolling over non-empty mask\");\n+    if ((_rm_size + _offset + _rm_size) * BitsPerWord > SHRT_MAX) {\n+      \/\/ The maximum OptoReg size is SHRT_MAX. Register masks\n+      \/\/ cannot represent anything beyond that.\n+      return false;\n+    }\n@@ -643,0 +711,1 @@\n+    return true;\n@@ -646,1 +715,8 @@\n-  uint Size() const;\n+  uint Size() const {\n+    uint sum = 0;\n+    assert(valid_watermarks(), \"sanity\");\n+    for (unsigned i = _lwm; i <= _hwm; i++) {\n+      sum += population_count(_rm_up(i));\n+    }\n+    return sum;\n+  }\n@@ -649,0 +725,6 @@\n+private:\n+  bool _dump_end_run(outputStream* st, OptoReg::Name start,\n+                     OptoReg::Name last) const;\n+\n+public:\n+  unsigned int static basic_rm_size() { return _RM_SIZE; }\n@@ -651,0 +733,1 @@\n+  void dump_hex(outputStream* st = tty) const; \/\/ Print a mask (raw hex)\n@@ -656,0 +739,4 @@\n+  bool can_represent(OptoReg::Name reg, unsigned int size = 1) const {\n+    reg = reg - offset_bits();\n+    return reg >= 0 && reg <= (int)(rm_size_bits() - size);\n+  }\n@@ -720,1 +807,1 @@\n-\/\/ Do not use this constant directly in client code!\n+\/\/ Do not use these constants directly in client code!\n@@ -722,0 +809,1 @@\n+#undef RM_SIZE_MIN\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":143,"deletions":55,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -562,0 +562,1 @@\n+const int max_method_parameter_length = 255; \/\/ JVM spec, 22nd ed. section 4.3.3 (p.83)\n@@ -1361,0 +1362,8 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ C2 limits\n+\n+\/\/ To avoid unbounded RegMask growth, we need to set a limit on the number of\n+\/\/ stack slots used by BoxLockNodes. We reach this limit by deeply nesting\n+\/\/ synchronized statements in Java.\n+const int BoxLockNode_slot_limit = 200;\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/chaitin.hpp\"\n@@ -30,1 +31,3 @@\n-\/\/ Sanity tests for RegMask and RegMaskIterator\n+\/\/ Sanity tests for RegMask and RegMaskIterator. The file tests operations on\n+\/\/ combinations of different RegMask versions (\"basic\", i.e. only statically\n+\/\/ allocated and \"extended\", i.e. extended with dynamically allocated memory).\n@@ -146,0 +149,12 @@\n+TEST_VM(RegMask, SUBTRACT_inner) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  rm2.Set_All();\n+  for (int i = 17; i < (int)rm1.rm_size_bits(); i++) {\n+    rm1.Insert(i);\n+  }\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_bits() - 17);\n+  contains_expected_num_of_registers(rm2, 17);\n+}\n+\n@@ -195,1 +210,1 @@\n-        rm.Insert(j);\n+      rm.Insert(j);\n@@ -202,0 +217,583 @@\n+\n+TEST_VM(RegMask, external_member) {\n+  RegMask rm;\n+  rm.set_AllStack(false);\n+  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+  rm.set_AllStack(true);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+}\n+\n+TEST_VM(RegMask, find_element) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(44));\n+  rm.Insert(OptoReg::Name(30));\n+  rm.Insert(OptoReg::Name(54));\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Name(30));\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Name(54));\n+  rm.set_AllStack(true);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Name(54));\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Bad);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Bad);\n+}\n+\n+TEST_VM(RegMask, find_first_set) {\n+  RegMask rm;\n+  LRG lrg;\n+  lrg._is_scalable = 0;\n+  lrg._is_vector = 0;\n+  ASSERT_EQ(rm.find_first_set(lrg, 2), OptoReg::Bad);\n+  rm.Insert(OptoReg::Name(24));\n+  rm.Insert(OptoReg::Name(25));\n+  rm.Insert(OptoReg::Name(26));\n+  rm.Insert(OptoReg::Name(27));\n+  rm.Insert(OptoReg::Name(16));\n+  rm.Insert(OptoReg::Name(17));\n+  rm.Insert(OptoReg::Name(18));\n+  rm.Insert(OptoReg::Name(19));\n+  ASSERT_EQ(rm.find_first_set(lrg, 4), OptoReg::Name(19));\n+}\n+\n+TEST_VM(RegMask, alignment) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(30));\n+  rm.Insert(OptoReg::Name(31));\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  rm.Insert(OptoReg::Name(32));\n+  rm.Insert(OptoReg::Name(37));\n+  rm.Insert(OptoReg::Name(62));\n+  rm.Insert(OptoReg::Name(71));\n+  rm.Insert(OptoReg::Name(74));\n+  rm.Insert(OptoReg::Name(75));\n+  ASSERT_FALSE(rm.is_aligned_pairs());\n+  rm.clear_to_pairs();\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  ASSERT_TRUE(rm.is_aligned_pairs());\n+  contains_expected_num_of_registers(rm, 4);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(30)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(31)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(74)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(75)));\n+  ASSERT_FALSE(rm.is_misaligned_pair());\n+  rm.Remove(OptoReg::Name(30));\n+  rm.Remove(OptoReg::Name(74));\n+  ASSERT_TRUE(rm.is_misaligned_pair());\n+}\n+\n+TEST_VM(RegMask, clear_to_sets) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(20));\n+  rm.Insert(OptoReg::Name(21));\n+  rm.Insert(OptoReg::Name(22));\n+  rm.Insert(OptoReg::Name(23));\n+  rm.Insert(OptoReg::Name(25));\n+  rm.Insert(OptoReg::Name(26));\n+  rm.Insert(OptoReg::Name(27));\n+  rm.Insert(OptoReg::Name(40));\n+  rm.Insert(OptoReg::Name(42));\n+  rm.Insert(OptoReg::Name(43));\n+  rm.Insert(OptoReg::Name(44));\n+  rm.Insert(OptoReg::Name(45));\n+  rm.clear_to_sets(2);\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  contains_expected_num_of_registers(rm, 10);\n+  rm.clear_to_sets(4);\n+  ASSERT_TRUE(rm.is_aligned_sets(4));\n+  contains_expected_num_of_registers(rm, 4);\n+  rm.clear_to_sets(8);\n+  ASSERT_TRUE(rm.is_aligned_sets(8));\n+  contains_expected_num_of_registers(rm, 0);\n+}\n+\n+TEST_VM(RegMask, smear_to_sets) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(3));\n+  rm.smear_to_sets(2);\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  contains_expected_num_of_registers(rm, 2);\n+  rm.smear_to_sets(4);\n+  ASSERT_TRUE(rm.is_aligned_sets(4));\n+  contains_expected_num_of_registers(rm, 4);\n+  rm.smear_to_sets(8);\n+  ASSERT_TRUE(rm.is_aligned_sets(8));\n+  contains_expected_num_of_registers(rm, 8);\n+  rm.smear_to_sets(16);\n+  ASSERT_TRUE(rm.is_aligned_sets(16));\n+  contains_expected_num_of_registers(rm, 16);\n+}\n+\n+TEST_VM(RegMask, overlap) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(23));\n+  rm1.Insert(OptoReg::Name(2));\n+  rm1.Insert(OptoReg::Name(12));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(4));\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(4));\n+  ASSERT_TRUE(rm1.overlap(rm2));\n+  ASSERT_TRUE(rm2.overlap(rm1));\n+}\n+\n+TEST_VM(RegMask, valid_reg) {\n+  RegMask rm;\n+  ASSERT_FALSE(rm.is_valid_reg(OptoReg::Name(42), 1));\n+  rm.Insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(5));\n+  rm.Insert(OptoReg::Name(6));\n+  rm.Insert(OptoReg::Name(7));\n+  ASSERT_FALSE(rm.is_valid_reg(OptoReg::Name(7), 4));\n+  ASSERT_TRUE(rm.is_valid_reg(OptoReg::Name(7), 2));\n+}\n+\n+TEST_VM(RegMask, rollover_and_insert_remove) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  OptoReg::Name reg2(rm.rm_size_bits() * 2 + 42);\n+  rm.set_AllStack(true);\n+  ASSERT_TRUE(rm.Member(reg1));\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg1);\n+  ASSERT_TRUE(rm.Member(reg1));\n+  rm.Remove(reg1);\n+  ASSERT_FALSE(rm.Member(reg1));\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg2);\n+  ASSERT_FALSE(rm.Member(reg1));\n+  ASSERT_TRUE(rm.Member(reg2));\n+}\n+\n+TEST_VM(RegMask, rollover_and_find) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  OptoReg::Name reg2(rm.rm_size_bits() + 7);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Bad);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Bad);\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  ASSERT_EQ(rm.find_first_elem(), reg2);\n+  ASSERT_EQ(rm.find_last_elem(), reg1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_find_first_set) {\n+  LRG lrg;\n+  lrg._is_scalable = 0;\n+  lrg._is_vector = 0;\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 24);\n+  OptoReg::Name reg2(rm.rm_size_bits() + 25);\n+  OptoReg::Name reg3(rm.rm_size_bits() + 26);\n+  OptoReg::Name reg4(rm.rm_size_bits() + 27);\n+  OptoReg::Name reg5(rm.rm_size_bits() + 16);\n+  OptoReg::Name reg6(rm.rm_size_bits() + 17);\n+  OptoReg::Name reg7(rm.rm_size_bits() + 18);\n+  OptoReg::Name reg8(rm.rm_size_bits() + 19);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_set(lrg, 2), OptoReg::Bad);\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  rm.Insert(reg3);\n+  rm.Insert(reg4);\n+  rm.Insert(reg5);\n+  rm.Insert(reg6);\n+  rm.Insert(reg7);\n+  rm.Insert(reg8);\n+  ASSERT_EQ(rm.find_first_set(lrg, 4), reg8);\n+}\n+\n+TEST_VM(RegMask, rollover_and_Set_All_From) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Set_All_From(reg1);\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits() - 42);\n+}\n+\n+TEST_VM(RegMask, rollover_and_Set_All_From_Offset) {\n+  RegMask rm;\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Set_All_From_Offset();\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits());\n+}\n+\n+TEST_VM(RegMask, rollover_and_iterate) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 2);\n+  OptoReg::Name reg2(rm.rm_size_bits() + 6);\n+  OptoReg::Name reg3(rm.rm_size_bits() + 17);\n+  OptoReg::Name reg4(rm.rm_size_bits() + 43);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  rm.Insert(reg3);\n+  rm.Insert(reg4);\n+  RegMaskIterator rmi(rm);\n+  ASSERT_EQ(rmi.next(), reg1);\n+  ASSERT_EQ(rmi.next(), reg2);\n+  ASSERT_EQ(rmi.next(), reg3);\n+  ASSERT_EQ(rmi.next(), reg4);\n+  ASSERT_FALSE(rmi.has_next());\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  rm1.set_AllStack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(42);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  rm1.set_AllStack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm2.set_AllStack(true);\n+  rm2.rollover();\n+  rm2.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(reg1);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm1.Insert(reg1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+#ifndef PRODUCT\n+\n+Arena* arena() {\n+  return Thread::current()->resource_area();\n+}\n+\n+static void is_basic(const RegMask& rm) {\n+  ASSERT_EQ(rm.rm_size(), RegMask::basic_rm_size());\n+}\n+\n+static void is_extended(const RegMask& rm) {\n+  ASSERT_TRUE(rm.rm_size() > RegMask::basic_rm_size());\n+}\n+\n+static int first_extended() {\n+  return RegMask::basic_rm_size() * BitsPerWord;\n+}\n+\n+static void extend(RegMask& rm, unsigned int n = 4) {\n+  \/\/ Extend the given RegMask with at least n dynamically-allocated words.\n+  rm.Insert(OptoReg::Name(first_extended() + (BitsPerWord * n) - 1));\n+  rm.Clear();\n+  ASSERT_TRUE(rm.rm_size() >= RegMask::basic_rm_size() + n);\n+}\n+\n+TEST_VM(RegMask, static_by_default) {\n+  \/\/ Check that a freshly created RegMask does not allocate dynamic memory.\n+  RegMask rm;\n+  is_basic(rm);\n+}\n+\n+TEST_VM(RegMask, iteration_extended) {\n+  RegMask rm(arena());\n+  rm.Insert(30);\n+  rm.Insert(31);\n+  rm.Insert(33);\n+  rm.Insert(62);\n+  rm.Insert(first_extended());\n+  rm.Insert(first_extended() + 42);\n+  rm.Insert(first_extended() + 55);\n+  rm.Insert(first_extended() + 456);\n+\n+  RegMaskIterator rmi(rm);\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(30));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(31));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(33));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(62));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended()));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 42));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 55));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 456));\n+  ASSERT_FALSE(rmi.has_next());\n+}\n+\n+TEST_VM(RegMask, Set_ALL_extended) {\n+  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits() on\n+  \/\/ extended RegMasks.\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.Set_All();\n+  ASSERT_EQ(rm.Size(), rm.rm_size_bits());\n+  ASSERT_TRUE(rm.is_NotEmpty());\n+  \/\/ Set_All sets AllStack bit\n+  ASSERT_TRUE(rm.is_AllStack());\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits());\n+}\n+\n+TEST_VM(RegMask, Set_ALL_From_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.Set_All_From(OptoReg::Name(42));\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits() - 42);\n+}\n+\n+TEST_VM(RegMask, Set_ALL_From_extended_grow) {\n+  RegMask rm(arena());\n+  rm.Set_All_From(first_extended() + OptoReg::Name(42));\n+  is_extended(rm);\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits() - first_extended() - 42);\n+}\n+\n+TEST_VM(RegMask, Clear_extended) {\n+  \/\/ Check that Clear doesn't leave any stray bits on extended RegMasks.\n+  RegMask rm(arena());\n+  rm.Insert(first_extended());\n+  is_extended(rm);\n+  rm.Set_All();\n+  rm.Clear();\n+  contains_expected_num_of_registers(rm, 0);\n+}\n+\n+TEST_VM(RegMask, AND_extended_basic) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.AND(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2;\n+  is_basic(rm2);\n+  rm1.AND(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, AND_extended_extended) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.AND(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  rm1.AND(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, OR_extended_basic) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.OR(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2;\n+  is_basic(rm2);\n+  rm1.OR(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, OR_extended_extended) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.OR(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  rm1.OR(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_extended) {\n+  RegMask rm1(arena());\n+  extend(rm1);\n+  RegMask rm2(arena());\n+  extend(rm2);\n+\n+  rm2.Set_All();\n+  ASSERT_TRUE(rm2.is_AllStack());\n+  for (int i = first_extended() + 17; i < (int)rm1.rm_size_bits(); i++) {\n+    rm1.Insert(i);\n+  }\n+  rm1.set_AllStack(true);\n+  ASSERT_TRUE(rm1.is_AllStack());\n+  rm2.SUBTRACT(rm1);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_bits() - first_extended() - 17);\n+  contains_expected_num_of_registers(rm2, first_extended() + 17);\n+}\n+\n+TEST_VM(RegMask, external_member_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.set_AllStack(false);\n+  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+  rm.set_AllStack(true);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+}\n+\n+TEST_VM(RegMask, overlap_extended) {\n+  RegMask rm1(arena());\n+  extend(rm1);\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(23));\n+  rm1.Insert(OptoReg::Name(2));\n+  rm1.Insert(OptoReg::Name(first_extended() + 12));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(first_extended() + 4));\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(first_extended() + 4));\n+  ASSERT_TRUE(rm1.overlap(rm2));\n+  ASSERT_TRUE(rm2.overlap(rm1));\n+}\n+\n+TEST_VM(RegMask, up_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  ASSERT_TRUE(rm.is_UP());\n+  rm.Insert(OptoReg::Name(1));\n+  ASSERT_TRUE(rm.is_UP());\n+  rm.Insert(OptoReg::Name(first_extended()));\n+  ASSERT_FALSE(rm.is_UP());\n+  rm.Clear();\n+  rm.set_AllStack(true);\n+  ASSERT_FALSE(rm.is_UP());\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner_basic_extended) {\n+  RegMask rm1;\n+  RegMask rm2(arena());\n+  rm1.Insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(42));\n+  is_basic(rm1);\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(first_extended() + 20));\n+  is_extended(rm2);\n+  rm1.SUBTRACT_inner(rm2);\n+  is_basic(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner_extended_basic) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  rm1.Insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(42));\n+  rm1.Insert(OptoReg::Name(first_extended() + 20));\n+  is_extended(rm1);\n+  rm2.Insert(OptoReg::Name(1));\n+  is_basic(rm2);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 2);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended() + 20)));\n+}\n+\n+TEST_VM(RegMask, rollover_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  is_extended(rm);\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Insert(reg1);\n+  ASSERT_TRUE(rm.Member(reg1));\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint_extended) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  extend(rm1);\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  rm1.set_AllStack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(42);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap_extended) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  extend(rm1);\n+  rm2.set_AllStack(true);\n+  rm2.rollover();\n+  rm2.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(reg1);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm1.Insert(reg1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+#endif \/\/ !PRODUCT\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":600,"deletions":2,"binary":false,"changes":602,"status":"modified"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8325467\n- * @summary Ensure C2 can compile methods with many arguments.\n- * @run main\/othervm -XX:CompileCommand=compileonly,compiler.arguments.TestManyMethodArguments::test\n- *                   -Xcomp\n- *                   -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+AbortVMOnCompilationFailure\n- *                   compiler.arguments.TestManyMethodArguments\n- *\/\n-\n-package compiler.arguments;\n-\n-public class TestManyMethodArguments {\n-    public static void main(String[] args) {\n-        try {\n-            test(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100);\n-        } catch (Exception e) {\n-            \/\/ Fine\n-        }\n-    }\n-\n-    public static long test(long x1, long x2, long x3, long x4, long x5, long x6, long x7, long x8, long x9, long x10, long x11, long x12, long x13, long x14, long x15, long x16, long x17, long x18, long x19, long x20, long x21, long x22, long x23, long x24, long x25, long x26, long x27, long x28, long x29, long x30, long x31, long x32, long x33, long x34, long x35, long x36, long x37, long x38, long x39, long x40, long x41, long x42, long x43, long x44, long x45, long x46, long x47, long x48, long x49, long x50, long x51, long x52, long x53, long x54, long x55, long x56, long x57, long x58, long x59, long x60, long x61, long x62, long x63, long x64, long x65, long x66, long x67, long x68, long x69, long x70, long x71, long x72, long x73, long x74, long x75, long x76, long x77, long x78, long x79, long x80, long x81, long x82, long x83, long x84, long x85, long x86, long x87, long x88, long x89, long x90, long x91, long x92, long x93, long x94, long x95, long x96, long x97, long x98, long x99, long x100) throws Exception {\n-        \/\/ Exceptions after every definition of a temporary forces the\n-        \/\/ evaluation order.\n-        long t1 = x1 % 101; if(t1 == 0) { throw new Exception(); }\n-        long t2 = x2 % 102; if(t2 == 0) { throw new Exception(); }\n-        long t3 = x3 % 103; if(t3 == 0) { throw new Exception(); }\n-        long t4 = x4 % 104; if(t4 == 0) { throw new Exception(); }\n-        long t5 = x5 % 105; if(t5 == 0) { throw new Exception(); }\n-        long t6 = x6 % 106; if(t6 == 0) { throw new Exception(); }\n-        long t7 = x7 % 107; if(t7 == 0) { throw new Exception(); }\n-        long t8 = x8 % 108; if(t8 == 0) { throw new Exception(); }\n-        long t9 = x9 % 109; if(t9 == 0) { throw new Exception(); }\n-        long t10 = x10 % 110; if(t10 == 0) { throw new Exception(); }\n-        long t11 = x11 % 111; if(t11 == 0) { throw new Exception(); }\n-        long t12 = x12 % 112; if(t12 == 0) { throw new Exception(); }\n-        long t13 = x13 % 113; if(t13 == 0) { throw new Exception(); }\n-        long t14 = x14 % 114; if(t14 == 0) { throw new Exception(); }\n-        long t15 = x15 % 115; if(t15 == 0) { throw new Exception(); }\n-        long t16 = x16 % 116; if(t16 == 0) { throw new Exception(); }\n-        long t17 = x17 % 117; if(t17 == 0) { throw new Exception(); }\n-        long t18 = x18 % 118; if(t18 == 0) { throw new Exception(); }\n-        long t19 = x19 % 119; if(t19 == 0) { throw new Exception(); }\n-        long t20 = x20 % 120; if(t20 == 0) { throw new Exception(); }\n-        long t21 = x21 % 121; if(t21 == 0) { throw new Exception(); }\n-        long t22 = x22 % 122; if(t22 == 0) { throw new Exception(); }\n-        long t23 = x23 % 123; if(t23 == 0) { throw new Exception(); }\n-        long t24 = x24 % 124; if(t24 == 0) { throw new Exception(); }\n-        long t25 = x25 % 125; if(t25 == 0) { throw new Exception(); }\n-        long t26 = x26 % 126; if(t26 == 0) { throw new Exception(); }\n-        long t27 = x27 % 127; if(t27 == 0) { throw new Exception(); }\n-        long t28 = x28 % 128; if(t28 == 0) { throw new Exception(); }\n-        long t29 = x29 % 129; if(t29 == 0) { throw new Exception(); }\n-        long t30 = x30 % 130; if(t30 == 0) { throw new Exception(); }\n-        long t31 = x31 % 131; if(t31 == 0) { throw new Exception(); }\n-        long t32 = x32 % 132; if(t32 == 0) { throw new Exception(); }\n-        long t33 = x33 % 133; if(t33 == 0) { throw new Exception(); }\n-        long t34 = x34 % 134; if(t34 == 0) { throw new Exception(); }\n-        long t35 = x35 % 135; if(t35 == 0) { throw new Exception(); }\n-        long t36 = x36 % 136; if(t36 == 0) { throw new Exception(); }\n-        long t37 = x37 % 137; if(t37 == 0) { throw new Exception(); }\n-        long t38 = x38 % 138; if(t38 == 0) { throw new Exception(); }\n-        long t39 = x39 % 139; if(t39 == 0) { throw new Exception(); }\n-        long t40 = x40 % 140; if(t40 == 0) { throw new Exception(); }\n-        long t41 = x41 % 141; if(t41 == 0) { throw new Exception(); }\n-        long t42 = x42 % 142; if(t42 == 0) { throw new Exception(); }\n-        long t43 = x43 % 143; if(t43 == 0) { throw new Exception(); }\n-        long t44 = x44 % 144; if(t44 == 0) { throw new Exception(); }\n-        long t45 = x45 % 145; if(t45 == 0) { throw new Exception(); }\n-        long t46 = x46 % 146; if(t46 == 0) { throw new Exception(); }\n-        long t47 = x47 % 147; if(t47 == 0) { throw new Exception(); }\n-        long t48 = x48 % 148; if(t48 == 0) { throw new Exception(); }\n-        long t49 = x49 % 149; if(t49 == 0) { throw new Exception(); }\n-        long t50 = x50 % 150; if(t50 == 0) { throw new Exception(); }\n-        long t51 = x51 % 151; if(t51 == 0) { throw new Exception(); }\n-        long t52 = x52 % 152; if(t52 == 0) { throw new Exception(); }\n-        long t53 = x53 % 153; if(t53 == 0) { throw new Exception(); }\n-        long t54 = x54 % 154; if(t54 == 0) { throw new Exception(); }\n-        long t55 = x55 % 155; if(t55 == 0) { throw new Exception(); }\n-        long t56 = x56 % 156; if(t56 == 0) { throw new Exception(); }\n-        long t57 = x57 % 157; if(t57 == 0) { throw new Exception(); }\n-        long t58 = x58 % 158; if(t58 == 0) { throw new Exception(); }\n-        long t59 = x59 % 159; if(t59 == 0) { throw new Exception(); }\n-        long t60 = x60 % 160; if(t60 == 0) { throw new Exception(); }\n-        long t61 = x61 % 161; if(t61 == 0) { throw new Exception(); }\n-        long t62 = x62 % 162; if(t62 == 0) { throw new Exception(); }\n-        long t63 = x63 % 163; if(t63 == 0) { throw new Exception(); }\n-        long t64 = x64 % 164; if(t64 == 0) { throw new Exception(); }\n-        long t65 = x65 % 165; if(t65 == 0) { throw new Exception(); }\n-        long t66 = x66 % 166; if(t66 == 0) { throw new Exception(); }\n-        long t67 = x67 % 167; if(t67 == 0) { throw new Exception(); }\n-        long t68 = x68 % 168; if(t68 == 0) { throw new Exception(); }\n-        long t69 = x69 % 169; if(t69 == 0) { throw new Exception(); }\n-        long t70 = x70 % 170; if(t70 == 0) { throw new Exception(); }\n-        long t71 = x71 % 171; if(t71 == 0) { throw new Exception(); }\n-        long t72 = x72 % 172; if(t72 == 0) { throw new Exception(); }\n-        long t73 = x73 % 173; if(t73 == 0) { throw new Exception(); }\n-        long t74 = x74 % 174; if(t74 == 0) { throw new Exception(); }\n-        long t75 = x75 % 175; if(t75 == 0) { throw new Exception(); }\n-        long t76 = x76 % 176; if(t76 == 0) { throw new Exception(); }\n-        long t77 = x77 % 177; if(t77 == 0) { throw new Exception(); }\n-        long t78 = x78 % 178; if(t78 == 0) { throw new Exception(); }\n-        long t79 = x79 % 179; if(t79 == 0) { throw new Exception(); }\n-        long t80 = x80 % 180; if(t80 == 0) { throw new Exception(); }\n-        long t81 = x81 % 181; if(t81 == 0) { throw new Exception(); }\n-        long t82 = x82 % 182; if(t82 == 0) { throw new Exception(); }\n-        long t83 = x83 % 183; if(t83 == 0) { throw new Exception(); }\n-        long t84 = x84 % 184; if(t84 == 0) { throw new Exception(); }\n-        long t85 = x85 % 185; if(t85 == 0) { throw new Exception(); }\n-        long t86 = x86 % 186; if(t86 == 0) { throw new Exception(); }\n-        long t87 = x87 % 187; if(t87 == 0) { throw new Exception(); }\n-        long t88 = x88 % 188; if(t88 == 0) { throw new Exception(); }\n-        long t89 = x89 % 189; if(t89 == 0) { throw new Exception(); }\n-        long t90 = x90 % 190; if(t90 == 0) { throw new Exception(); }\n-        long t91 = x91 % 191; if(t91 == 0) { throw new Exception(); }\n-        long t92 = x92 % 192; if(t92 == 0) { throw new Exception(); }\n-        long t93 = x93 % 193; if(t93 == 0) { throw new Exception(); }\n-        long t94 = x94 % 194; if(t94 == 0) { throw new Exception(); }\n-        long t95 = x95 % 195; if(t95 == 0) { throw new Exception(); }\n-        long t96 = x96 % 196; if(t96 == 0) { throw new Exception(); }\n-        long t97 = x97 % 197; if(t97 == 0) { throw new Exception(); }\n-        long t98 = x98 % 198; if(t98 == 0) { throw new Exception(); }\n-        long t99 = x99 % 199; if(t99 == 0) { throw new Exception(); }\n-        long t100 = x100 % 200; if(t100 == 0) { throw new Exception(); }\n-        \/\/ All temporaries are live here, stressing the register allocator.\n-        return t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17 + t18 + t19 + t20 + t21 + t22 + t23 + t24 + t25 + t26 + t27 + t28 + t29 + t30 + t31 + t32 + t33 + t34 + t35 + t36 + t37 + t38 + t39 + t40 + t41 + t42 + t43 + t44 + t45 + t46 + t47 + t48 + t49 + t50 + t51 + t52 + t53 + t54 + t55 + t56 + t57 + t58 + t59 + t60 + t61 + t62 + t63 + t64 + t65 + t66 + t67 + t68 + t69 + t70 + t71 + t72 + t73 + t74 + t75 + t76 + t77 + t78 + t79 + t80 + t81 + t82 + t83 + t84 + t85 + t86 + t87 + t88 + t89 + t90 + t91 + t92 + t93 + t94 + t95 + t96 + t97 + t98 + t99 + t100;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestManyMethodArguments.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325467\n+ * @summary Ensure C2 can compile methods with the maximum number of parameters\n+ *          (according to the JVM spec).\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.arguments.TestMaxMethodArguments::test\n+ *                   -Xcomp\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AbortVMOnCompilationFailure\n+ *                   compiler.arguments.TestMaxMethodArguments\n+ *\/\n+\n+package compiler.arguments;\n+\n+public class TestMaxMethodArguments {\n+    public static void main(String[] args) {\n+        try {\n+            test(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255);\n+        } catch (Exception e) {\n+            \/\/ Fine\n+        }\n+    }\n+\n+    public static int test(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8, int x9, int x10, int x11, int x12, int x13, int x14, int x15, int x16, int x17, int x18, int x19, int x20, int x21, int x22, int x23, int x24, int x25, int x26, int x27, int x28, int x29, int x30, int x31, int x32, int x33, int x34, int x35, int x36, int x37, int x38, int x39, int x40, int x41, int x42, int x43, int x44, int x45, int x46, int x47, int x48, int x49, int x50, int x51, int x52, int x53, int x54, int x55, int x56, int x57, int x58, int x59, int x60, int x61, int x62, int x63, int x64, int x65, int x66, int x67, int x68, int x69, int x70, int x71, int x72, int x73, int x74, int x75, int x76, int x77, int x78, int x79, int x80, int x81, int x82, int x83, int x84, int x85, int x86, int x87, int x88, int x89, int x90, int x91, int x92, int x93, int x94, int x95, int x96, int x97, int x98, int x99, int x100, int x101, int x102, int x103, int x104, int x105, int x106, int x107, int x108, int x109, int x110, int x111, int x112, int x113, int x114, int x115, int x116, int x117, int x118, int x119, int x120, int x121, int x122, int x123, int x124, int x125, int x126, int x127, int x128, int x129, int x130, int x131, int x132, int x133, int x134, int x135, int x136, int x137, int x138, int x139, int x140, int x141, int x142, int x143, int x144, int x145, int x146, int x147, int x148, int x149, int x150, int x151, int x152, int x153, int x154, int x155, int x156, int x157, int x158, int x159, int x160, int x161, int x162, int x163, int x164, int x165, int x166, int x167, int x168, int x169, int x170, int x171, int x172, int x173, int x174, int x175, int x176, int x177, int x178, int x179, int x180, int x181, int x182, int x183, int x184, int x185, int x186, int x187, int x188, int x189, int x190, int x191, int x192, int x193, int x194, int x195, int x196, int x197, int x198, int x199, int x200, int x201, int x202, int x203, int x204, int x205, int x206, int x207, int x208, int x209, int x210, int x211, int x212, int x213, int x214, int x215, int x216, int x217, int x218, int x219, int x220, int x221, int x222, int x223, int x224, int x225, int x226, int x227, int x228, int x229, int x230, int x231, int x232, int x233, int x234, int x235, int x236, int x237, int x238, int x239, int x240, int x241, int x242, int x243, int x244, int x245, int x246, int x247, int x248, int x249, int x250, int x251, int x252, int x253, int x254, int x255) throws Exception {\n+        \/\/ Exceptions after every definition of a temporary forces the\n+        \/\/ evaluation order.\n+        int t1 = x1 % 101; if(t1 == 0) { throw new Exception(); }\n+        int t2 = x2 % 102; if(t2 == 0) { throw new Exception(); }\n+        int t3 = x3 % 103; if(t3 == 0) { throw new Exception(); }\n+        int t4 = x4 % 104; if(t4 == 0) { throw new Exception(); }\n+        int t5 = x5 % 105; if(t5 == 0) { throw new Exception(); }\n+        int t6 = x6 % 106; if(t6 == 0) { throw new Exception(); }\n+        int t7 = x7 % 107; if(t7 == 0) { throw new Exception(); }\n+        int t8 = x8 % 108; if(t8 == 0) { throw new Exception(); }\n+        int t9 = x9 % 109; if(t9 == 0) { throw new Exception(); }\n+        int t10 = x10 % 110; if(t10 == 0) { throw new Exception(); }\n+        int t11 = x11 % 111; if(t11 == 0) { throw new Exception(); }\n+        int t12 = x12 % 112; if(t12 == 0) { throw new Exception(); }\n+        int t13 = x13 % 113; if(t13 == 0) { throw new Exception(); }\n+        int t14 = x14 % 114; if(t14 == 0) { throw new Exception(); }\n+        int t15 = x15 % 115; if(t15 == 0) { throw new Exception(); }\n+        int t16 = x16 % 116; if(t16 == 0) { throw new Exception(); }\n+        int t17 = x17 % 117; if(t17 == 0) { throw new Exception(); }\n+        int t18 = x18 % 118; if(t18 == 0) { throw new Exception(); }\n+        int t19 = x19 % 119; if(t19 == 0) { throw new Exception(); }\n+        int t20 = x20 % 120; if(t20 == 0) { throw new Exception(); }\n+        int t21 = x21 % 121; if(t21 == 0) { throw new Exception(); }\n+        int t22 = x22 % 122; if(t22 == 0) { throw new Exception(); }\n+        int t23 = x23 % 123; if(t23 == 0) { throw new Exception(); }\n+        int t24 = x24 % 124; if(t24 == 0) { throw new Exception(); }\n+        int t25 = x25 % 125; if(t25 == 0) { throw new Exception(); }\n+        int t26 = x26 % 126; if(t26 == 0) { throw new Exception(); }\n+        int t27 = x27 % 127; if(t27 == 0) { throw new Exception(); }\n+        int t28 = x28 % 128; if(t28 == 0) { throw new Exception(); }\n+        int t29 = x29 % 129; if(t29 == 0) { throw new Exception(); }\n+        int t30 = x30 % 130; if(t30 == 0) { throw new Exception(); }\n+        int t31 = x31 % 131; if(t31 == 0) { throw new Exception(); }\n+        int t32 = x32 % 132; if(t32 == 0) { throw new Exception(); }\n+        int t33 = x33 % 133; if(t33 == 0) { throw new Exception(); }\n+        int t34 = x34 % 134; if(t34 == 0) { throw new Exception(); }\n+        int t35 = x35 % 135; if(t35 == 0) { throw new Exception(); }\n+        int t36 = x36 % 136; if(t36 == 0) { throw new Exception(); }\n+        int t37 = x37 % 137; if(t37 == 0) { throw new Exception(); }\n+        int t38 = x38 % 138; if(t38 == 0) { throw new Exception(); }\n+        int t39 = x39 % 139; if(t39 == 0) { throw new Exception(); }\n+        int t40 = x40 % 140; if(t40 == 0) { throw new Exception(); }\n+        int t41 = x41 % 141; if(t41 == 0) { throw new Exception(); }\n+        int t42 = x42 % 142; if(t42 == 0) { throw new Exception(); }\n+        int t43 = x43 % 143; if(t43 == 0) { throw new Exception(); }\n+        int t44 = x44 % 144; if(t44 == 0) { throw new Exception(); }\n+        int t45 = x45 % 145; if(t45 == 0) { throw new Exception(); }\n+        int t46 = x46 % 146; if(t46 == 0) { throw new Exception(); }\n+        int t47 = x47 % 147; if(t47 == 0) { throw new Exception(); }\n+        int t48 = x48 % 148; if(t48 == 0) { throw new Exception(); }\n+        int t49 = x49 % 149; if(t49 == 0) { throw new Exception(); }\n+        int t50 = x50 % 150; if(t50 == 0) { throw new Exception(); }\n+        int t51 = x51 % 151; if(t51 == 0) { throw new Exception(); }\n+        int t52 = x52 % 152; if(t52 == 0) { throw new Exception(); }\n+        int t53 = x53 % 153; if(t53 == 0) { throw new Exception(); }\n+        int t54 = x54 % 154; if(t54 == 0) { throw new Exception(); }\n+        int t55 = x55 % 155; if(t55 == 0) { throw new Exception(); }\n+        int t56 = x56 % 156; if(t56 == 0) { throw new Exception(); }\n+        int t57 = x57 % 157; if(t57 == 0) { throw new Exception(); }\n+        int t58 = x58 % 158; if(t58 == 0) { throw new Exception(); }\n+        int t59 = x59 % 159; if(t59 == 0) { throw new Exception(); }\n+        int t60 = x60 % 160; if(t60 == 0) { throw new Exception(); }\n+        int t61 = x61 % 161; if(t61 == 0) { throw new Exception(); }\n+        int t62 = x62 % 162; if(t62 == 0) { throw new Exception(); }\n+        int t63 = x63 % 163; if(t63 == 0) { throw new Exception(); }\n+        int t64 = x64 % 164; if(t64 == 0) { throw new Exception(); }\n+        int t65 = x65 % 165; if(t65 == 0) { throw new Exception(); }\n+        int t66 = x66 % 166; if(t66 == 0) { throw new Exception(); }\n+        int t67 = x67 % 167; if(t67 == 0) { throw new Exception(); }\n+        int t68 = x68 % 168; if(t68 == 0) { throw new Exception(); }\n+        int t69 = x69 % 169; if(t69 == 0) { throw new Exception(); }\n+        int t70 = x70 % 170; if(t70 == 0) { throw new Exception(); }\n+        int t71 = x71 % 171; if(t71 == 0) { throw new Exception(); }\n+        int t72 = x72 % 172; if(t72 == 0) { throw new Exception(); }\n+        int t73 = x73 % 173; if(t73 == 0) { throw new Exception(); }\n+        int t74 = x74 % 174; if(t74 == 0) { throw new Exception(); }\n+        int t75 = x75 % 175; if(t75 == 0) { throw new Exception(); }\n+        int t76 = x76 % 176; if(t76 == 0) { throw new Exception(); }\n+        int t77 = x77 % 177; if(t77 == 0) { throw new Exception(); }\n+        int t78 = x78 % 178; if(t78 == 0) { throw new Exception(); }\n+        int t79 = x79 % 179; if(t79 == 0) { throw new Exception(); }\n+        int t80 = x80 % 180; if(t80 == 0) { throw new Exception(); }\n+        int t81 = x81 % 181; if(t81 == 0) { throw new Exception(); }\n+        int t82 = x82 % 182; if(t82 == 0) { throw new Exception(); }\n+        int t83 = x83 % 183; if(t83 == 0) { throw new Exception(); }\n+        int t84 = x84 % 184; if(t84 == 0) { throw new Exception(); }\n+        int t85 = x85 % 185; if(t85 == 0) { throw new Exception(); }\n+        int t86 = x86 % 186; if(t86 == 0) { throw new Exception(); }\n+        int t87 = x87 % 187; if(t87 == 0) { throw new Exception(); }\n+        int t88 = x88 % 188; if(t88 == 0) { throw new Exception(); }\n+        int t89 = x89 % 189; if(t89 == 0) { throw new Exception(); }\n+        int t90 = x90 % 190; if(t90 == 0) { throw new Exception(); }\n+        int t91 = x91 % 191; if(t91 == 0) { throw new Exception(); }\n+        int t92 = x92 % 192; if(t92 == 0) { throw new Exception(); }\n+        int t93 = x93 % 193; if(t93 == 0) { throw new Exception(); }\n+        int t94 = x94 % 194; if(t94 == 0) { throw new Exception(); }\n+        int t95 = x95 % 195; if(t95 == 0) { throw new Exception(); }\n+        int t96 = x96 % 196; if(t96 == 0) { throw new Exception(); }\n+        int t97 = x97 % 197; if(t97 == 0) { throw new Exception(); }\n+        int t98 = x98 % 198; if(t98 == 0) { throw new Exception(); }\n+        int t99 = x99 % 199; if(t99 == 0) { throw new Exception(); }\n+        int t100 = x100 % 200; if(t100 == 0) { throw new Exception(); }\n+        int t101 = x101 % 201; if(t101 == 0) { throw new Exception(); }\n+        int t102 = x102 % 202; if(t102 == 0) { throw new Exception(); }\n+        int t103 = x103 % 203; if(t103 == 0) { throw new Exception(); }\n+        int t104 = x104 % 204; if(t104 == 0) { throw new Exception(); }\n+        int t105 = x105 % 205; if(t105 == 0) { throw new Exception(); }\n+        int t106 = x106 % 206; if(t106 == 0) { throw new Exception(); }\n+        int t107 = x107 % 207; if(t107 == 0) { throw new Exception(); }\n+        int t108 = x108 % 208; if(t108 == 0) { throw new Exception(); }\n+        int t109 = x109 % 209; if(t109 == 0) { throw new Exception(); }\n+        int t110 = x110 % 210; if(t110 == 0) { throw new Exception(); }\n+        int t111 = x111 % 211; if(t111 == 0) { throw new Exception(); }\n+        int t112 = x112 % 212; if(t112 == 0) { throw new Exception(); }\n+        int t113 = x113 % 213; if(t113 == 0) { throw new Exception(); }\n+        int t114 = x114 % 214; if(t114 == 0) { throw new Exception(); }\n+        int t115 = x115 % 215; if(t115 == 0) { throw new Exception(); }\n+        int t116 = x116 % 216; if(t116 == 0) { throw new Exception(); }\n+        int t117 = x117 % 217; if(t117 == 0) { throw new Exception(); }\n+        int t118 = x118 % 218; if(t118 == 0) { throw new Exception(); }\n+        int t119 = x119 % 219; if(t119 == 0) { throw new Exception(); }\n+        int t120 = x120 % 220; if(t120 == 0) { throw new Exception(); }\n+        int t121 = x121 % 221; if(t121 == 0) { throw new Exception(); }\n+        int t122 = x122 % 222; if(t122 == 0) { throw new Exception(); }\n+        int t123 = x123 % 223; if(t123 == 0) { throw new Exception(); }\n+        int t124 = x124 % 224; if(t124 == 0) { throw new Exception(); }\n+        int t125 = x125 % 225; if(t125 == 0) { throw new Exception(); }\n+        int t126 = x126 % 226; if(t126 == 0) { throw new Exception(); }\n+        int t127 = x127 % 227; if(t127 == 0) { throw new Exception(); }\n+        int t128 = x128 % 228; if(t128 == 0) { throw new Exception(); }\n+        int t129 = x129 % 229; if(t129 == 0) { throw new Exception(); }\n+        int t130 = x130 % 230; if(t130 == 0) { throw new Exception(); }\n+        int t131 = x131 % 231; if(t131 == 0) { throw new Exception(); }\n+        int t132 = x132 % 232; if(t132 == 0) { throw new Exception(); }\n+        int t133 = x133 % 233; if(t133 == 0) { throw new Exception(); }\n+        int t134 = x134 % 234; if(t134 == 0) { throw new Exception(); }\n+        int t135 = x135 % 235; if(t135 == 0) { throw new Exception(); }\n+        int t136 = x136 % 236; if(t136 == 0) { throw new Exception(); }\n+        int t137 = x137 % 237; if(t137 == 0) { throw new Exception(); }\n+        int t138 = x138 % 238; if(t138 == 0) { throw new Exception(); }\n+        int t139 = x139 % 239; if(t139 == 0) { throw new Exception(); }\n+        int t140 = x140 % 240; if(t140 == 0) { throw new Exception(); }\n+        int t141 = x141 % 241; if(t141 == 0) { throw new Exception(); }\n+        int t142 = x142 % 242; if(t142 == 0) { throw new Exception(); }\n+        int t143 = x143 % 243; if(t143 == 0) { throw new Exception(); }\n+        int t144 = x144 % 244; if(t144 == 0) { throw new Exception(); }\n+        int t145 = x145 % 245; if(t145 == 0) { throw new Exception(); }\n+        int t146 = x146 % 246; if(t146 == 0) { throw new Exception(); }\n+        int t147 = x147 % 247; if(t147 == 0) { throw new Exception(); }\n+        int t148 = x148 % 248; if(t148 == 0) { throw new Exception(); }\n+        int t149 = x149 % 249; if(t149 == 0) { throw new Exception(); }\n+        int t150 = x150 % 250; if(t150 == 0) { throw new Exception(); }\n+        int t151 = x151 % 251; if(t151 == 0) { throw new Exception(); }\n+        int t152 = x152 % 252; if(t152 == 0) { throw new Exception(); }\n+        int t153 = x153 % 253; if(t153 == 0) { throw new Exception(); }\n+        int t154 = x154 % 254; if(t154 == 0) { throw new Exception(); }\n+        int t155 = x155 % 255; if(t155 == 0) { throw new Exception(); }\n+        int t156 = x156 % 256; if(t156 == 0) { throw new Exception(); }\n+        int t157 = x157 % 257; if(t157 == 0) { throw new Exception(); }\n+        int t158 = x158 % 258; if(t158 == 0) { throw new Exception(); }\n+        int t159 = x159 % 259; if(t159 == 0) { throw new Exception(); }\n+        int t160 = x160 % 260; if(t160 == 0) { throw new Exception(); }\n+        int t161 = x161 % 261; if(t161 == 0) { throw new Exception(); }\n+        int t162 = x162 % 262; if(t162 == 0) { throw new Exception(); }\n+        int t163 = x163 % 263; if(t163 == 0) { throw new Exception(); }\n+        int t164 = x164 % 264; if(t164 == 0) { throw new Exception(); }\n+        int t165 = x165 % 265; if(t165 == 0) { throw new Exception(); }\n+        int t166 = x166 % 266; if(t166 == 0) { throw new Exception(); }\n+        int t167 = x167 % 267; if(t167 == 0) { throw new Exception(); }\n+        int t168 = x168 % 268; if(t168 == 0) { throw new Exception(); }\n+        int t169 = x169 % 269; if(t169 == 0) { throw new Exception(); }\n+        int t170 = x170 % 270; if(t170 == 0) { throw new Exception(); }\n+        int t171 = x171 % 271; if(t171 == 0) { throw new Exception(); }\n+        int t172 = x172 % 272; if(t172 == 0) { throw new Exception(); }\n+        int t173 = x173 % 273; if(t173 == 0) { throw new Exception(); }\n+        int t174 = x174 % 274; if(t174 == 0) { throw new Exception(); }\n+        int t175 = x175 % 275; if(t175 == 0) { throw new Exception(); }\n+        int t176 = x176 % 276; if(t176 == 0) { throw new Exception(); }\n+        int t177 = x177 % 277; if(t177 == 0) { throw new Exception(); }\n+        int t178 = x178 % 278; if(t178 == 0) { throw new Exception(); }\n+        int t179 = x179 % 279; if(t179 == 0) { throw new Exception(); }\n+        int t180 = x180 % 280; if(t180 == 0) { throw new Exception(); }\n+        int t181 = x181 % 281; if(t181 == 0) { throw new Exception(); }\n+        int t182 = x182 % 282; if(t182 == 0) { throw new Exception(); }\n+        int t183 = x183 % 283; if(t183 == 0) { throw new Exception(); }\n+        int t184 = x184 % 284; if(t184 == 0) { throw new Exception(); }\n+        int t185 = x185 % 285; if(t185 == 0) { throw new Exception(); }\n+        int t186 = x186 % 286; if(t186 == 0) { throw new Exception(); }\n+        int t187 = x187 % 287; if(t187 == 0) { throw new Exception(); }\n+        int t188 = x188 % 288; if(t188 == 0) { throw new Exception(); }\n+        int t189 = x189 % 289; if(t189 == 0) { throw new Exception(); }\n+        int t190 = x190 % 290; if(t190 == 0) { throw new Exception(); }\n+        int t191 = x191 % 291; if(t191 == 0) { throw new Exception(); }\n+        int t192 = x192 % 292; if(t192 == 0) { throw new Exception(); }\n+        int t193 = x193 % 293; if(t193 == 0) { throw new Exception(); }\n+        int t194 = x194 % 294; if(t194 == 0) { throw new Exception(); }\n+        int t195 = x195 % 295; if(t195 == 0) { throw new Exception(); }\n+        int t196 = x196 % 296; if(t196 == 0) { throw new Exception(); }\n+        int t197 = x197 % 297; if(t197 == 0) { throw new Exception(); }\n+        int t198 = x198 % 298; if(t198 == 0) { throw new Exception(); }\n+        int t199 = x199 % 299; if(t199 == 0) { throw new Exception(); }\n+        int t200 = x200 % 300; if(t200 == 0) { throw new Exception(); }\n+        int t201 = x201 % 301; if(t201 == 0) { throw new Exception(); }\n+        int t202 = x202 % 302; if(t202 == 0) { throw new Exception(); }\n+        int t203 = x203 % 303; if(t203 == 0) { throw new Exception(); }\n+        int t204 = x204 % 304; if(t204 == 0) { throw new Exception(); }\n+        int t205 = x205 % 305; if(t205 == 0) { throw new Exception(); }\n+        int t206 = x206 % 306; if(t206 == 0) { throw new Exception(); }\n+        int t207 = x207 % 307; if(t207 == 0) { throw new Exception(); }\n+        int t208 = x208 % 308; if(t208 == 0) { throw new Exception(); }\n+        int t209 = x209 % 309; if(t209 == 0) { throw new Exception(); }\n+        int t210 = x210 % 310; if(t210 == 0) { throw new Exception(); }\n+        int t211 = x211 % 311; if(t211 == 0) { throw new Exception(); }\n+        int t212 = x212 % 312; if(t212 == 0) { throw new Exception(); }\n+        int t213 = x213 % 313; if(t213 == 0) { throw new Exception(); }\n+        int t214 = x214 % 314; if(t214 == 0) { throw new Exception(); }\n+        int t215 = x215 % 315; if(t215 == 0) { throw new Exception(); }\n+        int t216 = x216 % 316; if(t216 == 0) { throw new Exception(); }\n+        int t217 = x217 % 317; if(t217 == 0) { throw new Exception(); }\n+        int t218 = x218 % 318; if(t218 == 0) { throw new Exception(); }\n+        int t219 = x219 % 319; if(t219 == 0) { throw new Exception(); }\n+        int t220 = x220 % 320; if(t220 == 0) { throw new Exception(); }\n+        int t221 = x221 % 321; if(t221 == 0) { throw new Exception(); }\n+        int t222 = x222 % 322; if(t222 == 0) { throw new Exception(); }\n+        int t223 = x223 % 323; if(t223 == 0) { throw new Exception(); }\n+        int t224 = x224 % 324; if(t224 == 0) { throw new Exception(); }\n+        int t225 = x225 % 325; if(t225 == 0) { throw new Exception(); }\n+        int t226 = x226 % 326; if(t226 == 0) { throw new Exception(); }\n+        int t227 = x227 % 327; if(t227 == 0) { throw new Exception(); }\n+        int t228 = x228 % 328; if(t228 == 0) { throw new Exception(); }\n+        int t229 = x229 % 329; if(t229 == 0) { throw new Exception(); }\n+        int t230 = x230 % 330; if(t230 == 0) { throw new Exception(); }\n+        int t231 = x231 % 331; if(t231 == 0) { throw new Exception(); }\n+        int t232 = x232 % 332; if(t232 == 0) { throw new Exception(); }\n+        int t233 = x233 % 333; if(t233 == 0) { throw new Exception(); }\n+        int t234 = x234 % 334; if(t234 == 0) { throw new Exception(); }\n+        int t235 = x235 % 335; if(t235 == 0) { throw new Exception(); }\n+        int t236 = x236 % 336; if(t236 == 0) { throw new Exception(); }\n+        int t237 = x237 % 337; if(t237 == 0) { throw new Exception(); }\n+        int t238 = x238 % 338; if(t238 == 0) { throw new Exception(); }\n+        int t239 = x239 % 339; if(t239 == 0) { throw new Exception(); }\n+        int t240 = x240 % 340; if(t240 == 0) { throw new Exception(); }\n+        int t241 = x241 % 341; if(t241 == 0) { throw new Exception(); }\n+        int t242 = x242 % 342; if(t242 == 0) { throw new Exception(); }\n+        int t243 = x243 % 343; if(t243 == 0) { throw new Exception(); }\n+        int t244 = x244 % 344; if(t244 == 0) { throw new Exception(); }\n+        int t245 = x245 % 345; if(t245 == 0) { throw new Exception(); }\n+        int t246 = x246 % 346; if(t246 == 0) { throw new Exception(); }\n+        int t247 = x247 % 347; if(t247 == 0) { throw new Exception(); }\n+        int t248 = x248 % 348; if(t248 == 0) { throw new Exception(); }\n+        int t249 = x249 % 349; if(t249 == 0) { throw new Exception(); }\n+        int t250 = x250 % 350; if(t250 == 0) { throw new Exception(); }\n+        int t251 = x251 % 351; if(t251 == 0) { throw new Exception(); }\n+        int t252 = x252 % 352; if(t252 == 0) { throw new Exception(); }\n+        int t253 = x253 % 353; if(t253 == 0) { throw new Exception(); }\n+        int t254 = x254 % 354; if(t254 == 0) { throw new Exception(); }\n+        int t255 = x255 % 355; if(t255 == 0) { throw new Exception(); }\n+        \/\/ All temporaries are live here, stressing the register allocator.\n+        return t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17 + t18 + t19 + t20 + t21 + t22 + t23 + t24 + t25 + t26 + t27 + t28 + t29 + t30 + t31 + t32 + t33 + t34 + t35 + t36 + t37 + t38 + t39 + t40 + t41 + t42 + t43 + t44 + t45 + t46 + t47 + t48 + t49 + t50 + t51 + t52 + t53 + t54 + t55 + t56 + t57 + t58 + t59 + t60 + t61 + t62 + t63 + t64 + t65 + t66 + t67 + t68 + t69 + t70 + t71 + t72 + t73 + t74 + t75 + t76 + t77 + t78 + t79 + t80 + t81 + t82 + t83 + t84 + t85 + t86 + t87 + t88 + t89 + t90 + t91 + t92 + t93 + t94 + t95 + t96 + t97 + t98 + t99 + t100 + t101 + t102 + t103 + t104 + t105 + t106 + t107 + t108 + t109 + t110 + t111 + t112 + t113 + t114 + t115 + t116 + t117 + t118 + t119 + t120 + t121 + t122 + t123 + t124 + t125 + t126 + t127 + t128 + t129 + t130 + t131 + t132 + t133 + t134 + t135 + t136 + t137 + t138 + t139 + t140 + t141 + t142 + t143 + t144 + t145 + t146 + t147 + t148 + t149 + t150 + t151 + t152 + t153 + t154 + t155 + t156 + t157 + t158 + t159 + t160 + t161 + t162 + t163 + t164 + t165 + t166 + t167 + t168 + t169 + t170 + t171 + t172 + t173 + t174 + t175 + t176 + t177 + t178 + t179 + t180 + t181 + t182 + t183 + t184 + t185 + t186 + t187 + t188 + t189 + t190 + t191 + t192 + t193 + t194 + t195 + t196 + t197 + t198 + t199 + t200 + t201 + t202 + t203 + t204 + t205 + t206 + t207 + t208 + t209 + t210 + t211 + t212 + t213 + t214 + t215 + t216 + t217 + t218 + t219 + t220 + t221 + t222 + t223 + t224 + t225 + t226 + t227 + t228 + t229 + t230 + t231 + t232 + t233 + t234 + t235 + t236 + t237 + t238 + t239 + t240 + t241 + t242 + t243 + t244 + t245 + t246 + t247 + t248 + t249 + t250 + t251 + t252 + t253 + t254 + t255;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestMaxMethodArguments.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"}]}