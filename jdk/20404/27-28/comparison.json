{"files":[{"patch":"@@ -1659,2 +1659,4 @@\n-    \/\/ If we fail to color and the infinite flag is set, trigger\n-    \/\/ a chunk-rollover event\n+    \/\/ If we fail to color and the infinite flag is set, we must trigger\n+    \/\/ a chunk-rollover event and continue searching for a color in the next set\n+    \/\/ of slots (which are all necessarily stack slots, as registers are only in\n+    \/\/ the initial chunk)\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-          if( !value[ureg] ) {\n+          if( value[ureg] == nullptr ) {\n@@ -684,1 +684,1 @@\n-              if (!value[ureg_lo] && is_adjacent) { \/\/ Nearly always adjacent\n+              if (value[ureg_lo] == nullptr && is_adjacent) { \/\/ Nearly always adjacent\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-  \/\/ We support offsetting\/shifting register masks to explicitly represent stack\n+  \/\/ We support offsetting\/shifting register masks to make explicit stack\n@@ -224,3 +224,4 @@\n-  \/\/ spilled values. The _offset variable indicates how many words we offset\n-  \/\/ with. We consider all registers before the offset to not be included in the\n-  \/\/ register mask.\n+  \/\/ spilled values. Spilled values *must* get a stack slot, and therefore have\n+  \/\/ _infinite_stack=true. If we run out of stack slots in an\n+  \/\/ _infinite_mask=true register mask, we roll over the register mask to make\n+  \/\/ the next set of stack slots available for selection.\n@@ -228,0 +229,3 @@\n+  \/\/ The _offset variable indicates how many words we offset with.\n+  \/\/ We consider all registers before the offset to not be included in the\n+  \/\/ register mask.\n@@ -441,1 +445,1 @@\n-      : _rm_word() DEBUG_ONLY(COMMA _arena(arena)), _read_only(read_only),\n+      : _rm_word(), _arena(arena) DEBUG_ONLY(COMMA _read_only(read_only)),\n@@ -850,1 +854,1 @@\n-  unsigned int static basic_rm_size_in_words() {\n+  unsigned int static gtest_basic_rm_size_in_words() {\n@@ -854,1 +858,1 @@\n-  unsigned int static rm_size_in_bits_max() {\n+  unsigned int static gtest_rm_size_in_bits_max() {\n@@ -858,1 +862,1 @@\n-  bool equals(const RegMask& rm) const {\n+  bool gtest_equals(const RegMask& rm) const {\n@@ -886,1 +890,1 @@\n-  void set_offset(unsigned int offset) {\n+  void gtest_set_offset(unsigned int offset) {\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-  ASSERT_EQ(rm.rm_size_in_words(), RegMask::basic_rm_size_in_words());\n+  ASSERT_EQ(rm.rm_size_in_words(), RegMask::gtest_basic_rm_size_in_words());\n@@ -509,1 +509,1 @@\n-  ASSERT_TRUE(rm.rm_size_in_words() > RegMask::basic_rm_size_in_words());\n+  ASSERT_TRUE(rm.rm_size_in_words() > RegMask::gtest_basic_rm_size_in_words());\n@@ -513,1 +513,1 @@\n-  return RegMask::basic_rm_size_in_words() * BitsPerWord;\n+  return RegMask::gtest_basic_rm_size_in_words() * BitsPerWord;\n@@ -520,1 +520,1 @@\n-  ASSERT_TRUE(rm.rm_size_in_words() >= RegMask::basic_rm_size_in_words() + n);\n+  ASSERT_TRUE(rm.rm_size_in_words() >= RegMask::gtest_basic_rm_size_in_words() + n);\n@@ -866,1 +866,1 @@\n-    if (offset + RegMask::rm_size_in_bits_max() > mask_aux_ref.size()) {\n+    if (offset + RegMask::gtest_rm_size_in_bits_max() > mask_aux_ref.size()) {\n@@ -871,1 +871,1 @@\n-  mask_aux.set_offset(offset \/ BitsPerWord);\n+  mask_aux.gtest_set_offset(offset \/ BitsPerWord);\n@@ -883,1 +883,1 @@\n-    max_size = RegMask::rm_size_in_bits_max();\n+    max_size = RegMask::gtest_rm_size_in_bits_max();\n@@ -956,1 +956,1 @@\n-      reg = (next_random() % RegMask::rm_size_in_bits_max()) + offset_ref;\n+      reg = (next_random() % RegMask::gtest_rm_size_in_bits_max()) + offset_ref;\n@@ -1088,1 +1088,1 @@\n-      mask.set_offset(0);\n+      mask.gtest_set_offset(0);\n@@ -1139,1 +1139,1 @@\n-    if (reg >= RegMask::rm_size_in_bits_max()) {\n+    if (reg >= RegMask::gtest_rm_size_in_bits_max()) {\n@@ -1184,1 +1184,1 @@\n-    bool passed = src.equals(dst);\n+    bool passed = src.gtest_equals(dst);\n@@ -1214,1 +1214,1 @@\n-    bool passed = src.equals(dst);\n+    bool passed = src.gtest_equals(dst);\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    public static Template.ZeroArgs generateTest(PrimitiveType t, int numberOfArguments) {\n+    public static Template.ZeroArgs generateTest(PrimitiveType type, int numberOfArguments) {\n@@ -56,1 +56,1 @@\n-                .mapToObj(i -> t.name() + \" x\" + i)\n+                .mapToObj(i -> type.name() + \" x\" + i)\n@@ -63,2 +63,2 @@\n-                Template.let(\"type\", t.name()),\n-                Template.let(\"boxedType\", t.boxedTypeName()),\n+                Template.let(\"type\", type.name()),\n+                Template.let(\"boxedType\", type.boxedTypeName()),\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestMethodArguments.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}