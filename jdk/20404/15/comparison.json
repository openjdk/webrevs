{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,0 +165,5 @@\n+\/\/ Compute the least number of words required for registers in register masks.\n+int RegisterForm::words_for_regs() {\n+  return (_reg_ctr + 31) >> 5;\n+}\n+\n@@ -167,6 +172,3 @@\n-  \/\/ Need at least this many words\n-  int words_for_regs = (_reg_ctr + 31)>>5;\n-  \/\/ The array of Register Mask bits should be large enough to cover\n-  \/\/ all the machine registers and all parameters that need to be passed\n-  \/\/ on the stack (stack registers) up to some interesting limit.  Methods\n-  \/\/ that need more parameters will NOT be compiled.  On Intel, the limit\n+  \/\/ The array of Register Mask bits should be large enough to cover all the\n+  \/\/ machine registers and usually all parameters that need to be passed on the\n+  \/\/ stack (stack registers) up to some interesting limit. On Intel, the limit\n@@ -180,1 +182,1 @@\n-  return (words_for_regs + 3 + 1 + 1) & ~1;\n+  return (words_for_regs() + 3 + 1 + 1) & ~1;\n@@ -372,1 +374,1 @@\n-  fprintf(fp,\" 0x%x );\\n\", regs_in_word(i, false));\n+  fprintf(fp, \" 0x%x, false );\\n\", regs_in_word(i, false));\n@@ -379,1 +381,1 @@\n-    fprintf(fp,\" 0x%x );\\n\", regs_in_word(i, true));\n+    fprintf(fp, \" 0x%x, true );\\n\", regs_in_word(i, true));\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,2 @@\n+  static int  words_for_regs(); \/\/ Compute the least number of words required for\n+                                \/\/ registers in register masks.\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  fprintf(fp_hpp, \"\/\/ Minimum size of register-mask in ints\\n\");\n+  fprintf(fp_hpp, \"#define RM_SIZE_MIN %d\\n\", RegisterForm::words_for_regs());\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1223,1 +1223,1 @@\n-    if (new_live.is_NotEmpty()) {\n+    if (!new_live.is_Empty()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  FN(regmask,     C2 Short-Lived Register Mask Arena) \\\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -553,0 +553,3 @@\n+  if (C->failing()) {\n+    return;\n+  }\n@@ -627,0 +630,3 @@\n+    if (C->failing()) {\n+      return;\n+    }\n@@ -757,1 +763,1 @@\n-      _lrg_map.map(n->_idx, rm.is_NotEmpty() ? lr_counter++ : 0);\n+      _lrg_map.map(n->_idx, !rm.is_Empty() ? lr_counter++ : 0);\n@@ -778,1 +784,1 @@\n-      _lrg_map.map(n->_idx, rm.is_NotEmpty() ? n->_idx : 0);\n+      _lrg_map.map(n->_idx, !rm.is_Empty() ? n->_idx : 0);\n@@ -1388,3 +1394,2 @@\n-static bool is_legal_reg(LRG &lrg, OptoReg::Name reg, int chunk) {\n-  if (reg >= chunk && reg < (chunk + RegMask::CHUNK_SIZE) &&\n-      lrg.mask().Member(OptoReg::add(reg,-chunk))) {\n+static bool is_legal_reg(LRG& lrg, OptoReg::Name reg) {\n+  if (lrg.mask().can_represent(reg) && lrg.mask().Member(reg)) {\n@@ -1413,1 +1418,1 @@\n-static OptoReg::Name find_first_set(LRG &lrg, RegMask mask, int chunk) {\n+static OptoReg::Name find_first_set(LRG& lrg, RegMask& mask) {\n@@ -1419,1 +1424,3 @@\n-    if (chunk == 0 && OptoReg::is_reg(assigned)) {\n+    if (OptoReg::is_reg(assigned)) {\n+      assert(!lrg.mask().is_offset(),\n+             \"offset register masks can only contain stack slots\");\n@@ -1435,1 +1442,2 @@\n-      while (OptoReg::is_valid(assigned) && RegMask::can_represent(assigned)) {\n+      while (OptoReg::is_valid(assigned)) {\n+        assert(mask.can_represent(assigned), \"sanity\");\n@@ -1459,1 +1467,1 @@\n-OptoReg::Name PhaseChaitin::bias_color( LRG &lrg, int chunk ) {\n+OptoReg::Name PhaseChaitin::bias_color(LRG& lrg) {\n@@ -1473,1 +1481,1 @@\n-      if (is_legal_reg(lrg, reg, chunk))\n+      if (is_legal_reg(lrg, reg)) {\n@@ -1475,0 +1483,1 @@\n+      }\n@@ -1484,1 +1493,1 @@\n-      if (is_legal_reg(lrg, reg, chunk))\n+      if (is_legal_reg(lrg, reg)) {\n@@ -1486,1 +1495,2 @@\n-    } else if( chunk == 0 ) {\n+      }\n+    } else if (!lrg.mask().is_offset()) {\n@@ -1488,1 +1498,2 @@\n-      RegMask tempmask = lrg.mask();\n+      ResourceMark rm(C->regmask_arena());\n+      RegMask tempmask(lrg.mask(), C->regmask_arena());\n@@ -1491,1 +1502,1 @@\n-      OptoReg::Name reg = find_first_set(lrg, tempmask, chunk);\n+      OptoReg::Name reg = find_first_set(lrg, tempmask);\n@@ -1500,1 +1511,3 @@\n-    return OptoReg::add(find_first_set(lrg, lrg.mask(), chunk), chunk);\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask tempmask(lrg.mask(), C->regmask_arena());\n+    return find_first_set(lrg, tempmask);\n@@ -1513,1 +1526,1 @@\n-    if( OptoReg::is_reg(reg2))\n+    if (OptoReg::is_reg(reg2)) {\n@@ -1515,0 +1528,1 @@\n+    }\n@@ -1516,1 +1530,1 @@\n-  return OptoReg::add( reg, chunk );\n+  return reg;\n@@ -1520,3 +1534,3 @@\n-OptoReg::Name PhaseChaitin::choose_color( LRG &lrg, int chunk ) {\n-  assert( C->in_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP-1)), \"must not allocate stack0 (inside preserve area)\");\n-  assert(C->out_preserve_stack_slots() == 0 || chunk != 0 || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP+0)), \"must not allocate stack0 (inside preserve area)\");\n+OptoReg::Name PhaseChaitin::choose_color(LRG& lrg) {\n+  assert(C->in_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP - 1)), \"must not allocate stack0 (inside preserve area)\");\n+  assert(C->out_preserve_stack_slots() == 0 || lrg.mask().is_offset() || lrg._is_bound || lrg.mask().is_bound1() || !lrg.mask().Member(OptoReg::Name(_matcher._old_SP + 0)), \"must not allocate stack0 (inside preserve area)\");\n@@ -1527,1 +1541,1 @@\n-    return bias_color(lrg, chunk);\n+    return bias_color(lrg);\n@@ -1535,1 +1549,1 @@\n-  assert( !chunk, \"always color in 1st chunk\" );\n+  assert(!lrg.mask().is_offset(), \"always color in 1st chunk\");\n@@ -1575,1 +1589,0 @@\n-    int chunk = 0;              \/\/ Current chunk is first chunk\n@@ -1580,1 +1593,4 @@\n-    debug_only(RegMask orig_mask = lrg->mask();)\n+#ifndef PRODUCT\n+    ResourceMark rm(C->regmask_arena());\n+    RegMask orig_mask(lrg->mask(), C->regmask_arena());\n+#endif\n@@ -1586,6 +1602,0 @@\n-        \/\/ Note that neighbor might be a spill_reg.  In this case, exclusion\n-        \/\/ of its color will be a no-op, since the spill_reg chunk is in outer\n-        \/\/ space.  Also, if neighbor is in a different chunk, this exclusion\n-        \/\/ will be a no-op.  (Later on, if lrg runs out of possible colors in\n-        \/\/ its chunk, a new chunk of color may be tried, in which case\n-        \/\/ examination of neighbors is started again, at retry_next_chunk.)\n@@ -1594,2 +1604,7 @@\n-        \/\/ Only subtract masks in the same chunk\n-        if (nreg >= chunk && nreg < chunk + RegMask::CHUNK_SIZE) {\n+        \/\/ The neighbor might be a spill_reg. In this case, exclusion of its\n+        \/\/ color will be a no-op, since the spill_reg is in outer space. In\n+        \/\/ this case, do not exclude the corresponding mask. Later on, if lrg\n+        \/\/ runs out of possible colors in its chunk, a new chunk of color may\n+        \/\/ be tried, in which case examination of neighbors is started again,\n+        \/\/ at retry_next_chunk.\n+        if (nreg < LRG::SPILL_REG) {\n@@ -1598,1 +1613,2 @@\n-          RegMask rm = lrg->mask();\n+          ResourceMark r(C->regmask_arena());\n+          RegMask rm(lrg->mask(), C->regmask_arena());\n@@ -1600,1 +1616,1 @@\n-          lrg->SUBTRACT(nlrg.mask());\n+          lrg->SUBTRACT_inner(nlrg.mask());\n@@ -1627,1 +1643,1 @@\n-    OptoReg::Name reg = choose_color( *lrg, chunk );\n+    OptoReg::Name reg = choose_color(*lrg);\n@@ -1632,1 +1648,1 @@\n-    if(!OptoReg::is_valid(OptoReg::add(reg,-chunk)) && is_allstack) {\n+    if (!OptoReg::is_valid(reg) && is_allstack) {\n@@ -1634,2 +1650,10 @@\n-      chunk += RegMask::CHUNK_SIZE;\n-      lrg->Set_All();\n+      bool success = lrg->rollover();\n+      if (!success) {\n+        \/\/ We should never get here in practice. Bail out in product,\n+        \/\/ assert in debug.\n+        assert(false, \"the next available stack slots should be within the \"\n+                      \"OptoRegPair range\");\n+        C->record_method_not_compilable(\n+            \"chunk-rollover outside of OptoRegPair range\");\n+        return -1;\n+      }\n@@ -1641,1 +1665,1 @@\n-    else if( OptoReg::is_valid(reg)) {\n+    else if (OptoReg::is_valid(reg)) {\n@@ -1643,1 +1667,2 @@\n-      RegMask avail_rm = lrg->mask();\n+      ResourceMark rm(C->regmask_arena());\n+      RegMask avail_rm(lrg->mask(), C->regmask_arena());\n@@ -1649,4 +1674,3 @@\n-      if( reg >= _max_reg )     \/\/ Compute max register limit\n-        _max_reg = OptoReg::add(reg,1);\n-      \/\/ Fold reg back into normal space\n-      reg = OptoReg::add(reg,-chunk);\n+      if (reg >= _max_reg) { \/\/ Compute max register limit\n+        _max_reg = OptoReg::add(reg, 1);\n+      }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":68,"deletions":44,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+  void init_mask(Arena* arena) {\n+    new (&_mask) RegMask(arena);\n+  }\n@@ -134,0 +137,4 @@\n+  void SUBTRACT_inner(const RegMask& rm) {\n+    _mask.SUBTRACT_inner(rm);\n+    debug_only(_msize_valid = 0;)\n+  }\n@@ -135,1 +142,10 @@\n-  void Set_All() { _mask.Set_All(); debug_only(_msize_valid=1); _mask_size = RegMask::CHUNK_SIZE; }\n+  void Set_All() {\n+    _mask.Set_All();\n+    debug_only(_msize_valid = 1);\n+    _mask_size = _mask.rm_size_bits();\n+  }\n+  bool rollover() {\n+    debug_only(_msize_valid = 1);\n+    _mask_size = _mask.rm_size_bits();\n+    return _mask.rollover();\n+  }\n@@ -697,1 +713,1 @@\n-  OptoReg::Name choose_color( LRG &lrg, int chunk );\n+  OptoReg::Name choose_color(LRG& lrg);\n@@ -699,1 +715,1 @@\n-  OptoReg::Name bias_color( LRG &lrg, int chunk );\n+  OptoReg::Name bias_color(LRG& lrg);\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -696,1 +696,2 @@\n-  RegMask rm = lrgs(lr1).mask();\n+  ResourceMark r(C->regmask_arena());\n+  RegMask rm(lrgs(lr1).mask(), C->regmask_arena());\n","filename":"src\/hotspot\/share\/opto\/coalesce.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -689,0 +689,2 @@\n+      _FIRST_STACK_mask(comp_arena()),\n+      _regmask_arena(mtCompiler, Arena::Tag::tag_regmask),\n@@ -956,0 +958,2 @@\n+      _FIRST_STACK_mask(comp_arena()),\n+      _regmask_arena(mtCompiler, Arena::Tag::tag_regmask),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -524,0 +524,1 @@\n+  ResourceArea          _regmask_arena;         \/\/ Holds dynamically allocated extensions of short-lived register masks\n@@ -1112,0 +1113,1 @@\n+  ResourceArea*     regmask_arena()             { return &_regmask_arena; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1309,1 +1309,1 @@\n-  if (mach && mach->out_RegMask().is_bound1() && mach->out_RegMask().is_NotEmpty())\n+  if (mach && mach->out_RegMask().is_bound1() && !mach->out_RegMask().is_Empty())\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    _lrgs[i].init_mask(_arena);\n@@ -640,1 +641,2 @@\n-  RegMask mask_tmp = lrg.mask();\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask mask_tmp(lrg.mask(), C->regmask_arena());\n@@ -698,0 +700,3 @@\n+  ResourceMark r(C->regmask_arena());\n+  RegMask old(C->regmask_arena());\n+  RegMask r2mask(C->regmask_arena());\n@@ -712,1 +717,1 @@\n-    RegMask old = interfering_lrg.mask();\n+    old = interfering_lrg.mask();\n@@ -721,1 +726,1 @@\n-      RegMask r2mask = rm;\n+      r2mask = rm;\n@@ -916,1 +921,1 @@\n-        if (lrg.is_bound() && !n->rematerialize() && lrg.mask().is_NotEmpty()) {\n+        if (lrg.is_bound() && !n->rematerialize() && !lrg.mask().is_Empty()) {\n","filename":"src\/hotspot\/share\/opto\/ifg.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -851,1 +851,2 @@\n-  RegMask regs;\n+  ResourceMark rm(C->regmask_arena());\n+  RegMask regs(C->regmask_arena());\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"opto\/regmask.hpp\"\n@@ -41,7 +42,10 @@\n-BoxLockNode::BoxLockNode( int slot ) : Node( Compile::current()->root() ),\n-                                       _slot(slot), _kind(BoxLockNode::Regular) {\n-  init_class_id(Class_BoxLock);\n-  init_flags(Flag_rematerialize);\n-  OptoReg::Name reg = OptoReg::stack2reg(_slot);\n-  if (!RegMask::can_represent(reg, Compile::current()->sync_stack_slots())) {\n-    Compile::current()->record_method_not_compilable(\"must be able to represent all monitor slots in reg mask\");\n+BoxLockNode::BoxLockNode(int slot)\n+    : Node(Compile::current()->root()), _slot(slot),\n+      \/\/ In debug mode, signal that the register mask is constant.\n+      _inmask(OptoReg::stack2reg(_slot),\n+              Compile::current()->comp_arena()\n+              DEBUG_ONLY(COMMA \/*orig_const*\/ true)),\n+      _kind(BoxLockNode::Regular) {\n+  if (_slot > BoxLockNode_slot_limit) {\n+    Compile::current()->record_method_not_compilable(\n+        \"reached BoxLockNode slot limit\");\n@@ -50,1 +54,2 @@\n-  _inmask.Insert(reg);\n+  init_class_id(Class_BoxLock);\n+  init_flags(Flag_rematerialize);\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-  const int     _slot; \/\/ stack slot\n-  RegMask     _inmask; \/\/ OptoReg corresponding to stack slot\n+  const int _slot;       \/\/ stack slot\n+  const RegMask _inmask; \/\/ OptoReg corresponding to stack slot\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -528,1 +528,1 @@\n-    if (rm.is_NotEmpty() && rm.is_bound(ideal_reg())) {\n+    if (!rm.is_Empty() && rm.is_bound(ideal_reg())) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -750,1 +750,3 @@\n-  MachProjNode( Node *multi, uint con, const RegMask &out, uint ideal_reg ) : ProjNode(multi,con), _rout(out), _ideal_reg(ideal_reg) {\n+  MachProjNode(Node* multi, uint con, const RegMask& out, uint ideal_reg)\n+      : ProjNode(multi, con), _rout(out, Compile::current()->comp_arena()),\n+        _ideal_reg(ideal_reg) {\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,2 @@\n-  _register_save_type(register_save_type) {\n+  _register_save_type(register_save_type),\n+  _return_addr_mask(C->comp_arena()) {\n@@ -143,6 +144,0 @@\n-    if (!RegMask::can_represent_arg(warped)) {\n-      \/\/ the compiler cannot represent this method's calling sequence\n-      \/\/ Bailout. We do not have space to represent all arguments.\n-      C->record_method_not_compilable(\"unsupported incoming calling sequence\");\n-      return OptoReg::Bad;\n-    }\n@@ -201,1 +196,3 @@\n-  _return_addr_mask = return_addr();\n+  assert(_return_addr_mask.is_Empty(),\n+         \"return address mask must be empty initially\");\n+  _return_addr_mask.Insert(return_addr());\n@@ -238,0 +235,1 @@\n+    new (_calling_convention_mask + i) RegMask(C->comp_arena());\n@@ -294,3 +292,0 @@\n-    if (C->failing()) {\n-      return;\n-    }\n@@ -301,3 +296,0 @@\n-    if (C->failing()) {\n-      return;\n-    }\n@@ -324,8 +316,0 @@\n-  if (!RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1))) {\n-    \/\/ the compiler cannot represent this method's calling sequence\n-    \/\/ Bailout. We do not have space to represent all arguments.\n-    C->record_method_not_compilable(\"must be able to represent all call arguments in reg mask\");\n-  }\n-\n-  if (C->failing())  return;  \/\/ bailed out on incoming arg failure\n-\n@@ -454,0 +438,3 @@\n+  for (unsigned int i = 0; i < size; ++i) {\n+    new (rms + i) RegMask(Compile::current()->comp_arena());\n+  }\n@@ -493,1 +480,1 @@\n-    new (rms + i) RegMask();\n+    new (rms + i) RegMask(C->comp_arena());\n@@ -542,2 +529,0 @@\n-  OptoReg::Name i;\n-\n@@ -549,1 +534,1 @@\n-  for (i = init_in; i < _in_arg_limit; i = OptoReg::add(i,1)) {\n+  for (OptoReg::Name i = init_in; i < _in_arg_limit; i = OptoReg::add(i, 1)) {\n@@ -553,8 +538,1 @@\n-  guarantee(RegMask::can_represent_arg(OptoReg::add(_out_arg_limit,-1)),\n-            \"must be able to represent all call arguments in reg mask\");\n-  OptoReg::Name init = _out_arg_limit;\n-  for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1)) {\n-    C->FIRST_STACK_mask().Insert(i);\n-  }\n-  \/\/ Finally, set the \"infinite stack\" bit.\n-  C->FIRST_STACK_mask().set_AllStack();\n+  C->FIRST_STACK_mask().Set_All_From(_out_arg_limit);\n@@ -563,1 +541,1 @@\n-  RegMask aligned_stack_mask = C->FIRST_STACK_mask();\n+  RegMask aligned_stack_mask(C->FIRST_STACK_mask(), C->comp_arena());\n@@ -567,1 +545,1 @@\n-  RegMask scalable_stack_mask = aligned_stack_mask;\n+  RegMask scalable_stack_mask(aligned_stack_mask, C->comp_arena());\n@@ -995,1 +973,0 @@\n-  OptoReg::Name init = OptoReg::stack2reg(0);\n@@ -997,5 +974,1 @@\n-  OptoReg::Name i;\n-  for (i = init; RegMask::can_represent(i); i = OptoReg::add(i,1))\n-    STACK_ONLY_mask.Insert(i);\n-  \/\/ Also set the \"infinite stack\" bit.\n-  STACK_ONLY_mask.set_AllStack();\n+  STACK_ONLY_mask.Set_All_From(OptoReg::stack2reg(0));\n@@ -1003,1 +976,2 @@\n-  for (i = OptoReg::Name(0); i < OptoReg::Name(_last_Mach_Reg); i = OptoReg::add(i, 1)) {\n+  for (OptoReg::Name i = OptoReg::Name(0); i < OptoReg::Name(_last_Mach_Reg);\n+       i = OptoReg::add(i, 1)) {\n@@ -1280,6 +1254,2 @@\n-    if( warped >= out_arg_limit_per_call )\n-      out_arg_limit_per_call = OptoReg::add(warped,1);\n-    if (!RegMask::can_represent_arg(warped)) {\n-      \/\/ Bailout. For example not enough space on stack for all arguments. Happens for methods with too many arguments.\n-      C->record_method_not_compilable(\"unsupported calling sequence\");\n-      return OptoReg::Bad;\n+    if (warped >= out_arg_limit_per_call) {\n+      out_arg_limit_per_call = OptoReg::add(warped, 1);\n@@ -1369,1 +1339,3 @@\n-  for (uint i = 0; i < cnt; i++) ::new (&(msfpt->_in_rms[i])) RegMask();\n+  for (uint i = 0; i < cnt; i++) {\n+    ::new (&(msfpt->_in_rms[i])) RegMask(C->comp_arena());\n+  }\n@@ -1452,3 +1424,0 @@\n-      if (C->failing()) {\n-        return nullptr;\n-      }\n@@ -1459,3 +1428,0 @@\n-      if (C->failing()) {\n-        return nullptr;\n-      }\n@@ -1481,6 +1447,2 @@\n-    if (!RegMask::can_represent_arg(OptoReg::Name(out_arg_limit_per_call-1))) {\n-      \/\/ Bailout. We do not have space to represent all arguments.\n-      C->record_method_not_compilable(\"unsupported outgoing calling sequence\");\n-    } else {\n-      for (int i = begin_out_arg_area; i < out_arg_limit_per_call; i++)\n-        proj->_rout.Insert(OptoReg::Name(i));\n+    for (int i = begin_out_arg_area; i < out_arg_limit_per_call; i++) {\n+      proj->_rout.Insert(OptoReg::Name(i));\n@@ -1488,1 +1450,1 @@\n-    if (proj->_rout.is_NotEmpty()) {\n+    if (!proj->_rout.is_Empty()) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":25,"deletions":63,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -552,0 +552,8 @@\n+  if (this->is_MachProj()) {\n+    \/\/ MachProjNodes contain register masks that may contain pointers to\n+    \/\/ externally allocated memory. Make sure to use a proper constructor\n+    \/\/ instead of just shallowly copying.\n+    MachProjNode* mach = n->as_MachProj();\n+    MachProjNode* mthis = this->as_MachProj();\n+    new (&mach->_rout) RegMask(mthis->_rout);\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -186,2 +187,4 @@\n-  short _second;\n-  short _first;\n+  typedef short Name;\n+  Name _second;\n+  Name _first;\n+\n@@ -189,5 +192,25 @@\n-  void set_bad (                   ) { _second = OptoReg::Bad; _first = OptoReg::Bad; }\n-  void set1    ( OptoReg::Name n  ) { _second = OptoReg::Bad; _first = n; }\n-  void set2    ( OptoReg::Name n  ) { _second = n + 1;       _first = n; }\n-  void set_pair( OptoReg::Name second, OptoReg::Name first    ) { _second= second;    _first= first; }\n-  void set_ptr ( OptoReg::Name ptr ) {\n+  static constexpr bool can_fit(OptoReg::Name n) {\n+    return n <= std::numeric_limits<OptoRegPair::Name>::max();\n+  }\n+  void set_bad() {\n+    _second = OptoReg::Bad;\n+    _first = OptoReg::Bad;\n+  }\n+  void set1(OptoReg::Name n) {\n+    assert(can_fit(n), \"overflow\");\n+    _second = OptoReg::Bad;\n+    _first = n;\n+  }\n+  void set2(OptoReg::Name n) {\n+    assert(can_fit(n + 1), \"overflow\");\n+    assert(can_fit(n), \"overflow\");\n+    _second = n + 1;\n+    _first = n;\n+  }\n+  void set_pair(OptoReg::Name second, OptoReg::Name first) {\n+    assert(can_fit(second), \"overflow\");\n+    assert(can_fit(first), \"overflow\");\n+    _second = second;\n+    _first = first;\n+  }\n+  void set_ptr(OptoReg::Name ptr) {\n@@ -195,1 +218,2 @@\n-    _second = ptr+1;\n+    assert(can_fit(ptr + 1), \"overflow\");\n+    _second = ptr + 1;\n@@ -199,0 +223,1 @@\n+    assert(can_fit(ptr), \"overflow\");\n@@ -204,3 +229,6 @@\n-  OptoRegPair(OptoReg::Name second, OptoReg::Name first) {  _second = second; _first = first; }\n-  OptoRegPair(OptoReg::Name f) { _second = OptoReg::Bad; _first = f; }\n-  OptoRegPair() { _second = OptoReg::Bad; _first = OptoReg::Bad; }\n+  OptoRegPair(OptoReg::Name second, OptoReg::Name first) {\n+    assert(can_fit(second), \"overflow\");\n+    assert(can_fit(first), \"overflow\");\n+    _second = second;\n+    _first = first;\n+  }\n","filename":"src\/hotspot\/share\/opto\/optoreg.hpp","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -176,2 +176,1 @@\n-  bool can_use = ( RegMask::can_represent(def_reg) ? (use_mask.Member(def_reg) != 0)\n-                                                   : (use_mask.is_AllStack() != 0));\n+  bool can_use = use_mask.Member(def_reg);\n@@ -682,3 +681,5 @@\n-              if (!value[ureg_lo] &&\n-                  (!RegMask::can_represent(ureg_lo) ||\n-                   lrgs(useidx).mask().Member(ureg_lo))) { \/\/ Nearly always adjacent\n+              bool is_reg = OptoReg::is_reg(ureg_lo);\n+              bool is_adjacent = lrgs(useidx).mask().Member(ureg_lo);\n+              assert(is_adjacent || is_reg,\n+                     \"only registers can be non-adjacent\");\n+              if (!value[ureg_lo] && is_adjacent) { \/\/ Nearly always adjacent\n@@ -765,2 +766,4 @@\n-        if( RegMask::can_represent(nreg_lo) &&     \/\/ Either a spill slot, or\n-            !lrgs(lidx).mask().Member(nreg_lo) ) { \/\/ Nearly always adjacent\n+        bool is_reg = OptoReg::is_reg(nreg_lo);\n+        bool is_adjacent = lrgs(lidx).mask().Member(nreg_lo);\n+        assert(is_adjacent || is_reg, \"only registers can be non-adjacent\");\n+        if (!is_adjacent) { \/\/ Nearly always adjacent\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -479,1 +479,1 @@\n-    if (n->out_RegMask().is_NotEmpty()) {\n+    if (!n->out_RegMask().is_Empty()) {\n@@ -1129,1 +1129,2 @@\n-                  RegMask tmp_rm(umask);\n+                  ResourceMark rm(C->regmask_arena());\n+                  RegMask tmp_rm(umask, C->regmask_arena());\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/population_count.hpp\"\n@@ -55,1 +54,1 @@\n-  FORALL_BODY\n+    FORALL_BODY\n@@ -57,2 +56,1 @@\n-  0\n-);\n+    true);\n@@ -122,1 +120,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_up(i);\n@@ -125,1 +123,1 @@\n-    _RM_UP[i] = bits;\n+    _rm_up(i) = bits;\n@@ -138,1 +136,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_up(i);\n@@ -157,1 +155,1 @@\n-    uintptr_t v = _RM_UP[i];\n+    uintptr_t v = _rm_up(i);\n@@ -166,1 +164,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_up(i) != 0) {\n@@ -184,2 +182,2 @@\n-    if (_RM_UP[i] != 0) {               \/\/ Found some bits\n-      unsigned int bit_index = find_lowest_bit(_RM_UP[i]);\n+    if (_rm_up(i) != 0) {               \/\/ Found some bits\n+      unsigned int bit_index = find_lowest_bit(_rm_up(i));\n@@ -188,1 +186,1 @@\n-        if ((bit | (bit << 1U)) != _RM_UP[i]) {\n+        if ((bit | (bit << 1U)) != _rm_up(i)) {\n@@ -192,1 +190,1 @@\n-        assert(is_power_of_2(_RM_UP[i]), \"invariant\");\n+        assert(is_power_of_2(_rm_up(i)), \"invariant\");\n@@ -194,1 +192,1 @@\n-        if (i > _hwm || _RM_UP[i] != 1) {\n+        if (i > _hwm || _rm_up(i) != 1) {\n@@ -201,1 +199,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_up(i) != 0) {\n@@ -247,1 +245,1 @@\n-    if (_RM_UP[i]) {                \/\/ Found some bits\n+    if (_rm_up(i)) {                \/\/ Found some bits\n@@ -249,1 +247,2 @@\n-      return OptoReg::Name((i<<_LogWordBits) + find_lowest_bit(_RM_UP[i]) + (size - 1));\n+      return OptoReg::Name(offset_bits() + (i << _LogWordBits) +\n+                           find_lowest_bit(_rm_up(i)) + (size - 1));\n@@ -263,1 +262,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_up(i);\n@@ -278,1 +277,1 @@\n-    _RM_UP[i] = sets;\n+    _rm_up(i) = sets;\n@@ -291,1 +290,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_up(i);\n@@ -307,1 +306,1 @@\n-    _RM_UP[i] = sets;\n+    _rm_up(i) = sets;\n@@ -320,1 +319,1 @@\n-    uintptr_t bits = _RM_UP[i];\n+    uintptr_t bits = _rm_up(i);\n@@ -347,2 +346,2 @@\n-    if (_RM_UP[i] != 0) {       \/\/ Found some bits\n-      unsigned bit_index = find_lowest_bit(_RM_UP[i]);\n+    if (_rm_up(i) != 0) {       \/\/ Found some bits\n+      unsigned bit_index = find_lowest_bit(_rm_up(i));\n@@ -353,1 +352,1 @@\n-        if (set != _RM_UP[i]) {\n+        if (set != _rm_up(i)) {\n@@ -358,1 +357,1 @@\n-        if ((all & ~(bit-1)) != _RM_UP[i]) {\n+        if ((all & ~(bit - 1)) != _rm_up(i)) {\n@@ -364,1 +363,1 @@\n-        if (i > _hwm || _RM_UP[i] != set) {\n+        if (i > _hwm || _rm_up(i) != set) {\n@@ -371,1 +370,1 @@\n-        if (_RM_UP[i] != 0) {\n+        if (_rm_up(i) != 0) {\n@@ -395,6 +394,7 @@\n-\/\/ Compute size of register mask in bits\n-uint RegMask::Size() const {\n-  uint sum = 0;\n-  assert(valid_watermarks(), \"sanity\");\n-  for (unsigned i = _lwm; i <= _hwm; i++) {\n-    sum += population_count(_RM_UP[i]);\n+#ifndef PRODUCT\n+bool RegMask::_dump_end_run(outputStream* st, OptoReg::Name start,\n+                            OptoReg::Name last) const {\n+  bool last_is_end = last == (int)offset_bits() + (int)rm_size_bits() - 1;\n+  if (is_AllStack() && last_is_end) {\n+    st->print(\"-...\");\n+    return true;\n@@ -402,1 +402,9 @@\n-  return sum;\n+  if (start == last) { \/\/ 1-register run; no special printing\n+  } else if (start + 1 == last) {\n+    st->print(\",\"); \/\/ 2-register run; print as \"rX,rY\"\n+    OptoReg::dump(last, st);\n+  } else { \/\/ Multi-register run; print as \"rX-rZ\"\n+    st->print(\"-\");\n+    OptoReg::dump(last, st);\n+  }\n+  return false;\n@@ -405,1 +413,0 @@\n-#ifndef PRODUCT\n@@ -410,0 +417,1 @@\n+  bool printed_all_stack = false;\n@@ -426,8 +434,2 @@\n-        if (start == last) {    \/\/ 1-register run; no special printing\n-        } else if (start+1 == last) {\n-          st->print(\",\");       \/\/ 2-register run; print as \"rX,rY\"\n-          OptoReg::dump(last, st);\n-        } else {                \/\/ Multi-register run; print as \"rX-rZ\"\n-          st->print(\"-\");\n-          OptoReg::dump(last, st);\n-        }\n+        printed_all_stack = _dump_end_run(st, start, last);\n+        assert(!printed_all_stack, \"\");\n@@ -439,8 +441,12 @@\n-\n-    if (start == last) {        \/\/ 1-register run; no special printing\n-    } else if (start+1 == last) {\n-      st->print(\",\");           \/\/ 2-register run; print as \"rX,rY\"\n-      OptoReg::dump(last, st);\n-    } else {                    \/\/ Multi-register run; print as \"rX-rZ\"\n-      st->print(\"-\");\n-      OptoReg::dump(last, st);\n+    printed_all_stack = _dump_end_run(st, start, last);\n+    \/\/ Print all-stack if not already done.\n+    if (is_AllStack() && !printed_all_stack) {\n+      st->print(\",\");\n+      OptoReg::dump(offset_bits() + rm_size_bits(), st);\n+      st->print(\"-...\");\n+    }\n+  } else {\n+    \/\/ Mask is all-stack only.\n+    if (is_AllStack() && !printed_all_stack) {\n+      OptoReg::dump(offset_bits() + rm_size_bits(), st);\n+      st->print(\"-...\");\n@@ -448,1 +454,0 @@\n-    if (is_AllStack()) st->print(\"...\");\n@@ -452,0 +457,11 @@\n+\n+void RegMask::dump_hex(outputStream* st) const {\n+  st->print(\"...%x|\", is_AllStack() ? 0xf : 0x0);\n+  for (int i = _rm_max(); i >= 0; i--) {\n+    st->print(LP64_ONLY(\"%0*lx\") NOT_LP64(\"%0*x\"),\n+              (int)sizeof(uintptr_t) * CHAR_BIT \/ 4, _rm_up(i));\n+    if (i != 0) {\n+      st->print(\"|\");\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":69,"deletions":53,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -36,0 +37,8 @@\n+\/\/ To avoid unbounded RegMask growth and to be able to statically compute a\n+\/\/ register mask size upper bound (see RM_SIZE_MAX below), we need to set some\n+\/\/ form of limit on the number of stack slots used by BoxLockNodes. The limit\n+\/\/ below is rather arbitrary but should be quite generous and cover all\n+\/\/ practical cases. We reach this limit by, e.g., deeply nesting synchronized\n+\/\/ statements in Java.\n+const int BoxLockNode_slot_limit = 200;\n+\n@@ -51,2 +60,4 @@\n-\/\/ The ADLC defines 2 macros, RM_SIZE and FORALL_BODY.\n-\/\/ RM_SIZE is the size of a register mask in 32-bit words.\n+\/\/ The ADLC defines 3 macros, RM_SIZE, RM_SIZE_MIN, and FORALL_BODY.\n+\/\/ RM_SIZE is the base size of a register mask in 32-bit words.\n+\/\/ RM_SIZE_MIN is the theoretical minimum size of a register mask in 32-bit\n+\/\/ words.\n@@ -68,0 +79,2 @@\n+  static const unsigned int _RM_SIZE_MIN =\n+      LP64_ONLY(((RM_SIZE_MIN + 1) & ~1) >> 1) NOT_LP64(RM_SIZE_MIN);\n@@ -70,0 +83,20 @@\n+  \/\/ Compute a best-effort (statically known) upper bound for register mask\n+  \/\/ size in 32-bit words. When extending\/growing register masks, we should\n+  \/\/ never grow past this size.\n+  static const unsigned int RM_SIZE_MAX =\n+      (((RM_SIZE_MIN << 5) +                \/\/ Slots for machine registers\n+        (max_method_parameter_length * 2) + \/\/ Slots for incoming arguments\n+        (max_method_parameter_length * 2) + \/\/ Slots for outgoing arguments\n+        BoxLockNode_slot_limit +            \/\/ Slots for locks\n+        64                                  \/\/ Padding, reserved words, etc.\n+        ) + 31) >> 5; \/\/ Number of bits -> number of 32-bit words\n+  static const unsigned int _RM_SIZE_MAX =\n+      LP64_ONLY(((RM_SIZE_MAX + 1) & ~1) >> 1) NOT_LP64(RM_SIZE_MAX);\n+\n+  \/\/ Sanity check\n+  STATIC_ASSERT(RM_SIZE <= RM_SIZE_MAX);\n+\n+  \/\/ Ensure that register masks cannot grow beyond the point at which\n+  \/\/ OptoRegPair can no longer index the whole mask.\n+  STATIC_ASSERT(OptoRegPair::can_fit((RM_SIZE_MAX << 5) - 1));\n+\n@@ -71,5 +104,4 @@\n-    \/\/ Array of Register Mask bits.  This array is large enough to cover\n-    \/\/ all the machine registers and all parameters that need to be passed\n-    \/\/ on the stack (stack registers) up to some interesting limit.  Methods\n-    \/\/ that need more parameters will NOT be compiled.  On Intel, the limit\n-    \/\/ is something like 90+ parameters.\n+    \/\/ Array of Register Mask bits.  This array is large enough to cover all\n+    \/\/ the machine registers and usually all parameters that need to be passed\n+    \/\/ on the stack (stack registers) up to some interesting limit. On Intel,\n+    \/\/ the limit is something like 90+ parameters.\n@@ -80,4 +112,58 @@\n-  \/\/ The low and high water marks represents the lowest and highest word\n-  \/\/ that might contain set register mask bits, respectively. We guarantee\n-  \/\/ that there are no bits in words outside this range, but any word at\n-  \/\/ and between the two marks can still be 0.\n+  \/\/ In rare situations (e.g., \"more than 90+ parameters on Intel\"), we need to\n+  \/\/ extend the register mask with dynamically allocated memory. We keep the\n+  \/\/ base statically allocated _RM_UP, and arena allocate the extended mask\n+  \/\/ (RM_UP_EXT) separately. Another, perhaps more elegant, option would be to\n+  \/\/ have two subclasses of RegMask, where one is statically allocated and one\n+  \/\/ is (entirely) dynamically allocated. Given that register mask extension is\n+  \/\/ rare, we decided to use the current approach (_RM_UP and _RM_UP_EXT) to\n+  \/\/ keep the common case fast. Most of the time, we will then not need to\n+  \/\/ dynamically allocate anything.\n+  \/\/\n+  \/\/ We could use a GrowableArray here, but there are currently some\n+  \/\/ GrowableArray limitations that have a negative performance impact for our\n+  \/\/ use case:\n+  \/\/\n+  \/\/ - There is no efficient copy\/clone operation.\n+  \/\/ - GrowableArray construction currently default-initializes everything\n+  \/\/   within the array's initial capacity, which is unnecessary in our case.\n+  \/\/\n+  \/\/ After addressing these limitations, we should consider using a\n+  \/\/ GrowableArray here.\n+  uintptr_t* _RM_UP_EXT = nullptr;\n+\n+#ifdef ASSERT\n+  \/\/ Register masks may get shallowly copied without the use of constructors,\n+  \/\/ which is problematic when dealing with the externally allocated memory for\n+  \/\/ _RM_UP_EXT. Therefore, we need some sanity checks to ensure we have not\n+  \/\/ missed any such cases. The below variables enable such checks.\n+  \/\/\n+  \/\/ The original address of the _RM_UP_EXT variable, set when using\n+  \/\/ constructors. If we get copied\/cloned, &_RM_UP_EXT will no longer equal\n+  \/\/ orig_ext_adr.\n+  uintptr_t** orig_ext_adr = &_RM_UP_EXT;\n+  \/\/\n+  \/\/ If the original version, of which we may be a clone, is read-only. In such\n+  \/\/ cases, we can allow read-only sharing.\n+  bool orig_const = false;\n+#endif\n+\n+  \/\/ Current total register mask size in words\n+  unsigned int _rm_size;\n+\n+  \/\/ We support offsetting register masks to present different views of the\n+  \/\/ register space, mainly for use in PhaseChaitin::Select. The _offset\n+  \/\/ variable indicates how many words we offset with. We consider all\n+  \/\/ registers before the offset to not be included in the register mask.\n+  unsigned int _offset;\n+\n+  \/\/ If _all_stack = true, we consider all registers beyond what the register\n+  \/\/ mask can currently represent to be included. If _all_stack = false, we\n+  \/\/ consider the registers not included.\n+  bool _all_stack = false;\n+\n+  \/\/ The low and high watermarks represent the lowest and highest word that\n+  \/\/ might contain set register mask bits, respectively. We guarantee that\n+  \/\/ there are no bits in words outside this range, but any word at and between\n+  \/\/ the two marks can still be 0. We do not guarantee that the watermarks are\n+  \/\/ optimal. If _hwm < _lwm, the register mask is necessarily empty. Indeed,\n+  \/\/ when we construct empty register masks, we set _hwm = 0 and _lwm = max.\n@@ -87,2 +173,185 @@\n- public:\n-  enum { CHUNK_SIZE = _RM_SIZE * BitsPerWord };\n+  \/\/ The following diagram illustrates the internal representation of a RegMask\n+  \/\/ (with _offset = 0, for a made-up platform with 10 registers and 4-bit\n+  \/\/ words) that has been extended with two additional words to represent more\n+  \/\/ stack locations:\n+  \/\/                                   _hwm=3\n+  \/\/            _lwm=1                RM_SIZE=3                _rm_size=5\n+  \/\/              |                       |                        |\n+  \/\/   r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 s0 s1   s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 ...\n+  \/\/  [0  0  0  0 |0  1  1  0 |0  0  1  0 ] [1  1  0  1 |0  0  0  0] as  as  as\n+  \/\/ [0]         [1]         [2]           [0]         [1]\n+  \/\/\n+  \/\/ \\____________________________________\/ \\______________________\/\n+  \/\/                        |                           |\n+  \/\/                      RM_UP                     RM_UP_EXT\n+  \/\/ \\_____________________________________________________________\/\n+  \/\/                                 |\n+  \/\/                             _rm_size\n+  \/\/\n+  \/\/ In this example, registers {r5, r6} and stack locations {s0, s2, s3, s5}\n+  \/\/ are included in the register mask. Depending on the value of _all_stack,\n+  \/\/ (s10, s11, ...) are all included (as = 1) or excluded (as = 0). Note that\n+  \/\/ all registers\/stack locations under _lwm and over _hwm are excluded.\n+  \/\/ The exception is (s10, s11, ...), where the value is decided solely by\n+  \/\/ _all_stack, regardless of the value of _hwm.\n+  \/\/\n+  \/\/ The only operation that may update the _offset attribute is\n+  \/\/ RegMask::rollover(). This operation requires the register mask to be clean\n+  \/\/ and _all_stack to be true, and has the effect of increasing _offset by\n+  \/\/ _rm_size and setting all bits (now necessarily representing stack\n+  \/\/ locations) to 1. Here is how the above register mask looks like after\n+  \/\/ clearing, setting _all_stack to true, and successfully rolling over:\n+  \/\/\n+  \/\/ _lwm=0                                      RM_SIZE=3           _hwm=3      _rm_size=5\n+  \/\/  |                                              |                 |             |\n+  \/\/   s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 s20 s21  s22 s23 s24 s25 s26 s27 s28 s29 s30 s31 ...\n+  \/\/  [1   1   1   1  |1   1   1   1  |1   1   1   1 ] [1   1   1   1  |1   1   1   1]  1   1   1\n+  \/\/ [0]             [1]             [2]              [0]             [1]\n+  \/\/\n+  \/\/ \\_______________________________________________\/ \\_____________________________\/\n+  \/\/                           |                                     |\n+  \/\/                         RM_UP                               RM_UP_EXT\n+  \/\/ \\_______________________________________________________________________________\/\n+  \/\/                                         |\n+  \/\/                                     _rm_size\n+\n+  \/\/ Access word i in the register mask.\n+  const uintptr_t& _rm_up(unsigned int i) const {\n+    assert(orig_const || orig_ext_adr == &_RM_UP_EXT, \"clone sanity check\");\n+    assert(i < _rm_size, \"sanity\");\n+    if (i < _RM_SIZE) {\n+      return _RM_UP[i];\n+    } else {\n+      assert(_RM_UP_EXT != nullptr, \"sanity\");\n+      return _RM_UP_EXT[i - _RM_SIZE];\n+    }\n+  }\n+\n+  \/\/ Non-const version of the above.\n+  uintptr_t& _rm_up(unsigned int i) {\n+    assert(orig_ext_adr == &_RM_UP_EXT, \"clone sanity check\");\n+    return const_cast<uintptr_t&>(const_cast<const RegMask*>(this)->_rm_up(i));\n+  }\n+\n+  \/\/ The maximum word index\n+  unsigned int _rm_max() const {\n+    return _rm_size - 1U;\n+  }\n+\n+  \/\/ Where to extend the register mask\n+  Arena* _arena;\n+\n+  \/\/ Grow the register mask to ensure it can fit at least min_size words.\n+  void _grow(unsigned int min_size, bool init = true) {\n+    if (min_size > _rm_size) {\n+      assert(min_size <= _RM_SIZE_MAX, \"unexpected register mask growth\");\n+      assert(_arena != nullptr, \"register mask not growable\");\n+      min_size = MIN2(_RM_SIZE_MAX, round_up_power_of_2(min_size));\n+      unsigned int old_size = _rm_size;\n+      unsigned int old_ext_size = old_size - _RM_SIZE;\n+      unsigned int new_ext_size = min_size - _RM_SIZE;\n+      _rm_size = min_size;\n+      if (_RM_UP_EXT == nullptr) {\n+        assert(old_ext_size == 0, \"sanity\");\n+        _RM_UP_EXT = NEW_ARENA_ARRAY(_arena, uintptr_t, new_ext_size);\n+      } else {\n+        assert(orig_ext_adr == &_RM_UP_EXT, \"clone sanity check\");\n+        _RM_UP_EXT = REALLOC_ARENA_ARRAY(_arena, uintptr_t, _RM_UP_EXT,\n+                                         old_ext_size, new_ext_size);\n+      }\n+      if (init) {\n+        int fill = 0;\n+        if (is_AllStack()) {\n+          fill = 0xFF;\n+          _hwm = _rm_max();\n+        }\n+        _set_range(old_size, fill, _rm_size - old_size);\n+      }\n+    }\n+  }\n+\n+  \/\/ Make us a copy of src\n+  void _copy(const RegMask& src) {\n+    assert(_offset == src._offset, \"offset mismatch\");\n+    _hwm = src._hwm;\n+    _lwm = src._lwm;\n+\n+    \/\/ Copy base mask\n+    memcpy(_RM_UP, src._RM_UP, sizeof(uintptr_t) * _RM_SIZE);\n+    _all_stack = src._all_stack;\n+\n+    \/\/ Copy extension\n+    if (src._RM_UP_EXT != nullptr) {\n+      assert(src._rm_size > _RM_SIZE, \"sanity\");\n+      assert(orig_ext_adr == &_RM_UP_EXT, \"clone sanity check\");\n+      _grow(src._rm_size, false);\n+      memcpy(_RM_UP_EXT, src._RM_UP_EXT,\n+             sizeof(uintptr_t) * (src._rm_size - _RM_SIZE));\n+    }\n+\n+    \/\/ If the source is smaller than us, we need to set the gap according to\n+    \/\/ the sources all_stack flag.\n+    if (src._rm_size < _rm_size) {\n+      int value = 0;\n+      if (src.is_AllStack()) {\n+        value = 0xFF;\n+        _hwm = _rm_max();\n+      }\n+      _set_range(src._rm_size, value, _rm_size - src._rm_size);\n+    }\n+\n+    assert(valid_watermarks(), \"post-condition\");\n+  }\n+\n+  void _trim_watermarks() {\n+    if (_hwm < _lwm) {\n+      return;\n+    }\n+    while ((_hwm > _lwm) && _rm_up(_hwm) == 0) {\n+      _hwm--;\n+    }\n+    while ((_lwm < _hwm) && _rm_up(_lwm) == 0) {\n+      _lwm++;\n+    }\n+    if ((_lwm == _hwm) && _rm_up(_lwm) == 0) {\n+      _lwm = _rm_max();\n+      _hwm = 0;\n+    }\n+  }\n+\n+  \/\/ Set a span of words in the register mask to a given value.\n+  void _set_range(unsigned int start, int value, unsigned int length) {\n+    if (start < _RM_SIZE) {\n+      memset(_RM_UP + start, value,\n+             sizeof(uintptr_t) * MIN2((int)length, (int)_RM_SIZE - (int)start));\n+    }\n+    if (start + length > _RM_SIZE) {\n+      assert(_RM_UP_EXT != nullptr, \"sanity\");\n+      assert(orig_ext_adr == &_RM_UP_EXT, \"clone sanity check\");\n+      memset(_RM_UP_EXT + MAX2((int)start - (int)_RM_SIZE, 0), value,\n+             sizeof(uintptr_t) *\n+                 MIN2((int)length, (int)length - ((int)_RM_SIZE - (int)start)));\n+    }\n+  }\n+\n+public:\n+  unsigned int rm_size() const {\n+    return _rm_size;\n+  }\n+  unsigned int rm_size_bits() const {\n+    return _rm_size * BitsPerWord;\n+  }\n+\n+  bool is_offset() const {\n+    return _offset > 0;\n+  }\n+  unsigned int offset_bits() const {\n+    return _offset * BitsPerWord;\n+  };\n+\n+  bool is_AllStack() const {\n+    return _all_stack;\n+  }\n+  void set_AllStack(bool value = true) {\n+    _all_stack = value;\n+  }\n@@ -116,1 +385,1 @@\n-    FORALL_BODY\n+      FORALL_BODY\n@@ -118,1 +387,2 @@\n-    int dummy = 0) {\n+      bool all_stack)\n+      : _rm_size(_RM_SIZE), _offset(0), _all_stack(all_stack), _arena(nullptr) {\n@@ -134,7 +404,4 @@\n-  \/\/ Handy copying constructor\n-  RegMask(RegMask *rm) {\n-    _hwm = rm->_hwm;\n-    _lwm = rm->_lwm;\n-    for (unsigned i = 0; i < _RM_SIZE; i++) {\n-      _RM_UP[i] = rm->_RM_UP[i];\n-    }\n+  \/\/ Construct an empty mask\n+  RegMask(Arena* arena)\n+      : _RM_UP(), _rm_size(_RM_SIZE), _offset(0), _all_stack(false),\n+        _lwm(_RM_MAX), _hwm(0), _arena(arena) {\n@@ -143,3 +410,1 @@\n-\n-  \/\/ Construct an empty mask\n-  RegMask() : _RM_UP(), _lwm(_RM_MAX), _hwm(0) {\n+  RegMask() : RegMask(nullptr) {\n@@ -150,1 +415,4 @@\n-  RegMask(OptoReg::Name reg) : RegMask() {\n+  RegMask(OptoReg::Name reg,\n+          Arena* arena\n+          DEBUG_ONLY(COMMA bool orig_const = false))\n+      : RegMask(arena) {\n@@ -152,0 +420,1 @@\n+    DEBUG_ONLY(this->orig_const = orig_const;)\n@@ -153,0 +422,1 @@\n+  RegMask(OptoReg::Name reg) : RegMask(reg, nullptr) {}\n@@ -154,6 +424,3 @@\n-  \/\/ Check for register being in mask\n-  bool Member(OptoReg::Name reg) const {\n-    assert(reg < CHUNK_SIZE, \"\");\n-\n-    unsigned r = (unsigned)reg;\n-    return _RM_UP[r >> _LogWordBits] & (uintptr_t(1) << (r & _WordBitMask));\n+  RegMask(const RegMask& rm, Arena* arena)\n+      : _rm_size(_RM_SIZE), _offset(rm._offset), _arena(arena) {\n+    _copy(rm);\n@@ -162,5 +429,5 @@\n-  \/\/ The last bit in the register mask indicates that the mask should repeat\n-  \/\/ indefinitely with ONE bits.  Returns TRUE if mask is infinite or\n-  \/\/ unbounded in size.  Returns FALSE if mask is finite size.\n-  bool is_AllStack() const {\n-    return (_RM_UP[_RM_MAX] & (uintptr_t(1) << _WordBitMask)) != 0;\n+  RegMask(const RegMask& rm) : RegMask(rm, nullptr) {}\n+\n+  RegMask& operator=(const RegMask& rm) {\n+    _copy(rm);\n+    return *this;\n@@ -169,2 +436,10 @@\n-  void set_AllStack() {\n-    _RM_UP[_RM_MAX] |= (uintptr_t(1) << _WordBitMask);\n+  bool Member(OptoReg::Name reg) const {\n+    reg = reg - offset_bits();\n+    if (reg < 0) {\n+      return false;\n+    }\n+    if (reg >= (int)rm_size_bits()) {\n+      return is_AllStack();\n+    }\n+    unsigned int r = (unsigned int)reg;\n+    return _rm_up(r >> _LogWordBits) & (uintptr_t(1) << (r & _WordBitMask));\n@@ -173,2 +448,2 @@\n-  \/\/ Test for being a not-empty mask.\n-  bool is_NotEmpty() const {\n+  \/\/ Empty mask check. Ignores registers included through the all-stack flag.\n+  bool is_Empty() const {\n@@ -176,1 +451,0 @@\n-    uintptr_t tmp = 0;\n@@ -178,1 +452,3 @@\n-      tmp |= _RM_UP[i];\n+      if (_rm_up(i)) {\n+        return false;\n+      }\n@@ -180,1 +456,1 @@\n-    return tmp;\n+    return true;\n@@ -187,1 +463,1 @@\n-      uintptr_t bits = _RM_UP[i];\n+      uintptr_t bits = _rm_up(i);\n@@ -189,1 +465,2 @@\n-        return OptoReg::Name((i << _LogWordBits) + find_lowest_bit(bits));\n+        return OptoReg::Name(offset_bits() + (i << _LogWordBits) +\n+                             find_lowest_bit(bits));\n@@ -195,1 +472,2 @@\n-  \/\/ Get highest-numbered register from mask, or BAD if mask is empty.\n+  \/\/ Get highest-numbered register from mask, or BAD if mask is empty. Ignores\n+  \/\/ registers included through the all-stack flag.\n@@ -201,1 +479,1 @@\n-      uintptr_t bits = _RM_UP[--i];\n+      uintptr_t bits = _rm_up(--i);\n@@ -203,1 +481,2 @@\n-        return OptoReg::Name((i << _LogWordBits) + find_highest_bit(bits));\n+        return OptoReg::Name(offset_bits() + (i << _LogWordBits) +\n+                             find_highest_bit(bits));\n@@ -216,2 +495,2 @@\n-    assert(_hwm < _RM_SIZE, \"_hwm out of range: %d\", _hwm);\n-    assert(_lwm < _RM_SIZE, \"_lwm out of range: %d\", _lwm);\n+    assert(_hwm < _rm_size, \"_hwm out of range: %d\", _hwm);\n+    assert(_lwm < _rm_size, \"_lwm out of range: %d\", _lwm);\n@@ -219,1 +498,1 @@\n-      assert(_RM_UP[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n+      assert(_rm_up(i) == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n@@ -221,2 +500,2 @@\n-    for (unsigned i = _hwm + 1; i < _RM_SIZE; i++) {\n-      assert(_RM_UP[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n+    for (unsigned i = _hwm + 1; i < _rm_size; i++) {\n+      assert(_rm_up(i) == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n@@ -226,0 +505,9 @@\n+\n+  bool is_AllStack_only() const {\n+    assert(valid_watermarks(), \"sanity\");\n+    uintptr_t tmp = 0;\n+    for (unsigned int i = _lwm; i <= _hwm; i++) {\n+      tmp |= _rm_up(i);\n+    }\n+    return !tmp && is_AllStack();\n+  }\n@@ -263,1 +551,1 @@\n-  \/\/ Fast overlap test.  Non-zero if any registers in common.\n+  \/\/ Overlap test. Non-zero if any registers in common, including all-stack.\n@@ -265,0 +553,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -266,0 +555,3 @@\n+\n+    \/\/ Very common overlap case: _rm_up overlap. Check first to reduce\n+    \/\/ execution time.\n@@ -268,1 +560,0 @@\n-    uintptr_t result = 0;\n@@ -270,1 +561,10 @@\n-      result |= _RM_UP[i] & rm._RM_UP[i];\n+      if (_rm_up(i) & rm._rm_up(i)) {\n+        return true;\n+      }\n+    }\n+\n+    \/\/ Very rare overlap cases below.\n+\n+    \/\/ We are both all-stack\n+    if (is_AllStack() && rm.is_AllStack()) {\n+      return true;\n@@ -272,1 +572,21 @@\n-    return result;\n+\n+    \/\/ We are all-stack and rm _hwm is bigger than us\n+    if (is_AllStack() && rm._hwm >= _rm_size) {\n+      for (unsigned i = MAX2(rm._lwm, _rm_size); i <= rm._hwm; i++) {\n+        if (rm._rm_up(i)) {\n+          return true;\n+        }\n+      }\n+    }\n+\n+    \/\/ rm is all-stack and our _hwm is bigger than rm\n+    if (rm.is_AllStack() && _hwm >= rm._rm_size) {\n+      for (unsigned i = MAX2(_lwm, rm._rm_size); i <= _hwm; i++) {\n+        if (_rm_up(i)) {\n+          return true;\n+        }\n+      }\n+    }\n+\n+    \/\/ No overlap (also very common)\n+    return false;\n@@ -279,1 +599,1 @@\n-  \/\/ Clear a register mask\n+  \/\/ Clear a register mask. Does not clear any offset.\n@@ -281,1 +601,1 @@\n-    _lwm = _RM_MAX;\n+    _lwm = _rm_max();\n@@ -283,1 +603,2 @@\n-    memset(_RM_UP, 0, sizeof(uintptr_t) * _RM_SIZE);\n+    _set_range(0, 0, _rm_size);\n+    set_AllStack(false);\n@@ -289,0 +610,6 @@\n+    assert(_offset == 0, \"offset non-zero\");\n+    Set_All_From_Offset();\n+  }\n+\n+  \/\/ Fill a register mask with 1's from the current offset.\n+  void Set_All_From_Offset() {\n@@ -290,2 +617,3 @@\n-    _hwm = _RM_MAX;\n-    memset(_RM_UP, 0xFF, sizeof(uintptr_t) * _RM_SIZE);\n+    _hwm = _rm_max();\n+    _set_range(0, 0xFF, _rm_size);\n+    set_AllStack(true);\n@@ -295,0 +623,23 @@\n+  \/\/ Fill a register mask with 1's starting from the given register.\n+  void Set_All_From(OptoReg::Name reg) {\n+    reg = reg - offset_bits();\n+    assert(reg != OptoReg::Bad, \"sanity\");\n+    assert(reg != OptoReg::Special, \"sanity\");\n+    assert(reg >= 0, \"register outside mask\");\n+    assert(valid_watermarks(), \"pre-condition\");\n+    unsigned int r = (unsigned int)reg;\n+    unsigned int index = r >> _LogWordBits;\n+    unsigned int min_size = index + 1;\n+    _grow(min_size);\n+    _rm_up(index) |= (uintptr_t(-1) << (r & _WordBitMask));\n+    if (index < _rm_max()) {\n+      _set_range(index + 1, 0xFF, _rm_max() - index);\n+    }\n+    if (index < _lwm) {\n+      _lwm = index;\n+    }\n+    _hwm = _rm_max();\n+    set_AllStack();\n+    assert(valid_watermarks(), \"post-condition\");\n+  }\n+\n@@ -297,0 +648,1 @@\n+    reg = reg - offset_bits();\n@@ -299,1 +651,1 @@\n-    assert(reg < CHUNK_SIZE, \"sanity\");\n+    assert(reg >= 0, \"register outside mask\");\n@@ -301,2 +653,4 @@\n-    unsigned r = (unsigned)reg;\n-    unsigned index = r >> _LogWordBits;\n+    unsigned int r = (unsigned int)reg;\n+    unsigned int index = r >> _LogWordBits;\n+    unsigned int min_size = index + 1;\n+    _grow(min_size);\n@@ -305,1 +659,1 @@\n-    _RM_UP[index] |= (uintptr_t(1) << (r & _WordBitMask));\n+    _rm_up(index) |= (uintptr_t(1) << (r & _WordBitMask));\n@@ -311,3 +665,5 @@\n-    assert(reg < CHUNK_SIZE, \"\");\n-    unsigned r = (unsigned)reg;\n-    _RM_UP[r >> _LogWordBits] &= ~(uintptr_t(1) << (r & _WordBitMask));\n+    reg = reg - offset_bits();\n+    assert(reg >= 0, \"register outside mask\");\n+    assert(reg < (int)rm_size_bits(), \"register outside mask\");\n+    unsigned int r = (unsigned int)reg;\n+    _rm_up(r >> _LogWordBits) &= ~(uintptr_t(1) << (r & _WordBitMask));\n@@ -318,0 +674,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -319,0 +676,1 @@\n+    _grow(rm._rm_size);\n@@ -322,2 +680,9 @@\n-    for (unsigned i = _lwm; i <= _hwm; i++) {\n-      _RM_UP[i] |= rm._RM_UP[i];\n+    \/\/ Compute OR with all words from rm\n+    for (unsigned int i = _lwm; i <= _hwm && i < rm._rm_size; i++) {\n+      _rm_up(i) |= rm._rm_up(i);\n+    }\n+    \/\/ If rm is smaller than us and has the all-stack flag set, we need to set\n+    \/\/ all bits in the gap to 1.\n+    if (rm.is_AllStack() && rm._rm_size < _rm_size) {\n+      _set_range(rm._rm_size, 0xFF, _rm_size - rm._rm_size);\n+      _hwm = _rm_max();\n@@ -325,0 +690,1 @@\n+    set_AllStack(is_AllStack() || rm.is_AllStack());\n@@ -330,0 +696,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -331,4 +698,22 @@\n-    \/\/ Do not evaluate words outside the current watermark range, as they are\n-    \/\/ already zero and an &= would not change that\n-    for (unsigned i = _lwm; i <= _hwm; i++) {\n-      _RM_UP[i] &= rm._RM_UP[i];\n+    _grow(rm._rm_size);\n+    \/\/ Compute AND with all words from rm. Do not evaluate words outside the\n+    \/\/ current watermark range, as they are already zero and an &= would not\n+    \/\/ change that\n+    for (unsigned int i = _lwm; i <= _hwm && i < rm._rm_size; i++) {\n+      _rm_up(i) &= rm._rm_up(i);\n+    }\n+    \/\/ If rm is smaller than our high watermark and has the all-stack flag not\n+    \/\/ set, we need to set all bits in the gap to 0.\n+    if (!rm.is_AllStack() && _hwm > rm._rm_max()) {\n+      _set_range(rm._rm_size, 0, _hwm - rm._rm_max());\n+      _hwm = rm._rm_max();\n+    }\n+    \/\/ Narrow the watermarks if &rm spans a narrower range. Update after to\n+    \/\/ ensure non-overlapping words are zeroed out. If rm has the all-stack\n+    \/\/ flag set and is smaller than our high watermark, take care not to\n+    \/\/ incorrectly lower the high watermark according to rm.\n+    if (_lwm < rm._lwm) {\n+      _lwm = rm._lwm;\n+    }\n+    if (_hwm > rm._hwm && !(rm.is_AllStack() && _hwm > rm._rm_max())) {\n+      _hwm = rm._hwm;\n@@ -336,4 +721,2 @@\n-    \/\/ Narrow the watermarks if &rm spans a narrower range.\n-    \/\/ Update after to ensure non-overlapping words are zeroed out.\n-    if (_lwm < rm._lwm) _lwm = rm._lwm;\n-    if (_hwm > rm._hwm) _hwm = rm._hwm;\n+    set_AllStack(is_AllStack() && rm.is_AllStack());\n+    assert(valid_watermarks(), \"sanity\");\n@@ -342,1 +725,1 @@\n-  \/\/ Subtract 'rm' from 'this'\n+  \/\/ Subtract 'rm' from 'this'.\n@@ -344,0 +727,1 @@\n+    assert(_offset == rm._offset, \"offset mismatch\");\n@@ -345,4 +729,48 @@\n-    unsigned hwm = MIN2(_hwm, rm._hwm);\n-    unsigned lwm = MAX2(_lwm, rm._lwm);\n-    for (unsigned i = lwm; i <= hwm; i++) {\n-      _RM_UP[i] &= ~rm._RM_UP[i];\n+    _grow(rm._rm_size);\n+    unsigned int hwm = MIN2(_hwm, rm._hwm);\n+    unsigned int lwm = MAX2(_lwm, rm._lwm);\n+    for (unsigned int i = lwm; i <= hwm; i++) {\n+      _rm_up(i) &= ~rm._rm_up(i);\n+    }\n+    \/\/ If rm is smaller than our high watermark and has the all-stack flag set,\n+    \/\/ we need to set all bits in the gap to 0.\n+    if (rm.is_AllStack() && _hwm > rm._rm_max()) {\n+      _set_range(rm.rm_size(), 0, _hwm - rm._rm_max());\n+      _hwm = rm._rm_max();\n+    }\n+    set_AllStack(is_AllStack() && !rm.is_AllStack());\n+    _trim_watermarks();\n+    assert(valid_watermarks(), \"sanity\");\n+  }\n+\n+  \/\/ Subtract 'rm' from 'this', but ignore everything in 'rm' that does not\n+  \/\/ overlap with us and to not modify our all-stack flag. Supports masks of\n+  \/\/ differing offsets. Does not support 'rm' with the all-stack flag set.\n+  void SUBTRACT_inner(const RegMask& rm) {\n+    assert(valid_watermarks() && rm.valid_watermarks(), \"sanity\");\n+    assert(!rm.is_AllStack(), \"not supported\");\n+    \/\/ Various translations due to differing offsets\n+    int rm_index_diff = _offset - rm._offset;\n+    int rm_hwm_tr = (int)rm._hwm - rm_index_diff;\n+    int rm_lwm_tr = (int)rm._lwm - rm_index_diff;\n+    int rm_rm_max_tr = (int)rm._rm_max() - rm_index_diff;\n+    int rm_rm_size_tr = (int)rm._rm_size - rm_index_diff;\n+    int hwm = MIN2((int)_hwm, rm_hwm_tr);\n+    int lwm = MAX2((int)_lwm, rm_lwm_tr);\n+    for (int i = lwm; i <= hwm; i++) {\n+      assert(i + rm_index_diff < (int)rm._rm_size, \"sanity\");\n+      assert(i + rm_index_diff >= 0, \"sanity\");\n+      _rm_up(i) &= ~rm._rm_up(i + rm_index_diff);\n+    }\n+    _trim_watermarks();\n+    assert(valid_watermarks(), \"sanity\");\n+  }\n+\n+  \/\/ Roll over the register mask. The main use is to expose a new set of stack\n+  \/\/ slots for the register allocator. Return if the rollover succeeded or not.\n+  bool rollover() {\n+    assert(is_AllStack_only(), \"rolling over non-empty mask\");\n+    if (!OptoRegPair::can_fit((_rm_size + _offset + _rm_size) * BitsPerWord - 1)) {\n+      \/\/ Ensure that register masks cannot roll over beyond the point at which\n+      \/\/ OptoRegPair can no longer index the whole mask.\n+      return false;\n@@ -350,0 +778,3 @@\n+    _offset += _rm_size;\n+    Set_All_From_Offset();\n+    return true;\n@@ -353,1 +784,8 @@\n-  uint Size() const;\n+  uint Size() const {\n+    uint sum = 0;\n+    assert(valid_watermarks(), \"sanity\");\n+    for (unsigned i = _lwm; i <= _hwm; i++) {\n+      sum += population_count(_rm_up(i));\n+    }\n+    return sum;\n+  }\n@@ -356,0 +794,39 @@\n+private:\n+  bool _dump_end_run(outputStream* st, OptoReg::Name start,\n+                     OptoReg::Name last) const;\n+\n+public:\n+  unsigned int static basic_rm_size() { return _RM_SIZE; }\n+  unsigned int static rm_size_max_bits() {\n+    return _RM_SIZE_MAX * BitsPerWord;\n+  }\n+  bool equals(const RegMask& rm) const {\n+    assert(_offset == rm._offset, \"offset mismatch\");\n+    if (_all_stack != rm._all_stack) {\n+      return false;\n+    }\n+    \/\/ Shared segment\n+    for (unsigned int i = 0; i < MIN2(_rm_size, rm._rm_size); i++) {\n+      if (_rm_up(i) != rm._rm_up(i)) {\n+        return false;\n+      }\n+    }\n+    \/\/ If there is a size difference, check the protruding segment against\n+    \/\/ all-stack.\n+    const unsigned int start = MIN2(_rm_size, rm._rm_size);\n+    const uintptr_t value = _all_stack ? uintptr_t(-1) : 0;\n+    for (unsigned int i = start; i < _rm_size; i++) {\n+      if (_rm_up(i) != value) {\n+        return false;\n+      }\n+    }\n+    for (unsigned int i = start; i < rm._rm_size; i++) {\n+      if (rm._rm_up(i) != value) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+  void set_offset(unsigned int offset) {\n+    _offset = offset;\n+  }\n@@ -358,0 +835,1 @@\n+  void dump_hex(outputStream* st = tty) const; \/\/ Print a mask (raw hex)\n@@ -363,9 +841,3 @@\n-  static bool can_represent(OptoReg::Name reg, unsigned int size = 1) {\n-    \/\/ NOTE: MAX2(1U,size) in computation reflects the usage of the last\n-    \/\/       bit of the regmask as an infinite stack flag.\n-    return (int)reg < (int)(CHUNK_SIZE - MAX2(1U,size));\n-  }\n-  static bool can_represent_arg(OptoReg::Name reg) {\n-    \/\/ NOTE: SlotsPerVecZ in computation reflects the need\n-    \/\/       to keep mask aligned for largest value (VecZ).\n-    return can_represent(reg, SlotsPerVecZ);\n+  bool can_represent(OptoReg::Name reg, unsigned int size = 1) const {\n+    reg = reg - offset_bits();\n+    return reg >= 0 && reg <= (int)(rm_size_bits() - size);\n@@ -418,1 +890,1 @@\n-      _current_bits = _rm._RM_UP[_next_index++];\n+      _current_bits = _rm._rm_up(_next_index++);\n@@ -426,1 +898,3 @@\n-        _reg = OptoReg::Name(((_next_index - 1) << RegMask::_LogWordBits) + next_bit);\n+        _reg = OptoReg::Name(_rm.offset_bits() +\n+                             ((_next_index - 1) << RegMask::_LogWordBits) +\n+                             next_bit);\n@@ -437,1 +911,1 @@\n-\/\/ Do not use this constant directly in client code!\n+\/\/ Do not use these constants directly in client code!\n@@ -439,0 +913,1 @@\n+#undef RM_SIZE_MIN\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":574,"deletions":99,"binary":false,"changes":673,"status":"modified"},{"patch":"@@ -561,0 +561,1 @@\n+const int max_method_parameter_length = 255; \/\/ JVM spec, 22nd ed. section 4.3.3 (p.83)\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"opto\/chaitin.hpp\"\n@@ -29,1 +30,3 @@\n-\/\/ Sanity tests for RegMask and RegMaskIterator\n+\/\/ Sanity tests for RegMask and RegMaskIterator. The file tests operations on\n+\/\/ combinations of different RegMask versions (\"basic\", i.e. only statically\n+\/\/ allocated and \"extended\", i.e. extended with dynamically allocated memory).\n@@ -35,1 +38,1 @@\n-    ASSERT_TRUE(rm.is_NotEmpty());\n+    ASSERT_TRUE(!rm.is_Empty());\n@@ -37,1 +40,1 @@\n-    ASSERT_TRUE(!rm.is_NotEmpty());\n+    ASSERT_TRUE(rm.is_Empty());\n@@ -82,1 +85,1 @@\n-  \/\/ Check that Set_All doesn't add bits outside of CHUNK_SIZE\n+  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits()\n@@ -85,2 +88,2 @@\n-  ASSERT_TRUE(rm.Size() == RegMask::CHUNK_SIZE);\n-  ASSERT_TRUE(rm.is_NotEmpty());\n+  ASSERT_TRUE(rm.Size() == rm.rm_size_bits());\n+  ASSERT_TRUE(!rm.is_Empty());\n@@ -89,1 +92,1 @@\n-  contains_expected_num_of_registers(rm, RegMask::CHUNK_SIZE);\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits());\n@@ -135,1 +138,1 @@\n-  for (int i = 17; i < RegMask::CHUNK_SIZE; i++) {\n+  for (int i = 17; i < (int)rm1.rm_size_bits(); i++) {\n@@ -138,0 +141,1 @@\n+  rm1.set_AllStack();\n@@ -140,1 +144,13 @@\n-  contains_expected_num_of_registers(rm1, RegMask::CHUNK_SIZE - 17);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_bits() - 17);\n+  contains_expected_num_of_registers(rm2, 17);\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  rm2.Set_All();\n+  for (int i = 17; i < (int)rm1.rm_size_bits(); i++) {\n+    rm1.Insert(i);\n+  }\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_bits() - 17);\n@@ -147,1 +163,1 @@\n-  for (int i = 0; i < RegMask::CHUNK_SIZE - 1; i++) {\n+  for (int i = 0; i < (int)rm.rm_size_bits() - 1; i++) {\n@@ -162,1 +178,1 @@\n-  for (int i = 0; i < RegMask::CHUNK_SIZE - 2; i++) {\n+  for (int i = 0; i < (int)rm.rm_size_bits() - 2; i++) {\n@@ -173,2 +189,3 @@\n-  rm.Insert(RegMask::CHUNK_SIZE - 2);\n-  rm.Insert(RegMask::CHUNK_SIZE - 1);\n+  rm.Insert(rm.rm_size_bits() - 2);\n+  rm.Insert(rm.rm_size_bits() - 1);\n+  rm.set_AllStack();\n@@ -182,1 +199,1 @@\n-    for (int i = 0; i < RegMask::CHUNK_SIZE - size; i++) {\n+    for (int i = 0; i < (int)rm.rm_size_bits() - size; i++) {\n@@ -191,2 +208,2 @@\n-    for (int j = RegMask::CHUNK_SIZE - size; j < RegMask::CHUNK_SIZE; j++) {\n-        rm.Insert(j);\n+    for (int j = rm.rm_size_bits() - size; j < (int)rm.rm_size_bits(); j++) {\n+      rm.Insert(j);\n@@ -194,0 +211,1 @@\n+    rm.set_AllStack();\n@@ -197,1 +215,1008 @@\n-}\n\\ No newline at end of file\n+}\n+\n+TEST_VM(RegMask, external_member) {\n+  RegMask rm;\n+  rm.set_AllStack(false);\n+  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+  rm.set_AllStack(true);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+}\n+\n+TEST_VM(RegMask, find_element) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(44));\n+  rm.Insert(OptoReg::Name(30));\n+  rm.Insert(OptoReg::Name(54));\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Name(30));\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Name(54));\n+  rm.set_AllStack(true);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Name(54));\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Bad);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Bad);\n+}\n+\n+TEST_VM(RegMask, find_first_set) {\n+  RegMask rm;\n+  LRG lrg;\n+  lrg._is_scalable = 0;\n+  lrg._is_vector = 0;\n+  ASSERT_EQ(rm.find_first_set(lrg, 2), OptoReg::Bad);\n+  rm.Insert(OptoReg::Name(24));\n+  rm.Insert(OptoReg::Name(25));\n+  rm.Insert(OptoReg::Name(26));\n+  rm.Insert(OptoReg::Name(27));\n+  rm.Insert(OptoReg::Name(16));\n+  rm.Insert(OptoReg::Name(17));\n+  rm.Insert(OptoReg::Name(18));\n+  rm.Insert(OptoReg::Name(19));\n+  ASSERT_EQ(rm.find_first_set(lrg, 4), OptoReg::Name(19));\n+}\n+\n+TEST_VM(RegMask, alignment) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(30));\n+  rm.Insert(OptoReg::Name(31));\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  rm.Insert(OptoReg::Name(32));\n+  rm.Insert(OptoReg::Name(37));\n+  rm.Insert(OptoReg::Name(62));\n+  rm.Insert(OptoReg::Name(71));\n+  rm.Insert(OptoReg::Name(74));\n+  rm.Insert(OptoReg::Name(75));\n+  ASSERT_FALSE(rm.is_aligned_pairs());\n+  rm.clear_to_pairs();\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  ASSERT_TRUE(rm.is_aligned_pairs());\n+  contains_expected_num_of_registers(rm, 4);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(30)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(31)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(74)));\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(75)));\n+  ASSERT_FALSE(rm.is_misaligned_pair());\n+  rm.Remove(OptoReg::Name(30));\n+  rm.Remove(OptoReg::Name(74));\n+  ASSERT_TRUE(rm.is_misaligned_pair());\n+}\n+\n+TEST_VM(RegMask, clear_to_sets) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(20));\n+  rm.Insert(OptoReg::Name(21));\n+  rm.Insert(OptoReg::Name(22));\n+  rm.Insert(OptoReg::Name(23));\n+  rm.Insert(OptoReg::Name(25));\n+  rm.Insert(OptoReg::Name(26));\n+  rm.Insert(OptoReg::Name(27));\n+  rm.Insert(OptoReg::Name(40));\n+  rm.Insert(OptoReg::Name(42));\n+  rm.Insert(OptoReg::Name(43));\n+  rm.Insert(OptoReg::Name(44));\n+  rm.Insert(OptoReg::Name(45));\n+  rm.clear_to_sets(2);\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  contains_expected_num_of_registers(rm, 10);\n+  rm.clear_to_sets(4);\n+  ASSERT_TRUE(rm.is_aligned_sets(4));\n+  contains_expected_num_of_registers(rm, 4);\n+  rm.clear_to_sets(8);\n+  ASSERT_TRUE(rm.is_aligned_sets(8));\n+  contains_expected_num_of_registers(rm, 0);\n+}\n+\n+TEST_VM(RegMask, smear_to_sets) {\n+  RegMask rm;\n+  rm.Insert(OptoReg::Name(3));\n+  rm.smear_to_sets(2);\n+  ASSERT_TRUE(rm.is_aligned_sets(2));\n+  contains_expected_num_of_registers(rm, 2);\n+  rm.smear_to_sets(4);\n+  ASSERT_TRUE(rm.is_aligned_sets(4));\n+  contains_expected_num_of_registers(rm, 4);\n+  rm.smear_to_sets(8);\n+  ASSERT_TRUE(rm.is_aligned_sets(8));\n+  contains_expected_num_of_registers(rm, 8);\n+  rm.smear_to_sets(16);\n+  ASSERT_TRUE(rm.is_aligned_sets(16));\n+  contains_expected_num_of_registers(rm, 16);\n+}\n+\n+TEST_VM(RegMask, overlap) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(23));\n+  rm1.Insert(OptoReg::Name(2));\n+  rm1.Insert(OptoReg::Name(12));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(4));\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(4));\n+  ASSERT_TRUE(rm1.overlap(rm2));\n+  ASSERT_TRUE(rm2.overlap(rm1));\n+}\n+\n+TEST_VM(RegMask, valid_reg) {\n+  RegMask rm;\n+  ASSERT_FALSE(rm.is_valid_reg(OptoReg::Name(42), 1));\n+  rm.Insert(OptoReg::Name(3));\n+  rm.Insert(OptoReg::Name(5));\n+  rm.Insert(OptoReg::Name(6));\n+  rm.Insert(OptoReg::Name(7));\n+  ASSERT_FALSE(rm.is_valid_reg(OptoReg::Name(7), 4));\n+  ASSERT_TRUE(rm.is_valid_reg(OptoReg::Name(7), 2));\n+}\n+\n+TEST_VM(RegMask, rollover_and_insert_remove) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  OptoReg::Name reg2(rm.rm_size_bits() * 2 + 42);\n+  rm.set_AllStack(true);\n+  ASSERT_TRUE(rm.Member(reg1));\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg1);\n+  ASSERT_TRUE(rm.Member(reg1));\n+  rm.Remove(reg1);\n+  ASSERT_FALSE(rm.Member(reg1));\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg2);\n+  ASSERT_FALSE(rm.Member(reg1));\n+  ASSERT_TRUE(rm.Member(reg2));\n+}\n+\n+TEST_VM(RegMask, rollover_and_find) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  OptoReg::Name reg2(rm.rm_size_bits() + 7);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_elem(), OptoReg::Bad);\n+  ASSERT_EQ(rm.find_last_elem(), OptoReg::Bad);\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  ASSERT_EQ(rm.find_first_elem(), reg2);\n+  ASSERT_EQ(rm.find_last_elem(), reg1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_find_first_set) {\n+  LRG lrg;\n+  lrg._is_scalable = 0;\n+  lrg._is_vector = 0;\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 24);\n+  OptoReg::Name reg2(rm.rm_size_bits() + 25);\n+  OptoReg::Name reg3(rm.rm_size_bits() + 26);\n+  OptoReg::Name reg4(rm.rm_size_bits() + 27);\n+  OptoReg::Name reg5(rm.rm_size_bits() + 16);\n+  OptoReg::Name reg6(rm.rm_size_bits() + 17);\n+  OptoReg::Name reg7(rm.rm_size_bits() + 18);\n+  OptoReg::Name reg8(rm.rm_size_bits() + 19);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  ASSERT_EQ(rm.find_first_set(lrg, 2), OptoReg::Bad);\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  rm.Insert(reg3);\n+  rm.Insert(reg4);\n+  rm.Insert(reg5);\n+  rm.Insert(reg6);\n+  rm.Insert(reg7);\n+  rm.Insert(reg8);\n+  ASSERT_EQ(rm.find_first_set(lrg, 4), reg8);\n+}\n+\n+TEST_VM(RegMask, rollover_and_Set_All_From) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Set_All_From(reg1);\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits() - 42);\n+}\n+\n+TEST_VM(RegMask, rollover_and_Set_All_From_Offset) {\n+  RegMask rm;\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Set_All_From_Offset();\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits());\n+}\n+\n+TEST_VM(RegMask, rollover_and_iterate) {\n+  RegMask rm;\n+  OptoReg::Name reg1(rm.rm_size_bits() + 2);\n+  OptoReg::Name reg2(rm.rm_size_bits() + 6);\n+  OptoReg::Name reg3(rm.rm_size_bits() + 17);\n+  OptoReg::Name reg4(rm.rm_size_bits() + 43);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Clear();\n+  rm.Insert(reg1);\n+  rm.Insert(reg2);\n+  rm.Insert(reg3);\n+  rm.Insert(reg4);\n+  RegMaskIterator rmi(rm);\n+  ASSERT_EQ(rmi.next(), reg1);\n+  ASSERT_EQ(rmi.next(), reg2);\n+  ASSERT_EQ(rmi.next(), reg3);\n+  ASSERT_EQ(rmi.next(), reg4);\n+  ASSERT_FALSE(rmi.has_next());\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  rm1.set_AllStack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(42);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap) {\n+  RegMask rm1;\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  rm1.set_AllStack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm2.set_AllStack(true);\n+  rm2.rollover();\n+  rm2.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(reg1);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm1.Insert(reg1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+#ifndef PRODUCT\n+\n+Arena* arena() {\n+  return Thread::current()->resource_area();\n+}\n+\n+static void is_basic(const RegMask& rm) {\n+  ASSERT_EQ(rm.rm_size(), RegMask::basic_rm_size());\n+}\n+\n+static void is_extended(const RegMask& rm) {\n+  ASSERT_TRUE(rm.rm_size() > RegMask::basic_rm_size());\n+}\n+\n+static int first_extended() {\n+  return RegMask::basic_rm_size() * BitsPerWord;\n+}\n+\n+static void extend(RegMask& rm, unsigned int n = 4) {\n+  \/\/ Extend the given RegMask with at least n dynamically-allocated words.\n+  rm.Insert(OptoReg::Name(first_extended() + (BitsPerWord * n) - 1));\n+  rm.Clear();\n+  ASSERT_TRUE(rm.rm_size() >= RegMask::basic_rm_size() + n);\n+}\n+\n+TEST_VM(RegMask, static_by_default) {\n+  \/\/ Check that a freshly created RegMask does not allocate dynamic memory.\n+  RegMask rm;\n+  is_basic(rm);\n+}\n+\n+TEST_VM(RegMask, iteration_extended) {\n+  RegMask rm(arena());\n+  rm.Insert(30);\n+  rm.Insert(31);\n+  rm.Insert(33);\n+  rm.Insert(62);\n+  rm.Insert(first_extended());\n+  rm.Insert(first_extended() + 42);\n+  rm.Insert(first_extended() + 55);\n+  rm.Insert(first_extended() + 456);\n+\n+  RegMaskIterator rmi(rm);\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(30));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(31));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(33));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(62));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended()));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 42));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 55));\n+  ASSERT_TRUE(rmi.next() == OptoReg::Name(first_extended() + 456));\n+  ASSERT_FALSE(rmi.has_next());\n+}\n+\n+TEST_VM(RegMask, Set_ALL_extended) {\n+  \/\/ Check that Set_All doesn't add bits outside of rm.rm_size_bits() on\n+  \/\/ extended RegMasks.\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.Set_All();\n+  ASSERT_EQ(rm.Size(), rm.rm_size_bits());\n+  ASSERT_TRUE(!rm.is_Empty());\n+  \/\/ Set_All sets AllStack bit\n+  ASSERT_TRUE(rm.is_AllStack());\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits());\n+}\n+\n+TEST_VM(RegMask, Set_ALL_From_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.Set_All_From(OptoReg::Name(42));\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits() - 42);\n+}\n+\n+TEST_VM(RegMask, Set_ALL_From_extended_grow) {\n+  RegMask rm(arena());\n+  rm.Set_All_From(first_extended() + OptoReg::Name(42));\n+  is_extended(rm);\n+  contains_expected_num_of_registers(rm, rm.rm_size_bits() - first_extended() - 42);\n+}\n+\n+TEST_VM(RegMask, Clear_extended) {\n+  \/\/ Check that Clear doesn't leave any stray bits on extended RegMasks.\n+  RegMask rm(arena());\n+  rm.Insert(first_extended());\n+  is_extended(rm);\n+  rm.Set_All();\n+  rm.Clear();\n+  contains_expected_num_of_registers(rm, 0);\n+}\n+\n+TEST_VM(RegMask, AND_extended_basic) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.AND(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2;\n+  is_basic(rm2);\n+  rm1.AND(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, AND_extended_extended) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.AND(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  rm1.AND(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, OR_extended_basic) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.OR(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2;\n+  is_basic(rm2);\n+  rm1.OR(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, OR_extended_extended) {\n+  RegMask rm1(arena());\n+  rm1.Insert(OptoReg::Name(first_extended()));\n+  is_extended(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended())));\n+\n+  rm1.OR(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  rm1.OR(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_extended) {\n+  RegMask rm1(arena());\n+  extend(rm1);\n+  RegMask rm2(arena());\n+  extend(rm2);\n+\n+  rm2.Set_All();\n+  ASSERT_TRUE(rm2.is_AllStack());\n+  for (int i = first_extended() + 17; i < (int)rm1.rm_size_bits(); i++) {\n+    rm1.Insert(i);\n+  }\n+  rm1.set_AllStack(true);\n+  ASSERT_TRUE(rm1.is_AllStack());\n+  rm2.SUBTRACT(rm1);\n+  contains_expected_num_of_registers(rm1, rm1.rm_size_bits() - first_extended() - 17);\n+  contains_expected_num_of_registers(rm2, first_extended() + 17);\n+}\n+\n+TEST_VM(RegMask, external_member_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  rm.set_AllStack(false);\n+  ASSERT_FALSE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+  rm.set_AllStack(true);\n+  ASSERT_TRUE(rm.Member(OptoReg::Name(rm.rm_size_bits())));\n+}\n+\n+TEST_VM(RegMask, overlap_extended) {\n+  RegMask rm1(arena());\n+  extend(rm1);\n+  RegMask rm2(arena());\n+  extend(rm2);\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(23));\n+  rm1.Insert(OptoReg::Name(2));\n+  rm1.Insert(OptoReg::Name(first_extended() + 12));\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(first_extended() + 4));\n+  ASSERT_FALSE(rm1.overlap(rm2));\n+  ASSERT_FALSE(rm2.overlap(rm1));\n+  rm1.Insert(OptoReg::Name(first_extended() + 4));\n+  ASSERT_TRUE(rm1.overlap(rm2));\n+  ASSERT_TRUE(rm2.overlap(rm1));\n+}\n+\n+TEST_VM(RegMask, up_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  ASSERT_TRUE(rm.is_UP());\n+  rm.Insert(OptoReg::Name(1));\n+  ASSERT_TRUE(rm.is_UP());\n+  rm.Insert(OptoReg::Name(first_extended()));\n+  ASSERT_FALSE(rm.is_UP());\n+  rm.Clear();\n+  rm.set_AllStack(true);\n+  ASSERT_FALSE(rm.is_UP());\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner_basic_extended) {\n+  RegMask rm1;\n+  RegMask rm2(arena());\n+  rm1.Insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(42));\n+  is_basic(rm1);\n+  rm2.Insert(OptoReg::Name(1));\n+  rm2.Insert(OptoReg::Name(first_extended() + 20));\n+  is_extended(rm2);\n+  rm1.SUBTRACT_inner(rm2);\n+  is_basic(rm1);\n+  contains_expected_num_of_registers(rm1, 1);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n+}\n+\n+TEST_VM(RegMask, SUBTRACT_inner_extended_basic) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  rm1.Insert(OptoReg::Name(1));\n+  rm1.Insert(OptoReg::Name(42));\n+  rm1.Insert(OptoReg::Name(first_extended() + 20));\n+  is_extended(rm1);\n+  rm2.Insert(OptoReg::Name(1));\n+  is_basic(rm2);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 2);\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(42)));\n+  ASSERT_TRUE(rm1.Member(OptoReg::Name(first_extended() + 20)));\n+}\n+\n+TEST_VM(RegMask, rollover_extended) {\n+  RegMask rm(arena());\n+  extend(rm);\n+  is_extended(rm);\n+  OptoReg::Name reg1(rm.rm_size_bits() + 42);\n+  rm.set_AllStack(true);\n+  rm.rollover();\n+  rm.Insert(reg1);\n+  ASSERT_TRUE(rm.Member(reg1));\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_disjoint_extended) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  extend(rm1);\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  rm1.set_AllStack(true);\n+  rm1.rollover();\n+  rm1.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(42);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 1);\n+}\n+\n+TEST_VM(RegMask, rollover_and_SUBTRACT_inner_overlap_extended) {\n+  RegMask rm1(arena());\n+  RegMask rm2;\n+  OptoReg::Name reg1(rm1.rm_size_bits() + 42);\n+  extend(rm1);\n+  rm2.set_AllStack(true);\n+  rm2.rollover();\n+  rm2.Clear();\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+  rm1.Insert(reg1);\n+  rm2.Insert(reg1);\n+  rm1.SUBTRACT_inner(rm2);\n+  contains_expected_num_of_registers(rm1, 0);\n+  rm1.Insert(reg1);\n+  rm2.SUBTRACT_inner(rm1);\n+  contains_expected_num_of_registers(rm2, 0);\n+}\n+\n+const uint iterations = 50000;\n+\n+static uint r;\n+static uint next_random() {\n+  r = os::next_random(r);\n+  return r;\n+}\n+static void init_random() {\n+  if (StressSeed == 0) {\n+    r = static_cast<uint>(Ticks::now().nanoseconds());\n+    tty->print_cr(\"seed: %u\", r);\n+  } else {\n+    r = StressSeed;\n+  }\n+}\n+\n+static void print(const char* name, const RegMask& mask) {\n+  tty->print(\"%s: \", name);\n+  mask.print();\n+  tty->print_cr(\", size: %u, offset: %u, all_stack: %u\", mask.rm_size_bits(),\n+                mask.offset_bits(), mask.is_AllStack());\n+}\n+\n+static void assert_equivalent(const RegMask& mask,\n+                              const ResourceBitMap& mask_ref,\n+                              bool all_stack_ref) {\n+  ASSERT_EQ(mask_ref.count_one_bits(), mask.Size());\n+  RegMaskIterator it(mask);\n+  OptoReg::Name reg = OptoReg::Bad;\n+  while (it.has_next()) {\n+    reg = it.next();\n+    ASSERT_TRUE(OptoReg::is_valid(reg));\n+    ASSERT_TRUE(mask_ref.at(reg));\n+  }\n+  ASSERT_EQ(all_stack_ref, mask.is_AllStack());\n+}\n+\n+static void populate_auxiliary_sets(RegMask& mask_aux,\n+                                    ResourceBitMap& mask_aux_ref,\n+                                    uint reg_capacity, uint offset,\n+                                    bool random_offset) {\n+  mask_aux.Clear();\n+  mask_aux_ref.clear();\n+  if (random_offset) {\n+    uint offset_in_words = offset \/ BitsPerWord;\n+    uint capacity_in_words = reg_capacity \/ BitsPerWord;\n+    uint new_offset_in_words;\n+    uint offset_target = next_random() % 3;\n+    switch (offset_target) {\n+    case 0: \/\/ before\n+      if (offset_in_words == 0) {\n+        new_offset_in_words = 0;\n+      } else {\n+        new_offset_in_words = next_random() % offset_in_words;\n+      }\n+      break;\n+    case 1: \/\/ within\n+      new_offset_in_words =\n+          (next_random() % capacity_in_words) + offset_in_words;\n+      break;\n+    case 2: \/\/ after\n+      new_offset_in_words = offset_in_words + capacity_in_words +\n+                            (next_random() % (capacity_in_words));\n+      break;\n+    default:\n+      FAIL();\n+    }\n+    offset = new_offset_in_words * BitsPerWord;\n+    if (offset + RegMask::rm_size_max_bits() > mask_aux_ref.size()) {\n+      \/\/ Ensure that there is space in the reference mask.\n+      offset = 0;\n+    }\n+  }\n+  mask_aux.set_offset(offset \/ BitsPerWord);\n+  assert_equivalent(mask_aux, mask_aux_ref, false);\n+  uint max_size;\n+  uint size_target = next_random() % 3;\n+  switch (size_target) {\n+  case 0: \/\/ smaller\n+    max_size = reg_capacity \/ 2;\n+    break;\n+  case 1: \/\/ equal\n+    max_size = reg_capacity;\n+    break;\n+  case 2: \/\/ larger (if possible)\n+    max_size = RegMask::rm_size_max_bits();\n+    break;\n+  default:\n+    FAIL();\n+  }\n+  uint regs;\n+  uint regs_target = next_random() % 3;\n+  switch (regs_target) {\n+  case 0: \/\/ sparse\n+    regs = next_random() % 8;\n+    break;\n+  case 1: \/\/ medium\n+    regs = next_random() % (max_size \/ 8);\n+    break;\n+  case 2: \/\/ dense\n+    regs = next_random() % max_size;\n+    break;\n+  default:\n+    FAIL();\n+  }\n+  for (uint i = 0; i < regs; i++) {\n+    uint reg = (next_random() % max_size) + offset;\n+    mask_aux.Insert(reg);\n+    mask_aux_ref.set_bit(reg);\n+  }\n+  mask_aux.set_AllStack(next_random() % 2);\n+  assert_equivalent(mask_aux, mask_aux_ref, mask_aux.is_AllStack());\n+\n+  if (Verbose) {\n+    print(\"mask_aux\", mask_aux);\n+  }\n+}\n+\n+static void stack_extend_ref_masks(ResourceBitMap& mask1, bool all_stack1,\n+                                   uint size_bits1, uint offset1,\n+                                   ResourceBitMap& mask2, bool all_stack2,\n+                                   uint size_bits2, uint offset2) {\n+  uint size_bits_after = MAX2(size_bits1, size_bits2);\n+  if (all_stack1) {\n+    mask1.set_range(size_bits1 + offset1, size_bits_after + offset1);\n+  }\n+  if (all_stack2) {\n+    mask2.set_range(size_bits2 + offset2, size_bits_after + offset2);\n+  }\n+}\n+\n+TEST_VM(RegMask, random) {\n+  ResourceMark rm;\n+  RegMask mask(arena());\n+  ResourceBitMap mask_ref(std::numeric_limits<short>::max() + 1);\n+  bool all_stack_ref = false;\n+  uint offset_ref = 0;\n+  init_random();\n+\n+  for (uint i = 0; i < iterations; i++) {\n+    if (Verbose) {\n+      print(\"mask    \", mask);\n+      tty->print(\"%u. \", i);\n+    }\n+    uint action = next_random() % 13;\n+    uint reg;\n+    uint size_bits_before = mask.rm_size_bits();\n+    \/\/ This copy is used for stack-extension in overlap.\n+    ResourceBitMap mask_ref_copy(std::numeric_limits<short>::max() + 1);\n+    mask_ref_copy.clear();\n+    mask_ref.iterate([&](BitMap::idx_t index) {\n+      mask_ref_copy.set_bit(index);\n+      return true;\n+    });\n+    ResourceBitMap mask_aux_ref(std::numeric_limits<short>::max() + 1);\n+    RegMask mask_aux(arena());\n+    switch (action) {\n+    case 0:\n+      reg = (next_random() % RegMask::rm_size_max_bits()) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Insert\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Insert(reg);\n+      mask_ref.set_bit(reg);\n+      if (mask.is_AllStack() && reg >= size_bits_before) {\n+        \/\/ Stack-extend reference bitset.\n+        mask_ref.set_range(size_bits_before + offset_ref,\n+                           mask.rm_size_bits() + offset_ref);\n+      }\n+      break;\n+    case 1:\n+      reg = (next_random() % size_bits_before) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Remove\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Remove(reg);\n+      mask_ref.clear_bit(reg);\n+      break;\n+    case 2:\n+      if (Verbose) {\n+        tty->print_cr(\"action: Clear\");\n+      }\n+      mask.Clear();\n+      mask_ref.clear();\n+      all_stack_ref = false;\n+      break;\n+    case 3:\n+      if (offset_ref > 0) {\n+        \/\/ Set_All expects a zero-offset.\n+        break;\n+      }\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All\");\n+      }\n+      mask.Set_All();\n+      mask_ref.set_range(0, size_bits_before);\n+      all_stack_ref = true;\n+      break;\n+    case 4:\n+      if (Verbose) {\n+        tty->print_cr(\"action: AND\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.AND(mask_aux);\n+      stack_extend_ref_masks(mask_ref, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      mask_ref.set_intersection(mask_aux_ref);\n+      all_stack_ref = all_stack_ref && mask_aux.is_AllStack();\n+      break;\n+    case 5:\n+      if (Verbose) {\n+        tty->print_cr(\"action: OR\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.OR(mask_aux);\n+      stack_extend_ref_masks(mask_ref, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      mask_ref.set_union(mask_aux_ref);\n+      all_stack_ref = all_stack_ref || mask_aux.is_AllStack();\n+      break;\n+    case 6:\n+      if (Verbose) {\n+        tty->print_cr(\"action: SUBTRACT\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      mask.SUBTRACT(mask_aux);\n+      stack_extend_ref_masks(mask_ref, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      mask_ref.set_difference(mask_aux_ref);\n+      if (mask_aux.is_AllStack()) {\n+        all_stack_ref = false;\n+      }\n+      break;\n+    case 7:\n+      if (Verbose) {\n+        tty->print_cr(\"action: SUBTRACT_inner\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ true);\n+      \/\/ SUBTRACT_inner expects an argument register mask with all_stack =\n+      \/\/ false.\n+      mask_aux.set_AllStack(false);\n+      mask.SUBTRACT_inner(mask_aux);\n+      \/\/ SUBTRACT_inner does not have \"stack-extension semantics\".\n+      mask_ref.set_difference(mask_aux_ref);\n+      break;\n+    case 8:\n+      if (Verbose) {\n+        tty->print_cr(\"action: overlap\");\n+      }\n+      populate_auxiliary_sets(mask_aux, mask_aux_ref, mask.rm_size_bits(),\n+                              offset_ref, \/*random_offset*\/ false);\n+      \/\/ Stack-extend a copy of mask_ref to avoid mutating the original.\n+      stack_extend_ref_masks(mask_ref_copy, all_stack_ref, size_bits_before,\n+                             offset_ref, mask_aux_ref, mask_aux.is_AllStack(),\n+                             mask_aux.rm_size_bits(), mask_aux.offset_bits());\n+      ASSERT_EQ(mask_ref_copy.intersects(mask_aux_ref) ||\n+                    (all_stack_ref && mask_aux.is_AllStack()),\n+                mask.overlap(mask_aux));\n+      break;\n+    case 9:\n+      if (Verbose) {\n+        tty->print_cr(\"action: rollover\");\n+      }\n+      \/\/ rollover expects the mask to be cleared and with all_stack = true\n+      mask.Clear();\n+      mask.set_AllStack(true);\n+      mask_ref.clear();\n+      all_stack_ref = true;\n+      if (mask.rollover()) {\n+        offset_ref += size_bits_before;\n+        mask_ref.set_range(offset_ref, offset_ref + size_bits_before);\n+      }\n+      break;\n+    case 10:\n+      if (Verbose) {\n+        tty->print_cr(\"action: reset\");\n+      }\n+      mask.set_offset(0);\n+      mask.Clear();\n+      mask_ref.clear();\n+      all_stack_ref = false;\n+      offset_ref = 0;\n+      break;\n+    case 11:\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All_From_Offset\");\n+      }\n+      mask.Set_All_From_Offset();\n+      mask_ref.set_range(offset_ref, offset_ref + size_bits_before);\n+      all_stack_ref = true;\n+      break;\n+    case 12:\n+      reg = (next_random() % size_bits_before) + offset_ref;\n+      if (Verbose) {\n+        tty->print_cr(\"action: Set_All_From\");\n+        tty->print(\"value   : \");\n+        OptoReg::dump(reg);\n+        tty->cr();\n+      }\n+      mask.Set_All_From(reg);\n+      mask_ref.set_range(reg, offset_ref + size_bits_before);\n+      all_stack_ref = true;\n+      break;\n+    default:\n+      FAIL() << \"Unimplemented action\";\n+    }\n+    ASSERT_NO_FATAL_FAILURE(assert_equivalent(mask, mask_ref, all_stack_ref));\n+  }\n+}\n+\n+\/\/ Randomly sets register mask contents. Does not change register mask size.\n+static void randomize(RegMask& rm) {\n+  rm.Clear();\n+  \/\/ Uniform distribution over number of registers.\n+  uint regs = next_random() % (rm.rm_size_bits() + 1);\n+  for (uint i = 0; i < regs; i++) {\n+    uint reg = (next_random() % rm.rm_size_bits()) + rm.offset_bits();\n+    rm.Insert(reg);\n+  }\n+  rm.set_AllStack(next_random() % 2);\n+}\n+\n+static uint grow_randomly(RegMask& rm, uint min_growth = 1,\n+                          uint max_growth = 3) {\n+  \/\/ Grow between min_growth and max_growth times.\n+  uint grow = min_growth + (max_growth > 0 ? next_random() % max_growth : 0);\n+  for (uint i = 0; i < grow; ++i) {\n+    uint reg = rm.rm_size_bits();\n+    if (reg >= RegMask::rm_size_max_bits()) {\n+      \/\/ Cannot grow more\n+      break;\n+    }\n+    \/\/ Force grow\n+    rm.Insert(reg);\n+    if (!rm.is_AllStack()) {\n+      \/\/ Restore\n+      rm.Remove(reg);\n+    }\n+  }\n+  \/\/ Return how many times we grew\n+  return grow;\n+}\n+\n+TEST_VM(RegMask, random_copy) {\n+  init_random();\n+\n+  auto print_failure = [&](const RegMask& src, const RegMask& dst) {\n+    tty->print_cr(\"Failure, src and dst not equal\");\n+    tty->print(\"src: \");\n+    src.dump_hex();\n+    tty->cr();\n+    tty->print(\"dst: \");\n+    dst.dump_hex();\n+    tty->cr();\n+  };\n+\n+  \/\/ Test copying a larger register mask\n+  for (uint i = 0; i < iterations; i++) {\n+    ResourceMark rm;\n+\n+    \/\/ Create source RegMask\n+    RegMask src(arena());\n+\n+    \/\/ Grow source randomly\n+    grow_randomly(src);\n+\n+    \/\/ Randomly initialize source\n+    randomize(src);\n+\n+    \/\/ Copy construct source to destination\n+    RegMask dst(src, arena());\n+\n+    \/\/ Check equality\n+    bool passed = src.equals(dst);\n+    if (Verbose && !passed) {\n+      print_failure(src, dst);\n+    }\n+    ASSERT_TRUE(passed);\n+  }\n+\n+  \/\/ Test copying a smaller register mask\n+  for (uint i = 0; i < iterations; i++) {\n+    ResourceMark rm;\n+\n+    \/\/ Create destination RegMask\n+    RegMask dst(arena());\n+\n+    \/\/ Grow destination arbitrarily (1-3 times)\n+    uint growth = grow_randomly(dst, 1, 3);\n+\n+    \/\/ Create source RegMask\n+    RegMask src(arena());\n+\n+    \/\/ Grow source arbitrarily, but not as much as destination\n+    grow_randomly(src, 0, growth - 1);\n+\n+    \/\/ Randomly initialize source\n+    randomize(src);\n+\n+    \/\/ Copy source to destination\n+    dst = src;\n+\n+    \/\/ Check equality\n+    bool passed = src.equals(dst);\n+    if (Verbose && !passed) {\n+      print_failure(src, dst);\n+    }\n+    ASSERT_TRUE(passed);\n+  }\n+}\n+\n+#endif \/\/ !PRODUCT\n","filename":"test\/hotspot\/gtest\/opto\/test_regmask.cpp","additions":1042,"deletions":17,"binary":false,"changes":1059,"status":"modified"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8325467\n+ * @requires vm.opt.DeoptimizeALot == null | vm.opt.DeoptimizeALot == false\n+ * @summary Ensure C2 can compile methods with the maximum number of parameters\n+ *          (according to the JVM spec).\n+ * @run main\/othervm -XX:CompileCommand=compileonly,compiler.arguments.TestMaxMethodArguments::test\n+ *                   -Xcomp\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AbortVMOnCompilationFailure\n+ *                   compiler.arguments.TestMaxMethodArguments\n+ *\/\n+\n+package compiler.arguments;\n+\n+public class TestMaxMethodArguments {\n+    public static void main(String[] args) {\n+        try {\n+            test(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255);\n+        } catch (Exception e) {\n+            \/\/ Fine\n+        }\n+    }\n+\n+    public static int test(int x1, int x2, int x3, int x4, int x5, int x6, int x7, int x8, int x9, int x10, int x11, int x12, int x13, int x14, int x15, int x16, int x17, int x18, int x19, int x20, int x21, int x22, int x23, int x24, int x25, int x26, int x27, int x28, int x29, int x30, int x31, int x32, int x33, int x34, int x35, int x36, int x37, int x38, int x39, int x40, int x41, int x42, int x43, int x44, int x45, int x46, int x47, int x48, int x49, int x50, int x51, int x52, int x53, int x54, int x55, int x56, int x57, int x58, int x59, int x60, int x61, int x62, int x63, int x64, int x65, int x66, int x67, int x68, int x69, int x70, int x71, int x72, int x73, int x74, int x75, int x76, int x77, int x78, int x79, int x80, int x81, int x82, int x83, int x84, int x85, int x86, int x87, int x88, int x89, int x90, int x91, int x92, int x93, int x94, int x95, int x96, int x97, int x98, int x99, int x100, int x101, int x102, int x103, int x104, int x105, int x106, int x107, int x108, int x109, int x110, int x111, int x112, int x113, int x114, int x115, int x116, int x117, int x118, int x119, int x120, int x121, int x122, int x123, int x124, int x125, int x126, int x127, int x128, int x129, int x130, int x131, int x132, int x133, int x134, int x135, int x136, int x137, int x138, int x139, int x140, int x141, int x142, int x143, int x144, int x145, int x146, int x147, int x148, int x149, int x150, int x151, int x152, int x153, int x154, int x155, int x156, int x157, int x158, int x159, int x160, int x161, int x162, int x163, int x164, int x165, int x166, int x167, int x168, int x169, int x170, int x171, int x172, int x173, int x174, int x175, int x176, int x177, int x178, int x179, int x180, int x181, int x182, int x183, int x184, int x185, int x186, int x187, int x188, int x189, int x190, int x191, int x192, int x193, int x194, int x195, int x196, int x197, int x198, int x199, int x200, int x201, int x202, int x203, int x204, int x205, int x206, int x207, int x208, int x209, int x210, int x211, int x212, int x213, int x214, int x215, int x216, int x217, int x218, int x219, int x220, int x221, int x222, int x223, int x224, int x225, int x226, int x227, int x228, int x229, int x230, int x231, int x232, int x233, int x234, int x235, int x236, int x237, int x238, int x239, int x240, int x241, int x242, int x243, int x244, int x245, int x246, int x247, int x248, int x249, int x250, int x251, int x252, int x253, int x254, int x255) throws Exception {\n+        \/\/ Exceptions after every definition of a temporary forces the\n+        \/\/ evaluation order.\n+        int t1 = x1 % 101; if(t1 == 0) { throw new Exception(); }\n+        int t2 = x2 % 102; if(t2 == 0) { throw new Exception(); }\n+        int t3 = x3 % 103; if(t3 == 0) { throw new Exception(); }\n+        int t4 = x4 % 104; if(t4 == 0) { throw new Exception(); }\n+        int t5 = x5 % 105; if(t5 == 0) { throw new Exception(); }\n+        int t6 = x6 % 106; if(t6 == 0) { throw new Exception(); }\n+        int t7 = x7 % 107; if(t7 == 0) { throw new Exception(); }\n+        int t8 = x8 % 108; if(t8 == 0) { throw new Exception(); }\n+        int t9 = x9 % 109; if(t9 == 0) { throw new Exception(); }\n+        int t10 = x10 % 110; if(t10 == 0) { throw new Exception(); }\n+        int t11 = x11 % 111; if(t11 == 0) { throw new Exception(); }\n+        int t12 = x12 % 112; if(t12 == 0) { throw new Exception(); }\n+        int t13 = x13 % 113; if(t13 == 0) { throw new Exception(); }\n+        int t14 = x14 % 114; if(t14 == 0) { throw new Exception(); }\n+        int t15 = x15 % 115; if(t15 == 0) { throw new Exception(); }\n+        int t16 = x16 % 116; if(t16 == 0) { throw new Exception(); }\n+        int t17 = x17 % 117; if(t17 == 0) { throw new Exception(); }\n+        int t18 = x18 % 118; if(t18 == 0) { throw new Exception(); }\n+        int t19 = x19 % 119; if(t19 == 0) { throw new Exception(); }\n+        int t20 = x20 % 120; if(t20 == 0) { throw new Exception(); }\n+        int t21 = x21 % 121; if(t21 == 0) { throw new Exception(); }\n+        int t22 = x22 % 122; if(t22 == 0) { throw new Exception(); }\n+        int t23 = x23 % 123; if(t23 == 0) { throw new Exception(); }\n+        int t24 = x24 % 124; if(t24 == 0) { throw new Exception(); }\n+        int t25 = x25 % 125; if(t25 == 0) { throw new Exception(); }\n+        int t26 = x26 % 126; if(t26 == 0) { throw new Exception(); }\n+        int t27 = x27 % 127; if(t27 == 0) { throw new Exception(); }\n+        int t28 = x28 % 128; if(t28 == 0) { throw new Exception(); }\n+        int t29 = x29 % 129; if(t29 == 0) { throw new Exception(); }\n+        int t30 = x30 % 130; if(t30 == 0) { throw new Exception(); }\n+        int t31 = x31 % 131; if(t31 == 0) { throw new Exception(); }\n+        int t32 = x32 % 132; if(t32 == 0) { throw new Exception(); }\n+        int t33 = x33 % 133; if(t33 == 0) { throw new Exception(); }\n+        int t34 = x34 % 134; if(t34 == 0) { throw new Exception(); }\n+        int t35 = x35 % 135; if(t35 == 0) { throw new Exception(); }\n+        int t36 = x36 % 136; if(t36 == 0) { throw new Exception(); }\n+        int t37 = x37 % 137; if(t37 == 0) { throw new Exception(); }\n+        int t38 = x38 % 138; if(t38 == 0) { throw new Exception(); }\n+        int t39 = x39 % 139; if(t39 == 0) { throw new Exception(); }\n+        int t40 = x40 % 140; if(t40 == 0) { throw new Exception(); }\n+        int t41 = x41 % 141; if(t41 == 0) { throw new Exception(); }\n+        int t42 = x42 % 142; if(t42 == 0) { throw new Exception(); }\n+        int t43 = x43 % 143; if(t43 == 0) { throw new Exception(); }\n+        int t44 = x44 % 144; if(t44 == 0) { throw new Exception(); }\n+        int t45 = x45 % 145; if(t45 == 0) { throw new Exception(); }\n+        int t46 = x46 % 146; if(t46 == 0) { throw new Exception(); }\n+        int t47 = x47 % 147; if(t47 == 0) { throw new Exception(); }\n+        int t48 = x48 % 148; if(t48 == 0) { throw new Exception(); }\n+        int t49 = x49 % 149; if(t49 == 0) { throw new Exception(); }\n+        int t50 = x50 % 150; if(t50 == 0) { throw new Exception(); }\n+        int t51 = x51 % 151; if(t51 == 0) { throw new Exception(); }\n+        int t52 = x52 % 152; if(t52 == 0) { throw new Exception(); }\n+        int t53 = x53 % 153; if(t53 == 0) { throw new Exception(); }\n+        int t54 = x54 % 154; if(t54 == 0) { throw new Exception(); }\n+        int t55 = x55 % 155; if(t55 == 0) { throw new Exception(); }\n+        int t56 = x56 % 156; if(t56 == 0) { throw new Exception(); }\n+        int t57 = x57 % 157; if(t57 == 0) { throw new Exception(); }\n+        int t58 = x58 % 158; if(t58 == 0) { throw new Exception(); }\n+        int t59 = x59 % 159; if(t59 == 0) { throw new Exception(); }\n+        int t60 = x60 % 160; if(t60 == 0) { throw new Exception(); }\n+        int t61 = x61 % 161; if(t61 == 0) { throw new Exception(); }\n+        int t62 = x62 % 162; if(t62 == 0) { throw new Exception(); }\n+        int t63 = x63 % 163; if(t63 == 0) { throw new Exception(); }\n+        int t64 = x64 % 164; if(t64 == 0) { throw new Exception(); }\n+        int t65 = x65 % 165; if(t65 == 0) { throw new Exception(); }\n+        int t66 = x66 % 166; if(t66 == 0) { throw new Exception(); }\n+        int t67 = x67 % 167; if(t67 == 0) { throw new Exception(); }\n+        int t68 = x68 % 168; if(t68 == 0) { throw new Exception(); }\n+        int t69 = x69 % 169; if(t69 == 0) { throw new Exception(); }\n+        int t70 = x70 % 170; if(t70 == 0) { throw new Exception(); }\n+        int t71 = x71 % 171; if(t71 == 0) { throw new Exception(); }\n+        int t72 = x72 % 172; if(t72 == 0) { throw new Exception(); }\n+        int t73 = x73 % 173; if(t73 == 0) { throw new Exception(); }\n+        int t74 = x74 % 174; if(t74 == 0) { throw new Exception(); }\n+        int t75 = x75 % 175; if(t75 == 0) { throw new Exception(); }\n+        int t76 = x76 % 176; if(t76 == 0) { throw new Exception(); }\n+        int t77 = x77 % 177; if(t77 == 0) { throw new Exception(); }\n+        int t78 = x78 % 178; if(t78 == 0) { throw new Exception(); }\n+        int t79 = x79 % 179; if(t79 == 0) { throw new Exception(); }\n+        int t80 = x80 % 180; if(t80 == 0) { throw new Exception(); }\n+        int t81 = x81 % 181; if(t81 == 0) { throw new Exception(); }\n+        int t82 = x82 % 182; if(t82 == 0) { throw new Exception(); }\n+        int t83 = x83 % 183; if(t83 == 0) { throw new Exception(); }\n+        int t84 = x84 % 184; if(t84 == 0) { throw new Exception(); }\n+        int t85 = x85 % 185; if(t85 == 0) { throw new Exception(); }\n+        int t86 = x86 % 186; if(t86 == 0) { throw new Exception(); }\n+        int t87 = x87 % 187; if(t87 == 0) { throw new Exception(); }\n+        int t88 = x88 % 188; if(t88 == 0) { throw new Exception(); }\n+        int t89 = x89 % 189; if(t89 == 0) { throw new Exception(); }\n+        int t90 = x90 % 190; if(t90 == 0) { throw new Exception(); }\n+        int t91 = x91 % 191; if(t91 == 0) { throw new Exception(); }\n+        int t92 = x92 % 192; if(t92 == 0) { throw new Exception(); }\n+        int t93 = x93 % 193; if(t93 == 0) { throw new Exception(); }\n+        int t94 = x94 % 194; if(t94 == 0) { throw new Exception(); }\n+        int t95 = x95 % 195; if(t95 == 0) { throw new Exception(); }\n+        int t96 = x96 % 196; if(t96 == 0) { throw new Exception(); }\n+        int t97 = x97 % 197; if(t97 == 0) { throw new Exception(); }\n+        int t98 = x98 % 198; if(t98 == 0) { throw new Exception(); }\n+        int t99 = x99 % 199; if(t99 == 0) { throw new Exception(); }\n+        int t100 = x100 % 200; if(t100 == 0) { throw new Exception(); }\n+        int t101 = x101 % 201; if(t101 == 0) { throw new Exception(); }\n+        int t102 = x102 % 202; if(t102 == 0) { throw new Exception(); }\n+        int t103 = x103 % 203; if(t103 == 0) { throw new Exception(); }\n+        int t104 = x104 % 204; if(t104 == 0) { throw new Exception(); }\n+        int t105 = x105 % 205; if(t105 == 0) { throw new Exception(); }\n+        int t106 = x106 % 206; if(t106 == 0) { throw new Exception(); }\n+        int t107 = x107 % 207; if(t107 == 0) { throw new Exception(); }\n+        int t108 = x108 % 208; if(t108 == 0) { throw new Exception(); }\n+        int t109 = x109 % 209; if(t109 == 0) { throw new Exception(); }\n+        int t110 = x110 % 210; if(t110 == 0) { throw new Exception(); }\n+        int t111 = x111 % 211; if(t111 == 0) { throw new Exception(); }\n+        int t112 = x112 % 212; if(t112 == 0) { throw new Exception(); }\n+        int t113 = x113 % 213; if(t113 == 0) { throw new Exception(); }\n+        int t114 = x114 % 214; if(t114 == 0) { throw new Exception(); }\n+        int t115 = x115 % 215; if(t115 == 0) { throw new Exception(); }\n+        int t116 = x116 % 216; if(t116 == 0) { throw new Exception(); }\n+        int t117 = x117 % 217; if(t117 == 0) { throw new Exception(); }\n+        int t118 = x118 % 218; if(t118 == 0) { throw new Exception(); }\n+        int t119 = x119 % 219; if(t119 == 0) { throw new Exception(); }\n+        int t120 = x120 % 220; if(t120 == 0) { throw new Exception(); }\n+        int t121 = x121 % 221; if(t121 == 0) { throw new Exception(); }\n+        int t122 = x122 % 222; if(t122 == 0) { throw new Exception(); }\n+        int t123 = x123 % 223; if(t123 == 0) { throw new Exception(); }\n+        int t124 = x124 % 224; if(t124 == 0) { throw new Exception(); }\n+        int t125 = x125 % 225; if(t125 == 0) { throw new Exception(); }\n+        int t126 = x126 % 226; if(t126 == 0) { throw new Exception(); }\n+        int t127 = x127 % 227; if(t127 == 0) { throw new Exception(); }\n+        int t128 = x128 % 228; if(t128 == 0) { throw new Exception(); }\n+        int t129 = x129 % 229; if(t129 == 0) { throw new Exception(); }\n+        int t130 = x130 % 230; if(t130 == 0) { throw new Exception(); }\n+        int t131 = x131 % 231; if(t131 == 0) { throw new Exception(); }\n+        int t132 = x132 % 232; if(t132 == 0) { throw new Exception(); }\n+        int t133 = x133 % 233; if(t133 == 0) { throw new Exception(); }\n+        int t134 = x134 % 234; if(t134 == 0) { throw new Exception(); }\n+        int t135 = x135 % 235; if(t135 == 0) { throw new Exception(); }\n+        int t136 = x136 % 236; if(t136 == 0) { throw new Exception(); }\n+        int t137 = x137 % 237; if(t137 == 0) { throw new Exception(); }\n+        int t138 = x138 % 238; if(t138 == 0) { throw new Exception(); }\n+        int t139 = x139 % 239; if(t139 == 0) { throw new Exception(); }\n+        int t140 = x140 % 240; if(t140 == 0) { throw new Exception(); }\n+        int t141 = x141 % 241; if(t141 == 0) { throw new Exception(); }\n+        int t142 = x142 % 242; if(t142 == 0) { throw new Exception(); }\n+        int t143 = x143 % 243; if(t143 == 0) { throw new Exception(); }\n+        int t144 = x144 % 244; if(t144 == 0) { throw new Exception(); }\n+        int t145 = x145 % 245; if(t145 == 0) { throw new Exception(); }\n+        int t146 = x146 % 246; if(t146 == 0) { throw new Exception(); }\n+        int t147 = x147 % 247; if(t147 == 0) { throw new Exception(); }\n+        int t148 = x148 % 248; if(t148 == 0) { throw new Exception(); }\n+        int t149 = x149 % 249; if(t149 == 0) { throw new Exception(); }\n+        int t150 = x150 % 250; if(t150 == 0) { throw new Exception(); }\n+        int t151 = x151 % 251; if(t151 == 0) { throw new Exception(); }\n+        int t152 = x152 % 252; if(t152 == 0) { throw new Exception(); }\n+        int t153 = x153 % 253; if(t153 == 0) { throw new Exception(); }\n+        int t154 = x154 % 254; if(t154 == 0) { throw new Exception(); }\n+        int t155 = x155 % 255; if(t155 == 0) { throw new Exception(); }\n+        int t156 = x156 % 256; if(t156 == 0) { throw new Exception(); }\n+        int t157 = x157 % 257; if(t157 == 0) { throw new Exception(); }\n+        int t158 = x158 % 258; if(t158 == 0) { throw new Exception(); }\n+        int t159 = x159 % 259; if(t159 == 0) { throw new Exception(); }\n+        int t160 = x160 % 260; if(t160 == 0) { throw new Exception(); }\n+        int t161 = x161 % 261; if(t161 == 0) { throw new Exception(); }\n+        int t162 = x162 % 262; if(t162 == 0) { throw new Exception(); }\n+        int t163 = x163 % 263; if(t163 == 0) { throw new Exception(); }\n+        int t164 = x164 % 264; if(t164 == 0) { throw new Exception(); }\n+        int t165 = x165 % 265; if(t165 == 0) { throw new Exception(); }\n+        int t166 = x166 % 266; if(t166 == 0) { throw new Exception(); }\n+        int t167 = x167 % 267; if(t167 == 0) { throw new Exception(); }\n+        int t168 = x168 % 268; if(t168 == 0) { throw new Exception(); }\n+        int t169 = x169 % 269; if(t169 == 0) { throw new Exception(); }\n+        int t170 = x170 % 270; if(t170 == 0) { throw new Exception(); }\n+        int t171 = x171 % 271; if(t171 == 0) { throw new Exception(); }\n+        int t172 = x172 % 272; if(t172 == 0) { throw new Exception(); }\n+        int t173 = x173 % 273; if(t173 == 0) { throw new Exception(); }\n+        int t174 = x174 % 274; if(t174 == 0) { throw new Exception(); }\n+        int t175 = x175 % 275; if(t175 == 0) { throw new Exception(); }\n+        int t176 = x176 % 276; if(t176 == 0) { throw new Exception(); }\n+        int t177 = x177 % 277; if(t177 == 0) { throw new Exception(); }\n+        int t178 = x178 % 278; if(t178 == 0) { throw new Exception(); }\n+        int t179 = x179 % 279; if(t179 == 0) { throw new Exception(); }\n+        int t180 = x180 % 280; if(t180 == 0) { throw new Exception(); }\n+        int t181 = x181 % 281; if(t181 == 0) { throw new Exception(); }\n+        int t182 = x182 % 282; if(t182 == 0) { throw new Exception(); }\n+        int t183 = x183 % 283; if(t183 == 0) { throw new Exception(); }\n+        int t184 = x184 % 284; if(t184 == 0) { throw new Exception(); }\n+        int t185 = x185 % 285; if(t185 == 0) { throw new Exception(); }\n+        int t186 = x186 % 286; if(t186 == 0) { throw new Exception(); }\n+        int t187 = x187 % 287; if(t187 == 0) { throw new Exception(); }\n+        int t188 = x188 % 288; if(t188 == 0) { throw new Exception(); }\n+        int t189 = x189 % 289; if(t189 == 0) { throw new Exception(); }\n+        int t190 = x190 % 290; if(t190 == 0) { throw new Exception(); }\n+        int t191 = x191 % 291; if(t191 == 0) { throw new Exception(); }\n+        int t192 = x192 % 292; if(t192 == 0) { throw new Exception(); }\n+        int t193 = x193 % 293; if(t193 == 0) { throw new Exception(); }\n+        int t194 = x194 % 294; if(t194 == 0) { throw new Exception(); }\n+        int t195 = x195 % 295; if(t195 == 0) { throw new Exception(); }\n+        int t196 = x196 % 296; if(t196 == 0) { throw new Exception(); }\n+        int t197 = x197 % 297; if(t197 == 0) { throw new Exception(); }\n+        int t198 = x198 % 298; if(t198 == 0) { throw new Exception(); }\n+        int t199 = x199 % 299; if(t199 == 0) { throw new Exception(); }\n+        int t200 = x200 % 300; if(t200 == 0) { throw new Exception(); }\n+        int t201 = x201 % 301; if(t201 == 0) { throw new Exception(); }\n+        int t202 = x202 % 302; if(t202 == 0) { throw new Exception(); }\n+        int t203 = x203 % 303; if(t203 == 0) { throw new Exception(); }\n+        int t204 = x204 % 304; if(t204 == 0) { throw new Exception(); }\n+        int t205 = x205 % 305; if(t205 == 0) { throw new Exception(); }\n+        int t206 = x206 % 306; if(t206 == 0) { throw new Exception(); }\n+        int t207 = x207 % 307; if(t207 == 0) { throw new Exception(); }\n+        int t208 = x208 % 308; if(t208 == 0) { throw new Exception(); }\n+        int t209 = x209 % 309; if(t209 == 0) { throw new Exception(); }\n+        int t210 = x210 % 310; if(t210 == 0) { throw new Exception(); }\n+        int t211 = x211 % 311; if(t211 == 0) { throw new Exception(); }\n+        int t212 = x212 % 312; if(t212 == 0) { throw new Exception(); }\n+        int t213 = x213 % 313; if(t213 == 0) { throw new Exception(); }\n+        int t214 = x214 % 314; if(t214 == 0) { throw new Exception(); }\n+        int t215 = x215 % 315; if(t215 == 0) { throw new Exception(); }\n+        int t216 = x216 % 316; if(t216 == 0) { throw new Exception(); }\n+        int t217 = x217 % 317; if(t217 == 0) { throw new Exception(); }\n+        int t218 = x218 % 318; if(t218 == 0) { throw new Exception(); }\n+        int t219 = x219 % 319; if(t219 == 0) { throw new Exception(); }\n+        int t220 = x220 % 320; if(t220 == 0) { throw new Exception(); }\n+        int t221 = x221 % 321; if(t221 == 0) { throw new Exception(); }\n+        int t222 = x222 % 322; if(t222 == 0) { throw new Exception(); }\n+        int t223 = x223 % 323; if(t223 == 0) { throw new Exception(); }\n+        int t224 = x224 % 324; if(t224 == 0) { throw new Exception(); }\n+        int t225 = x225 % 325; if(t225 == 0) { throw new Exception(); }\n+        int t226 = x226 % 326; if(t226 == 0) { throw new Exception(); }\n+        int t227 = x227 % 327; if(t227 == 0) { throw new Exception(); }\n+        int t228 = x228 % 328; if(t228 == 0) { throw new Exception(); }\n+        int t229 = x229 % 329; if(t229 == 0) { throw new Exception(); }\n+        int t230 = x230 % 330; if(t230 == 0) { throw new Exception(); }\n+        int t231 = x231 % 331; if(t231 == 0) { throw new Exception(); }\n+        int t232 = x232 % 332; if(t232 == 0) { throw new Exception(); }\n+        int t233 = x233 % 333; if(t233 == 0) { throw new Exception(); }\n+        int t234 = x234 % 334; if(t234 == 0) { throw new Exception(); }\n+        int t235 = x235 % 335; if(t235 == 0) { throw new Exception(); }\n+        int t236 = x236 % 336; if(t236 == 0) { throw new Exception(); }\n+        int t237 = x237 % 337; if(t237 == 0) { throw new Exception(); }\n+        int t238 = x238 % 338; if(t238 == 0) { throw new Exception(); }\n+        int t239 = x239 % 339; if(t239 == 0) { throw new Exception(); }\n+        int t240 = x240 % 340; if(t240 == 0) { throw new Exception(); }\n+        int t241 = x241 % 341; if(t241 == 0) { throw new Exception(); }\n+        int t242 = x242 % 342; if(t242 == 0) { throw new Exception(); }\n+        int t243 = x243 % 343; if(t243 == 0) { throw new Exception(); }\n+        int t244 = x244 % 344; if(t244 == 0) { throw new Exception(); }\n+        int t245 = x245 % 345; if(t245 == 0) { throw new Exception(); }\n+        int t246 = x246 % 346; if(t246 == 0) { throw new Exception(); }\n+        int t247 = x247 % 347; if(t247 == 0) { throw new Exception(); }\n+        int t248 = x248 % 348; if(t248 == 0) { throw new Exception(); }\n+        int t249 = x249 % 349; if(t249 == 0) { throw new Exception(); }\n+        int t250 = x250 % 350; if(t250 == 0) { throw new Exception(); }\n+        int t251 = x251 % 351; if(t251 == 0) { throw new Exception(); }\n+        int t252 = x252 % 352; if(t252 == 0) { throw new Exception(); }\n+        int t253 = x253 % 353; if(t253 == 0) { throw new Exception(); }\n+        int t254 = x254 % 354; if(t254 == 0) { throw new Exception(); }\n+        int t255 = x255 % 355; if(t255 == 0) { throw new Exception(); }\n+        \/\/ All temporaries are live here, stressing the register allocator.\n+        return t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17 + t18 + t19 + t20 + t21 + t22 + t23 + t24 + t25 + t26 + t27 + t28 + t29 + t30 + t31 + t32 + t33 + t34 + t35 + t36 + t37 + t38 + t39 + t40 + t41 + t42 + t43 + t44 + t45 + t46 + t47 + t48 + t49 + t50 + t51 + t52 + t53 + t54 + t55 + t56 + t57 + t58 + t59 + t60 + t61 + t62 + t63 + t64 + t65 + t66 + t67 + t68 + t69 + t70 + t71 + t72 + t73 + t74 + t75 + t76 + t77 + t78 + t79 + t80 + t81 + t82 + t83 + t84 + t85 + t86 + t87 + t88 + t89 + t90 + t91 + t92 + t93 + t94 + t95 + t96 + t97 + t98 + t99 + t100 + t101 + t102 + t103 + t104 + t105 + t106 + t107 + t108 + t109 + t110 + t111 + t112 + t113 + t114 + t115 + t116 + t117 + t118 + t119 + t120 + t121 + t122 + t123 + t124 + t125 + t126 + t127 + t128 + t129 + t130 + t131 + t132 + t133 + t134 + t135 + t136 + t137 + t138 + t139 + t140 + t141 + t142 + t143 + t144 + t145 + t146 + t147 + t148 + t149 + t150 + t151 + t152 + t153 + t154 + t155 + t156 + t157 + t158 + t159 + t160 + t161 + t162 + t163 + t164 + t165 + t166 + t167 + t168 + t169 + t170 + t171 + t172 + t173 + t174 + t175 + t176 + t177 + t178 + t179 + t180 + t181 + t182 + t183 + t184 + t185 + t186 + t187 + t188 + t189 + t190 + t191 + t192 + t193 + t194 + t195 + t196 + t197 + t198 + t199 + t200 + t201 + t202 + t203 + t204 + t205 + t206 + t207 + t208 + t209 + t210 + t211 + t212 + t213 + t214 + t215 + t216 + t217 + t218 + t219 + t220 + t221 + t222 + t223 + t224 + t225 + t226 + t227 + t228 + t229 + t230 + t231 + t232 + t233 + t234 + t235 + t236 + t237 + t238 + t239 + t240 + t241 + t242 + t243 + t244 + t245 + t246 + t247 + t248 + t249 + t250 + t251 + t252 + t253 + t254 + t255;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestMaxMethodArguments.java","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,8 @@\n- * @bug 8322996\n- * @summary Ensure no assert error in C2 with deeply nested synchronize\n- *          statements.\n- * @run main\/othervm -XX:CompileCommand=compileonly,compiler.locks.TestNestedSynchronize::test\n+ * @bug 8322996 8324839 8325467\n+ * @summary Ensure C2 can compile deeply nested synchronize statements.\n+ *          Exercises C2 register masks, in particular. We incrementally\n+ *          increase the level of nesting (up to 100) to trigger potential edge\n+ *          cases.\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:CompileCommand=compileonly,Test::test*\n@@ -31,0 +35,2 @@\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+AbortVMOnCompilationFailure\n@@ -36,0 +42,3 @@\n+import compiler.lib.compile_framework.*;\n+import java.util.ArrayList;\n+\n@@ -37,0 +46,3 @@\n+    static int min = 1;\n+    static int max = 100;\n+    static String test_class_name = \"Test\";\n@@ -38,2 +50,69 @@\n-    public static void main(String[] args) {\n-        test();\n+    \/\/ The below method generates a program of the form:\n+    \/\/\n+    \/\/ public class Test {\n+    \/\/     public static void test1() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/\n+    \/\/         }\n+    \/\/     }\n+    \/\/\n+    \/\/\n+    \/\/     public static void test2() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/\n+    \/\/         }\n+    \/\/         }\n+    \/\/     }\n+    \/\/\n+    \/\/\n+    \/\/     public static void test3() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/\n+    \/\/         }\n+    \/\/         }\n+    \/\/         }\n+    \/\/     }\n+    \/\/\n+    \/\/     ...\n+    \/\/\n+    \/\/     public static void test99() {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         synchronized (Test.class) {\n+    \/\/         ...\n+    \/\/\n+    \/\/         ...\n+    \/\/         }\n+    \/\/         }\n+    \/\/         }\n+    \/\/     }\n+    \/\/ }\n+    \/\/\n+    \/\/ The above is a massive program. Therefore, we do not directly inline the\n+    \/\/ program in TestNestedSynchronize and instead compile and run it via the\n+    \/\/ CompileFramework.\n+    public static String generate_test() {\n+        ArrayList<String> methods = new ArrayList<String>();\n+        for (int i = min; i < max; i++) {\n+            String inner = \"\";\n+            for (int j = 0; j < i; j++) {\n+                inner = String.format(\"\"\"\n+                          synchronized (%s.class) {\n+                  %s\n+                          }\"\"\", test_class_name, inner);\n+            }\n+            methods.add(String.format(\"\"\"\n+                  public static void test%d() {\n+              %s\n+                  }\n+              \"\"\", i, inner));\n+        }\n+        String methods_string = String.join(\"\\n\\n\", methods);\n+        String test_program = String.format(\"\"\"\n+                public class %s {\n+                %s\n+                }\"\"\", test_class_name, methods_string);\n+        return test_program;\n@@ -42,194 +121,6 @@\n-    public static void test() {\n-\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-        synchronized (TestNestedSynchronize.class) {\n-\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n-        }\n+    public static void main(String[] args) {\n+        CompileFramework comp = new CompileFramework();\n+        comp.addJavaSourceCode(\"Test\", generate_test());\n+        comp.compile();\n+        for (int i = min; i < max; ++i) {\n+            comp.invoke(\"Test\", \"test\" + i, new Object[] {});\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestNestedSynchronize.java","additions":92,"deletions":201,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,12 @@\n- * @run junit\/othervm\/timeout=2500 -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyDependencies -XX:CompileCommand=memlimit,*.*,0 -esa -DBigArityTest.ITERATION_COUNT=1 test.java.lang.invoke.BigArityTest\n+ * @comment The reduced maximum node limit below avoids, in combination with\n+ *          -Xcomp, timeouts and excessive C2 memory consumption during\n+ *          compilation of some methods that both\n+ *            (1) have a large number of parameters, and\n+ *            (2) use JSR292 methods internally (which increases the\n+ *                MaxNodeLimit with a factor of 3)\n+ * @run junit\/othervm\/timeout=2500 -XX:+IgnoreUnrecognizedVMOptions\n+ *                                 -XX:MaxNodeLimit=20000\n+ *                                 -XX:-VerifyDependencies\n+ *                                 -XX:CompileCommand=memlimit,*.*,0\n+ *                                 -esa -DBigArityTest.ITERATION_COUNT=1\n+ *                                 test.java.lang.invoke.BigArityTest\n","filename":"test\/jdk\/java\/lang\/invoke\/BigArityTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,4 @@\n- * @run main TestCatchExceptionWithVarargs\n+ * @comment The maximum node limit below avoids, in combination with -Xcomp,\n+ *          timeouts due to compilation of a large number of methods with a\n+ *          large number of parameters.\n+ * @run main\/othervm -XX:MaxNodeLimit=15000 TestCatchExceptionWithVarargs\n","filename":"test\/jdk\/java\/lang\/invoke\/TestCatchExceptionWithVarargs.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,7 @@\n- * @run main\/bootclasspath\/othervm -DVarargsArrayTest.MAX_ARITY=255 -DVarargsArrayTest.START_ARITY=250\n- *                         VarargsArrayTest\n+ * @comment The maximum node limit below avoids, in combination with -Xcomp,\n+ *          timeouts due to compilation of a large number of methods with a\n+ *          large number of parameters.\n+ * @run main\/bootclasspath\/othervm -XX:MaxNodeLimit=15000\n+ *                                 -DVarargsArrayTest.MAX_ARITY=255\n+ *                                 -DVarargsArrayTest.START_ARITY=250\n+ *                                 VarargsArrayTest\n@@ -45,1 +50,4 @@\n- * @run main\/bootclasspath -DVarargsArrayTest.MAX_ARITY=255 -DVarargsArrayTest.EXHAUSTIVE=true VarargsArrayTest\n+ * @run main\/bootclasspath\/othervm -XX:MaxNodeLimit=15000\n+ *                                 -DVarargsArrayTest.MAX_ARITY=255\n+ *                                 -DVarargsArrayTest.EXHAUSTIVE=true\n+ *                                 VarargsArrayTest\n","filename":"test\/jdk\/java\/lang\/invoke\/VarargsArrayTest.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"}]}