{"files":[{"patch":"@@ -173,3 +173,3 @@\n-  \/\/ machine registers and usually all parameters that need to be passed on the\n-  \/\/ stack (stack registers) up to some interesting limit. On Intel, the limit\n-  \/\/ is something like 90+ parameters.\n+  \/\/ machine registers, as well as a certain number of parameters that need to\n+  \/\/ be passed on the stack (stack registers). The number of parameters that can\n+  \/\/ fit in the mask should be dimensioned to cover most common cases.\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -132,3 +132,1 @@\n-  void init_mask(Arena* arena) {\n-    new (&_mask) RegMask(arena);\n-  }\n+  void init_mask(Arena* arena) { new (&_mask) RegMask(arena); }\n@@ -137,4 +135,1 @@\n-  void SUBTRACT_inner(const RegMask& rm) {\n-    _mask.SUBTRACT_inner(rm);\n-    DEBUG_ONLY(_msize_valid = 0;)\n-  }\n+  void SUBTRACT_inner(const RegMask& rm) { _mask.SUBTRACT_inner(rm); DEBUG_ONLY(_msize_valid = 0;) }\n@@ -142,10 +137,2 @@\n-  void Set_All() {\n-    _mask.Set_All();\n-    DEBUG_ONLY(_msize_valid = 1);\n-    _mask_size = _mask.rm_size_in_bits();\n-  }\n-  bool rollover() {\n-    DEBUG_ONLY(_msize_valid = 1);\n-    _mask_size = _mask.rm_size_in_bits();\n-    return _mask.rollover();\n-  }\n+  void Set_All() { _mask.Set_All(); DEBUG_ONLY(_msize_valid = 1); _mask_size = _mask.rm_size_in_bits(); }\n+  bool rollover() { DEBUG_ONLY(_msize_valid = 1); _mask_size = _mask.rm_size_in_bits(); return _mask.rollover(); }\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-    : Node(Compile::current()->root()), _slot(slot),\n+    : Node(Compile::current()->root()),\n+      _slot(slot),\n@@ -49,0 +50,2 @@\n+  init_class_id(Class_BoxLock);\n+  init_flags(Flag_rematerialize);\n@@ -54,2 +57,0 @@\n-  init_class_id(Class_BoxLock);\n-  init_flags(Flag_rematerialize);\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -758,1 +758,2 @@\n-      : ProjNode(multi, con), _rout(out, Compile::current()->comp_arena()),\n+      : ProjNode(multi, con),\n+        _rout(out, Compile::current()->comp_arena()),\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -965,1 +965,1 @@\n-  c_frame_ptr_mask = c_frame_pointer();\n+  c_frame_ptr_mask = RegMask(c_frame_pointer());\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -681,1 +681,0 @@\n-              bool is_reg = OptoReg::is_reg(ureg_lo);\n@@ -683,1 +682,1 @@\n-              assert(is_adjacent || is_reg,\n+              assert(is_adjacent || OptoReg::is_reg(ureg_lo),\n@@ -766,1 +765,0 @@\n-        bool is_reg = OptoReg::is_reg(nreg_lo);\n@@ -768,1 +766,1 @@\n-        assert(is_adjacent || is_reg, \"only registers can be non-adjacent\");\n+        assert(is_adjacent || OptoReg::is_reg(nreg_lo), \"only registers can be non-adjacent\");\n","filename":"src\/hotspot\/share\/opto\/postaloc.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -119,4 +119,6 @@\n-    \/\/ Array of Register Mask bits.  This array is large enough to cover all\n-    \/\/ the machine registers and usually all parameters that need to be passed\n-    \/\/ on the stack (stack registers) up to some interesting limit. On Intel,\n-    \/\/ the limit is something like 90+ parameters.\n+    \/\/ Array of Register Mask bits. The array should be\n+    \/\/ large enough to cover all the machine registers, as well as a certain\n+    \/\/ number of parameters that need to be passed on the stack (stack\n+    \/\/ registers). The number of parameters that can fit in the mask should be\n+    \/\/ dimensioned to cover most common cases. We handle the uncommon cases by\n+    \/\/ extending register masks dynamically (see below).\n@@ -153,0 +155,3 @@\n+  \/\/ Where to extend the register mask\n+  Arena* _arena;\n+\n@@ -174,6 +179,0 @@\n-  \/\/ We support offsetting register masks to present different views of the\n-  \/\/ register space, mainly for use in PhaseChaitin::Select. The _offset\n-  \/\/ variable indicates how many words we offset with. We consider all\n-  \/\/ registers before the offset to not be included in the register mask.\n-  unsigned int _offset;\n-\n@@ -197,1 +196,1 @@\n-  \/\/ (with _offset = 0, for a made-up platform with 10 registers and 4-bit\n+  \/\/ (for a made-up platform with 10 registers and 4-bit\n@@ -204,1 +203,1 @@\n-  \/\/ Content:  [0  0  0  0 |0  1  1  0 |0  0  1  0 ] [1  1  0  1 |0  0  0  0] as  as  as\n+  \/\/ Content:  [0  0  0  0 |0  1  1  0 |0  0  1  0 ] [1  1  0  1 |0  0  0  0] is  is  is\n@@ -216,2 +215,2 @@\n-  \/\/ _infinite_stack (denoted with as), {s10, s11, ...} are all included (as=1)\n-  \/\/ or excluded (as=0). Note that all registers\/stack locations under _lwm\n+  \/\/ _infinite_stack (denoted with is), {s10, s11, ...} are all included (is=1)\n+  \/\/ or excluded (is=0). Note that all registers\/stack locations under _lwm\n@@ -221,0 +220,9 @@\n+\n+  \/\/ We support offsetting\/shifting register masks to explicitly represent stack\n+  \/\/ slots that originally are implicitly represented by _infinite_stack=true.\n+  \/\/ The main use is in PhaseChaitin::Select, when selecting stack slots for\n+  \/\/ spilled values. The _offset variable indicates how many words we offset\n+  \/\/ with. We consider all registers before the offset to not be included in the\n+  \/\/ register mask.\n+  \/\/\n+  unsigned int _offset;\n@@ -266,3 +274,0 @@\n-  \/\/ Where to extend the register mask\n-  Arena* _arena;\n-\n@@ -270,1 +275,1 @@\n-  void grow(unsigned int min_size, bool init = true) {\n+  void grow(unsigned int min_size, bool initialize_by_infinite_stack = true) {\n@@ -285,1 +290,1 @@\n-                                         old_ext_size, new_ext_size);\n+                                           old_ext_size, new_ext_size);\n@@ -287,1 +292,1 @@\n-      if (init) {\n+      if (initialize_by_infinite_stack) {\n@@ -414,1 +419,1 @@\n-      : _rm_size_in_words(RM_SIZE_IN_WORDS), _offset(0), _infinite_stack(infinite_stack), _arena(nullptr) {\n+      : _arena(nullptr), _rm_size_in_words(RM_SIZE_IN_WORDS), _infinite_stack(infinite_stack), _offset(0) {\n@@ -435,3 +440,3 @@\n-  RegMask(Arena* arena DEBUG_ONLY(COMMA bool read_only = false))\n-      : _rm_word() DEBUG_ONLY(COMMA _read_only(read_only)), _rm_size_in_words(RM_SIZE_IN_WORDS),\n-        _offset(0), _infinite_stack(false), _lwm(RM_WORD_MAX_INDEX), _hwm(0), _arena(arena) {\n+  explicit RegMask(Arena* arena DEBUG_ONLY(COMMA bool read_only = false))\n+      : _rm_word() DEBUG_ONLY(COMMA _arena(arena)), _read_only(read_only),\n+        _rm_size_in_words(RM_SIZE_IN_WORDS), _infinite_stack(false), _lwm(RM_WORD_MAX_INDEX), _hwm(0), _offset(0) {\n@@ -450,1 +455,5 @@\n-  RegMask(OptoReg::Name reg) : RegMask(reg, nullptr) {}\n+  explicit RegMask(OptoReg::Name reg) : RegMask(reg, nullptr) {}\n+\n+  \/\/ ----------------------------------------\n+  \/\/ Deep copying constructors and assignment\n+  \/\/ ----------------------------------------\n@@ -452,1 +461,0 @@\n-  \/\/ Deep copying\n@@ -454,1 +462,1 @@\n-      : _rm_size_in_words(RM_SIZE_IN_WORDS), _offset(rm._offset), _arena(arena) {\n+      : _arena(arena), _rm_size_in_words(RM_SIZE_IN_WORDS), _offset(rm._offset) {\n@@ -460,1 +468,0 @@\n-  \/\/ Deep copying\n@@ -466,0 +473,4 @@\n+  \/\/ ----------------\n+  \/\/ End deep copying\n+  \/\/ ----------------\n+\n@@ -843,1 +854,0 @@\n-  \/\/ Also used for testing.\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":39,"deletions":29,"binary":false,"changes":68,"status":"modified"}]}