{"files":[{"patch":"@@ -368,1 +368,1 @@\n-  fprintf(fp,\" 0x%x );\\n\", regs_in_word(i, false));\n+  fprintf(fp,\" 0x%x, false );\\n\", regs_in_word(i, false));\n@@ -375,1 +375,1 @@\n-    fprintf(fp,\" 0x%x );\\n\", regs_in_word(i, true));\n+    fprintf(fp,\" 0x%x, true );\\n\", regs_in_word(i, true));\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,10 @@\n-  \/\/ extend the register mask with dynamically allocated memory.\n+  \/\/ extend the register mask with dynamically allocated memory. We could use a\n+  \/\/ GrowableArray here, but there are currently some GrowableArray limitations\n+  \/\/ that have a negative performance impact for our use case:\n+  \/\/\n+  \/\/ - There is no efficient copy\/clone operation.\n+  \/\/ - GrowableArray construction currently default-initializes everything\n+  \/\/   within their capacity, which is unnecessary in our case.\n+  \/\/\n+  \/\/ After addressing these limitations, we should consider using a\n+  \/\/ GrowableArray here.\n@@ -122,0 +131,25 @@\n+  \/\/ The following diagram illustrates the internal representation of a RegMask\n+  \/\/ (with _offset = 0, for a made-up platform with 10 registers and 4-bit\n+  \/\/ words) that has been extended with two additional words to represent more\n+  \/\/ stack locations:\n+  \/\/                                   _hwm=3\n+  \/\/            _lwm=1                RM_SIZE=3                _rm_size=5\n+  \/\/              |                       |                        |\n+  \/\/   r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 s0 s1   s2 s3 s4 s5 s6 s7 s8 s9 s10 s11 ...\n+  \/\/  [0  0  0  0 |0  1  1  0 |0  0  1  0 ] [1  1  0  1 |0  0  0  0] as  as  as\n+  \/\/ [0]         [1]         [2]           [0]         [1]\n+  \/\/\n+  \/\/ \\____________________________________\/ \\______________________\/\n+  \/\/                        |                           |\n+  \/\/                      RM_UP                     RM_UP_EXT\n+  \/\/ \\_____________________________________________________________\/\n+  \/\/                                 |\n+  \/\/                             _rm_size\n+  \/\/\n+  \/\/ In this example, registers {r5, r6} and stack locations {s0, s2, s3, s5}\n+  \/\/ are included in the register mask. Depending on the value of _all_stack,\n+  \/\/ (s10, s11, ...) are all included (as = 1) or excluded (as = 0). Note that\n+  \/\/ all registers\/stack locations under _lwm and over _hwm are excluded.\n+  \/\/ The exception is (s10, s11, ...), where the value is decided solely by\n+  \/\/ _all_stack, regardless of the value of _hwm.\n+\n@@ -129,1 +163,0 @@\n-      assert( i >= _RM_SIZE, \"sanity\");\n@@ -148,1 +181,1 @@\n-    if(min_size > _rm_size) {\n+    if (min_size > _rm_size) {\n@@ -165,1 +198,1 @@\n-        if(is_AllStack()) {\n+        if (is_AllStack()) {\n@@ -195,1 +228,1 @@\n-    if (src._rm_size < _rm_size ) {\n+    if (src._rm_size < _rm_size) {\n@@ -207,2 +240,2 @@\n-  \/\/ Set a range of words in the register mask to a given value.\n-  void _set_range(unsigned int start, int value, unsigned int range) {\n+  \/\/ Set a span of words in the register mask to a given value.\n+  void _set_range(unsigned int start, int value, unsigned int length) {\n@@ -211,1 +244,1 @@\n-             sizeof(uintptr_t) * MIN2((int)range,(int)_RM_SIZE-(int)start));\n+             sizeof(uintptr_t) * MIN2((int)length,(int)_RM_SIZE-(int)start));\n@@ -213,1 +246,1 @@\n-    if (start + range > _RM_SIZE) {\n+    if (start + length > _RM_SIZE) {\n@@ -217,2 +250,2 @@\n-             sizeof(uintptr_t) * MIN2((int)range,\n-                                      (int)range-((int)_RM_SIZE-(int)start)));\n+             sizeof(uintptr_t) * MIN2((int)length,\n+                                      (int)length-((int)_RM_SIZE-(int)start)));\n@@ -262,1 +295,1 @@\n-    int dummy = 0): _rm_size(_RM_SIZE), _offset(0) {\n+    bool all_stack): _rm_size(_RM_SIZE), _offset(0), _all_stack(all_stack) {\n@@ -275,4 +308,0 @@\n-    \/\/ For historical reasons, this constructor uses the last bit of the mask\n-    \/\/ itself as the _all_stack flag. We need to record this fact using the now\n-    \/\/ separate _all_stack flag.\n-    set_AllStack(_RM_UP[_RM_MAX] & (uintptr_t(1) << _WordBitMask));\n@@ -432,1 +461,1 @@\n-      if(_rm_up(i) & rm._rm_up(i)) {\n+      if (_rm_up(i) & rm._rm_up(i)) {\n@@ -528,1 +557,1 @@\n-    if (rm.is_AllStack() && rm._rm_size < _rm_size ) {\n+    if (rm.is_AllStack() && rm._rm_size < _rm_size) {\n@@ -549,1 +578,1 @@\n-    if (!rm.is_AllStack() && _hwm > rm._rm_max() ) {\n+    if (!rm.is_AllStack() && _hwm > rm._rm_max()) {\n@@ -579,1 +608,1 @@\n-    if (rm.is_AllStack() && _hwm > rm._rm_max() ) {\n+    if (rm.is_AllStack() && _hwm > rm._rm_max()) {\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":49,"deletions":20,"binary":false,"changes":69,"status":"modified"}]}