{"files":[{"patch":"@@ -166,1 +166,3 @@\n-int RegisterForm::words_for_regs() { return (_reg_ctr + 31) >> 5; }\n+int RegisterForm::words_for_regs() {\n+  return (_reg_ctr + 31) >> 5;\n+}\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1532,1 +1532,2 @@\n-    if (OptoReg::is_valid(reg2) && OptoReg::is_reg(reg2 - lrg.mask().offset_bits())) {\n+    if (OptoReg::is_valid(reg2) &&\n+        OptoReg::is_reg(reg2 - lrg.mask().offset_bits())) {\n@@ -1590,6 +1591,6 @@\n-  \/\/ Yeah, yeah, yeah, I know, I know.  I can refactor this\n-  \/\/ to avoid the GOTO, although the refactored code will not\n-  \/\/ be much clearer.  We arrive here IFF we have a stack-based\n-  \/\/ live range that cannot color in the current chunk, and it\n-  \/\/ has to move into the next free stack chunk.\n-  retry_next_chunk:\n+    \/\/ Yeah, yeah, yeah, I know, I know.  I can refactor this\n+    \/\/ to avoid the GOTO, although the refactored code will not\n+    \/\/ be much clearer.  We arrive here IFF we have a stack-based\n+    \/\/ live range that cannot color in the current chunk, and it\n+    \/\/ has to move into the next free stack chunk.\n+    retry_next_chunk:\n@@ -1676,1 +1677,1 @@\n-      if( reg >= _max_reg ) {     \/\/ Compute max register limit\n+      if (reg >= _max_reg) { \/\/ Compute max register limit\n@@ -1741,0 +1742,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -133,1 +133,3 @@\n-  void init_mask(Arena* arena) { new (&_mask) RegMask(arena); }\n+  void init_mask(Arena* arena) {\n+    new (&_mask) RegMask(arena);\n+  }\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-#ifdef ASSERT\n@@ -45,5 +44,2 @@\n-      _inmask(OptoReg::stack2reg(_slot), Compile::current()->comp_arena(),\n-              true),\n-#else\n-      _inmask(OptoReg::stack2reg(_slot), Compile::current()->comp_arena()),\n-#endif\n+      _inmask(OptoReg::stack2reg(_slot),\n+              Compile::current()->comp_arena() DEBUG_ONLY(COMMA true)),\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  const int       _slot; \/\/ stack slot\n+  const int _slot;       \/\/ stack slot\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1260,1 +1260,1 @@\n-    if( warped >= out_arg_limit_per_call ) {\n+    if (warped >= out_arg_limit_per_call) {\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,1 +247,2 @@\n-      return OptoReg::Name(offset_bits() + (i<<_LogWordBits) + find_lowest_bit(_rm_up(i)) + (size - 1));\n+      return OptoReg::Name(offset_bits() + (i << _LogWordBits) +\n+                           find_lowest_bit(_rm_up(i)) + (size - 1));\n@@ -356,1 +357,1 @@\n-        if ((all & ~(bit-1)) != _rm_up(i)) {\n+        if ((all & ~(bit - 1)) != _rm_up(i)) {\n@@ -460,1 +461,2 @@\n-    st->print(LP64_ONLY(\"%0*lx\") NOT_LP64(\"%0*x\"), (int)sizeof(uintptr_t) * CHAR_BIT \/ 4, _rm_up(i));\n+    st->print(LP64_ONLY(\"%0*lx\") NOT_LP64(\"%0*x\"),\n+              (int)sizeof(uintptr_t) * CHAR_BIT \/ 4, _rm_up(i));\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -97,3 +97,3 @@\n-    \/\/ the machine registers and all parameters that need to be passed on the\n-    \/\/ stack (stack registers) up to some interesting limit. On Intel, the\n-    \/\/ limit is something like 90+ parameters.\n+    \/\/ the machine registers and usually all parameters that need to be passed\n+    \/\/ on the stack (stack registers) up to some interesting limit. On Intel,\n+    \/\/ the limit is something like 90+ parameters.\n@@ -106,1 +106,1 @@\n-  \/\/ base statically allocated _RM_UP, and arena-allocate the extended mask\n+  \/\/ base statically allocated _RM_UP, and arena allocate the extended mask\n@@ -120,1 +120,1 @@\n-  \/\/   within their capacity, which is unnecessary in our case.\n+  \/\/   within the array's initial capacity, which is unnecessary in our case.\n@@ -209,1 +209,3 @@\n-  unsigned int _rm_max() const { return _rm_size - 1U; }\n+  unsigned int _rm_max() const {\n+    return _rm_size - 1U;\n+  }\n@@ -303,2 +305,2 @@\n-             sizeof(uintptr_t) * MIN2((int)length,\n-                                      (int)length - ((int)_RM_SIZE - (int)start)));\n+             sizeof(uintptr_t) *\n+                 MIN2((int)length, (int)length - ((int)_RM_SIZE - (int)start)));\n@@ -309,2 +311,6 @@\n-  unsigned int rm_size() const { return _rm_size; }\n-  unsigned int rm_size_bits() const { return _rm_size * BitsPerWord; }\n+  unsigned int rm_size() const {\n+    return _rm_size;\n+  }\n+  unsigned int rm_size_bits() const {\n+    return _rm_size * BitsPerWord;\n+  }\n@@ -312,2 +318,6 @@\n-  bool is_offset() const { return _offset > 0; }\n-  unsigned int offset_bits() const { return _offset * BitsPerWord; };\n+  bool is_offset() const {\n+    return _offset > 0;\n+  }\n+  unsigned int offset_bits() const {\n+    return _offset * BitsPerWord;\n+  };\n@@ -315,2 +325,6 @@\n-  bool is_AllStack() const { return _all_stack; }\n-  void set_AllStack(bool value = true) { _all_stack = value; }\n+  bool is_AllStack() const {\n+    return _all_stack;\n+  }\n+  void set_AllStack(bool value = true) {\n+    _all_stack = value;\n+  }\n@@ -369,1 +383,3 @@\n-  RegMask() : RegMask(nullptr) { assert(valid_watermarks(), \"post-condition\"); }\n+  RegMask() : RegMask(nullptr) {\n+    assert(valid_watermarks(), \"post-condition\");\n+  }\n@@ -372,2 +388,3 @@\n-#ifdef ASSERT\n-  RegMask(OptoReg::Name reg, Arena* arena, bool orig_const = false)\n+  RegMask(OptoReg::Name reg,\n+          Arena* arena\n+          DEBUG_ONLY(COMMA bool orig_const = false))\n@@ -376,1 +393,1 @@\n-    this->orig_const = orig_const;\n+    DEBUG_ONLY(this->orig_const = orig_const;)\n@@ -378,2 +395,0 @@\n-#else\n-  RegMask(OptoReg::Name reg, Arena* arena) : RegMask(arena) { Insert(reg); }\n@@ -424,1 +439,2 @@\n-        return OptoReg::Name(offset_bits() + (i << _LogWordBits) + find_lowest_bit(bits));\n+        return OptoReg::Name(offset_bits() + (i << _LogWordBits) +\n+                             find_lowest_bit(bits));\n@@ -439,1 +455,2 @@\n-        return OptoReg::Name(offset_bits() + (i << _LogWordBits) + find_highest_bit(bits));\n+        return OptoReg::Name(offset_bits() + (i << _LogWordBits) +\n+                             find_highest_bit(bits));\n@@ -818,1 +835,3 @@\n-        _reg = OptoReg::Name(_rm.offset_bits() + ((_next_index - 1) << RegMask::_LogWordBits) + next_bit);\n+        _reg = OptoReg::Name(_rm.offset_bits() +\n+                             ((_next_index - 1) << RegMask::_LogWordBits) +\n+                             next_bit);\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":42,"deletions":23,"binary":false,"changes":65,"status":"modified"}]}