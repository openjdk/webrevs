{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.util.List;\n@@ -201,0 +202,13 @@\n+            @Override\n+            public String readAllAsString() throws IOException {\n+                ensureOpen();\n+                String result = cs.toString().substring(next);\n+                next += result.length();\n+                return result;\n+            }\n+\n+            @Override\n+            public List<String> readAllLines() throws IOException {\n+                return readAllAsString().lines().toList();\n+            }\n+\n@@ -385,0 +399,105 @@\n+    private String readAllCharsAsString() throws IOException {\n+        StringBuilder result = new StringBuilder();\n+        char[] str = new char[TRANSFER_BUFFER_SIZE];\n+        int n;\n+        while ((n = read(str)) != -1) {\n+            result.append(str, 0, n);\n+        }\n+        return result.toString();\n+    }\n+\n+    \/**\n+     * Reads all remaining characters as lines of text. This method blocks until\n+     * all remaining characters have been read and end of stream is detected,\n+     * or an exception is thrown. This method does not close the reader.\n+     *\n+     * <p> When this reader reaches the end of the stream, further\n+     * invocations of this method will return an empty list.\n+     *\n+     * <p> A <i>line<\/i> is either a sequence of zero or more characters\n+     * followed by a line terminator, or it is a sequence of one or\n+     * more characters followed by the end of the stream.\n+     * A line does not include the line terminator.\n+     *\n+     * <p> A <i>line terminator<\/i> is one of the following:\n+     * a line feed character {@code \"\\n\"} (U+000A),\n+     * a carriage return character {@code \"\\r\"} (U+000D),\n+     * or a carriage return followed immediately by a line feed\n+     * {@code \"\\r\\n\"} (U+000D U+000A).\n+     *\n+     * <p> The behavior for the case where the reader is\n+     * <i>asynchronously closed<\/i>, or the thread interrupted during the\n+     * read, is highly input reader specific, and therefore not specified.\n+     *\n+     * <p> If an I\/O error occurs reading from the stream, then it\n+     * may do so after some, but not all, characters have been read.\n+     * Consequently the stream may not be at end of stream and may\n+     * be in an inconsistent state. It is strongly recommended that the reader\n+     * be promptly closed if an I\/O error occurs.\n+     *\n+     * @apiNote\n+     * This method is intended for simple cases where it is convenient\n+     * to read all remaining characters in a single operation. It is not\n+     * intended for reading a large number of characters, for example,\n+     * greater than {@code 1G}.\n+     *\n+     * @return     the remaining characters as lines of text stored in an\n+     *             unmodifiable {@code List} of {@code String}s in the order\n+     *             they are read\n+     *\n+     * @throws     IOException  If an I\/O error occurs\n+     * @throws     OutOfMemoryError  If the number of remaining characters\n+     *             exceeds the implementation limit for {@code String}.\n+     *\n+     * @see String#lines\n+     * @see #readAllAsString\n+     * @see java.nio.file.Files#readAllLines\n+     *\n+     * @since 25\n+     *\/\n+    public List<String> readAllLines() throws IOException {\n+        return readAllCharsAsString().lines().toList();\n+    }\n+\n+    \/**\n+     * Reads all remaining characters into a string. This method blocks until\n+     * all remaining characters including all line separators have been read\n+     * and end of stream is detected, or an exception is thrown. The resulting\n+     * string will contain line separators as they appear in the stream. This\n+     * method does not close the reader.\n+     *\n+     * <p> When this reader reaches the end of the stream, further\n+     * invocations of this method will return an empty string.\n+     *\n+     * <p> The behavior for the case where the reader\n+     * is <i>asynchronously closed<\/i>, or the thread interrupted during the\n+     * read, is highly input reader specific, and therefore not specified.\n+     *\n+     * <p> If an I\/O error occurs reading from the stream, then it\n+     * may do so after some, but not all, characters have been read.\n+     * Consequently the stream may not be at end of stream and may\n+     * be in an inconsistent state. It is strongly recommended that the reader\n+     * be promptly closed if an I\/O error occurs.\n+     *\n+     * @apiNote\n+     * This method is intended for simple cases where it is appropriate and\n+     * convenient to read all remaining characters into a {@code String}. It\n+     * is not intended for reading a large number of characters, for example,\n+     * greater than {@code 1G}.\n+     *\n+     * @return     a {@code String} containing all remaining characters\n+     *\n+     * @throws     IOException       If an I\/O error occurs\n+     * @throws     OutOfMemoryError  If the number of remaining characters\n+     *                               exceeds the implementation limit for\n+     *                               {@code String}.\n+     *\n+     * @see #readAllLines\n+     * @see java.nio.file.Files#readString\n+     *\n+     * @since 25\n+     *\/\n+    public String readAllAsString() throws IOException {\n+        return readAllCharsAsString();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/Reader.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8354724\n+ * @summary Test Reader readAllLines and readAllAstring methods\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.Platform jdk.test.lib.RandomFactory\n+ * @run junit ReadAll\n+ * @key randomness\n+ *\/\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class ReadAll {\n+    private static final String PHRASE =\n+        \"Ange plein de gaiet√©, connaissez-vous l'angoisse\";\n+\n+    private static File file;\n+    private static Path path;\n+    private static Random rnd;\n+\n+    @BeforeAll\n+    public static void setup() throws IOException {\n+        path = Files.createTempFile(Path.of(\".\"), \"foo\", \"bar\");\n+        file = path.toFile();\n+\n+        rnd = RandomFactory.getRandom();\n+        int size = rnd.nextInt(2, 16386);\n+\n+        int plen = PHRASE.length();\n+        List<String> strings = new ArrayList<String>(size);\n+        while (strings.size() < size) {\n+            int fromIndex = rnd.nextInt(0, plen \/ 2);\n+            int toIndex = rnd.nextInt(fromIndex, plen);\n+            strings.add(PHRASE.substring(fromIndex, toIndex));\n+        }\n+        Files.write(path, strings);\n+        System.out.println(strings.size() + \" lines written\");\n+    }\n+\n+    @AfterAll\n+    public static void cleanup() throws IOException {\n+        if (file != null)\n+            file.delete();\n+    }\n+\n+    @Test\n+    public void readAllLines() throws IOException {\n+        \/\/ Reader implementation\n+        List<String> lines;\n+        try (FileReader fr = new FileReader(file)) {\n+            lines = fr.readAllLines();\n+        }\n+        System.out.println(lines.size() + \" lines read\");\n+\n+        List<String> linesExpected = Files.readAllLines(path);\n+        assertEquals(linesExpected, lines);\n+\n+        \/\/ Reader.of implementation\n+        String stringExpected = Files.readString(path);\n+        int n = rnd.nextInt(stringExpected.length()\/2);\n+        String substringExpected = stringExpected.substring(n);\n+        linesExpected = substringExpected.lines().toList();\n+        try (Reader r = new StringReader(stringExpected)) {\n+            r.skip(n);\n+            lines = r.readAllLines();\n+        }\n+        assertEquals(linesExpected, lines);\n+    }\n+\n+    @Test\n+    public void readAllAsString() throws IOException {\n+        \/\/ Reader implementation\n+        String string;\n+        try (FileReader fr = new FileReader(file)) {\n+            string = fr.readAllAsString();\n+        }\n+        String stringExpected = Files.readString(path);\n+        assertEquals(stringExpected, string);\n+\n+        \/\/ Reader.of implementation\n+        int n = rnd.nextInt(stringExpected.length()\/2);\n+        try (Reader r = Reader.of(stringExpected)) {\n+            r.skip(n);\n+            string = r.readAllAsString();\n+        }\n+        assertEquals(stringExpected.substring(n), string);\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/BufferedReader\/ReadAll.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"}]}