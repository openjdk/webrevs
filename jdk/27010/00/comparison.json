{"files":[{"patch":"@@ -41,7 +41,17 @@\n-\/**\n- * The flavor of method handle which emulates an invoke instruction\n- * on a predetermined argument.  The JVM dispatches to the correct method\n- * when the handle is created, not when it is invoked.\n- *\n- * All bound arguments are encapsulated in dedicated species.\n- *\/\n+\/\/\/ The flavor of method handle which is constructed with unmodifiable bound values,\n+\/\/\/ usable by lambda forms. For example, they can carry a configuration object\n+\/\/\/ for its lambda form, or carry an underlying method handle and its bound\n+\/\/\/ arguments for currying.\n+\/\/\/\n+\/\/\/ Each BMH acts like a strongly-typed argument list, where the types are\n+\/\/\/ [BasicType]s.  This type information is recorded by its species, represented\n+\/\/\/ by a per-class [SpeciesData].  A [Specializer] manages lookup for any species.\n+\/\/\/\n+\/\/\/ Factories are provided by [BoundMethodHandle.SpeciesData#factory()].\n+\/\/\/ Getters are exposed as [BoundMethodHandle.SpeciesData#getter(int)],\n+\/\/\/ which can be included as names in lambda forms.\n+\/\/\/\n+\/\/\/ [SimpleMethodHandle] (with no bound value) and [Species_L] (with a bound\n+\/\/\/ reference value) are explicitly provided to prevent bootstrap loops; the\n+\/\/\/ rest may be generated on demand, or may be pregenerated by\n+\/\/\/ [GenerateJLIClassesHelper].\n@@ -468,12 +478,4 @@\n-        \/**\n-         * Generation of concrete BMH classes.\n-         *\n-         * A concrete BMH species is fit for binding a number of values adhering to a\n-         * given type pattern. Reference types are erased.\n-         *\n-         * BMH species are cached by type pattern.\n-         *\n-         * A BMH species has a number of fields with the concrete (possibly erased) types of\n-         * bound values. Setters are provided as an API in BMH. Getters are exposed as MHs,\n-         * which can be included as names in lambda forms.\n-         *\/\n+        \/\/\/ Generates concrete BMH classes.\n+        \/\/\/\n+        \/\/\/ [GenerateJLIClassesHelper] can pre-generate species that are known\n+        \/\/\/ to be loaded from [MethodHandleStatics#traceSpeciesType].\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BoundMethodHandle.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -199,1 +199,11 @@\n-    \/* Placeholder class for DelegatingMethodHandles generated ahead of time *\/\n+    \/\/\/ Holds pre-generated bytecode for lambda forms used by DelegatingMethodHandle.\n+    \/\/\/ This class may be substituted by a generated class from [GenerateJLIClassesHelper].\n+    \/\/\/\n+    \/\/\/ The method names of this class are internal tokens recognized by\n+    \/\/\/ [InvokerBytecodeGenerator#lookupPregenerated] and is subject to change.\n+    \/\/\/\n+    \/\/\/ To view the actual content of this class in a JDK, run the `javap` in\n+    \/\/\/ that JDK with: (Note to escape `$` in bash)\n+    \/\/\/ ```\n+    \/\/\/ javap -c -p -v java.lang.invoke.DelegatingMethodHandle\\$Holder\n+    \/\/\/ ```\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DelegatingMethodHandle.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -942,1 +942,11 @@\n-    \/* Placeholder class for DirectMethodHandles generated ahead of time *\/\n+    \/\/\/ Holds pre-generated bytecode for lambda forms used by DirectMethodHandle.\n+    \/\/\/ This class may be substituted by a generated class from [GenerateJLIClassesHelper].\n+    \/\/\/\n+    \/\/\/ The method names of this class are internal tokens recognized by\n+    \/\/\/ [InvokerBytecodeGenerator#lookupPregenerated] and is subject to change.\n+    \/\/\/\n+    \/\/\/ To view the actual content of this class in a JDK, run the `javap` in\n+    \/\/\/ that JDK with: (Note to escape `$` in bash)\n+    \/\/\/ ```\n+    \/\/\/ javap -c -p -v java.lang.invoke.DirectMethodHandle\\$Holder\n+    \/\/\/ ```\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,5 +50,37 @@\n-\/**\n- * Helper class to assist the GenerateJLIClassesPlugin to get access to\n- * generate classes ahead of time.\n- *\/\n-class GenerateJLIClassesHelper {\n+\/\/\/ Generates bound method handle species classes, and classes with methods that\n+\/\/\/ hold compiled lambda form bytecode ahead of time, so certain lambda forms\n+\/\/\/ no longer need to spin classes because they can find existing bytecode.\n+\/\/\/ Bytecode pre-generation reduces static initialization costs, footprint costs,\n+\/\/\/ and circular dependencies that may arise if a class is generated per\n+\/\/\/ LambdaForm by [InvokerBytecodeGenerator].\n+\/\/\/\n+\/\/\/ Since lambda forms and bound method handle species are closely tied to\n+\/\/\/ method types, which have many varieties, this generator needs logs to detect\n+\/\/\/ which method types are used, so our generation matches the actual usage.\n+\/\/\/\n+\/\/\/ This does not have comprehensive coverage of all lambda forms created in a\n+\/\/\/ Java Runtime. For example, forms created by {@link LambdaFormEditor} are\n+\/\/\/ not captured.\n+\/\/\/\n+\/\/\/ Currently, `GenerateJLIClassesPlugin` and the AOT process pre-generate with\n+\/\/\/ `GenerateJLIClassesHelper`. `GenerateJLIClassesPlugin` runs for JDK builds;\n+\/\/\/ in a JDK image, `javap` can check the actual content of the generated classes,\n+\/\/\/ such as: (Note to escape `$` in bash)\n+\/\/\/ ```\n+\/\/\/ javap -c -p -v java.lang.invoke.LambdaForm\\$Holder\n+\/\/\/ javap -c -p -v java.lang.invoke.BoundMethodHandle\\$Species_J\n+\/\/\/ ```\n+\/\/\/ The AOT process pregenerates in the end of the training run, and initializes\n+\/\/\/ the classes for linkage in assembly phase; see `regeneratedClasses.hpp`.\n+\/\/\/\n+\/\/\/ VarHandle has a similar pre-generation system for its forms, except it is\n+\/\/\/ done at source generation; they reside in [VarHandleGuards].\n+\/\/\/\n+\/\/\/ @see #generateHolderClasses(Stream)\n+\/\/\/ @see BoundMethodHandle.Specializer\n+\/\/\/ @see DelegatingMethodHandle.Holder\n+\/\/\/ @see DirectMethodHandle.Holder\n+\/\/\/ @see Invokers.Holder\n+\/\/\/ @see LambdaForm.Holder\n+\/\/\/ @see VarHandleGuards\n+final class GenerateJLIClassesHelper {\n@@ -324,7 +356,15 @@\n-    \/*\n-     * Returns a map of class name in internal form to the corresponding class bytes\n-     * per the given stream of SPECIES_RESOLVE and LF_RESOLVE trace logs.\n-     *\n-     * Used by GenerateJLIClassesPlugin to pre-generate holder classes during\n-     * jlink phase.\n-     *\/\n+    \/\/\/ Returns a map of class name in internal form to the corresponding class\n+    \/\/\/ bytes.\n+    \/\/\/\n+    \/\/\/ A few known lambda forms, such as field accessors, can be comprehensively\n+    \/\/\/ generated.  Most others lambda forms are associated with unique method\n+    \/\/\/ types; thus they are generated per the given stream of SPECIES_RESOLVE\n+    \/\/\/ and LF_RESOLVE trace logs, which are created according to {@link\n+    \/\/\/ MethodHandleStatics#TRACE_RESOLVE} configuration.\n+    \/\/\/\n+    \/\/\/ The names of methods in the generated classes are internal tokens\n+    \/\/\/ recognized by [InvokerBytecodeGenerator#lookupPregenerated] and are\n+    \/\/\/ subject to change.\n+    \/\/\/\n+    \/\/\/ @see MethodHandleStatics#traceLambdaForm\n+    \/\/\/ @see MethodHandleStatics#traceSpeciesType\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":52,"deletions":12,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -448,0 +448,1 @@\n+    \/\/\/ Look up a method that may have been generated by [GenerateJLIClassesHelper].\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -700,1 +700,11 @@\n-    \/* Placeholder class for Invokers generated ahead of time *\/\n+    \/\/\/ Holds pre-generated bytecode for lambda forms used by method type invokers.\n+    \/\/\/ This class may be substituted by a generated class from [GenerateJLIClassesHelper].\n+    \/\/\/\n+    \/\/\/ The method names of this class are internal tokens recognized by\n+    \/\/\/ [InvokerBytecodeGenerator#lookupPregenerated] and is subject to change.\n+    \/\/\/\n+    \/\/\/ To view the actual content of this class in a JDK, run the `javap` in\n+    \/\/\/ that JDK with: (Note to escape `$` in bash)\n+    \/\/\/ ```\n+    \/\/\/ javap -c -p -v java.lang.invoke.Invokers\\$Holder\n+    \/\/\/ ```\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -142,0 +142,2 @@\n+    \/\/\/ Represents the \"basic\" types that exist in the JVM linkage and stack\/locals.\n+    \/\/\/ All subwords (boolean, byte, char, short) are promoted to int.\n@@ -1733,1 +1735,11 @@\n-    \/* Placeholder class for identity and constant forms generated ahead of time *\/\n+    \/\/\/ Holds pre-generated bytecode for common lambda forms.\n+    \/\/\/ This class may be substituted by a generated class from [GenerateJLIClassesHelper].\n+    \/\/\/\n+    \/\/\/ The method names of this class are internal tokens recognized by\n+    \/\/\/ [InvokerBytecodeGenerator#lookupPregenerated] and is subject to change.\n+    \/\/\/\n+    \/\/\/ To view the actual content of this class in a JDK, run the `javap` in\n+    \/\/\/ that JDK with: (Note to escape `$` in bash)\n+    \/\/\/ ```\n+    \/\/\/ javap -c -p -v java.lang.invoke.LambdaForm\\$Holder\n+    \/\/\/ ```\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}