{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -73,1 +74,1 @@\n- * The JVM class file format has a new version defined for each new\n+ * The JVM class file format has a {@linkplain ClassFileFormatVersion new version} defined for each new\n@@ -100,2 +101,6 @@\n-           Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n-                  Location.INNER_CLASS)),\n+           Location.SET_PUBLIC_1,\n+           cffv -> {\n+               return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                   Location.SET_CLASS_FIELD_METHOD:\n+                   Location.SET_PUBLIC_1;\n+           }),\n@@ -108,1 +113,6 @@\n-    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    PRIVATE(Modifier.PRIVATE, true, Location.SET_FIELD_METHOD_INNER_CLASS,\n+            cffv -> {\n+                return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                    Location.SET_FIELD_METHOD:\n+                    Location.SET_FIELD_METHOD_INNER_CLASS;\n+            }),\n@@ -115,1 +125,4 @@\n-    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    PROTECTED(Modifier.PROTECTED, true, Location.SET_FIELD_METHOD_INNER_CLASS,\n+              cffv -> {return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                      Location.SET_FIELD_METHOD:\n+                      Location.SET_FIELD_METHOD_INNER_CLASS;}),\n@@ -122,1 +135,4 @@\n-    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS),\n+    STATIC(Modifier.STATIC, true, Location.SET_FIELD_METHOD_INNER_CLASS,\n+           cffv -> {return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                Location.SET_FIELD_METHOD:\n+                Location.SET_FIELD_METHOD_INNER_CLASS;}),\n@@ -130,2 +146,10 @@\n-          Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n-                 Location.INNER_CLASS, Location.METHOD_PARAMETER)),\n+          Location.SET_FINAL_8,\n+          cffv -> {\n+              if (cffv.compareTo(ClassFileFormatVersion.RELEASE_8) >= 0) {\n+                  return Location.SET_FINAL_8;\n+              } else {\n+                  return (cffv == ClassFileFormatVersion.RELEASE_0) ?\n+                      Location.SET_CLASS_FIELD_METHOD :\n+                      Location.SET_CLASS_FIELD_METHOD_INNER_CLASS;\n+              }\n+          }),\n@@ -141,1 +165,1 @@\n-    SUPER(0x0000_0020, false, Location.SET_CLASS),\n+    SUPER(0x0000_0020, false, Location.SET_CLASS, null),\n@@ -148,1 +172,4 @@\n-    OPEN(0x0000_0020, false, Set.of(Location.MODULE)),\n+        OPEN(0x0000_0020, false, Location.SET_MODULE,\n+        cffv -> { return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+            Location.SET_MODULE:\n+            Location.EMPTY_SET;}),\n@@ -155,1 +182,4 @@\n-    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES),\n+    TRANSITIVE(0x0000_0020, false, Location.SET_MODULE_REQUIRES,\n+               cffv -> {return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                       Location.SET_MODULE_REQUIRES:\n+                       Location.EMPTY_SET;}),\n@@ -162,1 +192,1 @@\n-    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD),\n+    SYNCHRONIZED(Modifier.SYNCHRONIZED, true, Location.SET_METHOD, null),\n@@ -169,8 +199,11 @@\n-    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES),\n-\n-     \/**\n-      * The access flag {@code ACC_VOLATILE}, corresponding to the\n-      * source modifier {@link Modifier#VOLATILE volatile} with a mask\n-      * value of <code>{@value \"0x%04x\" Modifier#VOLATILE}<\/code>.\n-      *\/\n-    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD),\n+    STATIC_PHASE(0x0000_0040, false, Location.SET_MODULE_REQUIRES,\n+                 cffv -> {return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                         Location.SET_MODULE_REQUIRES:\n+                         Location.EMPTY_SET;}),\n+\n+   \/**\n+     * The access flag {@code ACC_VOLATILE}, corresponding to the\n+     * source modifier {@link Modifier#VOLATILE volatile} with a mask\n+     * value of <code>{@value \"0x%04x\" Modifier#VOLATILE}<\/code>.\n+     *\/\n+    VOLATILE(Modifier.VOLATILE, true, Location.SET_FIELD, null),\n@@ -183,1 +216,4 @@\n-    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD),\n+    BRIDGE(Modifier.BRIDGE, false, Location.SET_METHOD,\n+           cffv -> {return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                Location.SET_METHOD:\n+                Location.EMPTY_SET;}),\n@@ -190,1 +226,1 @@\n-    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD),\n+    TRANSIENT(Modifier.TRANSIENT, true, Location.SET_FIELD, null),\n@@ -197,1 +233,5 @@\n-    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD),\n+    VARARGS(Modifier.VARARGS, false, Location.SET_METHOD,\n+            cffv -> {return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                    Location.SET_METHOD:\n+                    Location.EMPTY_SET;}),\n+\n@@ -204,1 +244,1 @@\n-    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD),\n+    NATIVE(Modifier.NATIVE, true, Location.SET_METHOD, null),\n@@ -211,1 +251,4 @@\n-    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS),\n+    INTERFACE(Modifier.INTERFACE, false, Location.SET_CLASS_INNER_CLASS,\n+              cffv -> { return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n+                      Location.SET_CLASS:\n+                      Location.SET_CLASS_INNER_CLASS;}),\n@@ -219,1 +262,4 @@\n-             Set.of(Location.CLASS, Location.METHOD, Location.INNER_CLASS)),\n+             Location.SET_CLASS_METHOD_INNER_CLASS,\n+             cffv -> { return (cffv.compareTo(ClassFileFormatVersion.RELEASE_0) == 0 ) ?\n+                     Location.SET_CLASS_METHOD:\n+                     Location.SET_CLASS_METHOD_INNER_CLASS;}),\n@@ -231,1 +277,6 @@\n-    STRICT(Modifier.STRICT, true, Location.SET_METHOD),\n+    STRICT(Modifier.STRICT, true, Location.SET_METHOD,\n+           cffv -> {return (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n+                            cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n+                   Location.SET_METHOD:\n+                   Location.EMPTY_SET;}),\n+\n@@ -240,5 +291,13 @@\n-    SYNTHETIC(Modifier.SYNTHETIC, false,\n-              Set.of(Location.CLASS, Location.FIELD, Location.METHOD,\n-                     Location.INNER_CLASS, Location.METHOD_PARAMETER,\n-                     Location.MODULE, Location.MODULE_REQUIRES,\n-                     Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+    SYNTHETIC(Modifier.SYNTHETIC, false, Location.SET_SYNTHETIC_9,\n+              cffv -> {\n+                  if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 )\n+                      return Location.SET_SYNTHETIC_9;\n+                  else {\n+                      return\n+                          switch(cffv) {\n+                          case RELEASE_7 -> Location.SET_SYNTHETIC_7;\n+                          case RELEASE_8 -> Location.SET_SYNTHETIC_8;\n+                          default        -> Location.EMPTY_SET;\n+                          };\n+                  }\n+              }),\n@@ -251,1 +310,4 @@\n-    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS),\n+    ANNOTATION(Modifier.ANNOTATION, false, Location.SET_CLASS_INNER_CLASS,\n+               cffv -> {return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                Location.SET_CLASS_INNER_CLASS:\n+                Location.EMPTY_SET;}),\n@@ -258,2 +320,4 @@\n-    ENUM(Modifier.ENUM, false,\n-         Set.of(Location.CLASS, Location.FIELD, Location.INNER_CLASS)),\n+    ENUM(Modifier.ENUM, false, Location.SET_CLASS_FIELD_INNER_CLASS,\n+         cffv -> {return (cffv.compareTo(ClassFileFormatVersion.RELEASE_5) >= 0 ) ?\n+                 Location.SET_CLASS_FIELD_INNER_CLASS:\n+                 Location.EMPTY_SET;}),\n@@ -265,4 +329,10 @@\n-    MANDATED(Modifier.MANDATED, false,\n-             Set.of(Location.METHOD_PARAMETER,\n-                    Location.MODULE, Location.MODULE_REQUIRES,\n-                    Location.MODULE_EXPORTS, Location.MODULE_OPENS)),\n+    MANDATED(Modifier.MANDATED, false, Location.SET_MANDATED_9,\n+             cffv -> {\n+                 if (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) {\n+                     return Location.SET_MANDATED_9;\n+                 } else {\n+                     return (cffv == ClassFileFormatVersion.RELEASE_8) ?\n+                         Location.SET_METHOD_PARAM:\n+                         Location.EMPTY_SET;\n+                 }\n+             }),\n@@ -274,1 +344,4 @@\n-    MODULE(0x0000_8000, false, Location.SET_CLASS)\n+    MODULE(0x0000_8000, false, Location.SET_CLASS,\n+           cffv -> {return (cffv.compareTo(ClassFileFormatVersion.RELEASE_9) >= 0 ) ?\n+                   Location.SET_CLASS:\n+                   Location.EMPTY_SET;})\n@@ -286,0 +359,2 @@\n+    \/\/ Lambda to implement locations(ClassFileFormatVersion cffv)\n+    private final Function<ClassFileFormatVersion, Set<Location>> cffvToLocations;\n@@ -287,1 +362,4 @@\n-    private AccessFlag(int mask, boolean sourceModifier, Set<Location> locations) {\n+    private AccessFlag(int mask,\n+                       boolean sourceModifier,\n+                       Set<Location> locations,\n+                       Function<ClassFileFormatVersion, Set<Location>> cffvToLocations) {\n@@ -291,0 +369,1 @@\n+        this.cffvToLocations = cffvToLocations;\n@@ -309,1 +388,2 @@\n-     * {@return kinds of constructs the flag can be applied to}\n+     * {@return kinds of constructs the flag can be applied to in the\n+     * latest class file format version}\n@@ -315,0 +395,14 @@\n+    \/**\n+     * {@return kinds of constructs the flag can be applied to in the\n+     * given class file format version}\n+     * @param cffv the class file format version to use\n+     * @throws NullPointerException if the parameter is {@code null}\n+     *\/\n+    public Set<Location> locations(ClassFileFormatVersion cffv) {\n+        if (cffvToLocations == null) {\n+            return locations;\n+        } else {\n+            return cffvToLocations.apply(cffv);\n+        }\n+    }\n+\n@@ -405,0 +499,14 @@\n+        private static final Set<Location> EMPTY_SET = Set.of();\n+        private static final Set<Location> SET_MODULE = Set.of(MODULE);\n+        private static final Set<Location> SET_CLASS_METHOD_INNER_CLASS =\n+            Set.of(CLASS, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_CLASS_FIELD_METHOD =\n+            Set.of(CLASS, FIELD, METHOD);\n+        private static final Set<Location> SET_CLASS_FIELD_INNER_CLASS =\n+            Set.of(CLASS, FIELD, INNER_CLASS);\n+        private static final Set<Location> SET_CLASS_FIELD_METHOD_INNER_CLASS =\n+            Set.of(CLASS, FIELD, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_CLASS_METHOD =\n+            Set.of(CLASS, METHOD);\n+        private static final Set<Location> SET_FIELD_METHOD =\n+            Set.of(FIELD, METHOD);\n@@ -408,0 +516,1 @@\n+        private static final Set<Location> SET_METHOD_PARAM = Set.of(METHOD_PARAMETER);\n@@ -414,0 +523,25 @@\n+        private static final Set<Location> SET_PUBLIC_1 =\n+            Set.of(CLASS, FIELD, METHOD, INNER_CLASS);\n+        private static final Set<Location> SET_FINAL_8 =\n+            Set.of(CLASS, FIELD, METHOD,\n+                   INNER_CLASS,     \/* added in 1.1 *\/\n+                   METHOD_PARAMETER); \/* added in 8 *\/\n+        private static final Set<Location> SET_SYNTHETIC_7 =\n+              Set.of(CLASS, FIELD, METHOD,\n+                     INNER_CLASS);\n+        private static final Set<Location> SET_SYNTHETIC_8 =\n+              Set.of(CLASS, FIELD, METHOD,\n+                     INNER_CLASS, METHOD_PARAMETER);\n+        private static final Set<Location> SET_SYNTHETIC_9 =\n+              \/\/ Added as an access flag in 7\n+              Set.of(CLASS, FIELD, METHOD,\n+                     INNER_CLASS,\n+                     METHOD_PARAMETER, \/\/ Added in 8\n+                     \/\/ Module-related items added in 9\n+                     MODULE, MODULE_REQUIRES,\n+                     MODULE_EXPORTS, MODULE_OPENS);\n+        private static final Set<Location> SET_MANDATED_9 =\n+            Set.of(METHOD_PARAMETER, \/\/ From 8\n+                   \/\/ Starting in 9\n+                   MODULE, MODULE_REQUIRES,\n+                   MODULE_EXPORTS, MODULE_OPENS);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessFlag.java","additions":176,"deletions":42,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -0,0 +1,353 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.reflect;\n+\n+\/**\n+ * Class file format versions of the Java virtual machine.\n+ *\n+ * See the appropriate edition of <cite>The Java Virtual Machine\n+ * Specification<\/cite> for information about a particular class file\n+ * format version.\n+ *\n+ * <p>Note that additional class file format version constants will be\n+ * added to model future releases of the Java Virtual Machine\n+ * Specification.\n+ *\n+ * @since 20\n+ * @see System#getProperties System property {@code java.class.version}\n+ * @see java.compiler\/javax.lang.model.SourceVersion\n+ *\/\n+@SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n+public enum ClassFileFormatVersion {\n+\n+    \/**\n+     * The original version.\n+     *\n+     * The format described in <cite>The Java Virtual Specification,\n+     * First Edition<\/cite>.\n+     *\/\n+    RELEASE_0(45),\n+\n+    \/**\n+     * The version recognized by the Java Platform 1.1.\n+     *\n+     * @apiNote\n+     * While {@code RELEASE_0} and {@code RELEASE_1} have the same\n+     * {@linkplain #major() major version}, several additional\n+     * attributes were defined for {@code RELEASE_1} (JVMS {@jvms\n+     * 4.7}).\n+     *\n+     *\/\n+    RELEASE_1(45),\n+\n+    \/**\n+     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * v 1.2.\n+     *\n+     * The format described in <cite>The Java Virtual Machine\n+     * Specification, Second Edition<\/cite>, which includes the {@link\n+     * AccessFlag#STRICT ACC_STRICT} access flag.\n+     *\/\n+    RELEASE_2(46),\n+\n+    \/**\n+     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * v 1.3.\n+     *\/\n+    RELEASE_3(47),\n+\n+    \/**\n+     * The version recognized by the Java 2 Platform, Standard Edition,\n+     * v 1.4.\n+     *\/\n+    RELEASE_4(48),\n+\n+    \/**\n+     * The version recognized by the Java 2 Platform, Standard\n+     * Edition 5.0.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/maintenance\/jsr924\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Second Edition updated for Java SE 5.0<\/cite><\/a>\n+     * @see <a href=\"https:\/\/jcp.org\/en\/jsr\/detail?id=14\">\n+     * JSR 14: Add Generic Types To The Java&trade; Programming Language<\/a>\n+     * @see <a href=\"https:\/\/jcp.org\/en\/jsr\/detail?id=175\">\n+     * JSR 175: A Metadata Facility for the Java&trade; Programming Language<\/a>\n+     *\/\n+    RELEASE_5(49),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 6.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/maintenance\/jsr924\/index2.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE, Second Edition updated for Java SE 6<\/cite><\/a>\n+     *\/\n+    RELEASE_6(50),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 7.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 7 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_7(51),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 8.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 8 Edition<\/cite><\/a>\n+     * @see <a href=\"https:\/\/jcp.org\/en\/jsr\/detail?id=335\">\n+     * JSR 335: Lambda Expressions for the Java&trade; Programming Language<\/a>\n+     *\/\n+    RELEASE_8(52),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 9.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 9 Edition<\/cite><\/a>\n+     * @see <a href=\"https:\/\/jcp.org\/en\/jsr\/detail?id=376\">\n+     * JSR 376: Java&trade; Platform Module System<\/a>\n+     *\/\n+     RELEASE_9(53),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 10.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se10\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 10 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_10(54),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 11.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se11\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 11 Edition<\/cite><\/a>\n+     * @see <a href=\"https:\/\/openjdk.java.net\/jeps\/181\">\n+     * JEP 181: Nest-Based Access Control<\/a>\n+     *\/\n+    RELEASE_11(55),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 12.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se12\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 12 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_12(56),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 13.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se13\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 13 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_13(57),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 14.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se14\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 14 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_14(58),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 15.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se15\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 15 Edition<\/cite><\/a>\n+     * @see <a href=\"https:\/\/openjdk.java.net\/jeps\/371\">\n+     * JEP 371: Hidden Classes<\/a>\n+     *\/\n+    RELEASE_15(59),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 16.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se16\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 16 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_16(60),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 17.\n+     *\n+     * Additions in this release include sealed classes and\n+     * restoration of always-strict floating-point semantics.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se17\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 17 Edition<\/cite><\/a>\n+     * @see <a href=\"https:\/\/openjdk.java.net\/jeps\/306\">\n+     * JEP 306: Restore Always-Strict Floating-Point Semantics<\/a>\n+     * @see <a href=\"https:\/\/openjdk.java.net\/jeps\/409\">\n+     * JEP 409: Sealed Classes<\/a>\n+     *\/\n+    RELEASE_17(61),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 18.\n+     *\n+     * @see <a\n+     * href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se18\/html\/index.html\">\n+     * <cite>The Java Virtual Machine Specification, Java SE 18 Edition<\/cite><\/a>\n+     *\/\n+    RELEASE_18(62),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 19.\n+     *\/\n+    RELEASE_19(63),\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 20.\n+     *\/\n+    RELEASE_20(64);\n+\n+    \/\/ Note to maintainers: when adding constants for newer releases,\n+    \/\/ the implementation of latest() must be updated too.\n+\n+    private final int major;\n+\n+    private ClassFileFormatVersion(int major) {\n+        this.major = major;\n+    }\n+\n+    \/**\n+     * {@return the latest class file format version}\n+     *\/\n+    public static ClassFileFormatVersion latest() {\n+        return RELEASE_20;\n+    }\n+\n+    \/**\n+     * {@return the major class file version as an integer}\n+     * @jvms 4.1 The {@code ClassFile} Structure\n+     *\/\n+    public int major() {\n+        return major;\n+    }\n+\n+    \/**\n+     * {@return the latest class file format version that is usable\n+     * under the runtime version argument} If the runtime version's\n+     * {@linkplain Runtime.Version#feature() feature} is greater than\n+     * the feature of the {@linkplain #runtimeVersion() runtime\n+     * version} of the {@linkplain #latest() latest class file format\n+     * version}, an {@code IllegalArgumentException} is thrown.\n+     *\n+     * <p>Because the class file format versions of the Java platform\n+     * have so far followed a linear progression, only the feature\n+     * component of a runtime version is queried to determine the\n+     * mapping to a class file format version. If that linearity\n+     * changes in the future, other components of the runtime version\n+     * may influence the result.\n+     *\n+     * @apiNote\n+     * An expression to convert from a string value, for example\n+     * {@code \"17\"}, to the corresponding class file format version,\n+     * {@code RELEASE_17}, is:\n+     *\n+     * {@snippet lang=\"java\" :\n+     * ClassFileFormatVersion.valueOf(Runtime.Version.parse(\"17\"))}\n+     *\n+     * @param rv runtime version to map to a class file format version\n+     * @throws IllegalArgumentException if the feature of version\n+     * argument is greater than the feature of the platform version.\n+     *\/\n+    public static ClassFileFormatVersion valueOf(Runtime.Version rv) {\n+        \/\/ Could also implement this as a switch where a case was\n+        \/\/ added with each new release.\n+        return valueOf(\"RELEASE_\" + rv.feature());\n+    }\n+\n+    \/**\n+     * {@return the least runtime version that supports this class\n+     * file format version; otherwise {@code null}} The returned\n+     * runtime version has a {@linkplain Runtime.Version#feature()\n+     * feature} large enough to support this class file format version\n+     * and has no other elements set.\n+     *\n+     * Class file format versions greater than or equal to {@link\n+     * RELEASE_6} have non-{@code null} results.\n+     *\/\n+    public Runtime.Version runtimeVersion() {\n+        \/\/ Starting with Java SE 6, the leading digit was the primary\n+        \/\/ way of identifying the platform version.\n+        if (this.compareTo(RELEASE_6) >= 0) {\n+            return Runtime.Version.parse(Integer.toString(ordinal()));\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * {@return the latest class file format version whose major class\n+     * file version matches the argument}\n+     * @param major the major class file version as an integer\n+     * @throws IllegalArgumentException if the argument is outside of\n+     * the range of major class file versions\n+     *\/\n+    public static ClassFileFormatVersion fromMajor(int major) {\n+        if (major < 45  \/\/ RELEASE_0.major()\n+            || major > latest().major()) {\n+            throw new IllegalArgumentException(\"Out of range major class file vesion \"\n+                                               + major);\n+        }\n+        \/\/ RELEASE_0 and RELEASE_1 both have a major version of 45;\n+        \/\/ return RELEASE_1 for an argument of 45.\n+        return values()[major-44];\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ClassFileFormatVersion.java","additions":353,"deletions":0,"binary":false,"changes":353,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+ * @see java.lang.reflect.ClassFileFormatVersion\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,2 +69,1 @@\n-        \/\/ Class file version is stored like \"64.0\".\n-        int latestMajor = (int)Double.parseDouble(System.getProperty(\"java.class.version\"));\n+        int latestMajor = ClassFileFormatVersion.latest().major();\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/ClassFileVersionTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * Additionall, the access flags enum and synthetic cannot be\n+ * Additionally, the access flags enum and synthetic cannot be\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/FieldAccessFlagTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8289106\n+ * @summary Tests of AccessFlag.locations(ClassFileFormatVersion)\n+ *\/\n+\n+import java.lang.reflect.AccessFlag;\n+import static java.lang.reflect.AccessFlag.*;\n+import java.lang.reflect.ClassFileFormatVersion;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+\/*\n+ * There are several patterns of access flag applicability. First, an\n+ * access flag can be applied to the same set of locations for each\n+ * class file format version. This is \"invariant\" usage. Second, an\n+ * access flag can be defined for version N, therefore inapplicable\n+ * for earlier versions, and then applied to the same locations for\n+ * all subsequent versions. This is \"step\" usage. Finally, an access\n+ * flag to have a more complicated pattern, having multiple steps of\n+ * being allowed at more locations or even having locations removed if\n+ * the access flag is retired.\n+ *\n+ * List of access flags and how they are tested:\n+ *\n+ * PUBLIC       step\n+ * PRIVATE      step\n+ * PROTECTED    step\n+ * STATIC       step\n+ * FINAL        two-step\n+ * SUPER        invariant\n+ * OPEN         step\n+ * TRANSITIVE   step\n+ * SYNCHRONIZED invariant\n+ * STATIC_PHASE step\n+ * VOLATILE     invariant\n+ * BRIDGE       step\n+ * TRANSIENT    invariant\n+ * VARARGS      step\n+ * NATIVE       invariant\n+ * INTERFACE    step\n+ * ABSTRACT     step\n+ * STRICT       other\n+ * SYNTHETIC    other (three-step)\n+ * ANNOTATION   step\n+ * ENUM         step\n+ * MANDATED     two-step\n+ * MODULE       step\n+ *\/\n+\n+public class VersionedLocationsTest {\n+    public static void main(String... args) throws Exception {\n+        testInvariantAccessFlags();\n+        testStepFunctionAccessFlags();\n+        testTwoStepAccessFlags();\n+        testSynthetic();\n+        testStrict();\n+    }\n+\n+    \/**\n+     * Invariant access flags have the same set of locations for each\n+     * class file format version.\n+     *\/\n+    private static void testInvariantAccessFlags() {\n+        Set<AccessFlag> invariantAccessFlags =\n+            Set.of(SUPER, SYNCHRONIZED, VOLATILE, TRANSIENT, NATIVE);\n+        for(var accessFlag : invariantAccessFlags) {\n+            Set<AccessFlag.Location> expected = accessFlag.locations();\n+\n+            for(var cffv : ClassFileFormatVersion.values()) {\n+                compareLocations(accessFlag.locations(), accessFlag, cffv);\n+            }\n+        }\n+    }\n+\n+    private static void testStepFunctionAccessFlags() {\n+        StepFunctionTC[] testCases = {\n+            new StepFunctionTC(PUBLIC,\n+                               removeInnerClass(PUBLIC.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(PRIVATE,\n+                               removeInnerClass(PRIVATE.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(PROTECTED,\n+                               removeInnerClass(PROTECTED.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(STATIC,\n+                               removeInnerClass(STATIC.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(OPEN,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9),\n+\n+            new StepFunctionTC(TRANSITIVE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9),\n+\n+            new StepFunctionTC(STATIC_PHASE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9),\n+\n+            new StepFunctionTC(BRIDGE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(VARARGS,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(INTERFACE,\n+                               removeInnerClass(INTERFACE.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(ABSTRACT,\n+                               removeInnerClass(ABSTRACT.locations()),\n+                               ClassFileFormatVersion.RELEASE_1),\n+\n+            new StepFunctionTC(ANNOTATION,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(ENUM,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_5),\n+\n+            new StepFunctionTC(MODULE,\n+                               Set.of(),\n+                               ClassFileFormatVersion.RELEASE_9)\n+        };\n+\n+        for (var testCase : testCases) {\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                compareLocations(cffv.compareTo(testCase.transition()) >= 0 ?\n+                                 testCase.finalLocs() :\n+                                 testCase.initialLocs(),\n+                                 testCase.accessFlag, cffv);\n+            }\n+        }\n+    }\n+\n+    private static void compareLocations(Set<AccessFlag.Location> expected,\n+                                         AccessFlag accessFlag,\n+                                         ClassFileFormatVersion cffv) {\n+        var actual = accessFlag.locations(cffv);\n+        if (!expected.equals(actual)) {\n+            throw new RuntimeException(\"Unexpected locations for \" +\n+                                       accessFlag  + \" on \" + cffv + \"\\n\" +\n+                                       \"Expected \" + expected + \"; got \\t\" + actual);\n+        }\n+    }\n+\n+    private static Set<AccessFlag.Location> removeInnerClass(Set<AccessFlag.Location> locations) {\n+        var s = new HashSet<>(locations);\n+        s.remove(Location.INNER_CLASS);\n+        return s;\n+    }\n+\n+    private record StepFunctionTC(AccessFlag accessFlag,\n+                                  Set<AccessFlag.Location> initialLocs,\n+                                  ClassFileFormatVersion transition) {\n+\n+        public Set<AccessFlag.Location> finalLocs() {\n+            return accessFlag.locations();\n+        }\n+    }\n+\n+\n+    private record TwoStepFunctionTC(AccessFlag accessFlag,\n+                                     Set<AccessFlag.Location> initialLocs,\n+                                     ClassFileFormatVersion transition1,\n+                                     Set<AccessFlag.Location> firstLocs,\n+                                     ClassFileFormatVersion transition2) {\n+\n+        public Set<AccessFlag.Location> secondLocs() {\n+            return accessFlag.locations();\n+        }\n+    }\n+\n+    private static void testTwoStepAccessFlags() {\n+        TwoStepFunctionTC[] testCases = {\n+            new TwoStepFunctionTC(FINAL,\n+                                  Set.of(Location.CLASS, Location.FIELD, Location.METHOD),\n+                                  ClassFileFormatVersion.RELEASE_1,\n+                                  Set.of(Location.CLASS, Location.FIELD, Location.METHOD, Location.INNER_CLASS),\n+                                  ClassFileFormatVersion.RELEASE_8),\n+\n+            new TwoStepFunctionTC(MANDATED,\n+                                  Set.of(),\n+                                  ClassFileFormatVersion.RELEASE_8,\n+                                  Set.of(Location.METHOD_PARAMETER),\n+                                  ClassFileFormatVersion.RELEASE_9),\n+        };\n+\n+        for (var testCase : testCases) {\n+            for (var cffv : ClassFileFormatVersion.values()) {\n+                var transition1 = testCase.transition1();\n+                var transition2 = testCase.transition2();\n+                Set<AccessFlag.Location> expected;\n+                if (cffv.compareTo(transition1) < 0) {\n+                    expected = testCase.initialLocs();\n+                } else if (cffv.compareTo(transition1) >= 0 &&\n+                           cffv.compareTo(transition2) < 0) {\n+                    expected = testCase.firstLocs();\n+                } else { \/\/ cffv >= transition2\n+                    expected = testCase.secondLocs();\n+                }\n+\n+                compareLocations(expected, testCase.accessFlag(), cffv);\n+            }\n+        }\n+    }\n+\n+    private static void testSynthetic() {\n+        for (var cffv : ClassFileFormatVersion.values()) {\n+            Set<AccessFlag.Location> expected;\n+            if (cffv.compareTo(ClassFileFormatVersion.RELEASE_6) <= 0) {\n+                expected = Set.of();\n+            } else {\n+                expected =\n+                    switch(cffv) {\n+                        case RELEASE_7 -> Set.of(Location.CLASS, Location.FIELD,\n+                                                 Location.METHOD,\n+                                                 Location.INNER_CLASS);\n+                        case RELEASE_8 -> Set.of(Location.CLASS, Location.FIELD,\n+                                                 Location.METHOD,\n+                                                 Location.INNER_CLASS,\n+                                                 Location.METHOD_PARAMETER);\n+                        default        -> SYNTHETIC.locations();\n+                    };\n+            }\n+        compareLocations(expected, SYNTHETIC, cffv);\n+        }\n+    }\n+\n+    private static void testStrict() {\n+        for (var cffv : ClassFileFormatVersion.values()) {\n+            Set<AccessFlag.Location> expected =\n+                (cffv.compareTo(ClassFileFormatVersion.RELEASE_2)  >= 0 &&\n+                 cffv.compareTo(ClassFileFormatVersion.RELEASE_16) <= 0) ?\n+                Set.of(Location.METHOD) :\n+                Set.of();\n+            compareLocations(expected, STRICT, cffv);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/AccessFlag\/VersionedLocationsTest.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"}]}