{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -457,0 +458,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -117,38 +118,0 @@\n-    \/*\n-     * This function is used by IntegerPolynomial.setProduct(SmallValue v) to\n-     * multiply by a small constant (i.e. (int) 1,2,3,4). Instead of doing a\n-     * montgomery conversion followed by a montgomery multiplication, just use\n-     * the spare top (64-BITS_PER_LIMB) bits to multiply by a constant. (See [1]\n-     * Section 4 )\n-     *\n-     * Will return an unreduced value\n-     *\/\n-    @Override\n-    protected void multByInt(long[] a, long b) {\n-        assert (b < (1 << BITS_PER_LIMB));\n-        if (b == 2) {\n-            for (int i = 0; i < NUM_LIMBS; i++) {\n-                a[i] <<= 1;\n-            }\n-            reducePositive(a);\n-        } else if (b == 3) {\n-            for (int i = 0; i < NUM_LIMBS; i++) {\n-                a[i] *= 3;\n-            }\n-            reducePositive(a);\n-            reducePositive(a);\n-        } else if (b == 4) {\n-            for (int i = 0; i < NUM_LIMBS; i++) {\n-                a[i] <<= 2;\n-            }\n-            reducePositive(a);\n-            reducePositive(a);\n-            reducePositive(a);\n-        } else {\n-            for (int i = 0; i < NUM_LIMBS; i++) {\n-                a[i] *= b;\n-            }\n-            reduce(a);\n-        }\n-    }\n-\n@@ -204,0 +167,1 @@\n+    @ForceInline\n@@ -568,0 +532,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":3,"deletions":38,"binary":false,"changes":41,"status":"modified"}]}