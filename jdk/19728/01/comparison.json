{"files":[{"patch":"@@ -781,1 +781,1 @@\n-        result.appendLine(\"protected int mult(long[] a, long[] b, long[] r) {\");\n+        result.appendLine(\"protected void mult(long[] a, long[] b, long[] r) {\");\n@@ -807,3 +807,0 @@\n-        result.appendIndent();\n-        result.append(\"return 0;\");\n-        result.appendLine();\n@@ -839,1 +836,1 @@\n-        result.appendLine(\"protected int square(long[] a, long[] r) {\");\n+        result.appendLine(\"protected void square(long[] a, long[] r) {\");\n@@ -880,3 +877,0 @@\n-        result.appendIndent();\n-        result.append(\"return 0;\");\n-        result.appendLine();\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -252,1 +252,0 @@\n-  __ mov64(rax, 0x1); \/\/ Return 1 (Fig. 5, Step 6 [1] skipped in montgomeryMultiply)\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -532,2 +532,2 @@\n-  do_name(intPolyMult_name, \"mult\")                                                                                     \\\n-  do_signature(intPolyMult_signature, \"([J[J[J)I\")                                                                      \\\n+  do_name(intPolyMult_name, \"multImpl\")                                                                                     \\\n+  do_signature(intPolyMult_signature, \"([J[J[J)V\")                                                                      \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7557,2 +7557,0 @@\n-  Node* result = _gvn.transform(new ProjNode(call, TypeFunc::Parms));\n-  set_result(result);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1417,2 +1417,2 @@\n-  fields[TypeFunc::Parms + 0] = TypeInt::INT; \/\/ carry bits in output\n-  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);\n+  fields[TypeFunc::Parms + 0] = NULL;\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    protected int multByInt(long[] a, long b) {\n+    protected void multByInt(long[] a, long b) {\n@@ -98,1 +98,0 @@\n-        return 0;\n@@ -107,1 +106,1 @@\n-    protected abstract int mult(long[] a, long[] b, long[] r);\n+    protected abstract void mult(long[] a, long[] b, long[] r);\n@@ -115,1 +114,1 @@\n-    protected abstract int square(long[] a, long[] r);\n+    protected abstract void square(long[] a, long[] r);\n@@ -625,2 +624,2 @@\n-            int numAdds = mult(limbs, b.limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, numAdds);\n+            mult(limbs, b.limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, 0);\n@@ -638,2 +637,2 @@\n-            int numAdds = IntegerPolynomial.this.square(limbs, newLimbs);\n-            return new ImmutableElement(newLimbs, numAdds);\n+            IntegerPolynomial.this.square(limbs, newLimbs);\n+            return new ImmutableElement(newLimbs, 0);\n@@ -754,1 +753,2 @@\n-            numAdds = mult(limbs, b.limbs, limbs);\n+            mult(limbs, b.limbs, limbs);\n+            numAdds = 0;\n@@ -767,1 +767,2 @@\n-            numAdds += multByInt(limbs, value);\n+            multByInt(limbs, value);\n+            numAdds = 0;\n@@ -827,1 +828,2 @@\n-            numAdds = IntegerPolynomial.this.square(limbs, limbs);\n+            IntegerPolynomial.this.square(limbs, limbs);\n+            numAdds = 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    protected void mult(long[] a, long[] b, long[] r) {\n@@ -76,1 +76,0 @@\n-        return 0;\n@@ -103,1 +102,1 @@\n-    protected int square(long[] a, long[] r) {\n+    protected void square(long[] a, long[] r) {\n@@ -126,1 +125,0 @@\n-        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial1305.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    protected void mult(long[] a, long[] b, long[] r) {\n@@ -139,1 +139,0 @@\n-        return 0;\n@@ -192,1 +191,1 @@\n-    protected int square(long[] a, long[] r) {\n+    protected void square(long[] a, long[] r) {\n@@ -203,1 +202,0 @@\n-        return 0;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomialModBinP.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -106,2 +107,2 @@\n-        int numAdds = mult(vLimbs, h, montLimbs);\n-        return new ImmutableElement(montLimbs, numAdds);\n+        mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, 0);\n@@ -117,18 +118,0 @@\n-    \/*\n-     * This function is used by IntegerPolynomial.setProduct(SmallValue v) to\n-     * multiply by a small constant (i.e. (int) 1,2,3,4). Instead of doing a\n-     * montgomery conversion followed by a montgomery multiplication, just use\n-     * the spare top (64-BITS_PER_LIMB) bits to multiply by a constant. (See [1]\n-     * Section 4 )\n-     *\n-     * Will return an unreduced value\n-     *\/\n-    @Override\n-    protected int multByInt(long[] a, long b) {\n-        assert (b < (1 << BITS_PER_LIMB));\n-        for (int i = 0; i < a.length; i++) {\n-            a[i] *= b;\n-        }\n-        return (int) (b - 1);\n-    }\n-\n@@ -166,2 +149,2 @@\n-    protected int square(long[] a, long[] r) {\n-        return mult(a, a, r);\n+    protected void square(long[] a, long[] r) {\n+        mult(a, a, r);\n@@ -170,0 +153,1 @@\n+\n@@ -177,0 +161,7 @@\n+    @Override\n+    protected void mult(long[] a, long[] b, long[] r) {\n+        multImpl(a, b, r);\n+        reducePositive(r);\n+    }\n+\n+    @ForceInline\n@@ -178,1 +169,1 @@\n-    protected int mult(long[] a, long[] b, long[] r) {\n+    private void multImpl(long[] a, long[] b, long[] r) {\n@@ -411,30 +402,10 @@\n-        c6 += d2 + dd1 + (c5 >>> BITS_PER_LIMB);\n-        c7 += d3 + dd2 + (c6 >>> BITS_PER_LIMB);\n-        c8 += d4 + dd3 + (c7 >>> BITS_PER_LIMB);\n-        c9 = dd4 + (c8 >>> BITS_PER_LIMB);\n-\n-        c5 &= LIMB_MASK;\n-        c6 &= LIMB_MASK;\n-        c7 &= LIMB_MASK;\n-        c8 &= LIMB_MASK;\n-\n-        \/\/ At this point, the result could overflow by one modulus.\n-        c0 = c5 - modulus[0];\n-        c1 = c6 - modulus[1] + (c0 >> BITS_PER_LIMB);\n-        c0 &= LIMB_MASK;\n-        c2 = c7 - modulus[2] + (c1 >> BITS_PER_LIMB);\n-        c1 &= LIMB_MASK;\n-        c3 = c8 - modulus[3] + (c2 >> BITS_PER_LIMB);\n-        c2 &= LIMB_MASK;\n-        c4 = c9 - modulus[4] + (c3 >> BITS_PER_LIMB);\n-        c3 &= LIMB_MASK;\n-\n-        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n-\n-        r[0] = ((c5 & mask) | (c0 & ~mask));\n-        r[1] = ((c6 & mask) | (c1 & ~mask));\n-        r[2] = ((c7 & mask) | (c2 & ~mask));\n-        r[3] = ((c8 & mask) | (c3 & ~mask));\n-        r[4] = ((c9 & mask) | (c4 & ~mask));\n-\n-        return 0;\n+        c6 += d2 + dd1;\n+        c7 += d3 + dd2;\n+        c8 += d4 + dd3;\n+        c9 = dd4;\n+\n+        r[0] = c5;\n+        r[1] = c6;\n+        r[2] = c7;\n+        r[3] = c8;\n+        r[4] = c9;\n@@ -519,2 +490,2 @@\n-        int numAdds = mult(vLimbs, h, montLimbs);\n-        return new ImmutableElement(montLimbs, numAdds);\n+        mult(vLimbs, h, montLimbs);\n+        return new ImmutableElement(montLimbs, 0);\n@@ -559,0 +530,23 @@\n+\n+    \/\/ Used when limbs a could overflow by one modulus.\n+    @ForceInline\n+    protected void reducePositive(long[] a) {\n+        long aa0 = a[0];\n+        long aa1 = a[1] + (aa0>>BITS_PER_LIMB);\n+        long aa2 = a[2] + (aa1>>BITS_PER_LIMB);\n+        long aa3 = a[3] + (aa2>>BITS_PER_LIMB);\n+        long aa4 = a[4] + (aa3>>BITS_PER_LIMB);\n+\n+        long c0 = a[0] - modulus[0];\n+        long c1 = a[1] - modulus[1] + (c0 >> BITS_PER_LIMB);\n+        long c2 = a[2] - modulus[2] + (c1 >> BITS_PER_LIMB);\n+        long c3 = a[3] - modulus[3] + (c2 >> BITS_PER_LIMB);\n+        long c4 = a[4] - modulus[4] + (c3 >> BITS_PER_LIMB);\n+        long mask = c4 >> BITS_PER_LIMB; \/\/ Signed shift!\n+\n+        a[0] = ((aa0 & mask) | (c0 & ~mask)) & LIMB_MASK;\n+        a[1] = ((aa1 & mask) | (c1 & ~mask)) & LIMB_MASK;\n+        a[2] = ((aa2 & mask) | (c2 & ~mask)) & LIMB_MASK;\n+        a[3] = ((aa3 & mask) | (c3 & ~mask)) & LIMB_MASK;\n+        a[4] = ((aa4 & mask) | (c4 & ~mask));\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/MontgomeryIntegerPolynomialP256.java","additions":49,"deletions":55,"binary":false,"changes":104,"status":"modified"}]}