{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -567,1 +567,0 @@\n-  bool    seems_stable_comparison() const;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1357,15 +1357,0 @@\n-\/\/ True if the comparison seems to be the kind that will not change its\n-\/\/ statistics from true to false.  See comments in adjust_map_after_if.\n-\/\/ This question is only asked along paths which are already\n-\/\/ classified as untaken (by seems_never_taken), so really,\n-\/\/ if a path is never taken, its controlling comparison is\n-\/\/ already acting in a stable fashion.  If the comparison\n-\/\/ seems stable, we will put an expensive uncommon trap\n-\/\/ on the untaken path.\n-bool Parse::seems_stable_comparison() const {\n-  if (C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if)) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -1575,1 +1560,2 @@\n-  return (seems_never_taken(prob) && seems_stable_comparison());\n+  return seems_never_taken(prob) &&\n+         !C->too_many_traps(method(), bci(), Deoptimization::Reason_unstable_if);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"}]}