{"files":[{"patch":"@@ -38,0 +38,2 @@\n+import static jdk.incubator.vector.Float16Consts.EXP_BIAS;\n+import static jdk.incubator.vector.Float16Consts.SIGNIFICAND_WIDTH;\n@@ -98,1 +100,1 @@\n-\/\/ Currently Float16 is a value-based class and in future it is\n+\/\/ Currently Float16 is a value-based class and in the future it is\n@@ -105,1 +107,5 @@\n-    \/** @serial *\/\n+\n+    \/**\n+     * Primitive {@code short} field to hold the bits of the {@code Float16}.\n+     * @serial\n+     *\/\n@@ -107,0 +113,1 @@\n+\n@@ -110,1 +117,3 @@\n-    \/\/ IEEEremainder \/ remainder operator remainder\n+    \/\/ IEEEremainder and separate % operator remainder (which are\n+    \/\/ defined to use different rounding modes, see JLS sections 15.4\n+    \/\/ and 15.17.3).\n@@ -150,0 +159,3 @@\n+    \/**\n+     * A constant holding a zero (0.0) of type {@code Float16}.\n+     *\/\n@@ -152,0 +164,3 @@\n+    \/**\n+     * A constant holding a one (1.0) of type {@code Float16}.\n+     *\/\n@@ -319,1 +334,1 @@\n-        if (value <= -65_520L) {  \/\/ -(Float16.MAX_VALUE + Float16.ulp(Float16.MAX_VALUE) \/ 2)\n+        if (value <= -65_520L) {  \/\/ -(MAX_VALUE + ulp(MAX_VALUE) \/ 2)\n@@ -322,1 +337,1 @@\n-            if (value >= 65_520L) {  \/\/ Float16.MAX_VALUE + Float16.ulp(Float16.MAX_VALUE) \/ 2\n+            if (value >= 65_520L) {  \/\/ MAX_VALUE + ulp(MAX_VALUE) \/ 2\n@@ -430,1 +445,0 @@\n-        \/\/ Exponent bias adjust in the representation is equal to MAX_EXPONENT.\n@@ -432,1 +446,1 @@\n-                                   ( ((exp + MAX_EXPONENT) << (PRECISION - 1)) + signif_bits ) ));\n+                                   ( ((exp + EXP_BIAS) << (PRECISION - 1)) + signif_bits) ));\n@@ -471,1 +485,1 @@\n-            || Math.abs(trialResult) > (65504.0 + 32.0) || \/\/ Float.MAX_VALUE + ulp(MAX_VALUE),\n+            || Math.abs(trialResult) > (65504.0 + 32.0) || \/\/ MAX_VALUE + ulp(MAX_VALUE),\n@@ -902,1 +916,1 @@\n-        Float16 f16 = isNaN(value) ? Float16.NaN : value;\n+        Float16 f16 = isNaN(value) ? NaN : value;\n@@ -949,1 +963,1 @@\n-            return Float16.NaN.value;\n+            return NaN.value;\n@@ -1534,2 +1548,2 @@\n-        int bin16ExpBits     = 0x0000_7c00 & bits;     \/\/ Five exponent bits.\n-        return (bin16ExpBits >> (PRECISION - 1)) - 15;\n+        int bin16ExpBits = EXP_BIT_MASK & bits; \/\/ Five exponent bits.\n+        return (bin16ExpBits >> (PRECISION - 1)) - EXP_BIAS;\n@@ -1566,2 +1580,2 @@\n-        case MAX_EXPONENT + 1 -> abs(f16);          \/\/ NaN or infinity\n-        case MIN_EXPONENT - 1 -> Float16.MIN_VALUE; \/\/ zero or subnormal\n+        case MAX_EXPONENT + 1 -> abs(f16);  \/\/ NaN or infinity\n+        case MIN_EXPONENT - 1 -> MIN_VALUE; \/\/ zero or subnormal\n@@ -1569,1 +1583,1 @@\n-            assert exp <= MAX_EXPONENT && exp >= MIN_EXPONENT;\n+            assert exp <= MAX_EXPONENT && exp >= MIN_EXPONENT: \"Out of range exponent\";\n@@ -1690,2 +1704,1 @@\n-        final int MAX_SCALE = Float16.MAX_EXPONENT + -Float16.MIN_EXPONENT +\n-                Float16Consts.SIGNIFICAND_WIDTH + 1;\n+        final int MAX_SCALE = MAX_EXPONENT + -MIN_EXPONENT + SIGNIFICAND_WIDTH + 1;\n@@ -1728,3 +1741,2 @@\n-        return shortBitsToFloat16((short) ((float16ToRawShortBits(sign) & SIGN_BIT_MASK) |\n-                                           (float16ToRawShortBits(magnitude) &\n-                                            (EXP_BIT_MASK | SIGNIF_BIT_MASK) )));\n+        return shortBitsToFloat16((short)((float16ToRawShortBits(sign)      & SIGN_BIT_MASK) |\n+                                          (float16ToRawShortBits(magnitude) & MAG_BIT_MASK)));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float16.java","additions":32,"deletions":20,"binary":false,"changes":52,"status":"modified"}]}