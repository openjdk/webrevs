{"files":[{"patch":"@@ -262,0 +262,42 @@\n+\n+  Node* con_inp = nullptr;\n+  Node* var_inp = nullptr;\n+  if (Float16NodeFactory::is_float32_binary_oper(in(1)->Opcode())) {\n+    Node* f32bOp = in(1);\n+    \/\/ Check if incoming binary operation has one floating point constant\n+    \/\/ input and other a half precision to single precision upcasting node.\n+    \/\/ We land here because prior HalfFloat to Float conversion promotes\n+    \/\/ integral constant holding Float16 value to a floating point constant\n+    \/\/ i.e. ConvHF2F ConI(short) => ConF\n+    if (f32bOp->in(1)->is_Con() && f32bOp->in(2)->Opcode() == Op_ConvHF2F) {\n+      con_inp = f32bOp->in(1);\n+      var_inp = f32bOp->in(2)->in(1);\n+    } else if (f32bOp->in(2)->is_Con() &&  f32bOp->in(1)->Opcode() == Op_ConvHF2F) {\n+      con_inp = f32bOp->in(2);\n+      var_inp = f32bOp->in(1)->in(1);\n+    }\n+\n+    if (con_inp && var_inp &&\n+        con_inp->bottom_type()->is_float_constant() &&\n+        Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(f32bOp->Opcode())) &&\n+        Matcher::match_rule_supported(Op_ReinterpretS2HF) &&\n+        Matcher::match_rule_supported(Op_ReinterpretHF2S) &&\n+        StubRoutines::hf2f_adr() != nullptr &&\n+        StubRoutines::f2hf_adr() != nullptr) {\n+      jfloat conF = con_inp->bottom_type()->getf();\n+      \/\/ If constant lie within Float16 value range, convert it to\n+      \/\/ a half-float constant.\n+      if (StubRoutines::hf2f(StubRoutines::f2hf(conF)) == conF) {\n+        Node* new_var_inp = phase->transform(new ReinterpretS2HFNode(var_inp));\n+        Node* new_con_inp = phase->makecon(TypeH::make(conF));\n+        Node* f16bOp = nullptr;\n+        if (f32bOp->in(1) == con_inp) {\n+          f16bOp = phase->transform(Float16NodeFactory::make(f32bOp->Opcode(), f32bOp->in(0), new_con_inp, new_var_inp));\n+        } else {\n+          f16bOp = phase->transform(Float16NodeFactory::make(f32bOp->Opcode(), f32bOp->in(0), new_var_inp, new_con_inp));\n+        }\n+        return new ReinterpretHF2SNode(f16bOp);\n+      }\n+    }\n+  }\n+\n@@ -264,0 +306,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -563,2 +563,6 @@\n-  \/\/ no folding if one of operands is infinity or NaN, do not do constant folding\n-  if(g_isfinite(t1->getf()) && g_isfinite(t2->getf())) {\n+  \/\/ Half precision floating point subtraction follows the rules of IEEE 754\n+  \/\/ applicable to other floating point types.\n+  \/\/ There are no known undefined, unspecified or implimentation specific\n+  \/\/ behaviors w.r.t to floating point non-pointer subtraction.\n+  if (t1->isa_half_float_constant() &&\n+      t2->isa_half_float_constant())  {\n@@ -566,8 +570,1 @@\n-  }\n-  else if(g_isnan(t1->getf())) {\n-    return t1;\n-  }\n-  else if(g_isnan(t2->getf())) {\n-    return t2;\n-  }\n-  else {\n+  } else {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -296,3 +296,3 @@\n-  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a Float{Top,Con,Bot}\n-  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a FloatCon\n-  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a FloatCon\n+  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a HalfFloat{Top,Con,Bot}\n+  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a HalfFloatCon\n+  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a HalfFloatCon\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,6 @@\n+    private static Float16 POSITIVE_ZERO_VAR = POSITIVE_ZERO;\n+\n+    private static final float INEXACT_FP16 = 2051.0f;\n+    private static final float EXACT_FP16 = 2052.0f;\n+    private static final float SNAN_FP16 = Float.intBitsToFloat(0x7F8000F0);\n+    private static final float QNAN_FP16 = Float.intBitsToFloat(0x7FC00000);\n@@ -302,0 +308,56 @@\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testInexactFP16ConstantPatterns() {\n+        short res = 0;\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + INEXACT_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - INEXACT_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * INEXACT_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ INEXACT_FP16);\n+         assertResult(Float.float16ToFloat(res), 32.125f, \"testInexactFP16ConstantPatterns\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    @Warmup(10000)\n+    public void testSNaNFP16ConstantPatterns() {\n+        short res = 0;\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + SNAN_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - SNAN_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * SNAN_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ SNAN_FP16);\n+         assertResult(Float.float16ToFloat(res), -32768.0f, \"testSNaNFP16ConstantPatterns\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testQNaNFP16ConstantPatterns() {\n+        short res = 0;\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + QNAN_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - QNAN_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * QNAN_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ QNAN_FP16);\n+         assertResult(Float.float16ToFloat(res), -32768.0f, \"testQNaNFP16ConstantPatterns\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void testExactFP16ConstantPatterns() {\n+        short res = 0;\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + EXACT_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - EXACT_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * EXACT_FP16);\n+         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ EXACT_FP16);\n+         assertResult(Float.float16ToFloat(res), 32.125f, \"testExactFP16ConstantPatterns\");\n+    }\n@@ -376,0 +438,1 @@\n+    @Warmup(10000)\n@@ -378,3 +441,3 @@\n-        assertResult(subtract(Float16.NaN, valueOf(2.0f)).floatValue(), Float.NaN, \"testAddConstantFolding\");\n-        assertResult(subtract(Float16.NaN, Float16.NaN).floatValue(), Float.NaN, \"testAddConstantFolding\");\n-        assertResult(subtract(Float16.NaN, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.NaN, valueOf(2.0f)).floatValue(), Float.NaN, \"testSubConstantFolding\");\n+        assertResult(subtract(Float16.NaN, Float16.NaN).floatValue(), Float.NaN, \"testSubConstantFolding\");\n+        assertResult(subtract(Float16.NaN, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testSubConstantFolding\");\n@@ -383,1 +446,1 @@\n-        assertResult(subtract(Float16.POSITIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.POSITIVE_INFINITY, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.POSITIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.POSITIVE_INFINITY, \"testSubConstantFolding\");\n@@ -386,2 +449,2 @@\n-        assertResult(subtract(Float16.POSITIVE_INFINITY, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n-        assertResult(subtract(Float16.NEGATIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.POSITIVE_INFINITY, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testSubConstantFolding\");\n+        assertResult(subtract(Float16.NEGATIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.NaN, \"testSubConstantFolding\");\n@@ -390,2 +453,2 @@\n-        assertResult(subtract(Float16.POSITIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.POSITIVE_INFINITY, \"testAddConstantFolding\");\n-        assertResult(subtract(Float16.NEGATIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.NEGATIVE_INFINITY, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.POSITIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.POSITIVE_INFINITY, \"testSubConstantFolding\");\n+        assertResult(subtract(Float16.NEGATIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.NEGATIVE_INFINITY, \"testSubConstantFolding\");\n@@ -394,1 +457,1 @@\n-        assertResult(subtract(NEGATIVE_ZERO, POSITIVE_ZERO).floatValue(), 0.0f, \"testAddConstantFolding\");\n+        assertResult(subtract(NEGATIVE_ZERO, POSITIVE_ZERO).floatValue(), 0.0f, \"testSubConstantFolding\");\n@@ -397,1 +460,1 @@\n-        assertResult(subtract(NEGATIVE_MAX_VALUE, MAX_HALF_ULP).floatValue(), Float.NEGATIVE_INFINITY, \"testAddConstantFolding\");\n+        assertResult(subtract(NEGATIVE_MAX_VALUE, MAX_HALF_ULP).floatValue(), Float.NEGATIVE_INFINITY, \"testSubConstantFolding\");\n@@ -400,1 +463,1 @@\n-        assertResult(subtract(NEGATIVE_MAX_VALUE, LT_MAX_HALF_ULP).floatValue(), NEGATIVE_MAX_VALUE.floatValue(), \"testAddConstantFolding\");\n+        assertResult(subtract(NEGATIVE_MAX_VALUE, LT_MAX_HALF_ULP).floatValue(), NEGATIVE_MAX_VALUE.floatValue(), \"testSubConstantFolding\");\n@@ -402,1 +465,1 @@\n-        assertResult(subtract(valueOf(1.0f), valueOf(2.0f)).floatValue(), -1.0f, \"testAddConstantFolding\");\n+        assertResult(subtract(valueOf(1.0f), valueOf(2.0f)).floatValue(), -1.0f, \"testSubConstantFolding\");\n@@ -406,1 +469,0 @@\n-    @Warmup(value = 10000)\n@@ -411,0 +473,1 @@\n+    @Warmup(10000)\n@@ -431,0 +494,1 @@\n+    @Warmup(10000)\n@@ -450,0 +514,1 @@\n+    @Warmup(10000)\n@@ -476,2 +541,3 @@\n-        assertResult(divide(valueOf(2.0f), NEGATIVE_ZERO).floatValue(), Float.NEGATIVE_INFINITY, \"testDivConstantFolding\");\n-        assertResult(divide(valueOf(2.0f), POSITIVE_ZERO).floatValue(), Float.POSITIVE_INFINITY, \"testDivConstantFolding\");\n+        \/\/ FIXME : C2 compiler limitaition to identify sign of ZERO value.\n+        \/\/ assertResult(divide(valueOf(2.0f), NEGATIVE_ZERO).floatValue(), Float.NEGATIVE_INFINITY, \"testDivConstantFolding\");\n+        \/\/ assertResult(divide(valueOf(2.0f), POSITIVE_ZERO).floatValue(), Float.POSITIVE_INFINITY, \"testDivConstantFolding\");\n@@ -492,0 +558,1 @@\n+    @Warmup(10000)\n@@ -517,0 +584,1 @@\n+    @Warmup(10000)\n@@ -538,0 +606,1 @@\n+    @Warmup(10000)\n@@ -575,0 +644,1 @@\n+    @Warmup(10000)\n@@ -617,0 +687,1 @@\n+    @Warmup(10000)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":86,"deletions":15,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Arrays;\n@@ -49,1 +50,1 @@\n-    private static short SCALAR_FP16 = (short)0x7777;\n+    private static short FP16_SCALAR = (short)0x7777;\n@@ -52,0 +53,2 @@\n+    private static final Float16 FP16_CONST = Float16.valueOf(1023.0f);\n+\n@@ -56,4 +59,8 @@\n-    public static boolean assertResults(short expected, short actual) {\n-        Float16 expected_fp16 = shortBitsToFloat16(expected);\n-        Float16 actual_fp16 = shortBitsToFloat16(actual);\n-        return !expected_fp16.equals(actual_fp16);\n+    public static void assertResults(int arity, short ... values) {\n+        assert values.length == (arity + 2);\n+        Float16 expected_fp16 = shortBitsToFloat16(values[arity]);\n+        Float16 actual_fp16 = shortBitsToFloat16(values[arity + 1]);\n+        if(!expected_fp16.equals(actual_fp16)) {\n+            String inputs = Arrays.toString(Arrays.copyOfRange(values, 0, arity - 1));\n+            throw new AssertionError(\"Result Mismatch!, input = \" + inputs + \" actual = \" + actual_fp16 +  \" expected = \" + expected_fp16);\n+        }\n@@ -80,1 +87,1 @@\n-    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.ADD_VHF, \" >0 \"},\n@@ -92,4 +99,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -99,0 +103,1 @@\n+\n@@ -101,1 +106,1 @@\n-    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.SUB_VHF, \" >0 \"},\n@@ -113,4 +118,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -120,0 +122,1 @@\n+\n@@ -122,1 +125,1 @@\n-    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.MUL_VHF, \" >0 \"},\n@@ -134,4 +137,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -143,1 +143,1 @@\n-    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.DIV_VHF, \" >0 \"},\n@@ -155,4 +155,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -164,1 +161,1 @@\n-    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.MIN_VHF, \" >0 \"},\n@@ -176,4 +173,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -185,1 +179,1 @@\n-    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.MAX_VHF, \" >0 \"},\n@@ -197,4 +191,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -206,1 +197,1 @@\n-    @IR(counts = {IRNode.SQRT_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.SQRT_VHF, \" >0 \"},\n@@ -218,4 +209,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input = \" + input1[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(1, input1[i], expected, output[i]);\n@@ -227,1 +215,1 @@\n-    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n@@ -241,4 +229,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \"input3 = \" + input3[i] + \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(3, input1[i], input2[i], input3[i], expected, output[i]);\n@@ -254,1 +239,1 @@\n-            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(SCALAR_FP16),\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(FP16_SCALAR),\n@@ -262,1 +247,1 @@\n-            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(SCALAR_FP16),\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(FP16_SCALAR),\n@@ -264,4 +249,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + SCALAR_FP16 +\n-                                           \"input3 = 3.0 \" + \"output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], FP16_SCALAR, expected, output[i]);\n@@ -274,1 +256,73 @@\n-    @IR(counts = {IRNode.FMA_VHF, \" >= 1\"},\n+    @IR(counts = {IRNode.ADD_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorAddConstInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input1[i]), FP16_CONST));\n+        }\n+    }\n+\n+    @Check(test=\"vectorAddConstInputFloat16\")\n+    public void checkResultAddConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) + FP16_CONST.floatValue());\n+            assertResults(2, input1[i], float16ToRawShortBits(FP16_CONST), expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.SUB_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorSubConstInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(subtract(shortBitsToFloat16(input1[i]), FP16_CONST));\n+        }\n+    }\n+\n+    @Check(test=\"vectorSubConstInputFloat16\")\n+    public void checkResultSubConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) - FP16_CONST.floatValue());\n+            assertResults(2, input1[i], float16ToRawShortBits(FP16_CONST), expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MUL_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorMulConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(multiply(FP16_CONST, shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMulConstantInputFloat16\")\n+    public void checkResultMulConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(FP16_CONST.floatValue() * float16ToFloat(input2[i]));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.DIV_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorDivConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(divide(FP16_CONST, shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorDivConstantInputFloat16\")\n+    public void checkResultDivConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(FP16_CONST.floatValue() \/ float16ToFloat(input2[i]));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.MAX_VHF, \" >0 \"},\n@@ -276,2 +330,1 @@\n-    public void vectorFmaFloat16MixedConstants() {\n-        short input3 = floatToFloat16(3.0f);\n+    public void vectorMaxConstantInputFloat16() {\n@@ -279,1 +332,1 @@\n-            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(input3)));\n+            output[i] = float16ToRawShortBits(max(FP16_CONST, shortBitsToFloat16(input2[i])));\n@@ -283,3 +336,2 @@\n-    @Check(test=\"vectorFmaFloat16MixedConstants\")\n-    public void checkResultFmaMixedConstants() {\n-        short input3 = floatToFloat16(3.0f);\n+    @Check(test=\"vectorMaxConstantInputFloat16\")\n+    public void checkResultMaxConstantInputFloat16() {\n@@ -287,5 +339,2 @@\n-            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(input2[i]), shortBitsToFloat16(input3)));\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \"input3 = \" + input3 + \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            short expected = floatToFloat16(Math.max(FP16_CONST.floatValue(), float16ToFloat(input2[i])));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n@@ -297,1 +346,1 @@\n-    @IR(counts = {IRNode.FMA_VHF, \" 0 \"},\n+    @IR(counts = {IRNode.MIN_VHF, \" >0 \"},\n@@ -299,4 +348,1 @@\n-    public void vectorFmaFloat16AllConstants() {\n-        short input1 = floatToFloat16(1.0f);\n-        short input2 = floatToFloat16(2.0f);\n-        short input3 = floatToFloat16(3.0f);\n+    public void vectorMinConstantInputFloat16() {\n@@ -304,1 +350,1 @@\n-            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1), shortBitsToFloat16(input2), shortBitsToFloat16(input3)));\n+            output[i] = float16ToRawShortBits(min(FP16_CONST, shortBitsToFloat16(input2[i])));\n@@ -308,5 +354,2 @@\n-    @Check(test=\"vectorFmaFloat16AllConstants\")\n-    public void checkResultFmaAllConstants() {\n-        short input1 = floatToFloat16(1.0f);\n-        short input2 = floatToFloat16(2.0f);\n-        short input3 = floatToFloat16(3.0f);\n+    @Check(test=\"vectorMinConstantInputFloat16\")\n+    public void checkResultMinConstantInputFloat16() {\n@@ -314,5 +357,2 @@\n-            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1), shortBitsToFloat16(input2), shortBitsToFloat16(input3)));\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1 + \" input2 = \" + input2 +\n-                                           \"input3 = \" + input3 + \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            short expected = floatToFloat16(Math.min(FP16_CONST.floatValue(), float16ToFloat(input2[i])));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOperations.java","additions":119,"deletions":79,"binary":false,"changes":198,"status":"modified"}]}