{"files":[{"patch":"@@ -262,0 +262,59 @@\n+\n+  \/\/ Detects following ideal graph pattern\n+  \/\/      ConvF2HF(binopF(conF, ConvHF2F(varS))) =>\n+  \/\/              ReinterpretHF2SNode(binopHF(conHF, ReinterpretS2HFNode(varS)))\n+  Node* conF = nullptr;\n+  Node* varS = nullptr;\n+  if (Float16NodeFactory::is_float32_binary_oper(in(1)->Opcode())) {\n+    Node* binopF = in(1);\n+    \/\/ Check if incoming binary operation has one floating point constant\n+    \/\/ input and other a half precision to single precision upcasting node.\n+    \/\/ We land here because prior HalfFloat to Float conversion promotes\n+    \/\/ integral constant holding Float16 value to a floating point constant\n+    \/\/ i.e. ConvHF2F ConI(short) => ConF\n+    if (binopF->in(1)->is_Con() && binopF->in(2)->Opcode() == Op_ConvHF2F) {\n+      conF = binopF->in(1);\n+      varS = binopF->in(2)->in(1);\n+    } else if (binopF->in(2)->is_Con() &&  binopF->in(1)->Opcode() == Op_ConvHF2F) {\n+      conF = binopF->in(2);\n+      varS = binopF->in(1)->in(1);\n+    }\n+\n+    if (conF != nullptr &&\n+        varS != nullptr &&\n+        conF->bottom_type()->is_float_constant() &&\n+        Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(binopF->Opcode())) &&\n+        Matcher::match_rule_supported(Op_ReinterpretS2HF) &&\n+        Matcher::match_rule_supported(Op_ReinterpretHF2S) &&\n+        StubRoutines::hf2f_adr() != nullptr &&\n+        StubRoutines::f2hf_adr() != nullptr) {\n+      jfloat con = conF->bottom_type()->getf();\n+      \/\/ Conditions under which floating point constant can be considered for a pattern match.\n+      \/\/ 1. Constant must lie within Float16 value range, this will ensure that\n+      \/\/ we don't unintentially round off float constant to enforce a pattern match.\n+      \/\/ 2. If constant value is one of the valid IEEE 754 binary32 NaN bit pattern\n+      \/\/ then its safe to consider it for pattern match because of following reasons\n+      \/\/   a. As per section 2.8 of JVMS, Java Virtual Machine does not support\n+      \/\/   signaling NaN value.\n+      \/\/   b. Any signaling NaN which takes part in a non-comparison expression\n+      \/\/   results into a quiet NaN but preserves the significand bits of signaling NaN.\n+      \/\/   c. Pattern being matched includes a Float to Float16 conversion after binary\n+      \/\/   expression, this downcast will still preserve significand bits of binary32 NaN.\n+      bool isnan = ((*reinterpret_cast<jint*>(&con) & 0x7F800000) == 0x7F800000) &&\n+                   ((*reinterpret_cast<jint*>(&con) & 0x7FFFFF) != 0);\n+      if (StubRoutines::hf2f(StubRoutines::f2hf(con)) == con || isnan) {\n+        Node* newVarHF = phase->transform(new ReinterpretS2HFNode(varS));\n+        Node* conHF = phase->makecon(TypeH::make(con));\n+        Node* binopHF = nullptr;\n+        \/\/ Preserving original input order for semantic correctness\n+        \/\/ of non-commutative operation.\n+        if (binopF->in(1) == conF) {\n+          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), conHF, newVarHF));\n+        } else {\n+          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), newVarHF, conHF));\n+        }\n+        return new ReinterpretHF2SNode(binopHF);\n+      }\n+    }\n+  }\n+\n@@ -264,0 +323,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -563,2 +563,4 @@\n-  \/\/ no folding if one of operands is infinity or NaN, do not do constant folding\n-  if(g_isfinite(t1->getf()) && g_isfinite(t2->getf())) {\n+  \/\/ Half precision floating point subtraction follows the rules of IEEE 754\n+  \/\/ applicable to other floating point types.\n+  if (t1->isa_half_float_constant() &&\n+      t2->isa_half_float_constant())  {\n@@ -566,8 +568,1 @@\n-  }\n-  else if(g_isnan(t1->getf())) {\n-    return t1;\n-  }\n-  else if(g_isnan(t2->getf())) {\n-    return t2;\n-  }\n-  else {\n+  } else {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -296,3 +296,3 @@\n-  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a Float{Top,Con,Bot}\n-  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a FloatCon\n-  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a FloatCon\n+  const TypeH      *isa_half_float() const;          \/\/ Returns null if not a HalfFloat{Top,Con,Bot}\n+  const TypeH      *is_half_float_constant() const;  \/\/ Asserts it is a HalfFloatCon\n+  const TypeH      *isa_half_float_constant() const; \/\/ Returns null if not a HalfFloatCon\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import compiler.lib.verify.*;\n@@ -39,0 +40,3 @@\n+import compiler.lib.generators.Generator;\n+import static compiler.lib.generators.Generators.G;\n+\n@@ -58,1 +62,2 @@\n-    private static Random r = jdk.test.lib.Utils.getRandomInstance();\n+    private static Generator<Float> genF = G.uniformFloats(0.0f, 70000.0f);\n+    private static Generator<Short> genHF = G.uniformFloat16s(Float.floatToFloat16(-2000.0f), Float.floatToFloat16(2000.0f));\n@@ -60,5 +65,5 @@\n-    private static final Float16 RANDOM1 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n-    private static final Float16 RANDOM2 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n-    private static final Float16 RANDOM3 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n-    private static final Float16 RANDOM4 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n-    private static final Float16 RANDOM5 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n+    private static final Float16 RANDOM1 = Float16.valueOf(genF.next());\n+    private static final Float16 RANDOM2 = Float16.valueOf(genF.next());\n+    private static final Float16 RANDOM3 = Float16.valueOf(genF.next());\n+    private static final Float16 RANDOM4 = Float16.valueOf(genF.next());\n+    private static final Float16 RANDOM5 = Float16.valueOf(genF.next());\n@@ -71,0 +76,6 @@\n+    private static Float16 POSITIVE_ZERO_VAR = POSITIVE_ZERO;\n+\n+    private static final float INEXACT_FP16 = 2051.0f;\n+    private static final float EXACT_FP16 = 2052.0f;\n+    private static final float SNAN_FP16 = Float.intBitsToFloat(0x7F8000F0);\n+    private static final float QNAN_FP16 = Float.intBitsToFloat(0x7FC00000);\n@@ -81,5 +92,3 @@\n-        fl = new float[count];\n-        for (int i = 0; i < count; i++) {\n-            src[i] = Float.floatToFloat16(r.nextFloat() * MAX_VALUE.floatValue());\n-            fl[i] = r.nextFloat();\n-        }\n+        fl  = new float[count];\n+        G.fill(genF, fl);\n+        G.fill(genHF, src);\n@@ -273,1 +282,1 @@\n-    public void testDivByPOT() {\n+    public Float16 testDivByPOT() {\n@@ -284,1 +293,8 @@\n-        dst[0] = float16ToRawShortBits(res);\n+        return res;\n+    }\n+\n+    @Check(test=\"testDivByPOT\")\n+    public void checkDivByPOT(Float16 actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testDivByPOT\"));\n+        Float16 expected = testDivByPOT();\n+        Verify.checkEQ(Float16.float16ToRawShortBits(expected), Float16.float16ToRawShortBits(actual));\n@@ -292,1 +308,1 @@\n-    public void testMulByTWO() {\n+    public Float16 testMulByTWO() {\n@@ -299,1 +315,117 @@\n-        assertResult(res.floatValue(), (float)((20 * (20 - 1))\/2) * 2.0f, \"testMulByTWO\");\n+        return res;\n+    }\n+\n+    @Check(test=\"testMulByTWO\")\n+    public void checkMulByTWO(Float16 actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testMulByTWO\"));\n+        Float16 expected = testMulByTWO();\n+        Verify.checkEQ(Float16.float16ToRawShortBits(expected), Float16.float16ToRawShortBits(actual));\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public short testInexactFP16ConstantPatterns() {\n+        short res = 0;\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + INEXACT_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - INEXACT_FP16);\n+        res += Float.floatToFloat16(INEXACT_FP16 * POSITIVE_ZERO_VAR.floatValue());\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ INEXACT_FP16);\n+        return res;\n+    }\n+\n+    @Check(test=\"testInexactFP16ConstantPatterns\")\n+    public void checkInexactFP16ConstantPatterns(short actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testInexactFP16ConstantPatterns\"));\n+        short expected = testInexactFP16ConstantPatterns();\n+        Verify.checkEQ(expected, actual);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    @Warmup(10000)\n+    public short testSNaNFP16ConstantPatterns() {\n+        short res = 0;\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + SNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - SNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * SNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ SNAN_FP16);\n+        return res;\n+    }\n+\n+    @Check(test=\"testSNaNFP16ConstantPatterns\")\n+    public void checkSNaNFP16ConstantPatterns(short actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testSNaNFP16ConstantPatterns\"));\n+        short expected = testSNaNFP16ConstantPatterns();\n+        Verify.checkEQ(expected, actual);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    @Warmup(10000)\n+    public short testQNaNFP16ConstantPatterns() {\n+        short res = 0;\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + QNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - QNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * QNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ QNAN_FP16);\n+        return res;\n+    }\n+\n+    @Check(test=\"testQNaNFP16ConstantPatterns\")\n+    public void checkQNaNFP16ConstantPatterns(short actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testQNaNFP16ConstantPatterns\"));\n+        short expected = testQNaNFP16ConstantPatterns();\n+        Verify.checkEQ(expected, actual);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    @Warmup(10000)\n+    public short testExactFP16ConstantPatterns() {\n+        short res = 0;\n+        res += Float.floatToFloat16(EXACT_FP16 + POSITIVE_ZERO_VAR.floatValue());\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - EXACT_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * EXACT_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ EXACT_FP16);\n+        return res;\n+    }\n+\n+    @Check(test=\"testExactFP16ConstantPatterns\")\n+    public void checkExactFP16ConstantPatterns(short actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testExactFP16ConstantPatterns\"));\n+        short expected = testExactFP16ConstantPatterns();\n+        Verify.checkEQ(expected, actual);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    @Warmup(10000)\n+    public short testRandomFP16ConstantPatterns() {\n+        short res = 0;\n+        res += Float.floatToFloat16(RANDOM1_VAR.floatValue() + RANDOM2.floatValue());\n+        res += Float.floatToFloat16(RANDOM2_VAR.floatValue() - RANDOM3.floatValue());\n+        res += Float.floatToFloat16(RANDOM3_VAR.floatValue() * RANDOM4.floatValue());\n+        res += Float.floatToFloat16(RANDOM4_VAR.floatValue() \/ RANDOM5.floatValue());\n+        return res;\n+    }\n+\n+    @Check(test=\"testRandomFP16ConstantPatterns\")\n+    public void checkRandomFP16ConstantPatterns(short actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testRandomFP16ConstantPatterns\"));\n+        short expected = testRandomFP16ConstantPatterns();\n+        Verify.checkEQ(expected, actual);\n@@ -376,0 +508,1 @@\n+    @Warmup(10000)\n@@ -378,3 +511,3 @@\n-        assertResult(subtract(Float16.NaN, valueOf(2.0f)).floatValue(), Float.NaN, \"testAddConstantFolding\");\n-        assertResult(subtract(Float16.NaN, Float16.NaN).floatValue(), Float.NaN, \"testAddConstantFolding\");\n-        assertResult(subtract(Float16.NaN, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.NaN, valueOf(2.0f)).floatValue(), Float.NaN, \"testSubConstantFolding\");\n+        assertResult(subtract(Float16.NaN, Float16.NaN).floatValue(), Float.NaN, \"testSubConstantFolding\");\n+        assertResult(subtract(Float16.NaN, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testSubConstantFolding\");\n@@ -383,1 +516,1 @@\n-        assertResult(subtract(Float16.POSITIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.POSITIVE_INFINITY, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.POSITIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.POSITIVE_INFINITY, \"testSubConstantFolding\");\n@@ -386,2 +519,2 @@\n-        assertResult(subtract(Float16.POSITIVE_INFINITY, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n-        assertResult(subtract(Float16.NEGATIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.NaN, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.POSITIVE_INFINITY, Float16.POSITIVE_INFINITY).floatValue(), Float.NaN, \"testSubConstantFolding\");\n+        assertResult(subtract(Float16.NEGATIVE_INFINITY, Float16.NEGATIVE_INFINITY).floatValue(), Float.NaN, \"testSubConstantFolding\");\n@@ -390,2 +523,2 @@\n-        assertResult(subtract(Float16.POSITIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.POSITIVE_INFINITY, \"testAddConstantFolding\");\n-        assertResult(subtract(Float16.NEGATIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.NEGATIVE_INFINITY, \"testAddConstantFolding\");\n+        assertResult(subtract(Float16.POSITIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.POSITIVE_INFINITY, \"testSubConstantFolding\");\n+        assertResult(subtract(Float16.NEGATIVE_INFINITY, valueOf(2.0f)).floatValue(), Float.NEGATIVE_INFINITY, \"testSubConstantFolding\");\n@@ -394,1 +527,1 @@\n-        assertResult(subtract(NEGATIVE_ZERO, POSITIVE_ZERO).floatValue(), 0.0f, \"testAddConstantFolding\");\n+        assertResult(subtract(NEGATIVE_ZERO, POSITIVE_ZERO).floatValue(), 0.0f, \"testSubConstantFolding\");\n@@ -397,1 +530,1 @@\n-        assertResult(subtract(NEGATIVE_MAX_VALUE, MAX_HALF_ULP).floatValue(), Float.NEGATIVE_INFINITY, \"testAddConstantFolding\");\n+        assertResult(subtract(NEGATIVE_MAX_VALUE, MAX_HALF_ULP).floatValue(), Float.NEGATIVE_INFINITY, \"testSubConstantFolding\");\n@@ -400,1 +533,1 @@\n-        assertResult(subtract(NEGATIVE_MAX_VALUE, LT_MAX_HALF_ULP).floatValue(), NEGATIVE_MAX_VALUE.floatValue(), \"testAddConstantFolding\");\n+        assertResult(subtract(NEGATIVE_MAX_VALUE, LT_MAX_HALF_ULP).floatValue(), NEGATIVE_MAX_VALUE.floatValue(), \"testSubConstantFolding\");\n@@ -402,1 +535,1 @@\n-        assertResult(subtract(valueOf(1.0f), valueOf(2.0f)).floatValue(), -1.0f, \"testAddConstantFolding\");\n+        assertResult(subtract(valueOf(1.0f), valueOf(2.0f)).floatValue(), -1.0f, \"testSubConstantFolding\");\n@@ -406,1 +539,0 @@\n-    @Warmup(value = 10000)\n@@ -411,0 +543,1 @@\n+    @Warmup(10000)\n@@ -431,0 +564,1 @@\n+    @Warmup(10000)\n@@ -450,0 +584,1 @@\n+    @Warmup(10000)\n@@ -476,2 +611,3 @@\n-        assertResult(divide(valueOf(2.0f), NEGATIVE_ZERO).floatValue(), Float.NEGATIVE_INFINITY, \"testDivConstantFolding\");\n-        assertResult(divide(valueOf(2.0f), POSITIVE_ZERO).floatValue(), Float.POSITIVE_INFINITY, \"testDivConstantFolding\");\n+        \/\/ FIXME : C2 compiler limitaition to identify sign of ZERO value.\n+        \/\/ assertResult(divide(valueOf(2.0f), NEGATIVE_ZERO).floatValue(), Float.NEGATIVE_INFINITY, \"testDivConstantFolding\");\n+        \/\/ assertResult(divide(valueOf(2.0f), POSITIVE_ZERO).floatValue(), Float.POSITIVE_INFINITY, \"testDivConstantFolding\");\n@@ -492,0 +628,1 @@\n+    @Warmup(10000)\n@@ -517,0 +654,1 @@\n+    @Warmup(10000)\n@@ -538,0 +676,1 @@\n+    @Warmup(10000)\n@@ -575,0 +714,1 @@\n+    @Warmup(10000)\n@@ -611,1 +751,0 @@\n-    @Warmup(value = 10000)\n@@ -618,0 +757,1 @@\n+    @Warmup(10000)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":171,"deletions":31,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -608,0 +608,23 @@\n+    \/**\n+     * Fills the memory segments with shorts obtained by calling next on the generator.\n+     *\n+     * @param generator The generator from which to source the values.\n+     * @param ms Memory segment to be filled with random values.\n+     *\/\n+    public void fillShort(Generator<Short> generator, MemorySegment ms) {\n+        var layout = ValueLayout.JAVA_SHORT_UNALIGNED;\n+        for (long i = 0; i < ms.byteSize() \/ layout.byteSize(); i++) {\n+            ms.setAtIndex(layout, i, generator.next());\n+        }\n+    }\n+\n+    \/**\n+     * Fill the array with shorts using the distribution of nextDouble.\n+     *\n+     * @param a Array to be filled with random values.\n+     *\/\n+    public void fill(Generator<Short> generator, short[] a) {\n+        fillShort(generator, MemorySegment.ofArray(a));\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/Generators.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Arrays;\n@@ -49,1 +50,1 @@\n-    private static short SCALAR_FP16 = (short)0x7777;\n+    private static short FP16_SCALAR = (short)0x7777;\n@@ -52,0 +53,2 @@\n+    private static final Float16 FP16_CONST = Float16.valueOf(1023.0f);\n+\n@@ -63,4 +66,8 @@\n-    public static boolean assertResults(short expected, short actual) {\n-        Float16 expected_fp16 = shortBitsToFloat16(expected);\n-        Float16 actual_fp16 = shortBitsToFloat16(actual);\n-        return !expected_fp16.equals(actual_fp16);\n+    public static void assertResults(int arity, short ... values) {\n+        assert values.length == (arity + 2);\n+        Float16 expected_fp16 = shortBitsToFloat16(values[arity]);\n+        Float16 actual_fp16 = shortBitsToFloat16(values[arity + 1]);\n+        if(!expected_fp16.equals(actual_fp16)) {\n+            String inputs = Arrays.toString(Arrays.copyOfRange(values, 0, arity - 1));\n+            throw new AssertionError(\"Result Mismatch!, input = \" + inputs + \" actual = \" + actual_fp16 +  \" expected = \" + expected_fp16);\n+        }\n@@ -87,1 +94,1 @@\n-    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.ADD_VHF, \" >0 \"},\n@@ -89,1 +96,1 @@\n-    @IR(counts = {IRNode.ADD_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.ADD_VHF, \" >0 \"},\n@@ -101,4 +108,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -108,0 +112,1 @@\n+\n@@ -110,1 +115,1 @@\n-    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.SUB_VHF, \" >0 \"},\n@@ -112,1 +117,1 @@\n-    @IR(counts = {IRNode.SUB_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.SUB_VHF, \" >0 \"},\n@@ -124,4 +129,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -131,0 +133,1 @@\n+\n@@ -133,1 +136,1 @@\n-    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.MUL_VHF, \" >0 \"},\n@@ -135,1 +138,1 @@\n-    @IR(counts = {IRNode.MUL_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.MUL_VHF, \" >0 \"},\n@@ -147,4 +150,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -156,1 +156,1 @@\n-    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.DIV_VHF, \" >0 \"},\n@@ -158,1 +158,1 @@\n-    @IR(counts = {IRNode.DIV_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.DIV_VHF, \" >0 \"},\n@@ -170,4 +170,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -179,1 +176,1 @@\n-    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.MIN_VHF, \" >0 \"},\n@@ -181,1 +178,1 @@\n-    @IR(counts = {IRNode.MIN_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.MIN_VHF, \" >0 \"},\n@@ -193,4 +190,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -202,1 +196,1 @@\n-    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.MAX_VHF, \" >0 \"},\n@@ -204,1 +198,1 @@\n-    @IR(counts = {IRNode.MAX_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.MAX_VHF, \" >0 \"},\n@@ -216,4 +210,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], input2[i], expected, output[i]);\n@@ -225,1 +216,1 @@\n-    @IR(counts = {IRNode.SQRT_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.SQRT_VHF, \" >0 \"},\n@@ -227,1 +218,1 @@\n-    @IR(counts = {IRNode.SQRT_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.SQRT_VHF, \" >0 \"},\n@@ -239,4 +230,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input = \" + input1[i] +\n-                                           \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(1, input1[i], expected, output[i]);\n@@ -248,1 +236,1 @@\n-    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n@@ -250,1 +238,1 @@\n-    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n@@ -264,4 +252,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \"input3 = \" + input3[i] + \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(3, input1[i], input2[i], input3[i], expected, output[i]);\n@@ -273,1 +258,1 @@\n-    @IR(counts = {IRNode.FMA_VHF, \" >= 1\"},\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n@@ -275,1 +260,1 @@\n-    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n@@ -279,1 +264,1 @@\n-            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(SCALAR_FP16),\n+            output[i] = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(FP16_SCALAR),\n@@ -287,1 +272,1 @@\n-            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(SCALAR_FP16),\n+            short expected = float16ToRawShortBits(fma(shortBitsToFloat16(input1[i]), shortBitsToFloat16(FP16_SCALAR),\n@@ -289,4 +274,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + SCALAR_FP16 +\n-                                           \"input3 = 3.0 \" + \"output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(2, input1[i], FP16_SCALAR, expected, output[i]);\n@@ -299,1 +281,1 @@\n-    @IR(counts = {IRNode.FMA_VHF, \" >= 1\"},\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n@@ -301,1 +283,1 @@\n-    @IR(counts = {IRNode.FMA_VHF, \">= 1\"},\n+    @IR(counts = {IRNode.FMA_VHF, \" >0 \"},\n@@ -310,0 +292,1 @@\n+\n@@ -315,4 +298,1 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1[i] + \" input2 = \" + input2[i] +\n-                                           \"input3 = \" + input3 + \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(3, input1[i], input2[i], input3, expected, output[i]);\n@@ -344,4 +324,112 @@\n-            if (assertResults(expected, output[i])) {\n-                throw new RuntimeException(\"Invalid result: [\" + i + \"] input1 = \" + input1 + \" input2 = \" + input2 +\n-                                           \"input3 = \" + input3 + \" output = \" + output[i] + \" expected = \" + expected);\n-            }\n+            assertResults(3, input1, input2, input3, expected, output[i]);\n+        }\n+    }\n+\n+\n+    @Test\n+    @Warmup(50)\n+    @IR(counts = {IRNode.ADD_VHF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zvfh\", \"true\", \"sve\", \"true\"})\n+    @IR(counts = {IRNode.ADD_VHF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    public void vectorAddConstInputFloat16() {\n+         for (int i = 0; i < LEN; ++i) {\n+             output[i] = float16ToRawShortBits(add(shortBitsToFloat16(input1[i]), FP16_CONST));\n+         }\n+     }\n+\n+    @Check(test=\"vectorAddConstInputFloat16\")\n+    public void checkResultAddConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) + FP16_CONST.floatValue());\n+            assertResults(2, input1[i], float16ToRawShortBits(FP16_CONST), expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(50)\n+    @IR(counts = {IRNode.SUB_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorSubConstInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(subtract(shortBitsToFloat16(input1[i]), FP16_CONST));\n+        }\n+    }\n+\n+    @Check(test=\"vectorSubConstInputFloat16\")\n+    public void checkResultSubConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(float16ToFloat(input1[i]) - FP16_CONST.floatValue());\n+            assertResults(2, input1[i], float16ToRawShortBits(FP16_CONST), expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(50)\n+    @IR(counts = {IRNode.MUL_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorMulConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(multiply(FP16_CONST, shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMulConstantInputFloat16\")\n+    public void checkResultMulConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(FP16_CONST.floatValue() * float16ToFloat(input2[i]));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(50)\n+    @IR(counts = {IRNode.DIV_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorDivConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(divide(FP16_CONST, shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorDivConstantInputFloat16\")\n+    public void checkResultDivConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(FP16_CONST.floatValue() \/ float16ToFloat(input2[i]));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(50)\n+    @IR(counts = {IRNode.MAX_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorMaxConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(max(FP16_CONST, shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMaxConstantInputFloat16\")\n+    public void checkResultMaxConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.max(FP16_CONST.floatValue(), float16ToFloat(input2[i])));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(50)\n+    @IR(counts = {IRNode.MIN_VHF, \" >0 \"},\n+        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+    public void vectorMinConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = float16ToRawShortBits(min(FP16_CONST, shortBitsToFloat16(input2[i])));\n+        }\n+    }\n+\n+    @Check(test=\"vectorMinConstantInputFloat16\")\n+    public void checkResultMinConstantInputFloat16() {\n+        for (int i = 0; i < LEN; ++i) {\n+            short expected = floatToFloat16(Math.min(FP16_CONST.floatValue(), float16ToFloat(input2[i])));\n+            assertResults(2, float16ToRawShortBits(FP16_CONST), input2[i], expected, output[i]);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorOperations.java","additions":159,"deletions":71,"binary":false,"changes":230,"status":"modified"}]}