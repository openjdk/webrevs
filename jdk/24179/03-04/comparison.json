{"files":[{"patch":"@@ -263,2 +263,5 @@\n-  Node* con_inp = nullptr;\n-  Node* var_inp = nullptr;\n+  \/\/ Detects following ideal graph pattern\n+  \/\/      ConvF2HF(binopF(conF, ConvHF2F(varS))) =>\n+  \/\/              ReinterpretHF2SNode(binopHF(conHF, ReinterpretS2HFNode(varS)))\n+  Node* conF = nullptr;\n+  Node* varS = nullptr;\n@@ -266,1 +269,1 @@\n-    Node* f32bOp = in(1);\n+    Node* binopF = in(1);\n@@ -272,6 +275,6 @@\n-    if (f32bOp->in(1)->is_Con() && f32bOp->in(2)->Opcode() == Op_ConvHF2F) {\n-      con_inp = f32bOp->in(1);\n-      var_inp = f32bOp->in(2)->in(1);\n-    } else if (f32bOp->in(2)->is_Con() &&  f32bOp->in(1)->Opcode() == Op_ConvHF2F) {\n-      con_inp = f32bOp->in(2);\n-      var_inp = f32bOp->in(1)->in(1);\n+    if (binopF->in(1)->is_Con() && binopF->in(2)->Opcode() == Op_ConvHF2F) {\n+      conF = binopF->in(1);\n+      varS = binopF->in(2)->in(1);\n+    } else if (binopF->in(2)->is_Con() &&  binopF->in(1)->Opcode() == Op_ConvHF2F) {\n+      conF = binopF->in(2);\n+      varS = binopF->in(1)->in(1);\n@@ -280,3 +283,4 @@\n-    if (con_inp && var_inp &&\n-        con_inp->bottom_type()->is_float_constant() &&\n-        Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(f32bOp->Opcode())) &&\n+    if (conF != nullptr &&\n+        varS != nullptr &&\n+        conF->bottom_type()->is_float_constant() &&\n+        Matcher::match_rule_supported(Float16NodeFactory::get_float16_binary_oper(binopF->Opcode())) &&\n@@ -287,9 +291,22 @@\n-      jfloat conF = con_inp->bottom_type()->getf();\n-      \/\/ If constant lie within Float16 value range, convert it to\n-      \/\/ a half-float constant.\n-      if (StubRoutines::hf2f(StubRoutines::f2hf(conF)) == conF) {\n-        Node* new_var_inp = phase->transform(new ReinterpretS2HFNode(var_inp));\n-        Node* new_con_inp = phase->makecon(TypeH::make(conF));\n-        Node* f16bOp = nullptr;\n-        if (f32bOp->in(1) == con_inp) {\n-          f16bOp = phase->transform(Float16NodeFactory::make(f32bOp->Opcode(), f32bOp->in(0), new_con_inp, new_var_inp));\n+      jfloat con = conF->bottom_type()->getf();\n+      \/\/ Conditions under which floating point constant can be considered for a pattern match.\n+      \/\/ 1. Constant must lie within Float16 value range, this will ensure that\n+      \/\/ we don't unintentially round off float constant to enforce a pattern match.\n+      \/\/ 2. If constant value is one of the valid IEEE 754 binary32 NaN bit pattern\n+      \/\/ then its safe to consider it for pattern match because of following reasons\n+      \/\/   a. As per section 2.8 of JVMS, Java Virtual Machine does not support\n+      \/\/   signaling NaN value.\n+      \/\/   b. Any signaling NaN which takes part in a non-comparison expression\n+      \/\/   results into a quiet NaN but preserves the significand bits of signaling NaN.\n+      \/\/   c. Pattern being matched includes a Float to Float16 conversion after binary\n+      \/\/   expression, this downcast will still preserve significand bits of binary32 NaN.\n+      bool isnan = ((*reinterpret_cast<jint*>(&con) & 0x7F800000) == 0x7F800000) &&\n+                   ((*reinterpret_cast<jint*>(&con) & 0x7FFFFF) != 0);\n+      if (StubRoutines::hf2f(StubRoutines::f2hf(con)) == con || isnan) {\n+        Node* newVarHF = phase->transform(new ReinterpretS2HFNode(varS));\n+        Node* conHF = phase->makecon(TypeH::make(con));\n+        Node* binopHF = nullptr;\n+        \/\/ Preserving original input order for semantic correctness\n+        \/\/ of non-commutative operation.\n+        if (binopF->in(1) == conF) {\n+          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), conHF, newVarHF));\n@@ -297,1 +314,1 @@\n-          f16bOp = phase->transform(Float16NodeFactory::make(f32bOp->Opcode(), f32bOp->in(0), new_var_inp, new_con_inp));\n+          binopHF = phase->transform(Float16NodeFactory::make(binopF->Opcode(), binopF->in(0), newVarHF, conHF));\n@@ -299,1 +316,1 @@\n-        return new ReinterpretHF2SNode(f16bOp);\n+        return new ReinterpretHF2SNode(binopHF);\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -565,2 +565,0 @@\n-  \/\/ There are no known undefined, unspecified or implimentation specific\n-  \/\/ behaviors w.r.t to floating point non-pointer subtraction.\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import compiler.lib.verify.*;\n@@ -39,0 +40,3 @@\n+import compiler.lib.generators.Generator;\n+import static compiler.lib.generators.Generators.G;\n+\n@@ -58,1 +62,2 @@\n-    private static Random r = jdk.test.lib.Utils.getRandomInstance();\n+    private static Generator<Float> genF = G.uniformFloats(0.0f, 70000.0f);\n+    private static Generator<Short> genHF = G.uniformFloat16s(Float.floatToFloat16(-2000.0f), Float.floatToFloat16(2000.0f));\n@@ -60,5 +65,5 @@\n-    private static final Float16 RANDOM1 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n-    private static final Float16 RANDOM2 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n-    private static final Float16 RANDOM3 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n-    private static final Float16 RANDOM4 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n-    private static final Float16 RANDOM5 = Float16.valueOf(r.nextFloat() * MAX_VALUE.floatValue());\n+    private static final Float16 RANDOM1 = Float16.valueOf(genF.next());\n+    private static final Float16 RANDOM2 = Float16.valueOf(genF.next());\n+    private static final Float16 RANDOM3 = Float16.valueOf(genF.next());\n+    private static final Float16 RANDOM4 = Float16.valueOf(genF.next());\n+    private static final Float16 RANDOM5 = Float16.valueOf(genF.next());\n@@ -87,5 +92,3 @@\n-        fl = new float[count];\n-        for (int i = 0; i < count; i++) {\n-            src[i] = Float.floatToFloat16(r.nextFloat() * MAX_VALUE.floatValue());\n-            fl[i] = r.nextFloat();\n-        }\n+        fl  = new float[count];\n+        G.fill(genF, fl);\n+        G.fill(genHF, src);\n@@ -279,1 +282,1 @@\n-    public void testDivByPOT() {\n+    public Float16 testDivByPOT() {\n@@ -290,1 +293,8 @@\n-        dst[0] = float16ToRawShortBits(res);\n+        return res;\n+    }\n+\n+    @Check(test=\"testDivByPOT\")\n+    public void checkDivByPOT(Float16 actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testDivByPOT\"));\n+        Float16 expected = testDivByPOT();\n+        Verify.checkEQ(Float16.float16ToRawShortBits(expected), Float16.float16ToRawShortBits(actual));\n@@ -298,1 +308,1 @@\n-    public void testMulByTWO() {\n+    public Float16 testMulByTWO() {\n@@ -305,1 +315,8 @@\n-        assertResult(res.floatValue(), (float)((20 * (20 - 1))\/2) * 2.0f, \"testMulByTWO\");\n+        return res;\n+    }\n+\n+    @Check(test=\"testMulByTWO\")\n+    public void checkMulByTWO(Float16 actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testMulByTWO\"));\n+        Float16 expected = testMulByTWO();\n+        Verify.checkEQ(Float16.float16ToRawShortBits(expected), Float16.float16ToRawShortBits(actual));\n@@ -313,1 +330,1 @@\n-    public void testInexactFP16ConstantPatterns() {\n+    public short testInexactFP16ConstantPatterns() {\n@@ -315,5 +332,12 @@\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + INEXACT_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - INEXACT_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * INEXACT_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ INEXACT_FP16);\n-         assertResult(Float.float16ToFloat(res), 32.125f, \"testInexactFP16ConstantPatterns\");\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + INEXACT_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - INEXACT_FP16);\n+        res += Float.floatToFloat16(INEXACT_FP16 * POSITIVE_ZERO_VAR.floatValue());\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ INEXACT_FP16);\n+        return res;\n+    }\n+\n+    @Check(test=\"testInexactFP16ConstantPatterns\")\n+    public void checkInexactFP16ConstantPatterns(short actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testInexactFP16ConstantPatterns\"));\n+        short expected = testInexactFP16ConstantPatterns();\n+        Verify.checkEQ(expected, actual);\n@@ -323,1 +347,1 @@\n-    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n@@ -325,1 +349,1 @@\n-    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n@@ -328,1 +352,1 @@\n-    public void testSNaNFP16ConstantPatterns() {\n+    public short testSNaNFP16ConstantPatterns() {\n@@ -330,5 +354,12 @@\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + SNAN_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - SNAN_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * SNAN_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ SNAN_FP16);\n-         assertResult(Float.float16ToFloat(res), -32768.0f, \"testSNaNFP16ConstantPatterns\");\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + SNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - SNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * SNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ SNAN_FP16);\n+        return res;\n+    }\n+\n+    @Check(test=\"testSNaNFP16ConstantPatterns\")\n+    public void checkSNaNFP16ConstantPatterns(short actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testSNaNFP16ConstantPatterns\"));\n+        short expected = testSNaNFP16ConstantPatterns();\n+        Verify.checkEQ(expected, actual);\n@@ -338,1 +369,1 @@\n-    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n@@ -340,1 +371,1 @@\n-    @IR(counts = {IRNode.ADD_HF, \" 0 \", IRNode.SUB_HF, \" 0 \", IRNode.MUL_HF, \" 0 \", IRNode.DIV_HF, \" 0 \"},\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n@@ -342,1 +373,24 @@\n-    public void testQNaNFP16ConstantPatterns() {\n+    @Warmup(10000)\n+    public short testQNaNFP16ConstantPatterns() {\n+        short res = 0;\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + QNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - QNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * QNAN_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ QNAN_FP16);\n+        return res;\n+    }\n+\n+    @Check(test=\"testQNaNFP16ConstantPatterns\")\n+    public void checkQNaNFP16ConstantPatterns(short actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testQNaNFP16ConstantPatterns\"));\n+        short expected = testQNaNFP16ConstantPatterns();\n+        Verify.checkEQ(expected, actual);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+    @IR(counts = {IRNode.ADD_HF, \" >0 \", IRNode.SUB_HF, \" >0 \", IRNode.MUL_HF, \" >0 \", IRNode.DIV_HF, \" >0 \"},\n+        applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+    @Warmup(10000)\n+    public short testExactFP16ConstantPatterns() {\n@@ -344,5 +398,12 @@\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + QNAN_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - QNAN_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * QNAN_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ QNAN_FP16);\n-         assertResult(Float.float16ToFloat(res), -32768.0f, \"testQNaNFP16ConstantPatterns\");\n+        res += Float.floatToFloat16(EXACT_FP16 + POSITIVE_ZERO_VAR.floatValue());\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - EXACT_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * EXACT_FP16);\n+        res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ EXACT_FP16);\n+        return res;\n+    }\n+\n+    @Check(test=\"testExactFP16ConstantPatterns\")\n+    public void checkExactFP16ConstantPatterns(short actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testExactFP16ConstantPatterns\"));\n+        short expected = testExactFP16ConstantPatterns();\n+        Verify.checkEQ(expected, actual);\n@@ -356,1 +417,2 @@\n-    public void testExactFP16ConstantPatterns() {\n+    @Warmup(10000)\n+    public short testRandomFP16ConstantPatterns() {\n@@ -358,5 +420,12 @@\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() + EXACT_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() - EXACT_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() * EXACT_FP16);\n-         res += Float.floatToFloat16(POSITIVE_ZERO_VAR.floatValue() \/ EXACT_FP16);\n-         assertResult(Float.float16ToFloat(res), 32.125f, \"testExactFP16ConstantPatterns\");\n+        res += Float.floatToFloat16(RANDOM1_VAR.floatValue() + RANDOM2.floatValue());\n+        res += Float.floatToFloat16(RANDOM2_VAR.floatValue() - RANDOM3.floatValue());\n+        res += Float.floatToFloat16(RANDOM3_VAR.floatValue() * RANDOM4.floatValue());\n+        res += Float.floatToFloat16(RANDOM4_VAR.floatValue() \/ RANDOM5.floatValue());\n+        return res;\n+    }\n+\n+    @Check(test=\"testRandomFP16ConstantPatterns\")\n+    public void checkRandomFP16ConstantPatterns(short actual) throws Exception {\n+        TestFramework.deoptimize(TestFloat16ScalarOperations.class.getMethod(\"testRandomFP16ConstantPatterns\"));\n+        short expected = testRandomFP16ConstantPatterns();\n+        Verify.checkEQ(expected, actual);\n@@ -365,0 +434,1 @@\n+\n@@ -681,1 +751,0 @@\n-    @Warmup(value = 10000)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":113,"deletions":44,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -608,0 +608,23 @@\n+    \/**\n+     * Fills the memory segments with shorts obtained by calling next on the generator.\n+     *\n+     * @param generator The generator from which to source the values.\n+     * @param ms Memory segment to be filled with random values.\n+     *\/\n+    public void fillShort(Generator<Short> generator, MemorySegment ms) {\n+        var layout = ValueLayout.JAVA_SHORT_UNALIGNED;\n+        for (long i = 0; i < ms.byteSize() \/ layout.byteSize(); i++) {\n+            ms.setAtIndex(layout, i, generator.next());\n+        }\n+    }\n+\n+    \/**\n+     * Fill the array with shorts using the distribution of nextDouble.\n+     *\n+     * @param a Array to be filled with random values.\n+     *\/\n+    public void fill(Generator<Short> generator, short[] a) {\n+        fillShort(generator, MemorySegment.ofArray(a));\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/generators\/Generators.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}