{"files":[{"patch":"@@ -51,1 +51,0 @@\n-import sun.awt.util.IdentityLinkedList;\n@@ -1420,1 +1419,1 @@\n-        java.util.List<Window> toBlock = new IdentityLinkedList<Window>();\n+        java.util.List<Window> toBlock = new IdentityArrayList<Window>();\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Dialog.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,880 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.awt.util;\n-\n-import java.util.AbstractSequentialList;\n-import java.util.Collection;\n-import java.util.ConcurrentModificationException;\n-import java.util.Deque;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.NoSuchElementException;\n-\n-\/**\n- * Linked list implementation of the {@code List} interface.  Implements all\n- * optional list operations, and permits all elements (including\n- * {@code null}).  In addition to implementing the {@code List} interface,\n- * the {@code IdentityLinkedList} class provides uniformly named methods to\n- * {@code get}, {@code remove} and {@code insert} an element at the\n- * beginning and end of the list.  These operations allow linked lists to be\n- * used as a stack, {@linkplain java.util.Queue queue}, or {@linkplain Deque\n- * double-ended queue}. <p>\n- *\n- * The class implements the {@code Deque} interface, providing\n- * first-in-first-out queue operations for {@code add},\n- * {@code poll}, along with other stack and deque operations.<p>\n- *\n- * All of the operations perform as could be expected for a doubly-linked\n- * list.  Operations that index into the list will traverse the list from\n- * the beginning or the end, whichever is closer to the specified index.<p>\n- *\n- * <p><strong>Note that this implementation is not synchronized.<\/strong>\n- * If multiple threads access a linked list concurrently, and at least\n- * one of the threads modifies the list structurally, it <i>must<\/i> be\n- * synchronized externally.  (A structural modification is any operation\n- * that adds or deletes one or more elements; merely setting the value of\n- * an element is not a structural modification.)  This is typically\n- * accomplished by synchronizing on some object that naturally\n- * encapsulates the list.\n- *\n- * If no such object exists, the list should be \"wrapped\" using the\n- * {@link java.util.Collections#synchronizedList Collections.synchronizedList}\n- * method.  This is best done at creation time, to prevent accidental\n- * unsynchronized access to the list:<pre>\n- *   List list = Collections.synchronizedList(new IdentityLinkedList(...));<\/pre>\n- *\n- * <p>The iterators returned by this class's {@code iterator} and\n- * {@code listIterator} methods are <i>fail-fast<\/i>: if the list is\n- * structurally modified at any time after the iterator is created, in\n- * any way except through the Iterator's own {@code remove} or\n- * {@code add} methods, the iterator will throw a {@link\n- * ConcurrentModificationException}.  Thus, in the face of concurrent\n- * modification, the iterator fails quickly and cleanly, rather than\n- * risking arbitrary, non-deterministic behavior at an undetermined\n- * time in the future.\n- *\n- * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed\n- * as it is, generally speaking, impossible to make any hard guarantees in the\n- * presence of unsynchronized concurrent modification.  Fail-fast iterators\n- * throw {@code ConcurrentModificationException} on a best-effort basis.\n- * Therefore, it would be wrong to write a program that depended on this\n- * exception for its correctness:   <i>the fail-fast behavior of iterators\n- * should be used only to detect bugs.<\/i>\n- *\/\n-\n-public class IdentityLinkedList<E>\n-    extends AbstractSequentialList<E>\n-    implements List<E>, Deque<E>\n-{\n-    private transient Entry<E> header = new Entry<E>(null, null, null);\n-    private transient int size = 0;\n-\n-    \/**\n-     * Constructs an empty list.\n-     *\/\n-    public IdentityLinkedList() {\n-        header.next = header.previous = header;\n-    }\n-\n-    \/**\n-     * Constructs a list containing the elements of the specified\n-     * collection, in the order they are returned by the collection's\n-     * iterator.\n-     *\n-     * @param  c the collection whose elements are to be placed into this list\n-     * @throws NullPointerException if the specified collection is null\n-     *\/\n-    public IdentityLinkedList(Collection<? extends E> c) {\n-        this();\n-        addAll(c);\n-    }\n-\n-    \/**\n-     * Returns the first element in this list.\n-     *\n-     * @return the first element in this list\n-     * @throws NoSuchElementException if this list is empty\n-     *\/\n-    public E getFirst() {\n-        if (size==0)\n-            throw new NoSuchElementException();\n-\n-        return header.next.element;\n-    }\n-\n-    \/**\n-     * Returns the last element in this list.\n-     *\n-     * @return the last element in this list\n-     * @throws NoSuchElementException if this list is empty\n-     *\/\n-    public E getLast()  {\n-        if (size==0)\n-            throw new NoSuchElementException();\n-\n-        return header.previous.element;\n-    }\n-\n-    \/**\n-     * Removes and returns the first element from this list.\n-     *\n-     * @return the first element from this list\n-     * @throws NoSuchElementException if this list is empty\n-     *\/\n-    public E removeFirst() {\n-        return remove(header.next);\n-    }\n-\n-    \/**\n-     * Removes and returns the last element from this list.\n-     *\n-     * @return the last element from this list\n-     * @throws NoSuchElementException if this list is empty\n-     *\/\n-    public E removeLast() {\n-        return remove(header.previous);\n-    }\n-\n-    \/**\n-     * Inserts the specified element at the beginning of this list.\n-     *\n-     * @param e the element to add\n-     *\/\n-    public void addFirst(E e) {\n-        addBefore(e, header.next);\n-    }\n-\n-    \/**\n-     * Appends the specified element to the end of this list.\n-     *\n-     * <p>This method is equivalent to {@link #add}.\n-     *\n-     * @param e the element to add\n-     *\/\n-    public void addLast(E e) {\n-        addBefore(e, header);\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this list contains the specified element.\n-     * More formally, returns {@code true} if and only if this list contains\n-     * at least one element {@code e} such that\n-     * {@code o == e}.\n-     *\n-     * @param o element whose presence in this list is to be tested\n-     * @return {@code true} if this list contains the specified element\n-     *\/\n-    public boolean contains(Object o) {\n-        return indexOf(o) != -1;\n-    }\n-\n-    \/**\n-     * Returns the number of elements in this list.\n-     *\n-     * @return the number of elements in this list\n-     *\/\n-    public int size() {\n-        return size;\n-    }\n-\n-    \/**\n-     * Appends the specified element to the end of this list.\n-     *\n-     * <p>This method is equivalent to {@link #addLast}.\n-     *\n-     * @param e element to be appended to this list\n-     * @return {@code true} (as specified by {@link Collection#add})\n-     *\/\n-    public boolean add(E e) {\n-        addBefore(e, header);\n-        return true;\n-    }\n-\n-    \/**\n-     * Removes the first occurrence of the specified element from this list,\n-     * if it is present.  If this list does not contain the element, it is\n-     * unchanged.  More formally, removes the element with the lowest index\n-     * {@code i} such that {@code get(i) == o}\n-     * (if such an element exists).  Returns {@code true} if this list\n-     * contained the specified element (or equivalently, if this list\n-     * changed as a result of the call).\n-     *\n-     * @param o element to be removed from this list, if present\n-     * @return {@code true} if this list contained the specified element\n-     *\/\n-    public boolean remove(Object o) {\n-        for (Entry<E> e = header.next; e != header; e = e.next) {\n-            if (o == e.element) {\n-                remove(e);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Appends all of the elements in the specified collection to the end of\n-     * this list, in the order that they are returned by the specified\n-     * collection's iterator.  The behavior of this operation is undefined if\n-     * the specified collection is modified while the operation is in\n-     * progress.  (Note that this will occur if the specified collection is\n-     * this list, and it's nonempty.)\n-     *\n-     * @param c collection containing elements to be added to this list\n-     * @return {@code true} if this list changed as a result of the call\n-     * @throws NullPointerException if the specified collection is null\n-     *\/\n-    public boolean addAll(Collection<? extends E> c) {\n-        return addAll(size, c);\n-    }\n-\n-    \/**\n-     * Inserts all of the elements in the specified collection into this\n-     * list, starting at the specified position.  Shifts the element\n-     * currently at that position (if any) and any subsequent elements to\n-     * the right (increases their indices).  The new elements will appear\n-     * in the list in the order that they are returned by the\n-     * specified collection's iterator.\n-     *\n-     * @param index index at which to insert the first element\n-     *              from the specified collection\n-     * @param c collection containing elements to be added to this list\n-     * @return {@code true} if this list changed as a result of the call\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     * @throws NullPointerException if the specified collection is null\n-     *\/\n-    public boolean addAll(int index, Collection<? extends E> c) {\n-        if (index < 0 || index > size)\n-            throw new IndexOutOfBoundsException(\"Index: \"+index+\n-                                                \", Size: \"+size);\n-        Object[] a = c.toArray();\n-        int numNew = a.length;\n-        if (numNew==0)\n-            return false;\n-        modCount++;\n-\n-        Entry<E> successor = (index==size ? header : entry(index));\n-        Entry<E> predecessor = successor.previous;\n-        for (int i=0; i<numNew; i++) {\n-            @SuppressWarnings(\"unchecked\")\n-            E tmp = (E) a[i];\n-            Entry<E> e = new Entry<E>(tmp, successor, predecessor);\n-            predecessor.next = e;\n-            predecessor = e;\n-        }\n-        successor.previous = predecessor;\n-\n-        size += numNew;\n-        return true;\n-    }\n-\n-    \/**\n-     * Removes all of the elements from this list.\n-     *\/\n-    public void clear() {\n-        Entry<E> e = header.next;\n-        while (e != header) {\n-            Entry<E> next = e.next;\n-            e.next = e.previous = null;\n-            e.element = null;\n-            e = next;\n-        }\n-        header.next = header.previous = header;\n-        size = 0;\n-        modCount++;\n-    }\n-\n-\n-    \/\/ Positional Access Operations\n-\n-    \/**\n-     * Returns the element at the specified position in this list.\n-     *\n-     * @param index index of the element to return\n-     * @return the element at the specified position in this list\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     *\/\n-    public E get(int index) {\n-        return entry(index).element;\n-    }\n-\n-    \/**\n-     * Replaces the element at the specified position in this list with the\n-     * specified element.\n-     *\n-     * @param index index of the element to replace\n-     * @param element element to be stored at the specified position\n-     * @return the element previously at the specified position\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     *\/\n-    public E set(int index, E element) {\n-        Entry<E> e = entry(index);\n-        E oldVal = e.element;\n-        e.element = element;\n-        return oldVal;\n-    }\n-\n-    \/**\n-     * Inserts the specified element at the specified position in this list.\n-     * Shifts the element currently at that position (if any) and any\n-     * subsequent elements to the right (adds one to their indices).\n-     *\n-     * @param index index at which the specified element is to be inserted\n-     * @param element element to be inserted\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     *\/\n-    public void add(int index, E element) {\n-        addBefore(element, (index==size ? header : entry(index)));\n-    }\n-\n-    \/**\n-     * Removes the element at the specified position in this list.  Shifts any\n-     * subsequent elements to the left (subtracts one from their indices).\n-     * Returns the element that was removed from the list.\n-     *\n-     * @param index the index of the element to be removed\n-     * @return the element previously at the specified position\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     *\/\n-    public E remove(int index) {\n-        return remove(entry(index));\n-    }\n-\n-    \/**\n-     * Returns the indexed entry.\n-     *\/\n-    private Entry<E> entry(int index) {\n-        if (index < 0 || index >= size)\n-            throw new IndexOutOfBoundsException(\"Index: \"+index+\n-                                                \", Size: \"+size);\n-        Entry<E> e = header;\n-        if (index < (size >> 1)) {\n-            for (int i = 0; i <= index; i++)\n-                e = e.next;\n-        } else {\n-            for (int i = size; i > index; i--)\n-                e = e.previous;\n-        }\n-        return e;\n-    }\n-\n-\n-    \/\/ Search Operations\n-\n-    \/**\n-     * Returns the index of the first occurrence of the specified element\n-     * in this list, or -1 if this list does not contain the element.\n-     * More formally, returns the lowest index {@code i} such that\n-     * {@code get(i) == o},\n-     * or -1 if there is no such index.\n-     *\n-     * @param o element to search for\n-     * @return the index of the first occurrence of the specified element in\n-     *         this list, or -1 if this list does not contain the element\n-     *\/\n-    public int indexOf(Object o) {\n-        int index = 0;\n-        for (Entry<E> e = header.next; e != header; e = e.next) {\n-            if (o == e.element) {\n-                return index;\n-            }\n-            index++;\n-        }\n-        return -1;\n-    }\n-\n-    \/**\n-     * Returns the index of the last occurrence of the specified element\n-     * in this list, or -1 if this list does not contain the element.\n-     * More formally, returns the highest index {@code i} such that\n-     * {@code get(i) == o},\n-     * or -1 if there is no such index.\n-     *\n-     * @param o element to search for\n-     * @return the index of the last occurrence of the specified element in\n-     *         this list, or -1 if this list does not contain the element\n-     *\/\n-    public int lastIndexOf(Object o) {\n-        int index = size;\n-        for (Entry<E> e = header.previous; e != header; e = e.previous) {\n-            index--;\n-            if (o == e.element) {\n-                return index;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    \/\/ Queue operations.\n-\n-    \/**\n-     * Retrieves, but does not remove, the head (first element) of this list.\n-     * @return the head of this list, or {@code null} if this list is empty\n-     * @since 1.5\n-     *\/\n-    public E peek() {\n-        if (size==0)\n-            return null;\n-        return getFirst();\n-    }\n-\n-    \/**\n-     * Retrieves, but does not remove, the head (first element) of this list.\n-     * @return the head of this list\n-     * @throws NoSuchElementException if this list is empty\n-     * @since 1.5\n-     *\/\n-    public E element() {\n-        return getFirst();\n-    }\n-\n-    \/**\n-     * Retrieves and removes the head (first element) of this list\n-     * @return the head of this list, or {@code null} if this list is empty\n-     * @since 1.5\n-     *\/\n-    public E poll() {\n-        if (size==0)\n-            return null;\n-        return removeFirst();\n-    }\n-\n-    \/**\n-     * Retrieves and removes the head (first element) of this list.\n-     *\n-     * @return the head of this list\n-     * @throws NoSuchElementException if this list is empty\n-     * @since 1.5\n-     *\/\n-    public E remove() {\n-        return removeFirst();\n-    }\n-\n-    \/**\n-     * Adds the specified element as the tail (last element) of this list.\n-     *\n-     * @param e the element to add\n-     * @return {@code true} (as specified by {@link java.util.Queue#offer})\n-     * @since 1.5\n-     *\/\n-    public boolean offer(E e) {\n-        return add(e);\n-    }\n-\n-    \/\/ Deque operations\n-    \/**\n-     * Inserts the specified element at the front of this list.\n-     *\n-     * @param e the element to insert\n-     * @return {@code true} (as specified by {@link Deque#offerFirst})\n-     * @since 1.6\n-     *\/\n-    public boolean offerFirst(E e) {\n-        addFirst(e);\n-        return true;\n-    }\n-\n-    \/**\n-     * Inserts the specified element at the end of this list.\n-     *\n-     * @param e the element to insert\n-     * @return {@code true} (as specified by {@link Deque#offerLast})\n-     * @since 1.6\n-     *\/\n-    public boolean offerLast(E e) {\n-        addLast(e);\n-        return true;\n-    }\n-\n-    \/**\n-     * Retrieves, but does not remove, the first element of this list,\n-     * or returns {@code null} if this list is empty.\n-     *\n-     * @return the first element of this list, or {@code null}\n-     *         if this list is empty\n-     * @since 1.6\n-     *\/\n-    public E peekFirst() {\n-        if (size==0)\n-            return null;\n-        return getFirst();\n-    }\n-\n-    \/**\n-     * Retrieves, but does not remove, the last element of this list,\n-     * or returns {@code null} if this list is empty.\n-     *\n-     * @return the last element of this list, or {@code null}\n-     *         if this list is empty\n-     * @since 1.6\n-     *\/\n-    public E peekLast() {\n-        if (size==0)\n-            return null;\n-        return getLast();\n-    }\n-\n-    \/**\n-     * Retrieves and removes the first element of this list,\n-     * or returns {@code null} if this list is empty.\n-     *\n-     * @return the first element of this list, or {@code null} if\n-     *     this list is empty\n-     * @since 1.6\n-     *\/\n-    public E pollFirst() {\n-        if (size==0)\n-            return null;\n-        return removeFirst();\n-    }\n-\n-    \/**\n-     * Retrieves and removes the last element of this list,\n-     * or returns {@code null} if this list is empty.\n-     *\n-     * @return the last element of this list, or {@code null} if\n-     *     this list is empty\n-     * @since 1.6\n-     *\/\n-    public E pollLast() {\n-        if (size==0)\n-            return null;\n-        return removeLast();\n-    }\n-\n-    \/**\n-     * Pushes an element onto the stack represented by this list.  In other\n-     * words, inserts the element at the front of this list.\n-     *\n-     * <p>This method is equivalent to {@link #addFirst}.\n-     *\n-     * @param e the element to push\n-     * @since 1.6\n-     *\/\n-    public void push(E e) {\n-        addFirst(e);\n-    }\n-\n-    \/**\n-     * Pops an element from the stack represented by this list.  In other\n-     * words, removes and returns the first element of this list.\n-     *\n-     * <p>This method is equivalent to {@link #removeFirst()}.\n-     *\n-     * @return the element at the front of this list (which is the top\n-     *         of the stack represented by this list)\n-     * @throws NoSuchElementException if this list is empty\n-     * @since 1.6\n-     *\/\n-    public E pop() {\n-        return removeFirst();\n-    }\n-\n-    \/**\n-     * Removes the first occurrence of the specified element in this\n-     * list (when traversing the list from head to tail).  If the list\n-     * does not contain the element, it is unchanged.\n-     *\n-     * @param o element to be removed from this list, if present\n-     * @return {@code true} if the list contained the specified element\n-     * @since 1.6\n-     *\/\n-    public boolean removeFirstOccurrence(Object o) {\n-        return remove(o);\n-    }\n-\n-    \/**\n-     * Removes the last occurrence of the specified element in this\n-     * list (when traversing the list from head to tail).  If the list\n-     * does not contain the element, it is unchanged.\n-     *\n-     * @param o element to be removed from this list, if present\n-     * @return {@code true} if the list contained the specified element\n-     * @since 1.6\n-     *\/\n-    public boolean removeLastOccurrence(Object o) {\n-        for (Entry<E> e = header.previous; e != header; e = e.previous) {\n-            if (o == e.element) {\n-                remove(e);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Returns a list-iterator of the elements in this list (in proper\n-     * sequence), starting at the specified position in the list.\n-     * Obeys the general contract of {@code List.listIterator(int)}.<p>\n-     *\n-     * The list-iterator is <i>fail-fast<\/i>: if the list is structurally\n-     * modified at any time after the Iterator is created, in any way except\n-     * through the list-iterator's own {@code remove} or {@code add}\n-     * methods, the list-iterator will throw a\n-     * {@code ConcurrentModificationException}.  Thus, in the face of\n-     * concurrent modification, the iterator fails quickly and cleanly, rather\n-     * than risking arbitrary, non-deterministic behavior at an undetermined\n-     * time in the future.\n-     *\n-     * @param index index of the first element to be returned from the\n-     *              list-iterator (by a call to {@code next})\n-     * @return a ListIterator of the elements in this list (in proper\n-     *         sequence), starting at the specified position in the list\n-     * @throws IndexOutOfBoundsException {@inheritDoc}\n-     * @see List#listIterator(int)\n-     *\/\n-    public ListIterator<E> listIterator(int index) {\n-        return new ListItr(index);\n-    }\n-\n-    private class ListItr implements ListIterator<E> {\n-        private Entry<E> lastReturned = header;\n-        private Entry<E> next;\n-        private int nextIndex;\n-        private int expectedModCount = modCount;\n-\n-        ListItr(int index) {\n-            if (index < 0 || index > size)\n-                throw new IndexOutOfBoundsException(\"Index: \"+index+\n-                                                    \", Size: \"+size);\n-            if (index < (size >> 1)) {\n-                next = header.next;\n-                for (nextIndex=0; nextIndex<index; nextIndex++)\n-                    next = next.next;\n-            } else {\n-                next = header;\n-                for (nextIndex=size; nextIndex>index; nextIndex--)\n-                    next = next.previous;\n-            }\n-        }\n-\n-        public boolean hasNext() {\n-            return nextIndex != size;\n-        }\n-\n-        public E next() {\n-            checkForComodification();\n-            if (nextIndex == size)\n-                throw new NoSuchElementException();\n-\n-            lastReturned = next;\n-            next = next.next;\n-            nextIndex++;\n-            return lastReturned.element;\n-        }\n-\n-        public boolean hasPrevious() {\n-            return nextIndex != 0;\n-        }\n-\n-        public E previous() {\n-            if (nextIndex == 0)\n-                throw new NoSuchElementException();\n-\n-            lastReturned = next = next.previous;\n-            nextIndex--;\n-            checkForComodification();\n-            return lastReturned.element;\n-        }\n-\n-        public int nextIndex() {\n-            return nextIndex;\n-        }\n-\n-        public int previousIndex() {\n-            return nextIndex-1;\n-        }\n-\n-        public void remove() {\n-            checkForComodification();\n-            Entry<E> lastNext = lastReturned.next;\n-            try {\n-                IdentityLinkedList.this.remove(lastReturned);\n-            } catch (NoSuchElementException e) {\n-                throw new IllegalStateException();\n-            }\n-            if (next==lastReturned)\n-                next = lastNext;\n-            else\n-                nextIndex--;\n-            lastReturned = header;\n-            expectedModCount++;\n-        }\n-\n-        public void set(E e) {\n-            if (lastReturned == header)\n-                throw new IllegalStateException();\n-            checkForComodification();\n-            lastReturned.element = e;\n-        }\n-\n-        public void add(E e) {\n-            checkForComodification();\n-            lastReturned = header;\n-            addBefore(e, next);\n-            nextIndex++;\n-            expectedModCount++;\n-        }\n-\n-        final void checkForComodification() {\n-            if (modCount != expectedModCount)\n-                throw new ConcurrentModificationException();\n-        }\n-    }\n-\n-    private static class Entry<E> {\n-        E element;\n-        Entry<E> next;\n-        Entry<E> previous;\n-\n-        Entry(E element, Entry<E> next, Entry<E> previous) {\n-            this.element = element;\n-            this.next = next;\n-            this.previous = previous;\n-        }\n-    }\n-\n-    private Entry<E> addBefore(E e, Entry<E> entry) {\n-        Entry<E> newEntry = new Entry<E>(e, entry, entry.previous);\n-        newEntry.previous.next = newEntry;\n-        newEntry.next.previous = newEntry;\n-        size++;\n-        modCount++;\n-        return newEntry;\n-    }\n-\n-    private E remove(Entry<E> e) {\n-        if (e == header)\n-            throw new NoSuchElementException();\n-\n-        E result = e.element;\n-        e.previous.next = e.next;\n-        e.next.previous = e.previous;\n-        e.next = e.previous = null;\n-        e.element = null;\n-        size--;\n-        modCount++;\n-        return result;\n-    }\n-\n-    \/**\n-     * @since 1.6\n-     *\/\n-    public Iterator<E> descendingIterator() {\n-        return new DescendingIterator();\n-    }\n-\n-    \/** Adapter to provide descending iterators via ListItr.previous *\/\n-    private class DescendingIterator implements Iterator<E> {\n-        final ListItr itr = new ListItr(size());\n-        public boolean hasNext() {\n-            return itr.hasPrevious();\n-        }\n-        public E next() {\n-            return itr.previous();\n-        }\n-        public void remove() {\n-            itr.remove();\n-        }\n-    }\n-\n-    \/**\n-     * Returns an array containing all of the elements in this list\n-     * in proper sequence (from first to last element).\n-     *\n-     * <p>The returned array will be \"safe\" in that no references to it are\n-     * maintained by this list.  (In other words, this method must allocate\n-     * a new array).  The caller is thus free to modify the returned array.\n-     *\n-     * <p>This method acts as bridge between array-based and collection-based\n-     * APIs.\n-     *\n-     * @return an array containing all of the elements in this list\n-     *         in proper sequence\n-     *\/\n-    public Object[] toArray() {\n-        Object[] result = new Object[size];\n-        int i = 0;\n-        for (Entry<E> e = header.next; e != header; e = e.next)\n-            result[i++] = e.element;\n-        return result;\n-    }\n-\n-    \/**\n-     * Returns an array containing all of the elements in this list in\n-     * proper sequence (from first to last element); the runtime type of\n-     * the returned array is that of the specified array.  If the list fits\n-     * in the specified array, it is returned therein.  Otherwise, a new\n-     * array is allocated with the runtime type of the specified array and\n-     * the size of this list.\n-     *\n-     * <p>If the list fits in the specified array with room to spare (i.e.,\n-     * the array has more elements than the list), the element in the array\n-     * immediately following the end of the list is set to {@code null}.\n-     * (This is useful in determining the length of the list <i>only<\/i> if\n-     * the caller knows that the list does not contain any null elements.)\n-     *\n-     * <p>Like the {@link #toArray()} method, this method acts as bridge between\n-     * array-based and collection-based APIs.  Further, this method allows\n-     * precise control over the runtime type of the output array, and may,\n-     * under certain circumstances, be used to save allocation costs.\n-     *\n-     * <p>Suppose {@code x} is a list known to contain only strings.\n-     * The following code can be used to dump the list into a newly\n-     * allocated array of {@code String}:\n-     *\n-     * <pre>\n-     *     String[] y = x.toArray(new String[0]);<\/pre>\n-     *\n-     * Note that {@code toArray(new Object[0])} is identical in function to\n-     * {@code toArray()}.\n-     *\n-     * @param a the array into which the elements of the list are to\n-     *          be stored, if it is big enough; otherwise, a new array of the\n-     *          same runtime type is allocated for this purpose.\n-     * @return an array containing the elements of the list\n-     * @throws ArrayStoreException if the runtime type of the specified array\n-     *         is not a supertype of the runtime type of every element in\n-     *         this list\n-     * @throws NullPointerException if the specified array is null\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> T[] toArray(T[] a) {\n-        if (a.length < size)\n-            a = (T[])java.lang.reflect.Array.newInstance(\n-                                a.getClass().getComponentType(), size);\n-        int i = 0;\n-        Object[] result = a;\n-        for (Entry<E> e = header.next; e != header; e = e.next)\n-            result[i++] = e.element;\n-\n-        if (a.length > size)\n-            a[size] = null;\n-\n-        return a;\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/util\/IdentityLinkedList.java","additions":0,"deletions":880,"binary":false,"changes":880,"status":"deleted"}]}