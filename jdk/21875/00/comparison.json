{"files":[{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+\/*\n+ * @test\n+ * @bug 8342498\n+ * @summary Test SuperWord, when it aligns to field-store, and the corresponding allocation is eliminated.\n+ * @run driver compiler.loopopts.superword.TestEliminateAllocationWithCastP2XUse\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:-SplitIfBlocks -XX:LoopMaxUnroll=8 -XX:DominatorSearchLimit=45\n+ *                   compiler.loopopts.superword.TestEliminateAllocationWithCastP2XUse\n+ *\/\n+\n+public class TestEliminateAllocationWithCastP2XUse {\n+    public static void main(String args[]) {\n+        byte[] a = new byte[10_000];\n+        for (int i = 0; i < 10000; i++) {\n+            test(a);\n+        }\n+    }\n+\n+    \/\/ Summary:\n+    \/\/  - Some B allocations are detected as NoEscape, but cannot be removed because of a field load.\n+    \/\/  - The field loads cannot be LoadNode::split_through_phi because DominatorSearchLimit is too low\n+    \/\/    for the dominates query to look through some IfNode \/ IfProj path.\n+    \/\/  - We go into loop-opts.\n+    \/\/  - In theory, the Stores of B::offset would be moved out of the loop. But we disable\n+    \/\/    PhaseIdealLoop::try_move_store_after_loop by setting -XX:-SplitIfBlocks.\n+    \/\/  - The field loads are folded away because of some MaxUnroll trick, where the val constant folds to 1.\n+    \/\/  - SuperWord eventually kicks in, and vectorizes the array stores.\n+    \/\/  - Since some vectorization has happened, SuperWord wants to align the main loop with a memory reference\n+    \/\/    in the loop. The code here is not very smart, and just picks the memory reference that occurs the\n+    \/\/    most often. But the B::offset stores occur more often than the array stores, and so we align to\n+    \/\/    one of the B::offset stores. This inserts a CastP2X under the CheckCastPP of the B allocation.\n+    \/\/  - Once loop opts is over, we eventually go into macro expansion.\n+    \/\/  - During macro expansion, we now discover that the Allocations were marked NoEscape, and that by now\n+    \/\/    there are no field loads any more: yay, we can remove the allocation!\n+    \/\/  - ... except that there is the CastP2X from SuperWord alignment ...\n+    \/\/  - The Allocation removal code wants to pattern match the CastP2X as part of a GC barrier, but then\n+    \/\/    the pattern does not conform to the expecatation - it is after all from SuperWord. This leads to\n+    \/\/    an assert, and SIGSEGV in product, at least with G1GC.\n+    public static long test(byte[] a) {\n+        \/\/ Delay val == 1 until loop-opts, with MaxUnroll trick.\n+        int val = 0;\n+        for (int i = 0; i < 4; i++) {\n+            if ((i % 2) == 0) {\n+                val = 1;\n+            }\n+        }\n+        \/\/ during loop opts, we learn val == 1\n+        \/\/ But we don't know that during EscapeAnalysis (EA) yet.\n+\n+        \/\/ 9 Allocations, discovered as NoEscape during EA.\n+        B b1 = new B();\n+        B b2 = new B();\n+        B b3 = new B();\n+        B b4 = new B();\n+        B b5 = new B();\n+        B b6 = new B();\n+        B b7 = new B();\n+        B b8 = new B();\n+        B b9 = new B();\n+\n+        \/\/ Some path of IfNode \/ IfProj.\n+        \/\/ Only folds away once we know val == 1\n+        \/\/ This delays the LoadNode::split_through_phi, because it needs a dominates call\n+        \/\/ to succeed, but it cannot look through this path because we set -XX:DominatorSearchLimit=45\n+        \/\/ i.e. just a little too low to be able to look through.\n+        \/\/ Without the LoadNode::split_through_phi before the end of EA, the Allocation cannot yet be\n+        \/\/ removed, due to a \"Field load\", i.e. that Load for B::offset.\n+        \/\/ But later, this path can actually fold away, when we know that val == 1. At that point,\n+        \/\/ also the Load from B::offset folds away because LoadNode::split_through_phi succeeds\n+        \/\/ At that point the B allocations have no Loads any more, and can be removed... but this only\n+        \/\/ happens at macro expansion, after all loop opts.\n+        if (val == 1010) { throw new RuntimeException(\"never\"); }\n+        if (val == 1020) { throw new RuntimeException(\"never\"); }\n+        if (val == 1030) { throw new RuntimeException(\"never\"); }\n+        if (val == 1040) { throw new RuntimeException(\"never\"); }\n+        if (val == 1060) { throw new RuntimeException(\"never\"); }\n+        if (val == 1070) { throw new RuntimeException(\"never\"); }\n+        if (val == 1080) { throw new RuntimeException(\"never\"); }\n+        if (val == 1090) { throw new RuntimeException(\"never\"); }\n+\n+        if (val == 2010) { throw new RuntimeException(\"never\"); }\n+        if (val == 2020) { throw new RuntimeException(\"never\"); }\n+        if (val == 2030) { throw new RuntimeException(\"never\"); }\n+        if (val == 2040) { throw new RuntimeException(\"never\"); }\n+        if (val == 2060) { throw new RuntimeException(\"never\"); }\n+        if (val == 2070) { throw new RuntimeException(\"never\"); }\n+        if (val == 2080) { throw new RuntimeException(\"never\"); }\n+        if (val == 2090) { throw new RuntimeException(\"never\"); }\n+\n+        if (val == 3010) { throw new RuntimeException(\"never\"); }\n+        if (val == 3020) { throw new RuntimeException(\"never\"); }\n+        if (val == 3030) { throw new RuntimeException(\"never\"); }\n+        if (val == 3040) { throw new RuntimeException(\"never\"); }\n+        if (val == 3060) { throw new RuntimeException(\"never\"); }\n+        if (val == 3070) { throw new RuntimeException(\"never\"); }\n+        if (val == 3080) { throw new RuntimeException(\"never\"); }\n+        if (val == 3090) { throw new RuntimeException(\"never\"); }\n+\n+        if (val == 4010) { throw new RuntimeException(\"never\"); }\n+        if (val == 4020) { throw new RuntimeException(\"never\"); }\n+        if (val == 4030) { throw new RuntimeException(\"never\"); }\n+        if (val == 4040) { throw new RuntimeException(\"never\"); }\n+        if (val == 4060) { throw new RuntimeException(\"never\"); }\n+        if (val == 4070) { throw new RuntimeException(\"never\"); }\n+        if (val == 4080) { throw new RuntimeException(\"never\"); }\n+        if (val == 4090) { throw new RuntimeException(\"never\"); }\n+\n+        long mulVal = 1;\n+        for (int i = 0; i < a.length; i++) {\n+            mulVal *= 3;\n+            \/\/ We do some vector store, so that SuperWord succeeds, and creates the\n+            \/\/ alignment code, which emits the CastP2X.\n+            a[i]++;\n+            \/\/ But we also have 9 Stores for the B::offset.\n+            \/\/ SuperWord now sees more of these stores than of the array stores, and picks\n+            \/\/ one of the B::offset stores as the alignment reference... creating a CastP2X\n+            \/\/ for the CheckCastPP of the B allocation.\n+            b1.offset = mulVal;\n+            b2.offset = mulVal;\n+            b3.offset = mulVal;\n+            b4.offset = mulVal;\n+            b5.offset = mulVal;\n+            b6.offset = mulVal;\n+            b7.offset = mulVal;\n+            b8.offset = mulVal;\n+            b9.offset = mulVal;\n+        }\n+\n+        \/\/ This folds the loads away, once we know val == 1\n+        \/\/ That happens during loop-opts, so after EA, but before macro expansion.\n+        long ret = 0;\n+        if (val == 42) {\n+            ret = b1.offset +\n+                  b2.offset +\n+                  b3.offset +\n+                  b4.offset +\n+                  b5.offset +\n+                  b6.offset +\n+                  b7.offset +\n+                  b8.offset +\n+                  b9.offset;\n+        }\n+\n+        return ret;\n+    }\n+\n+    static class B {\n+        \/\/ Add padding so that the old SuperWord::can_create_pairs accepts the field store to B.offset\n+        long pad1 = 0;   \/\/ at 16\n+        long pad2 = 0;   \/\/ at 24\n+        long pad3 = 0;   \/\/ at 32\n+        long pad4 = 0;   \/\/ at 40\n+        long pad5 = 0;   \/\/ at 48\n+        long pad6 = 0;   \/\/ at 56\n+        long offset = 0; \/\/ offset at 64 bytes\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestEliminateAllocationWithCastP2XUse.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"}]}