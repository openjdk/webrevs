{"files":[{"patch":"@@ -1831,0 +1831,13 @@\n+#define INSN(NAME, op, width, umop, mop, mew, nf)                                               \\\n+  void NAME(VectorRegister Vd_or_Vs3, Register Rs1, VectorMask vm = unmasked) { \\\n+    patch_VLdSt(op, Vd_or_Vs3, width, Rs1, umop, vm, mop, mew, nf);                         \\\n+  }\n+\n+  \/\/ Vector Unit-Stride Segment Load Instructions\n+  INSN(vlseg3e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g3);\n+\n+  \/\/ Vector Unit-Stride Segment Store Instructions\n+  INSN(vsseg4e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g4);\n+\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -5106,0 +5106,220 @@\n+  \/**\n+   * vector registers:\n+   *   input VectorRegister's:  intputV1-V3, for m2 they could be v2, v4, v6, for m1 they could be v1, v2, v3\n+   *   index VectorRegister's:  idxV1-V4, for m2 they could be v8, v10, v12, v14, for m1 they could be v4, v5, v6, v7\n+   *   output VectorRegister's: outputV1-V4, for m2 they could be v16, v18, v20, v22, for m1 they could be v8, v9, v10, v11\n+   *\n+   * NOTE: each field will occupy a vector register group\n+   *\/\n+  void base64_vector_encode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3, VectorRegister outputV4,\n+                    Assembler::LMUL lmul) {\n+    \/\/ set vector register type\/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul);\n+\n+    \/\/ segmented load src into v registers: mem(src) => vr(3)\n+    __ vlseg3e8_v(inputV1, src);\n+\n+    \/\/ src = src + register_group_len_bytes * 3\n+    __ add(src, src, stepSrc);\n+\n+    \/\/ encoding\n+    \/\/   1. compute index into lookup table: vr(3) => vr(4)\n+    __ vsrl_vi(idxV1, inputV1, 2);\n+\n+    __ vsrl_vi(idxV2, inputV2, 2);\n+    __ vsll_vi(inputV1, inputV1, 6);\n+    __ vor_vv(idxV2, idxV2, inputV1);\n+    __ vsrl_vi(idxV2, idxV2, 2);\n+\n+    __ vsrl_vi(idxV3, inputV3, 4);\n+    __ vsll_vi(inputV2, inputV2, 4);\n+    __ vor_vv(idxV3, inputV2, idxV3);\n+    __ vsrl_vi(idxV3, idxV3, 2);\n+\n+    __ vsll_vi(idxV4, inputV3, 2);\n+    __ vsrl_vi(idxV4, idxV4, 2);\n+\n+    \/\/   2. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(outputV1, codec, idxV1);\n+    __ vluxei8_v(outputV2, codec, idxV2);\n+    __ vluxei8_v(outputV3, codec, idxV3);\n+    __ vluxei8_v(outputV4, codec, idxV4);\n+\n+    \/\/ segmented store encoded data in v registers back to dst: vr(4) => mem(dst)\n+    __ vsseg4e8_v(outputV1, dst);\n+\n+    \/\/ dst = dst + register_group_len_bytes * 4\n+    __ add(dst, dst, stepDst);\n+  }\n+\n+  \/**\n+   *  void j.u.Base64.Encoder.encodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - src, source array\n+   *  c_rarg1   - sp, src start offset\n+   *  c_rarg2   - sl, src end offset\n+   *  c_rarg3   - dst, dest array\n+   *  c_rarg4   - dp, dst start offset\n+   *  c_rarg5   - isURL, Base64 or URL character set\n+   *\/\n+  address generate_base64_encodeBlock() {\n+    alignas(64) static const char toBase64[64] = {\n+      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '\/'\n+    };\n+\n+    alignas(64) static const char toBase64URL[64] = {\n+      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"encodeBlock\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    Register src    = c_rarg0;\n+    Register soff   = c_rarg1;\n+    Register send   = c_rarg2;\n+    Register dst    = c_rarg3;\n+    Register doff   = c_rarg4;\n+    Register isURL  = c_rarg5;\n+\n+    Register codec  = c_rarg6;\n+    Register length = c_rarg7; \/\/ total length of src data in bytes\n+\n+    Label ProcessData, Exit, Greater;\n+\n+    \/\/ length should be multiple of 3\n+    __ sub(length, send, soff);\n+    \/\/ real src\/dst to process data\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+\n+    \/\/ load the codec base address\n+    __ la(codec, ExternalAddress((address) toBase64));\n+    __ beqz(isURL, ProcessData);\n+    __ la(codec, ExternalAddress((address) toBase64URL));\n+    __ BIND(ProcessData);\n+\n+    \/\/ vector version\n+    if (UseRVV) {\n+      Label ProcessM2, ProcessM1, ProcessScalar;\n+\n+      Register size      = soff;\n+      Register stepSrcM1 = send;\n+      Register stepSrcM2 = doff;\n+      Register stepDst   = isURL;\n+\n+      __ mv(size, MaxVectorSize * 2);\n+      __ mv(stepSrcM1, MaxVectorSize * 3);\n+      __ slli(stepSrcM2, stepSrcM1, 1);\n+      __ mv(stepDst, MaxVectorSize * 2 * 4);\n+\n+      __ BIND(ProcessM2);\n+      __ blt(length, stepSrcM1, ProcessScalar);\n+\n+      __ blt(length, stepSrcM2, ProcessM1);\n+\n+      base64_vector_encode_round(src, dst, codec,\n+                    size, stepSrcM2, stepDst,\n+                    v2, v4, v6,         \/\/ inputs\n+                    v8, v10, v12, v14,  \/\/ indexes\n+                    v16, v18, v20, v22, \/\/ outputs\n+                    Assembler::m2);\n+\n+      __ sub(length, length, stepSrcM2);\n+      __ j(ProcessM2);\n+\n+      __ BIND(ProcessM1);\n+      __ srli(size, size, 1);\n+      __ srli(stepDst, stepDst, 1);\n+      base64_vector_encode_round(src, dst, codec,\n+                    size, stepSrcM1, stepDst,\n+                    v1, v2, v3,         \/\/ inputs\n+                    v4, v5, v6, v7,     \/\/ indexes\n+                    v8, v9, v10, v11,   \/\/ outputs\n+                    Assembler::m1);\n+      __ sub(length, length, stepSrcM1);\n+      __ BIND(ProcessScalar);\n+    }\n+\n+    \/\/ scalar version\n+    {\n+      Register byte1 = soff, byte0 = send, byte2 = doff;\n+      Register combined24Bits = isURL;\n+      Register step = x28;\n+\n+      __ mv(step, 3);\n+      __ blt(length, step, Exit);\n+\n+      Label ScalarLoop;\n+      __ BIND(ScalarLoop);\n+      {\n+        \/\/ plain:   [byte0[7:0] : byte1[7:0] : byte2[7:0]] =>\n+        \/\/ encoded: [byte0[7:2] : byte0[1:0]+byte1[7:4] : byte1[3:0]+byte2[7:6] : byte2[5:0]]\n+\n+        \/\/ load 3 bytes src data\n+        __ lbu(byte0, Address(src, 0));\n+        __ lbu(byte1, Address(src, 1));\n+        __ lbu(byte2, Address(src, 2));\n+        __ addi(src, src, 3);\n+\n+        \/\/ construct 24 bits from 3 bytes\n+        __ slliw(byte0, byte0, 16);\n+        __ slliw(byte1, byte1, 8);\n+        __ orr(combined24Bits, byte0, byte1);\n+        __ orr(combined24Bits, combined24Bits, byte2);\n+\n+        \/\/ get codec index and encode(ie. load from codec by index)\n+        __ slliw(byte0, combined24Bits, 8);\n+        __ srliw(byte0, byte0, 26);\n+        __ add(byte0, codec, byte0);\n+        __ lbu(byte0, byte0);\n+\n+        __ slliw(byte1, combined24Bits, 14);\n+        __ srliw(byte1, byte1, 26);\n+        __ add(byte1, codec, byte1);\n+        __ lbu(byte1, byte1);\n+\n+        __ slliw(byte2, combined24Bits, 20);\n+        __ srliw(byte2, byte2, 26);\n+        __ add(byte2, codec, byte2);\n+        __ lbu(byte2, byte2);\n+\n+        __ andi(combined24Bits, combined24Bits, 0x3f);\n+        __ add(combined24Bits, codec, combined24Bits);\n+        __ lbu(combined24Bits, combined24Bits);\n+\n+        \/\/ store 4 bytes encoded data\n+        __ sb(byte0, Address(dst, 0));\n+        __ sb(byte1, Address(dst, 1));\n+        __ sb(byte2, Address(dst, 2));\n+        __ sb(combined24Bits, Address(dst, 3));\n+\n+        __ sub(length, length, 3);\n+        __ addi(dst, dst, 4);\n+        \/\/ loop back\n+        __ bge(length, step, ScalarLoop);\n+      }\n+    }\n+\n+    __ BIND(Exit);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -5999,0 +6219,4 @@\n+    if (UseBASE64Intrinsics) {\n+      StubRoutines::_base64_encodeBlock = generate_base64_encodeBlock();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":224,"deletions":0,"binary":false,"changes":224,"status":"modified"},{"patch":"@@ -268,0 +268,5 @@\n+  \/\/ Base64\n+  if (FLAG_IS_DEFAULT(UseBASE64Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseBASE64Intrinsics, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}