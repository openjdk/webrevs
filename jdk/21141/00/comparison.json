{"files":[{"patch":"@@ -215,0 +215,7 @@\n+            \/\/ Extract options\n+            new Option(false, OptionType.EXTRACT, \"--keep\", \"-k\") {\n+                void process(Main jartool, String opt, String arg) {\n+                    jartool.kflag = true;\n+                }\n+            },\n+\n@@ -257,0 +264,1 @@\n+        EXTRACT(\"extract\"),\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -158,0 +158,1 @@\n+     * kflag: keep existing file\n@@ -159,1 +160,1 @@\n-    boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, pflag, dflag, validate;\n+    boolean cflag, uflag, xflag, tflag, vflag, flag0, Mflag, iflag, pflag, dflag, kflag, validate;\n@@ -585,0 +586,3 @@\n+                        case 'k':\n+                            kflag = true;\n+                            break;\n@@ -1455,0 +1459,6 @@\n+            if (f.exists() && kflag) {\n+                if (vflag) {\n+                    output(formatMsg(\"out.kept\", name));\n+                }\n+                return rc;\n+            }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -168,0 +168,2 @@\n+out.kept=\\\n+        \\ \\ skipped: {0}\n@@ -310,0 +312,6 @@\n+main.help.opt.extract=\\\n+\\ Operation modifiers valid only in extract mode:\\n\n+main.help.opt.extract.keep=\\\n+\\  -k, --keep-old-files       Do not overwrite existing files.\\n\\\n+\\                             In particular, if a file appears more than once in an\\n\\\n+\\                             archive, later copies will not overwrite earlier copies.\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335912\n+ * @summary test extract jar files overwrite existing files behavior\n+ * @library \/test\/lib\n+ * @modules jdk.jartool\n+ * @build jdk.test.lib.Platform\n+ *        jdk.test.lib.util.FileUtils\n+ * @run testng ExtractFilesTest\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+import java.util.zip.ZipException;\n+\n+import jdk.test.lib.util.FileUtils;\n+\n+public class ExtractFilesTest {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jar tool not found\")\n+        );\n+\n+    private final String nl = System.lineSeparator();\n+    private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+    private final PrintStream out = new PrintStream(baos);\n+    private Runnable onCompletion;\n+\n+    @BeforeClass\n+    public void setupJar() throws IOException {\n+        mkdir(\"test1 test2\");\n+        echo(\"testfile1\", \"test1\/testfile1\");\n+        echo(\"testfile2\", \"test2\/testfile2\");\n+        jar(\"cf test.jar -C test1 . -C test2 .\");\n+        rm(\"test1 test2\");\n+    }\n+\n+    @AfterClass\n+    public void cleanup() {\n+        rm(\"test.jar\");\n+    }\n+\n+    @BeforeMethod\n+    public void reset() {\n+        onCompletion = null;\n+    }\n+\n+    @AfterMethod\n+    public void run() {\n+        if (onCompletion != null) {\n+            onCompletion.run();\n+        }\n+    }\n+\n+    @Test\n+    public void testExtract() throws IOException {\n+        jar(\"xvf test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: testfile1\" + nl +\n+                \" inflated: testfile2\" + nl;\n+        rm(\"META-INF testfile1 testfile2\");\n+        Assert.assertEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    @Test\n+    public void testOverwrite() throws IOException {\n+        touch(\"testfile1\");\n+        jar(\"xvf test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: testfile1\" + nl +\n+                \" inflated: testfile2\" + nl;\n+        Assert.assertEquals(\"testfile1\", cat(\"testfile1\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        Assert.assertEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    @Test\n+    public void testKeptOldFile() throws IOException {\n+        touch(\"testfile1\");\n+        jar(\"xkvf test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \"  skipped: testfile1\" + nl +\n+                \" inflated: testfile2\" + nl;\n+        Assert.assertEquals(\"\", cat(\"testfile1\"));\n+        Assert.assertEquals(\"testfile2\", cat(\"testfile2\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        Assert.assertEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    @Test\n+    public void testGnuOptionsKeptOldFile() throws IOException {\n+        touch(\"testfile1 testfile2\");\n+        jar(\"-x -k -v -f test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \"  skipped: testfile1\" + nl +\n+                \"  skipped: testfile2\" + nl;\n+        Assert.assertEquals(\"\", cat(\"testfile1\"));\n+        Assert.assertEquals(\"\", cat(\"testfile2\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        Assert.assertEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    @Test\n+    public void testGnuLongOptionsKeptOldFile() throws IOException {\n+        touch(\"testfile2\");\n+        jar(\"-x --keep -v -f test.jar\");\n+        println();\n+        String output = \"  created: META-INF\/\" + nl +\n+                \" inflated: META-INF\/MANIFEST.MF\" + nl +\n+                \" inflated: testfile1\" + nl +\n+                \"  skipped: testfile2\" + nl;\n+        Assert.assertEquals(\"testfile1\", cat(\"testfile1\"));\n+        Assert.assertEquals(\"\", cat(\"testfile2\"));\n+        rm(\"META-INF testfile1 testfile2\");\n+        Assert.assertEquals(baos.toByteArray(), output.getBytes());\n+    }\n+\n+    private Stream<Path> mkpath(String... args) {\n+        return Arrays.stream(args).map(d -> Paths.get(\".\", d.split(\"\/\")));\n+    }\n+\n+    private void mkdir(String cmdline) {\n+        System.out.println(\"mkdir -p \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                Files.createDirectories(p);\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void touch(String cmdline) {\n+        System.out.println(\"touch \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                Files.createFile(p);\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void echo(String text, String path) {\n+        System.out.println(\"echo '\" + text + \"' > \" + path);\n+        try {\n+            var p = Paths.get(\".\", path.split(\"\/\"));\n+            Files.writeString(p, text);\n+        } catch (IOException x) {\n+            throw new UncheckedIOException(x);\n+        }\n+    }\n+\n+    private String cat(String path) {\n+        System.out.println(\"cat \" + path);\n+        try {\n+            var p = Paths.get(\".\", path.split(\"\/\"));\n+            return String.join(nl, Files.readAllLines(p));\n+        } catch (IOException x) {\n+            throw new UncheckedIOException(x);\n+        }\n+    }\n+\n+    private void rm(String cmdline) {\n+        System.out.println(\"rm -rf \" + cmdline);\n+        mkpath(cmdline.split(\" +\")).forEach(p -> {\n+            try {\n+                if (Files.isDirectory(p)) {\n+                    FileUtils.deleteFileTreeWithRetry(p);\n+                } else {\n+                    FileUtils.deleteFileIfExistsWithRetry(p);\n+                }\n+            } catch (IOException x) {\n+                throw new UncheckedIOException(x);\n+            }\n+        });\n+    }\n+\n+    private void jar(String cmdline) throws IOException {\n+        System.out.println(\"jar \" + cmdline);\n+        baos.reset();\n+\n+        \/\/ the run method catches IOExceptions, we need to expose them\n+        ByteArrayOutputStream baes = new ByteArrayOutputStream();\n+        PrintStream err = new PrintStream(baes);\n+        PrintStream saveErr = System.err;\n+        System.setErr(err);\n+        int rc = JAR_TOOL.run(out, err, cmdline.split(\" +\"));\n+        System.setErr(saveErr);\n+        if (rc != 0) {\n+            String s = baes.toString();\n+            if (s.startsWith(\"java.util.zip.ZipException: duplicate entry: \")) {\n+                throw new ZipException(s);\n+            }\n+            throw new IOException(s);\n+        }\n+    }\n+\n+    private void println() throws IOException {\n+        System.out.println(new String(baos.toByteArray()));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jar\/ExtractFilesTest.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"}]}