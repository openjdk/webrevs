{"files":[{"patch":"@@ -46,0 +46,24 @@\n+void G1BlockOffsetTable::set_offset_array_raw(uint8_t* addr, uint8_t offset) {\n+  Atomic::store(addr, offset);\n+}\n+\n+void G1BlockOffsetTable::set_offset_array(uint8_t* addr, uint8_t offset) {\n+  check_address(addr, \"Block offset table address out of range\");\n+  set_offset_array_raw(addr, offset);\n+}\n+\n+void G1BlockOffsetTable::set_offset_array(uint8_t* addr, HeapWord* high, HeapWord* low) {\n+  check_address(addr, \"Block offset table address out of range\");\n+  assert(high >= low, \"addresses out of order\");\n+  size_t offset = pointer_delta(high, low);\n+  check_offset(offset, \"offset too large\");\n+  set_offset_array(addr, (uint8_t)offset);\n+}\n+\n+void G1BlockOffsetTable::set_offset_array(uint8_t* left, uint8_t* right, uint8_t offset) {\n+  check_address(right, \"Right block offset table address out of range\");\n+  assert(left <= right, \"indexes out of order\");\n+  size_t num_cards = right - left + 1;\n+  memset_with_concurrent_readers(left, offset, num_cards);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -69,0 +69,6 @@\n+  \/\/ Mapping from address to object start array entry\n+  inline uint8_t* entry_for_addr(const void* const p) const;\n+\n+  \/\/ Mapping from object start array entry to address of first word\n+  inline HeapWord* addr_for_entry(const uint8_t* const p) const;\n+\n@@ -80,0 +86,3 @@\n+  void verify_offset(uint8_t* card_index, uint8_t upper) const NOT_DEBUG_RETURN;\n+  void verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const NOT_DEBUG_RETURN;\n+\n@@ -102,6 +111,0 @@\n-  \/\/ Mapping from address to object start array entry\n-  uint8_t* entry_for_addr(const void* const p) const;\n-\n-  \/\/ Mapping from object start array entry to address of first word\n-  HeapWord* addr_for_entry(const uint8_t* const p) const;\n-\n@@ -115,3 +118,0 @@\n-  void verify_offset(uint8_t* card_index, uint8_t upper) const NOT_DEBUG_RETURN;\n-  void verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const NOT_DEBUG_RETURN;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -57,24 +57,0 @@\n-void G1BlockOffsetTable::set_offset_array_raw(uint8_t* addr, uint8_t offset) {\n-  Atomic::store(addr, offset);\n-}\n-\n-void G1BlockOffsetTable::set_offset_array(uint8_t* addr, uint8_t offset) {\n-  check_address(addr, \"Block offset table address out of range\");\n-  set_offset_array_raw(addr, offset);\n-}\n-\n-void G1BlockOffsetTable::set_offset_array(uint8_t* addr, HeapWord* high, HeapWord* low) {\n-  check_address(addr, \"Block offset table address out of range\");\n-  assert(high >= low, \"addresses out of order\");\n-  size_t offset = pointer_delta(high, low);\n-  check_offset(offset, \"offset too large\");\n-  set_offset_array(addr, (uint8_t)offset);\n-}\n-\n-void G1BlockOffsetTable::set_offset_array(uint8_t* left, uint8_t* right, uint8_t offset) {\n-  check_address(right, \"Right block offset table address out of range\");\n-  assert(left <= right, \"indexes out of order\");\n-  size_t num_cards = right - left + 1;\n-  memset_with_concurrent_readers(left, offset, num_cards);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"}]}