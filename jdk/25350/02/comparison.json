{"files":[{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2025, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -2199,2 +2199,2 @@\n-          __ test_bit(t0, to, 0);\n-          __ beqz(t0, L_skip_align1);\n+          __ test_bit(tmp_reg, to, 0);\n+          __ beqz(tmp_reg, L_skip_align1);\n@@ -2208,2 +2208,2 @@\n-          __ test_bit(t0, to, 1);\n-          __ beqz(t0, L_skip_align2);\n+          __ test_bit(tmp_reg, to, 1);\n+          __ beqz(tmp_reg, L_skip_align2);\n@@ -2217,2 +2217,2 @@\n-          __ test_bit(t0, to, 2);\n-          __ beqz(t0, L_skip_align4);\n+          __ test_bit(tmp_reg, to, 2);\n+          __ beqz(tmp_reg, L_skip_align4);\n@@ -2244,2 +2244,4 @@\n-    \/\/ Remaining count is less than 8 bytes and address is heapword aligned.\n-    Label L_fill_1, L_fill_2, L_exit1;\n+    \/\/ Handle copies less than 8 bytes.\n+    \/\/ Address may not be heapword aligned.\n+    Label L_fill_1, L_fill_2, L_exit;\n+    __ bind(L_fill_elements);\n@@ -2248,3 +2250,6 @@\n-        __ test_bit(t0, count, 2);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 2);\n+        __ beqz(tmp_reg, L_fill_2);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n+        __ sb(value, Address(to, 2));\n+        __ sb(value, Address(to, 3));\n@@ -2252,0 +2257,1 @@\n+\n@@ -2253,3 +2259,4 @@\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_1);\n-        __ sh(value, Address(to, 0));\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_1);\n+        __ sb(value, Address(to, 0));\n+        __ sb(value, Address(to, 1));\n@@ -2257,0 +2264,1 @@\n+\n@@ -2258,2 +2266,2 @@\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n@@ -2263,7 +2271,2 @@\n-        __ test_bit(t0, count, 1);\n-        __ beqz(t0, L_fill_2);\n-        __ sw(value, Address(to, 0));\n-        __ addi(to, to, 4);\n-        __ bind(L_fill_2);\n-        __ test_bit(t0, count, 0);\n-        __ beqz(t0, L_exit1);\n+        __ test_bit(tmp_reg, count, 1);\n+        __ beqz(tmp_reg, L_fill_2);\n@@ -2271,10 +2274,2 @@\n-        break;\n-      case T_INT:\n-        __ beqz(count, L_exit1);\n-        __ sw(value, Address(to, 0));\n-        break;\n-      default: ShouldNotReachHere();\n-    }\n-    __ bind(L_exit1);\n-    __ leave();\n-    __ ret();\n+        __ sh(value, Address(to, 2));\n+        __ addi(to, to, 4);\n@@ -2282,14 +2277,3 @@\n-    \/\/ Handle copies less than 8 bytes.\n-    Label L_loop1, L_loop2, L_exit2;\n-    __ bind(L_fill_elements);\n-    __ beqz(count, L_exit2);\n-    switch (t) {\n-      case T_BYTE:\n-        __ bind(L_loop1);\n-        __ sb(value, Address(to, 0));\n-        __ addi(to, to, 1);\n-        __ subiw(count, count, 1);\n-        __ bnez(count, L_loop1);\n-        break;\n-      case T_SHORT:\n-        __ bind(L_loop2);\n+        __ bind(L_fill_2);\n+        __ test_bit(tmp_reg, count, 0);\n+        __ beqz(tmp_reg, L_exit);\n@@ -2297,3 +2281,0 @@\n-        __ addi(to, to, 2);\n-        __ subiw(count, count, 2 >> shift);\n-        __ bnez(count, L_loop2);\n@@ -2302,0 +2283,1 @@\n+        __ beqz(count, L_exit);\n@@ -2306,1 +2288,1 @@\n-    __ bind(L_exit2);\n+    __ bind(L_exit);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":34,"deletions":52,"binary":false,"changes":86,"status":"modified"}]}