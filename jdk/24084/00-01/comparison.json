{"files":[{"patch":"@@ -69,1 +69,1 @@\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n+\n","filename":"src\/hotspot\/os\/aix\/safepointMechanism_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -386,1 +386,0 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -440,1 +439,1 @@\n-    if (!os::pd_release_memory(addr, size)) {\n+    if (!os::release_memory(addr, size)) {\n@@ -518,6 +517,2 @@\n-  {\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) != nullptr) {\n-      MemTracker::record_virtual_memory_commit((address) aligned_base, size, CALLER_PC);\n-      return aligned_base;\n-    }\n+  if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) == nullptr) {\n+    vm_exit_during_initialization(err_msg(\"Error in mapping Java heap at the given filesystem directory\"));\n@@ -525,2 +520,2 @@\n-  vm_exit_during_initialization(err_msg(\"Error in mapping Java heap at the given filesystem directory\"));\n-  return nullptr;\n+  MemTracker::record_virtual_memory_commit((address)aligned_base, size, CALLER_PC);\n+  return aligned_base;\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1054,8 +1054,3 @@\n-  {\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    mapAddress = (char *) ::mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n-    \/\/ it does not go through os api, the operation has to record from here\n-    if (mapAddress != MAP_FAILED) {\n-      MemTracker::record_virtual_memory_reserve_and_commit((address) mapAddress, size, CURRENT_PC, mtInternal);\n-    }\n-  }\n+\n+  mapAddress = (char*)::mmap(nullptr, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n+\n@@ -1080,0 +1075,2 @@\n+  \/\/ it does not go through os api, the operation has to record from here\n+  MemTracker::record_virtual_memory_reserve_and_commit((address)mapAddress, size, CURRENT_PC, mtInternal);\n@@ -1090,1 +1087,1 @@\n-  {\n+  if (MemTracker::enabled()) {\n@@ -1096,0 +1093,2 @@\n+  } else {\n+    res = ::munmap(addr, bytes);\n@@ -1210,4 +1209,0 @@\n-  char* mapAddress;\n-  {\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    mapAddress = (char *) ::mmap(nullptr, size, mmap_prot, MAP_SHARED, fd, 0);\n@@ -1215,5 +1210,2 @@\n-    \/\/ it does not go through os api, the operation has to record from here\n-    if (mapAddress != MAP_FAILED) {\n-      MemTracker::record_virtual_memory_reserve_and_commit((address) mapAddress, size, CURRENT_PC, mtInternal);\n-    }\n-  }\n+  char* mapAddress = (char*)::mmap(nullptr, size, mmap_prot, MAP_SHARED, fd, 0);\n+\n@@ -1231,0 +1223,3 @@\n+  \/\/ it does not go through os api, the operation has to record from here\n+  MemTracker::record_virtual_memory_reserve_and_commit((address)mapAddress, size, CURRENT_PC, mtInternal);\n+\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3006,1 +3006,1 @@\n-char* os::win32::allocate_pages_individually(size_t bytes, char* addr, DWORD flags,\n+static char* allocate_pages_individually(size_t bytes, char* addr, DWORD flags,\n@@ -3008,1 +3008,1 @@\n-                                         bool should_inject_error) {\n+                                         bool should_inject_error = false) {\n@@ -3031,1 +3031,2 @@\n-  os::pd_release_memory(p_buf, bytes + chunk_size);\n+  MemTracker::record_virtual_memory_reserve((address)p_buf, size_of_reserve, CALLER_PC);\n+  os::release_memory(p_buf, bytes + chunk_size);\n@@ -3087,1 +3088,6 @@\n-        os::pd_release_memory(p_buf, bytes_to_release);\n+        \/\/ NMT has yet to record any individual blocks, so it\n+        \/\/ need to create a dummy 'reserve' record to match\n+        \/\/ the release.\n+        MemTracker::record_virtual_memory_reserve((address)p_buf,\n+                                                  bytes_to_release, CALLER_PC);\n+        os::release_memory(p_buf, bytes_to_release);\n@@ -3316,1 +3322,1 @@\n-    res = os::win32::allocate_pages_individually(bytes, addr, MEM_RESERVE, PAGE_READWRITE);\n+    res = allocate_pages_individually(bytes, addr, MEM_RESERVE, PAGE_READWRITE);\n@@ -3322,2 +3328,1 @@\n-      fileStream fs(defaultStream::output_stream());\n-      fs.print_cr(\"reserve_memory of %zx bytes took \" JLONG_FORMAT \" ms (\" JLONG_FORMAT \" ticks)\", bytes,\n+      tty->print_cr(\"reserve_memory of %zx bytes took \" JLONG_FORMAT \" ms (\" JLONG_FORMAT \" ticks)\", bytes,\n@@ -3360,1 +3365,1 @@\n-  char * p_buf = os::win32::allocate_pages_individually(size, req_addr, flags, prot, LargePagesIndividualAllocationInjectError);\n+  char * p_buf = allocate_pages_individually(size, req_addr, flags, prot, LargePagesIndividualAllocationInjectError);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-  static char*  allocate_pages_individually(size_t bytes, char* addr, DWORD flags,\n-    DWORD prot, bool should_inject_error = false);\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1480,1 +1480,0 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -1630,1 +1629,0 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -1805,4 +1803,8 @@\n-  \/\/ it does not go through os api, the operation has to record from here\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n-  remove_file_mapping(addr);\n-  MemTracker::record_virtual_memory_release(addr, bytes);\n+  if (MemTracker::enabled()) {\n+    \/\/ it does not go through os api, the operation has to record from here\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    remove_file_mapping(addr);\n+    MemTracker::record_virtual_memory_release(addr, bytes);\n+  } else {\n+    remove_file_mapping(addr);\n+  }\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -145,9 +145,3 @@\n-  {\n-    \/\/ Reserve address space\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    if (!pd_reserve(addr, size)) {\n-      return false;\n-    }\n-\n-    \/\/ Register address views with native memory tracker\n-    ZNMT::reserve(addr, size);\n+  \/\/ Reserve address space\n+  if (!pd_reserve(addr, size)) {\n+    return false;\n@@ -156,0 +150,3 @@\n+  \/\/ Register address views with native memory tracker\n+  ZNMT::reserve(addr, size);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemory.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+      NmtVirtualMemoryLocker nvml;\n@@ -158,0 +159,1 @@\n+      NmtVirtualMemoryLocker nvml;\n@@ -168,0 +170,1 @@\n+      NmtVirtualMemoryLocker nvml;\n@@ -295,1 +298,1 @@\n-    NmtVirtualMemoryLocker(): _cml(NmtVirtualMemory_lock, _safe_to_use && enabled(), Mutex::_no_safepoint_check_flag){}\n+    NmtVirtualMemoryLocker(): _cml(NmtVirtualMemory_lock, _safe_to_use, Mutex::_no_safepoint_check_flag){}\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"utilities\/defaultStream.hpp\"\n@@ -401,2 +400,1 @@\n-      fileStream fs(defaultStream::output_stream());\n-      fs.print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), memory tag %u.\\n\"\n+      tty->print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), memory tag %u.\\n\"\n@@ -407,4 +405,4 @@\n-        fs.print_cr(\"Existing region allocated from:\");\n-        reserved_rgn->call_stack()->print_on(&fs);\n-        fs.print_cr(\"New region allocated from:\");\n-        stack.print_on(&fs);\n+        tty->print_cr(\"Existing region allocated from:\");\n+        reserved_rgn->call_stack()->print_on(tty);\n+        tty->print_cr(\"New region allocated from:\");\n+        stack.print_on(tty);\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1916,6 +1916,1 @@\n-  char* result;\n-  {\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    result = pd_reserve_memory(bytes, executable);\n-    MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC, mem_tag);\n-  }\n+  char* result = pd_reserve_memory(bytes, executable);\n@@ -1923,0 +1918,1 @@\n+    MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC, mem_tag);\n@@ -1931,6 +1927,1 @@\n-  char *result;\n-  {\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    result = SimulateFullAddressSpace ? nullptr : pd_attempt_reserve_memory_at(addr, bytes, executable);\n-    MemTracker::record_virtual_memory_reserve((address) result, bytes, CALLER_PC, mem_tag);\n-  }\n+  char* result = SimulateFullAddressSpace ? nullptr : pd_attempt_reserve_memory_at(addr, bytes, executable);\n@@ -1938,0 +1929,1 @@\n+    MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC, mem_tag);\n@@ -2117,11 +2109,9 @@\n-  {\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    \/\/ Now reserve\n-    for (unsigned i = 0; result == nullptr && i < num_attempts; i++) {\n-      const unsigned candidate_offset = points[i];\n-      char *const candidate = lo_att + candidate_offset * alignment_adjusted;\n-      assert(candidate <= hi_att, \"Invalid offset %u (\" ARGSFMT \")\", candidate_offset, ARGSFMTARGS);\n-      result = SimulateFullAddressSpace ? nullptr : os::pd_attempt_reserve_memory_at(candidate, bytes, false);\n-      if (!result) {\n-        log_trace(os, map)(\"Failed to attach at \" PTR_FORMAT, p2i(candidate));\n-      }\n+\n+  \/\/ Now reserve\n+  for (unsigned i = 0; result == nullptr && i < num_attempts; i++) {\n+    const unsigned candidate_offset = points[i];\n+    char* const candidate = lo_att + candidate_offset * alignment_adjusted;\n+    assert(candidate <= hi_att, \"Invalid offset %u (\" ARGSFMT \")\", candidate_offset, ARGSFMTARGS);\n+    result = SimulateFullAddressSpace ? nullptr : os::pd_attempt_reserve_memory_at(candidate, bytes, false);\n+    if (!result) {\n+      log_trace(os, map)(\"Failed to attach at \" PTR_FORMAT, p2i(candidate));\n@@ -2129,1 +2119,0 @@\n-    MemTracker::record_virtual_memory_reserve((address) result, bytes, CALLER_PC);\n@@ -2143,0 +2132,1 @@\n+    MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);\n@@ -2173,1 +2163,0 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2187,8 +2176,1 @@\n-  bool res;\n-  {\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    res = os::pd_commit_memory(addr, size, alignment_hint, executable);\n-    if (res) {\n-      MemTracker::record_virtual_memory_commit((address)addr, size, CALLER_PC);\n-    }\n-  }\n+  bool res = os::pd_commit_memory(addr, size, alignment_hint, executable);\n@@ -2196,0 +2178,1 @@\n+    MemTracker::record_virtual_memory_commit((address)addr, size, CALLER_PC);\n@@ -2206,1 +2189,0 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2214,1 +2196,0 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2219,0 +2200,7 @@\n+\/\/ The scope of NmtVirtualMemoryLocker covers both pd_uncommit_memory and record_virtual_memory_uncommit because\n+\/\/ these operations must happen atomically to avoid races. For example, if Thread_1 were to uncommit a region, but\n+\/\/ before Thread_1 can update NMT accounting, Thead_2 commits overlapping the same region and updates NMT,\n+\/\/ then Thread_1 finishes updating NMT. This would result in NMT perceiving part of the region being uncommited,\n+\/\/ when it is actually committed. The opposite scenario is not guarded against. pd_commit_memory and\n+\/\/ record_virtual_memory_commit do not happen atomically. We assume that there is some external synchronization\n+\/\/ that prevents a region from being uncommitted before it is finished being committed.\n@@ -2222,1 +2210,1 @@\n-  {\n+  if (MemTracker::enabled()) {\n@@ -2228,0 +2216,2 @@\n+  } else {\n+    res = pd_uncommit_memory(addr, bytes, executable);\n@@ -2239,0 +2229,7 @@\n+\/\/ The scope of NmtVirtualMemoryLocker covers both pd_release_memory and record_virtual_memory_release because\n+\/\/ these operations must happen atomically to avoid races. For example, Thread_1 releases a range, but before\n+\/\/ Thread_1 can update NMT accounting, Thread_2 reserves the same range and accounts it with NMT,\n+\/\/ then Thread_1 finishes updating NMT.  This would cause NMT to perceive the range as released, when it is\n+\/\/ actually reserved. The opposite scenario is not guarded against. pd_reserve_memory and\n+\/\/ record_virtual_memory_reserve do not happen atomically. We assume that there is some external synchronization\n+\/\/ that prevents a region from being released before it is finished being reserved.\n@@ -2242,1 +2239,1 @@\n-  {\n+  if (MemTracker::enabled()) {\n@@ -2248,0 +2245,2 @@\n+  } else {\n+    res = pd_release_memory(addr, bytes);\n@@ -2298,1 +2297,0 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2300,1 +2298,3 @@\n-  MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC, mem_tag);\n+  if (result != nullptr) {\n+    MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC, mem_tag);\n+  }\n@@ -2305,1 +2305,0 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2307,1 +2306,3 @@\n-  MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, mem_tag);\n+  if (result != nullptr) {\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, mem_tag);\n+  }\n@@ -2314,1 +2315,0 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2316,1 +2316,3 @@\n-  MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, mem_tag);\n+  if (result != nullptr) {\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, mem_tag);\n+  }\n@@ -2322,4 +2324,8 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n-  result = pd_unmap_memory(addr, bytes);\n-  if (result) {\n-    MemTracker::record_virtual_memory_release(addr, bytes);\n+  if (MemTracker::enabled()) {\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    result = pd_unmap_memory(addr, bytes);\n+    if (result) {\n+      MemTracker::record_virtual_memory_release(addr, bytes);\n+    }\n+  } else {\n+    result = pd_unmap_memory(addr, bytes);\n@@ -2342,6 +2348,2 @@\n-  char* result;\n-  {\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    result = pd_reserve_memory_special(size, alignment, page_size, addr, executable);\n-    MemTracker::record_virtual_memory_reserve_and_commit((address) result, size, CALLER_PC);\n-  }\n+\n+  char* result = pd_reserve_memory_special(size, alignment, page_size, addr, executable);\n@@ -2350,0 +2352,1 @@\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, size, CALLER_PC);\n@@ -2360,4 +2363,8 @@\n-  MemTracker::NmtVirtualMemoryLocker nvml;\n-  res = pd_release_memory_special(addr, bytes);\n-  if (res) {\n-    MemTracker::record_virtual_memory_release(addr, bytes);\n+  if (MemTracker::enabled()) {\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    res = pd_release_memory_special(addr, bytes);\n+    if (res) {\n+      MemTracker::record_virtual_memory_release(addr, bytes);\n+    }\n+  } else {\n+    res = pd_release_memory_special(addr, bytes);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":64,"deletions":57,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -1150,1 +1150,0 @@\n-\n@@ -1154,1 +1153,1 @@\n-  const size_t size = strlen(letters) +1;\n+  const size_t size = strlen(letters) + 1;\n@@ -1163,1 +1162,1 @@\n-  EXPECT_TRUE(strcmp(letters, result)==0);\n+  EXPECT_TRUE(strcmp(letters, result) == 0);\n@@ -1170,1 +1169,1 @@\n-  const size_t size = strlen(letters) +1;\n+  const size_t size = strlen(letters) + 1;\n@@ -1179,1 +1178,1 @@\n-  EXPECT_TRUE(strcmp(letters, result)==0);\n+  EXPECT_TRUE(strcmp(letters, result) == 0);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"threadHelper.inline.hpp\"\n@@ -574,61 +573,0 @@\n-\n-#ifdef ASSERT\n-TEST_VM_ASSERT_MSG(NMT_VirtualMemoryTracker, bad_reserve, \"Error: ShouldNotReachHere\") {\n-  if (MemTracker::tracking_level() >= NMT_summary) {\n-    const size_t size = 4 * os::vm_page_size();\n-\n-    address base = (address)0x1234;\n-    address frame = (address)0x1235;\n-    NativeCallStack stack(&frame, 1);\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-\n-    ASSERT_EQ(VirtualMemoryTracker::add_reserved_region(base, size, stack, mtTest), true);\n-    \/\/ This operation should fail, but should not result in NMT\/tty lock rank errors.\n-    ASSERT_EQ(VirtualMemoryTracker::add_reserved_region(base, size - 1, stack, mtTest), false);\n-  } else {\n-    tty->print_cr(\"skipped.\");\n-    ShouldNotReachHere();\n-  }\n-}\n-#endif\n-\n-\n-TEST_VM(NMT_VirtualMemoryTracker, reserved_region_accounting_atomicity) {\n-  if (MemTracker::tracking_level() >= NMT_summary) {\n-    \/\/ This tests whether virtual memory reserve operations are atomic with NMT accounting.\n-    const size_t page_sz = os::vm_page_size();\n-    const size_t size = 4 * page_sz;\n-    volatile bool _proceed;\n-    char* base;\n-\n-    auto release_memory = [&](Thread*, int) {\n-        Atomic::release_store_fence(&_proceed, true);\n-        os::release_memory(base, size);\n-    };\n-\n-    for(int i = 0; i < 10; i++) {\n-      \/\/ First, reserve a region.\n-      base = os::reserve_memory(size, false, mtTest);\n-      ASSERT_NE(base, (char*) nullptr);\n-\n-      TestThreadGroup<decltype(release_memory)> release_memory_thread{release_memory, 1};\n-      \/\/ T2 will first release the region, then update NMT accounting. This should be atomic.\n-      release_memory_thread.doit();\n-      while(!Atomic::load_acquire(&_proceed));\n-      \/\/ T1 tries to reserve the same region between when T2 releases it and updates NMT accounting.\n-      char* second_reservation = os::attempt_reserve_memory_at(base, size);\n-      release_memory_thread.join();\n-\n-      if(second_reservation != nullptr){\n-        \/\/ If the 2nd reservation succeeded, then NMT should have recorded the region as reserved.\n-        \/\/ If NMT views the region as already released, then T2's procedure of releasing the region and updating NMT accounting is not atomic.\n-        MemTracker::NmtVirtualMemoryLocker nvml;\n-        ASSERT_TRUE(VirtualMemoryTracker::remove_released_region((address) base, size));\n-      } else {\n-        \/\/ If the 2nd reservation failed, then release_memory_thread was too slow.\n-      }\n-    }\n-  } else {\n-    tty->print_cr(\"skipped.\");\n-  }\n-}\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"modified"}]}