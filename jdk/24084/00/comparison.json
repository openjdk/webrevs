{"files":[{"patch":"@@ -69,1 +69,1 @@\n-\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n","filename":"src\/hotspot\/os\/aix\/safepointMechanism_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -386,0 +386,1 @@\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -439,1 +440,1 @@\n-    if (!os::release_memory(addr, size)) {\n+    if (!os::pd_release_memory(addr, size)) {\n@@ -517,2 +518,6 @@\n-  if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) == nullptr) {\n-    vm_exit_during_initialization(err_msg(\"Error in mapping Java heap at the given filesystem directory\"));\n+  {\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) != nullptr) {\n+      MemTracker::record_virtual_memory_commit((address) aligned_base, size, CALLER_PC);\n+      return aligned_base;\n+    }\n@@ -520,2 +525,2 @@\n-  MemTracker::record_virtual_memory_commit((address)aligned_base, size, CALLER_PC);\n-  return aligned_base;\n+  vm_exit_during_initialization(err_msg(\"Error in mapping Java heap at the given filesystem directory\"));\n+  return nullptr;\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1054,3 +1054,8 @@\n-\n-  mapAddress = (char*)::mmap(nullptr, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n-\n+  {\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    mapAddress = (char *) ::mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n+    \/\/ it does not go through os api, the operation has to record from here\n+    if (mapAddress != MAP_FAILED) {\n+      MemTracker::record_virtual_memory_reserve_and_commit((address) mapAddress, size, CURRENT_PC, mtInternal);\n+    }\n+  }\n@@ -1075,2 +1080,0 @@\n-  \/\/ it does not go through os api, the operation has to record from here\n-  MemTracker::record_virtual_memory_reserve_and_commit((address)mapAddress, size, CURRENT_PC, mtInternal);\n@@ -1087,1 +1090,1 @@\n-  if (MemTracker::enabled()) {\n+  {\n@@ -1093,2 +1096,0 @@\n-  } else {\n-    res = ::munmap(addr, bytes);\n@@ -1209,0 +1210,4 @@\n+  char* mapAddress;\n+  {\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    mapAddress = (char *) ::mmap(nullptr, size, mmap_prot, MAP_SHARED, fd, 0);\n@@ -1210,2 +1215,5 @@\n-  char* mapAddress = (char*)::mmap(nullptr, size, mmap_prot, MAP_SHARED, fd, 0);\n-\n+    \/\/ it does not go through os api, the operation has to record from here\n+    if (mapAddress != MAP_FAILED) {\n+      MemTracker::record_virtual_memory_reserve_and_commit((address) mapAddress, size, CURRENT_PC, mtInternal);\n+    }\n+  }\n@@ -1223,3 +1231,0 @@\n-  \/\/ it does not go through os api, the operation has to record from here\n-  MemTracker::record_virtual_memory_reserve_and_commit((address)mapAddress, size, CURRENT_PC, mtInternal);\n-\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3006,1 +3006,1 @@\n-static char* allocate_pages_individually(size_t bytes, char* addr, DWORD flags,\n+char* os::win32::allocate_pages_individually(size_t bytes, char* addr, DWORD flags,\n@@ -3008,1 +3008,1 @@\n-                                         bool should_inject_error = false) {\n+                                         bool should_inject_error) {\n@@ -3031,2 +3031,1 @@\n-  MemTracker::record_virtual_memory_reserve((address)p_buf, size_of_reserve, CALLER_PC);\n-  os::release_memory(p_buf, bytes + chunk_size);\n+  os::pd_release_memory(p_buf, bytes + chunk_size);\n@@ -3088,6 +3087,1 @@\n-        \/\/ NMT has yet to record any individual blocks, so it\n-        \/\/ need to create a dummy 'reserve' record to match\n-        \/\/ the release.\n-        MemTracker::record_virtual_memory_reserve((address)p_buf,\n-                                                  bytes_to_release, CALLER_PC);\n-        os::release_memory(p_buf, bytes_to_release);\n+        os::pd_release_memory(p_buf, bytes_to_release);\n@@ -3322,1 +3316,1 @@\n-    res = allocate_pages_individually(bytes, addr, MEM_RESERVE, PAGE_READWRITE);\n+    res = os::win32::allocate_pages_individually(bytes, addr, MEM_RESERVE, PAGE_READWRITE);\n@@ -3328,1 +3322,2 @@\n-      tty->print_cr(\"reserve_memory of %zx bytes took \" JLONG_FORMAT \" ms (\" JLONG_FORMAT \" ticks)\", bytes,\n+      fileStream fs(defaultStream::output_stream());\n+      fs.print_cr(\"reserve_memory of %zx bytes took \" JLONG_FORMAT \" ms (\" JLONG_FORMAT \" ticks)\", bytes,\n@@ -3365,1 +3360,1 @@\n-  char * p_buf = allocate_pages_individually(size, req_addr, flags, prot, LargePagesIndividualAllocationInjectError);\n+  char * p_buf = os::win32::allocate_pages_individually(size, req_addr, flags, prot, LargePagesIndividualAllocationInjectError);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+  static char*  allocate_pages_individually(size_t bytes, char* addr, DWORD flags,\n+    DWORD prot, bool should_inject_error = false);\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1480,0 +1480,1 @@\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -1629,0 +1630,1 @@\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -1803,8 +1805,4 @@\n-  if (MemTracker::enabled()) {\n-    \/\/ it does not go through os api, the operation has to record from here\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    remove_file_mapping(addr);\n-    MemTracker::record_virtual_memory_release(addr, bytes);\n-  } else {\n-    remove_file_mapping(addr);\n-  }\n+  \/\/ it does not go through os api, the operation has to record from here\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n+  remove_file_mapping(addr);\n+  MemTracker::record_virtual_memory_release(addr, bytes);\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -145,4 +145,6 @@\n-  \/\/ Reserve address space\n-  if (!pd_reserve(addr, size)) {\n-    return false;\n-  }\n+  {\n+    \/\/ Reserve address space\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    if (!pd_reserve(addr, size)) {\n+      return false;\n+    }\n@@ -150,2 +152,3 @@\n-  \/\/ Register address views with native memory tracker\n-  ZNMT::reserve(addr, size);\n+    \/\/ Register address views with native memory tracker\n+    ZNMT::reserve(addr, size);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zVirtualMemory.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -133,1 +133,0 @@\n-      NmtVirtualMemoryLocker nvml;\n@@ -159,1 +158,0 @@\n-      NmtVirtualMemoryLocker nvml;\n@@ -170,1 +168,0 @@\n-      NmtVirtualMemoryLocker nvml;\n@@ -298,1 +295,1 @@\n-    NmtVirtualMemoryLocker(): _cml(NmtVirtualMemory_lock, _safe_to_use, Mutex::_no_safepoint_check_flag){}\n+    NmtVirtualMemoryLocker(): _cml(NmtVirtualMemory_lock, _safe_to_use && enabled(), Mutex::_no_safepoint_check_flag){}\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/defaultStream.hpp\"\n@@ -400,1 +401,2 @@\n-      tty->print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), memory tag %u.\\n\"\n+      fileStream fs(defaultStream::output_stream());\n+      fs.print_cr(\"Error: existing region: [\" INTPTR_FORMAT \"-\" INTPTR_FORMAT \"), memory tag %u.\\n\"\n@@ -405,4 +407,4 @@\n-        tty->print_cr(\"Existing region allocated from:\");\n-        reserved_rgn->call_stack()->print_on(tty);\n-        tty->print_cr(\"New region allocated from:\");\n-        stack.print_on(tty);\n+        fs.print_cr(\"Existing region allocated from:\");\n+        reserved_rgn->call_stack()->print_on(&fs);\n+        fs.print_cr(\"New region allocated from:\");\n+        stack.print_on(&fs);\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1916,2 +1916,4 @@\n-  char* result = pd_reserve_memory(bytes, executable);\n-  if (result != nullptr) {\n+  char* result;\n+  {\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    result = pd_reserve_memory(bytes, executable);\n@@ -1919,0 +1921,2 @@\n+  }\n+  if (result != nullptr) {\n@@ -1927,1 +1931,6 @@\n-  char* result = SimulateFullAddressSpace ? nullptr : pd_attempt_reserve_memory_at(addr, bytes, executable);\n+  char *result;\n+  {\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    result = SimulateFullAddressSpace ? nullptr : pd_attempt_reserve_memory_at(addr, bytes, executable);\n+    MemTracker::record_virtual_memory_reserve((address) result, bytes, CALLER_PC, mem_tag);\n+  }\n@@ -1929,1 +1938,0 @@\n-    MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC, mem_tag);\n@@ -2109,9 +2117,11 @@\n-\n-  \/\/ Now reserve\n-  for (unsigned i = 0; result == nullptr && i < num_attempts; i++) {\n-    const unsigned candidate_offset = points[i];\n-    char* const candidate = lo_att + candidate_offset * alignment_adjusted;\n-    assert(candidate <= hi_att, \"Invalid offset %u (\" ARGSFMT \")\", candidate_offset, ARGSFMTARGS);\n-    result = SimulateFullAddressSpace ? nullptr : os::pd_attempt_reserve_memory_at(candidate, bytes, false);\n-    if (!result) {\n-      log_trace(os, map)(\"Failed to attach at \" PTR_FORMAT, p2i(candidate));\n+  {\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    \/\/ Now reserve\n+    for (unsigned i = 0; result == nullptr && i < num_attempts; i++) {\n+      const unsigned candidate_offset = points[i];\n+      char *const candidate = lo_att + candidate_offset * alignment_adjusted;\n+      assert(candidate <= hi_att, \"Invalid offset %u (\" ARGSFMT \")\", candidate_offset, ARGSFMTARGS);\n+      result = SimulateFullAddressSpace ? nullptr : os::pd_attempt_reserve_memory_at(candidate, bytes, false);\n+      if (!result) {\n+        log_trace(os, map)(\"Failed to attach at \" PTR_FORMAT, p2i(candidate));\n+      }\n@@ -2119,0 +2129,1 @@\n+    MemTracker::record_virtual_memory_reserve((address) result, bytes, CALLER_PC);\n@@ -2132,1 +2143,0 @@\n-    MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);\n@@ -2163,0 +2173,1 @@\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2176,1 +2187,8 @@\n-  bool res = os::pd_commit_memory(addr, size, alignment_hint, executable);\n+  bool res;\n+  {\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    res = os::pd_commit_memory(addr, size, alignment_hint, executable);\n+    if (res) {\n+      MemTracker::record_virtual_memory_commit((address)addr, size, CALLER_PC);\n+    }\n+  }\n@@ -2178,1 +2196,0 @@\n-    MemTracker::record_virtual_memory_commit((address)addr, size, CALLER_PC);\n@@ -2189,0 +2206,1 @@\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2196,0 +2214,1 @@\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2203,1 +2222,1 @@\n-  if (MemTracker::enabled()) {\n+  {\n@@ -2209,2 +2228,0 @@\n-  } else {\n-    res = pd_uncommit_memory(addr, bytes, executable);\n@@ -2225,1 +2242,1 @@\n-  if (MemTracker::enabled()) {\n+  {\n@@ -2231,2 +2248,0 @@\n-  } else {\n-    res = pd_release_memory(addr, bytes);\n@@ -2283,0 +2298,1 @@\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2284,3 +2300,1 @@\n-  if (result != nullptr) {\n-    MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC, mem_tag);\n-  }\n+  MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC, mem_tag);\n@@ -2291,0 +2305,1 @@\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2292,3 +2307,1 @@\n-  if (result != nullptr) {\n-    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, mem_tag);\n-  }\n+  MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, mem_tag);\n@@ -2301,0 +2314,1 @@\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n@@ -2302,3 +2316,1 @@\n-  if (result != nullptr) {\n-    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, mem_tag);\n-  }\n+  MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, mem_tag);\n@@ -2310,8 +2322,4 @@\n-  if (MemTracker::enabled()) {\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    result = pd_unmap_memory(addr, bytes);\n-    if (result) {\n-      MemTracker::record_virtual_memory_release(addr, bytes);\n-    }\n-  } else {\n-    result = pd_unmap_memory(addr, bytes);\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n+  result = pd_unmap_memory(addr, bytes);\n+  if (result) {\n+    MemTracker::record_virtual_memory_release(addr, bytes);\n@@ -2334,2 +2342,6 @@\n-\n-  char* result = pd_reserve_memory_special(size, alignment, page_size, addr, executable);\n+  char* result;\n+  {\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+    result = pd_reserve_memory_special(size, alignment, page_size, addr, executable);\n+    MemTracker::record_virtual_memory_reserve_and_commit((address) result, size, CALLER_PC);\n+  }\n@@ -2338,1 +2350,0 @@\n-    MemTracker::record_virtual_memory_reserve_and_commit((address)result, size, CALLER_PC);\n@@ -2349,8 +2360,4 @@\n-  if (MemTracker::enabled()) {\n-    MemTracker::NmtVirtualMemoryLocker nvml;\n-    res = pd_release_memory_special(addr, bytes);\n-    if (res) {\n-      MemTracker::record_virtual_memory_release(addr, bytes);\n-    }\n-  } else {\n-    res = pd_release_memory_special(addr, bytes);\n+  MemTracker::NmtVirtualMemoryLocker nvml;\n+  res = pd_release_memory_special(addr, bytes);\n+  if (res) {\n+    MemTracker::record_virtual_memory_release(addr, bytes);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":57,"deletions":50,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -1116,0 +1116,68 @@\n+\n+TEST_VM(os, commit_memory_or_exit) {\n+  const size_t page_sz = os::vm_page_size();\n+  const size_t size = 16 * page_sz;\n+  const char* letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+\n+  char* base = os::reserve_memory(size, false, mtTest);\n+  ASSERT_NE(base, (char*) nullptr);\n+  os::commit_memory_or_exit(base, size, false, \"Commit failed.\");\n+  strcpy(base, letters);\n+  ASSERT_TRUE(os::uncommit_memory(base, size, false));\n+  os::commit_memory_or_exit(base, size, page_sz, false, \"Commit with alignment hint failed.\");\n+  strcpy(base, letters);\n+  ASSERT_TRUE(os::uncommit_memory(base, size, false));\n+  EXPECT_TRUE(os::release_memory(base, size));\n+}\n+\n+TEST_VM(os, map_memory_to_file) {\n+  const char* letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+  const size_t size = strlen(letters) +1;\n+\n+  int fd = os::open(\"map_memory_to_file.txt\", O_RDWR | O_CREAT, 0666);\n+  EXPECT_TRUE(fd > 0);\n+  EXPECT_TRUE(os::write(fd, letters, size));\n+\n+  char* result = os::map_memory_to_file(size, fd, mtTest);\n+  EXPECT_TRUE(result != nullptr);\n+\n+  EXPECT_TRUE(strcmp(letters, result)==0);\n+\n+  EXPECT_TRUE(os::unmap_memory(result, size));\n+  ::close(fd);\n+}\n+\n+\n+TEST_VM(os, map_unmap_memory) {\n+  const char* letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+  const char* path = \"map_unmap_memory.txt\";\n+  const size_t size = strlen(letters) +1;\n+  int fd = os::open(path, O_RDWR | O_CREAT, 0666);\n+  EXPECT_TRUE(fd > 0);\n+  EXPECT_TRUE(os::write(fd, letters, size));\n+  ::close(fd);\n+\n+  fd = os::open(path, O_RDONLY, 0666);\n+  char* result = os::map_memory(fd, path, 0, nullptr, size, true, false, mtTest);\n+  EXPECT_TRUE(result != nullptr);\n+  EXPECT_TRUE(strcmp(letters, result)==0);\n+  EXPECT_TRUE(os::unmap_memory(result, size));\n+  ::close(fd);\n+}\n+\n+TEST_VM(os, map_memory_to_file_aligned) {\n+  const char* letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+  const size_t size = strlen(letters) +1;\n+\n+  int fd = os::open(\"map_memory_to_file.txt\", O_RDWR | O_CREAT, 0666);\n+  EXPECT_TRUE(fd > 0);\n+  EXPECT_TRUE(os::write(fd, letters, size));\n+\n+  char* result = os::map_memory_to_file_aligned(os::vm_allocation_granularity(), os::vm_allocation_granularity(), fd, mtTest);\n+  EXPECT_TRUE(result != nullptr);\n+\n+  EXPECT_TRUE(strcmp(letters, result)==0);\n+\n+  EXPECT_TRUE(os::unmap_memory(result, os::vm_allocation_granularity()));\n+  ::close(fd);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"threadHelper.inline.hpp\"\n@@ -573,0 +574,61 @@\n+\n+#ifdef ASSERT\n+TEST_VM_ASSERT_MSG(NMT_VirtualMemoryTracker, bad_reserve, \"Error: ShouldNotReachHere\") {\n+  if (MemTracker::tracking_level() >= NMT_summary) {\n+    const size_t size = 4 * os::vm_page_size();\n+\n+    address base = (address)0x1234;\n+    address frame = (address)0x1235;\n+    NativeCallStack stack(&frame, 1);\n+    MemTracker::NmtVirtualMemoryLocker nvml;\n+\n+    ASSERT_EQ(VirtualMemoryTracker::add_reserved_region(base, size, stack, mtTest), true);\n+    \/\/ This operation should fail, but should not result in NMT\/tty lock rank errors.\n+    ASSERT_EQ(VirtualMemoryTracker::add_reserved_region(base, size - 1, stack, mtTest), false);\n+  } else {\n+    tty->print_cr(\"skipped.\");\n+    ShouldNotReachHere();\n+  }\n+}\n+#endif\n+\n+\n+TEST_VM(NMT_VirtualMemoryTracker, reserved_region_accounting_atomicity) {\n+  if (MemTracker::tracking_level() >= NMT_summary) {\n+    \/\/ This tests whether virtual memory reserve operations are atomic with NMT accounting.\n+    const size_t page_sz = os::vm_page_size();\n+    const size_t size = 4 * page_sz;\n+    volatile bool _proceed;\n+    char* base;\n+\n+    auto release_memory = [&](Thread*, int) {\n+        Atomic::release_store_fence(&_proceed, true);\n+        os::release_memory(base, size);\n+    };\n+\n+    for(int i = 0; i < 10; i++) {\n+      \/\/ First, reserve a region.\n+      base = os::reserve_memory(size, false, mtTest);\n+      ASSERT_NE(base, (char*) nullptr);\n+\n+      TestThreadGroup<decltype(release_memory)> release_memory_thread{release_memory, 1};\n+      \/\/ T2 will first release the region, then update NMT accounting. This should be atomic.\n+      release_memory_thread.doit();\n+      while(!Atomic::load_acquire(&_proceed));\n+      \/\/ T1 tries to reserve the same region between when T2 releases it and updates NMT accounting.\n+      char* second_reservation = os::attempt_reserve_memory_at(base, size);\n+      release_memory_thread.join();\n+\n+      if(second_reservation != nullptr){\n+        \/\/ If the 2nd reservation succeeded, then NMT should have recorded the region as reserved.\n+        \/\/ If NMT views the region as already released, then T2's procedure of releasing the region and updating NMT accounting is not atomic.\n+        MemTracker::NmtVirtualMemoryLocker nvml;\n+        ASSERT_TRUE(VirtualMemoryTracker::remove_released_region((address) base, size));\n+      } else {\n+        \/\/ If the 2nd reservation failed, then release_memory_thread was too slow.\n+      }\n+    }\n+  } else {\n+    tty->print_cr(\"skipped.\");\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"}]}