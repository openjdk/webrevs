{"files":[{"patch":"@@ -2200,0 +2200,7 @@\n+\/\/ The scope of NmtVirtualMemoryLocker covers both pd_uncommit_memory and record_virtual_memory_uncommit because\n+\/\/ these operations must happen atomically to avoid races. For example, if Thread_1 were to uncommit a region, but\n+\/\/ before Thread_1 can update NMT accounting, Thead_2 commits overlapping the same region and updates NMT,\n+\/\/ then Thread_1 finishes updating NMT. This would result in NMT perceiving part of the region being uncommited,\n+\/\/ when it is actually committed. The opposite scenario is not guarded against. pd_commit_memory and\n+\/\/ record_virtual_memory_commit do not happen atomically. We assume that there is some external synchronization\n+\/\/ that prevents a region from being uncommitted before it is finished being committed.\n@@ -2222,0 +2229,7 @@\n+\/\/ The scope of NmtVirtualMemoryLocker covers both pd_release_memory and record_virtual_memory_release because\n+\/\/ these operations must happen atomically to avoid races. For example, Thread_1 releases a range, but before\n+\/\/ Thread_1 can update NMT accounting, Thread_2 reserves the same range and accounts it with NMT,\n+\/\/ then Thread_1 finishes updating NMT.  This would cause NMT to perceive the range as released, when it is\n+\/\/ actually reserved. The opposite scenario is not guarded against. pd_reserve_memory and\n+\/\/ record_virtual_memory_reserve do not happen atomically. We assume that there is some external synchronization\n+\/\/ that prevents a region from being released before it is finished being reserved.\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1116,0 +1116,69 @@\n+\n+TEST_VM(os, commit_memory_or_exit) {\n+  const size_t page_sz = os::vm_page_size();\n+  const size_t size = 16 * page_sz;\n+  const char* letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+\n+  char* base = os::reserve_memory(size, false, mtTest);\n+  ASSERT_NE(base, (char*) nullptr);\n+  os::commit_memory_or_exit(base, size, false, \"Commit failed.\");\n+  strcpy(base, letters);\n+  ASSERT_TRUE(os::uncommit_memory(base, size, false));\n+  os::commit_memory_or_exit(base, size, page_sz, false, \"Commit with alignment hint failed.\");\n+  strcpy(base, letters);\n+  ASSERT_TRUE(os::uncommit_memory(base, size, false));\n+  EXPECT_TRUE(os::release_memory(base, size));\n+}\n+\n+#if !defined(_AIX)\n+TEST_VM(os, map_memory_to_file) {\n+  const char* letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+  const size_t size = strlen(letters) +1;\n+\n+  int fd = os::open(\"map_memory_to_file.txt\", O_RDWR | O_CREAT, 0666);\n+  EXPECT_TRUE(fd > 0);\n+  EXPECT_TRUE(os::write(fd, letters, size));\n+\n+  char* result = os::map_memory_to_file(size, fd, mtTest);\n+  EXPECT_TRUE(result != nullptr);\n+\n+  EXPECT_TRUE(strcmp(letters, result)==0);\n+\n+  EXPECT_TRUE(os::unmap_memory(result, size));\n+  ::close(fd);\n+}\n+\n+TEST_VM(os, map_unmap_memory) {\n+  const char* letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+  const char* path = \"map_unmap_memory.txt\";\n+  const size_t size = strlen(letters) + 1;\n+  int fd = os::open(path, O_RDWR | O_CREAT, 0666);\n+  EXPECT_TRUE(fd > 0);\n+  EXPECT_TRUE(os::write(fd, letters, size));\n+  ::close(fd);\n+\n+  fd = os::open(path, O_RDONLY, 0666);\n+  char* result = os::map_memory(fd, path, 0, nullptr, size, true, false, mtTest);\n+  EXPECT_TRUE(result != nullptr);\n+  EXPECT_TRUE(strcmp(letters, result) == 0);\n+  EXPECT_TRUE(os::unmap_memory(result, size));\n+  ::close(fd);\n+}\n+\n+TEST_VM(os, map_memory_to_file_aligned) {\n+  const char* letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+  const size_t size = strlen(letters) + 1;\n+\n+  int fd = os::open(\"map_memory_to_file.txt\", O_RDWR | O_CREAT, 0666);\n+  EXPECT_TRUE(fd > 0);\n+  EXPECT_TRUE(os::write(fd, letters, size));\n+\n+  char* result = os::map_memory_to_file_aligned(os::vm_allocation_granularity(), os::vm_allocation_granularity(), fd, mtTest);\n+  EXPECT_TRUE(result != nullptr);\n+\n+  EXPECT_TRUE(strcmp(letters, result) == 0);\n+\n+  EXPECT_TRUE(os::unmap_memory(result, os::vm_allocation_granularity()));\n+  ::close(fd);\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"}]}