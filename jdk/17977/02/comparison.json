{"files":[{"patch":"@@ -1129,0 +1129,4 @@\n+\/\/ Figure out which register class each belongs in: rc_int, rc_float or\n+\/\/ rc_stack.\n+enum RC { rc_bad, rc_int, rc_float, rc_predicate, rc_stack };\n+\n@@ -1907,4 +1911,0 @@\n-\/\/ Figure out which register class each belongs in: rc_int, rc_float or\n-\/\/ rc_stack.\n-enum RC { rc_bad, rc_int, rc_float, rc_predicate, rc_stack };\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1084,0 +1084,29 @@\n+OptoReg::Name ZBarrierSetAssembler::encode_float_vector_register_size(const Node* node, OptoReg::Name opto_reg) {\n+  switch (node->ideal_reg()) {\n+    case Op_RegF:\n+      \/\/ No need to refine. The original encoding is already fine to distinguish.\n+      assert(opto_reg % 4 == 0, \"Float register should only occupy a single slot\");\n+      break;\n+    \/\/ Use different encoding values of the same fp\/vector register to help distinguish different sizes.\n+    \/\/ Such as V16. The OptoReg::name and its corresponding slot value are\n+    \/\/ \"V16\": 64, \"V16_H\": 65, \"V16_J\": 66, \"V16_K\": 67.\n+    case Op_RegD:\n+    case Op_VecD:\n+      opto_reg &= ~3;\n+      opto_reg |= 1;\n+      break;\n+    case Op_VecX:\n+      opto_reg &= ~3;\n+      opto_reg |= 2;\n+      break;\n+    case Op_VecA:\n+      opto_reg &= ~3;\n+      opto_reg |= 3;\n+      break;\n+    default:\n+      assert(false, \"unexpected ideal register\");\n+      ShouldNotReachHere();\n+  }\n+  return opto_reg;\n+}\n+\n@@ -1091,1 +1120,1 @@\n-    return opto_reg & ~1;\n+    opto_reg = encode_float_vector_register_size(node, opto_reg);\n@@ -1102,0 +1131,10 @@\n+  struct RegisterData {\n+    VMReg _reg;\n+    int   _slots; \/\/ slots occupied once pushed into stack\n+\n+    \/\/ Used by GrowableArray::find()\n+    bool operator == (const RegisterData& other) {\n+      return _reg == other._reg;\n+    }\n+  };\n+\n@@ -1105,0 +1144,2 @@\n+  FloatRegSet           _neon_regs;\n+  FloatRegSet           _sve_regs;\n@@ -1109,1 +1150,4 @@\n-    \/\/ Record registers that needs to be saved\/restored\n+    int index = -1;\n+    GrowableArray<RegisterData> registers;\n+    VMReg prev_vm_reg = VMRegImpl::Bad();\n+\n@@ -1112,6 +1156,41 @@\n-      const OptoReg::Name opto_reg = rmi.next();\n-      if (OptoReg::is_reg(opto_reg)) {\n-        const VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n-        if (vm_reg->is_Register()) {\n-          _gp_regs += RegSet::of(vm_reg->as_Register());\n-        } else if (vm_reg->is_FloatRegister()) {\n+      OptoReg::Name opto_reg = rmi.next();\n+      VMReg vm_reg = OptoReg::as_VMReg(opto_reg);\n+\n+      if (vm_reg->is_Register()) {\n+        \/\/ GPR may have one or two slots in regmask\n+        \/\/ Determine whether the current vm_reg is the same physical register as the previous one\n+        if (is_same_register(vm_reg, prev_vm_reg)) {\n+          registers.at(index)._slots++;\n+        } else {\n+          RegisterData reg_data = { vm_reg, 1 };\n+          index = registers.append(reg_data);\n+        }\n+      } else if (vm_reg->is_FloatRegister()) {\n+        \/\/ We have size encoding in OptoReg of stub->live()\n+        \/\/ After encoding, float\/neon\/sve register has only one slot in regmask\n+        \/\/ Decode it to get the actual size\n+        VMReg vm_reg_base = vm_reg->as_FloatRegister()->as_VMReg();\n+        int slots = decode_float_vector_register_size(opto_reg);\n+        RegisterData reg_data = { vm_reg_base, slots };\n+        index = registers.append(reg_data);\n+      } else if (vm_reg->is_PRegister()) {\n+        \/\/ PRegister has only one slot in regmask\n+        RegisterData reg_data = { vm_reg, 1 };\n+        index = registers.append(reg_data);\n+      } else {\n+        assert(false, \"Unknown register type\");\n+        ShouldNotReachHere();\n+      }\n+      prev_vm_reg = vm_reg;\n+    }\n+\n+    \/\/ Record registers that needs to be saved\/restored\n+    for (GrowableArrayIterator<RegisterData> it = registers.begin(); it != registers.end(); ++it) {\n+      RegisterData reg_data = *it;\n+      VMReg vm_reg = reg_data._reg;\n+      int slots = reg_data._slots;\n+      if (vm_reg->is_Register()) {\n+        assert(slots == 1 || slots == 2, \"Unexpected register save size\");\n+        _gp_regs += RegSet::of(vm_reg->as_Register());\n+      } else if (vm_reg->is_FloatRegister()) {\n+        if (slots == 1 || slots == 2) {\n@@ -1119,2 +1198,2 @@\n-        } else if (vm_reg->is_PRegister()) {\n-          _p_regs += PRegSet::of(vm_reg->as_PRegister());\n+        } else if (slots == 4) {\n+          _neon_regs += FloatRegSet::of(vm_reg->as_FloatRegister());\n@@ -1122,1 +1201,2 @@\n-          fatal(\"Unknown register type\");\n+          assert(slots == Matcher::scalable_vector_reg_size(T_FLOAT), \"Unexpected register save size\");\n+          _sve_regs += FloatRegSet::of(vm_reg->as_FloatRegister());\n@@ -1124,0 +1204,3 @@\n+      } else {\n+        assert(vm_reg->is_PRegister() && slots == 1, \"Unknown register type\");\n+        _p_regs += PRegSet::of(vm_reg->as_PRegister());\n@@ -1133,0 +1216,51 @@\n+\n+    \/\/ Remove C-ABI SOE fp registers\n+    _fp_regs -= FloatRegSet::range(v8, v15);\n+  }\n+\n+  static enum RC rc_class(VMReg reg) {\n+    if (reg->is_reg()) {\n+      if (reg->is_Register()) {\n+        return rc_int;\n+      } else if (reg->is_FloatRegister()) {\n+        return rc_float;\n+      } else if (reg->is_PRegister()) {\n+        return rc_predicate;\n+      }\n+    }\n+    if (reg->is_stack()) {\n+      return rc_stack;\n+    }\n+    return rc_bad;\n+  }\n+\n+  static bool is_same_register(VMReg reg1, VMReg reg2) {\n+    if (reg1 == reg2) {\n+      return true;\n+    }\n+    if (rc_class(reg1) == rc_class(reg2)) {\n+      if (reg1->is_Register()) {\n+        return reg1->as_Register() == reg2->as_Register();\n+      } else if (reg1->is_FloatRegister()) {\n+        return reg1->as_FloatRegister() == reg2->as_FloatRegister();\n+      } else if (reg1->is_PRegister()) {\n+        return reg1->as_PRegister() == reg2->as_PRegister();\n+      }\n+    }\n+    return false;\n+  }\n+\n+  static int decode_float_vector_register_size(OptoReg::Name opto_reg) {\n+    switch (opto_reg & 3) {\n+      case 0:\n+        return 1;\n+      case 1:\n+        return 2;\n+      case 2:\n+        return 4;\n+      case 3:\n+        return Matcher::scalable_vector_reg_size(T_FLOAT);\n+      default:\n+        ShouldNotReachHere();\n+        return 0;\n+    }\n@@ -1139,0 +1273,2 @@\n+      _neon_regs(),\n+      _sve_regs(),\n@@ -1146,1 +1282,3 @@\n-    __ push_fp(_fp_regs, sp);\n+    __ push_fp(_fp_regs, sp, MacroAssembler::PushPopFp);\n+    __ push_fp(_neon_regs, sp, MacroAssembler::PushPopNeon);\n+    __ push_fp(_sve_regs, sp, MacroAssembler::PushPopSVE);\n@@ -1153,1 +1291,3 @@\n-    __ pop_fp(_fp_regs, sp);\n+    __ pop_fp(_sve_regs, sp, MacroAssembler::PushPopSVE);\n+    __ pop_fp(_neon_regs, sp, MacroAssembler::PushPopNeon);\n+    __ pop_fp(_fp_regs, sp, MacroAssembler::PushPopFp);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":154,"deletions":14,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,0 +190,3 @@\n+  OptoReg::Name encode_float_vector_register_size(const Node* node,\n+                                                  OptoReg::Name opto_reg);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2406,1 +2406,1 @@\n-int MacroAssembler::push_fp(unsigned int bitset, Register stack) {\n+int MacroAssembler::push_fp(unsigned int bitset, Register stack, FpPushPopMode mode) {\n@@ -2429,2 +2429,23 @@\n-  \/\/ SVE\n-  if (use_sve && sve_vector_size_in_bytes > 16) {\n+  if (mode == PushPopFull) {\n+    if (use_sve && sve_vector_size_in_bytes > 16) {\n+      mode = PushPopSVE;\n+    } else {\n+      mode = PushPopNeon;\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  {\n+    char buffer[48];\n+    if (mode == PushPopSVE) {\n+      snprintf(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n+    } else if (mode == PushPopNeon) {\n+      snprintf(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n+    } else {\n+      snprintf(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n+    }\n+    block_comment(buffer);\n+  }\n+#endif\n+\n+  if (mode == PushPopSVE) {\n@@ -2438,4 +2459,25 @@\n-  \/\/ NEON\n-  if (count == 1) {\n-    strq(as_FloatRegister(regs[0]), Address(pre(stack, -wordSize * 2)));\n-    return 2;\n+  if (mode == PushPopNeon) {\n+    if (count == 1) {\n+      strq(as_FloatRegister(regs[0]), Address(pre(stack, -wordSize * 2)));\n+      return 2;\n+    }\n+\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n+\n+    \/\/ Always pushing full 128 bit registers.\n+    stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -push_slots * wordSize * 2)));\n+    words_pushed += 2;\n+\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+      words_pushed += 2;\n+    }\n+\n+    if (odd) {\n+      strq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n+      words_pushed++;\n+    }\n+\n+    assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n+    return count * 2;\n@@ -2444,2 +2486,3 @@\n-  bool odd = (count & 1) == 1;\n-  int push_slots = count + (odd ? 1 : 0);\n+  if (mode == PushPopFp) {\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n@@ -2447,3 +2490,5 @@\n-  \/\/ Always pushing full 128 bit registers.\n-  stpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -push_slots * wordSize * 2)));\n-  words_pushed += 2;\n+    if (count == 1) {\n+      \/\/ Stack pointer must be 16 bytes aligned\n+      strd(as_FloatRegister(regs[0]), Address(pre(stack, -push_slots * wordSize)));\n+      return 1;\n+    }\n@@ -2451,2 +2496,1 @@\n-  for (int i = 2; i + 1 < count; i += 2) {\n-    stpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+    stpd(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(pre(stack, -push_slots * wordSize)));\n@@ -2454,1 +2498,0 @@\n-  }\n@@ -2456,3 +2499,14 @@\n-  if (odd) {\n-    strq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n-    words_pushed++;\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      stpd(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize));\n+      words_pushed += 2;\n+    }\n+\n+    if (odd) {\n+      \/\/ Stack pointer must be 16 bytes aligned\n+      strd(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize));\n+      words_pushed++;\n+    }\n+\n+    assert(words_pushed == count, \"oops, pushed != count\");\n+\n+    return count;\n@@ -2461,2 +2515,1 @@\n-  assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n-  return count * 2;\n+  return 0;\n@@ -2466,1 +2519,1 @@\n-int MacroAssembler::pop_fp(unsigned int bitset, Register stack) {\n+int MacroAssembler::pop_fp(unsigned int bitset, Register stack, FpPushPopMode mode) {\n@@ -2488,2 +2541,23 @@\n-  \/\/ SVE\n-  if (use_sve && sve_vector_size_in_bytes > 16) {\n+  if (mode == PushPopFull) {\n+    if (use_sve && sve_vector_size_in_bytes > 16) {\n+      mode = PushPopSVE;\n+    } else {\n+      mode = PushPopNeon;\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  {\n+    char buffer[48];\n+    if (mode == PushPopSVE) {\n+      snprintf(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n+    } else if (mode == PushPopNeon) {\n+      snprintf(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n+    } else {\n+      snprintf(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n+    }\n+    block_comment(buffer);\n+  }\n+#endif\n+\n+  if (mode == PushPopSVE) {\n@@ -2497,5 +2571,5 @@\n-  \/\/ NEON\n-  if (count == 1) {\n-    ldrq(as_FloatRegister(regs[0]), Address(post(stack, wordSize * 2)));\n-    return 2;\n-  }\n+  if (mode == PushPopNeon) {\n+    if (count == 1) {\n+      ldrq(as_FloatRegister(regs[0]), Address(post(stack, wordSize * 2)));\n+      return 2;\n+    }\n@@ -2503,2 +2577,2 @@\n-  bool odd = (count & 1) == 1;\n-  int push_slots = count + (odd ? 1 : 0);\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n@@ -2506,4 +2580,9 @@\n-  if (odd) {\n-    ldrq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n-    words_pushed++;\n-  }\n+    if (odd) {\n+      ldrq(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize * 2));\n+      words_pushed++;\n+    }\n+\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+      words_pushed += 2;\n+    }\n@@ -2511,2 +2590,1 @@\n-  for (int i = 2; i + 1 < count; i += 2) {\n-    ldpq(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize * 2));\n+    ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, push_slots * wordSize * 2)));\n@@ -2514,0 +2592,4 @@\n+\n+    assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n+\n+    return count * 2;\n@@ -2516,2 +2598,8 @@\n-  ldpq(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, push_slots * wordSize * 2)));\n-  words_pushed += 2;\n+  if (mode == PushPopFp) {\n+    bool odd = (count & 1) == 1;\n+    int push_slots = count + (odd ? 1 : 0);\n+\n+    if (count == 1) {\n+      ldrd(as_FloatRegister(regs[0]), Address(post(stack, push_slots * wordSize)));\n+      return 1;\n+    }\n@@ -2519,1 +2607,17 @@\n-  assert(words_pushed == count, \"oops, pushed(%d) != count(%d)\", words_pushed, count);\n+    if (odd) {\n+      ldrd(as_FloatRegister(regs[count - 1]), Address(stack, (count - 1) * wordSize));\n+      words_pushed++;\n+    }\n+\n+    for (int i = 2; i + 1 < count; i += 2) {\n+      ldpd(as_FloatRegister(regs[i]), as_FloatRegister(regs[i+1]), Address(stack, i * wordSize));\n+      words_pushed += 2;\n+    }\n+\n+    ldpd(as_FloatRegister(regs[0]), as_FloatRegister(regs[1]), Address(post(stack, push_slots * wordSize)));\n+    words_pushed += 2;\n+\n+    assert(words_pushed == count, \"oops, pushed != count\");\n+\n+    return count;\n+  }\n@@ -2521,1 +2625,1 @@\n-  return count * 2;\n+  return 0;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":144,"deletions":40,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -447,0 +447,9 @@\n+public:\n+\n+  enum FpPushPopMode {\n+    PushPopFull,\n+    PushPopSVE,\n+    PushPopNeon,\n+    PushPopFp\n+  };\n+\n@@ -456,2 +465,2 @@\n-  int push_fp(unsigned int bitset, Register stack);\n-  int pop_fp(unsigned int bitset, Register stack);\n+  int push_fp(unsigned int bitset, Register stack, FpPushPopMode mode);\n+  int pop_fp(unsigned int bitset, Register stack, FpPushPopMode mode);\n@@ -465,0 +474,1 @@\n+\n@@ -468,2 +478,2 @@\n-  void push_fp(FloatRegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }\n-  void pop_fp(FloatRegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }\n+  void push_fp(FloatRegSet regs, Register stack, FpPushPopMode mode = PushPopFull) { if (regs.bits()) push_fp(regs.bits(), stack, mode); }\n+  void pop_fp(FloatRegSet regs, Register stack, FpPushPopMode mode = PushPopFull) { if (regs.bits()) pop_fp(regs.bits(), stack, mode); }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-  assert( is_FloatRegister() && is_even(value()), \"must be\" );\n+  assert( is_FloatRegister(), \"must be\" );\n","filename":"src\/hotspot\/cpu\/aarch64\/vmreg_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,363 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/**\n+ * @test TestRegistersPushPopAtZGCLoadBarrierStub\n+ * @bug 8326541\n+ * @summary Test to verify that registers are saved and restored correctly based on\n+            the actual register usage length on aarch64 when entering load barrier stub.\n+ * @library \/test\/lib \/\n+ * @modules jdk.incubator.vector\n+ *\n+ * @requires vm.gc.ZGenerational & vm.debug\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @run driver gc.z.TestRegistersPushPopAtZGCLoadBarrierStub\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+class Inner {}\n+\n+class InnerFloat extends Inner {\n+    float data;\n+    public InnerFloat(float f) {\n+        data = f;\n+    }\n+}\n+\n+class InnerDouble extends Inner {\n+    double data;\n+    public InnerDouble(double f) {\n+        data = f;\n+    }\n+}\n+\n+class Outer {\n+    volatile Inner field;\n+    public Outer(Inner i) {\n+        field = i;\n+    }\n+}\n+\n+public class TestRegistersPushPopAtZGCLoadBarrierStub {\n+\n+    class Launcher {\n+        private final static int NUM = 1024;\n+        private final static int ITERATIONS = 20_000;\n+        private final static RandomGenerator RANDOM = RandomGeneratorFactory.getDefault().create(0);\n+        private final static Map<String, Runnable> TESTS;\n+\n+        private static float[] f_array;\n+        private static Outer f_outer;\n+        private static Outer d_outer;\n+\n+        static {\n+            f_array = new float[NUM];\n+            for (int i = 0; i < NUM; i++) {\n+                f_array[i] = RANDOM.nextFloat();\n+            }\n+\n+            InnerFloat f_inner = new InnerFloat(RANDOM.nextFloat());\n+            InnerDouble d_inner = new InnerDouble(RANDOM.nextDouble());\n+            f_outer = new Outer(f_inner);\n+            d_outer = new Outer(d_inner);\n+\n+            TESTS = new LinkedHashMap<>();\n+            TESTS.put(\"test_one_float_push_pop_at_load_barrier\", Launcher::test_one_float);\n+            TESTS.put(\"test_two_floats_push_pop_at_load_barrier\", Launcher::test_two_floats);\n+            TESTS.put(\"test_three_floats_push_pop_at_load_barrier\", Launcher::test_three_floats);\n+            TESTS.put(\"test_one_double_push_pop_at_load_barrier\", Launcher::test_one_double);\n+            TESTS.put(\"test_two_doubles_push_pop_at_load_barrier\", Launcher::test_two_doubles);\n+            TESTS.put(\"test_three_doubles_push_pop_at_load_barrier\", Launcher::test_three_doubles);\n+            TESTS.put(\"test_one_vector_128_push_pop_at_load_barrier\", Launcher::test_one_vector_128);\n+            TESTS.put(\"test_two_vectors_128_push_pop_at_load_barrier\", Launcher::test_two_vectors_128);\n+            TESTS.put(\"test_three_vectors_128_push_pop_at_load_barrier\", Launcher::test_three_vectors_128);\n+            TESTS.put(\"test_vector_max_push_pop_at_load_barrier\", Launcher::test_vector_max);\n+            TESTS.put(\"test_float_and_vector_push_pop_at_load_barrier\", Launcher::test_float_and_vector);\n+        }\n+\n+        static float test_one_float_push_pop_at_load_barrier(Outer outer, float f) {\n+            Inner inner = outer.field;\n+            return f + ((InnerFloat)inner).data;\n+        }\n+\n+        static float test_two_floats_push_pop_at_load_barrier(Outer outer, float f1, float f2) {\n+            Inner inner = outer.field;\n+            return f1 + f2 + ((InnerFloat)inner).data;\n+        }\n+\n+        static float test_three_floats_push_pop_at_load_barrier(Outer outer, float f1, float f2, float f3) {\n+            Inner inner = outer.field;\n+            return f1 + f2 + f3 + ((InnerFloat)inner).data;\n+        }\n+\n+        static double test_one_double_push_pop_at_load_barrier(Outer outer, double d) {\n+            Inner inner = outer.field;\n+            return d + ((InnerDouble)inner).data;\n+        }\n+\n+        static double test_two_doubles_push_pop_at_load_barrier(Outer outer, double d1, double d2) {\n+            Inner inner = outer.field;\n+            return d1 + d2 + ((InnerDouble)inner).data;\n+        }\n+\n+        static double test_three_doubles_push_pop_at_load_barrier(Outer outer, double d1, double d2, double d3) {\n+            Inner inner = outer.field;\n+            return d1 + d2 + d3 + ((InnerDouble)inner).data;\n+        }\n+\n+        static void test_one_vector_128_push_pop_at_load_barrier(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_128;\n+\n+            FloatVector av = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av = av.add(bv).add(value);\n+            }\n+        }\n+\n+        static void test_two_vectors_128_push_pop_at_load_barrier(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_128;\n+\n+            FloatVector av1 = FloatVector.zero(float_species);\n+            FloatVector av2 = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av1 = av1.add(bv).add(value);\n+                av2 = av2.add(av1);\n+            }\n+        }\n+\n+        static void test_three_vectors_128_push_pop_at_load_barrier(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_128;\n+\n+            FloatVector av1 = FloatVector.zero(float_species);\n+            FloatVector av2 = FloatVector.zero(float_species);\n+            FloatVector av3 = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av1 = av1.add(bv).add(value);\n+                av2 = av2.add(av1);\n+                av3 = av3.add(av2);\n+            }\n+        }\n+\n+        static void test_vector_max_push_pop_at_load_barrier(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_MAX;\n+\n+            FloatVector av = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av = av.add(bv).add(value);\n+            }\n+        }\n+\n+        static void test_float_and_vector_push_pop_at_load_barrier(float[] b, Outer outer, float f) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_MAX;\n+\n+            FloatVector av = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data + f;\n+                av = av.add(bv).add(value);\n+            }\n+        }\n+\n+        static void test_one_float() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_one_float_push_pop_at_load_barrier(f_outer, RANDOM.nextFloat());\n+            }\n+        }\n+\n+        static void test_two_floats() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_two_floats_push_pop_at_load_barrier(f_outer, RANDOM.nextFloat(), RANDOM.nextFloat());\n+            }\n+        }\n+\n+        static void test_three_floats() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_three_floats_push_pop_at_load_barrier(f_outer, RANDOM.nextFloat(), RANDOM.nextFloat(), RANDOM.nextFloat());\n+            }\n+        }\n+\n+        static void test_one_double() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_one_double_push_pop_at_load_barrier(d_outer, RANDOM.nextDouble());\n+            }\n+        }\n+\n+        static void test_two_doubles() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_two_doubles_push_pop_at_load_barrier(d_outer, RANDOM.nextDouble(), RANDOM.nextDouble());\n+            }\n+        }\n+\n+        static void test_three_doubles() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_three_doubles_push_pop_at_load_barrier(d_outer, RANDOM.nextDouble(), RANDOM.nextDouble(), RANDOM.nextDouble());\n+            }\n+        }\n+\n+        static void test_one_vector_128() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_one_vector_128_push_pop_at_load_barrier(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_two_vectors_128() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_two_vectors_128_push_pop_at_load_barrier(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_three_vectors_128() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_three_vectors_128_push_pop_at_load_barrier(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_vector_max() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_vector_max_push_pop_at_load_barrier(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_float_and_vector() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_float_and_vector_push_pop_at_load_barrier(f_array, f_outer, RANDOM.nextFloat());\n+            }\n+        }\n+\n+        public static void main(String args[]) {\n+            Runnable r = TESTS.get(args[0]);\n+            r.run();\n+        }\n+    }\n+\n+    static boolean containOnlyOneOccuranceOfKeyword(String text, String keyword) {\n+        int firstIndex = text.indexOf(keyword);\n+        int lastIndex = text.lastIndexOf(keyword);\n+        return firstIndex != -1 && firstIndex == lastIndex;\n+    }\n+\n+    \/\/ Check that registers are pushed and poped with correct register type and number\n+    static void checkPushPopRegNumberAndType(String stdout, String keyword, String expected_freg_type,\n+                                             int expected_number_of_push_pop_at_load_barrier_fregs) throws Exception {\n+        String keyString = keyword + expected_number_of_push_pop_at_load_barrier_fregs + \" \" + expected_freg_type + \" registers\";\n+        if (!containOnlyOneOccuranceOfKeyword(stdout, keyString)) {\n+            throw new RuntimeException(\"Stdout is expected to contain only one occurance of keyString: \" + \"'\" + keyString + \"'\");\n+        }\n+    }\n+\n+    static String launchJavaTestProcess(String test_name) throws Exception {\n+        ArrayList<String> command = new ArrayList<String>();\n+        command.add(\"-Xbatch\");\n+        command.add(\"-XX:LoopUnrollLimit=0\");\n+        command.add(\"-XX:-UseOnStackReplacement\");\n+        command.add(\"-XX:-TieredCompilation\");\n+        command.add(\"-XX:+UseZGC\");\n+        command.add(\"-XX:+ZGenerational\");\n+        command.add(\"--add-modules=jdk.incubator.vector\");\n+        command.add(\"-XX:CompileCommand=print,\" +  Launcher.class.getName() + \"::\" + test_name);\n+        command.add(Launcher.class.getName());\n+        command.add(test_name);\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output.getStdout();\n+    }\n+\n+    static void run_test(String test_name, String expected_freg_type, int expected_number_of_fregs,\n+                         String expected_vector_reg_type, int expected_number_of_vector_regs) throws Exception {\n+        String stdout = launchJavaTestProcess(test_name);\n+\n+        String keyword = \"push_fp: \";\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_fregs);\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_vector_reg_type, expected_number_of_vector_regs);\n+\n+        keyword = \"pop_fp: \";\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_fregs);\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_vector_reg_type, expected_number_of_vector_regs);\n+    }\n+\n+    static void run_test(String test_name, String expected_freg_type, int expected_number_of_fregs) throws Exception {\n+        String stdout = launchJavaTestProcess(test_name);\n+\n+        String keyword = \"push_fp: \";\n+        if (!containOnlyOneOccuranceOfKeyword(stdout, keyword)) {\n+            throw new RuntimeException(\"Stdout is expected to contain only one occurance of keyword: \" + \"'\" + keyword + \"'\");\n+        }\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_fregs);\n+\n+        keyword = \"pop_fp: \";\n+        if (!containOnlyOneOccuranceOfKeyword(stdout, keyword)) {\n+            throw new RuntimeException(\"Stdout is expected to contain only one occurance of keyword: \" + \"'\" + keyword + \"'\");\n+        }\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_fregs);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String vector_max_reg_type;\n+        if (VectorShape.S_Max_BIT.vectorBitSize() > 128) {\n+            vector_max_reg_type = \"SVE\";\n+        } else {\n+            vector_max_reg_type = \"Neon\";\n+        }\n+        run_test(\"test_one_float_push_pop_at_load_barrier\", \"fp\", 1);\n+        run_test(\"test_two_floats_push_pop_at_load_barrier\", \"fp\", 2);\n+        run_test(\"test_three_floats_push_pop_at_load_barrier\", \"fp\", 3);\n+        run_test(\"test_one_double_push_pop_at_load_barrier\", \"fp\", 1);\n+        run_test(\"test_two_doubles_push_pop_at_load_barrier\", \"fp\", 2);\n+        run_test(\"test_three_doubles_push_pop_at_load_barrier\", \"fp\", 3);\n+        run_test(\"test_one_vector_128_push_pop_at_load_barrier\", \"Neon\", 1);\n+        run_test(\"test_two_vectors_128_push_pop_at_load_barrier\", \"Neon\", 2);\n+        run_test(\"test_three_vectors_128_push_pop_at_load_barrier\", \"Neon\", 3);\n+        run_test(\"test_vector_max_push_pop_at_load_barrier\", vector_max_reg_type, 1);\n+        run_test(\"test_float_and_vector_push_pop_at_load_barrier\", \"fp\", 1, vector_max_reg_type, 1);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestRegistersPushPopAtZGCLoadBarrierStub.java","additions":363,"deletions":0,"binary":false,"changes":363,"status":"added"}]}