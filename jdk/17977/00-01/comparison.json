{"files":[{"patch":"@@ -2437,0 +2437,14 @@\n+#ifndef PRODUCT\n+  {\n+    char buffer[48];\n+    if (mode == PushPopSVE) {\n+      snprintf(buffer, sizeof(buffer), \"push_fp: %d SVE registers\", count);\n+    } else if (mode == PushPopNeon) {\n+      snprintf(buffer, sizeof(buffer), \"push_fp: %d Neon registers\", count);\n+    } else {\n+      snprintf(buffer, sizeof(buffer), \"push_fp: %d fp registers\", count);\n+    }\n+    block_comment(buffer);\n+  }\n+#endif\n+\n@@ -2535,0 +2549,14 @@\n+#ifndef PRODUCT\n+  {\n+    char buffer[48];\n+    if (mode == PushPopSVE) {\n+      snprintf(buffer, sizeof(buffer), \"pop_fp: %d SVE registers\", count);\n+    } else if (mode == PushPopNeon) {\n+      snprintf(buffer, sizeof(buffer), \"pop_fp: %d Neon registers\", count);\n+    } else {\n+      snprintf(buffer, sizeof(buffer), \"pop_fp: %d fp registers\", count);\n+    }\n+    block_comment(buffer);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,363 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.z;\n+\n+\/**\n+ * @test TestZSpillingAtLoadBarrierStub\n+ * @bug 8326541\n+ * @summary Test to verify that registers are saved and restored correctly based on\n+            the actual register usage length on aarch64 when entering load barrier stub.\n+ * @library \/test\/lib \/\n+ * @modules jdk.incubator.vector\n+ *\n+ * @requires vm.gc.ZGenerational & vm.debug\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @run driver gc.z.TestZSpillingAtLoadBarrierStub\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+class Inner {}\n+\n+class InnerFloat extends Inner {\n+    float data;\n+    public InnerFloat(float f) {\n+        data = f;\n+    }\n+}\n+\n+class InnerDouble extends Inner {\n+    double data;\n+    public InnerDouble(double f) {\n+        data = f;\n+    }\n+}\n+\n+class Outer {\n+    volatile Inner field;\n+    public Outer(Inner i) {\n+        field = i;\n+    }\n+}\n+\n+public class TestZSpillingAtLoadBarrierStub {\n+\n+    class Launcher {\n+        private final static int NUM = 1024;\n+        private final static int ITERATIONS = 50_000;\n+        private final static RandomGenerator RANDOM = RandomGeneratorFactory.getDefault().create(0);\n+        private final static Map<String, Runnable> TESTS;\n+\n+        private static float[] f_array;\n+        private static Outer f_outer;\n+        private static Outer d_outer;\n+\n+        static {\n+            f_array = new float[NUM];\n+            for (int i = 0; i < NUM; i++) {\n+                f_array[i] = RANDOM.nextFloat();\n+            }\n+\n+            InnerFloat f_inner = new InnerFloat(RANDOM.nextFloat());\n+            InnerDouble d_inner = new InnerDouble(RANDOM.nextDouble());\n+            f_outer = new Outer(f_inner);\n+            d_outer = new Outer(d_inner);\n+\n+            TESTS = new LinkedHashMap<>();\n+            TESTS.put(\"test_one_float_spilling\", Launcher::test_one_float);\n+            TESTS.put(\"test_two_floats_spilling\", Launcher::test_two_floats);\n+            TESTS.put(\"test_three_floats_spilling\", Launcher::test_three_floats);\n+            TESTS.put(\"test_one_double_spilling\", Launcher::test_one_double);\n+            TESTS.put(\"test_two_doubles_spilling\", Launcher::test_two_doubles);\n+            TESTS.put(\"test_three_doubles_spilling\", Launcher::test_three_doubles);\n+            TESTS.put(\"test_one_vector_128_spilling\", Launcher::test_one_vector_128);\n+            TESTS.put(\"test_two_vectors_128_spilling\", Launcher::test_two_vectors_128);\n+            TESTS.put(\"test_three_vectors_128_spilling\", Launcher::test_three_vectors_128);\n+            TESTS.put(\"test_vector_max_spilling\", Launcher::test_vector_max);\n+            TESTS.put(\"test_float_and_vector_spilling\", Launcher::test_float_and_vector);\n+        }\n+\n+        static float test_one_float_spilling(Outer outer, float f) {\n+            Inner inner = outer.field;\n+            return f + ((InnerFloat)inner).data;\n+        }\n+\n+        static float test_two_floats_spilling(Outer outer, float f1, float f2) {\n+            Inner inner = outer.field;\n+            return f1 + f2 + ((InnerFloat)inner).data;\n+        }\n+\n+        static float test_three_floats_spilling(Outer outer, float f1, float f2, float f3) {\n+            Inner inner = outer.field;\n+            return f1 + f2 + f3 + ((InnerFloat)inner).data;\n+        }\n+\n+        static double test_one_double_spilling(Outer outer, double d) {\n+            Inner inner = outer.field;\n+            return d + ((InnerDouble)inner).data;\n+        }\n+\n+        static double test_two_doubles_spilling(Outer outer, double d1, double d2) {\n+            Inner inner = outer.field;\n+            return d1 + d2 + ((InnerDouble)inner).data;\n+        }\n+\n+        static double test_three_doubles_spilling(Outer outer, double d1, double d2, double d3) {\n+            Inner inner = outer.field;\n+            return d1 + d2 + d3 + ((InnerDouble)inner).data;\n+        }\n+\n+        static void test_one_vector_128_spilling(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_128;\n+\n+            FloatVector av = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av = av.add(bv).add(value);\n+            }\n+        }\n+\n+        static void test_two_vectors_128_spilling(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_128;\n+\n+            FloatVector av1 = FloatVector.zero(float_species);\n+            FloatVector av2 = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av1 = av1.add(bv).add(value);\n+                av2 = av2.add(av1);\n+            }\n+        }\n+\n+        static void test_three_vectors_128_spilling(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_128;\n+\n+            FloatVector av1 = FloatVector.zero(float_species);\n+            FloatVector av2 = FloatVector.zero(float_species);\n+            FloatVector av3 = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av1 = av1.add(bv).add(value);\n+                av2 = av2.add(av1);\n+                av3 = av3.add(av2);\n+            }\n+        }\n+\n+        static void test_vector_max_spilling(float[] b, Outer outer) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_MAX;\n+\n+            FloatVector av = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data;\n+                av = av.add(bv).add(value);\n+            }\n+        }\n+\n+        static void test_float_and_vector_spilling(float[] b, Outer outer, float f) {\n+            VectorSpecies<Float> float_species = FloatVector.SPECIES_MAX;\n+\n+            FloatVector av = FloatVector.zero(float_species);\n+            for (int i = 0; i < b.length; i += float_species.length()) {\n+                Inner inner = outer.field;\n+                FloatVector bv = FloatVector.fromArray(float_species, b, i);\n+                float value = ((InnerFloat)inner).data + f;\n+                av = av.add(bv).add(value);\n+            }\n+        }\n+\n+        static void test_one_float() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_one_float_spilling(f_outer, RANDOM.nextFloat());\n+            }\n+        }\n+\n+        static void test_two_floats() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_two_floats_spilling(f_outer, RANDOM.nextFloat(), RANDOM.nextFloat());\n+            }\n+        }\n+\n+        static void test_three_floats() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_three_floats_spilling(f_outer, RANDOM.nextFloat(), RANDOM.nextFloat(), RANDOM.nextFloat());\n+            }\n+        }\n+\n+        static void test_one_double() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_one_double_spilling(d_outer, RANDOM.nextDouble());\n+            }\n+        }\n+\n+        static void test_two_doubles() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_two_doubles_spilling(d_outer, RANDOM.nextDouble(), RANDOM.nextDouble());\n+            }\n+        }\n+\n+        static void test_three_doubles() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_three_doubles_spilling(d_outer, RANDOM.nextDouble(), RANDOM.nextDouble(), RANDOM.nextDouble());\n+            }\n+        }\n+\n+        static void test_one_vector_128() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_one_vector_128_spilling(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_two_vectors_128() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_two_vectors_128_spilling(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_three_vectors_128() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_three_vectors_128_spilling(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_vector_max() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_vector_max_spilling(f_array, f_outer);\n+            }\n+        }\n+\n+        static void test_float_and_vector() {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                test_float_and_vector_spilling(f_array, f_outer, RANDOM.nextFloat());\n+            }\n+        }\n+\n+        public static void main(String args[]) {\n+            Runnable r = TESTS.get(args[0]);\n+            r.run();\n+        }\n+    }\n+\n+    static boolean containOnlyOneOccuranceOfKeyword(String text, String keyword) {\n+        int firstIndex = text.indexOf(keyword);\n+        int lastIndex = text.lastIndexOf(keyword);\n+        return firstIndex != -1 && firstIndex == lastIndex;\n+    }\n+\n+    \/\/ Check that registers are pushed and poped with correct register type and number\n+    static void checkPushPopRegNumberAndType(String stdout, String keyword, String expected_freg_type,\n+                                             int expected_number_of_spilling_fregs) throws Exception {\n+        String keyString = keyword + expected_number_of_spilling_fregs + \" \" + expected_freg_type + \" registers\";\n+        if (!containOnlyOneOccuranceOfKeyword(stdout, keyString)) {\n+            throw new RuntimeException(\"Stdout is expected to contain only one occurance of keyString: \" + \"'\" + keyString + \"'\");\n+        }\n+    }\n+\n+    static String launchJavaTestProcess(String test_name) throws Exception {\n+        ArrayList<String> command = new ArrayList<String>();\n+        command.add(\"-Xbatch\");\n+        command.add(\"-XX:LoopUnrollLimit=0\");\n+        command.add(\"-XX:-UseOnStackReplacement\");\n+        command.add(\"-XX:-TieredCompilation\");\n+        command.add(\"-XX:+UseZGC\");\n+        command.add(\"-XX:+ZGenerational\");\n+        command.add(\"--add-modules=jdk.incubator.vector\");\n+        command.add(\"-XX:CompileCommand=print,\" +  Launcher.class.getName() + \"::\" + test_name);\n+        command.add(Launcher.class.getName());\n+        command.add(test_name);\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(command);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output.getStdout();\n+    }\n+\n+    static void run_test(String test_name, String expected_freg_type, int expected_number_of_spilling_fregs,\n+                         String expected_vector_reg_type, int expected_number_of_spilling_vector_regs) throws Exception {\n+        String stdout = launchJavaTestProcess(test_name);\n+\n+        String keyword = \"push_fp: \";\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_spilling_fregs);\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_vector_reg_type, expected_number_of_spilling_vector_regs);\n+\n+        keyword = \"pop_fp: \";\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_spilling_fregs);\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_vector_reg_type, expected_number_of_spilling_vector_regs);\n+    }\n+\n+    static void run_test(String test_name, String expected_freg_type, int expected_number_of_spilling_fregs) throws Exception {\n+        String stdout = launchJavaTestProcess(test_name);\n+\n+        String keyword = \"push_fp: \";\n+        if (!containOnlyOneOccuranceOfKeyword(stdout, keyword)) {\n+            throw new RuntimeException(\"Stdout is expected to contain only one occurance of keyword: \" + \"'\" + keyword + \"'\");\n+        }\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_spilling_fregs);\n+\n+        keyword = \"pop_fp: \";\n+        if (!containOnlyOneOccuranceOfKeyword(stdout, keyword)) {\n+            throw new RuntimeException(\"Stdout is expected to contain only one occurance of keyword: \" + \"'\" + keyword + \"'\");\n+        }\n+        checkPushPopRegNumberAndType(stdout, keyword, expected_freg_type, expected_number_of_spilling_fregs);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String vector_max_reg_type;\n+        if (VectorShape.S_Max_BIT.vectorBitSize() > 128) {\n+            vector_max_reg_type = \"SVE\";\n+        } else {\n+            vector_max_reg_type = \"Neon\";\n+        }\n+        run_test(\"test_one_float_spilling\", \"fp\", 1);\n+        run_test(\"test_two_floats_spilling\", \"fp\", 2);\n+        run_test(\"test_three_floats_spilling\", \"fp\", 3);\n+        run_test(\"test_one_double_spilling\", \"fp\", 1);\n+        run_test(\"test_two_doubles_spilling\", \"fp\", 2);\n+        run_test(\"test_three_doubles_spilling\", \"fp\", 3);\n+        run_test(\"test_one_vector_128_spilling\", \"Neon\", 1);\n+        run_test(\"test_two_vectors_128_spilling\", \"Neon\", 2);\n+        run_test(\"test_three_vectors_128_spilling\", \"Neon\", 3);\n+        run_test(\"test_vector_max_spilling\", vector_max_reg_type, 1);\n+        run_test(\"test_float_and_vector_spilling\", \"fp\", 1, vector_max_reg_type, 1);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestZSpillingAtLoadBarrierStub.java","additions":363,"deletions":0,"binary":false,"changes":363,"status":"added"}]}