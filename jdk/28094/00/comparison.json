{"files":[{"patch":"@@ -580,1 +580,1 @@\n-    return !has_subklass() && (nof_implementors() == 0);\n+    return !has_subklass() && (!is_interface() || nof_implementors() == 0);\n@@ -594,0 +594,1 @@\n+  assert(is_interface(), \"required\");\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+    assert(is_interface(), \"must be\");\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,4 +100,3 @@\n-  const bool is_virtual_or_interface = (bytecode == Bytecodes::_invokevirtual) ||\n-                                       (bytecode == Bytecodes::_invokeinterface) ||\n-                                       (orig_callee->intrinsic_id() == vmIntrinsics::_linkToVirtual) ||\n-                                       (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface);\n+  const bool is_virtual = (bytecode == Bytecodes::_invokevirtual) || (orig_callee->intrinsic_id() == vmIntrinsics::_linkToVirtual);\n+  const bool is_interface = (bytecode == Bytecodes::_invokeinterface) || (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface);\n+  const bool is_virtual_or_interface = is_virtual || is_interface;\n@@ -342,3 +341,11 @@\n-    if (call_does_dispatch && bytecode == Bytecodes::_invokeinterface) {\n-      ciInstanceKlass* declared_interface =\n-          caller->get_declared_method_holder_at_bci(bci)->as_instance_klass();\n+    if (call_does_dispatch && is_interface) {\n+      ciInstanceKlass* declared_interface = nullptr;\n+      if (orig_callee->intrinsic_id() == vmIntrinsics::_linkToInterface) {\n+        \/\/ MemberName doesn't keep symbolic information once resolution is over, but\n+        \/\/ resolved method holder can be used as a conservative approximation.\n+        declared_interface = callee->holder();\n+      } else {\n+        assert(!orig_callee->is_method_handle_intrinsic(), \"not allowed\");\n+        declared_interface = caller->get_declared_method_holder_at_bci(bci)->as_instance_klass();\n+      }\n+      assert(declared_interface->is_interface(), \"required\");\n@@ -350,1 +357,0 @@\n-        assert(check_access, \"required\");\n@@ -352,1 +358,1 @@\n-            callee->find_monomorphic_target(caller->holder(), declared_interface, singleton);\n+            callee->find_monomorphic_target(caller->holder(), declared_interface, singleton, check_access);\n@@ -375,1 +381,1 @@\n-    } \/\/ call_does_dispatch && bytecode == Bytecodes::_invokeinterface\n+    } \/\/ call_does_dispatch && is_interface\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires vm.opt.StressMethodHandleLinkerInlining == null | !vm.opt.StressMethodHandleLinkerInlining\n@@ -58,0 +59,3 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+\n@@ -69,0 +73,12 @@\n+\n+        \/\/ Implementation limitation: CHA is not performed by C1 during inlining through MH linkers.\n+        if (!jdk.test.whitebox.code.Compiler.isC1Enabled()) {\n+            run(ObjectToString.TestMH.class, ObjectToString.class);\n+            run(ObjectHashCode.TestMH.class, ObjectHashCode.class);\n+            run(TwoLevelHierarchyLinear.TestMH.class, TwoLevelHierarchyLinear.class);\n+            run(ThreeLevelHierarchyLinear.TestMH.class, ThreeLevelHierarchyLinear.class);\n+            run(ThreeLevelHierarchyAbstractVsDefault.TestMH.class, ThreeLevelHierarchyAbstractVsDefault.class);\n+            run(ThreeLevelDefaultHierarchy.TestMH.class, ThreeLevelDefaultHierarchy.class);\n+            run(ThreeLevelDefaultHierarchy1.TestMH.class, ThreeLevelDefaultHierarchy1.class);\n+        }\n+\n@@ -90,1 +106,1 @@\n-        public Object test(I i) { return ObjectToStringHelper.testHelper(i); \/* invokeinterface I.toString() *\/ }\n+        public Object test(I i) throws Throwable { return ObjectToStringHelper.testHelper(i); \/* invokeinterface I.toString() *\/ }\n@@ -158,0 +174,14 @@\n+\n+        public static class TestMH extends ObjectToString {\n+            static final MethodHandle TEST_MH = findVirtualHelper(I.class, \"toString\", String.class, MethodHandles.lookup());\n+\n+            @Override\n+            public void checkInvalidReceiver() {\n+                \/\/ receiver type check failures trigger nmethod invalidation\n+            }\n+\n+            @Override\n+            public Object test(I obj) throws Throwable {\n+                return (String)TEST_MH.invokeExact(obj); \/\/ invokeinterface I.toString()\n+            }\n+        }\n@@ -178,1 +208,1 @@\n-        public Object test(I i) {\n+        public Object test(I i) throws Throwable {\n@@ -245,0 +275,14 @@\n+\n+        public static class TestMH extends ObjectHashCode {\n+            static final MethodHandle TEST_MH = findVirtualHelper(I.class, \"hashCode\", int.class, MethodHandles.lookup());\n+\n+            @Override\n+            public void checkInvalidReceiver() {\n+                \/\/ receiver type check failures trigger nmethod invalidation\n+            }\n+\n+            @Override\n+            public Object test(I obj) throws Throwable {\n+                return (int)TEST_MH.invokeExact(obj); \/\/ invokeinterface I.hashCode()\n+            }\n+        }\n@@ -266,1 +310,1 @@\n-        public Object test(I i) {\n+        public Object test(I i) throws Throwable {\n@@ -369,0 +413,14 @@\n+\n+        public static class TestMH extends TwoLevelHierarchyLinear {\n+            static final MethodHandle TEST_MH = findVirtualHelper(I.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public void checkInvalidReceiver() {\n+                \/\/ receiver type check failures trigger nmethod invalidation\n+            }\n+\n+            @Override\n+            public Object test(I obj) throws Throwable {\n+                return TEST_MH.invokeExact(obj); \/\/ invokeinterface I.m()\n+            }\n+        }\n@@ -388,1 +446,1 @@\n-        public Object test(I i) {\n+        public Object test(I i) throws Throwable {\n@@ -407,4 +465,10 @@\n-            initialize(DJ.class,  \/\/      DJ.m                    <: intf J.m ABSTRACT\n-                       K1.class,  \/\/ intf K1            <: intf I <: intf J.m ABSTRACT\n-                       K2.class); \/\/ intf K2.m ABSTRACT <: intf I <: intf J.m ABSTRACT\n-            assertCompiled();\n+            if (contextClass() == I.class) {\n+                initialize(DJ.class,  \/\/      DJ.m                    <: intf J.m ABSTRACT\n+                           K1.class,  \/\/ intf K1            <: intf I <: intf J.m ABSTRACT\n+                           K2.class); \/\/ intf K2.m ABSTRACT <: intf I <: intf J.m ABSTRACT\n+                assertCompiled();\n+            } else if (contextClass() == J.class) {\n+                \/\/ no classes to initialize w\/o breaking a dependency\n+            } else {\n+                throw new InternalError(\"unsupported context: \" + contextClass());\n+            }\n@@ -494,0 +558,24 @@\n+\n+        Class<?> contextClass() {\n+            return I.class;\n+        }\n+\n+        public static class TestMH extends ThreeLevelHierarchyLinear {\n+            static final MethodHandle TEST_MH = findVirtualHelper(I.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public void checkInvalidReceiver() {\n+                \/\/ receiver type check failures trigger nmethod invalidation\n+            }\n+\n+            @Override\n+            Class<?> contextClass() {\n+                return J.class;\n+            }\n+\n+            @Override\n+            public Object test(I obj) throws Throwable {\n+                return TEST_MH.invokeExact(obj); \/\/ invokeinterface I.m()\n+            }\n+        }\n+\n@@ -506,1 +594,1 @@\n-        public Object test(I i) {\n+        public Object test(I i) throws Throwable {\n@@ -601,0 +689,14 @@\n+\n+        public static class TestMH extends ThreeLevelHierarchyAbstractVsDefault {\n+            static final MethodHandle TEST_MH = findVirtualHelper(I.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public void checkInvalidReceiver() {\n+                \/\/ receiver type check failures trigger nmethod invalidation\n+            }\n+\n+            @Override\n+            public Object test(I obj) throws Throwable {\n+                return TEST_MH.invokeExact(obj); \/\/ invokeinterface I.m()\n+            }\n+        }\n@@ -620,1 +722,1 @@\n-        public Object test(I i) {\n+        public Object test(I i) throws Throwable {\n@@ -639,5 +741,11 @@\n-            initialize(DJ.class,    \/\/      DJ.m                               <: intf J.m ABSTRACT\n-                       K1.class,   \/\/ intf  K1            <: intf I            <: intf J.m ABSTRACT\n-                       K2.class,   \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J.m ABSTRACT\n-                       DK3.class); \/\/      DK3.m          <: intf K3.m DEFAULT <: intf J.m ABSTRACT\n-            assertCompiled();\n+            if (contextClass() == I.class) {\n+                initialize(DJ.class,   \/\/       DJ.m                               <: intf J.m ABSTRACT\n+                           K1.class,   \/\/ intf  K1            <: intf I            <: intf J.m ABSTRACT\n+                           K2.class,   \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J.m ABSTRACT\n+                           DK3.class); \/\/      DK3.m          <: intf K3.m DEFAULT <: intf J.m ABSTRACT\n+                assertCompiled();\n+            } else if (contextClass() == J.class) {\n+                \/\/ no classes to initialize w\/o breaking a dependency\n+            } else {\n+                throw new InternalError(\"unsupported context: \" + contextClass());\n+            }\n@@ -669,0 +777,23 @@\n+\n+        Class<?> contextClass() {\n+            return I.class;\n+        }\n+\n+        public static class TestMH extends ThreeLevelDefaultHierarchy {\n+            static final MethodHandle TEST_MH = findVirtualHelper(I.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public void checkInvalidReceiver() {\n+                \/\/ receiver type check failures trigger nmethod invalidation\n+            }\n+\n+            @Override\n+            Class<?> contextClass() {\n+                return J.class;\n+            }\n+\n+            @Override\n+            public Object test(I obj) throws Throwable {\n+                return TEST_MH.invokeExact(obj); \/\/ invokeinterface I.m()\n+            }\n+        }\n@@ -689,1 +820,1 @@\n-        public Object test(I i) {\n+        public Object test(I i) throws Throwable {\n@@ -708,5 +839,14 @@\n-            initialize(DJ1.class,\n-                       DJ2.class,\n-                       K1.class,\n-                       K2.class,\n-                       K3.class);\n+            if (contextClass() == I.class) {\n+                initialize(DJ1.class, \/\/      DJ1.m                               <: intf J1\n+                           DJ2.class, \/\/      DJ2.m                               <:          intf J2.m ABSTRACT\n+                           K1.class,  \/\/ intf  K1            <: intf I            <: intf J1, intf J2.m ABSTRACT\n+                           K2.class,  \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J1, intf J2.m ABSTRACT\n+                           K3.class); \/\/ intf  K3.m DEFAULT  <: intf I            <: intf J1, intf J2.m ABSTRACT\n+            } else if (contextClass() == J2.class) {\n+                initialize(DJ1.class, \/\/      DJ1.m                               <: intf J1\n+                           K1.class,  \/\/ intf  K1            <: intf I            <: intf J1, intf J2.m ABSTRACT\n+                           K2.class,  \/\/ intf  K2.m ABSTRACT <: intf I            <: intf J1, intf J2.m ABSTRACT\n+                           K3.class); \/\/ intf  K3.m DEFAULT  <: intf I            <: intf J1, intf J2.m ABSTRACT\n+            } else {\n+                throw new InternalError(\"unsupported context: \" + contextClass());\n+            }\n@@ -745,0 +885,23 @@\n+\n+        Class<?> contextClass() {\n+            return I.class;\n+        }\n+\n+        public static class TestMH extends ThreeLevelDefaultHierarchy1 {\n+            static final MethodHandle TEST_MH = findVirtualHelper(I.class, \"m\", Object.class, MethodHandles.lookup());\n+\n+            @Override\n+            public void checkInvalidReceiver() {\n+                \/\/ receiver type check failures trigger nmethod invalidation\n+            }\n+\n+            @Override\n+            Class<?> contextClass() {\n+                return J2.class;\n+            }\n+\n+            @Override\n+            public Object test(I obj) throws Throwable {\n+                return TEST_MH.invokeExact(obj); \/\/ invokeinterface I.m()\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/cha\/StrengthReduceInterfaceCall.java","additions":184,"deletions":21,"binary":false,"changes":205,"status":"modified"}]}