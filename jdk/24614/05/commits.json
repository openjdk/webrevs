[{"commit":{"message":"Limit running test only on windows"},"files":[{"filename":"test\/jdk\/java\/awt\/Clipboard\/ConcurrentClipboardAccessTest.java"}],"sha":"b9307454b05da44c2ce572d81b60cd91bebfea9b"},{"commit":{"message":"Address review comments:\n\n- reduce log level in WClipboard#handleContentsChanged to DEBUG, so that\n  in normal operation it will not be visible\n- restore comment on WClipboard#closeClipboard\n- adjust comment on WClipboard#openClipboard\n- Ensure ConcurrentClipboardAccessTest shutsdown on its own when not\n  run in an environment with an external timeout handling.\n- Added finishing message to ConcurrentClipboardAccessTest, so that\n  correct termination can be determined visually if run manually"},"files":[{"filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WClipboard.java"},{"filename":"test\/jdk\/java\/awt\/Clipboard\/ConcurrentClipboardAccessTest.java"}],"sha":"50ccf76659f702933ca8b1db3b8a9637813f1aaa"},{"commit":{"message":"Add headful key to the jtreg description"},"files":[{"filename":"test\/jdk\/java\/awt\/Clipboard\/ConcurrentClipboardAccessTest.java"}],"sha":"bfa99a718846563055fc6721e1f51ce19885a5b5"},{"commit":{"message":"Add crash reproducer as jtreg test"},"files":[{"filename":"test\/jdk\/java\/awt\/Clipboard\/ConcurrentClipboardAccessTest.java"}],"sha":"e5ebf59f12516032dc0c8ffaa5b6ec6565a31b4e"},{"commit":{"message":"Adress review comments: Update copyright years and fix whitespace in if condition"},"files":[{"filename":"src\/java.desktop\/share\/classes\/sun\/awt\/datatransfer\/SunClipboard.java"},{"filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WClipboard.java"},{"filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Clipboard.cpp"}],"sha":"4fa4ef905c7508444293b5d36f5836edbea27a5f"},{"commit":{"message":"8353950: Ensure windows clipboard is not accessed concurrently\n\nThe focus of this change is the windows port of the AWT. openClipboard\nand closeClipboard are only implemented there.\n\nThe general idea here is, that the section between openClipboard and\ncloseClipboard must be considered a critical section, that must not be\naccessed concurrently.\n\nThe fix idea here is to use a ReentrantLock to protect the native side.\nopenClipboard now check if the lock can be locked (tryLock) if that\nfails, an IllegalStateException is raised.\n\nThis is defined behavior for the accessors from client code (see for\nexample the documentation for Clipboard#setContents and\nClipboard#getContents.\n\nThe remaining problem is the upcall from the WToolkit. The message loop\nhandler has to react to the WM_CLIPBOARDUPDATE. When that message is\nreceived an upcall to WClipboard#handleContentsChanged is invoked. That\nin turn will make a downcall to the native getClipboardFormats. That\nmethod used EnumClipboardFormats to enumerate the formats in the\nclipboard. The problem is, that EnumClipboardFormats need the clipboard\nto be opened (as implemented in openClipboard). \n\nThis is problematic as the upcall from native should not lead to an\nexception. Even if the exception is caught, it will result in flavor\nlisteners not being called.\n\nSince Windows Vista \/ Windows Server 2008 GetUpdatedClipboardFormats\ncan be used, which does not need an open clipboard and thus would be\nsafe to be called from the upcall.\n\nTesting:\n\n- fastdebug build does not hit asserts anymore for the reproducer code\n  (see previous commit)\n- reproducer code for JDK-8332271 does not crash anymore. Code was\n  run for multiple minutes and no crash was observed\n- tests from test\/jdk\/java\/awt\/Clipboard were run and tests succeeded\n  in release and fastdebug configuration"},"files":[{"filename":"src\/java.desktop\/share\/classes\/sun\/awt\/datatransfer\/SunClipboard.java"},{"filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WClipboard.java"},{"filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Clipboard.cpp"}],"sha":"24c0d0a5fd9d46830eacaab2b439bc44dc389c89"},{"commit":{"message":"8353950: Ensure JDK does not crash when running reproducer\n\nFor investigation\/testing issue JDK-8353950 it is necessary to create a\nnon-crashing baseline. Testing JDK-8353950 was done with a fastdebug\nbuild of the JDK. The build was modified so that instead of blockingly\nshowing a messagebox, only CLI output was generated when an assertion\nwas hit. This is necessary, so that the reproducer runs with higher\nconcurrency.\n\nThe call to MessageBoxA was commented out for this in awt_Debug.cpp.\n\nReproducer Code\n===============\n\n```java\n\nimport java.awt.Toolkit;\nimport java.awt.datatransfer.FlavorEvent;\nimport java.awt.datatransfer.FlavorListener;\nimport java.awt.datatransfer.StringSelection;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport javax.swing.SwingUtilities;\n\npublic class Clipboardreproducer2 {\n\n    private static final System.Logger LOG = System.getLogger(Clipboardreproducer2.class.getName());\n\n    public static void main(String[] args) throws Exception {\n\n        AtomicBoolean end = new AtomicBoolean(false);\n\n        SwingUtilities.invokeLater(() -> {\n            Toolkit.getDefaultToolkit().getSystemClipboard().addFlavorListener(new FlavorListener() {\n                @Override\n                public void flavorsChanged(FlavorEvent e) {\n                    LOG.log(System.Logger.Level.INFO, \"Flavor Changed: {0} \/\/ {1}\", e, SwingUtilities.isEventDispatchThread());\n                }\n            });\n        });\n\n        Runnable copy = new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(\"Test\"), null);\n\/\/                    LOG.log(System.Logger.Level.INFO, \"Copy 1\");\n                } catch (IllegalStateException ex) {\n                    LOG.log(System.Logger.Level.ERROR, \"Failed to invoke copy (1)\", ex);\n                }\n                if(! end.get()) {\n                    SwingUtilities.invokeLater(this);\n                } else {\n                    System.out.println(\"Exitting\");\n                }\n            }\n        };\n\n        SwingUtilities.invokeLater(copy);\n\n        Thread.sleep(60 * 1000);\n\n        LOG.log(System.Logger.Level.INFO, \"DONE\");\n\n        end.set(true);\n\n        Thread.sleep(500);\n\n        LOG.log(System.Logger.Level.INFO, \"END\");\n\n        System.exit(0);\n\n    }\n\n}\n```\n\nCrash message\n=============\n\n```\n#\n# A fatal error has been detected by the Java Runtime Environment:\n#\n#  Internal Error (c:\\temp\\jdk\\src\\hotspot\\share\\runtime\/jniHandles.inline.hpp:81), pid=3816, tid=5224\n#  assert(external_guard || result != nullptr) failed: Invalid JNI handle\n#\n# JRE version: OpenJDK Runtime Environment (25.0) (fastdebug build 25-internal-adhoc.Matthias.jdk)\n# Java VM: OpenJDK 64-Bit Server VM (fastdebug 25-internal-adhoc.Matthias.jdk, mixed mode, tiered, compressed oops, compressed class ptrs, g1 gc, windows-amd64)\n# Problematic frame:\n# V  [jvm.dll+0x5160eb]  JNIHandles::resolve_impl<0,0>+0x27b\n#\n# Core dump will be written. Default location: c:\\Temp\\hs_err_pid3816.mdmp\n#\n# An error report file with more information is saved as:\n# c:\\Temp\\hs_err_pid3816.log\n[16.331s][warning][os] Loading hsdis library failed\n#\n# If you would like to submit a bug report, please visit:\n#   https:\/\/bugreport.java.com\/bugreport\/crash.jsp\n#\n```\n\nThe code from JDK-8332271 was also tested, but that did not yield a\nvisible result. It crashes, but the only data recorded is an entry in\nthe eventlog of windows.\n\nAnalysis\n========\n\nLooking through the code in `awt_Clipboard.cpp` there is a possible race\ncondition. Each call to openClipboard with a non-null caller will reset\nthe value of AwtClipboard::theCurrentClipboard. That variable holds a\nreference to the java peer of the native clipboard.\n\nThe race is (line number refer to state in commit\n1d7138fe021d64686ac59cddd1bc7c787c610aa9):\n\nThread 1: Application code calls Clipboard#setContents. On windows the\ncode now flows through WClipboard#openClipboard and will run to\nawt_Clipboard.cpp line 145 (this is in the native implementatio of\nopenClipboard. Just before DeleteGlobalRef.\n\nThread 2: The windows event loop gets a WM_CLIPBOARDUPDATE message and\ncalls into AwtClipboard::WmClipboardUpdate (awt_Clipboard.cpp line 60).\nThe code runs through the non-null check and just before the\n`CallVoidMethod` call.\n\nThread 1: Continues and executes DeleteGlobalRef.\n\nThread 2: Continues exection with:\n`env->CallVoidMethod(theCurrentClipboard, lostSelectionOwnershipMID)`.\nBut at this point theCurrentClipboard does not hold a valid object\nhandle anymore and crashes the VM.\n\nProposed solution\n=================\n\nThe code already makes assumptions, that there is only one AwtToolkit\n(see calls to AwtToolkit::GetInstance). In addition\nWToolkit#getSystemClipboard ensures, that only one WClipboard will\nbe created for this.\n\nBased on this, this change drops the ability to pass in a new Clipboard\non each call to `openClipboard`. Instead the registration of the\njava side of the clipboard with the native side is moved to construction\ntime of the WClipboard object. `openClipboard` is modified, so that it\nverifies the assumption asserting that a new owner matches the initial\nowner."},"files":[{"filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WClipboard.java"},{"filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Clipboard.cpp"}],"sha":"e893b368a0e32ff17c1182fb261e0561d48827d3"}]