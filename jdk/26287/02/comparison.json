{"files":[{"patch":"@@ -862,41 +862,0 @@\n-\/\/ Convert an oop to a JavaThread found on the specified ThreadsList.\n-\/\/ The ThreadsListHandle in the caller \"protects\" the returned\n-\/\/ JavaThread *.\n-\/\/\n-\/\/ On success, *jt_pp is set to the converted JavaThread * and\n-\/\/ JVMTI_ERROR_NONE is returned. On error, returns various\n-\/\/ JVMTI_ERROR_* values.\n-\/\/\n-jvmtiError\n-JvmtiExport::cv_oop_to_JavaThread(ThreadsList * t_list, oop thread_oop,\n-                                  JavaThread ** jt_pp) {\n-  assert(t_list != nullptr, \"must have a ThreadsList\");\n-  assert(thread_oop != nullptr, \"must have an oop\");\n-  assert(jt_pp != nullptr, \"must have a return JavaThread pointer\");\n-\n-  if (!thread_oop->is_a(vmClasses::Thread_klass())) {\n-    \/\/ The oop is not a java.lang.Thread.\n-    return JVMTI_ERROR_INVALID_THREAD;\n-  }\n-  \/\/ Looks like a java.lang.Thread oop at this point.\n-\n-  JavaThread * java_thread = java_lang_Thread::thread(thread_oop);\n-  if (java_thread == nullptr) {\n-    \/\/ The java.lang.Thread does not contain a JavaThread * so it has\n-    \/\/ not yet run or it has died.\n-    return JVMTI_ERROR_THREAD_NOT_ALIVE;\n-  }\n-  \/\/ Looks like a live JavaThread at this point.\n-\n-  if (!t_list->includes(java_thread)) {\n-    \/\/ Not on the JavaThreads list so it is not alive.\n-    return JVMTI_ERROR_THREAD_NOT_ALIVE;\n-  }\n-\n-  \/\/ Return a live JavaThread that is \"protected\" by the\n-  \/\/ ThreadsListHandle in the caller.\n-  *jt_pp = java_thread;\n-\n-  return JVMTI_ERROR_NONE;\n-}\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -457,2 +457,0 @@\n-  static jvmtiError cv_oop_to_JavaThread(ThreadsList * t_list, oop thread_oop,\n-                                         JavaThread ** jt_pp);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -794,0 +794,6 @@\n+\/\/ If the jthread resolves to a virtual thread then the JavaThread *\n+\/\/ for its current carrier thread (if any) is returned via *jt_pp.\n+\/\/ It is up to the caller to prevent the virtual thread from changing\n+\/\/ its mounted status, or else account for it when acting on the carrier\n+\/\/ JavaThread.\n+\/\/\n@@ -795,1 +801,1 @@\n-\/\/ after this call so the oop is returned. On success, *jt_pp is set\n+\/\/ after this call so the oop is always returned. On success, *jt_pp is set\n@@ -797,1 +803,1 @@\n-\/\/ returns false.\n+\/\/ returns false, and *jt_pp is unchanged.\n@@ -821,4 +827,16 @@\n-    \/\/ The java.lang.Thread does not contain a JavaThread* so it has not\n-    \/\/ run enough to be put on a ThreadsList or it has exited enough to\n-    \/\/ make it past ensure_join() where the JavaThread* is cleared.\n-    return false;\n+    if (!java_lang_VirtualThread::is_instance(thread_oop)) {\n+      \/\/ The java.lang.Thread does not contain a JavaThread* so it has not\n+      \/\/ run enough to be put on a ThreadsList or it has exited enough to\n+      \/\/ make it past ensure_join() where the JavaThread* is cleared.\n+      return false;\n+    } else {\n+      \/\/ For virtual threads we need to extract the carrier's JavaThread - if any.\n+       oop carrier_thread = java_lang_VirtualThread::carrier_thread(thread_oop);\n+       if (carrier_thread != nullptr) {\n+         java_thread = java_lang_Thread::thread(carrier_thread);\n+       }\n+       if (java_thread == nullptr) {\n+         \/\/ Virtual thread was unmounted, or else carrier has now terminated.\n+         return false;\n+       }\n+    }\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,2 @@\n-\/\/ There are several different ways to refer to java.lang.Thread objects\n-\/\/ so we have a few ways to get a protected JavaThread *:\n+\/\/ There are two ways to refer to java.lang.Thread objects so we have two ways\n+\/\/ to get a protected JavaThread*:\n@@ -72,11 +72,0 @@\n-\/\/ JVM\/TI oop example (this one should be very rare):\n-\/\/   oop thread_obj = ...;\n-\/\/   :\n-\/\/   JavaThread *jt = nullptr;\n-\/\/   ThreadsListHandle tlh;\n-\/\/   jvmtiError err = JvmtiExport::cv_oop_to_JavaThread(tlh.list(), thread_obj, &jt);\n-\/\/   if (err != JVMTI_ERROR_NONE) {\n-\/\/     return err;\n-\/\/   }\n-\/\/   :  \/\/ do stuff with 'jt'...\n-\/\/\n@@ -85,2 +74,2 @@\n-\/\/ remains in scope. The target JavaThread * may have logically exited,\n-\/\/ but that target JavaThread * will not be deleted until it is no\n+\/\/ remains in scope. The target JavaThread* may have logically exited,\n+\/\/ but that target JavaThread* will not be deleted until it is no\n@@ -321,1 +310,1 @@\n-  bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread ** jt_pp, oop * thread_oop_p);\n+  bool cv_internal_thread_to_JavaThread(jobject jthread, JavaThread** jt_pp, oop* thread_oop_p);\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"}]}