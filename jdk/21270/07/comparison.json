{"files":[{"patch":"@@ -465,1 +465,1 @@\n-\n+  int nof_input_phi_nodes = 0;\n@@ -467,0 +467,7 @@\n+    if (ophi->in(i)->is_Phi()) {\n+      \/\/ ignore phi node with more than one input phi node\n+      if (++nof_input_phi_nodes > 1) {\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Cannot reduce Phi %d. More than one input phi node.\", ophi->_idx);)\n+        return false;\n+      }\n+    }\n@@ -486,1 +493,1 @@\n-  NOT_PRODUCT(if (TraceReduceAllocationMerges && !found_sr_allocate) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. No SR Allocate as input.\", ophi->_idx, _invocation);)\n+  NOT_PRODUCT(if (TraceReduceAllocationMerges && !found_sr_allocate) tty->print_cr(\"Cannot reduce Phi %d on invocation %d. No SR Allocate as input.\", ophi->_idx, _invocation);)\n@@ -529,1 +536,2 @@\n-bool ConnectionGraph::can_reduce_check_users(Node* n, uint nesting) const {\n+\/\/  - Phi -> Phi -> AddP -> Load\n+bool ConnectionGraph::can_reduce_check_users(Node* n, uint phi_nest_level) const {\n@@ -532,2 +540,2 @@\n-\n-    if (use->is_SafePoint()) {\n+    \/\/ Skip Phi -> Phi -> SafePoints and allow only Phi -> SafePoints and Phi -> CastPP -> SafePoints\n+    if (use->is_SafePoint() && (!n->is_Phi() || phi_nest_level < 1)) {\n@@ -535,1 +543,1 @@\n-        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Call has non_debug_use().\", n->_idx, _invocation);)\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Cannot reduce Phi %d on invocation %d. Call has non_debug_use().\", n->_idx, _invocation);)\n@@ -538,1 +546,1 @@\n-        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. It has already been reduced.\", n->_idx, _invocation);)\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Cannot reduce Phi %d on invocation %d. It has already been reduced.\", n->_idx, _invocation);)\n@@ -542,0 +550,1 @@\n+      assert(phi_nest_level <= 1, \"unexpected nesting level\");\n@@ -547,2 +556,2 @@\n-        if (!use_use->is_Load() || !use_use->as_Load()->can_split_through_phi_base(_igvn)) {\n-          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. AddP user isn't a [splittable] Load(): %s\", n->_idx, _invocation, use_use->Name());)\n+        if (!use_use->is_Load() || !use_use->as_Load()->can_split_through_phi_base(_igvn, (phi_nest_level > 0))) {\n+          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Cannot reduce %s Phi %d on invocation %d. AddP user isn't a [splittable] Load(): %s\", (phi_nest_level > 0)?\"nested\":\"\", n->_idx, _invocation, use_use->Name());)\n@@ -551,1 +560,1 @@\n-          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. [Narrow] Klass Load: %s\", n->_idx, _invocation, use_use->Name());)\n+          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Cannot reduce %s Phi %d on invocation %d. [Narrow] Klass Load: %s\", (phi_nest_level > 0)?\"nested\":\"\", n->_idx, _invocation, use_use->Name());)\n@@ -555,2 +564,2 @@\n-    } else if (nesting > 0) {\n-      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. Unsupported user %s at nesting level %d.\", n->_idx, _invocation, use->Name(), nesting);)\n+    } else if (phi_nest_level > 0) {\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Cannot reduce Phi %d on invocation %d. Unsupported user %s at nesting level %d.\", n->_idx, _invocation, use->Name(), phi_nest_level);)\n@@ -558,0 +567,7 @@\n+    } else if (use->is_Phi()) {\n+      if (n->_idx == use->_idx) {\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Cannot reduce Self loop nested Phi\");)\n+        return false;\n+      } else if (!can_reduce_phi_check_inputs(use->as_Phi()) || !can_reduce_check_users(use->as_Phi(), phi_nest_level+1)) {\n+        return false;\n+      }\n@@ -563,1 +579,1 @@\n-          tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP is not to an instance.\", n->_idx, _invocation);\n+          tty->print_cr(\"Cannot reduce Phi %d on invocation %d. CastPP is not to an instance.\", n->_idx, _invocation);\n@@ -587,1 +603,1 @@\n-              tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);\n+              tty->print_cr(\"Cannot reduce Phi %d on invocation %d. CastPP %d doesn't have simple control.\", n->_idx, _invocation, use->_idx);\n@@ -596,1 +612,1 @@\n-      if (!can_reduce_check_users(use, nesting+1)) {\n+      if (!can_reduce_check_users(use, phi_nest_level+1)) {\n@@ -601,1 +617,1 @@\n-        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. CmpP\/N %d isn't reducible.\", n->_idx, _invocation, use->_idx);)\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Cannot reduce Phi %d on invocation %d. CmpP\/N %d isn't reducible.\", n->_idx, _invocation, use->_idx);)\n@@ -605,1 +621,1 @@\n-      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Can NOT reduce Phi %d on invocation %d. One of the uses is: %d %s\", n->_idx, _invocation, use->_idx, use->Name());)\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Cannot reduce Phi %d on invocation %d. One of the uses is: %d %s\", n->_idx, _invocation, use->_idx, use->Name());)\n@@ -632,1 +648,1 @@\n-  if (!can_reduce_phi_check_inputs(ophi) || !can_reduce_check_users(ophi, \/* nesting: *\/ 0)) {\n+  if (!can_reduce_phi_check_inputs(ophi) || !can_reduce_check_users(ophi, \/* phi_nest_level: *\/ 0)) {\n@@ -739,1 +755,1 @@\n-Node* ConnectionGraph::split_castpp_load_through_phi(Node* curr_addp, Node* curr_load, Node* region, GrowableArray<Node*>* bases_for_loads, GrowableArray<Node *>  &alloc_worklist) {\n+Node* ConnectionGraph::split_castpp_load_through_phi(Node* curr_addp, Node* curr_load, Node* region, GrowableArray<Node*>* bases_for_loads, GrowableArray<Node *>  &alloc_worklist, Unique_Node_List &reducible_merges) {\n@@ -789,1 +805,1 @@\n-  updates_after_load_split(data_phi, curr_load, alloc_worklist);\n+  updates_after_load_split(data_phi, curr_load, alloc_worklist, reducible_merges);\n@@ -866,1 +882,1 @@\n-void ConnectionGraph::reduce_phi_on_castpp_field_load(Node* curr_castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist) {\n+void ConnectionGraph::reduce_phi_on_castpp_field_load(Node* curr_castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist, Unique_Node_List &reducible_merges) {\n@@ -914,1 +930,1 @@\n-        Node* phi = split_castpp_load_through_phi(use, use_use, ophi->in(0), &bases_for_loads, alloc_worklist);\n+        Node* phi = split_castpp_load_through_phi(use, use_use, ophi->in(0), &bases_for_loads, alloc_worklist, reducible_merges);\n@@ -1022,1 +1038,1 @@\n-void ConnectionGraph::updates_after_load_split(Node* data_phi, Node* previous_load, GrowableArray<Node *>  &alloc_worklist) {\n+void ConnectionGraph::updates_after_load_split(Node* data_phi, Node* previous_load, GrowableArray<Node *>  &alloc_worklist, Unique_Node_List &reducible_merges) {\n@@ -1051,2 +1067,8 @@\n-      if (jobj_ptn == nullptr || !jobj_ptn->scalar_replaceable()) {\n-        continue;\n+      if (base->is_Phi()) {\n+        if (!reducible_merges.member(base)) {\n+          continue;\n+        }\n+      } else {\n+        if (jobj_ptn == nullptr || !jobj_ptn->scalar_replaceable()) {\n+          continue;\n+        }\n@@ -1075,1 +1097,1 @@\n-void ConnectionGraph::reduce_phi_on_field_access(Node* previous_addp, GrowableArray<Node *>  &alloc_worklist) {\n+void ConnectionGraph::reduce_phi_on_field_access(Node* previous_addp, GrowableArray<Node *>  &alloc_worklist, Unique_Node_List &reducible_merges) {\n@@ -1091,1 +1113,1 @@\n-      updates_after_load_split(data_phi, previous_load, alloc_worklist);\n+      updates_after_load_split(data_phi, previous_load, alloc_worklist, reducible_merges);\n@@ -1282,1 +1304,18 @@\n-void ConnectionGraph::reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist) {\n+void ConnectionGraph::reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist, Unique_Node_List &reducible_merges) {\n+  Unique_Node_List nested_phis;\n+  \/\/ Collect nested phi nodes first because the graph will change while splitting the child\/nested phi node.\n+  for (DUIterator_Fast imax, i = ophi->fast_outs(imax); i < imax; i++) {\n+    Node* use = ophi->fast_out(i);\n+    if (use->is_Phi()) {\n+      assert(use->_idx != ophi->_idx, \"Unexpected selfloop Phi.\");\n+      nested_phis.push(use);\n+    }\n+  }\n+\n+  \/\/ Splitting through the child phi nodes ahead of parent phi nodes in nested scenarios is crucial.\n+  \/\/ Ensure that the splits are applied to the load fields of child phi nodes before the parent phi nodes take place.\n+  for (uint i = 0; i < nested_phis.size(); i++) {\n+    Node *nested_phi = nested_phis.at(i);\n+    reduce_phi(nested_phi->as_Phi(), alloc_worklist, memnode_worklist, reducible_merges);\n+  }\n+\n@@ -1310,1 +1349,1 @@\n-    reduce_phi_on_castpp_field_load(castpps.at(i), alloc_worklist, memnode_worklist);\n+    reduce_phi_on_castpp_field_load(castpps.at(i), alloc_worklist, memnode_worklist, reducible_merges);\n@@ -1317,1 +1356,1 @@\n-      reduce_phi_on_field_access(use, alloc_worklist);\n+      reduce_phi_on_field_access(use, alloc_worklist, reducible_merges);\n@@ -4485,0 +4524,5 @@\n+      \/\/ Nested phi node, this Addp will go away when phi node is reduced\n+      if (addp_base->is_Phi()) {\n+        assert(reducible_merges.member(addp_base), \"nestedphi node must be part of reduce merge list\");\n+        continue;\n+      }\n@@ -4510,1 +4554,1 @@\n-        reduce_phi(n->as_Phi(), alloc_worklist, memnode_worklist);\n+        reduce_phi(n->as_Phi(), alloc_worklist, memnode_worklist, reducible_merges);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":75,"deletions":31,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -598,2 +598,2 @@\n-  void updates_after_load_split(Node* data_phi, Node* previous_load, GrowableArray<Node *>  &alloc_worklist);\n-  Node* split_castpp_load_through_phi(Node* curr_addp, Node* curr_load, Node* region, GrowableArray<Node*>* bases_for_loads, GrowableArray<Node *>  &alloc_worklist);\n+  void updates_after_load_split(Node* data_phi, Node* previous_load, GrowableArray<Node *>  &alloc_worklist, Unique_Node_List &reducible_merges);\n+  Node* split_castpp_load_through_phi(Node* curr_addp, Node* curr_load, Node* region, GrowableArray<Node*>* bases_for_loads, GrowableArray<Node *>  &alloc_worklist, Unique_Node_List &reducible_merges);\n@@ -608,1 +608,1 @@\n-  bool can_reduce_check_users(Node* n, uint nesting) const;\n+  bool can_reduce_check_users(Node* n, uint phi_nest_level) const;\n@@ -611,2 +611,2 @@\n-  void reduce_phi_on_field_access(Node* previous_addp, GrowableArray<Node *>  &alloc_worklist);\n-  void reduce_phi_on_castpp_field_load(Node* castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist);\n+  void reduce_phi_on_field_access(Node* previous_addp, GrowableArray<Node *>  &alloc_worklist, Unique_Node_List &reducible_merges);\n+  void reduce_phi_on_castpp_field_load(Node* castpp, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist, Unique_Node_List &reducible_merges);\n@@ -616,1 +616,1 @@\n-  void reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist);\n+  void reduce_phi(PhiNode* ophi, GrowableArray<Node *>  &alloc_worklist, GrowableArray<Node *>  &memnode_worklist, Unique_Node_List &reducible_merges);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1568,0 +1568,69 @@\n+\/\/------------------------------get_region_of_split_through_phi------------------------------\n+\/\/ Given a base node and a memory node, this function determines the region of split through phi.\n+\/\/ If the base node is not a phi node, it returns nullptr.\n+Node* LoadNode::get_region_of_split_through_base_phi(PhaseGVN* phase, Node *base) {\n+  Node* mem        = in(Memory);\n+  Node* address    = in(Address);\n+  bool base_is_phi = (base != nullptr) && base->is_Phi();\n+  Node* region = nullptr;\n+  DomResult dom_result = DomResult::Dominate;\n+  if (!base_is_phi) {\n+    assert(mem->is_Phi(), \"memory node should be a Phi\");\n+    region = mem->in(0);\n+    \/\/ Skip if the region dominates some control edge of the address.\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(address, region);\n+  } else if (!mem->is_Phi()) {\n+    assert(base_is_phi, \"base node should be a Phi\");\n+    region = base->in(0);\n+    \/\/ Skip if the region dominates some control edge of the memory.\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, region);\n+  } else if (base->in(0) != mem->in(0)) {\n+    assert(base_is_phi && mem->is_Phi(), \"base and memory nodes should be Phi\");\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, base->in(0));\n+    if (dom_result == DomResult::Dominate) {\n+      region = base->in(0);\n+    } else {\n+      dom_result = MemNode::maybe_all_controls_dominate(address, mem->in(0));\n+      if (dom_result == DomResult::Dominate) {\n+        region = mem->in(0);\n+      }\n+      \/\/ Otherwise we encountered a complex graph.\n+    }\n+  } else {\n+    assert(base->in(0) == mem->in(0), \"base and memory nodes should have the same region\");\n+    region = mem->in(0);\n+  }\n+\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  if (dom_result != DomResult::Dominate) {\n+    if (dom_result == DomResult::EncounteredDeadCode) {\n+      \/\/ There is some dead code which eventually will be removed in IGVN.\n+      \/\/ Once this is the case, we get an unambiguous dominance result.\n+      \/\/ Push the node to the worklist again until the dead code is removed.\n+      igvn->_worklist.push(this);\n+    }\n+    return nullptr;\n+  }\n+  return region;\n+}\n+\n+static bool can_split_through_phi_helper(Node *base, Node *mem) {\n+  if (base == nullptr || !base->is_Phi()) {\n+    return false;\n+  }\n+\n+  if (!mem->is_Phi()) {\n+    \/\/ Skip if the region dominates some control edge of the memory.\n+    if (!MemNode::all_controls_dominate(mem, base->in(0)))\n+      return false;\n+  } else if (base->in(0) != mem->in(0)) {\n+    \/\/ Skip if the region dominates some control edge of the memory.\n+    if (!MemNode::all_controls_dominate(mem, base->in(0))) {\n+      return false; \/\/ complex graph\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -1573,1 +1642,1 @@\n-\/\/ Some differences from original method (split_through_phi):\n+\/\/ The difference from the original method (split_through_phi) is:\n@@ -1575,1 +1644,1 @@\n-bool LoadNode::can_split_through_phi_base(PhaseGVN* phase) {\n+bool LoadNode::can_split_through_phi_base(PhaseGVN* phase, bool nested) {\n@@ -1585,1 +1654,1 @@\n-  if (req() > 3 || base == nullptr || !base->is_Phi()) {\n+  if (req() > 3 || !can_split_through_phi_helper(base, mem)) {\n@@ -1589,7 +1658,9 @@\n-  if (!mem->is_Phi()) {\n-    if (!MemNode::all_controls_dominate(mem, base->in(0))) {\n-      return false;\n-    }\n-  } else if (base->in(0) != mem->in(0)) {\n-    if (!MemNode::all_controls_dominate(mem, base->in(0))) {\n-      return false;\n+  if (nested) {\n+    for (uint i = 1; i < base->req(); i++) {\n+      if (base->in(i)->is_Phi()) {\n+        \/\/ base->in(i) is the parent phi node for base node.\n+        Node *mem_node_for_load_after_opt = get_memory_node_for_nestedphi_after_split(phase, base, i);\n+        if (!mem_node_for_load_after_opt || !can_split_through_phi_helper(base->in(i), mem_node_for_load_after_opt)) {\n+          return false;\n+        }\n+      }\n@@ -1598,1 +1669,0 @@\n-\n@@ -1602,0 +1672,28 @@\n+\/\/------------------------------get_memory_node_for_nestedphi_after_split------------------------------\n+\/\/ Given a nestedphi node and its parentphi node, this function pretends that a split has occurred on a load field\n+\/\/ and returns the memory node of the new load field node that is attached to the parentphi node.\n+\/\/ Note that this function doesn't actually perform the split.\n+\/\/ If a split is impossible, it returns nullptr.\n+Node* LoadNode::get_memory_node_for_nestedphi_after_split(PhaseGVN* phase, Node *base, uint parent_idx) {\n+  Node* mem        = in(Memory);\n+  Node* region = get_region_of_split_through_base_phi(phase, base);\n+  if (region == nullptr) {\n+    return nullptr;\n+  }\n+\n+  Node* in = region->in(parent_idx);\n+  if (region->is_CountedLoop() && region->as_Loop()->is_strip_mined() && parent_idx == LoopNode::EntryControl &&\n+    in != nullptr && in->is_OuterStripMinedLoop()) {\n+    \/\/ No node should go in the outer strip mined loop\n+    in = in->in(LoopNode::EntryControl);\n+  }\n+  if (in == nullptr || in == phase->C->top()) {\n+    \/\/ Dead path?  Use a dead data op\n+    return phase->C->top()->in(Memory);\n+  } else if (mem->is_Phi() && (mem->in(0) == region)) {\n+    return mem->in(parent_idx);\n+  }\n+\n+  return mem;\n+}\n+\n@@ -1638,1 +1736,1 @@\n-    if (cnt == 3) {\n+    if (cnt == 3 && !ignore_missing_instance_id) {\n@@ -1682,39 +1780,2 @@\n-  Node* region;\n-  DomResult dom_result = DomResult::Dominate;\n-  if (!base_is_phi) {\n-    assert(mem->is_Phi(), \"sanity\");\n-    region = mem->in(0);\n-    \/\/ Skip if the region dominates some control edge of the address.\n-    \/\/ We will check `dom_result` later.\n-    dom_result = MemNode::maybe_all_controls_dominate(address, region);\n-  } else if (!mem->is_Phi()) {\n-    assert(base_is_phi, \"sanity\");\n-    region = base->in(0);\n-    \/\/ Skip if the region dominates some control edge of the memory.\n-    \/\/ We will check `dom_result` later.\n-    dom_result = MemNode::maybe_all_controls_dominate(mem, region);\n-  } else if (base->in(0) != mem->in(0)) {\n-    assert(base_is_phi && mem->is_Phi(), \"sanity\");\n-    dom_result = MemNode::maybe_all_controls_dominate(mem, base->in(0));\n-    if (dom_result == DomResult::Dominate) {\n-      region = base->in(0);\n-    } else {\n-      dom_result = MemNode::maybe_all_controls_dominate(address, mem->in(0));\n-      if (dom_result == DomResult::Dominate) {\n-        region = mem->in(0);\n-      }\n-      \/\/ Otherwise we encountered a complex graph.\n-    }\n-  } else {\n-    assert(base->in(0) == mem->in(0), \"sanity\");\n-    region = mem->in(0);\n-  }\n-\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-  if (dom_result != DomResult::Dominate) {\n-    if (dom_result == DomResult::EncounteredDeadCode) {\n-      \/\/ There is some dead code which eventually will be removed in IGVN.\n-      \/\/ Once this is the case, we get an unambiguous dominance result.\n-      \/\/ Push the node to the worklist again until the dead code is removed.\n-      igvn->_worklist.push(this);\n-    }\n+  Node* region = get_region_of_split_through_base_phi(phase, base);\n+  if (region == nullptr) {\n@@ -1726,0 +1787,1 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":113,"deletions":51,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -251,1 +251,6 @@\n-  bool can_split_through_phi_base(PhaseGVN *phase);\n+  bool can_split_through_phi_base(PhaseGVN *phase, bool nested = false);\n+\n+  \/\/ Returns a memory node for load node after splitting through nestedphi node\n+  \/\/ Calling code is responsible to clean up (remove_dead_node) after use\n+  Node* get_memory_node_for_nestedphi_after_split(PhaseGVN* phase, Node *base, uint parent_idx);\n+  Node* get_region_of_split_through_base_phi(PhaseGVN* phase, Node *base);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,742 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8341293\n+ * @summary Tests that C2 can correctly scalar replace some object allocation merges.\n+ * @library \/test\/lib \/\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @run driver\/timeout=240000 compiler.c2.irTests.scalarReplacement.AllocationMergesNestedPhiTests\n+ *\/\n+public class AllocationMergesNestedPhiTests {\n+    private int invocations = 0;\n+    private static Point global_escape = new Point(2022, 2023);\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework();\n+\n+        Scenario scenario0 = new Scenario(0, \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                                             \"-XX:+UnlockDiagnosticVMOptions\",\n+                                             \"-XX:+ReduceAllocationMerges\",\n+                                             \"-XX:+TraceReduceAllocationMerges\",\n+                                             \"-XX:+DeoptimizeALot\",\n+                                             \"-XX:+UseCompressedOops\",\n+                                             \"-XX:+UseCompressedClassPointers\",\n+                                             \"-XX:CompileCommand=inline,*Point::*\",\n+                                             \"-XX:CompileCommand=inline,*Nested::*\",\n+                                             \"-XX:CompileCommand=exclude,*::dummy*\");\n+\n+        Scenario scenario1 = new Scenario(1, \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                                             \"-XX:+UnlockDiagnosticVMOptions\",\n+                                             \"-XX:+ReduceAllocationMerges\",\n+                                             \"-XX:+TraceReduceAllocationMerges\",\n+                                             \"-XX:+DeoptimizeALot\",\n+                                             \"-XX:+UseCompressedOops\",\n+                                             \"-XX:-UseCompressedClassPointers\",\n+                                             \"-XX:CompileCommand=inline,*Point::*\",\n+                                             \"-XX:CompileCommand=inline,*Nested::*\",\n+                                             \"-XX:CompileCommand=exclude,*::dummy*\");\n+\n+        Scenario scenario2 = new Scenario(2, \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                                             \"-XX:+UnlockDiagnosticVMOptions\",\n+                                             \"-XX:+ReduceAllocationMerges\",\n+                                             \"-XX:+TraceReduceAllocationMerges\",\n+                                             \"-XX:+DeoptimizeALot\",\n+                                             \"-XX:-UseCompressedOops\",\n+                                             \"-XX:CompileCommand=inline,*Point::*\",\n+                                             \"-XX:CompileCommand=inline,*Nested::*\",\n+                                             \"-XX:CompileCommand=exclude,*::dummy*\");\n+\n+        Scenario scenario3 = new Scenario(3, \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                                             \"-XX:+UnlockDiagnosticVMOptions\",\n+                                             \"-XX:CompileCommand=inline,*::charAt*\",\n+                                             \"-XX:CompileCommand=inline,*Point::*\",\n+                                             \"-XX:CompileCommand=inline,*Nested::*\",\n+                                             \"-XX:CompileCommand=exclude,*::dummy*\");\n+\n+        framework.addScenarios(scenario0, scenario1, scenario2, scenario3).start();\n+    }\n+\n+    \/\/ ------------------ No Scalar Replacement Should Happen in The Tests Below ------------------- \/\/\n+\n+    @Run(test = {\n+                 \"testRematerialize_SingleObj_C2\",\n+                 \"testRematerialize_TryCatch_C2\",\n+                 \"testMerge_TryCatchFinally_C2\",\n+                 \"testRematerialize_MultiObj_C2\",\n+                 \"testGlobalEscapeInThread_C2\",\n+                 \"testGlobalEscapeInThreadWithSync_C2\",\n+                 \"testFieldEscapeWithMerge_C2\",\n+                 \"testNestedPhi_FieldLoad_C2\",\n+                 \"testThreeLevelNestedPhi_C2\",\n+                 \"testNestedPhiProcessOrder_C2\",\n+                 \"testNestedPhi_TryCatch_C2\",\n+                 \"testBailOut_C2\",\n+                 \"testNestedPhiPolymorphic_C2\",\n+                 \"testNestedPhiWithTrap_C2\",\n+                 \"testNestedPhiWithLambda_C2\",\n+                 \"testMultiParentPhi_C2\"\n+                })\n+    public void runner(RunInfo info) {\n+        invocations++;\n+\n+        Random random = info.getRandom();\n+        boolean cond1 = invocations % 2 == 0;\n+        boolean cond2 = !cond1;\n+\n+        int l = random.nextInt();\n+        int w = random.nextInt();\n+        int x = random.nextInt();\n+        int y = random.nextInt();\n+        int z = random.nextInt();\n+        try {\n+            Asserts.assertEQ(testRematerialize_SingleObj_Interp(cond1, x, y),       testRematerialize_SingleObj_C2(cond1, x, y));\n+        } catch (Exception e) {}\n+        Asserts.assertEQ(testRematerialize_TryCatch_Interp(cond1, l, x, y),         testRematerialize_TryCatch_C2(cond1, l, x, y));\n+        Asserts.assertEQ(testMerge_TryCatchFinally_Interp(cond1, l, x, y),          testMerge_TryCatchFinally_C2(cond1, l, x, y));\n+        Asserts.assertEQ(testRematerialize_MultiObj_Interp(cond1, cond2, x, y),     testRematerialize_MultiObj_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testGlobalEscapeInThread_Intrep(cond1, l, x, y),           testGlobalEscapeInThread_C2(cond1, l, x, y));\n+        Asserts.assertEQ(testGlobalEscapeInThreadWithSync_Intrep(cond1, x, y),      testGlobalEscapeInThreadWithSync_C2(cond1, x, y));\n+        Asserts.assertEQ(testFieldEscapeWithMerge_Intrep(cond1, x, y),              testFieldEscapeWithMerge_C2(cond1, x, y));\n+        Asserts.assertEQ(testNestedPhi_FieldLoad_Interp(cond1, cond2, x, y),        testNestedPhi_FieldLoad_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testThreeLevelNestedPhi_Interp(cond1, cond2, x, y),        testThreeLevelNestedPhi_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testNestedPhiProcessOrder_Interp(cond1, cond2, x, y),      testNestedPhiProcessOrder_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testNestedPhi_TryCatch_Interp(cond1, cond2, x, y),         testNestedPhi_TryCatch_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testBailOut_Interp(cond1, cond2, x, y),                    testBailOut_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testNestedPhiPolymorphic_Interp(cond1, cond2, x, y),       testNestedPhiPolymorphic_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testNestedPhiWithTrap_Interp(cond1, cond2, x, y),          testNestedPhiWithTrap_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testNestedPhiWithLambda_Interp(cond1, cond2, x, y),        testNestedPhiWithLambda_C2(cond1, cond2, x, y));\n+        Asserts.assertEQ(testMultiParentPhi_Interp(cond1, x, y),                    testMultiParentPhi_C2(cond1, x, y));\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testRematerialize_SingleObj(boolean cond1, int x, int y) throws Exception {\n+        Point p = new Point(x, y);\n+\n+        if (cond1) {\n+            p = new Point(x+1, y+1);\n+            global_escape = p;\n+        }\n+\n+        if (!cond1)\n+            throw new Exception();\n+\n+        return p.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \">=1\", IRNode.SAFEPOINT_SCALAR_MERGE, \">=1\"},\n+        phase = CompilePhase.ITER_GVN_AFTER_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfAnd = {\"EliminateAllocations\", \"true\", \"DeoptimizeALot\", \"true\"})\n+    int testRematerialize_SingleObj_C2(boolean cond1,int x, int y) throws Exception { return testRematerialize_SingleObj(cond1, x, y); }\n+\n+    @DontCompile\n+    int testRematerialize_SingleObj_Interp(boolean cond1, int x, int y) throws Exception { return testRematerialize_SingleObj(cond1, x, y); }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testRematerialize_TryCatch(boolean cond1, int n, int x, int y) {\n+        Point p = new Point(x, y);\n+        if (cond1) {\n+            p = new Point(x+1, y+1);\n+            global_escape = p;\n+        }\n+        try {\n+            p.y = n\/0;\n+        } catch (Exception e) {}\n+\n+        return p.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \">=1\", IRNode.SAFEPOINT_SCALAR_MERGE, \">=1\",  IRNode.SAFEPOINT_SCALAR_OBJECT, \">=1\"},\n+        phase = CompilePhase.ITER_GVN_AFTER_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testRematerialize_TryCatch_C2(boolean cond1, int n, int x, int y) { return testRematerialize_TryCatch(cond1, n, x, y); }\n+\n+    @DontCompile\n+    int testRematerialize_TryCatch_Interp(boolean cond1, int n, int x, int y) { return testRematerialize_TryCatch(cond1, n, x, y); }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testMerge_TryCatchFinally(boolean cond1, int n, int x, int y) {\n+\n+        Point p = new Point(x, y);\n+        try {\n+            if (cond1) {\n+                p = new Point(x+1, y+1);\n+            }\n+        } catch (Exception e) {\n+            p.y = n;\n+        } finally {\n+            dummy_defaults();\n+            p = new Point(n, x+y);\n+        }\n+\n+        return p.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \">=2\"},\n+        phase = CompilePhase.ITER_GVN_AFTER_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testMerge_TryCatchFinally_C2(boolean cond1, int n, int x, int y) { return testMerge_TryCatchFinally(cond1, n, x, y); }\n+\n+    @DontCompile\n+    int testMerge_TryCatchFinally_Interp(boolean cond1, int n, int x, int y) { return testMerge_TryCatchFinally(cond1, n, x, y); }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testRematerialize_MultiObj(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(x+2, y+4);\n+\n+        if (cond1) {\n+            p1 = new Point(x+1, y+1);\n+            global_escape = p1;\n+        }\n+\n+        if (x%2 == 1) {\n+            p2 = new Point(x*2, y\/4);\n+        }\n+\n+        try {\n+            String s = null;\n+            s.length();\n+        } catch (Exception e) {}\n+\n+        if (cond2)\n+            return p1.y;\n+        return p2.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \">=1\", IRNode.SAFEPOINT_SCALAR_MERGE, \">=1\", IRNode.SAFEPOINT_SCALAR_OBJECT, \">=2\"},\n+        phase= CompilePhase.ITER_GVN_AFTER_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testRematerialize_MultiObj_C2(boolean cond1, boolean cond2, int x, int y) { return testRematerialize_MultiObj(cond1, cond2, x, y); }\n+\n+    @DontCompile\n+    int testRematerialize_MultiObj_Interp(boolean cond1, boolean cond2, int x, int y) { return testRematerialize_MultiObj(cond1, cond2, x, y); }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @ForceInline\n+    public int testGlobalEscapeInThread(boolean cond, int n, int x, int y) {\n+        Point p = new Point(x, y);\n+        Object syncObject = new Object();\n+        Runnable threadLoop = () -> {\n+            if (cond)\n+                global_escape = new Point( x+n, y+n);\n+        };\n+        Thread thLoop = new Thread(threadLoop);\n+        thLoop.start();\n+        try {\n+            thLoop.join();\n+        } catch (InterruptedException e) {}\n+\n+        if (cond && n % 2 == 1)\n+            p.x = global_escape.x;\n+\n+        return p.y;\n+    }\n+\n+    @DontCompile\n+    int testGlobalEscapeInThread_Intrep(boolean cond1, int n, int x, int y) { return testGlobalEscapeInThread(cond1, n, x, y); }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \">=4\"},\n+        phase= CompilePhase.ITER_GVN_AFTER_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testGlobalEscapeInThread_C2(boolean cond1, int n, int x, int y) { return testGlobalEscapeInThread(cond1, n, x, y); }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @ForceInline\n+    public int testGlobalEscapeInThreadWithSync(boolean cond, int x, int y) {\n+        Point p = new Point(x, y);\n+        for (int i = 0; i < 2; i++) {\n+            if (cond)\n+                p = new Point(x+i, y+i);\n+            TestThread th = new TestThread(p);\n+            th.start();\n+        }\n+        return p.y;\n+    }\n+\n+    @DontCompile\n+    int testGlobalEscapeInThreadWithSync_Intrep(boolean cond1, int x, int y) { return testGlobalEscapeInThreadWithSync(cond1, x, y); }\n+\n+    @Test\n+    int testGlobalEscapeInThreadWithSync_C2(boolean cond1, int x, int y) { return testGlobalEscapeInThreadWithSync(cond1, x, y); }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @ForceInline\n+    public int testFieldEscapeWithMerge(boolean cond, int x, int y) {\n+\n+        Point p1 = new Point(x, y);\n+        Point p2 = new Point(x+y, x*y);\n+        Line ln = new Line(p1, p2);\n+        if (cond) {\n+            ln.p1 = new Point(x-y, x\/y);\n+            global_escape = ln.p2;\n+        }\n+        return ln.p1.y;\n+    }\n+\n+    @DontCompile\n+    int testFieldEscapeWithMerge_Intrep(boolean cond1, int x, int y) { return testFieldEscapeWithMerge(cond1, x, y); }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \">=1\"},\n+        phase= CompilePhase.ITER_GVN_AFTER_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testFieldEscapeWithMerge_C2(boolean cond1, int x, int y) { return testFieldEscapeWithMerge(cond1, x, y); }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @ForceInline\n+    int testNestedPhi_FieldLoad(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        if (cond1) {\n+            p1 = new Point(x+30, y+40);\n+        }\n+        Point p2 = p1;\n+        if (cond2) {\n+          p2 = new Point(x+50, y+60);\n+        }\n+        return  p2.x + p2.y;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"3\" },\n+        phase = CompilePhase.PHASEIDEAL_BEFORE_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    @IR(counts = { IRNode.ALLOC, \"0\" },\n+        phase = CompilePhase.ITER_GVN_AFTER_ELIMINATION,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testNestedPhi_FieldLoad_C2(boolean cond1, boolean cond2, int x, int y) {\n+       return testNestedPhi_FieldLoad(cond1, cond2, x, y);\n+    }\n+\n+    @DontCompile\n+    int testNestedPhi_FieldLoad_Interp(boolean cond1, boolean cond2, int x, int y) {\n+       return testNestedPhi_FieldLoad(cond1, cond2, x, y);\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @DontCompile\n+    int testThreeLevelNestedPhi_Interp(boolean cond1, boolean cond2, int x, int y) { return testThreeLevelNestedPhi(cond1, cond2, x, y); }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"3\" },\n+        phase = CompilePhase.PHASEIDEAL_BEFORE_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    @IR(counts = { IRNode.ALLOC, \"<=2\" },\n+        phase = CompilePhase.ITER_GVN_AFTER_ELIMINATION,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testThreeLevelNestedPhi_C2(boolean cond1, boolean cond2, int x, int y) { return testThreeLevelNestedPhi(cond1, cond2, x, y); }\n+\n+    @ForceInline\n+    int testThreeLevelNestedPhi(boolean cond1, boolean cond2, int x, int y) {\n+\n+        Point p1 = new Point(x, y);\n+        if (cond1) {\n+            p1 = new Point(x, y);\n+        }\n+\n+        Point p2 = p1;\n+        if (cond2) {\n+            p2 = new Point(x, y);\n+        }\n+\n+        Point p3 = p2;\n+        if (cond1 && cond2) {\n+            p3 = new Point(x, y);\n+        }\n+        return  p3.x + p3.y;\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @DontCompile\n+    int testNestedPhiProcessOrder_Interp(boolean cond1, boolean cond2, int x, int y) { return testNestedPhiProcessOrder(cond1, cond2, x, y); }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" },\n+        phase = CompilePhase.PHASEIDEAL_BEFORE_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    @IR(counts = { IRNode.ALLOC, \"0\" },\n+        phase = CompilePhase.ITER_GVN_AFTER_ELIMINATION,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testNestedPhiProcessOrder_C2(boolean cond1, boolean cond2, int x, int y) { return testNestedPhiProcessOrder(cond1, cond2, x, y); }\n+\n+    @ForceInline\n+    \/\/ make sure the child phis are processed fist\n+    int testNestedPhiProcessOrder(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = p1;\n+        if (cond1)\n+            p1 = new Point(x, y);\n+\n+        if (cond2)\n+            p2 = p1;\n+\n+       return p2.x;\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @DontCompile\n+    int testNestedPhi_TryCatch_Interp(boolean cond1, boolean cond2, int x, int y) { return testNestedPhi_TryCatch(cond1, cond2, x, y); }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"2\" },\n+        phase = CompilePhase.PHASEIDEAL_BEFORE_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    @IR(counts = { IRNode.ALLOC, \"0\" },\n+        phase = CompilePhase.ITER_GVN_AFTER_ELIMINATION,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testNestedPhi_TryCatch_C2(boolean cond1, boolean cond2, int x, int y) { return testNestedPhi_TryCatch(cond1, cond2, x, y); }\n+\n+    @ForceInline\n+    int testNestedPhi_TryCatch(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = p1;\n+        try {\n+            if (cond1)\n+            p1 = new Point(x, y);\n+            if (cond2)\n+                p2 = p1;\n+        } catch (Exception e) {\n+            p2 = new Point (x, y);\n+        }\n+        return p2.x;\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @DontCompile\n+    int testBailOut_Interp(boolean cond1, boolean cond2, int x, int y) { return testBailOut(cond1, cond2, x, y); }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"3\" },\n+        phase = CompilePhase.PHASEIDEAL_BEFORE_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    @IR(counts = { IRNode.ALLOC, \"0\" },\n+        phase = CompilePhase.ITER_GVN_AFTER_ELIMINATION,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testBailOut_C2(boolean cond1, boolean cond2, int x, int y) { return testBailOut(cond1, cond2, x, y); }\n+\n+    @ForceInline\n+    int testBailOut(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = p1;\n+        if (cond1)\n+          p1 = new Point(x, y);\n+\n+        if (cond2)\n+          p2 = new Point(x, y);\n+\n+        try {\n+            if (cond1 && cond2)\n+                throw new Exception();\n+        } catch (Exception e) {}\n+\n+        return p2.getX();\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @DontCompile\n+    int testNestedPhiPolymorphic_Interp(boolean cond1, boolean cond2, int x, int y) { return testNestedPhiPolymorphic(cond1, cond2, x, y); }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"3\" },\n+        phase = CompilePhase.PHASEIDEAL_BEFORE_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    @IR(counts = { IRNode.ALLOC, \"0\" },\n+        phase = CompilePhase.ITER_GVN_AFTER_ELIMINATION,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testNestedPhiPolymorphic_C2(boolean cond1, boolean cond2, int x, int y) { return testNestedPhiPolymorphic(cond1, cond2, x, y); }\n+\n+    @ForceInline\n+    int testNestedPhiPolymorphic(boolean cond1, boolean cond2, int x, int l) {\n+        Shape obj1 = new Square(l);\n+        if (cond1)\n+            obj1 = new Circle(l);\n+        Shape obj2 = obj1;\n+        if (cond2)\n+            obj2 = new Circle(x + l\/5);\n+        return obj2.l;\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @DontCompile\n+    int testNestedPhiWithTrap_Interp(boolean cond1, boolean cond2, int x, int y) { return testNestedPhiWithTrap(cond1, cond2, x, y); }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \"3\" },\n+        phase = CompilePhase.PHASEIDEAL_BEFORE_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    @IR(counts = { IRNode.ALLOC, \"2\" },\n+        phase = CompilePhase.ITER_GVN_AFTER_ELIMINATION,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testNestedPhiWithTrap_C2(boolean cond1, boolean cond2, int x, int y) { return testNestedPhiWithTrap(cond1, cond2, x, y); }\n+\n+    @ForceInline\n+    int testNestedPhiWithTrap(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        if (cond1)\n+            p1 = new Point(x, y);\n+\n+        Point p2 = p1;\n+        dummy();\n+        if (cond2)\n+            p2 = new Point(x, y);\n+\n+        return p2.x;\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+   @DontCompile\n+    int testNestedPhiWithLambda_Interp(boolean cond1, boolean cond2, int x, int y) { return testNestedPhiWithLambda(cond1, cond2, x, y); }\n+\n+    @Test\n+    @IR(counts = { IRNode.ALLOC, \">=3\" },\n+        phase = CompilePhase.PHASEIDEAL_BEFORE_EA,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    @IR(counts = { IRNode.ALLOC, \"<=2\" },\n+        phase = CompilePhase.ITER_GVN_AFTER_ELIMINATION,\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"EliminateAllocations\", \"true\"})\n+    int testNestedPhiWithLambda_C2(boolean cond1, boolean cond2, int x, int y) { return testNestedPhiWithLambda(cond1, cond2, x, y); }\n+\n+    @ForceInline\n+    public int testNestedPhiWithLambda(boolean cond1, boolean cond2, int x, int y) {\n+        Point1 p1 = new Point1(x, y);\n+        if (cond1)\n+            p1 = new Point1(x, y);\n+\n+        Point1 p2 = p1;\n+        PointSupplier ps = () -> (cond2? (new Point1(x, y)) : (new Point1(x+70, y+80)));\n+        if (cond2)\n+            p2 = ps.getPoint();\n+        return p2.x;\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+    @DontCompile\n+    int testMultiParentPhi_Interp(boolean cond1, int x, int y) { return testMultiParentPhi(cond1, x, y); }\n+\n+    @Test\n+    int testMultiParentPhi_C2(boolean cond1, int x, int y) { return testMultiParentPhi(cond1, x, y); }\n+\n+    @ForceInline\n+    public static int testMultiParentPhi(boolean cond1, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p3 = new Point(x+30, y+31);\n+        if (cond1) {\n+          p1 = new Point(x+12, y+13);\n+          p3 = new Point(x+32, y+33);\n+        }\n+        Point p2 = new Point(x+20, y+21);\n+        try {\n+           Point p4 = new Point(x+40, y+41);\n+        } catch (NullPointerException ne) {\n+            p2 = p3;\n+        } catch (Exception e) {\n+            p2 = p1;\n+        }\n+        return p2.x;\n+    }\n+\n+   \/\/ ------------------ Utility for Testing ------------------- \/\/\n+\n+    @DontCompile\n+    static void dummy() {\n+    }\n+\n+    @DontCompile\n+    static int dummy(Point p) {\n+        return p.x * p.y;\n+    }\n+\n+    @DontCompile\n+    static int dummy(int x) {\n+        return x;\n+    }\n+\n+    @DontCompile\n+    static Point dummy(int x, int y) {\n+        return new Point(x, y);\n+    }\n+\n+    @DontCompile\n+    static String dummy(String str) {\n+        return str;\n+    }\n+\n+    @DontCompile\n+    static ADefaults dummy_defaults() {\n+        return new ADefaults();\n+    }\n+\n+    static class Nested {\n+        int x, y;\n+        Nested other;\n+        Nested(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+            this.other = null;\n+        }\n+    }\n+\n+    static class Point {\n+        int x, y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (!(o instanceof Point)) return false;\n+            Point p = (Point) o;\n+            return (p.x == x) && (p.y == y);\n+        }\n+\n+        int getX() {\n+            return x;\n+        }\n+    }\n+\n+   class Line {\n+       Point p1, p2;\n+       Line(Point p1, Point p2) {\n+           this.p1 = p1;\n+           this.p2 = p2;\n+       }\n+    }\n+\n+    interface PointSupplier {\n+        Point1 getPoint();\n+    }\n+\n+   class Point1 implements PointSupplier {\n+       int x, y;\n+       Point1(int x, int y) {\n+           this.x = x;\n+           this.y = y;\n+       }\n+       public Point1 getPoint() {\n+           return this;\n+       }\n+    }\n+\n+    class Shape {\n+        int x, y, l;\n+        Shape(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    class Square extends Shape {\n+        Square(int l) {\n+            super(0, 0);\n+            this.l = l;\n+        }\n+    }\n+\n+    class Circle extends Shape {\n+        Circle(int l) {\n+            super(0, 0);\n+            this.l = l;\n+        }\n+    }\n+\n+    static class ADefaults {\n+        static int ble;\n+        int i;\n+        @DontCompile\n+        ADefaults(int i) { this.i = i; }\n+        @DontCompile\n+        ADefaults() { }\n+    }\n+\n+    class TestThread extends Thread {\n+        private static Object syncObject = new Object();\n+        Point p;\n+\n+        TestThread(Point p) {\n+            this.p = p;\n+        }\n+\n+        public void run() {\n+            try {\n+                synchronized(syncObject) {\n+                    p = new Point(1,1);\n+                    global_escape = p;\n+                }\n+            } catch(Exception e){}\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesNestedPhiTests.java","additions":742,"deletions":0,"binary":false,"changes":742,"status":"added"},{"patch":"@@ -1737,0 +1737,10 @@\n+    public static final String SAFEPOINT_SCALAR_MERGE = PREFIX + \"SAFEPOINT_SCALAR_MERGE\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SAFEPOINT_SCALAR_MERGE, \"SafePointScalarMerge\");\n+    }\n+\n+    public static final String SAFEPOINT_SCALAR_OBJECT = PREFIX + \"SAFEPOINT_SCALAR_OBJECT\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SAFEPOINT_SCALAR_OBJECT, \"SafePointScalarObject\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,691 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public abstract class AllocationMergesNestedPhi {\n+    private static final int SIZE        = 1000000;\n+    private static final boolean cond1[] = new boolean[SIZE];\n+    private static final boolean cond2[] = new boolean[SIZE];\n+    private static final int ws[]        = new int[SIZE];\n+    private static final int xs[]        = new int[SIZE];\n+    private static final int ys[]        = new int[SIZE];\n+    private static final int zs[]        = new int[SIZE];\n+    private static Load global_escape   = new Load(2022, 2023);\n+    private RandomGenerator rng          = RandomGeneratorFactory.getDefault().create();\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @Setup\n+    public void setup() {\n+        for (int i = 0; i < SIZE; i++) {\n+            cond1[i] = i % 2 == 0;\n+            cond2[i] = i % 2 == 1;\n+\n+            ws[i] = rng.nextInt();\n+            xs[i] = rng.nextInt();\n+            ys[i] = rng.nextInt();\n+            zs[i] = rng.nextInt();\n+        }\n+    }\n+\n+    \/\/ -------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testRematerialize_SingleObj(boolean cond1, int x, int y) throws Exception {\n+        Load p = new Load(x, y);\n+\n+        if (cond1) {\n+            p = new Load(x+1, y+1);\n+            global_escape = p;\n+        }\n+\n+        if (!cond1)\n+            throw new Exception();\n+\n+        return p.y;\n+    }\n+\n+    @Benchmark\n+    public void testRematerialize_SingleObj_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            try {\n+                result += testRematerialize_SingleObj(cond1[i], xs[i], ys[i]);\n+            } catch (Exception e) {}\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testRematerialize_TryCatch(boolean cond1, int n, int x, int y) {\n+        Load p = new Load(x, y);\n+        int a = 5;\n+        int b = 10-5;\n+        if (cond1) {\n+            p = new Load(x+1, y+1);\n+            global_escape = p;\n+        }\n+        try {\n+            p.y = n\/(a-b);\n+        } catch (Exception e) {}\n+\n+        return p.y;\n+    }\n+\n+    @Benchmark\n+    public void testRematerialize_TryCatch_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testRematerialize_TryCatch(cond1[i], xs[i], ys[i], zs[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testMerge_TryCatchFinally(boolean cond1, int n, int x, int y) {\n+\n+        Point p = new Point(x, y);\n+        try {\n+            if (cond1) {\n+                p = new Point(x+1, y+1);\n+            }\n+        } catch (Exception e) {\n+            p.y = n;\n+        } finally {\n+            dummy_defaults();\n+            p = new Point(n, x+y);\n+        }\n+\n+        return p.y;\n+    }\n+\n+    @Benchmark\n+    public void testMerge_TryCatchFinally_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testMerge_TryCatchFinally(cond1[i], xs[i], ys[i], zs[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testRematerialize_MultiObj(boolean cond1, boolean cond2, int x, int y) {\n+        Load p1 = new Load(x, y);\n+        Load p2 = new Load(x+2, y+4);\n+\n+        if (cond1) {\n+            p1 = new Load(x+1, y+1);\n+            global_escape = p1;\n+        }\n+\n+        if (x%2 == 1) {\n+            p2 = new Load(x*2, y\/4);\n+        }\n+\n+        try {\n+            String s = null;\n+            s.length();\n+        } catch (Exception e) {}\n+\n+        if (cond2)\n+            return p1.y;\n+        return p2.y;\n+    }\n+\n+    @Benchmark\n+    public void testRematerialize_MultiObj_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testRematerialize_MultiObj(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testFieldEscapeWithMerge(boolean cond, int x, int y) {\n+\n+        Load p1 = new Load(x, y);\n+        Load p2 = new Load(x+y, x*y);\n+        Line ln = new Line(p1, p2);\n+        if (cond) {\n+            ln.p1 = new Load(x-y, x\/y);\n+            global_escape = ln.p2;\n+        }\n+        return ln.p1.y;\n+    }\n+\n+    @Benchmark\n+    public void testFieldEscapeWithMerge_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testFieldEscapeWithMerge(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testNestedPhi_FieldLoad(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        if (cond1) {\n+            p1 = new Point(x+30, y+40);\n+        }\n+        Point p2 = p1;\n+        if (cond2) {\n+          p2 = new Point(x+50, y+60);\n+        }\n+        return  p2.x + p2.y;\n+    }\n+\n+    @Benchmark\n+    public void testNestedPhi_FieldLoad_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testNestedPhi_FieldLoad(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testThreeLevelNestedPhi(boolean cond1, boolean cond2, int x, int y) {\n+\n+        Point p1 = new Point(x, y);\n+        if (cond1) {\n+            p1 = new Point(x, y);\n+        }\n+\n+        Point p2 = p1;\n+        if (cond2) {\n+            p2 = new Point(x, y);\n+        }\n+\n+        Point p3 = p2;\n+        if (cond1 && cond2) {\n+            p3 = new Point(x, y);\n+        }\n+        return  p3.x + p3.y;\n+    }\n+\n+    @Benchmark\n+    public void testThreeLevelNestedPhi_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testThreeLevelNestedPhi(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    \/\/ make sure the child phis are processed fist\n+    int testNestedPhiProcessOrder(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = p1;\n+        if (cond1)\n+            p1 = new Point(x, y);\n+\n+        if (cond2)\n+            p2 = p1;\n+\n+       return p2.x;\n+    }\n+\n+    @Benchmark\n+    public void testNestedPhiProcessOrder_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testNestedPhiProcessOrder(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testNestedPhi_TryCatch(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = p1;\n+        try {\n+            if (cond1)\n+            p1 = new Point(x, y);\n+            if (cond2)\n+                p2 = p1;\n+        } catch (Exception e) {\n+            p2 = new Point (x, y);\n+        }\n+        return p2.x;\n+    }\n+\n+    @Benchmark\n+    public void testNestedPhi_TryCatch_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testNestedPhi_TryCatch(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testBailOut(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p2 = p1;\n+        if (cond1)\n+          p1 = new Point(x, y);\n+\n+        if (cond2)\n+          p2 = new Point(x, y);\n+\n+        try {\n+            if (cond1 && cond2)\n+                throw new Exception();\n+        } catch (Exception e) {}\n+\n+        return p2.getX();\n+    }\n+\n+    @Benchmark\n+    public void testBailOut_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testBailOut(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testNestedPhiPolymorphic(boolean cond1, boolean cond2, int x, int l) {\n+        Shape obj1 = new Square(l);\n+        if (cond1)\n+            obj1 = new Circle(l);\n+        Shape obj2 = obj1;\n+        if (cond2)\n+            obj2 = new Circle(x + l\/5);\n+        return obj2.l;\n+    }\n+\n+    @Benchmark\n+    public void testNestedPhiPolymorphic_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testNestedPhiPolymorphic(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    int testNestedPhiWithTrap(boolean cond1, boolean cond2, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        if (cond1)\n+            p1 = new Point(x, y);\n+\n+        Point p2 = p1;\n+        dummy();\n+        if (cond2)\n+            p2 = new Point(x, y);\n+\n+        return p2.x;\n+    }\n+\n+    @Benchmark\n+    public void testNestedPhiWithTrap_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testNestedPhiWithTrap(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public int testNestedPhiWithLambda(boolean cond1, boolean cond2, int x, int y) {\n+        Point1 p1 = new Point1(x, y);\n+        if (cond1)\n+            p1 = new Point1(x, y);\n+\n+        Point1 p2 = p1;\n+        PointSupplier ps = () -> (cond2? (new Point1(x, y)) : (new Point1(x+70, y+80)));\n+        if (cond2)\n+            p2 = ps.getPoint();\n+        return p2.x;\n+    }\n+\n+    @Benchmark\n+    public void testNestedPhiWithLambda_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testNestedPhiWithLambda(cond1[i], cond2[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+\n+    \/\/--------------------------------------------------------------------------------------------------------------------------------------------\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public static int testMultiParentPhi(boolean cond1, int x, int y) {\n+        Point p1 = new Point(x, y);\n+        Point p3 = new Point(x+30, y+31);\n+        if (cond1) {\n+          p1 = new Point(x+12, y+13);\n+          p3 = new Point(x+32, y+33);\n+        }\n+        Point p2 = new Point(x+20, y+21);\n+        try {\n+           Point p4 = new Point(x+40, y+41);\n+        } catch (NullPointerException ne) {\n+            p2 = p3;\n+        } catch (Exception e) {\n+            p2 = p1;\n+        }\n+        return p2.x;\n+    }\n+\n+    @Benchmark\n+    public void testMultiParentPhi_runner(Blackhole bh) {\n+        int result = 0;\n+        for (int i = 0 ; i < SIZE; i++) {\n+            result += testMultiParentPhi(cond1[i], xs[i], ys[i]);\n+        }\n+        bh.consume(result);\n+    }\n+\n+\n+   \/\/ ------------------ Utility for Testing ------------------- \/\/\n+\n+\n+    @Fork(value = 3, jvmArgsPrepend = {\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:+UseTLAB\",\n+        \"-XX:-ReduceAllocationMerges\",\n+    })\n+    public static class NopRAM extends AllocationMergesNestedPhi {\n+    }\n+\n+    @Fork(value = 3, jvmArgsPrepend = {\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:+ReduceAllocationMerges\",\n+    })\n+    public static class YesRAM extends AllocationMergesNestedPhi {\n+    }\n+\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static void dummy() {\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static int dummy(Point p) {\n+        return p.x * p.y;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static int dummy(int x) {\n+        return x;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static Point dummy(int x, int y) {\n+        return new Point(x, y);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static String dummy(String str) {\n+        return str;\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+    static ADefaults dummy_defaults() {\n+        return new ADefaults();\n+    }\n+\n+    static class Nested {\n+        int x, y;\n+        Nested other;\n+        Nested(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+            this.other = null;\n+        }\n+    }\n+\n+    static class Point {\n+        int x, y;\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (!(o instanceof Point)) return false;\n+            Point p = (Point) o;\n+            return (p.x == x) && (p.y == y);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return x + y;\n+        }\n+\n+        int getX() {\n+            return x;\n+        }\n+    }\n+\n+   class Line {\n+       Load p1, p2;\n+       Line(Load p1, Load p2) {\n+           this.p1 = p1;\n+           this.p2 = p2;\n+       }\n+    }\n+\n+    interface PointSupplier {\n+        Point1 getPoint();\n+    }\n+\n+   class Point1 implements PointSupplier {\n+       int x, y;\n+       Point1(int x, int y) {\n+           this.x = x;\n+           this.y = y;\n+       }\n+       public Point1 getPoint() {\n+           return this;\n+       }\n+    }\n+\n+    class Shape {\n+        int x, y, l;\n+        Shape(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    class Square extends Shape {\n+        Square(int l) {\n+            super(0, 0);\n+            this.l = l;\n+        }\n+    }\n+\n+    class Circle extends Shape {\n+        Circle(int l) {\n+            super(0, 0);\n+            this.l = l;\n+        }\n+    }\n+\n+    static class ADefaults {\n+        static int ble;\n+        int i;\n+        @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+        ADefaults(int i) { this.i = i; }\n+        @CompilerControl(CompilerControl.Mode.EXCLUDE)\n+        ADefaults() { }\n+    }\n+\n+     static class Load {\n+        long id;\n+        String name;\n+        Integer[] values = new Integer[10];\n+        int x, y;\n+\n+        @CompilerControl(CompilerControl.Mode.INLINE)\n+        Load(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (!(o instanceof Load)) return false;\n+            Load p = (Load) o;\n+            return (p.x == x) && (p.y == y);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return x + y;\n+        }\n+    }\n+\n+    static class Picture {\n+        public int id;\n+        public Point position;\n+\n+        public Picture(int id, int x, int y) {\n+            this.id = id;\n+            this.position = new Point(x, y);\n+        }\n+    }\n+\n+    static class PicturePositions {\n+        public int id;\n+        public Point[] positions;\n+\n+        public PicturePositions(int id, int x, int y) {\n+            this.id = id;\n+            this.positions = new Point[] { new Point(x, y), new Point(y, x) };\n+        }\n+    }\n+\n+    class Root {\n+        public int a;\n+        public int b;\n+        public int c;\n+        public int d;\n+        public int e;\n+\n+        public Root(int a, int b, int c, int d, int e) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+            this.d = d;\n+            this.e = e;\n+        }\n+    }\n+\n+    class Usr extends Root {\n+        public float flt;\n+\n+        public Usr(float a, float b, float c) {\n+            super((int)a, (int)b, (int)c, 0, 0);\n+            this.flt = a;\n+        }\n+    }\n+\n+    class Home extends Root {\n+        public double[] arr;\n+\n+        public Home(double a, double b) {\n+            super((int)a, (int)b, 0, 0, 0);\n+            this.arr = new double[] {a, b};\n+        }\n+\n+    }\n+\n+    class Tmp extends Root {\n+        public String s;\n+\n+        public Tmp(String s) {\n+            super((int)s.length(), 0, 0, 0, 0);\n+            this.s = s;\n+        }\n+    }\n+\n+    class Etc extends Root {\n+        public String a;\n+\n+        public Etc(String s) {\n+            super((int)s.length(), 0, 0, 0, 0);\n+            this.a = s;\n+        }\n+    }\n+\n+    class A { }\n+    class B { }\n+    class C { }\n+    class D { }\n+    class E { }\n+    class F { }\n+    class G { }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/AllocationMergesNestedPhi.java","additions":691,"deletions":0,"binary":false,"changes":691,"status":"added"}]}