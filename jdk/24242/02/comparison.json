{"files":[{"patch":"@@ -0,0 +1,44 @@\n+#\n+# Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include LibCommon.gmk\n+\n+################################################################################\n+\n+ifeq ($(call isTargetOs, linux macosx windows), true)\n+\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBLE, \\\n+      NAME := le, \\\n+      TOOLCHAIN := TOOLCHAIN_LINK_CXX, \\\n+      OPTIMIZATION := SIZE, \\\n+      EXTRA_HEADER_DIRS := java.base:libjava, \\\n+      LIBS_windows := user32.lib, \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBLE)\n+\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/jdk.internal.le\/Lib.gmk","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.io;\n+\n+import java.io.IOError;\n+import java.io.IOException;\n+import java.io.FileDescriptor;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.Charset;\n+import java.util.Formatter;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import sun.nio.cs.StreamDecoder;\n+import sun.nio.cs.StreamEncoder;\n+\n+\/**\n+ * Base for JDK's JdkConsole implementations.\n+ *\/\n+public abstract class BaseJdkConsoleImpl implements JdkConsole {\n+    @Override\n+    public PrintWriter writer() {\n+        return pw;\n+    }\n+\n+    @Override\n+    public Reader reader() {\n+        return reader;\n+    }\n+\n+    @Override\n+    public JdkConsole println(Object obj) {\n+        pw.println(obj);\n+        \/\/ automatic flushing covers println\n+        return this;\n+    }\n+\n+    @Override\n+    public JdkConsole print(Object obj) {\n+        pw.print(obj);\n+        pw.flush(); \/\/ automatic flushing does not cover print\n+        return this;\n+    }\n+\n+    @Override\n+    public String readln(String prompt) {\n+        String line = null;\n+        synchronized (writeLock) {\n+            synchronized(readLock) {\n+                pw.print(prompt);\n+                pw.flush(); \/\/ automatic flushing does not cover print\n+                try {\n+                    char[] ca = readline(false);\n+                    if (ca != null)\n+                        line = new String(ca);\n+                } catch (IOException x) {\n+                    throw new IOError(x);\n+                }\n+            }\n+        }\n+        return line;\n+    }\n+\n+    @Override\n+    public String readln() {\n+        String line = null;\n+        synchronized(readLock) {\n+            try {\n+                char[] ca = readline(false);\n+                if (ca != null)\n+                    line = new String(ca);\n+            } catch (IOException x) {\n+                throw new IOError(x);\n+            }\n+        }\n+        return line;\n+    }\n+\n+    @Override\n+    public JdkConsole format(Locale locale, String format, Object ... args) {\n+        formatter.format(locale, format, args).flush();\n+        return this;\n+    }\n+\n+    @Override\n+    public String readLine(Locale locale, String format, Object ... args) {\n+        String line = null;\n+        synchronized (writeLock) {\n+            synchronized(readLock) {\n+                if (!format.isEmpty())\n+                    pw.format(locale, format, args);\n+                try {\n+                    char[] ca = readline(false);\n+                    if (ca != null)\n+                        line = new String(ca);\n+                } catch (IOException x) {\n+                    throw new IOError(x);\n+                }\n+            }\n+        }\n+        return line;\n+    }\n+\n+    @Override\n+    public String readLine() {\n+        return readLine(Locale.getDefault(Locale.Category.FORMAT), \"\");\n+    }\n+\n+    @Override\n+    public char[] readPassword(Locale locale, String format, Object ... args) {\n+        char[] passwd = null;\n+        synchronized (writeLock) {\n+            synchronized(readLock) {\n+                try {\n+                    if (!format.isEmpty())\n+                        pw.format(locale, format, args);\n+                    passwd = readline(true);\n+                } catch (IOException x) {\n+                    throw new IOError(x);\n+                }\n+                pw.println();\n+            }\n+        }\n+        return passwd;\n+    }\n+\n+    @Override\n+    public char[] readPassword() {\n+        return readPassword(Locale.getDefault(Locale.Category.FORMAT), \"\");\n+    }\n+\n+    @Override\n+    public void flush() {\n+        pw.flush();\n+    }\n+\n+    @Override\n+    public Charset charset() {\n+        return charset;\n+    }\n+\n+    protected Reader wrapReader(Reader baseReader) {\n+        return baseReader;\n+    }\n+\n+    protected final Charset charset;\n+    protected final Object readLock;\n+    protected final Object writeLock;\n+    protected final Reader reader;\n+    protected final Writer out;\n+    protected final PrintWriter pw;\n+    protected final Formatter formatter;\n+\n+    protected abstract char[] readline(boolean password) throws IOException;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    public BaseJdkConsoleImpl(Charset charset) {\n+        Objects.requireNonNull(charset);\n+        this.charset = charset;\n+        readLock = new Object();\n+        writeLock = new Object();\n+        out = StreamEncoder.forOutputStreamWriter(\n+                new FileOutputStream(FileDescriptor.out),\n+                writeLock,\n+                charset);\n+        pw = new PrintWriter(out, true) {\n+            public void close() {\n+            }\n+        };\n+        formatter = new Formatter(out);\n+        StreamDecoder plainReader = StreamDecoder.forInputStreamReader(\n+                new FileInputStream(FileDescriptor.in),\n+                readLock,\n+                charset);\n+        reader = wrapReader(plainReader);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/BaseJdkConsoleImpl.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -30,4 +30,0 @@\n-import java.io.FileDescriptor;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.PrintWriter;\n@@ -35,1 +31,0 @@\n-import java.io.Writer;\n@@ -38,3 +33,0 @@\n-import java.util.Formatter;\n-import java.util.Locale;\n-import java.util.Objects;\n@@ -44,1 +36,0 @@\n-import sun.nio.cs.StreamEncoder;\n@@ -49,139 +40,1 @@\n-public final class JdkConsoleImpl implements JdkConsole {\n-    @Override\n-    public PrintWriter writer() {\n-        return pw;\n-    }\n-\n-    @Override\n-    public Reader reader() {\n-        return reader;\n-    }\n-\n-    @Override\n-    public JdkConsole println(Object obj) {\n-        pw.println(obj);\n-        \/\/ automatic flushing covers println\n-        return this;\n-    }\n-\n-    @Override\n-    public JdkConsole print(Object obj) {\n-        pw.print(obj);\n-        pw.flush(); \/\/ automatic flushing does not cover print\n-        return this;\n-    }\n-\n-    @Override\n-    public String readln(String prompt) {\n-        String line = null;\n-        synchronized (writeLock) {\n-            synchronized(readLock) {\n-                pw.print(prompt);\n-                pw.flush(); \/\/ automatic flushing does not cover print\n-                try {\n-                    char[] ca = readline(false);\n-                    if (ca != null)\n-                        line = new String(ca);\n-                } catch (IOException x) {\n-                    throw new IOError(x);\n-                }\n-            }\n-        }\n-        return line;\n-    }\n-\n-    @Override\n-    public String readln() {\n-        String line = null;\n-        synchronized(readLock) {\n-            try {\n-                char[] ca = readline(false);\n-                if (ca != null)\n-                    line = new String(ca);\n-            } catch (IOException x) {\n-                throw new IOError(x);\n-            }\n-        }\n-        return line;\n-    }\n-\n-    @Override\n-    public JdkConsole format(Locale locale, String format, Object ... args) {\n-        formatter.format(locale, format, args).flush();\n-        return this;\n-    }\n-\n-    @Override\n-    public String readLine(Locale locale, String format, Object ... args) {\n-        String line = null;\n-        synchronized (writeLock) {\n-            synchronized(readLock) {\n-                if (!format.isEmpty())\n-                    pw.format(locale, format, args);\n-                try {\n-                    char[] ca = readline(false);\n-                    if (ca != null)\n-                        line = new String(ca);\n-                } catch (IOException x) {\n-                    throw new IOError(x);\n-                }\n-            }\n-        }\n-        return line;\n-    }\n-\n-    @Override\n-    public String readLine() {\n-        return readLine(Locale.getDefault(Locale.Category.FORMAT), \"\");\n-    }\n-\n-    @Override\n-    public char[] readPassword(Locale locale, String format, Object ... args) {\n-        char[] passwd = null;\n-        synchronized (writeLock) {\n-            synchronized(readLock) {\n-                installShutdownHook();\n-                try {\n-                    synchronized(restoreEchoLock) {\n-                        restoreEcho = echo(false);\n-                    }\n-                } catch (IOException x) {\n-                    throw new IOError(x);\n-                }\n-                IOError ioe = null;\n-                try {\n-                    if (!format.isEmpty())\n-                        pw.format(locale, format, args);\n-                    passwd = readline(true);\n-                } catch (IOException x) {\n-                    ioe = new IOError(x);\n-                } finally {\n-                    try {\n-                        synchronized(restoreEchoLock) {\n-                            if (restoreEcho) {\n-                                restoreEcho = echo(true);\n-                            }\n-                        }\n-                    } catch (IOException x) {\n-                        if (ioe == null)\n-                            ioe = new IOError(x);\n-                        else\n-                            ioe.addSuppressed(x);\n-                    }\n-                    if (ioe != null) {\n-                        Arrays.fill(passwd, ' ');\n-                        try {\n-                            if (reader instanceof LineReader lr) {\n-                                lr.zeroOut();\n-                            }\n-                        } catch (IOException _) {\n-                            \/\/ ignore\n-                        }\n-                        throw ioe;\n-                    }\n-                }\n-                pw.println();\n-            }\n-        }\n-        return passwd;\n-    }\n+public final class JdkConsoleImpl extends BaseJdkConsoleImpl {\n@@ -216,18 +69,0 @@\n-    @Override\n-    public char[] readPassword() {\n-        return readPassword(Locale.getDefault(Locale.Category.FORMAT), \"\");\n-    }\n-\n-    @Override\n-    public void flush() {\n-        pw.flush();\n-    }\n-\n-    @Override\n-    public Charset charset() {\n-        return charset;\n-    }\n-\n-    private final Charset charset;\n-    private final Object readLock;\n-    private final Object writeLock;\n@@ -236,4 +71,0 @@\n-    private final Reader reader;\n-    private final Writer out;\n-    private final PrintWriter pw;\n-    private final Formatter formatter;\n@@ -244,1 +75,50 @@\n-    private char[] readline(boolean zeroOut) throws IOException {\n+    protected char[] readline(boolean password) throws IOException {\n+        if (!password) {\n+            return doReadline(password);\n+        }\n+\n+        \/\/reading password, disable echo, and ensure it is re-enabled:\n+        installShutdownHook();\n+        try {\n+            synchronized(restoreEchoLock) {\n+                restoreEcho = echo(false);\n+            }\n+        } catch (IOException x) {\n+            throw new IOError(x);\n+        }\n+        IOError ioe = null;\n+        char[] passwd = null;\n+        try {\n+            passwd = doReadline(true);\n+        } catch (IOException x) {\n+            ioe = new IOError(x);\n+        } finally {\n+            try {\n+                synchronized(restoreEchoLock) {\n+                    if (restoreEcho) {\n+                        restoreEcho = echo(true);\n+                    }\n+                }\n+            } catch (IOException x) {\n+                if (ioe == null)\n+                    ioe = new IOError(x);\n+                else\n+                    ioe.addSuppressed(x);\n+            }\n+            if (ioe != null) {\n+                Arrays.fill(passwd, ' ');\n+                try {\n+                    if (reader instanceof LineReader lr) {\n+                        lr.zeroOut();\n+                    }\n+                } catch (IOException _) {\n+                    \/\/ ignore\n+                }\n+                throw ioe;\n+            }\n+        }\n+\n+        return passwd;\n+    }\n+\n+    private char[] doReadline(boolean password) throws IOException {\n@@ -258,1 +138,1 @@\n-            if (zeroOut) {\n+            if (password) {\n@@ -401,0 +281,5 @@\n+    @Override\n+    protected Reader wrapReader(Reader baseReader) {\n+        return new LineReader(baseReader);\n+    }\n+\n@@ -402,4 +287,1 @@\n-        Objects.requireNonNull(charset);\n-        this.charset = charset;\n-        readLock = new Object();\n-        writeLock = new Object();\n+        super(charset);\n@@ -407,13 +289,0 @@\n-        out = StreamEncoder.forOutputStreamWriter(\n-                new FileOutputStream(FileDescriptor.out),\n-                writeLock,\n-                charset);\n-        pw = new PrintWriter(out, true) {\n-            public void close() {\n-            }\n-        };\n-        formatter = new Formatter(out);\n-        reader = new LineReader(StreamDecoder.forInputStreamReader(\n-                new FileInputStream(FileDescriptor.in),\n-                readLock,\n-                charset));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/io\/JdkConsoleImpl.java","additions":58,"deletions":189,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.console;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.util.Locale;\n+import jdk.internal.console.SimpleConsoleReader.CleanableBuffer;\n+\n+import jdk.internal.io.BaseJdkConsoleImpl;\n+\n+\/**\n+ * JdkConsole implementation based on the platform's TTY, with basic keyboard navigation.\n+ *\/\n+public final class JdkConsoleImpl extends BaseJdkConsoleImpl {\n+\n+    private final boolean isTTY;\n+\n+    @Override\n+    public char[] readPassword() {\n+        return readPassword(Locale.getDefault(Locale.Category.FORMAT), \"\");\n+    }\n+\n+    @Override\n+    public void flush() {\n+        pw.flush();\n+    }\n+\n+    @Override\n+    public Charset charset() {\n+        return charset;\n+    }\n+\n+    protected char[] readline(boolean password) throws IOException {\n+        if (isTTY) {\n+            return NativeConsoleReader.readline(reader, out, password);\n+        } else {\n+            \/\/dumb input:\n+            CleanableBuffer buffer = new CleanableBuffer();\n+\n+            try {\n+                int r;\n+\n+                OUTER: while ((r = reader.read()) != (-1)) {\n+                    switch (r) {\n+                        case '\\r', '\\n' -> { break OUTER; }\n+                        default -> buffer.insert(buffer.length(), (char) r);\n+                    }\n+                }\n+\n+                return buffer.getData();\n+            } finally {\n+                buffer.zeroOut();\n+            }\n+        }\n+    }\n+\n+    public JdkConsoleImpl(boolean isTTY, Charset charset) {\n+        super(charset);\n+        this.isTTY = isTTY;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/console\/JdkConsoleImpl.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.console;\n+\n+import java.nio.charset.Charset;\n+import jdk.internal.io.JdkConsole;\n+import jdk.internal.io.JdkConsoleProvider;\n+\n+public class JdkConsoleProviderImpl implements JdkConsoleProvider {\n+\n+    @Override\n+    public JdkConsole console(boolean isTTY, Charset charset) {\n+        if (!NativeConsoleReader.isSupported()) {\n+            return null;\n+        }\n+\n+        \/\/only supported on Linux, Mac OS\/X and Windows:\n+        return new JdkConsoleImpl(isTTY, charset);\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/console\/JdkConsoleProviderImpl.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.console;\n+\n+@SuppressWarnings(\"serial\")\n+public class LastErrorException extends RuntimeException{\n+\n+    public final long lastError;\n+\n+    public LastErrorException(long lastError) {\n+        this.lastError = lastError;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/console\/LastErrorException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.console;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.IntSupplier;\n+import jdk.internal.org.jline.utils.WCWidth;\n+\n+public class SimpleConsoleReader {\n+\n+    \/\/public, to simplify access from tests:\n+    public static char[] doRead(Reader reader,\n+                                Writer out,\n+                                boolean password,\n+                                TerminalConfiguration terminalConfig) throws IOException {\n+        CleanableBuffer result = new CleanableBuffer();\n+        try {\n+            doReadImpl(reader, out, password, terminalConfig, result);\n+            return result.getData();\n+        } finally {\n+            result.zeroOut();\n+        }\n+    }\n+\n+    private static void doReadImpl(Reader reader,\n+                                   Writer out,\n+                                   boolean password,\n+                                   TerminalConfiguration terminalConfiguration,\n+                                   CleanableBuffer result) throws IOException {\n+        int caret = 0;\n+        int r;\n+        PaintState prevState = new PaintState();\n+        int firstLineOffset = terminalConfiguration.firstLineOffset();\n+\n+        READ: while (true) {\n+            \/\/paint:\n+            if (firstLineOffset != (-1) && !password) {\n+                prevState = repaint(out, firstLineOffset,\n+                                    terminalConfiguration.terminalWidthSupplier(),\n+                                    result.data, result.length, caret, prevState);\n+            }\n+\n+            \/\/read\n+            r = reader.read();\n+\n+            if (r == terminalConfiguration.eraseControlCharacter()) {\n+                \/\/backspace:\n+                if (caret > 0) {\n+                    result.delete(caret - 1, caret);\n+                    caret--;\n+                }\n+                continue READ;\n+            } else if (r == terminalConfiguration.eofControlCharacter()) {\n+                break READ;\n+            }\n+\n+            switch (r) {\n+                case -1: continue READ;\n+                case '\\n', '\\r': break READ;\n+                case '\\033':\n+                    r = reader.read();\n+                    switch (r) {\n+                        case '[':\n+                            r = reader.read();\n+\n+                            StringBuilder firstNumber = new StringBuilder();\n+\n+                            r = readNumber(reader, r, firstNumber);\n+\n+                            String modifier;\n+                            String key;\n+\n+                            switch (r) {\n+                                case '~' -> {\n+                                    key = firstNumber.toString();\n+                                    modifier = \"1\";\n+                                }\n+                                case ';' -> {\n+                                    key = firstNumber.toString();\n+\n+                                    StringBuilder modifierBuilder = new StringBuilder();\n+\n+                                    r = readNumber(reader, reader.read(), modifierBuilder);\n+                                    modifier = modifierBuilder.toString();\n+\n+                                    if (r == 'R') {\n+                                        firstLineOffset = Integer.parseInt(modifier) - 1;\n+                                        continue READ;\n+                                    }\n+\n+                                    if (r != '~') {\n+                                        \/\/TODO: unexpected, anything that can be done?\n+                                    }\n+                                }\n+                                default -> {\n+                                    key = Character.toString(r);\n+                                    modifier = firstNumber.isEmpty() ? \"1\"\n+                                                                     : firstNumber.toString();\n+                                }\n+                            }\n+\n+                            if (\"1\".equals(modifier)) {\n+                                switch (key) {\n+                                    case \"C\": if (caret < result.length()) caret++; break;\n+                                    case \"D\": if (caret > 0) caret--; break;\n+                                    case \"1\", \"H\": caret = 0; break;\n+                                    case \"4\", \"F\": caret = result.length(); break;\n+                                    case \"3\":\n+                                        \/\/delete\n+                                        result.delete(caret, caret + 1);\n+                                        continue READ;\n+                                }\n+                            }\n+                    }\n+                    continue READ;\n+            }\n+\n+            caret += result.insert(caret, (char) r);\n+        }\n+\n+        if (!password) {\n+            \/\/show the final state:\n+            repaint(out, firstLineOffset,\n+                    terminalConfiguration.terminalWidthSupplier(),\n+                    result.data, result.length, caret, prevState);\n+        }\n+\n+        out.append(\"\\n\\r\").flush();\n+    }\n+\n+    private static PaintState repaint(Writer out,\n+                                      int firstLineOffset,\n+                                      IntSupplier terminalWidthSupplier,\n+                                      int[] toDisplay,\n+                                      int toDisplayLength,\n+                                      int caret,\n+                                      PaintState prevPaintState) throws IOException {\n+        \/\/for simplicity, repaint the whole input buffer\n+        \/\/for more efficiency, could compute smaller (ideally minimal) changes,\n+        \/\/and apply them instead of repainting everything:\n+        record DisplayLine(int lineStartIndex, int lineLength) {}\n+        int terminalWidth = terminalWidthSupplier.getAsInt();\n+        List<DisplayLine> toDisplayLines = new ArrayList<>();\n+        int lineOffset = firstLineOffset;\n+        int lineStartIndex = 0;\n+\n+        while (lineStartIndex < toDisplayLength) {\n+            int currentLineColumns = terminalWidth - lineOffset;\n+            int currentLineEnd = lineStartIndex;\n+\n+            while (currentLineEnd < toDisplayLength) {\n+                currentLineColumns -= WCWidth.wcwidth(toDisplay[currentLineEnd]);\n+\n+                if (currentLineColumns < 0) {\n+                    break;\n+                }\n+\n+                currentLineEnd++;\n+            }\n+\n+            toDisplayLines.add(new DisplayLine(lineStartIndex, currentLineEnd - lineStartIndex));\n+            lineStartIndex = currentLineEnd;\n+            lineOffset = 0;\n+        }\n+\n+        for (int i = prevPaintState.caretLine() + 1; i < prevPaintState.lines(); i++) {\n+            out.append(\"\\033[B\");\n+        }\n+        for (int i = prevPaintState.lines() - 1; i >= 0; i--) {\n+            if (i == 0) {\n+                out.append(\"\\033[\" + (firstLineOffset + 1) + \"G\");\n+                out.append(\"\\033[K\");\n+            } else {\n+                out.append(\"\\r\");\n+                out.append(\"\\033[K\");\n+                out.append(\"\\033[A\");\n+            }\n+        }\n+\n+        char[] toPrint = new char[2];\n+\n+        for (Iterator<DisplayLine> it = toDisplayLines.iterator(); it.hasNext();) {\n+            DisplayLine line = it.next();\n+            for (int o = 0; o < line.lineLength(); o++) {\n+                int printLength = Character.toChars(toDisplay[line.lineStartIndex() + o], toPrint, 0);\n+\n+                out.write(toPrint, 0, printLength);\n+            }\n+\n+            if (it.hasNext()) {\n+                out.append(\"\\n\\r\");\n+            }\n+        }\n+\n+        Arrays.fill(toPrint, '\\0');\n+\n+        int prevCaretLine = prevPaintState.lines();\n+\n+        if (caret < toDisplayLength) {\n+            int currentPos = toDisplayLength;\n+\n+            prevCaretLine = prevPaintState.lines() - 1;\n+\n+            while (caret < currentPos - toDisplayLines.get(prevCaretLine).lineLength()) {\n+                out.append(\"\\033[A\");\n+                currentPos -= toDisplayLines.get(prevCaretLine).lineLength();\n+                prevCaretLine--;\n+            }\n+\n+            int currentLineStart = currentPos - toDisplayLines.get(prevCaretLine).lineLength();\n+            int linePosition = caret - currentLineStart;\n+\n+            if (prevCaretLine == 0) {\n+                linePosition += firstLineOffset;\n+            }\n+\n+            out.append(\"\\033[\" + (linePosition + 1) + \"G\");\n+        }\n+        out.flush();\n+        return new PaintState(toDisplayLines.size(), prevCaretLine);\n+    }\n+\n+    private static int readNumber(Reader reader, int r, StringBuilder number) throws IOException {\n+        while (Character.isDigit(r)) {\n+            number.append((char) r);\n+            r = reader.read();\n+        }\n+        return r;\n+    }\n+\n+    public record Size(int width, int height) {}\n+    public record TerminalConfiguration(int firstLineOffset,\n+                                        int eofControlCharacter,\n+                                        int eraseControlCharacter,\n+                                        IntSupplier terminalWidthSupplier) {}\n+    record PaintState(int lines, int caretLine) {\n+\n+        public PaintState() {\n+            this(1, 0);\n+        }\n+\n+    }\n+\n+    static final class CleanableBuffer {\n+        private char pendingHighSurrogate;\n+        private int pendingSurrogateCaret = -1;\n+        private int[] data = new int[16];\n+        private int length;\n+\n+        public void delete(int from, int to) {\n+            System.arraycopy(data, to, data, from, length - to);\n+            length--;\n+        }\n+\n+        public int length() {\n+            return length;\n+        }\n+\n+        public int insert(int caret, char c) {\n+            if (Character.isHighSurrogate(c)) {\n+                if (pendingSurrogateCaret != (-1)) {\n+                    doInsert(pendingSurrogateCaret, (int) c);\n+                }\n+                pendingHighSurrogate = c;\n+                pendingSurrogateCaret = caret;\n+                return 0;\n+            } else if (Character.isLowSurrogate(c)) {\n+                if (pendingSurrogateCaret == (-1)) {\n+                    doInsert(caret, (int) c);\n+                } else if (pendingSurrogateCaret != caret) {\n+                    doInsert(pendingSurrogateCaret, (int) pendingHighSurrogate);\n+                    doInsert(caret, (int) c);\n+                } else {\n+                    doInsert(caret, Character.toCodePoint(pendingHighSurrogate, c));\n+                }\n+                pendingHighSurrogate = '\\0';\n+                pendingSurrogateCaret = -1;\n+                return 1;\n+            } else {\n+                doInsert(caret, (int) c);\n+                return 1;\n+            }\n+        }\n+\n+        private void doInsert(int caret, int codePoint) {\n+            while (length + 1 >= data.length) {\n+                int[] newData = Arrays.copyOf(data, data.length * 2);\n+\n+                zeroOut();\n+                data = newData;\n+            }\n+\n+            System.arraycopy(data, caret, data, caret + 1, length - caret);\n+            data[caret] = codePoint;\n+            length++;\n+        }\n+\n+\n+        public char[] getData() {\n+            if (length == 0) {\n+                return null;\n+            }\n+\n+            char[] tempResult = new char[2 * length];\n+            int target = 0;\n+\n+            for (int source = 0; source < length; source++) {\n+                target += Character.toChars(data[source], tempResult, target);\n+            }\n+\n+            char[] result = Arrays.copyOf(tempResult, target);\n+            Arrays.fill(tempResult, '\\0');\n+\n+            return result;\n+        }\n+\n+        public void zeroOut() {\n+            Arrays.fill(data, 0);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/console\/SimpleConsoleReader.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -1,308 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.org.jline;\n-\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.Reader;\n-import java.nio.charset.Charset;\n-import java.util.Locale;\n-\n-import jdk.internal.io.JdkConsole;\n-import jdk.internal.io.JdkConsoleProvider;\n-import jdk.internal.org.jline.reader.EndOfFileException;\n-import jdk.internal.org.jline.reader.LineReader;\n-import jdk.internal.org.jline.reader.LineReaderBuilder;\n-import jdk.internal.org.jline.terminal.Terminal;\n-import jdk.internal.org.jline.terminal.TerminalBuilder;\n-import jdk.internal.org.jline.terminal.TerminalBuilder.SystemOutput;\n-\n-\/**\n- * JdkConsole\/Provider implementations for jline\n- *\/\n-public class JdkConsoleProviderImpl implements JdkConsoleProvider {\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public JdkConsole console(boolean isTTY, Charset charset) {\n-        return new LazyDelegatingJdkConsoleImpl(charset);\n-    }\n-\n-    private static class LazyDelegatingJdkConsoleImpl implements JdkConsole {\n-        private final Charset charset;\n-        private volatile boolean jlineInitialized;\n-        private volatile JdkConsole delegate;\n-\n-        public LazyDelegatingJdkConsoleImpl(Charset charset) {\n-            this.charset = charset;\n-            this.delegate = new jdk.internal.io.JdkConsoleImpl(charset);\n-        }\n-\n-        @Override\n-        public PrintWriter writer() {\n-            return getDelegate(true).writer();\n-        }\n-\n-        @Override\n-        public Reader reader() {\n-            return getDelegate(true).reader();\n-        }\n-\n-        @Override\n-        public JdkConsole println(Object obj) {\n-            JdkConsole delegate = getDelegate(false);\n-\n-            delegate.println(obj);\n-            flushOldDelegateIfNeeded(delegate);\n-\n-            return this;\n-        }\n-\n-        @Override\n-        public JdkConsole print(Object obj) {\n-            JdkConsole delegate = getDelegate(false);\n-\n-            delegate.print(obj);\n-            flushOldDelegateIfNeeded(delegate);\n-\n-            return this;\n-        }\n-\n-        @Override\n-        public String readln(String prompt) {\n-            return getDelegate(true).readln(prompt);\n-        }\n-\n-        @Override\n-        public String readln() {\n-            return getDelegate(true).readln();\n-        }\n-\n-        @Override\n-        public JdkConsole format(Locale locale, String format, Object... args) {\n-            JdkConsole delegate = getDelegate(false);\n-\n-            delegate.format(locale, format, args);\n-            flushOldDelegateIfNeeded(delegate);\n-\n-            return this;\n-        }\n-\n-        @Override\n-        public String readLine(Locale locale, String format, Object... args) {\n-            return getDelegate(true).readLine(locale, format, args);\n-        }\n-\n-        @Override\n-        public String readLine() {\n-            return getDelegate(true).readLine();\n-        }\n-\n-        @Override\n-        public char[] readPassword(Locale locale, String format, Object... args) {\n-            return getDelegate(true).readPassword(locale, format, args);\n-        }\n-\n-        @Override\n-        public char[] readPassword() {\n-            return getDelegate(true).readPassword();\n-        }\n-\n-        @Override\n-        public void flush() {\n-            getDelegate(false).flush();\n-        }\n-\n-        @Override\n-        public Charset charset() {\n-            return charset;\n-        }\n-\n-        private void flushOldDelegateIfNeeded(JdkConsole oldDelegate) {\n-            if (oldDelegate != getDelegate(false)) {\n-                \/\/if the delegate changed in the mean time, make sure the original\n-                \/\/delegate is flushed:\n-                oldDelegate.flush();\n-            }\n-        }\n-\n-        private JdkConsole getDelegate(boolean needsJLine) {\n-            if (!needsJLine || jlineInitialized) {\n-                return delegate;\n-            }\n-\n-            return initializeJLineDelegate();\n-        }\n-\n-        private synchronized JdkConsole initializeJLineDelegate() {\n-            JdkConsole newDelegate = delegate;\n-\n-            if (jlineInitialized) {\n-                return newDelegate;\n-            }\n-\n-            try {\n-                Terminal terminal = TerminalBuilder.builder().encoding(charset)\n-                                                   .exec(false)\n-                                                   .nativeSignals(false)\n-                                                   .systemOutput(SystemOutput.SysOut)\n-                                                   .build();\n-                newDelegate = new JdkConsoleImpl(terminal);\n-            } catch (IllegalStateException ise) {\n-                \/\/cannot create a non-dumb, non-exec terminal,\n-                \/\/use the standard Console:\n-            } catch (IOException ioe) {\n-                \/\/something went wrong, keep the existing delegate\n-            }\n-\n-            delegate = newDelegate;\n-            jlineInitialized = true;\n-\n-            return newDelegate;\n-        }\n-    }\n-\n-    \/**\n-     * An implementation of JdkConsole, which act as a delegate for the\n-     * public Console class.\n-     *\/\n-    private static class JdkConsoleImpl implements JdkConsole {\n-        private final Terminal terminal;\n-        private volatile LineReader jline;\n-\n-        @Override\n-        public PrintWriter writer() {\n-            return terminal.writer();\n-        }\n-\n-        @Override\n-        public Reader reader() {\n-            return terminal.reader();\n-        }\n-\n-        @Override\n-        public JdkConsole println(Object obj) {\n-            writer().println(obj);\n-            writer().flush();\n-            return this;\n-        }\n-\n-        @Override\n-        public JdkConsole print(Object obj) {\n-            writer().print(obj);\n-            writer().flush();\n-            return this;\n-        }\n-\n-        @Override\n-        public String readln(String prompt) {\n-            try {\n-                initJLineIfNeeded();\n-                return jline.readLine(prompt == null ? \"null\" : prompt.replace(\"%\", \"%%\"));\n-            } catch (EndOfFileException eofe) {\n-                return null;\n-            }\n-        }\n-\n-        @Override\n-        public String readln() {\n-            return readLine();\n-        }\n-\n-        @Override\n-        public JdkConsole format(Locale locale, String format, Object ... args) {\n-            writer().format(locale, format, args).flush();\n-            return this;\n-        }\n-\n-        @Override\n-        public String readLine(Locale locale, String format, Object ... args) {\n-            try {\n-                initJLineIfNeeded();\n-                return jline.readLine(String.format(locale, format, args).replace(\"%\", \"%%\"));\n-            } catch (EndOfFileException eofe) {\n-                return null;\n-            }\n-        }\n-\n-        @Override\n-        public String readLine() {\n-            try {\n-                initJLineIfNeeded();\n-                return jline.readLine();\n-            } catch (EndOfFileException eofe) {\n-                return null;\n-            }\n-        }\n-\n-        @Override\n-        public char[] readPassword(Locale locale, String format, Object ... args) {\n-            try {\n-                initJLineIfNeeded();\n-                return jline.readLine(String.format(locale, format, args).replace(\"%\", \"%%\"), '\\0')\n-                            .toCharArray();\n-            } catch (EndOfFileException eofe) {\n-                return null;\n-            } finally {\n-                jline.zeroOut();\n-            }\n-        }\n-\n-        @Override\n-        public char[] readPassword() {\n-            return readPassword(Locale.getDefault(Locale.Category.FORMAT), \"\");\n-        }\n-\n-        @Override\n-        public void flush() {\n-            terminal.flush();\n-        }\n-\n-        @Override\n-        public Charset charset() {\n-            return terminal.encoding();\n-        }\n-\n-        public JdkConsoleImpl(Terminal terminal) {\n-            this.terminal = terminal;\n-        }\n-\n-        private void initJLineIfNeeded() {\n-            LineReader jline = this.jline;\n-            if (jline == null) {\n-                synchronized (this) {\n-                    jline = this.jline;\n-                    if (jline == null) {\n-                        jline = LineReaderBuilder.builder().terminal(terminal).build();\n-                        this.jline = jline;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/JdkConsoleProviderImpl.java","additions":0,"deletions":308,"binary":false,"changes":308,"status":"deleted"},{"patch":"@@ -53,1 +53,1 @@\n-            jdk.internal.org.jline.JdkConsoleProviderImpl;\n+            jdk.internal.console.JdkConsoleProviderImpl;\n","filename":"src\/jdk.internal.le\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.console;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.Writer;\n+import jdk.internal.console.SimpleConsoleReader.TerminalConfiguration;\n+\n+public class NativeConsoleReader {\n+\n+    private static final int CONTROL_EOF_OFFSET = 0;\n+    private static final int CONTROL_ERASE_OFFSET = 1;\n+    private static final int CONTROL_CHARS_LEN = 2;\n+\n+    private static final boolean supported;\n+\n+    public static boolean isSupported() {\n+        return supported;\n+    }\n+\n+    public static char[] readline(Reader reader, Writer out, boolean password) throws IOException {\n+        int[] controlCharacters = new int[CONTROL_CHARS_LEN];\n+        byte[] originalTermios = switchToRaw(controlCharacters);\n+        Thread restoreConsole = new Thread(() -> {\n+            restore(originalTermios);\n+        });\n+        try {\n+            Runtime.getRuntime().addShutdownHook(restoreConsole);\n+            int width = terminalWidth();\n+            out.append(\"\\033[6n\").flush(); \/\/ask the terminal to provide cursor location\n+            TerminalConfiguration terminalConfig = new TerminalConfiguration(\n+                    -1,\n+                    controlCharacters[CONTROL_EOF_OFFSET],\n+                    controlCharacters[CONTROL_ERASE_OFFSET],\n+                    () -> width);\n+            return SimpleConsoleReader.doRead(reader, out, password, terminalConfig);\n+        } finally {\n+            restoreConsole.run();\n+            Runtime.getRuntime().removeShutdownHook(restoreConsole);\n+        }\n+    }\n+\n+    static {\n+        boolean initialized;\n+\n+        try {\n+            loadNativeLibrary();\n+            initialized = true;\n+        } catch (UnsatisfiedLinkError err) {\n+            initialized = false;\n+        }\n+\n+        supported = initialized;\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    private static void loadNativeLibrary() {\n+        System.loadLibrary(\"le\");\n+        initIDs();\n+    }\n+\n+    private static native void initIDs();\n+    private static native byte[] switchToRaw(int[] controlCharacters);\n+    private static native void restore(byte[] termios);\n+    private static native int terminalWidth();\n+}\n","filename":"src\/jdk.internal.le\/unix\/classes\/jdk\/internal\/console\/NativeConsoleReader.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jdk_internal_console_NativeConsoleReader.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <termios.h>\n+#include <unistd.h>\n+#include <sys\/ioctl.h>\n+\n+#define CONTROL_EOF_OFFSET 0\n+#define CONTROL_ERASE_OFFSET 1\n+\n+static jclass lastErrorExceptionClass;\n+static jmethodID lastErrorExceptionConstructor;\n+\n+static void throw_errno(JNIEnv *env);\n+\n+JNIEXPORT void JNICALL Java_jdk_internal_console_NativeConsoleReader_initIDs\n+  (JNIEnv *env, jclass) {\n+    jclass cls;\n+    cls = env->FindClass(\"jdk\/internal\/console\/LastErrorException\");\n+    CHECK_NULL(cls);\n+    lastErrorExceptionClass = (jclass) env->NewGlobalRef(cls);\n+    lastErrorExceptionConstructor = env->GetMethodID(lastErrorExceptionClass, \"<init>\", \"(J)V\");\n+    CHECK_NULL(lastErrorExceptionConstructor);\n+}\n+\n+JNIEXPORT jbyteArray JNICALL Java_jdk_internal_console_NativeConsoleReader_switchToRaw\n+  (JNIEnv *env, jclass, jintArray controlCharacters) {\n+    int fd = 0;\n+    termios data;\n+\n+    if (tcgetattr(fd, &data) != 0) {\n+        throw_errno(env);\n+        return NULL;\n+    }\n+\n+    size_t termios_size = sizeof(termios);\n+    jbyteArray result = env->NewByteArray(termios_size);\n+    env->SetByteArrayRegion(result, 0, termios_size, (jbyte *) &data);\n+\n+    data.c_iflag &= ~(BRKINT | IGNPAR | ICRNL | IXON | IMAXBEL) | IXOFF;\n+    data.c_lflag &= ~(ICANON | ECHO);\n+\n+    if (tcsetattr(fd, TCSADRAIN, &data) != 0) {\n+        throw_errno(env);\n+        return NULL;\n+    }\n+\n+    jint controlChars[2] = {\n+        data.c_cc[VEOF],\n+        data.c_cc[VERASE],\n+    };\n+\n+    env->SetIntArrayRegion(controlCharacters, 0, 2, controlChars);\n+\n+    return result;\n+}\n+\n+JNIEXPORT void JNICALL Java_jdk_internal_console_NativeConsoleReader_restore\n+  (JNIEnv *env, jclass, jbyteArray storedData) {\n+    int fd = 0;\n+    termios data;\n+\n+    size_t termios_size = sizeof(termios);\n+    env->GetByteArrayRegion(storedData, 0, termios_size, (jbyte*) &data);\n+\n+    if (tcsetattr(fd, TCSADRAIN, &data) != 0) {\n+        throw_errno(env);\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Java_jdk_internal_console_NativeConsoleReader_terminalWidth\n+  (JNIEnv *env, jclass) {\n+    int fd = 0;\n+    winsize ws;\n+\n+    if (ioctl(fd, TIOCGWINSZ, &ws) != 0) {\n+        throw_errno(env);\n+        return -1;\n+    }\n+\n+    return ws.ws_col;\n+}\n+\n+\/*\n+ * Throws LastErrorException based on the errno:\n+ *\/\n+static void throw_errno(JNIEnv *env) {\n+    jobject exc = env->NewObject(lastErrorExceptionClass,\n+                                 lastErrorExceptionConstructor,\n+                                 errno);\n+    env->Throw((jthrowable) exc);\n+}\n","filename":"src\/jdk.internal.le\/unix\/native\/lible\/NativeConsoleReader.cpp","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.console;\n+\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import jdk.internal.console.SimpleConsoleReader.TerminalConfiguration;\n+import static jdk.internal.console.WindowsTerminal.*;\n+\n+public class NativeConsoleReader {\n+\n+    public static boolean isSupported() {\n+        return supported;\n+    }\n+\n+    public static char[] readline(Reader reader, Writer out, boolean password) throws IOException {\n+        byte[] originalModes = switchToRaw();\n+        try {\n+            AtomicInteger width = new AtomicInteger(terminalWidth());\n+            int firstLineOffset = cursorX();\n+            Reader in = new ConsoleInputStream(() -> {\n+                width.set(terminalWidth());\n+            });\n+            TerminalConfiguration terminalConfig = new TerminalConfiguration(\n+                    firstLineOffset,\n+                    VEOF,\n+                    VERASE,\n+                    () -> width.get());\n+            return SimpleConsoleReader.doRead(in, out, password, terminalConfig);\n+        } finally {\n+            restore(originalModes);\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/console\/NativeConsoleReader.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2002-2023, the original author(s).\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.console;\n+\n+import java.io.Reader;\n+import java.io.IOException;\n+\n+\/\/partly based on AbstractWindowsTerminal from JLine:\n+public class WindowsTerminal {\n+\n+    public static final int SHIFT_FLAG = 0x01;\n+    public static final int ALT_FLAG = 0x02;\n+    public static final int CTRL_FLAG = 0x04;\n+\n+    public static final int RIGHT_ALT_PRESSED = 0x0001;\n+    public static final int LEFT_ALT_PRESSED = 0x0002;\n+    public static final int RIGHT_CTRL_PRESSED = 0x0004;\n+    public static final int LEFT_CTRL_PRESSED = 0x0008;\n+    public static final int SHIFT_PRESSED = 0x0010;\n+\n+    public static final int VEOF = 4;\n+    public static final int VERASE = 127;\n+\n+    static {\n+        loadNativeLibrary();\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    private static void loadNativeLibrary() {\n+        System.loadLibrary(\"le\");\n+        initIDs();\n+    }\n+\n+    private static native void initIDs();\n+            static native byte[] switchToRaw();\n+            static native void restore(byte[] originalModes);\n+            static native int terminalWidth();\n+            static native int cursorX();\n+    private static native Object readEvent();\n+\n+    public record KeyEvent(boolean keyDown, short keyCode, char uchar, int controlKeyState) {}\n+    public record WindowSizeEvent() {}\n+\n+           static final class ConsoleInputStream extends Reader {\n+\n+        private final Runnable refreshWidth;\n+        private char[] backlog;\n+        private int backlogIndex;\n+\n+        public ConsoleInputStream(Runnable refreshWidth) {\n+            this.refreshWidth = refreshWidth;\n+        }\n+\n+        @Override\n+        public int read(char[] cbuf, int off, int len) throws IOException {\n+            if (len == 0) {\n+                return 0;\n+            }\n+\n+            while (backlog == null || backlogIndex >= backlog.length) {\n+                Object event = readEvent();\n+                switch (event) {\n+                    case null -> {} \/\/continue\n+                    case KeyEvent keyEvent -> {\n+                        processKeyEvent(\n+                                keyEvent.keyDown(), keyEvent.keyCode(), keyEvent.uchar(), keyEvent.controlKeyState());\n+                    }\n+                    case WindowSizeEvent evt -> {\n+                        refreshWidth.run();\n+                        return -1;\n+                    }\n+                    default -> throw new IllegalStateException(\"No other instances should be provided! Got: \" + event.getClass());\n+                }\n+            }\n+            cbuf[0] = backlog[backlogIndex++];\n+            return 1;\n+        }\n+\n+        protected void processKeyEvent(\n+                final boolean isKeyDown, final short virtualKeyCode, char ch, final int controlKeyState)\n+                throws IOException {\n+            StringBuilder data = new StringBuilder();\n+            final boolean isCtrl = (controlKeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) > 0;\n+            final boolean isAlt = (controlKeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)) > 0;\n+            final boolean isShift = (controlKeyState & SHIFT_PRESSED) > 0;\n+            \/\/ key down event\n+            if (isKeyDown && ch != '\\3') {\n+                \/\/ Pressing \"Alt Gr\" is translated to Alt-Ctrl, hence it has to be checked that Ctrl is _not_ pressed,\n+                \/\/ otherwise inserting of \"Alt Gr\" codes on non-US keyboards would yield errors\n+                if (ch != 0\n+                        && (controlKeyState\n+                                        & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED | RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED))\n+                                == (RIGHT_ALT_PRESSED | LEFT_CTRL_PRESSED)) {\n+                    data.append(ch);\n+                } else {\n+                    final String keySeq = getEscapeSequence(\n+                            virtualKeyCode, (isCtrl ? CTRL_FLAG : 0) + (isAlt ? ALT_FLAG : 0) + (isShift ? SHIFT_FLAG : 0));\n+                    if (keySeq != null) {\n+                        data.append(keySeq);\n+                    } else {\n+                    \/* uchar value in Windows when CTRL is pressed:\n+                     * 1). Ctrl +  <0x41 to 0x5e>      : uchar=<keyCode> - 'A' + 1\n+                     * 2). Ctrl + Backspace(0x08)      : uchar=0x7f\n+                     * 3). Ctrl + Enter(0x0d)          : uchar=0x0a\n+                     * 4). Ctrl + Space(0x20)          : uchar=0x20\n+                     * 5). Ctrl + <Other key>          : uchar=0\n+                     * 6). Ctrl + Alt + <Any key>      : uchar=0\n+                     *\/\n+                    if (ch > 0) {\n+                        if (isAlt) {\n+                            data.append('\\033');\n+                        }\n+                        if (isCtrl && ch != ' ' && ch != '\\n' && ch != 0x7f) {\n+                            data.append((char) (ch == '?' ? 0x7f : Character.toUpperCase(ch) & 0x1f));\n+                        } else if (isCtrl && ch == '\\n') {\n+                            \/\/simulate Alt-Enter:\n+                            data.append('\\033');\n+                            data.append('\\r');\n+                        } else {\n+                            data.append(ch);\n+                        }\n+                    } else if (isCtrl) { \/\/ Handles the ctrl key events(uchar=0)\n+                        if (virtualKeyCode >= 'A' && virtualKeyCode <= 'Z') {\n+                            ch = (char) (virtualKeyCode - 0x40);\n+                        } else if (virtualKeyCode == 191) { \/\/ ?\n+                            ch = 127;\n+                        }\n+                        if (ch > 0) {\n+                            if (isAlt) {\n+                                data.append('\\033');\n+                            }\n+                            data.append(ch);\n+                        }\n+                    }\n+                    }\n+                }\n+            } else if (isKeyDown && ch == '\\3') {\n+                data.append('\\3');\n+            }\n+            \/\/ key up event\n+            else {\n+                \/\/ support ALT+NumPad input method\n+                if (virtualKeyCode == 0x12 \/*VK_MENU ALT key*\/ && ch > 0) {\n+                    data.append(ch); \/\/ no such combination in Windows\n+                }\n+            }\n+            backlog = new char[data.length()];\n+            for (int i = 0; i < data.length(); i++) {\n+                backlog[i] = data.charAt(i);\n+            }\n+            backlogIndex = 0;\n+        }\n+\n+        protected String getEscapeSequence(short keyCode, int keyState) {\n+            \/\/ virtual keycodes: http:\/\/msdn.microsoft.com\/en-us\/library\/windows\/desktop\/dd375731(v=vs.85).aspx\n+            \/\/ TODO: numpad keys, modifiers\n+            String escapeSequence = null;\n+            switch (keyCode) {\n+                case 0x08: \/\/ VK_BACK BackSpace\n+                    escapeSequence = Character.toString(VERASE);\n+                    break;\n+                case 0x09:\n+                    return null;\n+                case 0x23: \/\/ VK_END\n+                    escapeSequence = \"\\033[F\";\n+                    break;\n+                case 0x24: \/\/ VK_HOME\n+                    escapeSequence = \"\\033[H\";\n+                    break;\n+                case 0x25: \/\/ VK_LEFT\n+                    escapeSequence = \"\\033[D\";\n+                    break;\n+                case 0x27: \/\/ VK_RIGHT\n+                    escapeSequence = \"\\033[C\";\n+                    break;\n+                case 0x2E: \/\/ VK_DELETE\n+                    escapeSequence = \"\\033[3~\";\n+                    break;\n+                case 0x21: \/\/ VK_PRIOR PageUp\n+                case 0x22: \/\/ VK_NEXT PageDown\n+                case 0x26: \/\/ VK_UP\n+                case 0x28: \/\/ VK_DOWN\n+                case 0x2D: \/\/ VK_INSERT\n+\n+                case 0x70: \/\/ VK_F1\n+                case 0x71: \/\/ VK_F2\n+                case 0x72: \/\/ VK_F3\n+                case 0x73: \/\/ VK_F4\n+                case 0x74: \/\/ VK_F5\n+                case 0x75: \/\/ VK_F6\n+                case 0x76: \/\/ VK_F7\n+                case 0x77: \/\/ VK_F8\n+                case 0x78: \/\/ VK_F9\n+                case 0x79: \/\/ VK_F10\n+                case 0x7A: \/\/ VK_F11\n+                case 0x7B: \/\/ VK_F12\n+                    return \"\";\n+                case 0x5D: \/\/ VK_CLOSE_BRACKET(Menu key)\n+                case 0x5B: \/\/ VK_OPEN_BRACKET(Window key)\n+                default:\n+                    return null;\n+            }\n+            if (keyState != 0) {\n+                \/\/with modifiers - ignore:\n+                return \"\";\n+            }\n+            return escapeSequence;\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/console\/WindowsTerminal.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jdk_internal_console_WindowsTerminal.h\"\n+\n+#include <stdlib.h>\n+#include <Windows.h>\n+\n+static jclass lastErrorExceptionClass;\n+static jmethodID lastErrorExceptionConstructor;\n+\n+static jclass KEY_EVENT_Class;\n+static jmethodID KEY_EVENT_Constructor;\n+\n+static jclass WINDOW_SIZE_EVENT_Class;\n+static jmethodID WINDOW_SIZE_EVENT_Constructor;\n+\n+static void throw_errno(JNIEnv *env);\n+\n+JNIEXPORT void JNICALL Java_jdk_internal_console_WindowsTerminal_initIDs\n+  (JNIEnv *env, jclass) {\n+    jclass cls;\n+    cls = env->FindClass(\"jdk\/internal\/console\/LastErrorException\");\n+    CHECK_NULL(cls);\n+    lastErrorExceptionClass = (jclass) env->NewGlobalRef(cls);\n+    lastErrorExceptionConstructor = env->GetMethodID(lastErrorExceptionClass, \"<init>\", \"(J)V\");\n+    CHECK_NULL(lastErrorExceptionConstructor);\n+    KEY_EVENT_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/console\/WindowsTerminal$KeyEvent\"));\n+    CHECK_NULL(KEY_EVENT_Class);\n+    KEY_EVENT_Constructor = env->GetMethodID(KEY_EVENT_Class, \"<init>\", \"(ZSCI)V\");\n+    CHECK_NULL(KEY_EVENT_Constructor);\n+    WINDOW_SIZE_EVENT_Class = (jclass) env->NewGlobalRef(env->FindClass(\"jdk\/internal\/console\/WindowsTerminal$WindowSizeEvent\"));\n+    CHECK_NULL(WINDOW_SIZE_EVENT_Class);\n+    WINDOW_SIZE_EVENT_Constructor = env->GetMethodID(WINDOW_SIZE_EVENT_Class, \"<init>\", \"()V\");\n+    CHECK_NULL(WINDOW_SIZE_EVENT_Constructor);\n+}\n+\n+JNIEXPORT jbyteArray JNICALL Java_jdk_internal_console_WindowsTerminal_switchToRaw\n+  (JNIEnv *env, jclass) {\n+    HANDLE inHandle = GetStdHandle(STD_INPUT_HANDLE);\n+    DWORD origInMode;\n+\n+    if (!GetConsoleMode(inHandle, &origInMode)) {\n+        throw_errno(env);\n+        return NULL;\n+    }\n+\n+    HANDLE outHandle = GetStdHandle(STD_OUTPUT_HANDLE);\n+    DWORD origOutMode;\n+\n+    if (!GetConsoleMode(outHandle, &origOutMode)) {\n+        throw_errno(env);\n+        return NULL;\n+    }\n+\n+    if (!SetConsoleMode(inHandle, ENABLE_PROCESSED_INPUT)) {\n+        throw_errno(env);\n+        return NULL;\n+    }\n+\n+    if (!SetConsoleMode(outHandle, ENABLE_VIRTUAL_TERMINAL_PROCESSING | ENABLE_PROCESSED_OUTPUT)) {\n+        throw_errno(env);\n+        return NULL;\n+    }\n+\n+    jsize dword_size = (jsize) sizeof(DWORD);\n+    jbyteArray result = env->NewByteArray(2 * dword_size);\n+\n+    env->SetByteArrayRegion(result, 0, dword_size, (jbyte *) &origInMode);\n+    env->SetByteArrayRegion(result, dword_size, dword_size, (jbyte *) &origOutMode);\n+\n+    return result;\n+}\n+\n+JNIEXPORT void JNICALL Java_jdk_internal_console_WindowsTerminal_restore\n+  (JNIEnv *env, jclass, jbyteArray storedData) {\n+    jsize dword_size = (jsize) sizeof(DWORD);\n+    DWORD origInMode;\n+    DWORD origOutMode;\n+\n+    env->GetByteArrayRegion(storedData, 0, dword_size, (jbyte*) &origInMode);\n+    env->GetByteArrayRegion(storedData, dword_size, dword_size, (jbyte*) &origOutMode);\n+\n+    HANDLE inHandle = GetStdHandle(STD_INPUT_HANDLE);\n+\n+    if (!SetConsoleMode(inHandle, origInMode)) {\n+        throw_errno(env);\n+        return ;\n+    }\n+\n+    HANDLE outHandle = GetStdHandle(STD_OUTPUT_HANDLE);\n+\n+    if (!SetConsoleMode(outHandle, origOutMode)) {\n+        throw_errno(env);\n+        return ;\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Java_jdk_internal_console_WindowsTerminal_terminalWidth\n+  (JNIEnv *env, jclass) {\n+    HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n+    CONSOLE_SCREEN_BUFFER_INFO buffer;\n+    if (!GetConsoleScreenBufferInfo(h, &buffer)) {\n+        DWORD error = GetLastError();\n+        jobject exc = env->NewObject(lastErrorExceptionClass,\n+                                     lastErrorExceptionConstructor,\n+                                     (jlong) error);\n+        env->Throw((jthrowable) exc);\n+        return -1;\n+    }\n+    return buffer.dwSize.X;\n+}\n+\n+JNIEXPORT jint JNICALL Java_jdk_internal_console_WindowsTerminal_cursorX\n+  (JNIEnv *env, jclass) {\n+    HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n+    CONSOLE_SCREEN_BUFFER_INFO buffer;\n+    if (!GetConsoleScreenBufferInfo(h, &buffer)) {\n+        DWORD error = GetLastError();\n+        jobject exc = env->NewObject(lastErrorExceptionClass,\n+                                     lastErrorExceptionConstructor,\n+                                     (jlong) error);\n+        env->Throw((jthrowable) exc);\n+        return -1;\n+    }\n+    return buffer.dwCursorPosition.X;\n+}\n+\n+JNIEXPORT jobject JNICALL Java_jdk_internal_console_WindowsTerminal_readEvent\n+  (JNIEnv *env, jclass) {\n+    HANDLE h = GetStdHandle(STD_INPUT_HANDLE);\n+    INPUT_RECORD buffer;\n+    DWORD numberOfEventsRead;\n+    if (!ReadConsoleInputW(h, &buffer, 1, &numberOfEventsRead)) {\n+        throw_errno(env);\n+        return NULL;\n+    }\n+    switch (buffer.EventType) {\n+        case KEY_EVENT: {\n+                jobject keyEvent = env->NewObject(KEY_EVENT_Class,\n+                                                  KEY_EVENT_Constructor,\n+                                                  buffer.Event.KeyEvent.bKeyDown,\n+                                                  buffer.Event.KeyEvent.wVirtualKeyCode,\n+                                                  buffer.Event.KeyEvent.uChar.UnicodeChar,\n+                                                  buffer.Event.KeyEvent.dwControlKeyState);\n+                return keyEvent;\n+            }\n+        case WINDOW_BUFFER_SIZE_EVENT: {\n+            jobject windowSizeEvent = env->NewObject(WINDOW_SIZE_EVENT_Class,\n+                                                     WINDOW_SIZE_EVENT_Constructor);\n+\n+            return windowSizeEvent;\n+        }\n+    }\n+    return NULL;\n+}\n+\n+\/*\n+ * Throws LastErrorException based on GetLastError:\n+ *\/\n+static void throw_errno(JNIEnv *env) {\n+    DWORD error = GetLastError();\n+    jobject exc = env->NewObject(lastErrorExceptionClass,\n+                                 lastErrorExceptionConstructor,\n+                                 (jlong) error);\n+    env->Throw((jthrowable) exc);\n+}\n","filename":"src\/jdk.internal.le\/windows\/native\/lible\/WindowsTerminal.cpp","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -92,1 +92,0 @@\n-                con.printf(\"\\n\");\n","filename":"test\/jdk\/java\/io\/Console\/LocaleTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,419 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8352693\n+ * @summary Test simple console reader.\n+ * @modules jdk.internal.le\/jdk.internal.console\n+ * @run main JdkConsoleImplConsoleTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.console.SimpleConsoleReader;\n+import jdk.internal.console.SimpleConsoleReader.TerminalConfiguration;\n+\n+public class JdkConsoleImplConsoleTest {\n+    public static void main(String... args) throws IOException {\n+        new JdkConsoleImplConsoleTest().run();\n+    }\n+\n+    private void run() throws IOException {\n+        testNavigation();\n+        testTerminalHandling();\n+        testSurrogates();\n+        testWraps();\n+    }\n+\n+    private void testNavigation() throws IOException {\n+        String input = \"\"\"\n+                       12345\\033[D\\033[D\\033[3~6\\033[1~7\\033[4~8\\033[H9\\033[FA\\r\n+                       \"\"\";\n+        String expectedResult = \"97123658A\";\n+        char[] read = SimpleConsoleReader.doRead(new StringReader(input),\n+                                                 new StringWriter(),\n+                                                 false,\n+                                                 createTerminalConfig(Integer.MAX_VALUE));\n+        assertEquals(expectedResult, new String(read));\n+    }\n+\n+    private void testTerminalHandling() throws IOException {\n+        Terminal terminal = new Terminal(5, 5);\n+        Thread.ofVirtual().start(() -> {\n+            try {\n+                SimpleConsoleReader.doRead(terminal.getInput(),\n+                                           terminal.getOutput(),\n+                                           false,\n+                                           createTerminalConfig(terminal.width));\n+            } catch (IOException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        });\n+\n+        terminal.typed(\"123456\");\n+        assertEquals(\"\"\"\n+                     12345\n+                     6\n+\n+\n+                     \"\"\",\n+                     terminal.getDisplay());\n+        terminal.typed(\"\\033[D\\033[D\\033[DN\");\n+        assertEquals(\"\"\"\n+                     123N4\n+                     56\n+\n+\n+                     \"\"\",\n+                     terminal.getDisplay());\n+    }\n+\n+    private void testSurrogates() throws IOException {\n+        {\n+            String input = \"\"\"\n+                           1\\uD83D\\uDE032\n+                           \"\"\";\n+            String expectedResult = \"1\\uD83D\\uDE032\";\n+            char[] read = SimpleConsoleReader.doRead(new StringReader(input),\n+                                                     new StringWriter(),\n+                                                     false,\n+                                                     createTerminalConfig(Integer.MAX_VALUE));\n+            assertEquals(expectedResult, new String(read));\n+        }\n+        {\n+            String input = \"\"\"\n+                           1\\uD83D\\uDE032\\u007F\\u007F3\n+                           \"\"\";\n+            String expectedResult = \"13\";\n+            char[] read = SimpleConsoleReader.doRead(new StringReader(input),\n+                                                     new StringWriter(),\n+                                                     false,\n+                                                     createTerminalConfig(Integer.MAX_VALUE));\n+            assertEquals(expectedResult, new String(read));\n+        }\n+\n+        {\n+            Terminal terminal = new Terminal(5, 5);\n+            Thread.ofVirtual().start(() -> {\n+                try {\n+                    SimpleConsoleReader.doRead(terminal.getInput(),\n+                                               terminal.getOutput(),\n+                                               false,\n+                                               createTerminalConfig(terminal.width));\n+                } catch (IOException ex) {\n+                    throw new IllegalStateException(ex);\n+                }\n+            });\n+\n+            terminal.typed(\"12\\uD83D\\uDE03456\");\n+            assertEquals(\"\"\"\n+                         12\\uD83D\\uDE034\n+                         56\n+\n+\n+                         \"\"\",\n+                         terminal.getDisplay());\n+            terminal.typed(\"\\033[D\\033[D\\033[D\\033[DN\");\n+            assertEquals(\"\"\"\n+                         12N\\uD83D\\uDE03\n+                         456\n+\n+\n+                         \"\"\",\n+                         terminal.getDisplay());\n+        }\n+\n+        {\n+            Terminal terminal = new Terminal(5, 5);\n+            Thread.ofVirtual().start(() -> {\n+                try {\n+                    SimpleConsoleReader.doRead(terminal.getInput(),\n+                                               terminal.getOutput(),\n+                                               false,\n+                                               createTerminalConfig(terminal.width));\n+                } catch (IOException ex) {\n+                    throw new IllegalStateException(ex);\n+                }\n+            });\n+\n+            terminal.typed(\"12\\uD83F\\uDEEF456\");\n+            assertEquals(\"\"\"\n+                         12\\uD83F\\uDEEF45\n+                         6\n+\n+\n+                         \"\"\",\n+                         terminal.getDisplay());\n+            terminal.typed(\"\\033[D\\033[D\\033[D\\033[DN\");\n+            assertEquals(\"\"\"\n+                         12N\\uD83F\\uDEEF4\n+                         56\n+\n+\n+                         \"\"\",\n+                         terminal.getDisplay());\n+        }\n+    }\n+\n+    private void testWraps() throws IOException {\n+        {\n+            Terminal terminal = new Terminal(5, 5);\n+            Thread.ofVirtual().start(() -> {\n+                try {\n+                    SimpleConsoleReader.doRead(terminal.getInput(),\n+                                               terminal.getOutput(),\n+                                               false,\n+                                               createTerminalConfig(terminal.width));\n+                } catch (IOException ex) {\n+                    throw new IllegalStateException(ex);\n+                }\n+            });\n+\n+            terminal.typed(\"12345ABCDEabc\");\n+            assertEquals(\"\"\"\n+                         12345\n+                         ABCDE\n+                         abc\n+\n+                         \"\"\",\n+                         terminal.getDisplay());\n+        }\n+    }\n+\n+    private static TerminalConfiguration createTerminalConfig(int width) {\n+        return new TerminalConfiguration(0, 4, 127, () -> width);\n+    }\n+\n+    private static void assertEquals(Object expected, Object actual) {\n+        if (!Objects.equals(expected, actual)) {\n+            throw new AssertionError(\"expected: \" + expected +\n+                                     \"actual: \" + actual);\n+        }\n+    }\n+\n+    private static class Terminal {\n+        private final Map<Character, Object> bindings = new HashMap<>();\n+        private final int width;\n+        private final int[][] buffer;\n+        private final StringBuilder pendingOutput = new StringBuilder();\n+        private final StringBuilder pendingInput = new StringBuilder();\n+        private final Object emptyInputLock = new Object();\n+        private Map<Character, Object> currentBindings = bindings;\n+        private int cursorX;\n+        private int cursorY;\n+\n+        public Terminal(int width, int height) {\n+            this.width = width;\n+            this.buffer = new int[height][];\n+\n+            for (int i = 0; i < height; i++) {\n+                this.buffer[i] = createLine();\n+            }\n+\n+            cursorX = 1;\n+            cursorY = 1;\n+\n+            \/\/ addKeyBinding(\"\\033[D\", () -> cursorX = Math.max(cursorX - 1, 0));\n+            addKeyBinding(\"\\033[A\", () -> cursorY = Math.max(cursorY - 1, 1));\n+            addKeyBinding(\"\\033[B\", () -> cursorY = Math.min(cursorY + 1, buffer.length));\n+            addKeyBinding(\"\\033[1G\", () -> cursorX = 1);\n+            addKeyBinding(\"\\033[2G\", () -> cursorX = 2);\n+            addKeyBinding(\"\\033[3G\", () -> cursorX = 3);\n+            addKeyBinding(\"\\033[4G\", () -> cursorX = 4);\n+            addKeyBinding(\"\\033[5G\", () -> cursorX = 5);\n+            addKeyBinding(\"\\033[K\", () -> Arrays.fill(buffer[cursorY - 1], cursorX - 1, buffer[cursorY - 1].length, ' '));\n+            addKeyBinding(\"\\n\", () -> {\n+                cursorY++;\n+                if (cursorY > buffer.length) {\n+                    throw new AssertionError(\"scrolling via \\\\n not implemented!\");\n+                }\n+            });\n+            addKeyBinding(\"\\r\", () -> cursorX = 1);\n+        }\n+\n+        private int[] createLine() {\n+            int[] line = new int[width];\n+\n+            Arrays.fill(line, ' ');\n+\n+            return line;\n+        }\n+\n+        private void addKeyBinding(String sequence, Runnable action) {\n+            Map<Character, Object> pending = bindings;\n+\n+            for (int i = 0; i < sequence.length() - 1; i++) {\n+                pending = (Map<Character, Object>) pending.computeIfAbsent(sequence.charAt(i), _ -> new HashMap<>());\n+            }\n+\n+            if (pending.put(sequence.charAt(sequence.length() - 1), action) != null) {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        private void handleOutput(char c) {\n+            pendingOutput.append(c);\n+\n+            Object nestedBindings = currentBindings.get(c);\n+\n+            switch (nestedBindings) {\n+                case null -> {\n+                    for (int i = 0; i < pendingOutput.length(); i++) {\n+                        if (cursorX > buffer[0].length) { \/\/(width)\n+                            cursorX = 1;\n+                            cursorY++;\n+                            scrollIfNeeded();\n+                        }\n+\n+                        char currentChar = pendingOutput.charAt(i);\n+\n+                        if (Character.isLowSurrogate(currentChar) &&\n+                            cursorX > 1 &&\n+                            Character.isHighSurrogate((char) buffer[cursorY - 1][cursorX - 2])) {\n+                            buffer[cursorY - 1][cursorX - 2] = Character.toCodePoint((char) buffer[cursorY - 1][cursorX - 2], currentChar);\n+                        } else {\n+                            buffer[cursorY - 1][cursorX - 1] = currentChar;\n+\n+                            cursorX++;\n+                        }\n+                    }\n+\n+                    pendingOutput.delete(0, pendingOutput.length());\n+                    currentBindings = bindings;\n+                }\n+\n+                case Runnable r -> {\n+                    r.run();\n+                    pendingOutput.delete(0, pendingOutput.length());\n+                    currentBindings = bindings;\n+                }\n+\n+                case Map nextBindings -> {\n+                    currentBindings = nextBindings;\n+                }\n+\n+                default -> throw new IllegalStateException();\n+            }\n+        }\n+\n+        private void scrollIfNeeded() {\n+            if (cursorY > buffer.length) {\n+                for (int j = 0; j < buffer.length - 1; j++) {\n+                    buffer[j] = buffer[j + 1];\n+                }\n+\n+                buffer[buffer.length - 1] = createLine();\n+                cursorY--;\n+            }\n+        }\n+\n+        public Writer getOutput() {\n+            return new Writer() {\n+                @Override\n+                public void write(char[] cbuf, int off, int len) throws IOException {\n+                    for (int i = 0; i < len; i++) {\n+                        handleOutput(cbuf[i + off]);\n+                    }\n+                }\n+\n+                @Override\n+                public void flush() throws IOException {}\n+\n+                @Override\n+                public void close() throws IOException {}\n+\n+            };\n+        }\n+\n+        public Reader getInput() {\n+            return new Reader() {\n+                @Override\n+                public int read(char[] cbuf, int off, int len) throws IOException {\n+                    if (len == 0) {\n+                        return 0;\n+                    }\n+\n+                    synchronized (pendingInput) {\n+                        while (pendingInput.isEmpty()) {\n+                            synchronized (emptyInputLock) {\n+                                emptyInputLock.notifyAll();\n+                            }\n+                            try {\n+                                pendingInput.wait();\n+                            } catch (InterruptedException ex) {\n+                            }\n+                        }\n+\n+                        cbuf[off] = pendingInput.charAt(0);\n+                        pendingInput.delete(0, 1);\n+\n+                        return 1;\n+                    }\n+                }\n+\n+                @Override\n+                public void close() throws IOException {}\n+            };\n+        }\n+\n+        public void typed(String text) {\n+            synchronized (pendingInput) {\n+                pendingInput.append(text);\n+                pendingInput.notifyAll();\n+            }\n+            synchronized (emptyInputLock) {\n+                try {\n+                    emptyInputLock.wait();\n+                } catch (InterruptedException ex) {\n+                }\n+            }\n+        }\n+\n+        public String getDisplay() {\n+            return Arrays.stream(buffer)\n+                         .map(this::line2String)\n+                         .map(l -> l.replaceAll(\" +$\", \"\"))\n+                         .collect(Collectors.joining(\"\\n\"));\n+        }\n+        private String line2String(int[] line) {\n+            char[] chars = new char[2 * line.length];\n+            int idx = 0;\n+\n+            for (int codePoint : line) {\n+                idx += Character.toChars(codePoint, chars, idx);\n+            }\n+\n+            return new String(chars, 0, idx);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/io\/JdkConsoleImplConsoleTest.java","additions":419,"deletions":0,"binary":false,"changes":419,"status":"added"},{"patch":"@@ -28,2 +28,1 @@\n- * @modules jdk.internal.le\/jdk.internal.org.jline\n- *          jdk.internal.le\/jdk.internal.org.jline.terminal\n+ * @modules jdk.internal.le\/jdk.internal.org.jline.terminal\n","filename":"test\/jdk\/jdk\/internal\/jline\/AbstractWindowsTerminalTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+    private static final String NL = System.getProperty(\"line.separator\");\n+\n@@ -54,1 +56,2 @@\n-        doRunConsoleTest(\"testCorrectOutputReadPassword\", \"inp\", \"%s\");\n+        doRunConsoleTest(\"testCorrectOutputReadPassword\", \"inp\",\n+                         \"%s\" + NL); \/\/see BaseJdkConsoleImpl.readPassword re the NL\n","filename":"test\/jdk\/jdk\/internal\/jline\/JLineConsoleProviderTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8333086\n- * @summary Verify the JLine backend is not initialized for simple printing.\n- * @enablePreview\n- * @modules jdk.internal.le\/jdk.internal.org.jline.reader\n- *          jdk.internal.le\/jdk.internal.org.jline.terminal\n- * @library \/test\/lib\n- * @run main LazyJdkConsoleProvider\n- *\/\n-\n-import java.io.IO;\n-import jdk.internal.org.jline.reader.LineReader;\n-import jdk.internal.org.jline.terminal.Terminal;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class LazyJdkConsoleProvider {\n-\n-    public static void main(String... args) throws Throwable {\n-        switch (args.length > 0 ? args[0] : \"default\") {\n-            case \"write\" -> {\n-                System.console().println(\"Hello!\");\n-                System.console().print(\"Hello!\");\n-                System.console().format(\"\\nHello!\\n\");\n-                System.console().flush();\n-                IO.println(\"Hello!\");\n-                IO.print(\"Hello!\");\n-            }\n-            case \"read\" -> System.console().readLine(\"Hello!\");\n-            case \"IO-read\" -> {\n-                IO.readln(\"Hello!\");\n-            }\n-            case \"default\" -> {\n-                new LazyJdkConsoleProvider().runTest();\n-            }\n-        }\n-    }\n-\n-    void runTest() throws Exception {\n-        record TestCase(String testKey, String expected, String notExpected) {}\n-        TestCase[] testCases = new TestCase[] {\n-            new TestCase(\"write\", null, Terminal.class.getName()),\n-            new TestCase(\"read\", LineReader.class.getName(), null),\n-            new TestCase(\"IO-read\", LineReader.class.getName(), null)\n-        };\n-        for (TestCase tc : testCases) {\n-            ProcessBuilder builder =\n-                    ProcessTools.createTestJavaProcessBuilder(\"--enable-preview\",\n-                                                              \"-verbose:class\",\n-                                                              \"-Djdk.console=jdk.internal.le\",\n-                                                              LazyJdkConsoleProvider.class.getName(),\n-                                                              tc.testKey());\n-            OutputAnalyzer output = ProcessTools.executeProcess(builder, \"\");\n-\n-            output.waitFor();\n-\n-            if (output.getExitValue() != 0) {\n-                throw new AssertionError(\"Unexpected return value: \" + output.getExitValue() +\n-                                         \", actualOut: \" + output.getStdout() +\n-                                         \", actualErr: \" + output.getStderr());\n-            }\n-            if (tc.expected() != null) {\n-                output.shouldContain(tc.expected());\n-            }\n-\n-            if (tc.notExpected() != null) {\n-                output.shouldNotContain(tc.notExpected());\n-            }\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/internal\/jline\/LazyJdkConsoleProvider.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"}]}