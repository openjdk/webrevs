{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+\n+import jdk.internal.constant.ConstantUtils;\n@@ -66,0 +68,2 @@\n+import static jdk.internal.constant.ConstantUtils.classDesc;\n+import static jdk.internal.constant.ConstantUtils.methodDesc;\n@@ -252,1 +256,1 @@\n-            var mt = methodType(m.getReturnType(), JLRA.getExecutableSharedParameterTypes(m), true);\n+            var md = methodDesc(m.getReturnType(), JLRA.getExecutableSharedParameterTypes(m));\n@@ -257,1 +261,1 @@\n-                                                       Arrays.stream(thrown).map(MethodHandleProxies::desc))\n+                                                       Arrays.stream(thrown).map(ConstantUtils::classDesc))\n@@ -259,1 +263,1 @@\n-            methods.add(new MethodInfo(desc(mt), exceptionTypeDescs, fieldName));\n+            methods.add(new MethodInfo(md, exceptionTypeDescs, fieldName));\n@@ -282,1 +286,1 @@\n-        byte[] template = createTemplate(loader, ClassDesc.of(className), desc(intfc), uniqueName, methods);\n+        byte[] template = createTemplate(loader, ClassDesc.of(className), classDesc(intfc), uniqueName, methods);\n@@ -338,3 +342,3 @@\n-    private static final List<ClassDesc> DEFAULT_RETHROWS = List.of(desc(RuntimeException.class), desc(Error.class));\n-    private static final ClassDesc CD_UndeclaredThrowableException = desc(UndeclaredThrowableException.class);\n-    private static final ClassDesc CD_IllegalAccessException = desc(IllegalAccessException.class);\n+    private static final List<ClassDesc> DEFAULT_RETHROWS = List.of(classDesc(RuntimeException.class), classDesc(Error.class));\n+    private static final ClassDesc CD_UndeclaredThrowableException = classDesc(UndeclaredThrowableException.class);\n+    private static final ClassDesc CD_IllegalAccessException = classDesc(IllegalAccessException.class);\n@@ -347,2 +351,2 @@\n-    private static final MethodTypeDesc MTD_void_Lookup_MethodHandle_MethodHandle =\n-            desc(MT_void_Lookup_MethodHandle_MethodHandle);\n+    private static final MethodTypeDesc MTD_void_Lookup_MethodHandle_MethodHandle\n+            = methodDesc(MT_void_Lookup_MethodHandle_MethodHandle);\n@@ -534,10 +538,0 @@\n-    private static ClassDesc desc(Class<?> cl) {\n-        return cl.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert class \"\n-                + cl.getName() + \" to a constant\"));\n-    }\n-\n-    private static MethodTypeDesc desc(MethodType mt) {\n-        return mt.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert method type \"\n-                + mt + \" to a constant\"));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -1099,1 +1100,1 @@\n-                                        MethodTypeDesc.ofDescriptor(args.toMethodDescriptorString()),\n+                                        ConstantUtils.methodDesc(args),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+import static jdk.internal.constant.ConstantUtils.classDesc;\n+import static jdk.internal.constant.ConstantUtils.methodDesc;\n+\n@@ -137,1 +140,1 @@\n-    private ClassEntry classEntry;\n+    private final ClassEntry classEntry;\n@@ -163,1 +166,1 @@\n-    private ProxyGenerator(ClassLoader loader, String className, List<Class<?>> interfaces,\n+    private ProxyGenerator(String className, List<Class<?>> interfaces,\n@@ -193,1 +196,1 @@\n-        ProxyGenerator gen = new ProxyGenerator(loader, name, interfaces, accessFlags);\n+        ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);\n@@ -234,8 +237,0 @@\n-    \/**\n-     * {@return the {@code ClassDesc} of the given type}\n-     * @param type the {@code Class} object\n-     *\/\n-    private static ClassDesc toClassDesc(Class<?> type) {\n-        return ClassDesc.ofDescriptor(type.descriptorString());\n-    }\n-\n@@ -328,1 +323,1 @@\n-            ProxyMethod pm = methods.get(0);\n+            ProxyMethod pm = methods.getFirst();\n@@ -504,1 +499,1 @@\n-                (f) -> new ArrayList<>(3));\n+                _ -> new ArrayList<>(3));\n@@ -534,1 +529,1 @@\n-                (f) -> new ArrayList<>(3));\n+                _ -> new ArrayList<>(3));\n@@ -640,1 +635,0 @@\n-         * @param methodFieldName the fieldName to generate\n@@ -653,5 +647,1 @@\n-            var pTypes = new ClassDesc[parameterTypes.length];\n-            for (int i = 0; i < pTypes.length; i++) {\n-                pTypes[i] = toClassDesc(parameterTypes[i]);\n-            }\n-            MethodTypeDesc desc = MethodTypeDescImpl.ofTrusted(toClassDesc(returnType), pTypes);\n+            var desc = methodDesc(returnType, parameterTypes);\n@@ -668,1 +658,1 @@\n-                                toClassDesc(fromClass),\n+                                classDesc(fromClass),\n@@ -696,1 +686,1 @@\n-                                cob.exceptionCatch(cob.startLabel(), c1, c1, toClassDesc(exc));\n+                                cob.exceptionCatch(cob.startLabel(), c1, c1, classDesc(exc));\n@@ -742,1 +732,1 @@\n-                cob.checkcast(toClassDesc(type))\n+                cob.checkcast(classDesc(type))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":13,"deletions":23,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+import static jdk.internal.constant.ConstantUtils.classDesc;\n+\n@@ -324,1 +326,1 @@\n-            return EnumDesc.of(enumClassTemplate.describeConstable().orElseThrow(), (String) label);\n+            return EnumDesc.of(classDesc(enumClassTemplate), (String) label);\n@@ -467,4 +469,2 @@\n-                            cb.instanceOf(Wrapper.forBasicType(classLabel)\n-                                    .wrapperType()\n-                                    .describeConstable()\n-                                    .orElseThrow());\n+                            cb.instanceOf(classDesc(Wrapper.forBasicType(classLabel)\n+                                    .wrapperType()));\n@@ -520,1 +520,1 @@\n-                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, typePair.from.describeConstable().orElseThrow()));\n+                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, classDesc(typePair.from)));\n@@ -606,2 +606,2 @@\n-                            MethodTypeDesc.of(element.caseLabel().getClass().describeConstable().orElseThrow(),\n-                                    Wrapper.asPrimitiveType(element.caseLabel().getClass()).describeConstable().orElseThrow()));\n+                            MethodTypeDesc.of(classDesc(element.caseLabel().getClass()),\n+                                    classDesc(Wrapper.asPrimitiveType(element.caseLabel().getClass()))));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import static jdk.internal.constant.ConstantUtils.classDesc;\n@@ -248,1 +249,1 @@\n-                    : ClassHierarchyInfo.ofClass(cl.getSuperclass().describeConstable().orElseThrow());\n+                    : ClassHierarchyInfo.ofClass(classDesc(cl.getSuperclass()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodType;\n@@ -50,0 +52,53 @@\n+    \/\/ Note:\n+    \/\/ Non-JDK users should create their own utilities that wrap\n+    \/\/ {@code .describeConstable().orElseThrow()} calls;\n+    \/\/ these xxDesc methods has undefined and unsafe exceptional\n+    \/\/ behavior, so they are not suitable as public APIs.\n+\n+    \/**\n+     * Creates a ClassDesc from a Class object, requires that this class\n+     * can always be described nominally, i.e. this class is not a\n+     * hidden class or interface or an array with a hidden component\n+     * type.\n+     *\/\n+    public static ClassDesc classDesc(Class<?> type) {\n+        if (type.isPrimitive()) {\n+            return Wrapper.forPrimitiveType(type).classDescriptor();\n+        }\n+        return ReferenceClassDescImpl.ofValidated(type.descriptorString());\n+    }\n+\n+    \/**\n+     * Creates a MethodTypeDesc from a MethodType object, requires that\n+     * the type can be described nominally, i.e. all of its return\n+     * type and parameter types can be described nominally.\n+     *\/\n+    public static MethodTypeDesc methodDesc(MethodType type) {\n+        var returnDesc = classDesc(type.returnType());\n+        if (type.parameterCount() == 0) {\n+            return MethodTypeDescImpl.ofValidated(returnDesc, EMPTY_CLASSDESC);\n+        }\n+        var paramDescs = new ClassDesc[type.parameterCount()];\n+        for (int i = 0; i < type.parameterCount(); i++) {\n+            paramDescs[i] = classDesc(type.parameterType(i));\n+        }\n+        return MethodTypeDescImpl.ofValidated(returnDesc, paramDescs);\n+    }\n+\n+    \/**\n+     * Creates a MethodTypeDesc from return class and parameter\n+     * class objects, requires that all of them can be described nominally.\n+     * This version is mainly useful for working with Method objects.\n+     *\/\n+    public static MethodTypeDesc methodDesc(Class<?> returnType, Class<?>[] parameterTypes) {\n+        var returnDesc = classDesc(returnType);\n+        if (parameterTypes.length == 0) {\n+            return MethodTypeDescImpl.ofValidated(returnDesc, EMPTY_CLASSDESC);\n+        }\n+        var paramDescs = new ClassDesc[parameterTypes.length];\n+        for (int i = 0; i < parameterTypes.length; i++) {\n+            paramDescs[i] = classDesc(parameterTypes[i]);\n+        }\n+        return MethodTypeDescImpl.ofValidated(returnDesc, paramDescs);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false)\n+                == descriptor.length() : descriptor;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+\n@@ -53,1 +54,0 @@\n-import java.lang.constant.Constable;\n@@ -73,0 +73,2 @@\n+import static jdk.internal.constant.ConstantUtils.classDesc;\n+import static jdk.internal.constant.ConstantUtils.methodDesc;\n@@ -83,18 +85,18 @@\n-    private static final ClassDesc CD_Arena = desc(Arena.class);\n-    private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);\n-    private static final ClassDesc CD_MemorySegment_Scope = desc(MemorySegment.Scope.class);\n-    private static final ClassDesc CD_SharedUtils = desc(SharedUtils.class);\n-    private static final ClassDesc CD_AbstractMemorySegmentImpl = desc(AbstractMemorySegmentImpl.class);\n-    private static final ClassDesc CD_MemorySessionImpl = desc(MemorySessionImpl.class);\n-    private static final ClassDesc CD_Utils = desc(Utils.class);\n-    private static final ClassDesc CD_SegmentAllocator = desc(SegmentAllocator.class);\n-    private static final ClassDesc CD_ValueLayout = desc(ValueLayout.class);\n-    private static final ClassDesc CD_ValueLayout_OfBoolean = desc(ValueLayout.OfBoolean.class);\n-    private static final ClassDesc CD_ValueLayout_OfByte = desc(ValueLayout.OfByte.class);\n-    private static final ClassDesc CD_ValueLayout_OfShort = desc(ValueLayout.OfShort.class);\n-    private static final ClassDesc CD_ValueLayout_OfChar = desc(ValueLayout.OfChar.class);\n-    private static final ClassDesc CD_ValueLayout_OfInt = desc(ValueLayout.OfInt.class);\n-    private static final ClassDesc CD_ValueLayout_OfLong = desc(ValueLayout.OfLong.class);\n-    private static final ClassDesc CD_ValueLayout_OfFloat = desc(ValueLayout.OfFloat.class);\n-    private static final ClassDesc CD_ValueLayout_OfDouble = desc(ValueLayout.OfDouble.class);\n-    private static final ClassDesc CD_AddressLayout = desc(AddressLayout.class);\n+    private static final ClassDesc CD_Arena = classDesc(Arena.class);\n+    private static final ClassDesc CD_MemorySegment = classDesc(MemorySegment.class);\n+    private static final ClassDesc CD_MemorySegment_Scope = classDesc(MemorySegment.Scope.class);\n+    private static final ClassDesc CD_SharedUtils = classDesc(SharedUtils.class);\n+    private static final ClassDesc CD_AbstractMemorySegmentImpl = classDesc(AbstractMemorySegmentImpl.class);\n+    private static final ClassDesc CD_MemorySessionImpl = classDesc(MemorySessionImpl.class);\n+    private static final ClassDesc CD_Utils = classDesc(Utils.class);\n+    private static final ClassDesc CD_SegmentAllocator = classDesc(SegmentAllocator.class);\n+    private static final ClassDesc CD_ValueLayout = classDesc(ValueLayout.class);\n+    private static final ClassDesc CD_ValueLayout_OfBoolean = classDesc(ValueLayout.OfBoolean.class);\n+    private static final ClassDesc CD_ValueLayout_OfByte = classDesc(ValueLayout.OfByte.class);\n+    private static final ClassDesc CD_ValueLayout_OfShort = classDesc(ValueLayout.OfShort.class);\n+    private static final ClassDesc CD_ValueLayout_OfChar = classDesc(ValueLayout.OfChar.class);\n+    private static final ClassDesc CD_ValueLayout_OfInt = classDesc(ValueLayout.OfInt.class);\n+    private static final ClassDesc CD_ValueLayout_OfLong = classDesc(ValueLayout.OfLong.class);\n+    private static final ClassDesc CD_ValueLayout_OfFloat = classDesc(ValueLayout.OfFloat.class);\n+    private static final ClassDesc CD_ValueLayout_OfDouble = classDesc(ValueLayout.OfDouble.class);\n+    private static final ClassDesc CD_AddressLayout = classDesc(AddressLayout.class);\n@@ -199,1 +201,1 @@\n-            clb.withMethodBody(METHOD_NAME, desc(callerMethodType), ACC_PUBLIC | ACC_STATIC,\n+            clb.withMethodBody(METHOD_NAME, methodDesc(callerMethodType), ACC_PUBLIC | ACC_STATIC,\n@@ -365,1 +367,1 @@\n-        cb.invokevirtual(CD_MethodHandle, \"invokeExact\", desc(leafType));\n+        cb.invokevirtual(CD_MethodHandle, \"invokeExact\", methodDesc(leafType));\n@@ -469,1 +471,1 @@\n-                case SegmentBase unused          -> emitSegmentBase();\n+                case SegmentBase _               -> emitSegmentBase();\n@@ -471,1 +473,1 @@\n-                case Dup unused                  -> emitDupBinding();\n+                case Dup _                       -> emitDupBinding();\n@@ -611,1 +613,1 @@\n-            MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, desc(storeType));\n+            MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, classDesc(storeType));\n@@ -669,1 +671,1 @@\n-                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, desc(chunkStoreType));\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, classDesc(chunkStoreType));\n@@ -700,1 +702,1 @@\n-                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, desc(storeType));\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, classDesc(storeType));\n@@ -719,1 +721,1 @@\n-                MethodTypeDesc descriptor = MethodTypeDesc.of(desc(loadType), valueLayoutType, CD_long);\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(classDesc(loadType), valueLayoutType, CD_long);\n@@ -812,1 +814,1 @@\n-            MethodTypeDesc descriptor = MethodTypeDesc.of(desc(loadType), valueLayoutType, CD_long);\n+            MethodTypeDesc descriptor = MethodTypeDesc.of(classDesc(loadType), valueLayoutType, CD_long);\n@@ -852,1 +854,1 @@\n-                MethodTypeDesc descriptor = MethodTypeDesc.of(desc(chunkType), valueLayoutType, CD_long);\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(classDesc(chunkType), valueLayoutType, CD_long);\n@@ -991,5 +993,0 @@\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T desc(Constable c) {\n-        return (T) c.describeConstable().orElseThrow();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"}]}