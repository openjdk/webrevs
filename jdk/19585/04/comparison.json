{"files":[{"patch":"@@ -48,0 +48,1 @@\n+import static jdk.internal.constant.ConstantUtils.CD_module_info;\n@@ -395,1 +396,1 @@\n-        return build(ClassDesc.of(\"module-info\"), clb -> {\n+        return build(CD_module_info, clb -> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import static jdk.internal.constant.ConstantUtils.dropFirstAndLastChar;\n@@ -168,1 +167,1 @@\n-               ? Wrapper.forPrimitiveType(descriptor.charAt(0)).classDescriptor()\n+               ? Wrapper.forPrimitiveType(descriptor.charAt(0)).basicClassDescriptor()\n@@ -318,1 +317,1 @@\n-                return Wrapper.forBasicType(desc.charAt(1)).classDescriptor();\n+                return Wrapper.forBasicType(desc.charAt(1)).basicClassDescriptor();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+\n+import jdk.internal.constant.ConstantUtils;\n@@ -66,0 +68,1 @@\n+import static jdk.internal.constant.ConstantUtils.*;\n@@ -252,1 +255,1 @@\n-            var mt = methodType(m.getReturnType(), JLRA.getExecutableSharedParameterTypes(m), true);\n+            var md = methodTypeDesc(m.getReturnType(), JLRA.getExecutableSharedParameterTypes(m));\n@@ -257,1 +260,1 @@\n-                                                       Arrays.stream(thrown).map(MethodHandleProxies::desc))\n+                                                       Arrays.stream(thrown).map(ConstantUtils::referenceClassDesc))\n@@ -259,1 +262,1 @@\n-            methods.add(new MethodInfo(desc(mt), exceptionTypeDescs, fieldName));\n+            methods.add(new MethodInfo(md, exceptionTypeDescs, fieldName));\n@@ -282,1 +285,2 @@\n-        byte[] template = createTemplate(loader, ClassDesc.of(className), desc(intfc), uniqueName, methods);\n+        byte[] template = createTemplate(loader, binaryNameToDesc(className),\n+                referenceClassDesc(intfc), uniqueName, methods);\n@@ -338,3 +342,3 @@\n-    private static final List<ClassDesc> DEFAULT_RETHROWS = List.of(desc(RuntimeException.class), desc(Error.class));\n-    private static final ClassDesc CD_UndeclaredThrowableException = desc(UndeclaredThrowableException.class);\n-    private static final ClassDesc CD_IllegalAccessException = desc(IllegalAccessException.class);\n+    private static final List<ClassDesc> DEFAULT_RETHROWS = List.of(referenceClassDesc(RuntimeException.class), referenceClassDesc(Error.class));\n+    private static final ClassDesc CD_UndeclaredThrowableException = referenceClassDesc(UndeclaredThrowableException.class);\n+    private static final ClassDesc CD_IllegalAccessException = referenceClassDesc(IllegalAccessException.class);\n@@ -347,2 +351,2 @@\n-    private static final MethodTypeDesc MTD_void_Lookup_MethodHandle_MethodHandle =\n-            desc(MT_void_Lookup_MethodHandle_MethodHandle);\n+    private static final MethodTypeDesc MTD_void_Lookup_MethodHandle_MethodHandle\n+            = methodTypeDesc(MT_void_Lookup_MethodHandle_MethodHandle);\n@@ -534,10 +538,0 @@\n-    private static ClassDesc desc(Class<?> cl) {\n-        return cl.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert class \"\n-                + cl.getName() + \" to a constant\"));\n-    }\n-\n-    private static MethodTypeDesc desc(MethodType mt) {\n-        return mt.describeConstable().orElseThrow(() -> newInternalError(\"Cannot convert method type \"\n-                + mt + \" to a constant\"));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -1093,1 +1094,1 @@\n-            byte[] classBytes = ClassFile.of().build(ClassDesc.of(className),\n+            byte[] classBytes = ClassFile.of().build(ConstantUtils.binaryNameToDesc(className),\n@@ -1099,1 +1100,1 @@\n-                                        MethodTypeDesc.ofDescriptor(args.toMethodDescriptorString()),\n+                                        ConstantUtils.methodTypeDesc(args),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+import static jdk.internal.constant.ConstantUtils.*;\n+\n@@ -137,1 +139,1 @@\n-    private ClassEntry classEntry;\n+    private final ClassEntry classEntry;\n@@ -163,1 +165,1 @@\n-    private ProxyGenerator(ClassLoader loader, String className, List<Class<?>> interfaces,\n+    private ProxyGenerator(String className, List<Class<?>> interfaces,\n@@ -166,1 +168,1 @@\n-        this.classEntry = cp.classEntry(ReferenceClassDescImpl.ofValidatedBinaryName(className));\n+        this.classEntry = cp.classEntry(ConstantUtils.binaryNameToDesc(className));\n@@ -193,1 +195,1 @@\n-        ProxyGenerator gen = new ProxyGenerator(loader, name, interfaces, accessFlags);\n+        ProxyGenerator gen = new ProxyGenerator(name, interfaces, accessFlags);\n@@ -230,1 +232,1 @@\n-            ces.add(cp.classEntry(ReferenceClassDescImpl.ofValidatedBinaryName(t.getName())));\n+            ces.add(cp.classEntry(ConstantUtils.binaryNameToDesc(t.getName())));\n@@ -234,8 +236,0 @@\n-    \/**\n-     * {@return the {@code ClassDesc} of the given type}\n-     * @param type the {@code Class} object\n-     *\/\n-    private static ClassDesc toClassDesc(Class<?> type) {\n-        return ClassDesc.ofDescriptor(type.descriptorString());\n-    }\n-\n@@ -328,1 +322,1 @@\n-            ProxyMethod pm = methods.get(0);\n+            ProxyMethod pm = methods.getFirst();\n@@ -504,1 +498,1 @@\n-                (f) -> new ArrayList<>(3));\n+                _ -> new ArrayList<>(3));\n@@ -534,1 +528,1 @@\n-                (f) -> new ArrayList<>(3));\n+                _ -> new ArrayList<>(3));\n@@ -640,1 +634,0 @@\n-         * @param methodFieldName the fieldName to generate\n@@ -653,5 +646,1 @@\n-            var pTypes = new ClassDesc[parameterTypes.length];\n-            for (int i = 0; i < pTypes.length; i++) {\n-                pTypes[i] = toClassDesc(parameterTypes[i]);\n-            }\n-            MethodTypeDesc desc = MethodTypeDescImpl.ofTrusted(toClassDesc(returnType), pTypes);\n+            var desc = methodTypeDesc(returnType, parameterTypes);\n@@ -668,1 +657,1 @@\n-                                toClassDesc(fromClass),\n+                                referenceClassDesc(fromClass),\n@@ -696,1 +685,1 @@\n-                                cob.exceptionCatch(cob.startLabel(), c1, c1, toClassDesc(exc));\n+                                cob.exceptionCatch(cob.startLabel(), c1, c1, referenceClassDesc(exc));\n@@ -742,1 +731,1 @@\n-                cob.checkcast(toClassDesc(type))\n+                cob.checkcast(referenceClassDesc(type))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.classfile.ClassBuilder;\n@@ -53,0 +52,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -62,0 +62,3 @@\n+import static jdk.internal.constant.ConstantUtils.classDesc;\n+import static jdk.internal.constant.ConstantUtils.referenceClassDesc;\n+\n@@ -324,1 +327,1 @@\n-            return EnumDesc.of(enumClassTemplate.describeConstable().orElseThrow(), (String) label);\n+            return EnumDesc.of(referenceClassDesc(enumClassTemplate), (String) label);\n@@ -467,4 +470,1 @@\n-                            cb.instanceOf(Wrapper.forBasicType(classLabel)\n-                                    .wrapperType()\n-                                    .describeConstable()\n-                                    .orElseThrow());\n+                            cb.instanceOf(Wrapper.forBasicType(classLabel).wrapperClassDescriptor());\n@@ -518,1 +518,1 @@\n-                            cb.invokestatic(ExactConversionsSupport.class.describeConstable().orElseThrow(),\n+                            cb.invokestatic(referenceClassDesc(ExactConversionsSupport.class),\n@@ -520,1 +520,1 @@\n-                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, typePair.from.describeConstable().orElseThrow()));\n+                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, classDesc(typePair.from)));\n@@ -556,1 +556,1 @@\n-                    cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n+                    cb.invokeinterface(referenceClassDesc(BiPredicate.class),\n@@ -604,1 +604,2 @@\n-                    cb.invokestatic(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                    var caseLabelWrapper = Wrapper.forWrapperType(element.caseLabel().getClass());\n+                    cb.invokestatic(caseLabelWrapper.wrapperClassDescriptor(),\n@@ -606,2 +607,2 @@\n-                            MethodTypeDesc.of(element.caseLabel().getClass().describeConstable().orElseThrow(),\n-                                    Wrapper.asPrimitiveType(element.caseLabel().getClass()).describeConstable().orElseThrow()));\n+                            MethodTypeDesc.of(caseLabelWrapper.wrapperClassDescriptor(),\n+                                    caseLabelWrapper.basicClassDescriptor()));\n@@ -634,1 +635,1 @@\n-        byte[] classBytes = ClassFile.of().build(ReferenceClassDescImpl.ofValidatedBinaryName(typeSwitchClassName(caller.lookupClass())),\n+        byte[] classBytes = ClassFile.of().build(ConstantUtils.binaryNameToDesc(typeSwitchClassName(caller.lookupClass())),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import static jdk.internal.constant.ConstantUtils.referenceClassDesc;\n@@ -248,1 +249,1 @@\n-                    : ClassHierarchyInfo.ofClass(cl.getSuperclass().describeConstable().orElseThrow());\n+                    : ClassHierarchyInfo.ofClass(referenceClassDesc(cl.getSuperclass()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.classfile.constantpool.NameAndTypeEntry;\n@@ -36,1 +35,0 @@\n-import java.lang.classfile.constantpool.DynamicConstantPoolEntry;\n@@ -49,0 +47,2 @@\n+import static jdk.internal.constant.ConstantUtils.binaryNameToDesc;\n+\n@@ -1324,2 +1324,2 @@\n-        private static final ClassDesc CD_Cloneable = ClassDesc.of(\"java.lang.Cloneable\");\n-        private static final ClassDesc CD_Serializable = ClassDesc.of(\"java.io.Serializable\");\n+        private static final ClassDesc CD_Cloneable = binaryNameToDesc(\"java.lang.Cloneable\");\n+        private static final ClassDesc CD_Serializable = binaryNameToDesc(\"java.io.Serializable\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodType;\n@@ -44,0 +46,1 @@\n+    public static final ClassDesc CD_module_info = binaryNameToDesc(\"module-info\");\n@@ -50,0 +53,72 @@\n+    \/\/ Note:\n+    \/\/ Non-JDK users should create their own utilities that wrap\n+    \/\/ {@code .describeConstable().orElseThrow()} calls;\n+    \/\/ these xxDesc methods has undefined and unsafe exceptional\n+    \/\/ behavior, so they are not suitable as public APIs.\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated binary name\n+     * for a class or interface type. Validated version of {@link\n+     * ClassDesc#of(String)}.\n+     *\n+     * @param binaryName a binary name\n+     *\/\n+    public static ClassDesc binaryNameToDesc(String binaryName) {\n+        return ReferenceClassDescImpl.ofValidated(\"L\" + binaryToInternal(binaryName) + \";\");\n+    }\n+\n+    \/**\n+     * Creates a ClassDesc from a Class object, requires that this class\n+     * can always be described nominally, i.e. this class is not a\n+     * hidden class or interface or an array with a hidden component\n+     * type.\n+     *\/\n+    public static ClassDesc classDesc(Class<?> type) {\n+        if (type.isPrimitive()) {\n+            return Wrapper.forPrimitiveType(type).basicClassDescriptor();\n+        }\n+        return referenceClassDesc(type);\n+    }\n+\n+    \/**\n+     * Creates a ClassDesc from a Class object representing a non-hidden\n+     * class or interface or an array type with a non-hidden component type.\n+     *\/\n+    public static ClassDesc referenceClassDesc(Class<?> type) {\n+        return ReferenceClassDescImpl.ofValidated(type.descriptorString());\n+    }\n+\n+    \/**\n+     * Creates a MethodTypeDesc from a MethodType object, requires that\n+     * the type can be described nominally, i.e. all of its return\n+     * type and parameter types can be described nominally.\n+     *\/\n+    public static MethodTypeDesc methodTypeDesc(MethodType type) {\n+        var returnDesc = classDesc(type.returnType());\n+        if (type.parameterCount() == 0) {\n+            return MethodTypeDescImpl.ofValidated(returnDesc, EMPTY_CLASSDESC);\n+        }\n+        var paramDescs = new ClassDesc[type.parameterCount()];\n+        for (int i = 0; i < type.parameterCount(); i++) {\n+            paramDescs[i] = classDesc(type.parameterType(i));\n+        }\n+        return MethodTypeDescImpl.ofValidated(returnDesc, paramDescs);\n+    }\n+\n+    \/**\n+     * Creates a MethodTypeDesc from return class and parameter\n+     * class objects, requires that all of them can be described nominally.\n+     * This version is mainly useful for working with Method objects.\n+     *\/\n+    public static MethodTypeDesc methodTypeDesc(Class<?> returnType, Class<?>[] parameterTypes) {\n+        var returnDesc = classDesc(returnType);\n+        if (parameterTypes.length == 0) {\n+            return MethodTypeDescImpl.ofValidated(returnDesc, EMPTY_CLASSDESC);\n+        }\n+        var paramDescs = new ClassDesc[parameterTypes.length];\n+        for (int i = 0; i < parameterTypes.length; i++) {\n+            paramDescs[i] = classDesc(parameterTypes[i]);\n+        }\n+        return MethodTypeDescImpl.ofValidated(returnDesc, paramDescs);\n+    }\n+\n@@ -234,1 +309,1 @@\n-            return Wrapper.forPrimitiveType(descriptor.charAt(start)).classDescriptor();\n+            return Wrapper.forPrimitiveType(descriptor.charAt(start)).basicClassDescriptor();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":76,"deletions":1,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false)\n+                == descriptor.length() : descriptor;\n@@ -72,11 +74,0 @@\n-    \/**\n-     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n-     * for a class or interface type or an array type.\n-     *\n-     * @param descriptor a field descriptor string for a class or interface type\n-     * @jvms 4.3.2 Field Descriptors\n-     *\/\n-    public static ClassDesc ofValidatedBinaryName(String typeSwitchClassName) {\n-        return ofValidated(\"L\" + binaryToInternal(typeSwitchClassName) + \";\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+\n@@ -53,1 +54,0 @@\n-import java.lang.constant.Constable;\n@@ -73,0 +73,1 @@\n+import static jdk.internal.constant.ConstantUtils.*;\n@@ -83,18 +84,18 @@\n-    private static final ClassDesc CD_Arena = desc(Arena.class);\n-    private static final ClassDesc CD_MemorySegment = desc(MemorySegment.class);\n-    private static final ClassDesc CD_MemorySegment_Scope = desc(MemorySegment.Scope.class);\n-    private static final ClassDesc CD_SharedUtils = desc(SharedUtils.class);\n-    private static final ClassDesc CD_AbstractMemorySegmentImpl = desc(AbstractMemorySegmentImpl.class);\n-    private static final ClassDesc CD_MemorySessionImpl = desc(MemorySessionImpl.class);\n-    private static final ClassDesc CD_Utils = desc(Utils.class);\n-    private static final ClassDesc CD_SegmentAllocator = desc(SegmentAllocator.class);\n-    private static final ClassDesc CD_ValueLayout = desc(ValueLayout.class);\n-    private static final ClassDesc CD_ValueLayout_OfBoolean = desc(ValueLayout.OfBoolean.class);\n-    private static final ClassDesc CD_ValueLayout_OfByte = desc(ValueLayout.OfByte.class);\n-    private static final ClassDesc CD_ValueLayout_OfShort = desc(ValueLayout.OfShort.class);\n-    private static final ClassDesc CD_ValueLayout_OfChar = desc(ValueLayout.OfChar.class);\n-    private static final ClassDesc CD_ValueLayout_OfInt = desc(ValueLayout.OfInt.class);\n-    private static final ClassDesc CD_ValueLayout_OfLong = desc(ValueLayout.OfLong.class);\n-    private static final ClassDesc CD_ValueLayout_OfFloat = desc(ValueLayout.OfFloat.class);\n-    private static final ClassDesc CD_ValueLayout_OfDouble = desc(ValueLayout.OfDouble.class);\n-    private static final ClassDesc CD_AddressLayout = desc(AddressLayout.class);\n+    private static final ClassDesc CD_Arena = referenceClassDesc(Arena.class);\n+    private static final ClassDesc CD_MemorySegment = referenceClassDesc(MemorySegment.class);\n+    private static final ClassDesc CD_MemorySegment_Scope = referenceClassDesc(MemorySegment.Scope.class);\n+    private static final ClassDesc CD_SharedUtils = referenceClassDesc(SharedUtils.class);\n+    private static final ClassDesc CD_AbstractMemorySegmentImpl = referenceClassDesc(AbstractMemorySegmentImpl.class);\n+    private static final ClassDesc CD_MemorySessionImpl = referenceClassDesc(MemorySessionImpl.class);\n+    private static final ClassDesc CD_Utils = referenceClassDesc(Utils.class);\n+    private static final ClassDesc CD_SegmentAllocator = referenceClassDesc(SegmentAllocator.class);\n+    private static final ClassDesc CD_ValueLayout = referenceClassDesc(ValueLayout.class);\n+    private static final ClassDesc CD_ValueLayout_OfBoolean = referenceClassDesc(ValueLayout.OfBoolean.class);\n+    private static final ClassDesc CD_ValueLayout_OfByte = referenceClassDesc(ValueLayout.OfByte.class);\n+    private static final ClassDesc CD_ValueLayout_OfShort = referenceClassDesc(ValueLayout.OfShort.class);\n+    private static final ClassDesc CD_ValueLayout_OfChar = referenceClassDesc(ValueLayout.OfChar.class);\n+    private static final ClassDesc CD_ValueLayout_OfInt = referenceClassDesc(ValueLayout.OfInt.class);\n+    private static final ClassDesc CD_ValueLayout_OfLong = referenceClassDesc(ValueLayout.OfLong.class);\n+    private static final ClassDesc CD_ValueLayout_OfFloat = referenceClassDesc(ValueLayout.OfFloat.class);\n+    private static final ClassDesc CD_ValueLayout_OfDouble = referenceClassDesc(ValueLayout.OfDouble.class);\n+    private static final ClassDesc CD_AddressLayout = referenceClassDesc(AddressLayout.class);\n@@ -199,1 +200,1 @@\n-            clb.withMethodBody(METHOD_NAME, desc(callerMethodType), ACC_PUBLIC | ACC_STATIC,\n+            clb.withMethodBody(METHOD_NAME, methodTypeDesc(callerMethodType), ACC_PUBLIC | ACC_STATIC,\n@@ -365,1 +366,1 @@\n-        cb.invokevirtual(CD_MethodHandle, \"invokeExact\", desc(leafType));\n+        cb.invokevirtual(CD_MethodHandle, \"invokeExact\", methodTypeDesc(leafType));\n@@ -469,1 +470,1 @@\n-                case SegmentBase unused          -> emitSegmentBase();\n+                case SegmentBase _               -> emitSegmentBase();\n@@ -471,1 +472,1 @@\n-                case Dup unused                  -> emitDupBinding();\n+                case Dup _                       -> emitDupBinding();\n@@ -611,1 +612,1 @@\n-            MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, desc(storeType));\n+            MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, classDesc(storeType));\n@@ -669,1 +670,1 @@\n-                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, desc(chunkStoreType));\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, classDesc(chunkStoreType));\n@@ -700,1 +701,1 @@\n-                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, desc(storeType));\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(CD_void, valueLayoutType, CD_long, classDesc(storeType));\n@@ -719,1 +720,1 @@\n-                MethodTypeDesc descriptor = MethodTypeDesc.of(desc(loadType), valueLayoutType, CD_long);\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(classDesc(loadType), valueLayoutType, CD_long);\n@@ -812,1 +813,1 @@\n-            MethodTypeDesc descriptor = MethodTypeDesc.of(desc(loadType), valueLayoutType, CD_long);\n+            MethodTypeDesc descriptor = MethodTypeDesc.of(classDesc(loadType), valueLayoutType, CD_long);\n@@ -852,1 +853,1 @@\n-                MethodTypeDesc descriptor = MethodTypeDesc.of(desc(chunkType), valueLayoutType, CD_long);\n+                MethodTypeDesc descriptor = MethodTypeDesc.of(classDesc(chunkType), valueLayoutType, CD_long);\n@@ -991,5 +992,0 @@\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private static <T> T desc(Constable c) {\n-        return (T) c.describeConstable().orElseThrow();\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -35,2 +35,4 @@\n-    \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray     format               numericClass  superClass  classDescriptor\n-    BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0], Format.unsigned( 1), 0, 0, ConstantDescs.CD_boolean),\n+    \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray     format               numericClass  superClass\n+    \/\/        basicClassDescriptor    wrapperClassDescriptor\n+    BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0], Format.unsigned( 1), 0, 0,\n+            ConstantDescs.CD_boolean, ConstantDescs.CD_Boolean),\n@@ -39,8 +41,16 @@\n-    BYTE   (     Byte.class,      \"Byte\",    byte.class,    \"byte\", 'B', new    byte[0], Format.signed(   8), BYTE_CLASS, BYTE_SUPERCLASSES, ConstantDescs.CD_byte),\n-    SHORT  (    Short.class,     \"Short\",   short.class,   \"short\", 'S', new   short[0], Format.signed(  16), SHORT_CLASS, SHORT_SUPERCLASSES, ConstantDescs.CD_short),\n-    CHAR   (Character.class, \"Character\",    char.class,    \"char\", 'C', new    char[0], Format.unsigned(16), CHAR_CLASS, CHAR_SUPERCLASSES, ConstantDescs.CD_char),\n-    INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0], Format.signed(  32), INT_CLASS, INT_SUPERCLASSES, ConstantDescs.CD_int),\n-    LONG   (     Long.class,      \"Long\",    long.class,    \"long\", 'J', new    long[0], Format.signed(  64), LONG_CLASS, LONG_SUPERCLASSES, ConstantDescs.CD_long),\n-    FLOAT  (    Float.class,     \"Float\",   float.class,   \"float\", 'F', new   float[0], Format.floating(32), FLOAT_CLASS, FLOAT_SUPERCLASSES, ConstantDescs.CD_float),\n-    DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0], Format.floating(64), DOUBLE_CLASS, DOUBLE_CLASS, ConstantDescs.CD_double),\n-    OBJECT (   Object.class,    \"Object\",  Object.class,  \"Object\", 'L', new  Object[0], Format.other(    1), 0, 0, ConstantDescs.CD_Object),\n+    BYTE   (     Byte.class,      \"Byte\",    byte.class,    \"byte\", 'B', new    byte[0], Format.signed(   8), BYTE_CLASS, BYTE_SUPERCLASSES,\n+            ConstantDescs.CD_byte, ConstantDescs.CD_Byte),\n+    SHORT  (    Short.class,     \"Short\",   short.class,   \"short\", 'S', new   short[0], Format.signed(  16), SHORT_CLASS, SHORT_SUPERCLASSES,\n+            ConstantDescs.CD_short, ConstantDescs.CD_Short),\n+    CHAR   (Character.class, \"Character\",    char.class,    \"char\", 'C', new    char[0], Format.unsigned(16), CHAR_CLASS, CHAR_SUPERCLASSES,\n+            ConstantDescs.CD_char, ConstantDescs.CD_Character),\n+    INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0], Format.signed(  32), INT_CLASS, INT_SUPERCLASSES,\n+            ConstantDescs.CD_int, ConstantDescs.CD_Integer),\n+    LONG   (     Long.class,      \"Long\",    long.class,    \"long\", 'J', new    long[0], Format.signed(  64), LONG_CLASS, LONG_SUPERCLASSES,\n+            ConstantDescs.CD_long, ConstantDescs.CD_Long),\n+    FLOAT  (    Float.class,     \"Float\",   float.class,   \"float\", 'F', new   float[0], Format.floating(32), FLOAT_CLASS, FLOAT_SUPERCLASSES,\n+            ConstantDescs.CD_float, ConstantDescs.CD_Float),\n+    DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0], Format.floating(64), DOUBLE_CLASS, DOUBLE_CLASS,\n+            ConstantDescs.CD_double, ConstantDescs.CD_Double),\n+    OBJECT (   Object.class,    \"Object\",  Object.class,  \"Object\", 'L', new  Object[0], Format.other(    1), 0, 0,\n+            ConstantDescs.CD_Object, ConstantDescs.CD_Object),\n@@ -48,1 +58,2 @@\n-    VOID   (     Void.class,      \"Void\",    void.class,    \"void\", 'V',           null, Format.other(    0), 0, 0, ConstantDescs.CD_void),\n+    VOID   (     Void.class,      \"Void\",    void.class,    \"void\", 'V',           null, Format.other(    0), 0, 0,\n+            ConstantDescs.CD_void, ConstantDescs.CD_Void),\n@@ -63,1 +74,2 @@\n-    private final ClassDesc classDesc;\n+    private final ClassDesc basicClassDesc;\n+    private final ClassDesc wrapperClassDesc;\n@@ -65,10 +77,11 @@\n-    private Wrapper(Class<?> wtype,\n-                    String wtypeName,\n-                    Class<?> ptype,\n-                    String ptypeName,\n-                    char tchar,\n-                    Object emptyArray,\n-                    int format,\n-                    int numericClass,\n-                    int superClasses,\n-                    ClassDesc classDesc) {\n+    Wrapper(Class<?> wtype,\n+            String wtypeName,\n+            Class<?> ptype,\n+            String ptypeName,\n+            char tchar,\n+            Object emptyArray,\n+            int format,\n+            int numericClass,\n+            int superClasses,\n+            ClassDesc basicClassDesc,\n+            ClassDesc wrapperClassDesc) {\n@@ -85,1 +98,2 @@\n-        this.classDesc = classDesc;\n+        this.basicClassDesc = basicClassDesc;\n+        this.wrapperClassDesc = wrapperClassDesc;\n@@ -393,1 +407,4 @@\n-    public ClassDesc classDescriptor() { return classDesc; }\n+    public ClassDesc basicClassDescriptor() { return basicClassDesc; }\n+\n+    \/** A nominal descriptor of the wrapper type *\/\n+    public ClassDesc wrapperClassDescriptor() { return wrapperClassDesc; }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":41,"deletions":24,"binary":false,"changes":65,"status":"modified"}]}