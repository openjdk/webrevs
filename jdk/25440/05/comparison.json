{"files":[{"patch":"@@ -2538,0 +2538,76 @@\n+\/\/ Returns true if the given operation can be vectorized with \"truncation\" where the upper bits in the integer do not\n+\/\/ contribute to the result. This is true for most arithmetic operations, but false for operations such as\n+\/\/ leading\/trailing zero count.\n+static bool can_subword_truncate(Node* in, const Type* type) {\n+  if (in->is_Load() || in->is_Store() || in->is_Convert() || in->is_Phi()) {\n+    return true;\n+  }\n+\n+  int opc = in->Opcode();\n+\n+  \/\/ For shorts and chars, check an additional set of nodes.\n+  if (type == TypeInt::SHORT || type == TypeInt::CHAR) {\n+    switch (opc) {\n+    case Op_ExtractS:\n+    case Op_ExtractC:\n+    case Op_ReverseBytesS:\n+    case Op_ReverseBytesUS:\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Can be truncated:\n+  switch (opc) {\n+  case Op_AddI:\n+  case Op_SubI:\n+  case Op_MulI:\n+  case Op_AndI:\n+  case Op_OrI:\n+  case Op_XorI:\n+    return true;\n+  }\n+\n+#ifdef ASSERT\n+  \/\/ While shifts have subword vectorized forms, they require knowing the precise type of input loads so they are\n+  \/\/ considered non-truncating.\n+  if (VectorNode::is_shift_opcode(opc)) {\n+    return false;\n+  }\n+\n+  \/\/ Cannot be truncated:\n+  switch (opc) {\n+  case Op_AbsI:\n+  case Op_DivI:\n+  case Op_MinI:\n+  case Op_MaxI:\n+  case Op_CMoveI:\n+  case Op_Conv2B:\n+  case Op_RotateRight:\n+  case Op_RotateLeft:\n+  case Op_PopCountI:\n+  case Op_ReverseBytesI:\n+  case Op_ReverseI:\n+  case Op_CountLeadingZerosI:\n+  case Op_CountTrailingZerosI:\n+  case Op_IsInfiniteF:\n+  case Op_IsInfiniteD:\n+  case Op_AddReductionVI:\n+  case Op_MulReductionVI:\n+  case Op_AndReductionV:\n+  case Op_OrReductionV:\n+  case Op_XorReductionV:\n+  case Op_MaxReductionV:\n+  case Op_MinReductionV:\n+    return false;\n+  default:\n+    \/\/ If this assert is hit, that means that we need to determine if the node can be safely truncated,\n+    \/\/ and then add it to the list of truncating nodes or the list of non-truncating ones just above.\n+    \/\/ In product, we just return false, which is always correct.\n+    assert(false, \"Unexpected node in SuperWord truncation: %s\", NodeClassNames[in->Opcode()]);\n+  }\n+#endif\n+\n+  \/\/ Default to disallowing vector truncation\n+  return false;\n+}\n+\n@@ -2592,1 +2668,1 @@\n-            if (VectorNode::is_shift_opcode(op) || op == Op_AbsI || op == Op_ReverseBytesI) {\n+            if (!can_subword_truncate(in, vt)) {\n@@ -2594,1 +2670,2 @@\n-              if (load->is_Load() &&\n+              \/\/ For certain operations such as shifts and abs(), use the size of the load if it exists\n+              if ((VectorNode::is_shift_opcode(op) || op == Op_AbsI) && load->is_Load() &&\n@@ -2601,1 +2678,1 @@\n-                \/\/ Widen type to int to avoid the creation of vector nodes. Note\n+                \/\/ Widen type to the node type to avoid the creation of vector nodes. Note\n@@ -2603,1 +2680,1 @@\n-                vt = TypeInt::INT;\n+                vt = container_type(in);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":81,"deletions":4,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.generators.*;\n+\n+\/*\n+ * @test\n+ * @bug 8350177\n+ * @summary Ensure that truncation of subword vectors produces correct results\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestSubwordTruncation\n+ *\/\n+\n+public class TestSubwordTruncation {\n+    private static final RestrictableGenerator<Integer> G = Generators.G.ints();\n+    private static final int SIZE = 10000;\n+\n+    @Setup\n+    static Object[] setupShortArray() {\n+        short[] arr = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            arr[i] = G.next().shortValue();\n+        }\n+\n+        return new Object[] { arr };\n+    }\n+\n+\n+    @Setup\n+    static Object[] setupByteArray() {\n+        byte[] arr = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            arr[i] = G.next().byteValue();\n+        }\n+\n+        return new Object[] { arr };\n+    }\n+\n+    @Setup\n+    static Object[] setupCharArray() {\n+        char[] arr = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            arr[i] = (char) G.next().shortValue();\n+        }\n+\n+        return new Object[] { arr };\n+    }\n+\n+    \/\/ Shorts\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortLeadingZeros(short[] in) {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (short) Integer.numberOfLeadingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testShortLeadingZeros\")\n+    public void checkTestShortLeadingZeros(Object[] vals) {\n+        short[] in = (short[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short val = (short) Integer.numberOfLeadingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortTrailingZeros(short[] in) {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (short) Integer.numberOfTrailingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testShortTrailingZeros\")\n+    public void checkTestShortTrailingZeros(Object[] vals) {\n+        short[] in = (short[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short val = (short) Integer.numberOfTrailingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortReverse(short[] in) {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (short) Integer.reverse(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testShortReverse\")\n+    public void checkTestShortReverse(Object[] vals) {\n+        short[] in = (short[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short val = (short) Integer.reverse(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortBitCount(short[] in) {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (short) Integer.bitCount(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testShortBitCount\")\n+    public void checkTestShortBitCount(Object[] vals) {\n+        short[] in = (short[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short val = (short) Integer.bitCount(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Chars\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupCharArray\")\n+    public Object[] testCharLeadingZeros(char[] in) {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (char) Integer.numberOfLeadingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testCharLeadingZeros\")\n+    public void checkTestCharLeadingZeros(Object[] vals) {\n+        char[] in = (char[]) vals[0];\n+        char[] res = (char[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            char val = (char) Integer.numberOfLeadingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupCharArray\")\n+    public Object[] testCharTrailingZeros(char[] in) {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (char) Integer.numberOfTrailingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testCharTrailingZeros\")\n+    public void checkTestCharTrailingZeros(Object[] vals) {\n+        char[] in = (char[]) vals[0];\n+        char[] res = (char[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            char val = (char) Integer.numberOfTrailingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupCharArray\")\n+    public Object[] testCharReverse(char[] in) {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (char) Integer.reverse(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testCharReverse\")\n+    public void checkTestCharReverse(Object[] vals) {\n+        char[] in = (char[]) vals[0];\n+        char[] res = (char[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            char val = (char) Integer.reverse(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupCharArray\")\n+    public Object[] testCharBitCount(char[] in) {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (char) Integer.bitCount(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testCharBitCount\")\n+    public void checkTestCharBitCount(Object[] vals) {\n+        char[] in = (char[]) vals[0];\n+        char[] res = (char[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            char val = (char) Integer.bitCount(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Bytes\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteLeadingZeros(byte[] in) {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (byte) Integer.numberOfLeadingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testByteLeadingZeros\")\n+    public void checkTestByteLeadingZeros(Object[] vals) {\n+        byte[] in = (byte[]) vals[0];\n+        byte[] res = (byte[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            byte val = (byte) Integer.numberOfLeadingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteTrailingZeros(byte[] in) {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (byte) Integer.numberOfTrailingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testByteTrailingZeros\")\n+    public void checkTestByteTrailingZeros(Object[] vals) {\n+        byte[] in = (byte[]) vals[0];\n+        byte[] res = (byte[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            byte val = (byte) Integer.numberOfTrailingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteReverse(byte[] in) {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (byte) Integer.reverse(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testByteReverse\")\n+    public void checkTestByteReverse(Object[] vals) {\n+        byte[] in = (byte[]) vals[0];\n+        byte[] res = (byte[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            byte val = (byte) Integer.reverse(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteBitCount(byte[] in) {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (byte) Integer.bitCount(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testByteBitCount\")\n+    public void checkTestByteBitCount(Object[] vals) {\n+        byte[] in = (byte[]) vals[0];\n+        byte[] res = (byte[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            byte val = (byte) Integer.bitCount(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSubwordTruncation.java","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"}]}