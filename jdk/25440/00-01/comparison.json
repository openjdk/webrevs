{"files":[{"patch":"@@ -2489,2 +2489,5 @@\n-static bool can_subword_truncate(Node* in) {\n-  if (in->is_Load() || in->is_Store() || in->is_Convert()) {\n+\/\/ Returns true if the given operation can be vectorized with \"truncation\" where the upper bits in the integer do not\n+\/\/ contribute to the result. This is true for most arithmetic operations, but false for operations such as\n+\/\/ leading\/trailing zero count.\n+static bool can_subword_truncate(Node* in, const Type* type) {\n+  if (in->is_Load() || in->is_Store() || in->is_Convert() || in->is_Phi()) {\n@@ -2495,2 +2498,22 @@\n-  return opc == Op_AddI || opc == Op_SubI || opc == Op_MulI || opc == Op_AndI || opc == Op_OrI || opc == Op_XorI\n-    || opc == Op_ReverseBytesS || opc == Op_ReverseBytesUS;\n+\n+  \/\/ For shorts and chars, check an additional set of nodes.\n+  if (type == TypeInt::SHORT || type == TypeInt::CHAR) {\n+    switch (opc) {\n+    case Op_ReverseBytesS:\n+    case Op_ReverseBytesUS:\n+      return true;\n+    }\n+  }\n+\n+  switch (opc) {\n+  case Op_AddI:\n+  case Op_SubI:\n+  case Op_MulI:\n+  case Op_AndI:\n+  case Op_OrI:\n+  case Op_XorI:\n+    return true;\n+  }\n+\n+  \/\/ Default to disallowing vector truncation\n+  return false;\n@@ -2553,1 +2576,1 @@\n-            if (!can_subword_truncate(in)) {\n+            if (!can_subword_truncate(in, vt)) {\n@@ -2555,1 +2578,2 @@\n-              if (VectorNode::is_shift_opcode(op) && load->is_Load() &&\n+              \/\/ For certain operations such as shifts and abs(), use the size of the load if it exists\n+              if ((VectorNode::is_shift_opcode(op) || op == Op_AbsI) && load->is_Load() &&\n@@ -2562,1 +2586,1 @@\n-                \/\/ Widen type to int to avoid the creation of vector nodes. Note\n+                \/\/ Widen type to the node type to avoid the creation of vector nodes. Note\n@@ -2564,1 +2588,1 @@\n-                vt = TypeInt::INT;\n+                vt = container_type(in);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -63,0 +63,10 @@\n+    @Setup\n+    static Object[] setupCharArray() {\n+        char[] arr = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            arr[i] = (char) G.next().shortValue();\n+        }\n+\n+        return new Object[] { arr };\n+    }\n+\n@@ -165,0 +175,102 @@\n+    \/\/ Chars\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupCharArray\")\n+    public Object[] testCharLeadingZeros(char[] in) {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (char) Integer.numberOfLeadingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testCharLeadingZeros\")\n+    public void checkTestCharLeadingZeros(Object[] vals) {\n+        char[] in = (char[]) vals[0];\n+        char[] res = (char[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            char val = (char) Integer.numberOfLeadingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupCharArray\")\n+    public Object[] testCharTrailingZeros(char[] in) {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (char) Integer.numberOfTrailingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testCharTrailingZeros\")\n+    public void checkTestCharTrailingZeros(Object[] vals) {\n+        char[] in = (char[]) vals[0];\n+        char[] res = (char[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            char val = (char) Integer.numberOfTrailingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupCharArray\")\n+    public Object[] testCharReverse(char[] in) {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (char) Integer.reverse(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testCharReverse\")\n+    public void checkTestCharReverse(Object[] vals) {\n+        char[] in = (char[]) vals[0];\n+        char[] res = (char[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            char val = (char) Integer.reverse(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupCharArray\")\n+    public Object[] testCharBitCount(char[] in) {\n+        char[] res = new char[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (char) Integer.bitCount(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testCharBitCount\")\n+    public void checkTestCharBitCount(Object[] vals) {\n+        char[] in = (char[]) vals[0];\n+        char[] res = (char[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            char val = (char) Integer.bitCount(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSubwordTruncation.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"modified"}]}