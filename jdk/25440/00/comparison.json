{"files":[{"patch":"@@ -2489,0 +2489,10 @@\n+static bool can_subword_truncate(Node* in) {\n+  if (in->is_Load() || in->is_Store() || in->is_Convert()) {\n+    return true;\n+  }\n+\n+  int opc = in->Opcode();\n+  return opc == Op_AddI || opc == Op_SubI || opc == Op_MulI || opc == Op_AndI || opc == Op_OrI || opc == Op_XorI\n+    || opc == Op_ReverseBytesS || opc == Op_ReverseBytesUS;\n+}\n+\n@@ -2543,1 +2553,1 @@\n-            if (VectorNode::is_shift_opcode(op) || op == Op_AbsI || op == Op_ReverseBytesI) {\n+            if (!can_subword_truncate(in)) {\n@@ -2545,1 +2555,1 @@\n-              if (load->is_Load() &&\n+              if (VectorNode::is_shift_opcode(op) && load->is_Load() &&\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorization;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.generators.*;\n+\n+\/*\n+ * @test\n+ * @bug 8350177\n+ * @summary Ensure that truncation of subword vectors produces correct results\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorization.TestSubwordTruncation\n+ *\/\n+\n+public class TestSubwordTruncation {\n+    private static final RestrictableGenerator<Integer> G = Generators.G.ints();\n+    private static final int SIZE = 10000;\n+\n+    @Setup\n+    static Object[] setupShortArray() {\n+        short[] arr = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            arr[i] = G.next().shortValue();\n+        }\n+\n+        return new Object[] { arr };\n+    }\n+\n+\n+    @Setup\n+    static Object[] setupByteArray() {\n+        byte[] arr = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            arr[i] = G.next().byteValue();\n+        }\n+\n+        return new Object[] { arr };\n+    }\n+\n+    \/\/ Shorts\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortLeadingZeros(short[] in) {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (short) Integer.numberOfLeadingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testShortLeadingZeros\")\n+    public void checkTestShortLeadingZeros(Object[] vals) {\n+        short[] in = (short[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short val = (short) Integer.numberOfLeadingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortTrailingZeros(short[] in) {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (short) Integer.numberOfTrailingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testShortTrailingZeros\")\n+    public void checkTestShortTrailingZeros(Object[] vals) {\n+        short[] in = (short[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short val = (short) Integer.numberOfTrailingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortReverse(short[] in) {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (short) Integer.reverse(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testShortReverse\")\n+    public void checkTestShortReverse(Object[] vals) {\n+        short[] in = (short[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short val = (short) Integer.reverse(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupShortArray\")\n+    public Object[] testShortBitCount(short[] in) {\n+        short[] res = new short[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (short) Integer.bitCount(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testShortBitCount\")\n+    public void checkTestShortBitCount(Object[] vals) {\n+        short[] in = (short[]) vals[0];\n+        short[] res = (short[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            short val = (short) Integer.bitCount(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Bytes\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteLeadingZeros(byte[] in) {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (byte) Integer.numberOfLeadingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testByteLeadingZeros\")\n+    public void checkTestByteLeadingZeros(Object[] vals) {\n+        byte[] in = (byte[]) vals[0];\n+        byte[] res = (byte[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            byte val = (byte) Integer.numberOfLeadingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteTrailingZeros(byte[] in) {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (byte) Integer.numberOfTrailingZeros(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testByteTrailingZeros\")\n+    public void checkTestByteTrailingZeros(Object[] vals) {\n+        byte[] in = (byte[]) vals[0];\n+        byte[] res = (byte[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            byte val = (byte) Integer.numberOfTrailingZeros(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteReverse(byte[] in) {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (byte) Integer.reverse(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testByteReverse\")\n+    public void checkTestByteReverse(Object[] vals) {\n+        byte[] in = (byte[]) vals[0];\n+        byte[] res = (byte[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            byte val = (byte) Integer.reverse(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.STORE_VECTOR, \"=0\" })\n+    @Arguments(setup = \"setupByteArray\")\n+    public Object[] testByteBitCount(byte[] in) {\n+        byte[] res = new byte[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+             res[i] = (byte) Integer.bitCount(in[i]);\n+        }\n+\n+        return new Object[] { in, res };\n+    }\n+\n+    @Check(test = \"testByteBitCount\")\n+    public void checkTestByteBitCount(Object[] vals) {\n+        byte[] in = (byte[]) vals[0];\n+        byte[] res = (byte[]) vals[1];\n+\n+        for (int i = 0; i < SIZE; i++) {\n+            byte val = (byte) Integer.bitCount(in[i]);\n+            if (res[i] != val) {\n+                throw new IllegalStateException(\"Expected \" + val + \" but got \" + res[i] + \" for \" + in[i]);\n+            }\n+        }\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestSubwordTruncation.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"}]}