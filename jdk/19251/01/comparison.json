{"files":[{"patch":"@@ -628,6 +628,6 @@\n-     *     <li>The offset of the access operation (computed as above) must fall inside\n-     *     the spatial bounds of the accessed memory segment, or an\n-     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n-     *     {@code O + A <= S}, where {@code O} is the accessed offset (computed as above),\n-     *     {@code A} is the size of the selected layout and {@code S} is the size of the\n-     *     accessed memory segment.<\/li>\n+     *     <li>The access operation must fall inside the spatial bounds of the accessed\n+     *     memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case\n+     *     when {@code B + A <= S}, where {@code O} is the base offset (defined above),\n+     *     {@code A} is the size of this layout and {@code S} is the size of the\n+     *     accessed memory segment. Note that the size of this layout might be <em>bigger<\/em>\n+     *     than the size of the accessed layout (e.g. when accessing a struct member).<\/li>\n@@ -756,6 +756,6 @@\n-     *     <li>The offset of the access operation (computed as above) must fall inside\n-     *     the spatial bounds of the accessed memory segment, or an\n-     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n-     *     {@code O + A <= S}, where {@code O} is the accessed offset (computed as above),\n-     *     {@code A} is the size of the selected layout and {@code S} is the size of the\n-     *     accessed memory segment.<\/li>\n+     *     <li>The access operation must fall inside the spatial bounds of the accessed\n+     *     memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case\n+     *     when {@code B + A <= S}, where {@code O} is the base offset (defined above),\n+     *     {@code A} is the size of this layout and {@code S} is the size of the\n+     *     accessed memory segment. Note that the size of this layout might be <em>bigger<\/em>\n+     *     than the size of the accessed layout (e.g. when accessing a struct member).<\/li>\n@@ -825,6 +825,6 @@\n-     *     <li>The start offset of the slicing operation (computed as above) must fall\n-     *     inside the spatial bounds of the accessed memory segment, or an\n-     *     {@link IndexOutOfBoundsException} is thrown. This is the case when\n-     *     {@code O + A <= S}, where {@code O} is the start offset of\n-     *     the slicing operation (computed as above), {@code A} is the size of the\n-     *     selected layout and {@code S} is the size of the accessed memory segment.<\/li>\n+     *     <li>The slicing operation must fall inside the spatial bounds of the accessed\n+     *     memory segment, or an {@link IndexOutOfBoundsException} is thrown. This is the case\n+     *     when {@code B + A <= S}, where {@code O} is the base offset (defined above),\n+     *     {@code A} is the size of this layout and {@code S} is the size of the\n+     *     accessed memory segment. Note that the size of this layout might be <em>bigger<\/em>\n+     *     than the size of the accessed layout (e.g. when accessing a struct member).<\/li>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.foreign.Utils;\n-\n@@ -45,3 +43,0 @@\n-    \/** access size (in bytes, computed from var handle carrier type) **\/\n-    final long length;\n-\n@@ -51,1 +46,1 @@\n-    VarHandleSegmentViewBase(VarForm form, boolean be, long length, long alignmentMask, boolean exact) {\n+    VarHandleSegmentViewBase(VarForm form, boolean be, long alignmentMask, boolean exact) {\n@@ -54,1 +49,0 @@\n-        this.length = length;\n@@ -58,4 +52,0 @@\n-    static IllegalArgumentException newIllegalArgumentExceptionForMisalignedAccess(long address) {\n-        return new IllegalArgumentException(\"Misaligned access at address: \" + Utils.toHexString(address));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleSegmentViewBase.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,0 +309,3 @@\n+     * Note: the returned var handle does not perform any size or alignment check. It is up to clients\n+     * to adapt the returned var handle and insert the appropriate checks.\n+     *\n@@ -319,1 +322,0 @@\n-        long size = Utils.byteWidthOfPrimitive(carrier);\n@@ -324,1 +326,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsBytes(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsBytes(be, alignmentMask, exact));\n@@ -326,1 +328,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsChars(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsChars(be, alignmentMask, exact));\n@@ -328,1 +330,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsShorts(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsShorts(be, alignmentMask, exact));\n@@ -330,1 +332,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsInts(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsInts(be, alignmentMask, exact));\n@@ -332,1 +334,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsFloats(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsFloats(be, alignmentMask, exact));\n@@ -334,1 +336,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsLongs(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsLongs(be, alignmentMask, exact));\n@@ -336,1 +338,1 @@\n-            return maybeAdapt(new VarHandleSegmentAsDoubles(be, size, alignmentMask, exact));\n+            return maybeAdapt(new VarHandleSegmentAsDoubles(be, alignmentMask, exact));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-    VarHandleSegmentAs$Type$s(boolean be, long length, long alignmentMask, boolean exact) {\n-        super(FORM, be, length, alignmentMask, exact);\n+    VarHandleSegmentAs$Type$s(boolean be, long alignmentMask, boolean exact) {\n+        super(FORM, be, alignmentMask, exact);\n@@ -63,1 +63,1 @@\n-                new VarHandleSegmentAs$Type$s(be, length, alignmentMask, true);\n+                new VarHandleSegmentAs$Type$s(be, alignmentMask, true);\n@@ -70,1 +70,1 @@\n-                new VarHandleSegmentAs$Type$s(be, length, alignmentMask, false);\n+                new VarHandleSegmentAs$Type$s(be, alignmentMask, false);\n@@ -100,1 +100,1 @@\n-    static AbstractMemorySegmentImpl checkAddress(Object obb, long offset, long length, boolean ro) {\n+    static AbstractMemorySegmentImpl checkReadOnly(Object obb, boolean ro) {\n@@ -102,1 +102,1 @@\n-        oo.checkAccess(offset, length, ro);\n+        oo.checkReadOnly(ro);\n@@ -111,1 +111,1 @@\n-        return offsetPlain(bb, offset, alignmentMask);\n+        return offsetPlain(bb, offset);\n@@ -115,1 +115,1 @@\n-    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset) {\n@@ -117,6 +117,1 @@\n-        long address = base + offset;\n-        long maxAlignMask = bb.maxAlignMask();\n-        if (((address | maxAlignMask) & alignmentMask) != 0) {\n-            throw VarHandleSegmentViewBase.newIllegalArgumentExceptionForMisalignedAccess(address);\n-        }\n-        return address;\n+        return base + offset;\n@@ -128,1 +123,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n@@ -132,1 +127,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base),\n@@ -139,1 +134,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask));\n+                offsetPlain(bb, base));\n@@ -143,1 +138,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base),\n@@ -152,1 +147,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -156,1 +151,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base),\n@@ -163,1 +158,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base),\n@@ -168,1 +163,1 @@\n-                offsetPlain(bb, base, handle.alignmentMask),\n+                offsetPlain(bb, base),\n@@ -178,1 +173,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n@@ -188,1 +183,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -198,1 +193,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n@@ -208,1 +203,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -218,1 +213,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, true);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n@@ -228,1 +223,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -239,1 +234,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -249,1 +244,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -260,1 +255,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -271,1 +266,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -282,1 +277,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -292,1 +287,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -302,1 +297,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -312,1 +307,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -322,1 +317,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -333,1 +328,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -344,1 +339,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -357,1 +352,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -371,1 +366,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -385,1 +380,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -413,1 +408,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -427,1 +422,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -441,1 +436,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -467,1 +462,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -481,1 +476,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -495,1 +490,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -522,1 +517,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -536,1 +531,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n@@ -550,1 +545,1 @@\n-        AbstractMemorySegmentImpl bb = checkAddress(obb, base, handle.length, false);\n+        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":47,"deletions":52,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -360,1 +360,1 @@\n-    public void checkAccess(long offset, long length, boolean readOnly) {\n+    public void checkReadOnly(boolean readOnly) {\n@@ -364,0 +364,5 @@\n+    }\n+\n+    @ForceInline\n+    public void checkAccess(long offset, long length, boolean readOnly) {\n+        checkReadOnly(readOnly);\n@@ -826,0 +831,1 @@\n+        Objects.requireNonNull(value);\n@@ -951,0 +957,1 @@\n+        Objects.requireNonNull(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    private static final MethodHandle MH_CHECK_ALIGN;\n+    private static final MethodHandle MH_CHECK_ENCL_LAYOUT;\n@@ -80,1 +80,1 @@\n-            MH_CHECK_ALIGN = lookup.findStatic(LayoutPath.class, \"checkAlign\",\n+            MH_CHECK_ENCL_LAYOUT = lookup.findStatic(LayoutPath.class, \"checkEnclosingLayout\",\n@@ -208,1 +208,1 @@\n-        VarHandle handle = valueLayout.varHandle();\n+        VarHandle handle = Utils.makeSegmentViewVarHandle(valueLayout);\n@@ -214,1 +214,1 @@\n-        if (derefAdapters.length == 0 && enclosing != null) {\n+        if (derefAdapters.length == 0) {\n@@ -217,1 +217,1 @@\n-            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ENCL_LAYOUT, 2, rootLayout());\n@@ -278,1 +278,1 @@\n-            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ALIGN, 2, rootLayout());\n+            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ENCL_LAYOUT, 2, rootLayout());\n@@ -287,2 +287,3 @@\n-    private static void checkAlign(MemorySegment segment, long offset, MemoryLayout constraint) {\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, constraint)) {\n+    private static void checkEnclosingLayout(MemorySegment segment, long offset, MemoryLayout enclosing) {\n+        ((AbstractMemorySegmentImpl)segment).checkAccess(offset, enclosing.byteSize(), true);\n+        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, enclosing)) {\n@@ -291,1 +292,1 @@\n-                    , offset, constraint.byteAlignment(), constraint, segment));\n+                    , offset, enclosing.byteAlignment(), enclosing, segment));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,0 @@\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -93,20 +91,0 @@\n-        final class VarHandleCache {\n-            private static final Map<ValueLayout, VarHandle> HANDLE_MAP = new ConcurrentHashMap<>();\n-\n-            static VarHandle put(ValueLayout layout, VarHandle handle) {\n-                VarHandle prev = HANDLE_MAP.putIfAbsent(layout, handle);\n-                return prev != null ? prev : handle;\n-            }\n-\n-            static VarHandle get(ValueLayout layout) {\n-                return HANDLE_MAP.get(layout);\n-            }\n-        }\n-        layout = layout.withoutName(); \/\/ name doesn't matter\n-        \/\/ keep the addressee layout as it's used below\n-\n-        VarHandle handle = VarHandleCache.get(layout);\n-        if (handle != null) {\n-            return handle;\n-        }\n-\n@@ -124,1 +102,1 @@\n-        handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n+        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memorySegmentViewHandle(baseCarrier,\n@@ -136,1 +114,1 @@\n-        return VarHandleCache.put(layout, handle);\n+        return handle;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":3,"deletions":25,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -191,0 +191,4 @@\n+        return varHandleInternal(elements);\n+    }\n+\n+    public VarHandle varHandleInternal(PathElement... elements) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/AbstractLayout.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.util.Map;\n@@ -43,0 +44,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -160,0 +162,3 @@\n+            final class VarHandleCache {\n+                private static final Map<ValueLayout, VarHandle> HANDLE_MAP = new ConcurrentHashMap<>();\n+            }\n@@ -162,1 +167,1 @@\n-                handle = Utils.makeSegmentViewVarHandle(self());\n+                handle = VarHandleCache.HANDLE_MAP.computeIfAbsent(self().withoutName(), _ -> varHandleInternal());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -61,3 +61,2 @@\n-            \/\/ access is unaligned, but access mode is supported\n-            assertTrue(compatible ||\n-                    (layout instanceof GroupLayout && segment.maxByteAlignment() < layout.byteAlignment()));\n+            \/\/ access is unaligned\n+            assertTrue(segment.maxByteAlignment() < layout.byteAlignment());\n","filename":"test\/jdk\/java\/foreign\/TestAccessModes.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-        MemoryLayout seq = MemoryLayout.sequenceLayout(10, layout);\n+        MemoryLayout seq = MemoryLayout.sequenceLayout(1, layout);\n","filename":"test\/jdk\/java\/foreign\/TestHeapAlignment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.invoke.VarHandle.AccessMode;\n@@ -334,0 +335,51 @@\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testVarHandleBadSegment(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                         long expectedByteOffset) throws Throwable {\n+        MemoryLayout seqLayout = MemoryLayout.sequenceLayout(10, layout);\n+        PathElement[] seqPathElements = new PathElement[pathElements.length + 1];\n+        long[] seqIndexes = new long[indexes.length + 1];\n+        System.arraycopy(pathElements, 0, seqPathElements, 1, pathElements.length);\n+        System.arraycopy(indexes, 0, seqIndexes, 1, indexes.length);\n+        seqPathElements[0] = PathElement.sequenceElement();\n+        seqIndexes[0] = 0;\n+        MethodHandle getter_handle = seqLayout.varHandle(seqPathElements)\n+                .toMethodHandle(AccessMode.GET)\n+                .asSpreader(long[].class, seqIndexes.length);\n+        MemorySegment segment = Arena.ofAuto().allocate(layout);\n+        assertThrows(IndexOutOfBoundsException.class, () -> getter_handle.invoke(segment, 0L, seqIndexes));\n+    }\n+\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testSliceHandleBadSegment(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                        long expectedByteOffset) throws Throwable {\n+        MemoryLayout seqLayout = MemoryLayout.sequenceLayout(10, layout);\n+        PathElement[] seqPathElements = new PathElement[pathElements.length + 1];\n+        long[] seqIndexes = new long[indexes.length + 1];\n+        System.arraycopy(pathElements, 0, seqPathElements, 1, pathElements.length);\n+        System.arraycopy(indexes, 0, seqIndexes, 1, indexes.length);\n+        seqPathElements[0] = PathElement.sequenceElement();\n+        seqIndexes[0] = 0;\n+        MethodHandle getter_handle = seqLayout.sliceHandle(seqPathElements)\n+                .asSpreader(long[].class, seqIndexes.length);\n+        MemorySegment segment = Arena.ofAuto().allocate(layout);\n+        assertThrows(IndexOutOfBoundsException.class, () -> getter_handle.invoke(segment, 0L, seqIndexes));\n+    }\n+\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testArrayElementVarHandleBadSegment(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                          long expectedByteOffset) throws Throwable {\n+        MemoryLayout seqLayout = MemoryLayout.sequenceLayout(10, layout);\n+        PathElement[] seqPathElements = new PathElement[pathElements.length + 1];\n+        long[] seqIndexes = new long[indexes.length + 2];\n+        System.arraycopy(pathElements, 0, seqPathElements, 1, pathElements.length);\n+        System.arraycopy(indexes, 0, seqIndexes, 2, indexes.length);\n+        seqPathElements[0] = PathElement.sequenceElement();\n+        seqIndexes[0] = 0;\n+        seqIndexes[1] = 0;\n+        MethodHandle getter_handle = seqLayout.arrayElementVarHandle(seqPathElements)\n+                .toMethodHandle(AccessMode.GET)\n+                .asSpreader(long[].class, seqIndexes.length);\n+        MemorySegment segment = Arena.ofAuto().allocate(layout);\n+        assertThrows(IndexOutOfBoundsException.class, () -> getter_handle.invoke(segment, 0L, seqIndexes));\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"}]}