{"files":[{"patch":"@@ -31,1 +31,4 @@\n- * @run driver compiler.vectorization.TestFloatConversionsVectorNaN\n+ * @run driver compiler.vectorization.TestFloatConversionsVectorNaN nCOH_nAV\n+ * @run driver compiler.vectorization.TestFloatConversionsVectorNaN nCOH_yAV\n+ * @run driver compiler.vectorization.TestFloatConversionsVectorNaN yCOH_nAV\n+ * @run driver compiler.vectorization.TestFloatConversionsVectorNaN yCOH_yAV\n@@ -50,2 +53,10 @@\n-        TestFramework.runWithFlags(\"-XX:-TieredCompilation\",\n-                                   \"-XX:CompileThresholdScaling=0.3\");\n+        TestFramework framework = new TestFramework(TestFloatConversionsVectorNaN.class);\n+        framework.addFlags(\"-XX:-TieredCompilation\", \"-XX:CompileThresholdScaling=0.3\");\n+        switch (args[0]) {\n+            case \"nCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"nCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            case \"yCOH_nAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:-AlignVector\"); }\n+            case \"yCOH_yAV\" -> { framework.addFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+UseCompactObjectHeaders\", \"-XX:+AlignVector\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        };\n+        framework.start();\n@@ -56,1 +67,2 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"},\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"})\n@@ -60,0 +72,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ F_adr = base + 16 + 4*i   ->  i % 2 = 0       F_adr = base + 12 + 4*i   ->  i % 2 = 1\n+            \/\/ S_adr = base + 16 + 2*i   ->  i % 4 = 0       S_adr = base + 12 + 2*i   ->  i % 4 = 2\n+            \/\/ -> vectorize                                  -> no vectorization\n@@ -132,1 +149,2 @@\n-    @IR(counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"})\n+    @IR(counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE + \"min(max_float, max_short)\", \"> 0\"},\n+        applyIfOr = {\"UseCompactObjectHeaders\", \"false\", \"AlignVector\", \"false\"})\n@@ -136,0 +154,5 @@\n+            \/\/ With AlignVector, we need 8-byte alignment of vector loads\/stores.\n+            \/\/ UseCompactObjectHeaders=false                 UseCompactObjectHeaders=true\n+            \/\/ F_adr = base + 16 + 4*i   ->  i % 2 = 0       F_adr = base + 12 + 4*i   ->  i % 2 = 1\n+            \/\/ S_adr = base + 16 + 2*i   ->  i % 4 = 0       S_adr = base + 12 + 2*i   ->  i % 4 = 2\n+            \/\/ -> vectorize                                  -> no vectorization\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloatConversionsVectorNaN.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"}]}