{"files":[{"patch":"@@ -393,1 +393,1 @@\n-  bool interpreted_native_or_deoptimized_on_stack();\n+  bool check_valid_fast_path();\n@@ -1517,1 +1517,4 @@\n-bool FreezeBase::interpreted_native_or_deoptimized_on_stack() {\n+\/\/ There are no interpreted frames if we're not called from the interpreter and we haven't ancountered an i2c\n+\/\/ adapter or called Deoptimization::unpack_frames. As for native frames, upcalls from JNI also go through the\n+\/\/ interpreter (see JavaCalls::call_helper), while the UpcallLinker explicitly sets cont_fastpath.\n+bool FreezeBase::check_valid_fast_path() {\n@@ -1525,2 +1528,2 @@\n-    if (f.is_interpreted_frame() || f.is_native_frame() || f.is_deoptimized_frame()) {\n-      return true;\n+    if (!f.is_compiled_frame() || f.is_deoptimized_frame()) {\n+      return false;\n@@ -1529,1 +1532,1 @@\n-  return false;\n+  return true;\n@@ -1591,5 +1594,1 @@\n-  \/\/ There are no interpreted frames if we're not called from the interpreter and we haven't ancountered an i2c\n-  \/\/ adapter or called Deoptimization::unpack_frames. Calls from native frames also go through the interpreter\n-  \/\/ (see JavaCalls::call_helper).\n-  assert(!current->cont_fastpath()\n-         || (current->cont_fastpath_thread_state() && !freeze.interpreted_native_or_deoptimized_on_stack()), \"\");\n+  assert(!current->cont_fastpath() || freeze.check_valid_fast_path(), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"}]}