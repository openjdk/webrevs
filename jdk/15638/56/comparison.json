{"files":[{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang.runtime;\n+\n+\/**\n+ * A testing conversion of a value is exact if it yields a result without loss\n+ * of information or throwing an exception. Otherwise, it is inexact. Some\n+ * conversions are always exact regardless of the value. These conversions are\n+ * said to be unconditionally exact.\n+ * <p>\n+ * For example, a conversion from {@code int} to {@code byte} for the value 10\n+ * is exact because the result, 10, is the same as the original value. In\n+ * contrast, if the {@code int} variable {@code i} stores the value 1000 then a\n+ * narrowing primitive conversion to {@code byte} will yield the result -24.\n+ * Loss of information has occurred: both the magnitude and the sign of the\n+ * result are different than those of the original value. As such, a conversion\n+ * from {@code int} to {@code byte} for the value 1000 is inexact. Finally a\n+ * widening primitive conversion from {@code byte} to {@code int} is\n+ * unconditionally exact because it will always succeed with no loss of\n+ * information about the magnitude of the numeric value.\n+ * <p>\n+ * The methods in this class provide the run-time support for the exactness\n+ * checks of testing conversions from a primitive type to primitive type. These\n+ * methods may be used, for example, by Java compiler implementations to\n+ * implement checks for {@code instanceof} and pattern matching runtime\n+ * implementations. Unconditionally exact testing conversions do not require a\n+ * corresponding action at run time and, for this reason, methods corresponding\n+ * to these exactness checks are omitted here.\n+ * <p>\n+ * The run time conversion checks examine whether loss of information would\n+ * occur if a testing conversion would be to be applied. In those cases where a\n+ * floating-point primitive type is involved, and the value of the testing\n+ * conversion is either signed zero, signed infinity or {@code NaN}, these\n+ * methods comply with the following:\n+ *\n+ * <ul>\n+ * <li>Converting a floating-point negative zero to an integer type is considered\n+ *   inexact.<\/li>\n+ * <li>Converting a floating-point {@code NaN} or infinity to an integer type is\n+ *   considered inexact.<\/li>\n+ * <li>Converting a floating-point {@code NaN} or infinity or signed zero to another\n+ *   floating-point type is considered exact.<\/li>\n+ * <\/ul>\n+ *\n+ * @jls 5.7.1 Exact Testing Conversions\n+ * @jls 5.7.2 Unconditionally Exact Testing Conversions\n+ * @jls 15.20.2 The instanceof Operator\n+ *\n+ * @implNote Some exactness checks describe a test which can be redirected\n+ * safely through one of the existing methods. Those are omitted too (i.e.,\n+ * {@code byte} to {@code char} can be redirected  to\n+ * {@link ExactConversionsSupport#isIntToCharExact(int)}, {@code short} to\n+ * {@code byte} can be redirected to\n+ * {@link ExactConversionsSupport#isIntToByteExact(int)} and similarly for\n+ * {@code short} to {@code char}, {@code char} to {@code byte} and {@code char}\n+ * to {@code short} to the corresponding methods that take an {@code int}).\n+ *\n+ * @since 23\n+ *\/\n+public final class ExactConversionsSupport {\n+\n+    private ExactConversionsSupport() { }\n+\n+    \/**\n+     * Exactness method from int to byte\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isIntToByteExact(int n)      {return n == (int)(byte)n;}\n+\n+    \/**\n+     * Exactness method from int to short\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isIntToShortExact(int n)     {return n == (int)(short)n;}\n+\n+    \/**\n+     * Exactness method from int to char\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isIntToCharExact(int n)      {return n == (int)(char)n;}\n+\n+    \/**\n+     * Exactness method from int to float\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isIntToFloatExact(int n) {\n+        return n == (int)(float)n && n != Integer.MAX_VALUE;\n+    }\n+    \/**\n+     * Exactness method from long to byte\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isLongToByteExact(long n)    {return n == (long)(byte)n;}\n+\n+    \/**\n+     * Exactness method from long to short\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isLongToShortExact(long n)   {return n == (long)(short)n;}\n+\n+    \/**\n+     * Exactness method from long to char\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isLongToCharExact(long n)    {return n == (long)(char)n;}\n+\n+    \/**\n+     * Exactness method from long to int\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     *\/\n+    public static boolean isLongToIntExact(long n)     {return n == (long)(int)n;}\n+\n+    \/**\n+     * Exactness method from long to float\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isLongToFloatExact(long n) {\n+        return n == (long)(float)n && n != Long.MAX_VALUE;\n+    }\n+\n+    \/**\n+     * Exactness method from long to double\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isLongToDoubleExact(long n) {\n+        return n == (long)(double)n && n != Long.MAX_VALUE;\n+    }\n+\n+    \/**\n+     * Exactness method from float to byte\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isFloatToByteExact(float n)  {\n+        return n == (float)(byte)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from float to short\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isFloatToShortExact(float n) {\n+        return n == (float)(short)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from float to char\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isFloatToCharExact(float n)  {\n+        return n == (float)(char)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from float to int\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isFloatToIntExact(float n) {\n+        return n == (float)(int)n && n != 0x1p31f && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from float to long\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isFloatToLongExact(float n) {\n+        return n == (float)(long)n && n != 0x1p63f && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to byte\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToByteExact(double n) {\n+        return n == (double)(byte)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to short\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToShortExact(double n){\n+        return n == (double)(short)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to char\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToCharExact(double n) {\n+        return n == (double)(char)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to int\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToIntExact(double n)  {\n+        return n == (double)(int)n && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to long\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToLongExact(double n) {\n+        return n == (double)(long)n && n != 0x1p63 && !isNegativeZero(n);\n+    }\n+\n+    \/**\n+     * Exactness method from double to float\n+     * @param n value\n+     * @return true if and only if the passed value can be converted exactly to the target type\n+     * @implSpec relies on the notion of representation equivalence defined in the\n+     * specification of the {@linkplain Double} class.\n+     *\/\n+    public static boolean isDoubleToFloatExact(double n) {\n+        return n == (double)(float)n || n != n;\n+    }\n+\n+    private static boolean isNegativeZero(float n) {\n+        return Float.floatToRawIntBits(n) == Integer.MIN_VALUE;\n+    }\n+\n+    private static boolean isNegativeZero(double n) {\n+        return Double.doubleToRawLongBits(n) == Long.MIN_VALUE;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ExactConversionsSupport.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.lang.classfile.CodeBuilder;\n@@ -30,0 +31,1 @@\n+import java.lang.constant.ConstantDesc;\n@@ -43,0 +45,1 @@\n+import java.util.function.Consumer;\n@@ -48,0 +51,1 @@\n+import jdk.internal.misc.PreviewFeatures;\n@@ -52,0 +56,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -53,0 +59,1 @@\n+import sun.invoke.util.Wrapper;\n@@ -68,0 +75,1 @@\n+    private static final boolean previewEnabled = PreviewFeatures.isEnabled();\n@@ -77,0 +85,2 @@\n+    private static final Map<TypePairs, String> typePairToName;\n+\n@@ -92,0 +102,1 @@\n+        typePairToName = TypePairs.initialize();\n@@ -137,6 +148,9 @@\n-     * @throws NullPointerException if any argument is {@code null}\n-     * @throws IllegalArgumentException if any element in the labels array is null, if the\n-     * invocation type is not not a method type of first parameter of a reference type,\n-     * second parameter of type {@code int} and with {@code int} as its return type,\n-     * or if {@code labels} contains an element that is not of type {@code String},\n-     * {@code Integer}, {@code Class} or {@code EnumDesc}.\n+     * @throws NullPointerException     if any argument is {@code null}\n+     * @throws IllegalArgumentException if any element in the labels array is null\n+     * @throws IllegalArgumentException if the invocation type is not a method type of first parameter of a reference type,\n+     *                                  second parameter of type {@code int} and with {@code int} as its return type,\n+     * @throws IllegalArgumentException if {@code labels} contains an element that is not of type {@code String},\n+     *                                  {@code Integer}, {@code Long}, {@code Float}, {@code Double}, {@code Boolean},\n+     *                                  {@code Class} or {@code EnumDesc}.\n+     * @throws IllegalArgumentException if {@code labels} contains an element that is not of type {@code Boolean}\n+     *                                  when {@code target} is a {@code Boolean.class}.\n@@ -150,0 +164,1 @@\n+        Class<?> selectorType = invocationType.parameterType(0);\n@@ -152,1 +167,0 @@\n-            || invocationType.parameterType(0).isPrimitive()\n@@ -157,2 +171,1 @@\n-        labels = labels.clone();\n-        Stream.of(labels).forEach(SwitchBootstraps::verifyLabel);\n+        Stream.of(labels).forEach(l -> verifyLabel(l, selectorType));\n@@ -160,1 +173,1 @@\n-        MethodHandle target = generateInnerClass(lookup, labels);\n+        MethodHandle target = generateTypeSwitch(lookup, selectorType, labels);\n@@ -167,1 +180,1 @@\n-    private static void verifyLabel(Object label) {\n+    private static void verifyLabel(Object label, Class<?> selectorType) {\n@@ -172,0 +185,1 @@\n+\n@@ -175,0 +189,8 @@\n+\n+            ((labelClass != Float.class &&\n+              labelClass != Long.class &&\n+              labelClass != Double.class &&\n+              labelClass != Boolean.class) ||\n+              ((selectorType.equals(boolean.class) || selectorType.equals(Boolean.class)) && labelClass != Boolean.class && labelClass != Class.class) ||\n+             !previewEnabled) &&\n+\n@@ -269,1 +291,1 @@\n-                                                                            generateInnerClass(lookup, labels),\n+                                                                            generateTypeSwitch(lookup, invocationType.parameterType(0), labels),\n@@ -273,1 +295,1 @@\n-            target = generateInnerClass(lookup, labels);\n+            target = generateTypeSwitch(lookup, invocationType.parameterType(0), labels);\n@@ -384,55 +406,66 @@\n-    @SuppressWarnings(\"removal\")\n-    private static MethodHandle generateInnerClass(MethodHandles.Lookup caller, Object[] labels) {\n-        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n-        List<Class<?>> extraClassLabels = new ArrayList<>();\n-\n-        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n-            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n-               .withMethodBody(\"typeSwitch\",\n-                               TYPES_SWITCH_DESCRIPTOR,\n-                               ClassFile.ACC_FINAL | ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n-                               cb -> {\n-                    cb.aload(0);\n-                    Label nonNullLabel = cb.newLabel();\n-                    cb.if_nonnull(nonNullLabel);\n-                    cb.iconst_m1();\n-                    cb.ireturn();\n-                    cb.labelBinding(nonNullLabel);\n-                    if (labels.length == 0) {\n-                        cb.constantInstruction(0)\n-                          .ireturn();\n-                        return ;\n-                    }\n-                    cb.iload(1);\n-                    Label dflt = cb.newLabel();\n-                    record Element(Label target, Label next, Object caseLabel) {}\n-                    List<Element> cases = new ArrayList<>();\n-                    List<SwitchCase> switchCases = new ArrayList<>();\n-                    Object lastLabel = null;\n-                    for (int idx = labels.length - 1; idx >= 0; idx--) {\n-                        Object currentLabel = labels[idx];\n-                        Label target = cb.newLabel();\n-                        Label next;\n-                        if (lastLabel == null) {\n-                            next = dflt;\n-                        } else if (lastLabel.equals(currentLabel)) {\n-                            next = cases.getLast().next();\n-                        } else {\n-                            next = cases.getLast().target();\n-                        }\n-                        lastLabel = currentLabel;\n-                        cases.add(new Element(target, next, currentLabel));\n-                        switchCases.add(SwitchCase.of(idx, target));\n-                    }\n-                    cases = cases.reversed();\n-                    switchCases = switchCases.reversed();\n-                    cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n-                    for (int idx = 0; idx < cases.size(); idx++) {\n-                        Element element = cases.get(idx);\n-                        Label next = element.next();\n-                        cb.labelBinding(element.target());\n-                        if (element.caseLabel() instanceof Class<?> classLabel) {\n-                            Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n-                            if (classLabelConstableOpt.isPresent()) {\n-                                cb.aload(0);\n-                                cb.instanceof_(classLabelConstableOpt.orElseThrow());\n+    private static Consumer<CodeBuilder> generateTypeSwitchSkeleton(Class<?> selectorType, Object[] labelConstants, List<EnumDesc<?>> enumDescs, List<Class<?>> extraClassLabels) {\n+        int SELECTOR_OBJ        = 0;\n+        int RESTART_IDX         = 1;\n+        int ENUM_CACHE          = 2;\n+        int EXTRA_CLASS_LABELS  = 3;\n+\n+        return cb -> {\n+            cb.aload(SELECTOR_OBJ);\n+            Label nonNullLabel = cb.newLabel();\n+            cb.if_nonnull(nonNullLabel);\n+            cb.iconst_m1();\n+            cb.ireturn();\n+            cb.labelBinding(nonNullLabel);\n+            if (labelConstants.length == 0) {\n+                cb.constantInstruction(0)\n+                        .ireturn();\n+                return;\n+            }\n+            cb.iload(RESTART_IDX);\n+            Label dflt = cb.newLabel();\n+            record Element(Label target, Label next, Object caseLabel) { }\n+            List<Element> cases = new ArrayList<>();\n+            List<SwitchCase> switchCases = new ArrayList<>();\n+            Object lastLabel = null;\n+            for (int idx = labelConstants.length - 1; idx >= 0; idx--) {\n+                Object currentLabel = labelConstants[idx];\n+                Label target = cb.newLabel();\n+                Label next;\n+                if (lastLabel == null) {\n+                    next = dflt;\n+                } else if (lastLabel.equals(currentLabel)) {\n+                    next = cases.getLast().next();\n+                } else {\n+                    next = cases.getLast().target();\n+                }\n+                lastLabel = currentLabel;\n+                cases.add(new Element(target, next, currentLabel));\n+                switchCases.add(SwitchCase.of(idx, target));\n+            }\n+            cases = cases.reversed();\n+            switchCases = switchCases.reversed();\n+            cb.tableswitch(0, labelConstants.length - 1, dflt, switchCases);\n+            for (int idx = 0; idx < cases.size(); idx++) {\n+                Element element = cases.get(idx);\n+                Label next = element.next();\n+                cb.labelBinding(element.target());\n+                if (element.caseLabel() instanceof Class<?> classLabel) {\n+                    if (unconditionalExactnessCheck(selectorType, classLabel)) {\n+                        \/\/nothing - unconditionally use this case\n+                    } else if (classLabel.isPrimitive()) {\n+                        if (!selectorType.isPrimitive() && !Wrapper.isWrapperNumericOrBooleanType(selectorType)) {\n+                            \/\/ Object o = ...\n+                            \/\/ o instanceof Wrapped(float)\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(Wrapper.forBasicType(classLabel)\n+                                    .wrapperType()\n+                                    .describeConstable()\n+                                    .orElseThrow());\n+                            cb.ifeq(next);\n+                        } else if (!unconditionalExactnessCheck(Wrapper.asPrimitiveType(selectorType), classLabel)) {\n+                            \/\/ Integer i = ... or int i = ...\n+                            \/\/ o instanceof float\n+                            Label notNumber = cb.newLabel();\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(ConstantDescs.CD_Number);\n+                            if (selectorType == long.class || selectorType == float.class || selectorType == double.class) {\n@@ -441,12 +474,25 @@\n-                                cb.aload(3);\n-                                cb.constantInstruction(extraClassLabels.size());\n-                                cb.invokeinterface(ConstantDescs.CD_List,\n-                                                   \"get\",\n-                                                   MethodTypeDesc.of(ConstantDescs.CD_Object,\n-                                                                     ConstantDescs.CD_int));\n-                                cb.checkcast(ConstantDescs.CD_Class);\n-                                cb.aload(0);\n-                                cb.invokevirtual(ConstantDescs.CD_Class,\n-                                                 \"isInstance\",\n-                                                 MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                                   ConstantDescs.CD_Object));\n+                                cb.ifeq(notNumber);\n+                            }\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.checkcast(ConstantDescs.CD_Number);\n+                            if (selectorType == long.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"longValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_long));\n+                            } else if (selectorType == float.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"floatValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_float));\n+                            } else if (selectorType == double.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"doubleValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_double));\n+                            } else {\n+                                Label compare = cb.newLabel();\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"intValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_int));\n+                                cb.goto_(compare);\n+                                cb.labelBinding(notNumber);\n+                                cb.aload(SELECTOR_OBJ);\n+                                cb.instanceof_(ConstantDescs.CD_Character);\n@@ -454,1 +500,6 @@\n-                                extraClassLabels.add(classLabel);\n+                                cb.aload(SELECTOR_OBJ);\n+                                cb.checkcast(ConstantDescs.CD_Character);\n+                                cb.invokevirtual(ConstantDescs.CD_Character,\n+                                        \"charValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_char));\n+                                cb.labelBinding(compare);\n@@ -456,23 +507,6 @@\n-                        } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n-                            int enumIdx = enumDescs.size();\n-                            enumDescs.add(enumLabel);\n-                            cb.aload(2);\n-                            cb.constantInstruction(enumIdx);\n-                            cb.invokestatic(ConstantDescs.CD_Integer,\n-                                            \"valueOf\",\n-                                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n-                                                              ConstantDescs.CD_int));\n-                            cb.aload(0);\n-                            cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n-                                               \"test\",\n-                                               MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                                 ConstantDescs.CD_Object,\n-                                                                 ConstantDescs.CD_Object));\n-                            cb.ifeq(next);\n-                        } else if (element.caseLabel() instanceof String stringLabel) {\n-                            cb.ldc(stringLabel);\n-                            cb.aload(0);\n-                            cb.invokevirtual(ConstantDescs.CD_Object,\n-                                             \"equals\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                               ConstantDescs.CD_Object));\n+\n+                            TypePairs typePair = TypePairs.of(Wrapper.asPrimitiveType(selectorType), classLabel);\n+                            String methodName = typePairToName.get(typePair);\n+                            cb.invokestatic(ExactConversionsSupport.class.describeConstable().orElseThrow(),\n+                                    methodName,\n+                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, typePair.from.describeConstable().orElseThrow()));\n@@ -480,15 +514,6 @@\n-                        } else if (element.caseLabel() instanceof Integer integerLabel) {\n-                            Label compare = cb.newLabel();\n-                            Label notNumber = cb.newLabel();\n-                            cb.aload(0);\n-                            cb.instanceof_(ConstantDescs.CD_Number);\n-                            cb.ifeq(notNumber);\n-                            cb.aload(0);\n-                            cb.checkcast(ConstantDescs.CD_Number);\n-                            cb.invokevirtual(ConstantDescs.CD_Number,\n-                                             \"intValue\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_int));\n-                            cb.goto_(compare);\n-                            cb.labelBinding(notNumber);\n-                            cb.aload(0);\n-                            cb.instanceof_(ConstantDescs.CD_Character);\n+                        }\n+                    } else {\n+                        Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n+                        if (classLabelConstableOpt.isPresent()) {\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(classLabelConstableOpt.orElseThrow());\n@@ -496,8 +521,0 @@\n-                            cb.aload(0);\n-                            cb.checkcast(ConstantDescs.CD_Character);\n-                            cb.invokevirtual(ConstantDescs.CD_Character,\n-                                             \"charValue\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_char));\n-                            cb.labelBinding(compare);\n-                            cb.ldc(integerLabel);\n-                            cb.if_icmpne(next);\n@@ -505,2 +522,14 @@\n-                            throw new InternalError(\"Unsupported label type: \" +\n-                                                    element.caseLabel().getClass());\n+                            cb.aload(EXTRA_CLASS_LABELS);\n+                            cb.constantInstruction(extraClassLabels.size());\n+                            cb.invokeinterface(ConstantDescs.CD_List,\n+                                    \"get\",\n+                                    MethodTypeDesc.of(ConstantDescs.CD_Object,\n+                                            ConstantDescs.CD_int));\n+                            cb.checkcast(ConstantDescs.CD_Class);\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.invokevirtual(ConstantDescs.CD_Class,\n+                                    \"isInstance\",\n+                                    MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                            ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                            extraClassLabels.add(classLabel);\n@@ -508,2 +537,0 @@\n-                        cb.constantInstruction(idx);\n-                        cb.ireturn();\n@@ -511,4 +538,95 @@\n-                    cb.labelBinding(dflt);\n-                    cb.constantInstruction(cases.size());\n-                    cb.ireturn();\n-                });\n+                } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                    int enumIdx = enumDescs.size();\n+                    enumDescs.add(enumLabel);\n+                    cb.aload(ENUM_CACHE);\n+                    cb.constantInstruction(enumIdx);\n+                    cb.invokestatic(ConstantDescs.CD_Integer,\n+                            \"valueOf\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n+                                    ConstantDescs.CD_int));\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n+                            \"test\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else if (element.caseLabel() instanceof String stringLabel) {\n+                    cb.ldc(stringLabel);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                            \"equals\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                    Label compare = cb.newLabel();\n+                    Label notNumber = cb.newLabel();\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.instanceof_(ConstantDescs.CD_Number);\n+                    cb.ifeq(notNumber);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.checkcast(ConstantDescs.CD_Number);\n+                    cb.invokevirtual(ConstantDescs.CD_Number,\n+                            \"intValue\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_int));\n+                    cb.goto_(compare);\n+                    cb.labelBinding(notNumber);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.instanceof_(ConstantDescs.CD_Character);\n+                    cb.ifeq(next);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.checkcast(ConstantDescs.CD_Character);\n+                    cb.invokevirtual(ConstantDescs.CD_Character,\n+                            \"charValue\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_char));\n+                    cb.labelBinding(compare);\n+\n+                    cb.ldc(integerLabel);\n+                    cb.if_icmpne(next);\n+                } else if ((element.caseLabel() instanceof Long ||\n+                        element.caseLabel() instanceof Float ||\n+                        element.caseLabel() instanceof Double ||\n+                        element.caseLabel() instanceof Boolean)) {\n+                    if (element.caseLabel() instanceof Boolean c) {\n+                        cb.constantInstruction(c ? 1 : 0);\n+                    } else {\n+                        cb.constantInstruction((ConstantDesc) element.caseLabel());\n+                    }\n+                    cb.invokestatic(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                            \"valueOf\",\n+                            MethodTypeDesc.of(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                                    Wrapper.asPrimitiveType(element.caseLabel().getClass()).describeConstable().orElseThrow()));\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                            \"equals\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else {\n+                    throw new InternalError(\"Unsupported label type: \" +\n+                            element.caseLabel().getClass());\n+                }\n+                cb.constantInstruction(idx);\n+                cb.ireturn();\n+            }\n+            cb.labelBinding(dflt);\n+            cb.constantInstruction(cases.size());\n+            cb.ireturn();\n+        };\n+    }\n+\n+    \/*\n+     * Construct the method handle that represents the method int typeSwitch(Object, int, BiPredicate, List)\n+     *\/\n+    private static MethodHandle generateTypeSwitch(MethodHandles.Lookup caller, Class<?> selectorType, Object[] labelConstants) {\n+        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n+        List<Class<?>> extraClassLabels = new ArrayList<>();\n+\n+        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())),\n+                clb -> {\n+                    clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n+                       .withMethodBody(\"typeSwitch\",\n+                                       TYPES_SWITCH_DESCRIPTOR,\n+                                       ClassFile.ACC_FINAL | ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                                       generateTypeSwitchSkeleton(selectorType, labelConstants, enumDescs, extraClassLabels));\n@@ -528,2 +646,7 @@\n-            return MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n-                                                                List.copyOf(extraClassLabels));\n+            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n+                                                       List.copyOf(extraClassLabels));\n+            typeSwitch = MethodHandles.explicitCastArguments(typeSwitch,\n+                                                             MethodType.methodType(int.class,\n+                                                                                   selectorType,\n+                                                                                   int.class));\n+            return typeSwitch;\n@@ -544,0 +667,57 @@\n+\n+    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.checkUnconditionallyExactPrimitives\n+    private static boolean unconditionalExactnessCheck(Class<?> selectorType, Class<?> targetType) {\n+        Wrapper selectorWrapper = Wrapper.forBasicType(selectorType);\n+        Wrapper targetWrapper   = Wrapper.forBasicType(targetType);\n+        if (selectorType.isPrimitive() && targetType.equals(selectorWrapper.wrapperType())) {\n+            return true;\n+        }\n+        else if (selectorType.equals(targetType) ||\n+                ((selectorType.equals(byte.class) && !targetType.equals(char.class)) ||\n+                 (selectorType.equals(short.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))) ||\n+                 (selectorType.equals(char.class)  && (selectorWrapper.isStrictSubRangeOf(targetWrapper)))  ||\n+                 (selectorType.equals(int.class)   && (targetType.equals(double.class) || targetType.equals(long.class))) ||\n+                 (selectorType.equals(float.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))))) return true;\n+        return false;\n+    }\n+\n+    \/\/ TypePairs should be in sync with the corresponding record in Lower\n+    record TypePairs(Class<?> from, Class<?> to) {\n+        public static TypePairs of(Class<?> from,  Class<?> to) {\n+            if (from == byte.class || from == short.class || from == char.class) {\n+                from = int.class;\n+            }\n+            return new TypePairs(from, to);\n+        }\n+\n+        public static Map<TypePairs, String> initialize() {\n+            Map<TypePairs, String> typePairToName = new HashMap<>();\n+            typePairToName.put(new TypePairs(byte.class,   char.class),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  byte.class),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(short.class,  char.class),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   byte.class),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(char.class,   short.class),  \"isIntToShortExact\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(int.class,    byte.class),   \"isIntToByteExact\");\n+            typePairToName.put(new TypePairs(int.class,    short.class),  \"isIntToShortExact\");\n+            typePairToName.put(new TypePairs(int.class,    char.class),   \"isIntToCharExact\");\n+            typePairToName.put(new TypePairs(int.class,    float.class),  \"isIntToFloatExact\");\n+            typePairToName.put(new TypePairs(long.class,   byte.class),   \"isLongToByteExact\");\n+            typePairToName.put(new TypePairs(long.class,   short.class),  \"isLongToShortExact\");\n+            typePairToName.put(new TypePairs(long.class,   char.class),   \"isLongToCharExact\");\n+            typePairToName.put(new TypePairs(long.class,   int.class),    \"isLongToIntExact\");\n+            typePairToName.put(new TypePairs(long.class,   float.class),  \"isLongToFloatExact\");\n+            typePairToName.put(new TypePairs(long.class,   double.class), \"isLongToDoubleExact\");\n+            typePairToName.put(new TypePairs(float.class,  byte.class),   \"isFloatToByteExact\");\n+            typePairToName.put(new TypePairs(float.class,  short.class),  \"isFloatToShortExact\");\n+            typePairToName.put(new TypePairs(float.class,  char.class),   \"isFloatToCharExact\");\n+            typePairToName.put(new TypePairs(float.class,  int.class),    \"isFloatToIntExact\");\n+            typePairToName.put(new TypePairs(float.class,  long.class),   \"isFloatToLongExact\");\n+            typePairToName.put(new TypePairs(double.class, byte.class),   \"isDoubleToByteExact\");\n+            typePairToName.put(new TypePairs(double.class, short.class),  \"isDoubleToShortExact\");\n+            typePairToName.put(new TypePairs(double.class, char.class),   \"isDoubleToCharExact\");\n+            typePairToName.put(new TypePairs(double.class, int.class),    \"isDoubleToIntExact\");\n+            typePairToName.put(new TypePairs(double.class, long.class),   \"isDoubleToLongExact\");\n+            typePairToName.put(new TypePairs(double.class, float.class),  \"isDoubleToFloatExact\");\n+            return typePairToName;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":318,"deletions":138,"binary":false,"changes":456,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Map;\n+import static sun.invoke.util.Wrapper.NumericClasses.*;\n@@ -31,2 +33,2 @@\n-    \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray     format\n-    BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0], Format.unsigned( 1)),\n+    \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray     format               numericClass  superClass\n+    BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0], Format.unsigned( 1), 0, 0),\n@@ -35,8 +37,8 @@\n-    BYTE   (     Byte.class,      \"Byte\",    byte.class,    \"byte\", 'B', new    byte[0], Format.signed(   8)),\n-    SHORT  (    Short.class,     \"Short\",   short.class,   \"short\", 'S', new   short[0], Format.signed(  16)),\n-    CHAR   (Character.class, \"Character\",    char.class,    \"char\", 'C', new    char[0], Format.unsigned(16)),\n-    INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0], Format.signed(  32)),\n-    LONG   (     Long.class,      \"Long\",    long.class,    \"long\", 'J', new    long[0], Format.signed(  64)),\n-    FLOAT  (    Float.class,     \"Float\",   float.class,   \"float\", 'F', new   float[0], Format.floating(32)),\n-    DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0], Format.floating(64)),\n-    OBJECT (   Object.class,    \"Object\",  Object.class,  \"Object\", 'L', new  Object[0], Format.other(    1)),\n+    BYTE   (     Byte.class,      \"Byte\",    byte.class,    \"byte\", 'B', new    byte[0], Format.signed(   8), BYTE_CLASS, BYTE_SUPERCLASSES),\n+    SHORT  (    Short.class,     \"Short\",   short.class,   \"short\", 'S', new   short[0], Format.signed(  16), SHORT_CLASS, SHORT_SUPERCLASSES),\n+    CHAR   (Character.class, \"Character\",    char.class,    \"char\", 'C', new    char[0], Format.unsigned(16), CHAR_CLASS, CHAR_SUPERCLASSES),\n+    INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0], Format.signed(  32), INT_CLASS, INT_SUPERCLASSES),\n+    LONG   (     Long.class,      \"Long\",    long.class,    \"long\", 'J', new    long[0], Format.signed(  64), LONG_CLASS, LONG_SUPERCLASSES),\n+    FLOAT  (    Float.class,     \"Float\",   float.class,   \"float\", 'F', new   float[0], Format.floating(32), FLOAT_CLASS, FLOAT_SUPERCLASSES),\n+    DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0], Format.floating(64), DOUBLE_CLASS, DOUBLE_CLASS),\n+    OBJECT (   Object.class,    \"Object\",  Object.class,  \"Object\", 'L', new  Object[0], Format.other(    1), 0, 0),\n@@ -44,1 +46,1 @@\n-    VOID   (     Void.class,      \"Void\",    void.class,    \"void\", 'V',           null, Format.other(    0)),\n+    VOID   (     Void.class,      \"Void\",    void.class,    \"void\", 'V',           null, Format.other(    0), 0, 0),\n@@ -55,0 +57,2 @@\n+    private final int      numericClass;\n+    private final int      superClasses;\n@@ -58,1 +62,1 @@\n-    private Wrapper(Class<?> wtype, String wtypeName, Class<?> ptype, String ptypeName, char tchar, Object emptyArray, int format) {\n+    private Wrapper(Class<?> wtype, String wtypeName, Class<?> ptype, String ptypeName, char tchar, Object emptyArray, int format, int numericClass, int superClasses) {\n@@ -65,0 +69,2 @@\n+        this.numericClass = numericClass;\n+        this.superClasses = superClasses;\n@@ -427,0 +433,5 @@\n+    \/** Query:  Is the given type a wrapper, such as {@code Integer}, {@code Byte}, etc excluding {@code Void} and {@code Object}? *\/\n+    public static boolean isWrapperNumericOrBooleanType(Class<?> type) {\n+        return isWrapperType(type) && findWrapperType(type) != VOID && findWrapperType(type) != OBJECT;\n+    }\n+\n@@ -631,0 +642,30 @@\n+\n+    \/\/ NumericClasses should be in sync with com.sun.tools.javac.code.TypeTag.NumericClasses\n+    public static class NumericClasses {\n+        public static final int BYTE_CLASS = 1;\n+        public static final int CHAR_CLASS = 2;\n+        public static final int SHORT_CLASS = 4;\n+        public static final int INT_CLASS = 8;\n+        public static final int LONG_CLASS = 16;\n+        public static final int FLOAT_CLASS = 32;\n+        public static final int DOUBLE_CLASS = 64;\n+\n+        static final int BYTE_SUPERCLASSES = BYTE_CLASS | SHORT_CLASS | INT_CLASS |\n+                LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int CHAR_SUPERCLASSES = CHAR_CLASS | INT_CLASS |\n+                LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int SHORT_SUPERCLASSES = SHORT_CLASS | INT_CLASS |\n+                LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int INT_SUPERCLASSES = INT_CLASS | LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int LONG_SUPERCLASSES = LONG_CLASS | FLOAT_CLASS | DOUBLE_CLASS;\n+\n+        static final int FLOAT_SUPERCLASSES = FLOAT_CLASS | DOUBLE_CLASS;\n+    }\n+\n+    public boolean isStrictSubRangeOf(Wrapper target) {\n+        return (this.superClasses & target.numericClass) != 0 && this != target;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":53,"deletions":12,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+            case PRIMITIVE_PATTERNS -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -257,0 +257,1 @@\n+        PRIMITIVE_PATTERNS(JDK23, Fragments.FeaturePrimitivePatterns, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+    public final Type exactConversionsSupportType;\n@@ -548,0 +549,1 @@\n+        exactConversionsSupportType = enterClass(\"java.lang.runtime.ExactConversionsSupport\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,0 +189,4 @@\n+    public boolean isInSuperClassesOf(TypeTag tag) {\n+        return (this.numericClass & tag.superClasses) != 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeTag.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5027,0 +5027,46 @@\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n+    \/** Check unconditionality between any combination of reference or primitive types.\n+     *\n+     *  Rules:\n+     *    an identity conversion\n+     *    a widening reference conversion\n+     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n+     *    a boxing conversion\n+     *    a boxing conversion followed by a widening reference conversion\n+     *\n+     *  @param source     Source primitive or reference type\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean isUnconditionallyExact(Type source, Type target) {\n+        if (isSameType(source, target)) {\n+            return true;\n+        }\n+\n+        return target.isPrimitive()\n+                ? isUnconditionallyExactPrimitives(source, target)\n+                : isSubtype(boxedTypeOrType(erasure(source)), target);\n+    }\n+\n+    \/** Check unconditionality between primitive types.\n+     *\n+     *  - widening from one integral type to another,\n+     *  - widening from one floating point type to another,\n+     *  - widening from byte, short, or char to a floating point type,\n+     *  - widening from int to double.\n+     *\n+     *  @param selectorType     Type of selector\n+     *  @param targetType       Target type\n+     *\/\n+    public boolean isUnconditionallyExactPrimitives(Type selectorType, Type targetType) {\n+        if (isSameType(selectorType, targetType)) {\n+            return true;\n+        }\n+\n+        return (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n+                ((selectorType.hasTag(BYTE) && !targetType.hasTag(CHAR)) ||\n+                 (selectorType.hasTag(SHORT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))) ||\n+                 (selectorType.hasTag(CHAR)  && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag())))  ||\n+                 (selectorType.hasTag(INT)   && (targetType.hasTag(DOUBLE) || targetType.hasTag(LONG))) ||\n+                 (selectorType.hasTag(FLOAT) && (selectorType.getTag().isStrictSubRangeOf(targetType.getTag()))));\n+    }\n+    \/\/ <\/editor-fold>\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1685,0 +1685,1 @@\n+            boolean booleanSwitch = types.isSameType(types.unboxedTypeOrType(seltype), syms.booleanType);\n@@ -1687,1 +1688,0 @@\n-            boolean errorPrimitiveSwitch = seltype.isPrimitive() && !intSwitch;\n@@ -1689,0 +1689,4 @@\n+            if (seltype.isPrimitive() && !intSwitch) {\n+                preview.checkSourceLevel(selector.pos(), Feature.PRIMITIVE_PATTERNS);\n+                patternSwitch = true;\n+            }\n@@ -1690,1 +1694,1 @@\n-                !intSwitch && !errorPrimitiveSwitch) {\n+                !intSwitch) {\n@@ -1694,3 +1698,0 @@\n-                if (errorPrimitiveSwitch) {\n-                    log.error(selector.pos(), Errors.SelectorTypeNotAllowed(seltype));\n-                }\n@@ -1712,0 +1713,1 @@\n+            JCCaseLabel unconditionalCaseLabel = null;\n@@ -1779,4 +1781,9 @@\n-                                } else if (!stringSwitch && !intSwitch && !errorPrimitiveSwitch) {\n-                                    log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n-                                } else if (!constants.add(pattype.constValue())) {\n-                                    log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                }\n+                                else {\n+                                    if (!stringSwitch && !intSwitch &&\n+                                            !((pattype.getTag().isInSuperClassesOf(LONG) || pattype.getTag().equals(BOOLEAN)) &&\n+                                              types.isSameType(types.unboxedTypeOrType(seltype), pattype))) {\n+                                        log.error(label.pos(), Errors.ConstantLabelNotCompatible(pattype, seltype));\n+                                    } else if (!constants.add(pattype.constValue())) {\n+                                        log.error(c.pos(), Errors.DuplicateCaseLabel);\n+                                    }\n@@ -1791,0 +1798,2 @@\n+                        }  else if (booleanSwitch && constants.containsAll(Set.of(0, 1))) {\n+                            log.error(label.pos(), Errors.DefaultAndBothBooleanValues);\n@@ -1799,1 +1808,4 @@\n-                        if (!primaryType.hasTag(TYPEVAR)) {\n+\n+                        if (primaryType.isPrimitive()) {\n+                            preview.checkSourceLevel(pat.pos(), Feature.PRIMITIVE_PATTERNS);\n+                        } else if (!primaryType.hasTag(TYPEVAR)) {\n@@ -1802,3 +1814,1 @@\n-                        if (!errorPrimitiveSwitch) {\n-                            checkCastablePattern(pat.pos(), seltype, primaryType);\n-                        }\n+                        checkCastablePattern(pat.pos(), seltype, primaryType);\n@@ -1827,2 +1837,1 @@\n-                                types.isSubtype(types.boxedTypeOrType(types.erasure(seltype)),\n-                                                patternType);\n+                                types.isUnconditionallyExact(seltype, patternType);\n@@ -1834,0 +1843,2 @@\n+                            } else if (booleanSwitch && constants.containsAll(Set.of(0, 1))) {\n+                                log.error(pat.pos(), Errors.UnconditionalPatternAndBothBooleanValues);\n@@ -1836,0 +1847,1 @@\n+                            unconditionalCaseLabel = label;\n@@ -1862,1 +1874,1 @@\n-                chk.checkSwitchCaseLabelDominated(cases);\n+                chk.checkSwitchCaseLabelDominated(unconditionalCaseLabel, cases);\n@@ -4100,2 +4112,7 @@\n-        Type exprtype = chk.checkNullOrRefType(\n-                tree.expr.pos(), attribExpr(tree.expr, env));\n+        Type exprtype = attribExpr(tree.expr, env);\n+        if (exprtype.isPrimitive()) {\n+            preview.checkSourceLevel(tree.expr.pos(), Feature.PRIMITIVE_PATTERNS);\n+        } else {\n+            exprtype = chk.checkNullOrRefType(\n+                    tree.expr.pos(), exprtype);\n+        }\n@@ -4122,11 +4139,5 @@\n-        if (!clazztype.hasTag(TYPEVAR)) {\n-            clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n-        }\n-        if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n-            boolean valid = false;\n-            if (allowReifiableTypesInInstanceof) {\n-                valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n-            } else {\n-                log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n-                          Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n-                allowReifiableTypesInInstanceof = true;\n+        if (clazztype.isPrimitive()) {\n+            preview.checkSourceLevel(tree.pattern.pos(), Feature.PRIMITIVE_PATTERNS);\n+        } else {\n+            if (!clazztype.hasTag(TYPEVAR)) {\n+                clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);\n@@ -4134,2 +4145,12 @@\n-            if (!valid) {\n-                clazztype = types.createErrorType(clazztype);\n+            if (!clazztype.isErroneous() && !types.isReifiable(clazztype)) {\n+                boolean valid = false;\n+                if (allowReifiableTypesInInstanceof) {\n+                    valid = checkCastablePattern(tree.expr.pos(), exprtype, clazztype);\n+                } else {\n+                    log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(),\n+                            Feature.REIFIABLE_TYPES_INSTANCEOF.error(this.sourceName));\n+                    allowReifiableTypesInInstanceof = true;\n+                }\n+                if (!valid) {\n+                    clazztype = types.createErrorType(clazztype);\n+                }\n@@ -4155,6 +4176,3 @@\n-                   (!exprType.isPrimitive() ||\n-                    !pattType.isPrimitive() ||\n-                    !types.isSameType(exprType, pattType))) {\n-            chk.basicHandler.report(pos,\n-                    diags.fragment(Fragments.NotApplicableTypes(exprType, pattType)));\n-            return false;\n+                (!exprType.isPrimitive() || !pattType.isPrimitive() || !types.isSameType(exprType, pattType))) {\n+            preview.checkSourceLevel(pos, Feature.PRIMITIVE_PATTERNS);\n+            return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":55,"deletions":37,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -4803,1 +4803,1 @@\n-    void checkSwitchCaseLabelDominated(List<JCCase> cases) {\n+    void checkSwitchCaseLabelDominated(JCCaseLabel unconditionalCaseLabel, List<JCCase> cases) {\n@@ -4808,0 +4808,2 @@\n+        boolean unconditionalFound = false;\n+\n@@ -4835,1 +4837,3 @@\n-                    if (types.isSubtype(currentType, testType) &&\n+                    boolean dominated = false;\n+                    if (unconditionalCaseLabel == testCaseLabel) unconditionalFound = true;\n+                    if (types.isUnconditionallyExact(currentType, testType) &&\n@@ -4838,1 +4842,0 @@\n-                        boolean dominated = false;\n@@ -4848,3 +4851,9 @@\n-                        if (dominated) {\n-                            log.error(label.pos(), Errors.PatternDominated);\n-                        }\n+                    }\n+\n+                    \/\/ Domination can occur even when we have not an unconditional pair between case labels.\n+                    if (unconditionalFound && unconditionalCaseLabel != label) {\n+                        dominated = true;\n+                    }\n+\n+                    if (dominated) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n@@ -4861,1 +4870,1 @@\n-                case CONSTANTCASELABEL -> types.boxedTypeOrType(((JCConstantCaseLabel) label).expr.type);\n+                case CONSTANTCASELABEL -> ((JCConstantCaseLabel) label).expr.type;\n@@ -4868,1 +4877,1 @@\n-            if (existingPatternType.isPrimitive() ^ currentPatternType.isPrimitive()) {\n+            if (!types.isUnconditionallyExact(currentPatternType, existingPatternType)) {\n@@ -4871,7 +4880,0 @@\n-            if (existingPatternType.isPrimitive()) {\n-                return types.isSameType(existingPatternType, currentPatternType);\n-            } else {\n-                if (!types.isSubtype(currentPatternType, existingPatternType)) {\n-                    return false;\n-                }\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -760,3 +760,8 @@\n-            tree.isExhaustive = tree.hasUnconditionalPattern ||\n-                                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases) ||\n-                                exhausts(tree.selector, tree.cases);\n+\n+            if (tree.hasUnconditionalPattern ||\n+                TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n+                tree.isExhaustive = true;\n+            } else {\n+                tree.isExhaustive = exhausts(tree.selector, tree.cases);\n+            }\n+\n@@ -773,0 +778,1 @@\n+            Set<Object> booleanLiterals = new HashSet<>();\n@@ -783,9 +789,14 @@\n-                        Symbol s = TreeInfo.symbol(constantLabel.expr);\n-                        if (s != null && s.isEnum()) {\n-                            enum2Constants.computeIfAbsent(s.owner, x -> {\n-                                Set<Symbol> result = new HashSet<>();\n-                                s.owner.members()\n-                                       .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n-                                       .forEach(result::add);\n-                                return result;\n-                            }).remove(s);\n+                        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n+                            Object value = ((JCLiteral) constantLabel.expr).value;\n+                            booleanLiterals.add(value);\n+                        } else {\n+                            Symbol s = TreeInfo.symbol(constantLabel.expr);\n+                            if (s != null && s.isEnum()) {\n+                                enum2Constants.computeIfAbsent(s.owner, x -> {\n+                                    Set<Symbol> result = new HashSet<>();\n+                                    s.owner.members()\n+                                            .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n+                                            .forEach(result::add);\n+                                    return result;\n+                                }).remove(s);\n+                            }\n@@ -796,0 +807,5 @@\n+\n+            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.size() == 2) {\n+                return true;\n+            }\n+\n@@ -826,2 +842,1 @@\n-                    if (pd instanceof BindingPattern bp &&\n-                        types.isSubtype(seltypeComponent, types.erasure(bp.type))) {\n+                    if(isBpCovered(seltypeComponent, pd)) {\n@@ -1107,2 +1122,1 @@\n-                    covered &= newNested instanceof BindingPattern bp &&\n-                               types.isSubtype(types.erasure(componentType[i]), types.erasure(bp.type));\n+                    covered &= isBpCovered(componentType[i], newNested);\n@@ -1284,0 +1298,24 @@\n+    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n+        if (newNested instanceof BindingPattern bp) {\n+            var seltype = types.erasure(componentType);\n+\n+            if (seltype.isPrimitive()) {\n+                if (types.isSameType(bp.type, types.boxedClass(seltype).type)) {\n+                    return true;\n+                }\n+\n+                \/\/ if the target is unconditionally exact to the pattern, target is covered\n+                if (types.isUnconditionallyExact(seltype, bp.type)) {\n+                    return true;\n+                }\n+            } else if (seltype.isReference() && bp.type.isPrimitive() && types.isCastable(seltype, bp.type)) {\n+                return true;\n+            } else {\n+                if (types.isSubtype(seltype, types.erasure(bp.type))) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n@@ -3465,1 +3503,1 @@\n-            Type type = types.isSubtype(selectorType, binding.type)\n+            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":55,"deletions":17,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+    private final HashMap<TypePairs, String> typePairToName;\n@@ -136,0 +137,1 @@\n+        typePairToName = TypePairs.initialize(syms);\n@@ -2924,0 +2926,172 @@\n+    \/**\n+     * All the exactness checks between primitive types that require a run-time\n+     * check are in {@code java.lang.runtime.ExactConversionsSupport}. Those methods\n+     * are in the form {@code ExactConversionsSupport.is<S>To<T>Exact} where both\n+     * {@code S} and {@code T} are primitive types and correspond to the runtime\n+     * action that will be executed to check whether a certain value (that is passed\n+     * as a parameter) can be converted to {@code T} without loss of information.\n+     *\n+     * Rewrite {@code instanceof if expr : Object} and Type is primitive type:\n+     *\n+     * {@snippet :\n+     *   Object v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; tmp$123 instanceof Float)\n+     * }\n+     *\n+     * Rewrite {@code instanceof if expr : wrapper reference type}\n+     *\n+     * {@snippet :\n+     *   Integer v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; tmp$123 != null && ExactConversionsSupport.intToFloatExact(tmp$123.intValue()))\n+     * }\n+     *\n+     * Rewrite {@code instanceof if expr : primitive}\n+     *\n+     * {@snippet :\n+     *   int v = ...\n+     *   if (v instanceof float)\n+     *   =>\n+     *   if (let tmp$123 = v; ExactConversionsSupport.intToFloatExact(tmp$123))\n+     * }\n+     *\n+     * More rewritings:\n+     * <ul>\n+     * <li>If the {@code instanceof} check is unconditionally exact rewrite to true.<\/li>\n+     * <li>If expression type is {@code Byte}, {@code Short}, {@code Integer}, ..., an\n+     *     unboxing conversion followed by a widening primitive conversion.<\/li>\n+     * <li>If expression type is a supertype: {@code Number}, a narrowing reference\n+     *     conversion followed by an unboxing conversion.<\/li>\n+     * <\/ul>\n+     *\/\n+    public void visitTypeTest(JCInstanceOf tree) {\n+        if (tree.expr.type.isPrimitive() || tree.pattern.type.isPrimitive()) {\n+            JCExpression exactnessCheck = null;\n+            JCExpression instanceOfExpr = translate(tree.expr);\n+\n+            \/\/ preserving the side effects of the value\n+            VarSymbol dollar_s = new VarSymbol(FINAL | SYNTHETIC,\n+                    names.fromString(\"tmp\" + tree.pos + this.target.syntheticNameChar()),\n+                    tree.expr.type,\n+                    currentMethodSym);\n+            JCStatement var = make.at(tree.pos())\n+                    .VarDef(dollar_s, instanceOfExpr).setType(dollar_s.type);\n+\n+            if (types.isUnconditionallyExact(tree.expr.type, tree.pattern.type)) {\n+                exactnessCheck = make\n+                        .LetExpr(List.of(var), make.Literal(BOOLEAN, 1).setType(syms.booleanType.constType(1)))\n+                        .setType(syms.booleanType);\n+            }\n+            else if (tree.expr.type.isReference()) {\n+                JCExpression nullCheck = makeBinary(NE,\n+                        make.Ident(dollar_s),\n+                        makeNull());\n+                if (types.isUnconditionallyExact(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                    exactnessCheck = make\n+                            .LetExpr(List.of(var), nullCheck)\n+                            .setType(syms.booleanType);\n+                } else if (types.unboxedType(tree.expr.type).isPrimitive()) {\n+                    exactnessCheck = getExactnessCheck(tree,\n+                            boxIfNeeded(make.Ident(dollar_s), types.unboxedType(tree.expr.type)));\n+                } else {\n+                    exactnessCheck = make.at(tree.pos())\n+                            .TypeTest(tree.expr, make.Type(types.boxedClass(tree.pattern.type).type))\n+                            .setType(syms.booleanType);\n+                }\n+\n+                exactnessCheck = make.LetExpr(List.of(var), makeBinary(AND,\n+                        nullCheck,\n+                        exactnessCheck))\n+                        .setType(syms.booleanType);\n+            }\n+            else if (tree.expr.type.isPrimitive()) {\n+                JCIdent argument = make.Ident(dollar_s);\n+\n+                JCExpression exactnessCheckCall =\n+                        getExactnessCheck(tree, argument);\n+\n+                exactnessCheck = make.LetExpr(List.of(var), exactnessCheckCall)\n+                        .setType(syms.booleanType);\n+            }\n+\n+            result = exactnessCheck;\n+        } else {\n+            tree.expr = translate(tree.expr);\n+            tree.pattern = translate(tree.pattern);\n+            result = tree;\n+        }\n+    }\n+\n+    \/\/ TypePairs should be in sync with the corresponding record in SwitchBootstraps\n+    record TypePairs(TypeSymbol from, TypeSymbol to) {\n+        public static TypePairs of(Symtab syms, Type from, Type to) {\n+            if (from == syms.byteType || from == syms.shortType || from == syms.charType) {\n+                from = syms.intType;\n+            }\n+            return new TypePairs(from, to);\n+        }\n+\n+        public TypePairs(Type from, Type to) {\n+            this(from.tsym, to.tsym);\n+        }\n+\n+        public static HashMap<TypePairs, String> initialize(Symtab syms) {\n+            HashMap<TypePairs, String> typePairToName = new HashMap<>();\n+            typePairToName.put(new TypePairs(syms.byteType,   syms.charType),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.byteType),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.shortType,  syms.charType),   \"isIntToCharExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.byteType),   \"isIntToByteExact\");      \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.charType,   syms.shortType),  \"isIntToShortExact\");     \/\/ redirected\n+            typePairToName.put(new TypePairs(syms.intType,    syms.byteType),   \"isIntToByteExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.shortType),  \"isIntToShortExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.charType),   \"isIntToCharExact\");\n+            typePairToName.put(new TypePairs(syms.intType,    syms.floatType),  \"isIntToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.byteType),   \"isLongToByteExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.shortType),  \"isLongToShortExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.charType),   \"isLongToCharExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.intType),    \"isLongToIntExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.floatType),  \"isLongToFloatExact\");\n+            typePairToName.put(new TypePairs(syms.longType,   syms.doubleType), \"isLongToDoubleExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.byteType),   \"isFloatToByteExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.shortType),  \"isFloatToShortExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.charType),   \"isFloatToCharExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.intType),    \"isFloatToIntExact\");\n+            typePairToName.put(new TypePairs(syms.floatType,  syms.longType),   \"isFloatToLongExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.byteType),   \"isDoubleToByteExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.shortType),  \"isDoubleToShortExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.charType),   \"isDoubleToCharExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.intType),    \"isDoubleToIntExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.longType),   \"isDoubleToLongExact\");\n+            typePairToName.put(new TypePairs(syms.doubleType, syms.floatType),  \"isDoubleToFloatExact\");\n+            return typePairToName;\n+        }\n+    }\n+\n+    private JCExpression getExactnessCheck(JCInstanceOf tree, JCExpression argument) {\n+        TypePairs pair = TypePairs.of(syms, types.unboxedTypeOrType(tree.expr.type), tree.pattern.type);\n+\n+        Name exactnessFunction = names.fromString(typePairToName.get(pair));\n+\n+        \/\/ Resolve the exactness method\n+        Symbol ecsym = lookupMethod(tree.pos(),\n+                exactnessFunction,\n+                syms.exactConversionsSupportType,\n+                List.of(pair.from.type));\n+\n+        \/\/ Generate the method call ExactnessChecks.<exactness method>(<argument>);\n+        JCFieldAccess select = make.Select(\n+                make.QualIdent(syms.exactConversionsSupportType.tsym),\n+                exactnessFunction);\n+        select.sym = ecsym;\n+        select.setType(syms.booleanType);\n+\n+        JCExpression exactnessCheck = make.Apply(List.nil(),\n+                select,\n+                List.of(argument));\n+        exactnessCheck.setType(syms.booleanType);\n+        return exactnessCheck;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                if (!tree.allowNull && !principalType.isPrimitive()) {\n+                if (!tree.allowNull || !types.isSubtype(currentValue.type, principalType)) {\n@@ -499,0 +499,1 @@\n+            boolean primitiveSelector = seltype.isPrimitive();\n@@ -503,0 +504,1 @@\n+            Type resolvedSelectorType = seltype;\n@@ -504,1 +506,1 @@\n-                    List.of(enumSelector ? seltype : syms.objectType, syms.intType),\n+                    List.of(resolvedSelectorType, syms.intType),\n@@ -738,0 +740,75 @@\n+    private Symbol.DynamicVarSymbol makePrimitive(DiagnosticPosition pos, Type primitiveType) {\n+        Assert.checkNonNull(currentClass);\n+\n+        List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n+                syms.stringType,\n+                new ClassType(syms.classType.getEnclosingType(),\n+                        List.of(syms.constantBootstrapsType),\n+                        syms.classType.tsym));\n+\n+        Name bootstrapName = names.fromString(\"primitiveClass\");\n+        MethodSymbol bsm = rs.resolveInternalMethod(pos, env, syms.constantBootstrapsType,\n+                bootstrapName, bsm_staticArgs, List.nil());\n+\n+        PrimitiveGenerator primitiveGenerator = new PrimitiveGenerator();\n+        primitiveGenerator.assembleSig(primitiveType);\n+        return new Symbol.DynamicVarSymbol(names.fromString(primitiveGenerator.sb.toString()),\n+                syms.noSymbol,\n+                new Symbol.MethodHandleSymbol(bsm),\n+                syms.classType,\n+                new LoadableConstant[]{});\n+    }\n+\n+    private Symbol.DynamicVarSymbol makeBooleanConstant(DiagnosticPosition pos, int constant) {\n+        Assert.checkNonNull(currentClass);\n+\n+        List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n+                syms.stringType,\n+                new ClassType(syms.classType.getEnclosingType(),\n+                        List.of(syms.constantBootstrapsType),\n+                        syms.classType.tsym));\n+\n+        Name bootstrapName = names.fromString(\"getStaticFinal\");\n+        MethodSymbol bsm = rs.resolveInternalMethod(pos, env, syms.constantBootstrapsType,\n+                bootstrapName, bsm_staticArgs, List.nil());\n+\n+        return new Symbol.DynamicVarSymbol(constant == 0 ? names.fromString(\"FALSE\") : names.fromString(\"TRUE\"),\n+                syms.noSymbol,\n+                new Symbol.MethodHandleSymbol(bsm),\n+                types.boxedTypeOrType(syms.booleanType),\n+                new LoadableConstant[]{});\n+    }\n+\n+    private class PrimitiveGenerator extends Types.SignatureGenerator {\n+\n+        \/**\n+         * An output buffer for type signatures.\n+         *\/\n+        StringBuilder sb = new StringBuilder();\n+\n+        PrimitiveGenerator() {\n+            super(types);\n+        }\n+\n+        @Override\n+        protected void append(char ch) {\n+            sb.append(ch);\n+        }\n+\n+        @Override\n+        protected void append(byte[] ba) {\n+            sb.append(new String(ba));\n+        }\n+\n+        @Override\n+        protected void append(Name name) {\n+            sb.append(name.toString());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return sb.toString();\n+        }\n+    }\n+\n+\n@@ -826,1 +903,2 @@\n-                                instanceofCheck.allowNull &&\n+                                (!types.erasure(binding.type).isPrimitive() ? instanceofCheck.allowNull :\n+                                types.isUnconditionallyExact(commonNestedExpression.type, types.erasure(binding.type))) &&\n@@ -857,0 +935,1 @@\n+                    newSwitch.hasUnconditionalPattern = hasUnconditional;\n@@ -933,1 +1012,1 @@\n-        return types.boxedTypeOrType(types.erasure(TreeInfo.primaryPatternType(p)));\n+        return types.erasure(TreeInfo.primaryPatternType(p));\n@@ -939,2 +1018,6 @@\n-            if (types.isSubtype(selector, principalType)) {\n-                return (LoadableConstant) selector;\n+            if (((JCPatternCaseLabel) l).pat.type.isReference()) {\n+                if (types.isSubtype(selector, principalType)) {\n+                    return (LoadableConstant) selector;\n+                } else {\n+                    return (LoadableConstant) principalType;\n+                }\n@@ -942,1 +1025,1 @@\n-                return (LoadableConstant) principalType;\n+                return makePrimitive(l.pos(), principalType);\n@@ -957,2 +1040,5 @@\n-                    case BYTE, CHAR,\n-                         SHORT, INT -> LoadableConstant.Int((Integer) expr.type.constValue());\n+                    case BOOLEAN -> makeBooleanConstant(l.pos(), (Integer) expr.type.constValue());\n+                    case BYTE, CHAR, SHORT, INT -> LoadableConstant.Int((Integer) expr.type.constValue());\n+                    case LONG -> LoadableConstant.Long((Long) expr.type.constValue());\n+                    case FLOAT -> LoadableConstant.Float((Float) expr.type.constValue());\n+                    case DOUBLE -> LoadableConstant.Double((Double) expr.type.constValue());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":95,"deletions":9,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -552,0 +552,6 @@\n+compiler.err.unconditional.pattern.and.both.boolean.values=\\\n+    switch has both boolean values and an unconditional pattern\n+\n+compiler.err.default.and.both.boolean.values=\\\n+    switch has both boolean values and a default label\n+\n@@ -566,4 +572,0 @@\n-# 0: type\n-compiler.err.selector.type.not.allowed=\\\n-    selector type {0} is not allowed\n-\n@@ -2668,4 +2670,0 @@\n-# 0: type, 1: type\n-compiler.misc.not.applicable.types=\\\n-    pattern of type {1} is not applicable at {0}\n-\n@@ -3203,0 +3201,3 @@\n+compiler.misc.feature.primitive.patterns=\\\n+    primitive patterns\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -212,8 +212,8 @@\n-        BOOLEAN(TokenKind.BOOLEAN, XEXPR1|XDECL1),  \/\/  boolean\n-        BYTE(TokenKind.BYTE, XEXPR1|XDECL1),  \/\/  byte\n-        CHAR(TokenKind.CHAR, XEXPR1|XDECL1),  \/\/  char\n-        DOUBLE(TokenKind.DOUBLE, XEXPR1|XDECL1),  \/\/  double\n-        FLOAT(TokenKind.FLOAT, XEXPR1|XDECL1),  \/\/  float\n-        INT(TokenKind.INT, XEXPR1|XDECL1),  \/\/  int\n-        LONG(TokenKind.LONG, XEXPR1|XDECL1),  \/\/  long\n-        SHORT(TokenKind.SHORT, XEXPR1|XDECL1),  \/\/  short\n+        BOOLEAN(TokenKind.BOOLEAN, XEXPR1|XDECL1|XTERM),  \/\/  boolean\n+        BYTE(TokenKind.BYTE, XEXPR1|XDECL1|XTERM),  \/\/  byte\n+        CHAR(TokenKind.CHAR, XEXPR1|XDECL1|XTERM),  \/\/  char\n+        DOUBLE(TokenKind.DOUBLE, XEXPR1|XDECL1|XTERM),  \/\/  double\n+        FLOAT(TokenKind.FLOAT, XEXPR1|XDECL1|XTERM),  \/\/  float\n+        INT(TokenKind.INT, XEXPR1|XDECL1|XTERM),  \/\/  int\n+        LONG(TokenKind.LONG, XEXPR1|XDECL1|XTERM),  \/\/  long\n+        SHORT(TokenKind.SHORT, XEXPR1|XDECL1|XTERM),  \/\/  short\n@@ -808,1 +808,2 @@\n-            while (token.kind.isExpression())\n+            while (token.kind.isExpression()) {\n+                CT prevToken = in.prevCT;\n@@ -810,0 +811,15 @@\n+                \/\/ primitive types can only appear in the end of an `instanceof` expression\n+                switch (token.kind) {\n+                    case EOF:\n+                        switch (in.prevCT.kind) {\n+                            case BYTE, SHORT, CHAR, INT, LONG, FLOAT, DOUBLE, BOOLEAN:\n+                                switch (prevToken.kind) {\n+                                    case INSTANCEOF:\n+                                        return Completeness.COMPLETE;\n+                                    default:\n+                                        return Completeness.DEFINITELY_INCOMPLETE;\n+                                }\n+                        }\n+                }\n+            }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.Serializable;\n+import java.lang.Enum.EnumDesc;\n+import java.lang.classfile.ClassFile;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.AccessFlag;\n+import java.lang.runtime.ExactConversionsSupport;\n+import java.lang.runtime.SwitchBootstraps;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * @test\n+ * @bug 8304487\n+ * @summary Verify boundary and special cases of exact conversion predicates\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.classfile\n+ * @compile ExactnessConversionsSupportTest.java\n+ * @run testng\/othervm ExactnessConversionsSupportTest\n+ *\/\n+@Test\n+public class ExactnessConversionsSupportTest {\n+\n+    public static void main(String[] args) {\n+        testByte();\n+        testShort();\n+        testChar();\n+        testInt();\n+        testLong();\n+        testFloat();\n+        testDouble();\n+    }\n+\n+    public static void testByte() {\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact((byte) (Byte.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact((byte) (0)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact((byte) (Byte.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToByteExact((short) (Short.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact((short) (0)));\n+        assertEquals(false, ExactConversionsSupport.isIntToByteExact((short) (Short.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToByteExact((char) (Character.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact((char) (Character.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToByteExact(Integer.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isIntToByteExact(0));\n+        assertEquals(false, ExactConversionsSupport.isIntToByteExact(Integer.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isLongToByteExact(Long.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isLongToByteExact(0L));\n+        assertEquals(false, ExactConversionsSupport.isLongToByteExact(Long.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(Float.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToByteExact((float) 0));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(Float.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(Float.NaN));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(Float.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(Float.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToByteExact(-0.0f));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToByteExact(+0.0f));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(Double.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToByteExact(0d));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(Double.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(Double.NaN));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(Double.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(Double.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToByteExact(-0.0d));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToByteExact(+0.0d));\n+    }\n+    public static void testShort() {\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((byte) (Byte.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((byte) (0)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((byte) (Byte.MIN_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((short) (Short.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((short) (0)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((short) (Short.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToShortExact((char) (Character.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((char) (Character.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToShortExact((Integer.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToShortExact((0)));\n+        assertEquals(false, ExactConversionsSupport.isIntToShortExact((Integer.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isLongToShortExact(Long.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isLongToShortExact(0L));\n+        assertEquals(false, ExactConversionsSupport.isLongToShortExact(Long.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToShortExact(0f));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.NaN));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(Float.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToShortExact(-0.0f));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToShortExact(+0.0f));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(Double.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToShortExact((double) 0));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(Double.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(Double.NaN));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(Double.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(Double.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToShortExact(-0.0d));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToShortExact(+0.0d));\n+    }\n+    public static void testChar() {\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((byte) (Byte.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((byte) (0)));\n+        assertEquals(false, ExactConversionsSupport.isIntToCharExact((byte) (Byte.MIN_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((short) (Short.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((short) (0)));\n+        assertEquals(false, ExactConversionsSupport.isIntToCharExact((short) (Short.MIN_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((char) (Character.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact((char) (Character.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isIntToCharExact (Integer.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isIntToCharExact(0));\n+        assertEquals(false, ExactConversionsSupport.isIntToCharExact(Integer.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isLongToCharExact(Long.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isLongToCharExact(0l));\n+        assertEquals(false, ExactConversionsSupport.isLongToCharExact(Long.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(Float.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToCharExact((float) 0));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(Float.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(Float.NaN));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(Float.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(Float.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isFloatToCharExact(-0.0f));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToCharExact(+0.0f));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(Double.MAX_VALUE));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToCharExact((double) 0));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(Double.MIN_VALUE));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(Double.NaN));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(Double.POSITIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(Double.NEGATIVE_INFINITY));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToCharExact(-0.0d));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToCharExact(+0.0d));\n+    }\n+    public static void testInt() {\n+        assertEquals(false, ExactConversionsSupport.isLongToIntExact((Long.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isLongToIntExact((0L)));\n+        assertEquals(false, ExactConversionsSupport.isLongToIntExact((Long.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((Float.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToIntExact(((float) 0)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((Float.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((Float.NaN)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((Float.POSITIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((Float.NEGATIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToIntExact((-0.0f)));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToIntExact((+0.0f)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((Double.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToIntExact(((double) 0)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((Double.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((Double.NaN)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((Double.POSITIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((Double.NEGATIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToIntExact((-0.0d)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToIntExact((+0.0d)));\n+    }\n+    public static void testLong() {\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((Float.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToLongExact(((float) 0)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((Float.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((Float.NaN)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((Float.POSITIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((Float.NEGATIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isFloatToLongExact((-0.0f)));\n+        assertEquals(true,  ExactConversionsSupport.isFloatToLongExact((+0.0f)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((Double.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToLongExact(((double) 0)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((Double.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((Double.NaN)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((Double.POSITIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((Double.NEGATIVE_INFINITY)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToLongExact((-0.0d)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToLongExact((+0.0d)));\n+    }\n+    public static void testFloat() {\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((byte) (Byte.MAX_VALUE))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((byte) (0))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((byte) (Byte.MIN_VALUE))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((short) (Short.MAX_VALUE))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((short) (0))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((short) (Short.MIN_VALUE))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((char) (Character.MAX_VALUE))));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact(((char) (Character.MIN_VALUE))));\n+        assertEquals(false, ExactConversionsSupport.isIntToFloatExact( (Integer.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact((0)));\n+        assertEquals(true,  ExactConversionsSupport.isIntToFloatExact((Integer.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isLongToFloatExact((Long.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isLongToFloatExact((0l)));\n+        assertEquals(true,  ExactConversionsSupport.isLongToFloatExact((Long.MIN_VALUE)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToFloatExact((Double.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact(((double) 0)));\n+        assertEquals(false, ExactConversionsSupport.isDoubleToFloatExact((Double.MIN_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact((Double.NaN)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact((Double.POSITIVE_INFINITY)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact((Double.NEGATIVE_INFINITY)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact((-0.0d)));\n+        assertEquals(true,  ExactConversionsSupport.isDoubleToFloatExact((+0.0d)));\n+    }\n+    public static void testDouble() {\n+        assertEquals(false, ExactConversionsSupport.isLongToDoubleExact((Long.MAX_VALUE)));\n+        assertEquals(true,  ExactConversionsSupport.isLongToDoubleExact((0L)));\n+        assertEquals(true,  ExactConversionsSupport.isLongToDoubleExact((Long.MIN_VALUE)));\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/ExactnessConversionsSupportTest.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -49,0 +49,1 @@\n+ * @modules java.base\/jdk.internal.classfile\n@@ -114,6 +115,3 @@\n-        try {\n-            testType(1, 0, 1, 1.0, Integer.class);\n-            fail(\"Didn't get the expected exception.\");\n-        } catch (IllegalArgumentException ex) {\n-            \/\/OK\n-        }\n+        testType(1, 0, 1, 1.0d, Integer.class);\n+        testType(1, 0, 1, 1.0f, Integer.class);\n+        testType(1, 0, 1, true, Integer.class);\n@@ -127,0 +125,9 @@\n+        testType(new Object() {\n+            @Override\n+            public boolean equals(Object obj) {\n+                if (obj instanceof Long i) {\n+                    return i == 1;\n+                }\n+                return super.equals(obj);\n+            }\n+        }, 0, 1, 1L);\n@@ -181,1 +188,0 @@\n-            MethodType.methodType(int.class, double.class, int.class),\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -399,0 +399,5 @@\n+\n+    public void testInstanceOf() {\n+        assertStatus(\"i instanceof Integer\", COMPLETE, \"i instanceof Integer\");\n+        assertStatus(\"i instanceof int\", COMPLETE, \"i instanceof int\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @build KullaTesting TestingInputStream\n+ * @run testng PrimitiveInstanceOfTest\n+ *\/\n+import jdk.jshell.JShell;\n+import org.testng.annotations.Test;\n+\n+import java.util.function.Consumer;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class PrimitiveInstanceOfTest extends KullaTesting {\n+\n+    public void testInstanceOf() {\n+        assertEval(\"int i = 42;\");\n+        assertEval(\"i instanceof Integer\");\n+        assertEval(\"i instanceof int\");\n+    }\n+\n+    public void testInstanceOfRef() {\n+        assertEval(\"Integer i = 42;\");\n+        assertEval(\"i instanceof Integer\");\n+        assertEval(\"i instanceof Number\");\n+    }\n+\n+    @org.testng.annotations.BeforeMethod\n+    public void setUp() {\n+        super.setUp(bc -> bc.compilerOptions(\"--source\", System.getProperty(\"java.specification.version\"), \"--enable-preview\").remoteVMOptions(\"--enable-preview\"));\n+    }\n+}\n","filename":"test\/langtools\/jdk\/jshell\/PrimitiveInstanceOfTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.default.and.both.boolean.values\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --source 23\n+public class DefaultAndBothBoolean {\n+    private int test(boolean sel) {\n+        return switch (sel) {\n+            case true -> 1;\n+            case false -> 2;\n+            default -> 3;\n+        };\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/DefaultAndBothBoolean.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.misc.not.applicable.types\n-\/\/ key: compiler.err.prob.found.req\n-\n-class NotApplicableTypes {\n-    void t(int i) {\n-        switch (i) {\n-            case Integer j -> {}\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotApplicableTypes.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.misc.feature.primitive.patterns\n+\/\/ key: compiler.warn.preview.feature.use.plural\n+\/\/ options: --enable-preview -source ${jdk.version} -Xlint:preview\n+\n+class PrimitivePatternMatching {\n+    boolean m(Object o) {\n+        return o instanceof int s;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/PrimitivePatternMatching.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ key: compiler.err.selector.type.not.allowed\n-\n-public class SelectorTypeNotAllowed {\n-    private void noLong(long sel) {\n-        switch (sel) {\n-            default -> {}\n-        }\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/SelectorTypeNotAllowed.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -30,1 +30,9 @@\n-    boolean b = (this instanceof int);\n+    interface Sig {\n+        void m(int s);\n+    }\n+\n+    Sig consume(Sig s) { return s; }\n+\n+    public void meth() {\n+        Sig s = consume(int::new);\n+    }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TypeReqClassArray.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,3 @@\n-    int i;\n-    boolean b = (i instanceof Object);\n+\n+    void method(Inner<int> in) {}\n+    class Inner<T> {}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/TypeReqRef.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.unconditional.pattern.and.both.boolean.values\n+\/\/ key: compiler.note.preview.filename\n+\/\/ key: compiler.note.preview.recompile\n+\/\/ options: --enable-preview --source 23\n+public class UnconditionalPatternAndBothBoolean {\n+    private int test(boolean sel) {\n+        return switch (sel) {\n+            case true -> 1;\n+            case false -> 2;\n+            case boolean b -> 3;\n+        };\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/UnconditionalPatternAndBothBoolean.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -6,1 +6,1 @@\n- *\/\n+ * @compile --enable-preview --source ${jdk.version} CastConversionMatch.java *\/\n","filename":"test\/langtools\/tools\/javac\/patterns\/CastConversionMatch.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-CastConversionMatch.java:11:26: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n+CastConversionMatch.java:11:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\n","filename":"test\/langtools\/tools\/javac\/patterns\/CastConversionMatch.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,7 +30,0 @@\n-        if (p instanceof P7(byte b)); \/\/incorrect pattern type\n-        if (p instanceof P7(long l)); \/\/incorrect pattern type\n-        switch (p) {\n-            case P7(byte b) -> {} \/\/incorrect pattern type - no exception should occur\n-            case P7(long l) -> {} \/\/incorrect pattern type - no exception should occur\n-            default -> {}\n-        }\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,4 +1,4 @@\n-DeconstructionPatternErrors.java:42:37: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:44:28: compiler.err.illegal.start.of.type\n-DeconstructionPatternErrors.java:46:42: compiler.err.expected: ';'\n-DeconstructionPatternErrors.java:46:43: compiler.err.not.stmt\n+DeconstructionPatternErrors.java:35:37: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:37:28: compiler.err.illegal.start.of.type\n+DeconstructionPatternErrors.java:39:42: compiler.err.expected: ';'\n+DeconstructionPatternErrors.java:39:43: compiler.err.not.stmt\n@@ -23,5 +23,1 @@\n-DeconstructionPatternErrors.java:30:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:31:29: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-DeconstructionPatternErrors.java:33:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, byte)\n-DeconstructionPatternErrors.java:34:21: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, long)\n-26 errors\n\\ No newline at end of file\n+22 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/DeconstructionPatternErrors.out","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @build combo.ComboTestHelper\n+ * @compile PrimitiveInstanceOfComboTest.java\n+ * @run main PrimitiveInstanceOfComboTest\n+ *\/\n+\n+import combo.ComboInstance;\n+import combo.ComboParameter;\n+import combo.ComboTask;\n+import combo.ComboTestHelper;\n+import toolbox.ToolBox;\n+\n+public class PrimitiveInstanceOfComboTest extends ComboInstance<PrimitiveInstanceOfComboTest> {\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    protected ToolBox tb;\n+\n+    PrimitiveInstanceOfComboTest() {\n+        super();\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new ComboTestHelper<PrimitiveInstanceOfComboTest>()\n+                .withDimension(\"TYPE1\", (x, type1) -> x.type1 = type1, Type.values())\n+                .withDimension(\"TYPE2\", (x, type2) -> x.type2 = type2, Type.values())\n+                .withFailMode(ComboTestHelper.FailMode.FAIL_FAST)\n+                .run(PrimitiveInstanceOfComboTest::new);\n+    }\n+\n+    private Type type1;\n+    private Type type2;\n+\n+    private static final String test1 =\n+            \"\"\"\n+            public class Test {\n+                public static void doTest(#{TYPE1} in) {\n+                    var r = (#{TYPE2}) in;\n+                }\n+            }\n+            \"\"\";\n+\n+    private static final String test2 =\n+            \"\"\"\n+            public class Test {\n+                public static void doTest(#{TYPE1} in) {\n+                    var r = in instanceof #{TYPE2};\n+                }\n+            }\n+            \"\"\";\n+\n+    @Override\n+    protected void doWork() throws Throwable {\n+        ComboTask task1 = newCompilationTask()\n+                .withSourceFromTemplate(test1.replace(\"#{TYPE1}\", type1.code).replace(\"#{TYPE2}\", type2.code))\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"-source\").withOption(JAVA_VERSION);;\n+\n+        ComboTask task2 = newCompilationTask()\n+                .withSourceFromTemplate(test2.replace(\"#{TYPE1}\", type1.code).replace(\"#{TYPE2}\", type2.code))\n+                .withOption(\"--enable-preview\")\n+                .withOption(\"-source\").withOption(JAVA_VERSION);;\n+\n+        task1.generate(result1 -> {\n+            task2.generate(result2 -> {\n+                if (result1.hasErrors() ^ result2.hasErrors()) {\n+                    throw new AssertionError(\"Unexpected result: \" +\n+                            \"\\n task1: \" + result1.hasErrors() + \", info: \" + result1.compilationInfo() +\n+                            \"\\n task1: \" + result2.hasErrors() + \", info: \" + result2.compilationInfo());\n+                }\n+            });\n+        });\n+    }\n+\n+    public enum Type implements ComboParameter {\n+        BYTE(\"byte\"),\n+        SHORT(\"short\"),\n+        CHAR(\"char\"),\n+        INT(\"int\"),\n+        LONG(\"long\"),\n+        FLOAT(\"float\"),\n+        DOUBLE(\"double\"),\n+        BOOLEAN(\"boolean\"),\n+\n+        BYTE_r(\"Byte\"),\n+        SHORT_r(\"Short\"),\n+        CHAR_r(\"Character\"),\n+        INTEGER_r(\"Integer\"),\n+        LONG_r(\"Long\"),\n+        FLOAT_r(\"Float\"),\n+        DOUBLE_r(\"Double\"),\n+        BOOLEAN_r(\"Boolean\");\n+\n+        private final String code;\n+\n+        Type(String code) {\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public String expand(String optParameter) {\n+            throw new UnsupportedOperationException(\"Not supported.\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfComboTest.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile\/fail\/ref=PrimitiveInstanceOfErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitiveInstanceOfErrors.java\n+ *\/\n+public class PrimitiveInstanceOfErrors {\n+    public static boolean unboxingAndNarrowingPrimitiveNotAllowedPerCastingConversion() {\n+        Long l_within_int_range = 42L;\n+        Long l_outside_int_range = 999999999999999999L;\n+\n+        return l_within_int_range instanceof int && !(l_outside_int_range instanceof int);\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndNarrowingPrimitive(T i) {\n+        return i instanceof byte;\n+    }\n+\n+    public static void boxingConversionsBetweenIncompatibleTypes() {\n+        int i = 42;\n+\n+        boolean ret1 = i instanceof Integer; \/\/ (Integer) i \/\/ OK and true\n+        boolean ret2 = i instanceof Double;  \/\/ error: incompatible types\n+        boolean ret3 = i instanceof Short;   \/\/ error: incompatible types\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfErrors.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+PrimitiveInstanceOfErrors.java:13:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Long, int)\n+PrimitiveInstanceOfErrors.java:13:55: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: java.lang.Long, int)\n+PrimitiveInstanceOfErrors.java:17:16: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: T, byte)\n+PrimitiveInstanceOfErrors.java:24:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Double)\n+PrimitiveInstanceOfErrors.java:25:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Short)\n+- compiler.note.preview.filename: PrimitiveInstanceOfErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+5 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfErrors.out","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile PrimitiveInstanceOfNumericValueTests.java\n+ * @run main\/othervm PrimitiveInstanceOfNumericValueTests\n+ *\/\n+public class PrimitiveInstanceOfNumericValueTests {\n+\n+    public static void main(String[] args) {\n+        testByte();\n+        testShort();\n+        testChar();\n+        testInt();\n+        testLong();\n+        testFloat();\n+        testDouble();\n+    }\n+\n+    public static void testByte() {\n+        assertEquals(true,  ((byte) (Byte.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((byte) (0)) instanceof byte);\n+        assertEquals(true,  ((byte) (Byte.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, ((short) (Short.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((short) (0)) instanceof byte);\n+        assertEquals(false, ((short) (Short.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, ((char) (Character.MAX_VALUE)) instanceof byte);\n+        assertEquals(true,  ((char) (Character.MIN_VALUE)) instanceof byte);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  (0) instanceof byte);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  (0L) instanceof byte);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  ((float) 0) instanceof byte);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Float.NaN) instanceof byte);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (-0.0f) instanceof byte);\n+        assertEquals(true,  (+0.0f) instanceof byte);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof byte);\n+        assertEquals(true,  ((double) 0) instanceof byte);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof byte);\n+        assertEquals(false, (Double.NaN) instanceof byte);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof byte);\n+        assertEquals(false, (-0.0d) instanceof byte);\n+        assertEquals(true,  (+0.0d) instanceof byte);\n+    }\n+    public static void testShort() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((byte) (0)) instanceof short);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof short);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((short) (0)) instanceof short);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof short);\n+        assertEquals(false, ((char) (Character.MAX_VALUE)) instanceof short);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof short);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof short);\n+        assertEquals(true, (0) instanceof short);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof short);\n+        assertEquals(true, (0L) instanceof short);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof short);\n+        assertEquals(true, ((float) 0) instanceof short);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Float.NaN) instanceof short);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof short);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof short);\n+        assertEquals(false, (-0.0f) instanceof short);\n+        assertEquals(true, (+0.0f) instanceof short);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof short);\n+        assertEquals(true, ((double) 0) instanceof short);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof short);\n+        assertEquals(false, (Double.NaN) instanceof short);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof short);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof short);\n+        assertEquals(false, (-0.0d) instanceof short);\n+        assertEquals(true, (+0.0d) instanceof short);\n+    }\n+    public static void testChar() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((byte) (0)) instanceof char);\n+        assertEquals(false, ((byte) (Byte.MIN_VALUE)) instanceof char);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((short) (0)) instanceof char);\n+        assertEquals(false, ((short) (Short.MIN_VALUE)) instanceof char);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof char);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof char);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof char);\n+        assertEquals(true, (0) instanceof char);\n+        assertEquals(false, (Integer.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof char);\n+        assertEquals(true, (0L) instanceof char);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof char);\n+        assertEquals(true, ((float) 0) instanceof char);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Float.NaN) instanceof char);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof char);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof char);\n+        assertEquals(false, (-0.0f) instanceof char);\n+        assertEquals(true, (+0.0f) instanceof char);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof char);\n+        assertEquals(true, ((double) 0) instanceof char);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof char);\n+        assertEquals(false, (Double.NaN) instanceof char);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof char);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof char);\n+        assertEquals(false, (-0.0d) instanceof char);\n+        assertEquals(true, (+0.0d) instanceof char);\n+    }\n+    public static void testInt() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((byte) (0)) instanceof int);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof int);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((short) (0)) instanceof int);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof int);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof int);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof int);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof int);\n+        assertEquals(true, (0) instanceof int);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof int);\n+        assertEquals(true, (0L) instanceof int);\n+        assertEquals(false, (Long.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof int);\n+        assertEquals(true, ((float) 0) instanceof int);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Float.NaN) instanceof int);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof int);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof int);\n+        assertEquals(false, (-0.0f) instanceof int);\n+        assertEquals(true, (+0.0f) instanceof int);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof int);\n+        assertEquals(true, ((double) 0) instanceof int);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof int);\n+        assertEquals(false, (Double.NaN) instanceof int);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof int);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof int);\n+        assertEquals(false, (-0.0d) instanceof int);\n+        assertEquals(true, (+0.0d) instanceof int);\n+    }\n+    public static void testLong() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((byte) (0)) instanceof long);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof long);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((short) (0)) instanceof long);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof long);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof long);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof long);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof long);\n+        assertEquals(true, (0L) instanceof long);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof long);\n+        assertEquals(true, (Long.MAX_VALUE) instanceof long);\n+        assertEquals(true, (0) instanceof long);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Float.MAX_VALUE) instanceof long);\n+        assertEquals(true, ((float) 0) instanceof long);\n+        assertEquals(false, (Float.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Float.NaN) instanceof long);\n+        assertEquals(false, (Float.POSITIVE_INFINITY) instanceof long);\n+        assertEquals(false, (Float.NEGATIVE_INFINITY) instanceof long);\n+        assertEquals(false, (-0.0f) instanceof long);\n+        assertEquals(true, (+0.0f) instanceof long);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof long);\n+        assertEquals(true, ((double) 0) instanceof long);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof long);\n+        assertEquals(false, (Double.NaN) instanceof long);\n+        assertEquals(false, (Double.POSITIVE_INFINITY) instanceof long);\n+        assertEquals(false, (Double.NEGATIVE_INFINITY) instanceof long);\n+        assertEquals(false, (-0.0d) instanceof long);\n+        assertEquals(true, (+0.0d) instanceof long);\n+    }\n+    public static void testFloat() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((byte) (0) instanceof float));\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof float);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((short) (0)) instanceof float);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof float);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof float);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof float);\n+        assertEquals(false, (Integer.MAX_VALUE) instanceof float);\n+        assertEquals(true, (0) instanceof float);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof float);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof float);\n+        assertEquals(true, (0L) instanceof float);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Float.MAX_VALUE) instanceof float);\n+        assertEquals(true, ((float) 0) instanceof float);\n+        assertEquals(true, (Float.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Float.NaN) instanceof float);\n+        assertEquals(true, (Float.POSITIVE_INFINITY) instanceof float);\n+        assertEquals(true, (Float.NEGATIVE_INFINITY) instanceof float);\n+        assertEquals(true, (-0.0f) instanceof float);\n+        assertEquals(true, (+0.0f) instanceof float);\n+        assertEquals(false, (Double.MAX_VALUE) instanceof float);\n+        assertEquals(true, ((double) 0) instanceof float);\n+        assertEquals(false, (Double.MIN_VALUE) instanceof float);\n+        assertEquals(true, (Double.NaN) instanceof float);\n+        assertEquals(true, (Double.POSITIVE_INFINITY) instanceof float);\n+        assertEquals(true, (Double.NEGATIVE_INFINITY) instanceof float);\n+        assertEquals(true, (-0.0d) instanceof float);\n+        assertEquals(true, (+0.0d) instanceof float);\n+    }\n+    public static void testDouble() {\n+        assertEquals(true, ((byte) (Byte.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((byte) (0)) instanceof double);\n+        assertEquals(true, ((byte) (Byte.MIN_VALUE)) instanceof double);\n+        assertEquals(true, ((short) (Short.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((short) (0)) instanceof double);\n+        assertEquals(true, ((short) (Short.MIN_VALUE)) instanceof double);\n+        assertEquals(true, ((char) (Character.MAX_VALUE)) instanceof double);\n+        assertEquals(true, ((char) (Character.MIN_VALUE)) instanceof double);\n+        assertEquals(true, (Integer.MAX_VALUE) instanceof double);\n+        assertEquals(true, (0) instanceof double);\n+        assertEquals(true, (Integer.MIN_VALUE) instanceof double);\n+        assertEquals(false, (Long.MAX_VALUE) instanceof double);\n+        assertEquals(true, (0L) instanceof double);\n+        assertEquals(true, (Long.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Float.MAX_VALUE) instanceof double);\n+        assertEquals(true, ((float) 0) instanceof double);\n+        assertEquals(true, (Float.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Float.NaN) instanceof double);\n+        assertEquals(true, (Float.POSITIVE_INFINITY) instanceof double);\n+        assertEquals(true, (Float.NEGATIVE_INFINITY) instanceof double);\n+        assertEquals(true, (-0.0f) instanceof double);\n+        assertEquals(true, (+0.0f) instanceof double);\n+        assertEquals(true, (Double.MAX_VALUE) instanceof double);\n+        assertEquals(true, ((double) 0) instanceof double);\n+        assertEquals(true, (Double.MIN_VALUE) instanceof double);\n+        assertEquals(true, (Double.NaN) instanceof double);\n+        assertEquals(true, (Double.POSITIVE_INFINITY) instanceof double);\n+        assertEquals(true, (Double.NEGATIVE_INFINITY) instanceof double);\n+        assertEquals(true, (-0.0d) instanceof double);\n+        assertEquals(true, (+0.0d) instanceof double);\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfNumericValueTests.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile PrimitiveInstanceOfPatternOpWithRecordPatterns.java\n+ * @run main\/othervm PrimitiveInstanceOfPatternOpWithRecordPatterns\n+ *\/\n+public class PrimitiveInstanceOfPatternOpWithRecordPatterns {\n+\n+    public static void main(String[] args) {\n+        assertEquals(true,  identityPrimitiveConversion());\n+        assertEquals(true,  wideningPrimitiveConversion());\n+        assertEquals(true,  narrowingPrimitiveConversion());\n+        assertEquals(true,  wideningAndNarrowingPrimitiveConversion());\n+        assertEquals(true,  boxingConversion());\n+        assertEquals(true,  boxingAndWideningReferenceConversion());\n+        assertEquals(true,  unboxing());\n+        assertEquals(true,  unboxingWithObject());\n+        assertEquals(true,  wideningReferenceConversionUnboxing());\n+        assertEquals(true,  wideningReferenceConversionUnboxingAndWideningPrimitive());\n+        assertEquals(true,  unboxingAndWideningPrimitiveExact());\n+        assertEquals(false, unboxingAndWideningPrimitiveNotExact());\n+        assertEquals(true,  unboxingWhenNullAndWideningPrimitive());\n+        assertEquals(true,  narrowingAndUnboxing());\n+    }\n+\n+    public static boolean identityPrimitiveConversion() {\n+        R_int r = new R_int(42);\n+        return r instanceof R_int(int _);\n+    }\n+\n+    public static boolean wideningPrimitiveConversion() {\n+        R_byte b = new R_byte((byte) 42);\n+        R_short s = new R_short((short) 42);\n+        R_char c = new R_char('a');\n+\n+        return b instanceof R_byte(int _) && s instanceof R_short(int _) && c instanceof R_char(int _);\n+    }\n+\n+    public static boolean narrowingPrimitiveConversion() {\n+        R_long l_within_int_range = new R_long(42L);\n+        R_long l_outside_int_range = new R_long(999999999999999999L);\n+\n+        return l_within_int_range instanceof R_long(int _) && !(l_outside_int_range instanceof R_long(int _));\n+    }\n+\n+    public static boolean wideningAndNarrowingPrimitiveConversion() {\n+        R_byte b = new R_byte((byte) 42);\n+        R_byte b2 = new R_byte((byte) -42);\n+        R_char c = new R_char((char) 42);\n+        return b instanceof R_byte(char _) && c instanceof R_char(byte _) && !(b2 instanceof R_byte(char _));\n+    }\n+\n+    public static boolean boxingConversion() {\n+        R_int i = new R_int(42);\n+\n+        return i instanceof R_int(Integer _);\n+    }\n+\n+    public static boolean boxingAndWideningReferenceConversion() {\n+        R_int i = new R_int(42);\n+        return i instanceof R_int(Object _) &&\n+                i instanceof R_int(Number _) &&\n+                i instanceof R_int(Comparable _);\n+    }\n+\n+    public static boolean unboxing() {\n+        R_Integer i = new R_Integer(Integer.valueOf(1));\n+        return i instanceof R_Integer(int _);\n+    }\n+\n+    public static boolean unboxingWithObject() {\n+        R_Object o1 = new R_Object((int) 42);\n+        R_Object o2 = new R_Object((byte) 42);\n+\n+        return o1 instanceof R_Object(int i1) &&\n+                o2 instanceof R_Object(byte b1) &&\n+                !(o1 instanceof R_Object(byte b2) &&\n+                !(o2 instanceof R_Object(int i2)));\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing() {\n+        R_generic i = new R_generic(42);\n+        return i instanceof R_generic(int _);\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndWideningPrimitive() {\n+        R_generic i = new R_generic(42);\n+        return i instanceof R_generic(double _);\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveExact() {\n+        R_ByteValue b = new R_ByteValue(Byte.valueOf((byte)42));\n+        R_ShortValue s = new R_ShortValue(Short.valueOf((short)42));\n+        R_CharacterValue c = new R_CharacterValue(Character.valueOf('a'));\n+\n+        return (b instanceof R_ByteValue(int _)) && (s instanceof R_ShortValue(int _)) && (c instanceof R_CharacterValue(int _));\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveNotExact() {\n+        int smallestIntNotRepresentable = 16777217; \/\/ 2^24 + 1\n+        R_Integer i = new R_Integer(Integer.valueOf(smallestIntNotRepresentable));\n+\n+        return i instanceof R_Integer(float _);\n+    }\n+\n+    public static boolean unboxingWhenNullAndWideningPrimitive() {\n+        R_ByteValue b = new R_ByteValue(null);\n+        R_ShortValue s = new R_ShortValue(null);\n+        R_CharacterValue c = new R_CharacterValue(null);\n+\n+        return !(b instanceof R_ByteValue(int _)) && !(s instanceof R_ShortValue(int _)) && !(c instanceof R_CharacterValue(int _));\n+    }\n+\n+    public static boolean narrowingAndUnboxing() {\n+        R_Number n = new R_Number(Byte.valueOf((byte) 42));\n+\n+        return n instanceof R_Number(byte _);\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+\n+    record R_int(int i) {}\n+    record R_byte(byte b) {}\n+    record R_short(short b) {}\n+    record R_char(char c) {}\n+    record R_long(long l) {}\n+    record R_Integer(Integer i) {}\n+    record R_Object(Object i) {}\n+    record R_generic<T extends Integer>(int i) {}\n+    record R_ByteValue(Byte b) {}\n+    record R_ShortValue(Short s) {}\n+    record R_CharacterValue(Character s) {}\n+    record R_Number(Number s) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfPatternOpWithRecordPatterns.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile PrimitiveInstanceOfTypeComparisonOp.java\n+ * @run main\/othervm PrimitiveInstanceOfTypeComparisonOp\n+ *\/\n+public class PrimitiveInstanceOfTypeComparisonOp {\n+\n+    public static void main(String[] args) {\n+        assertEquals(true,  identityPrimitiveConversion());\n+        assertEquals(true,  wideningPrimitiveConversion());\n+        assertEquals(true,  narrowingPrimitiveConversion());\n+        assertEquals(true,  wideningAndNarrowingPrimitiveConversion());\n+        assertEquals(true,  boxingConversion());\n+        assertEquals(true,  boxingAndWideningReferenceConversion());\n+        assertEquals(true,  unboxing());\n+        assertEquals(true,  unboxingWithObject());\n+        assertEquals(true,  wideningReferenceConversionUnboxing(42));\n+        assertEquals(true,  wideningReferenceConversionUnboxingAndWideningPrimitive(42));\n+        assertEquals(true,  unboxingAndWideningPrimitiveExact());\n+        assertEquals(false, unboxingAndWideningPrimitiveNotExact());\n+        assertEquals(true,  unboxingWhenNullAndWideningPrimitive());\n+        assertEquals(true,  narrowingAndUnboxing());\n+        assertEquals(true,  patternExtractRecordComponent());\n+        assertEquals(true,  exprMethod());\n+        assertEquals(true,  exprStaticallyQualified());\n+    }\n+\n+    public static boolean identityPrimitiveConversion() {\n+        int i = 42;\n+        return i instanceof int;\n+    }\n+\n+    public static boolean wideningPrimitiveConversion() {\n+        byte b = (byte) 42;\n+        short s = (short) 42;\n+        char c = 'a';\n+\n+        return b instanceof int && s instanceof int && c instanceof int;\n+    }\n+\n+    public static boolean narrowingPrimitiveConversion() {\n+        long l_within_int_range = 42L;\n+        long l_outside_int_range = 999999999999999999L;\n+\n+        return l_within_int_range instanceof int && !(l_outside_int_range instanceof int);\n+    }\n+\n+    public static boolean wideningAndNarrowingPrimitiveConversion() {\n+        byte b = (byte) 42;\n+        byte b2 = (byte) -42;\n+        char c = (char) 42;\n+        return b instanceof char && c instanceof byte && !(b2 instanceof char);\n+    }\n+\n+    public static boolean boxingConversion() {\n+        int i = 42;\n+\n+        return i instanceof Integer;\n+    }\n+\n+    public static boolean boxingAndWideningReferenceConversion() {\n+        int i = 42;\n+        return i instanceof Object &&\n+                i instanceof Number &&\n+                i instanceof Comparable;\n+    }\n+\n+    public static boolean unboxing() {\n+        Integer i = Integer.valueOf(1);\n+        return i instanceof int;\n+    }\n+\n+    public static boolean unboxingWithObject() {\n+        Object o1 = (int) 42;\n+        Object o2 = (byte) 42;\n+\n+        return o1 instanceof int i1 &&\n+                o2 instanceof byte b1 &&\n+                !(o1 instanceof byte b2 &&\n+                !(o2 instanceof int i2));\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxing(T i) {\n+        return i instanceof int;\n+    }\n+\n+    public static <T extends Integer> boolean wideningReferenceConversionUnboxingAndWideningPrimitive(T i) {\n+        return i instanceof double;\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveExact() {\n+        Byte b = Byte.valueOf((byte)42);\n+        Short s = Short.valueOf((short)42);\n+        Character c = Character.valueOf('a');\n+\n+        return (b instanceof int) && (s instanceof int) && (c instanceof int);\n+    }\n+\n+    public static boolean unboxingAndWideningPrimitiveNotExact() {\n+        int smallestIntNotRepresentable = 16777217; \/\/ 2^24 + 1\n+        Integer i = Integer.valueOf(smallestIntNotRepresentable);\n+\n+        return i instanceof float;\n+    }\n+\n+    public static boolean unboxingWhenNullAndWideningPrimitive() {\n+        Byte b = null;\n+        Short s = null;\n+        Character c = null;\n+\n+        return !(b instanceof int) && !(s instanceof int) && !(c instanceof int);\n+    }\n+\n+    public static boolean narrowingAndUnboxing() {\n+        Number n = Byte.valueOf((byte) 42);\n+\n+        return n instanceof byte;\n+    }\n+\n+    public record P(int i) { }\n+    public static boolean patternExtractRecordComponent() {\n+        Object p = new P(42);\n+        if (p instanceof P(byte b)) {\n+            return b == 42;\n+        }\n+        return false;\n+    }\n+\n+    public static int meth() {return 42;}\n+    public static boolean exprMethod() {\n+        return meth() instanceof int;\n+    }\n+\n+    public class A1 {\n+        public static int i = 42;\n+    }\n+    public static boolean exprStaticallyQualified() {\n+        return A1.i instanceof int;\n+    }\n+\n+    static void assertEquals(boolean expected, boolean actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfTypeComparisonOp.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,597 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile PrimitivePatternsSwitch.java\n+ * @run main\/othervm PrimitivePatternsSwitch\n+ *\/\n+public class PrimitivePatternsSwitch {\n+    public static void main(String[] args) {\n+        assertEquals(1,  primitiveSwitch(42));\n+        assertEquals(2,  primitiveSwitch(123));\n+        assertEquals(1,  primitiveSwitchUnnamed(42));\n+        assertEquals(2,  primitiveSwitchUnnamed(123));\n+        assertEquals(42, primitiveSwitch2());\n+        assertEquals(42, primitiveSwitch3());\n+        assertEquals(1,  primitiveSwitch4(0.0f));\n+        assertEquals(2,  primitiveSwitch4(1.0f));\n+        assertEquals(1,  primitiveSwitchUnconditionallyExact(Byte.MAX_VALUE));\n+        assertEquals(42, exhaustive0());\n+        assertEquals(1,  exhaustive1WithDefault());\n+        assertEquals(2,  exhaustive2WithDefault());\n+        assertEquals(1,  exhaustive1());\n+        assertEquals(1,  exhaustive2());\n+        assertEquals(1,  exhaustive3());\n+        assertEquals(1,  exhaustive4());\n+        assertEquals(2,  exhaustive5());\n+        assertEquals(1,  exhaustive6());\n+        assertEquals(1,  exhaustive7(true));\n+        assertEquals(1,  exhaustive7s(true));\n+        assertEquals(1,  exhaustive8(true));\n+        assertEquals(1,  exhaustive9(true));\n+        assertEquals(1,  exhaustive9(false));\n+        assertEquals(1,  exhaustiveWithRecords1());\n+        assertEquals(1,  exhaustiveWithRecords2());\n+        assertEquals(1,  exhaustiveWithRecords4());\n+        assertEquals(1,  exhaustiveWithRecords5());\n+        assertEquals(1,  exhaustiveWithRecords6());\n+        assertEquals(2,  ensureProperSelectionWithRecords());\n+        assertEquals(1,  ensureProperSelectionWithRecords2());\n+        assertEquals(3,  ensureProperSelectionWithRecords3());\n+        assertEquals(42, switchAndDowncastFromObjectPrimitive());\n+        assertEquals(42, dominationBetweenBoxedAndPrimitive());\n+        assertEquals(2,  wideningAndUnboxing());\n+        assertEquals(2,  wideningAndUnboxingInRecord());\n+        assertEquals(2,  wideningAndInferredUnboxingInRecord());\n+        assertEquals(5f, switchOverBoxedFloat(0f));\n+        assertEquals(7f, switchOverBoxedFloat(1f));\n+        assertEquals(9f, switchOverBoxedFloat(2f));\n+        assertEquals(9f, switchOverBoxedFloat(2f));\n+        assertEquals(5f, switchOverPrimitiveDouble(0d));\n+        assertEquals(7f, switchOverPrimitiveDouble(1d));\n+        assertEquals(9f, switchOverPrimitiveDouble(2d));\n+        assertEquals(1, switchOverPrimitiveChar('a'));\n+        assertEquals(-1, switchOverPrimitiveChar('x'));\n+        assertTrue(switchOverBoxedBooleanWithUnconditional(Boolean.valueOf(true)));\n+        assertTrue(switchOverBoxedBooleanWithUnconditional(true));\n+        assertTrue(!switchOverBoxedBooleanWithUnconditional(false));\n+        assertEquals(1, switchOverPrimitiveBooleanWithDefault(true));\n+        assertEquals(2, switchOverPrimitiveBooleanWithDefault(false));\n+        assertEquals(1, switchOverPrimitiveBoolean(true));\n+        assertEquals(2, switchOverPrimitiveBoolean(false));\n+        assertEquals(1, switchOverPrimitiveFloat(0.0f\/0.0f));\n+        assertEquals(2, switchOverPrimitiveFloat((float) Math.pow(0.0f\/0.0f, 0)));\n+        assertEquals(3, switchOverPrimitiveFloat(0.0f));\n+        assertEquals(4, switchOverPrimitiveFloat(-0.0f));\n+        assertEquals(1, switchRedirectedExactnessMethods1('a'));\n+        assertEquals(-1, switchRedirectedExactnessMethods1('\\u03A9'));\n+        assertEquals(1, switchRedirectedExactnessMethods2('\\u03A9'));\n+        assertEquals(-1, switchRedirectedExactnessMethods2('\\uFFFF'));\n+        assertEquals(1, switchLongAndUnconditional(32778L));\n+        assertEquals(2, switchLongAndUnconditional(42L));\n+        assertEquals(1, switchByte((byte) 128));\n+        assertEquals(2, switchByte((byte) 42));\n+        assertEquals(1, switchShort((short) 32778));\n+        assertEquals(2, switchShort((short) 42));\n+        assertEquals(1, switchInt(32778));\n+        assertEquals(2, switchInt(42));\n+        assertEquals(1, switchChar( '\\u0010'));\n+        assertEquals(2, switchChar('a'));\n+        assertEquals(1, testIntInNonEnhancedSwitchStatement(1));\n+        assertEquals(0, testIntInNonEnhancedSwitchStatement(0));\n+        assertEquals(1, testFloatInEnhancedSwitchStatement(1.0f));\n+        assertEquals(0, testFloatInEnhancedSwitchStatement(0.0f));\n+        assertEquals(1, testDoubleInEnhancedSwitchStatement(1.0d));\n+        assertEquals(0, testDoubleInEnhancedSwitchStatement(0.0d));\n+        assertEquals(1, testLongInEnhancedSwitchStatement(1l));\n+        assertEquals(0, testLongInEnhancedSwitchStatement(0l));\n+        assertEquals(1, testBooleanInEnhancedSwitchStatement(true));\n+        assertEquals(0, testBooleanInEnhancedSwitchStatement(false));\n+        assertEquals(1, testByteWrapperToIntUnconditionallyExact());\n+        assertEquals(1, testIntegerWrapperToFloat());\n+        assertEquals(-1, testIntegerWrapperToFloatInexact());\n+    }\n+\n+    public static int primitiveSwitch(int i) {\n+        return switch (i) {\n+            case int j when j == 42-> 1;\n+            case int j -> 2;\n+        };\n+    }\n+\n+    public static int primitiveSwitchUnnamed(int i) {\n+        return switch (i) {\n+            case int _ when i == 42-> 1;\n+            case int _ -> 2;\n+        };\n+    }\n+\n+    public static int primitiveSwitch2() {\n+        Object o = Integer.valueOf(42);\n+        switch (o) {\n+            case int i: return i;\n+            default: break;\n+        }\n+        return -1;\n+    }\n+\n+    public static int primitiveSwitch3() {\n+        int i = 42;\n+        switch (i) {\n+            case Integer ii: return ii;\n+        }\n+    }\n+\n+    public static int primitiveSwitch4(float f) {\n+        return switch (f) {\n+            case 0.0f -> 1;\n+            case Float fi when fi == 1f -> 2;\n+            case Float fi -> 3;\n+        };\n+    }\n+\n+    public static int primitiveSwitchUnconditionallyExact(byte c) {\n+        return switch (c) {\n+            case short _ -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive0() {\n+        Integer i = 42;\n+        switch (i) {\n+            case int j: return j;\n+        }\n+    }\n+\n+    public static int exhaustive1WithDefault() {\n+        int i = 42;\n+        return switch (i) {\n+            case byte  b -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive2WithDefault() {\n+        int i = 30000;\n+        return switch (i) {\n+            case byte  b -> 1;\n+            case short s -> 2;\n+            default -> 3;\n+        };\n+    }\n+\n+    public static int exhaustive1() {\n+        int i = 42;\n+        return switch (i) {\n+            case Integer p -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive2() {\n+        int i = 42;\n+        return switch (i) {\n+            case long d -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive3() {\n+        int i = 42;\n+        return switch (i) {\n+            case double d -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive4() {\n+        int i = 127;\n+        return switch (i) {\n+            case byte b -> 1;\n+            case double d -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive5() {\n+        int i = 127 + 1;\n+        return switch (i) {\n+            case byte b -> 1;\n+            case double d -> 2;\n+        };\n+    }\n+\n+    public static int exhaustive6() {\n+        Integer i = Integer.valueOf(42);\n+        return switch (i) {\n+            case int p -> 1;\n+        };\n+    }\n+\n+    public static int exhaustive7(Boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+            case false: return 2;  \/\/ with reminder, null, OK\n+        }\n+    }\n+\n+    public static int exhaustive7s(Boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;      \/\/ with reminder, null, OK\n+        };\n+    }\n+\n+    public static int exhaustive8(Boolean b) {\n+        switch (b) {\n+            case boolean bb: return 1;\n+        }\n+    }\n+\n+    public static int exhaustive9(boolean b) {\n+        switch (b) {\n+            case Boolean bb: return 1;\n+        }\n+    }\n+\n+    public static int exhaustiveWithRecords1() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because Integer exhaustive at type int\n+            case R_int(Integer x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords2() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because double unconditional at int\n+            case R_int(double x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords4() {\n+        R_Integer r = new R_Integer(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because R_Integer(int) exhaustive at type R_Integer(Integer), because int exhaustive at type Integer\n+            case R_Integer(int x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords5() {\n+        R_Integer r = new R_Integer(42);\n+        return switch (r) {\n+            \/\/ exhaustive, because double exhaustive at Integer\n+            case R_Integer(double x) -> 1;\n+        };\n+    }\n+\n+    public static int exhaustiveWithRecords6() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) -> 2;\n+        };\n+    }\n+\n+    public static int ensureProperSelectionWithRecords() {\n+        R_int r = new R_int(4242);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) -> 2;\n+        };\n+    }\n+\n+    public static int ensureProperSelectionWithRecords2() {\n+        R_double r = new R_double(42);\n+        switch (r) {\n+            case R_double(int i):\n+                return meth_int(i);\n+            case R_double(double x):\n+                return meth_double(x);\n+        }\n+    }\n+\n+    public static int ensureProperSelectionWithRecords3() {\n+        R_int r = new R_int(4242);\n+        return switch (r) {\n+            case R_int(byte x) -> 1;\n+            case R_int(int x) when x == 236 -> 2;\n+            case R_int(int x) -> 3;\n+        };\n+    }\n+\n+    public static int meth_int(int i) { return 1; }\n+    public static int meth_double(double d) { return 2;}\n+\n+    public static int switchAndDowncastFromObjectPrimitive() {\n+        Object i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static int dominationBetweenBoxedAndPrimitive() {\n+        Object i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            case byte ip     -> ip;\n+            default -> -1;\n+        };\n+    }\n+\n+    static int wideningAndUnboxing() {\n+        Number o = Integer.valueOf(42);\n+        return switch (o) {\n+            case byte b -> 1;\n+            case int i -> 2;\n+            case float f -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    static int wideningAndUnboxingInRecord() {\n+        Box<Number> box = new Box<>(Integer.valueOf(42));\n+        return switch (box) {\n+            case Box<Number>(byte b) -> 1;\n+            case Box<Number>(int i) -> 2;\n+            case Box<Number>(float f) -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    static int wideningAndInferredUnboxingInRecord() {\n+        Box<Number> box = new Box<>(Integer.valueOf(42));\n+        return switch (box) {\n+            case Box(byte b) -> 1;\n+            case Box(int i) -> 2;\n+            case Box(float f) -> 3;\n+            default -> 4;\n+        };\n+    }\n+\n+    public static float switchOverBoxedFloat(Float f) {\n+        return switch (f) {\n+            case 0f -> 5f + 0f;\n+            case Float fi when fi == 1f -> 6f + fi;\n+            case Float fi -> 7f + fi;\n+        };\n+    }\n+\n+    public static double switchOverPrimitiveDouble(Double d) {\n+        return switch (d) {\n+            case 0d -> 5d + 0d;\n+            case Double di when di == 1d -> 6d + di;\n+            case Double di -> 7d + di;\n+        };\n+    }\n+\n+    public static boolean switchOverBoxedBooleanWithUnconditional(Boolean b) {\n+        return switch (b) {\n+            case true -> true;\n+            case Boolean bi -> bi;\n+        };\n+    }\n+\n+    public static int switchOverPrimitiveBooleanWithDefault(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            default -> 2;\n+        };\n+    }\n+\n+    public static int switchOverPrimitiveBoolean(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+        };\n+    }\n+\n+    public static int switchOverPrimitiveChar(char c) {\n+        return switch (c) {\n+            case 'a' -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static final float NaNconstant = Float.NaN;\n+    public static int switchOverPrimitiveFloat(float f) {\n+        return switch (f) {\n+            case NaNconstant -> 1;\n+            case 1.0f -> 2;\n+            case 0.0f -> 3;\n+            case -0.0f -> 4;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.char_byte is properly redirected to int_byte\n+    public static int switchRedirectedExactnessMethods1(char c) {\n+        return switch (c) {\n+            case byte _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.char_short is properly redirected to int_short\n+    public static int switchRedirectedExactnessMethods2(char c) {\n+        return switch (c) {\n+            case short _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    \/\/ tests that Exactness.short_byte is properly redirected to int_byte\n+    public static int switchRedirectedExactnessMethods2(short c) {\n+        return switch (c) {\n+            case byte _ -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static int switchLongAndUnconditional(long l) {\n+        return switch (l) {\n+            case 32778L -> 1;\n+            case long c -> 2;\n+        };\n+    }\n+\n+    public static int switchByte(byte b) {\n+        return switch (b) {\n+            case (byte)128 -> 1;\n+            case byte c -> 2;\n+        };\n+    }\n+\n+    public static int switchShort(short s) {\n+        return switch (s) {\n+            case (short)32778 -> 1;\n+            case short c -> 2;\n+        };\n+    }\n+\n+    public static int switchInt(int i) {\n+        return switch (i) {\n+            case 32778 -> 1;\n+            case int c -> 2;\n+        };\n+    }\n+\n+    public static int switchChar(char c) {\n+        return switch (c) {\n+            case '\\u0010' -> 1;\n+            case char cc -> 2;\n+        };\n+    }\n+\n+    public static int testIntInNonEnhancedSwitchStatement(int v1) {\n+        int i = 0;\n+        switch (v1) {\n+            case 1:\n+                i = 1;\n+                break;\n+        }\n+        return i;\n+    }\n+\n+    public static int testFloatInEnhancedSwitchStatement(float v1) {\n+        int i = 0;\n+        switch (v1) {\n+            case 1.0f:\n+                i = 1;\n+                break;\n+            default:\n+                i = 0;\n+        }\n+        return i;\n+    }\n+\n+    public static int testDoubleInEnhancedSwitchStatement(double v1) {\n+        int i = 0;\n+        switch (v1) {\n+            case 1d:\n+                i = 1;\n+                break;\n+            default:\n+                i = 0;\n+        }\n+        return i;\n+    }\n+\n+    public static int testLongInEnhancedSwitchStatement(long v1) {\n+        int i = 0;\n+        switch (v1) {\n+            case 1l:\n+                i = 1;\n+                break;\n+            default:\n+                i = 0;\n+        }\n+        return i;\n+    }\n+\n+    public static int testBooleanInEnhancedSwitchStatement(boolean v1) {\n+        int i = 0;\n+        switch (v1) {\n+            case true:\n+                i = 1;\n+                break;\n+            default:\n+                i = 0;\n+        }\n+        return i;\n+    }\n+\n+    public static int testByteWrapperToIntUnconditionallyExact() {\n+        Byte b = Byte.valueOf((byte) 42);\n+        return switch (b) {\n+            case int p -> 1;\n+        };\n+    }\n+\n+    public static int testIntegerWrapperToFloat() {\n+        Integer i = Integer.valueOf(42);\n+        return switch (i) {\n+            case float p -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static int testIntegerWrapperToFloatInexact() {\n+        Integer i = Integer.valueOf(Integer.MAX_VALUE);\n+        return switch (i) {\n+            case float p -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+\n+    record R_Integer(Integer x) {}\n+    record R_int(int x) {}\n+    record R_double(double x) {}\n+    record Box<N extends Number>(N num) {}\n+\n+    static void assertEquals(int expected, int actual) {\n+        if (expected != actual) {\n+            throw new AssertionError(\"Expected: \" + expected + \", actual: \" + actual);\n+        }\n+    }\n+\n+    static void assertEquals(float expected, float actual) {\n+        if (Float.compare(expected, actual) != 0) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    static void assertEquals(double expected, double actual) {\n+        if (Double.compare(expected, actual) != 0) {\n+            throw new AssertionError(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n+    static void assertTrue(boolean actual) {\n+        if (!actual) {\n+            throw new AssertionError(\"Expected: true, but got false\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitch.java","additions":597,"deletions":0,"binary":false,"changes":597,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8304487\n+ * @summary Compiler Implementation for Primitive types in patterns, instanceof, and switch (Preview)\n+ * @enablePreview\n+ * @compile\/fail\/ref=PrimitivePatternsSwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitivePatternsSwitchErrors.java\n+ *\/\n+public class PrimitivePatternsSwitchErrors {\n+    record R_int(int x) {}\n+\n+    public static void dominationBetweenPrimitivePatterns() {\n+        int i = 42;\n+        switch (i) {\n+            case short s -> System.out.println(\"its a short\");\n+            case byte b  -> System.out.println(\"its a byte\"); \/\/ Error - dominated!\n+            default      -> System.out.println(\"any other integral value\");\n+        }\n+    }\n+\n+    public static int dominationWithRecordPatterns() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(int x) -> 1;\n+            case R_int(byte x) -> 2;  \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int inconvertibleNestedComponent() {\n+        R_int r = new R_int(42);\n+        return switch (r) {\n+            case R_int(Long x) -> 1; \/\/ inconvertible\n+        };\n+    }\n+\n+    public static int nonExhaustive1() {\n+        int i = 42;\n+        return switch (i) {  \/\/ Error - not exhaustive\n+            case short s -> s;\n+        };\n+    }\n+\n+    public static int nonExhaustive2() {\n+        int i = 42;\n+        return switch (i) { \/\/ Error - not exhaustive\n+            case byte  b -> 1;\n+            case short s -> 2;\n+        };\n+    }\n+\n+    public static int nonExhaustive3() {\n+        int i = 42;\n+        return switch (i) { \/\/ Error - not exhaustive\n+            case byte  b -> 1;\n+            case float f -> 2;\n+        };\n+    }\n+\n+    public static int dominationBetweenBoxedAndPrimitive() {\n+        int i = 42;\n+        return switch (i) {\n+            case Integer ib  -> ib;\n+            case byte ip     -> ip; \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int constantDominatedWithPrimitivePattern() {\n+        int i = 42;\n+        return switch (i) {\n+            case int j -> 42;\n+            case 43    -> -1;   \/\/ Error - dominated!\n+        };\n+    }\n+\n+    public static int constantDominatedWithFloatPrimitivePattern() {\n+        float f = 42.0f;\n+        return switch (f) {\n+            case Float ff -> 42;\n+            case 43.0f    -> -1;   \/\/ Error - dominated!\n+        };\n+    }\n+\n+    void switchLongOverByte(byte b) {\n+        switch (b) {\n+            case 0L: return ;\n+        }\n+    }\n+\n+    void switchOverPrimitiveFloatFromInt(float f) {\n+        switch (f) {\n+            case 16777216:\n+                break;\n+            case 16777217:\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    void switchOverNotRepresentableFloat(Float f) {\n+        switch (f) {\n+            case 1.0f:\n+                break;\n+            case 0.999999999f:\n+                break;\n+            case Float fi:\n+                break;\n+        }\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedDefault(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+            default -> 3;\n+        };\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedDefaultStatement(boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+            case false: return 2;\n+            default: return 3;\n+        }\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedUnconditionalStatement(boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+            case false: return 2;\n+            case boolean bb: return 3; \/\/ error\n+        }\n+    }\n+\n+    void switchCombinationsNonIntegral() {\n+        float f = 0f;\n+        long l = 0L;\n+        double d = 0d;\n+        Float fB = 0F;\n+        Long lB = 0L;\n+        Double dB = 0D;\n+\n+        switch (f) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (l) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (d) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (fB) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (lB) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+\n+        switch (dB) {\n+            case 1l: return;\n+            case 2f: return;\n+            case 3d: return;\n+            default:\n+        }\n+    }\n+\n+    int switchOverPrimitiveBooleanExhaustiveWithNonPermittedUnconditional(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+            case false -> 2;\n+            case boolean bb -> 3; \/\/ error\n+        };\n+    }\n+\n+    int duplicateUnconditionalWithPrimitives(int i) {\n+        return switch (i) {\n+            case int ii -> 1;\n+            case long l -> 2; \/\/ error\n+        };\n+    }\n+\n+    int booleanSingleCase1(boolean b) {\n+        return switch (b) {\n+            case true -> 1;\n+        };\n+    }\n+\n+    int booleanSingleCase2(boolean b) {\n+        switch (b) {\n+            case true: return 1;\n+        }\n+    }\n+\n+    void nullAndPrimitive() {\n+        int i = 42;\n+        switch (i) {\n+            case short s -> System.out.println(\"its a short\");\n+            case null    -> System.out.println(\"oops\");\n+            default      -> System.out.println(\"any other integral value\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+PrimitivePatternsSwitchErrors.java:15:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:24:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:31:24: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Long)\n+PrimitivePatternsSwitchErrors.java:62:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:70:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:78:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:84:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: long, byte)\n+PrimitivePatternsSwitchErrors.java:90:18: compiler.err.constant.label.not.compatible: int, float\n+PrimitivePatternsSwitchErrors.java:92:18: compiler.err.constant.label.not.compatible: int, float\n+PrimitivePatternsSwitchErrors.java:103:13: compiler.err.duplicate.case.label\n+PrimitivePatternsSwitchErrors.java:114:13: compiler.err.default.and.both.boolean.values\n+PrimitivePatternsSwitchErrors.java:122:13: compiler.err.default.and.both.boolean.values\n+PrimitivePatternsSwitchErrors.java:130:18: compiler.err.unconditional.pattern.and.both.boolean.values\n+PrimitivePatternsSwitchErrors.java:143:18: compiler.err.constant.label.not.compatible: long, float\n+PrimitivePatternsSwitchErrors.java:145:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: double, float)\n+PrimitivePatternsSwitchErrors.java:151:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: float, long)\n+PrimitivePatternsSwitchErrors.java:152:18: compiler.err.prob.found.req: (compiler.misc.possible.loss.of.precision: double, long)\n+PrimitivePatternsSwitchErrors.java:157:18: compiler.err.constant.label.not.compatible: long, double\n+PrimitivePatternsSwitchErrors.java:158:18: compiler.err.constant.label.not.compatible: float, double\n+PrimitivePatternsSwitchErrors.java:164:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, java.lang.Float)\n+PrimitivePatternsSwitchErrors.java:166:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, java.lang.Float)\n+PrimitivePatternsSwitchErrors.java:172:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, java.lang.Long)\n+PrimitivePatternsSwitchErrors.java:173:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: double, java.lang.Long)\n+PrimitivePatternsSwitchErrors.java:178:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: long, java.lang.Double)\n+PrimitivePatternsSwitchErrors.java:179:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: float, java.lang.Double)\n+PrimitivePatternsSwitchErrors.java:189:18: compiler.err.unconditional.pattern.and.both.boolean.values\n+PrimitivePatternsSwitchErrors.java:196:18: compiler.err.duplicate.unconditional.pattern\n+PrimitivePatternsSwitchErrors.java:216:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: compiler.misc.type.null, int)\n+PrimitivePatternsSwitchErrors.java:30:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:37:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:44:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:52:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:201:16: compiler.err.not.exhaustive\n+PrimitivePatternsSwitchErrors.java:207:9: compiler.err.not.exhaustive.statement\n+- compiler.note.preview.filename: PrimitivePatternsSwitchErrors.java, DEFAULT\n+- compiler.note.preview.recompile\n+34 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.out","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -131,0 +131,199 @@\n+    @Test\n+    public void testNestedPrimitive1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       if (r instanceof R(byte b)) {\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:28: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testNestedPrimitive2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       switch (r) {\n+                           case R(byte b) -> {}\n+                           default -> {}\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:20: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testNestedPrimitive3(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       if (r instanceof R(long l)) {\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:28: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testNestedPrimitive4(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(R r) {\n+                       switch (r) {\n+                           case R(long l) -> {}\n+                           default -> {}\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:20: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitive2Reference1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(int i) {\n+                       if (i instanceof Integer j) {}\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:13: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitive2Reference2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(int i) {\n+                       switch (i) {\n+                           case Integer j -> {}\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testReference2Primitive1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Integer i) {\n+                       if (i instanceof int j) {}\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testReference2Primitive2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Integer i) {\n+                       switch (i) {\n+                           case int j -> {}\n+                       }\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitivePatternObject1(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object o) {\n+                       if (o instanceof int j) {}\n+                   }\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:4:26: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testPrimitivePatternObject2(Path base) throws Exception {\n+        doTest(base,\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private void test(Object o) {\n+                       switch (o) {\n+                           case int j -> {}\n+                       }\n+                   }\n+                   record R(int i) {}\n+               }\n+               \"\"\",\n+               21,\n+               \"Test.java:5:18: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+               \"1 error\");\n+    }\n+\n+    @Test\n+    public void testOtherPrimitives(Path base) throws Exception {\n+        for (String type : new String[] {\"boolean\", \"long\", \"float\", \"double\"}) {\n+            doTest(base,\n+                   \"\"\"\n+                   package test;\n+                   public class Test {\n+                       private void test($type v) {\n+                           switch (v) {\n+                               default -> {}\n+                           }\n+                       }\n+                   }\n+                   \"\"\".replace(\"$type\", type),\n+                   21,\n+                   \"Test.java:4:16: compiler.err.preview.feature.disabled.plural: (compiler.misc.feature.primitive.patterns)\",\n+                   \"1 error\");\n+        }\n+    }\n+\n@@ -132,0 +331,4 @@\n+        doTest(base, testCode, 17, expectedErrors);\n+    }\n+\n+    private void doTest(Path base, String testCode, int sourceLevel, String... expectedErrors) throws IOException {\n@@ -141,1 +344,1 @@\n-                    .options(\"--release\", \"17\",\n+                    .options(\"--release\", \"\" + sourceLevel,\n","filename":"test\/langtools\/tools\/javac\/patterns\/SourceLevelChecks.java","additions":204,"deletions":1,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -130,6 +130,0 @@\n-    void primitivePattern(Object o) {\n-        switch (o) {\n-            case int i: break;\n-            default: break;\n-        }\n-    }\n@@ -242,10 +236,0 @@\n-    void primitiveToReference(int i) {\n-        switch (i) {\n-            case Integer j: break;\n-        }\n-    }\n-    void referenceToPrimitive(Integer i) {\n-        switch (i) {\n-            case int j: break;\n-        }\n-    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4,9 +4,11 @@\n-SwitchErrors.java:138:28: compiler.err.default.label.not.allowed\n-SwitchErrors.java:144:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:149:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:154:18: compiler.err.default.label.not.allowed\n-SwitchErrors.java:213:29: compiler.err.default.label.not.allowed\n-SwitchErrors.java:220:32: compiler.err.default.label.not.allowed\n-SwitchErrors.java:227:32: compiler.err.default.label.not.allowed\n-SwitchErrors.java:283:20: compiler.err.illegal.start.of.type\n-SwitchErrors.java:286:28: compiler.err.illegal.start.of.type\n+SwitchErrors.java:132:28: compiler.err.default.label.not.allowed\n+SwitchErrors.java:138:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:143:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:148:18: compiler.err.default.label.not.allowed\n+SwitchErrors.java:207:29: compiler.err.default.label.not.allowed\n+SwitchErrors.java:214:32: compiler.err.default.label.not.allowed\n+SwitchErrors.java:221:32: compiler.err.default.label.not.allowed\n+SwitchErrors.java:267:20: compiler.err.illegal.start.of.type\n+SwitchErrors.java:270:28: compiler.err.illegal.start.of.type\n+SwitchErrors.java:290:42: compiler.err.expected2: :, ->\n+SwitchErrors.java:299:45: compiler.err.expected2: :, ->\n@@ -14,2 +16,0 @@\n-SwitchErrors.java:315:45: compiler.err.expected2: :, ->\n-SwitchErrors.java:322:42: compiler.err.expected2: :, ->\n@@ -39,24 +39,21 @@\n-SwitchErrors.java:132:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-SwitchErrors.java:143:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:149:27: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:155:18: compiler.err.flows.through.to.pattern\n-SwitchErrors.java:167:18: compiler.err.pattern.expected\n-SwitchErrors.java:173:78: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:179:73: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n-SwitchErrors.java:186:21: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:197:13: compiler.err.unconditional.pattern.and.default\n-SwitchErrors.java:195:29: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:204:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:220:21: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:227:29: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:239:18: compiler.err.duplicate.unconditional.pattern\n-SwitchErrors.java:244:18: compiler.err.prob.found.req: (compiler.misc.not.applicable.types: int, java.lang.Integer)\n-SwitchErrors.java:249:18: compiler.err.type.found.req: int, (compiler.misc.type.req.class.array)\n-SwitchErrors.java:255:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:262:24: compiler.err.invalid.case.label.combination\n-SwitchErrors.java:269:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:276:18: compiler.err.flows.through.from.pattern\n-SwitchErrors.java:292:49: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n-SwitchErrors.java:294:55: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n-SwitchErrors.java:300:26: compiler.err.pattern.type.cannot.infer\n-SwitchErrors.java:315:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:137:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:143:27: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:149:18: compiler.err.flows.through.to.pattern\n+SwitchErrors.java:161:18: compiler.err.pattern.expected\n+SwitchErrors.java:167:78: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:173:73: compiler.err.cant.resolve.location: kindname.variable, n, , , (compiler.misc.location: kindname.class, SwitchErrors, null)\n+SwitchErrors.java:180:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:191:13: compiler.err.unconditional.pattern.and.default\n+SwitchErrors.java:189:29: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:198:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:214:21: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:221:29: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:233:18: compiler.err.duplicate.unconditional.pattern\n+SwitchErrors.java:239:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:246:24: compiler.err.invalid.case.label.combination\n+SwitchErrors.java:253:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:260:18: compiler.err.flows.through.from.pattern\n+SwitchErrors.java:276:49: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:278:55: compiler.err.cant.resolve.location.args: kindname.method, length, , , (compiler.misc.location: kindname.class, java.lang.Object, null)\n+SwitchErrors.java:284:26: compiler.err.pattern.type.cannot.infer\n+SwitchErrors.java:299:21: compiler.err.invalid.case.label.combination\n@@ -73,3 +70,3 @@\n-SwitchErrors.java:159:9: compiler.err.not.exhaustive.statement\n-SwitchErrors.java:232:9: compiler.err.not.exhaustive.statement\n-74 errors\n\\ No newline at end of file\n+SwitchErrors.java:153:9: compiler.err.not.exhaustive.statement\n+SwitchErrors.java:226:9: compiler.err.not.exhaustive.statement\n+71 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.out","additions":35,"deletions":38,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * @test \/nodynamiccopyright\/\n- * @bug 8206986\n- * @summary Verify switch over boolean\/long\/float\/double is not allowed.\n- * @compile\/fail\/ref=SwitchNoExtraTypes.out -XDrawDiagnostics SwitchNoExtraTypes.java\n- *\/\n-\n-public class SwitchNoExtraTypes {\n-\n-    private void switchBoolean(boolean b) {\n-        switch (b) {\n-            case true: return ;\n-        }\n-    }\n-\n-    private void switchLong(long l) {\n-        switch (l) {\n-            case 0: return ;\n-        }\n-    }\n-\n-    private void switchFloat(float f) {\n-        switch (f) {\n-            case 0: return ;\n-        }\n-    }\n-\n-    private void switchDouble(double d) {\n-        switch (d) {\n-            case 0: return ;\n-        }\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,5 +0,0 @@\n-SwitchNoExtraTypes.java:11:16: compiler.err.selector.type.not.allowed: boolean\n-SwitchNoExtraTypes.java:17:16: compiler.err.selector.type.not.allowed: long\n-SwitchNoExtraTypes.java:23:16: compiler.err.selector.type.not.allowed: float\n-SwitchNoExtraTypes.java:29:16: compiler.err.selector.type.not.allowed: double\n-4 errors\n","filename":"test\/langtools\/tools\/javac\/switchextra\/SwitchNoExtraTypes.out","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.preview.patterns;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * Tests Exactness methods\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations=5, time=1)\n+@Measurement(iterations=5, time=1)\n+@Threads(2)\n+@Fork(value = 1,\n+      jvmArgsPrepend = {\"-Djmh.blackhole.mode=COMPILER\",\n+                        \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class Exactness {\n+\n+    private static boolean int_float_based_on_leading_trailing(int n) {\n+        if (n == Integer.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Float.PRECISION >= \/\/ 24\n+                (32 - (Integer.numberOfLeadingZeros(n) +\n+                        Integer.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_int_float_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(int_float_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean int_float_based_on_filtering(int n) {\n+        return n == (int)(float)n && n != Integer.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_int_float_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(int_float_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean long_float_based_on_leading_trailing(long n) {\n+        if (n == Long.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Float.PRECISION >= \/\/ 24\n+                (64 - (Long.numberOfLeadingZeros(n) +\n+                        Long.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_long_float_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_float_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean long_float_based_on_filtering(long n) {\n+        return n == (long)(float)n && n != Long.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_long_float_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_float_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean long_double_based_on_leading_trailing(long n) {\n+        if (n == Long.MIN_VALUE)\n+            return true;\n+        n = Math.abs(n);\n+        return Double.PRECISION >= \/\/ 53\n+                (64 - (Long.numberOfLeadingZeros(n) +\n+                        Long.numberOfTrailingZeros(n))) ;\n+    }\n+    @Benchmark\n+    public void test_long_double_based_on_leading_trailing(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_double_based_on_leading_trailing(n));\n+        }\n+    }\n+\n+    private static boolean long_double_based_on_filtering(long n) {\n+        return n == (long)(double)n && n != Long.MAX_VALUE;\n+    }\n+    @Benchmark\n+    public void test_long_double_based_on_filtering(Blackhole bh) {\n+        for(int n = Integer.MIN_VALUE; n < Integer.MAX_VALUE; n++) {\n+            bh.consume(long_double_based_on_filtering(n));\n+        }\n+    }\n+\n+    private static boolean float_int_based_on_compare(float n) {\n+        return Double.compare((double)n, (double)((int)n)) == 0;\n+    }\n+    @Benchmark\n+    public void test_float_int_based_on_compare(Blackhole bh) {\n+        float n = -Float.MAX_VALUE;\n+        while (n <= Float.MAX_VALUE) {\n+            bh.consume(float_int_based_on_compare(n));\n+            n = Math.nextUp(n);\n+        }\n+    }\n+\n+    private static boolean isNegativeZero(float n) {\n+        return Float.floatToRawIntBits(n) == Integer.MIN_VALUE;\n+    }\n+    private static boolean float_int_based_on_filtering(float n) {\n+        return n == (float)(int)n && n != 0x1p31f && !isNegativeZero(n);\n+    }\n+    @Benchmark\n+    public void test_float_int_based_on_filtering(Blackhole bh) {\n+        float n = -Float.MAX_VALUE;\n+        while (n <= Float.MAX_VALUE) {\n+            bh.consume(float_int_based_on_filtering(n));\n+            n = Math.nextUp(n);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/preview\/patterns\/Exactness.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"}]}