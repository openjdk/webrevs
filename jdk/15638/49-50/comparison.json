{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.classfile.CodeBuilder;\n@@ -44,0 +45,1 @@\n+import java.util.function.Consumer;\n@@ -170,1 +172,1 @@\n-        MethodHandle target = generateInnerClass(lookup, selectorType, labels);\n+        MethodHandle target = generateTypeSwitch(lookup, selectorType, labels);\n@@ -288,1 +290,1 @@\n-                                                                            generateInnerClass(lookup, invocationType.parameterType(0), labels),\n+                                                                            generateTypeSwitch(lookup, invocationType.parameterType(0), labels),\n@@ -292,1 +294,1 @@\n-            target = generateInnerClass(lookup, invocationType.parameterType(0), labels);\n+            target = generateTypeSwitch(lookup, invocationType.parameterType(0), labels);\n@@ -403,159 +405,58 @@\n-    @SuppressWarnings(\"removal\")\n-    private static MethodHandle generateInnerClass(MethodHandles.Lookup caller, Class<?> selectorType, Object[] labels) {\n-        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n-        List<Class<?>> extraClassLabels = new ArrayList<>();\n-\n-        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n-            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n-               .withMethodBody(\"typeSwitch\",\n-                               TYPES_SWITCH_DESCRIPTOR,\n-                               ClassFile.ACC_FINAL | ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n-                               cb -> {\n-                    cb.aload(0);\n-                    Label nonNullLabel = cb.newLabel();\n-                    cb.if_nonnull(nonNullLabel);\n-                    cb.iconst_m1();\n-                    cb.ireturn();\n-                    cb.labelBinding(nonNullLabel);\n-                    if (labels.length == 0) {\n-                        cb.constantInstruction(0)\n-                          .ireturn();\n-                        return ;\n-                    }\n-                    cb.iload(1);\n-                    Label dflt = cb.newLabel();\n-                    record Element(Label target, Label next, Object caseLabel) {}\n-                    List<Element> cases = new ArrayList<>();\n-                    List<SwitchCase> switchCases = new ArrayList<>();\n-                    Object lastLabel = null;\n-                    for (int idx = labels.length - 1; idx >= 0; idx--) {\n-                        Object currentLabel = labels[idx];\n-                        Label target = cb.newLabel();\n-                        Label next;\n-                        if (lastLabel == null) {\n-                            next = dflt;\n-                        } else if (lastLabel.equals(currentLabel)) {\n-                            next = cases.getLast().next();\n-                        } else {\n-                            next = cases.getLast().target();\n-                        }\n-                        lastLabel = currentLabel;\n-                        cases.add(new Element(target, next, currentLabel));\n-                        switchCases.add(SwitchCase.of(idx, target));\n-                    }\n-                    cases = cases.reversed();\n-                    switchCases = switchCases.reversed();\n-                    cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n-                    for (int idx = 0; idx < cases.size(); idx++) {\n-                        Element element = cases.get(idx);\n-                        Label next = element.next();\n-                        cb.labelBinding(element.target());\n-                        if (element.caseLabel() instanceof Class<?> classLabel) {\n-                            if (unconditionalExactnessCheck(selectorType, classLabel)) {\n-                                \/\/nothing - unconditionally use this case\n-                            } else if (classLabel.isPrimitive()) {\n-                                if (!selectorType.isPrimitive() && !Wrapper.isWrapperNumericOrBooleanType(selectorType)) {\n-                                    \/\/ Object o = ...\n-                                    \/\/ o instanceof Wrapped(float)\n-                                    cb.aload(0);\n-                                    cb.instanceof_(Wrapper.forBasicType(classLabel)\n-                                                          .wrapperType()\n-                                                          .describeConstable()\n-                                                          .orElseThrow());\n-                                    cb.ifeq(next);\n-                                } else if (!unconditionalExactnessCheck(Wrapper.asPrimitiveType(selectorType), classLabel)) {\n-                                    \/\/ Integer i = ... or int i = ...\n-                                    \/\/ o instanceof float\n-                                    Label notNumber = cb.newLabel();\n-                                    cb.aload(0);\n-                                    cb.instanceof_(ConstantDescs.CD_Number);\n-                                    if (selectorType == long.class || selectorType == float.class || selectorType == double.class) {\n-                                        cb.ifeq(next);\n-                                    } else {\n-                                        cb.ifeq(notNumber);\n-                                    }\n-                                    cb.aload(0);\n-                                    cb.checkcast(ConstantDescs.CD_Number);\n-                                    if (selectorType == long.class) {\n-                                        cb.invokevirtual(ConstantDescs.CD_Number,\n-                                                     \"longValue\",\n-                                                     MethodTypeDesc.of(ConstantDescs.CD_long));\n-                                    } else if (selectorType == float.class) {\n-                                        cb.invokevirtual(ConstantDescs.CD_Number,\n-                                                     \"floatValue\",\n-                                                     MethodTypeDesc.of(ConstantDescs.CD_float));\n-                                    } else if (selectorType == double.class) {\n-                                        cb.invokevirtual(ConstantDescs.CD_Number,\n-                                                     \"doubleValue\",\n-                                                     MethodTypeDesc.of(ConstantDescs.CD_double));\n-                                    } else {\n-                                        Label compare = cb.newLabel();\n-                                        cb.invokevirtual(ConstantDescs.CD_Number,\n-                                                         \"intValue\",\n-                                                         MethodTypeDesc.of(ConstantDescs.CD_int));\n-                                        cb.goto_(compare);\n-                                        cb.labelBinding(notNumber);\n-                                        cb.aload(0);\n-                                        cb.instanceof_(ConstantDescs.CD_Character);\n-                                        cb.ifeq(next);\n-                                        cb.aload(0);\n-                                        cb.checkcast(ConstantDescs.CD_Character);\n-                                        cb.invokevirtual(ConstantDescs.CD_Character,\n-                                                         \"charValue\",\n-                                                         MethodTypeDesc.of(ConstantDescs.CD_char));\n-                                        cb.labelBinding(compare);\n-                                    }\n-\n-                                    TypePairs typePair = TypePairs.of(Wrapper.asPrimitiveType(selectorType), classLabel);\n-                                    String methodName = typePairToName.get(typePair);\n-                                    cb.invokestatic(ExactConversionsSupport.class.describeConstable().orElseThrow(),\n-                                                    methodName,\n-                                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, typePair.from.describeConstable().orElseThrow()));\n-                                    cb.ifeq(next);\n-                                }\n-                            } else {\n-                                Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n-                                if (classLabelConstableOpt.isPresent()) {\n-                                    cb.aload(0);\n-                                    cb.instanceof_(classLabelConstableOpt.orElseThrow());\n-                                    cb.ifeq(next);\n-                                } else {\n-                                    cb.aload(3);\n-                                    cb.constantInstruction(extraClassLabels.size());\n-                                    cb.invokeinterface(ConstantDescs.CD_List,\n-                                                       \"get\",\n-                                                       MethodTypeDesc.of(ConstantDescs.CD_Object,\n-                                                                         ConstantDescs.CD_int));\n-                                    cb.checkcast(ConstantDescs.CD_Class);\n-                                    cb.aload(0);\n-                                    cb.invokevirtual(ConstantDescs.CD_Class,\n-                                                     \"isInstance\",\n-                                                     MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                                       ConstantDescs.CD_Object));\n-                                    cb.ifeq(next);\n-                                    extraClassLabels.add(classLabel);\n-                                }\n-                            }\n-                        } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n-                            int enumIdx = enumDescs.size();\n-                            enumDescs.add(enumLabel);\n-                            cb.aload(2);\n-                            cb.constantInstruction(enumIdx);\n-                            cb.invokestatic(ConstantDescs.CD_Integer,\n-                                            \"valueOf\",\n-                                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n-                                                              ConstantDescs.CD_int));\n-                            cb.aload(0);\n-                            cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n-                                               \"test\",\n-                                               MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                                 ConstantDescs.CD_Object,\n-                                                                 ConstantDescs.CD_Object));\n-                            cb.ifeq(next);\n-                        } else if (element.caseLabel() instanceof String stringLabel) {\n-                            cb.ldc(stringLabel);\n-                            cb.aload(0);\n-                            cb.invokevirtual(ConstantDescs.CD_Object,\n-                                             \"equals\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                               ConstantDescs.CD_Object));\n+    private static Consumer<CodeBuilder> generateTypeSwitchSkeleton(Class<?> selectorType, Object[] labelConstants, List<EnumDesc<?>> enumDescs, List<Class<?>> extraClassLabels) {\n+        int SELECTOR_OBJ        = 0;\n+        int RESTART_IDX         = 1;\n+        int ENUM_CACHE          = 2;\n+        int EXTRA_CLASS_LABELS  = 3;\n+\n+        return cb -> {\n+            cb.aload(SELECTOR_OBJ);\n+            Label nonNullLabel = cb.newLabel();\n+            cb.if_nonnull(nonNullLabel);\n+            cb.iconst_m1();\n+            cb.ireturn();\n+            cb.labelBinding(nonNullLabel);\n+            if (labelConstants.length == 0) {\n+                cb.constantInstruction(0)\n+                        .ireturn();\n+                return;\n+            }\n+            cb.iload(RESTART_IDX);\n+            Label dflt = cb.newLabel();\n+            record Element(Label target, Label next, Object caseLabel) { }\n+            List<Element> cases = new ArrayList<>();\n+            List<SwitchCase> switchCases = new ArrayList<>();\n+            Object lastLabel = null;\n+            for (int idx = labelConstants.length - 1; idx >= 0; idx--) {\n+                Object currentLabel = labelConstants[idx];\n+                Label target = cb.newLabel();\n+                Label next;\n+                if (lastLabel == null) {\n+                    next = dflt;\n+                } else if (lastLabel.equals(currentLabel)) {\n+                    next = cases.getLast().next();\n+                } else {\n+                    next = cases.getLast().target();\n+                }\n+                lastLabel = currentLabel;\n+                cases.add(new Element(target, next, currentLabel));\n+                switchCases.add(SwitchCase.of(idx, target));\n+            }\n+            cases = cases.reversed();\n+            switchCases = switchCases.reversed();\n+            cb.tableswitch(0, labelConstants.length - 1, dflt, switchCases);\n+            for (int idx = 0; idx < cases.size(); idx++) {\n+                Element element = cases.get(idx);\n+                Label next = element.next();\n+                cb.labelBinding(element.target());\n+                if (element.caseLabel() instanceof Class<?> classLabel) {\n+                    if (unconditionalExactnessCheck(selectorType, classLabel)) {\n+                        \/\/nothing - unconditionally use this case\n+                    } else if (classLabel.isPrimitive()) {\n+                        if (!selectorType.isPrimitive() && !Wrapper.isWrapperNumericOrBooleanType(selectorType)) {\n+                            \/\/ Object o = ...\n+                            \/\/ o instanceof Wrapped(float)\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(Wrapper.forBasicType(classLabel)\n+                                    .wrapperType()\n+                                    .describeConstable()\n+                                    .orElseThrow());\n@@ -563,2 +464,3 @@\n-                        } else if (element.caseLabel() instanceof Integer integerLabel) {\n-                            Label compare = cb.newLabel();\n+                        } else if (!unconditionalExactnessCheck(Wrapper.asPrimitiveType(selectorType), classLabel)) {\n+                            \/\/ Integer i = ... or int i = ...\n+                            \/\/ o instanceof float\n@@ -566,1 +468,1 @@\n-                            cb.aload(0);\n+                            cb.aload(SELECTOR_OBJ);\n@@ -568,2 +470,6 @@\n-                            cb.ifeq(notNumber);\n-                            cb.aload(0);\n+                            if (selectorType == long.class || selectorType == float.class || selectorType == double.class) {\n+                                cb.ifeq(next);\n+                            } else {\n+                                cb.ifeq(notNumber);\n+                            }\n+                            cb.aload(SELECTOR_OBJ);\n@@ -571,24 +477,12 @@\n-                            cb.invokevirtual(ConstantDescs.CD_Number,\n-                                             \"intValue\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_int));\n-                            cb.goto_(compare);\n-                            cb.labelBinding(notNumber);\n-                            cb.aload(0);\n-                            cb.instanceof_(ConstantDescs.CD_Character);\n-                            cb.ifeq(next);\n-                            cb.aload(0);\n-                            cb.checkcast(ConstantDescs.CD_Character);\n-                            cb.invokevirtual(ConstantDescs.CD_Character,\n-                                             \"charValue\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_char));\n-                            cb.labelBinding(compare);\n-\n-                            cb.ldc(integerLabel);\n-                            cb.if_icmpne(next);\n-                        } else if ((element.caseLabel() instanceof Long ||\n-                                    element.caseLabel() instanceof Float ||\n-                                    element.caseLabel() instanceof Double ||\n-                                    element.caseLabel() instanceof Boolean)) {\n-                            \/\/TODO: should call equals on the constant, not on the selector, check\n-                            if (element.caseLabel() instanceof Boolean c) {\n-                                cb.constantInstruction(c ? 1 : 0);\n+                            if (selectorType == long.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"longValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_long));\n+                            } else if (selectorType == float.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"floatValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_float));\n+                            } else if (selectorType == double.class) {\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"doubleValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_double));\n@@ -596,1 +490,15 @@\n-                                cb.constantInstruction((ConstantDesc) element.caseLabel());\n+                                Label compare = cb.newLabel();\n+                                cb.invokevirtual(ConstantDescs.CD_Number,\n+                                        \"intValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_int));\n+                                cb.goto_(compare);\n+                                cb.labelBinding(notNumber);\n+                                cb.aload(SELECTOR_OBJ);\n+                                cb.instanceof_(ConstantDescs.CD_Character);\n+                                cb.ifeq(next);\n+                                cb.aload(SELECTOR_OBJ);\n+                                cb.checkcast(ConstantDescs.CD_Character);\n+                                cb.invokevirtual(ConstantDescs.CD_Character,\n+                                        \"charValue\",\n+                                        MethodTypeDesc.of(ConstantDescs.CD_char));\n+                                cb.labelBinding(compare);\n@@ -598,9 +506,13 @@\n-                            cb.invokestatic(element.caseLabel().getClass().describeConstable().orElseThrow(),\n-                                            \"valueOf\",\n-                                            MethodTypeDesc.of(element.caseLabel().getClass().describeConstable().orElseThrow(),\n-                                                              Wrapper.asPrimitiveType(element.caseLabel().getClass()).describeConstable().orElseThrow()));\n-                            cb.aload(0);\n-                            cb.invokevirtual(ConstantDescs.CD_Object,\n-                                             \"equals\",\n-                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n-                                                               ConstantDescs.CD_Object));\n+\n+                            TypePairs typePair = TypePairs.of(Wrapper.asPrimitiveType(selectorType), classLabel);\n+                            String methodName = typePairToName.get(typePair);\n+                            cb.invokestatic(ExactConversionsSupport.class.describeConstable().orElseThrow(),\n+                                    methodName,\n+                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, typePair.from.describeConstable().orElseThrow()));\n+                            cb.ifeq(next);\n+                        }\n+                    } else {\n+                        Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n+                        if (classLabelConstableOpt.isPresent()) {\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.instanceof_(classLabelConstableOpt.orElseThrow());\n@@ -609,2 +521,14 @@\n-                            throw new InternalError(\"Unsupported label type: \" +\n-                                                    element.caseLabel().getClass());\n+                            cb.aload(EXTRA_CLASS_LABELS);\n+                            cb.constantInstruction(extraClassLabels.size());\n+                            cb.invokeinterface(ConstantDescs.CD_List,\n+                                    \"get\",\n+                                    MethodTypeDesc.of(ConstantDescs.CD_Object,\n+                                            ConstantDescs.CD_int));\n+                            cb.checkcast(ConstantDescs.CD_Class);\n+                            cb.aload(SELECTOR_OBJ);\n+                            cb.invokevirtual(ConstantDescs.CD_Class,\n+                                    \"isInstance\",\n+                                    MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                            ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                            extraClassLabels.add(classLabel);\n@@ -612,2 +536,0 @@\n-                        cb.constantInstruction(idx);\n-                        cb.ireturn();\n@@ -615,4 +537,95 @@\n-                    cb.labelBinding(dflt);\n-                    cb.constantInstruction(cases.size());\n-                    cb.ireturn();\n-                });\n+                } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                    int enumIdx = enumDescs.size();\n+                    enumDescs.add(enumLabel);\n+                    cb.aload(ENUM_CACHE);\n+                    cb.constantInstruction(enumIdx);\n+                    cb.invokestatic(ConstantDescs.CD_Integer,\n+                            \"valueOf\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n+                                    ConstantDescs.CD_int));\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n+                            \"test\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else if (element.caseLabel() instanceof String stringLabel) {\n+                    cb.ldc(stringLabel);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                            \"equals\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                    Label compare = cb.newLabel();\n+                    Label notNumber = cb.newLabel();\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.instanceof_(ConstantDescs.CD_Number);\n+                    cb.ifeq(notNumber);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.checkcast(ConstantDescs.CD_Number);\n+                    cb.invokevirtual(ConstantDescs.CD_Number,\n+                            \"intValue\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_int));\n+                    cb.goto_(compare);\n+                    cb.labelBinding(notNumber);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.instanceof_(ConstantDescs.CD_Character);\n+                    cb.ifeq(next);\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.checkcast(ConstantDescs.CD_Character);\n+                    cb.invokevirtual(ConstantDescs.CD_Character,\n+                            \"charValue\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_char));\n+                    cb.labelBinding(compare);\n+\n+                    cb.ldc(integerLabel);\n+                    cb.if_icmpne(next);\n+                } else if ((element.caseLabel() instanceof Long ||\n+                        element.caseLabel() instanceof Float ||\n+                        element.caseLabel() instanceof Double ||\n+                        element.caseLabel() instanceof Boolean)) {\n+                    if (element.caseLabel() instanceof Boolean c) {\n+                        cb.constantInstruction(c ? 1 : 0);\n+                    } else {\n+                        cb.constantInstruction((ConstantDesc) element.caseLabel());\n+                    }\n+                    cb.invokestatic(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                            \"valueOf\",\n+                            MethodTypeDesc.of(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                                    Wrapper.asPrimitiveType(element.caseLabel().getClass()).describeConstable().orElseThrow()));\n+                    cb.aload(SELECTOR_OBJ);\n+                    cb.invokevirtual(ConstantDescs.CD_Object,\n+                            \"equals\",\n+                            MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                    ConstantDescs.CD_Object));\n+                    cb.ifeq(next);\n+                } else {\n+                    throw new InternalError(\"Unsupported label type: \" +\n+                            element.caseLabel().getClass());\n+                }\n+                cb.constantInstruction(idx);\n+                cb.ireturn();\n+            }\n+            cb.labelBinding(dflt);\n+            cb.constantInstruction(cases.size());\n+            cb.ireturn();\n+        };\n+    }\n+\n+    \/*\n+     * Construct the method handle that represents the method int typeSwitch(Object, int, BiPredicate, List)\n+     *\/\n+    private static MethodHandle generateTypeSwitch(MethodHandles.Lookup caller, Class<?> selectorType, Object[] labelConstants) {\n+        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n+        List<Class<?>> extraClassLabels = new ArrayList<>();\n+\n+        byte[] classBytes = ClassFile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())),\n+                clb -> {\n+                    clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n+                       .withMethodBody(\"typeSwitch\",\n+                                       TYPES_SWITCH_DESCRIPTOR,\n+                                       ClassFile.ACC_FINAL | ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC,\n+                                       generateTypeSwitchSkeleton(selectorType, labelConstants, enumDescs, extraClassLabels));\n@@ -620,0 +633,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":223,"deletions":209,"binary":false,"changes":432,"status":"modified"},{"patch":"@@ -125,0 +125,9 @@\n+        testType(new Object() {\n+            @Override\n+            public boolean equals(Object obj) {\n+                if (obj instanceof Long i) {\n+                    return i == 1;\n+                }\n+                return super.equals(obj);\n+            }\n+        }, 0, 1, 1L);\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}