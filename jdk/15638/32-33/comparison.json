{"files":[{"patch":"@@ -29,0 +29,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,1 +38,2 @@\n-import java.util.HashMap;\n+import java.lang.reflect.AccessFlag;\n+import java.util.ArrayList;\n@@ -37,0 +42,2 @@\n+import java.util.Optional;\n+import java.util.function.BiPredicate;\n@@ -39,0 +46,3 @@\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Label;\n+import jdk.internal.classfile.instruction.SwitchCase;\n@@ -40,1 +50,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -42,0 +51,4 @@\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -43,0 +56,2 @@\n+import jdk.internal.classfile.CodeBuilder;\n+import sun.invoke.util.Wrapper;\n@@ -58,0 +73,1 @@\n+    private static final boolean previewEnabled = true;\n@@ -59,9 +75,0 @@\n-    private static final MethodHandle INSTANCEOF_CHECK;\n-    private static final MethodHandle IS_ASSIGNABLE_FROM_CHECK;\n-    private static final MethodHandle INTEGER_EQ_CHECK;\n-    private static final MethodHandle LONG_EQ_CHECK;\n-    private static final MethodHandle FLOAT_EQ_CHECK;\n-    private static final MethodHandle DOUBLE_EQ_CHECK;\n-    private static final MethodHandle BOOLEAN_EQ_CHECK;\n-    private static final MethodHandle OBJECT_EQ_CHECK;\n-    private static final MethodHandle ENUM_EQ_CHECK;\n@@ -72,1 +79,5 @@\n-    private static final HashMap<TypePairs, String> typePairToName;\n+\n+    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n+            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I\");\n+\n+    private static final Map<TypePairs, String> typePairToName;\n@@ -75,1 +86,0 @@\n-        typePairToName = TypePairs.initialize();\n@@ -77,20 +87,0 @@\n-            INSTANCEOF_CHECK = MethodHandles.permuteArguments(LOOKUP.findVirtual(Class.class, \"isInstance\",\n-                                                                                 MethodType.methodType(boolean.class, Object.class)),\n-                                                              MethodType.methodType(boolean.class, Object.class, Class.class), 1, 0);\n-            IS_ASSIGNABLE_FROM_CHECK = MethodHandles.permuteArguments(LOOKUP.findVirtual(Class.class, \"isAssignableFrom\",\n-                                                                                 MethodType.methodType(boolean.class, Class.class)),\n-                                                              MethodType.methodType(boolean.class, Class.class, Class.class), 1, 0);\n-            INTEGER_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"integerEqCheck\",\n-                                           MethodType.methodType(boolean.class, Object.class, Integer.class));\n-            LONG_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"longEqCheck\",\n-                    MethodType.methodType(boolean.class, long.class, Long.class));\n-            FLOAT_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"floatEqCheck\",\n-                    MethodType.methodType(boolean.class, float.class, Float.class));\n-            DOUBLE_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"doubleEqCheck\",\n-                    MethodType.methodType(boolean.class, double.class, Double.class));\n-            BOOLEAN_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"booleanEqCheck\",\n-                    MethodType.methodType(boolean.class, boolean.class, Boolean.class));\n-            OBJECT_EQ_CHECK = LOOKUP.findStatic(Objects.class, \"equals\",\n-                                           MethodType.methodType(boolean.class, Object.class, Object.class));\n-            ENUM_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"enumEqCheck\",\n-                                           MethodType.methodType(boolean.class, Object.class, EnumDesc.class, MethodHandles.Lookup.class, ResolvedEnumLabel.class));\n@@ -110,0 +100,1 @@\n+        typePairToName = TypePairs.initialize();\n@@ -157,1 +148,1 @@\n-     * invocation type is not not a method type of first parameter of a reference type,\n+     * invocation type is not a method type of first parameter of a reference type,\n@@ -160,1 +151,3 @@\n-     * {@code Integer}, {@code Class} or {@code EnumDesc}.\n+     * {@code Integer}, {@code Long}, {@code Float}, {@code Double}, {@code Boolean},\n+     * {@code Class} or {@code EnumDesc}. Additionally, if {@code labels} contains an element\n+     * that is not of type {@code Boolean} when {@code target} is a {@code Boolean.class}.\n@@ -168,0 +161,1 @@\n+        Class<?> selectorType = invocationType.parameterType(0);\n@@ -170,0 +164,1 @@\n+            || (selectorType.isPrimitive() && !previewEnabled)\n@@ -175,1 +170,1 @@\n-        Stream.of(labels).forEach(SwitchBootstraps::verifyLabel);\n+        Stream.of(labels).forEach(l -> verifyLabel(l, selectorType));\n@@ -177,7 +172,3 @@\n-        MethodHandle target;\n-        if (invocationType.parameterType(0).isPrimitive()) {\n-            target = createMethodHandleSwitch(lookup, labels, invocationType.parameterType(0));\n-        }\n-        else {\n-            target = createMethodHandleSwitch(lookup, labels, Object.class);\n-        }\n+        MethodHandle target = generateInnerClass(lookup, selectorType, labels);\n+\n+        target = withIndexCheck(target, labels.length);\n@@ -188,1 +179,1 @@\n-    private static void verifyLabel(Object label) {\n+    private static void verifyLabel(Object label, Class<?> selectorType) {\n@@ -193,0 +184,1 @@\n+\n@@ -196,4 +188,8 @@\n-            labelClass != Float.class &&\n-            labelClass != Long.class &&\n-            labelClass != Double.class &&\n-            labelClass != Boolean.class &&\n+                \n+            ((labelClass != Float.class &&\n+              labelClass != Long.class &&\n+              labelClass != Double.class &&\n+              labelClass != Boolean.class) ||\n+              ((selectorType.equals(boolean.class) || selectorType.equals(Boolean.class)) && labelClass != Boolean.class && labelClass != Class.class) ||\n+             !previewEnabled) &&\n+                \n@@ -205,166 +201,0 @@\n-    \/*\n-     * Construct test chains for labels inside switch, to handle switch repeats:\n-     * switch (idx) {\n-     *     case 0 -> if (selector matches label[0]) return 0; else if (selector matches label[1]) return 1; else ...\n-     *     case 1 -> if (selector matches label[1]) return 1; else ...\n-     *     ...\n-     * }\n-     *\/\n-    private static MethodHandle createRepeatIndexSwitch(MethodHandles.Lookup lookup, Object[] labels, Class<?> selectorType) {\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, selectorType);\n-        MethodHandle[] testChains = new MethodHandle[labels.length];\n-        List<Object> labelsList = List.of(labels).reversed();\n-        \/\/ unconditionally exact patterns always match\n-        MethodHandle trueDef = MethodHandles.dropArguments(MethodHandles.constant(boolean.class, true), 0, selectorType, Object.class);\n-        for (int i = 0; i < labels.length; i++) {\n-            MethodHandle test = def;\n-            int idx = labels.length - 1;\n-            List<Object> currentLabels = labelsList.subList(0, labels.length - i);\n-            for (int j = 0; j < currentLabels.size(); j++, idx--) {\n-                Object currentLabel = currentLabels.get(j);\n-                Object testLabel = currentLabel;\n-                if (j + 1 < currentLabels.size() && currentLabels.get(j + 1) == currentLabel) continue;\n-                MethodHandle currentTest;\n-                if (currentLabel instanceof Class<?> currentLabelClass) {\n-                    if (unconditionalExactnessCheck(selectorType, currentLabelClass)) {\n-                        currentTest = trueDef;\n-                    } else if (currentLabelClass.isPrimitive()) {\n-                         if (selectorType.equals(Object.class)) {\n-                            currentTest = INSTANCEOF_CHECK;\n-                            testLabel = Wrapper.forBasicType(currentLabelClass).wrapperType();\n-                        } else {\n-                            MethodHandle exactnessCheck;\n-                            try {\n-                                TypePairs typePair = TypePairs.of(selectorType, currentLabelClass);\n-                                String methodName = typePairToName.get(typePair);\n-                                MethodType methodType = MethodType.methodType(boolean.class, typePair.from);\n-                                exactnessCheck = lookup.findStatic(ExactConversionsSupport.class, methodName, methodType).asType(MethodType.methodType(boolean.class, selectorType));\n-                            }\n-                            catch (ReflectiveOperationException e) {\n-                                throw new ExceptionInInitializerError(e);\n-                            }\n-                            currentTest = MethodHandles.dropArguments(exactnessCheck, 1, Object.class);\n-                        }\n-                    } else if (selectorType.isPrimitive()) {\n-                        currentTest = IS_ASSIGNABLE_FROM_CHECK;\n-                        currentTest = MethodHandles.dropArguments(currentTest, 0, selectorType);\n-                        currentTest = MethodHandles.insertArguments(currentTest, 1, Class.class);\n-                        testLabel = currentLabelClass;\n-                    } else {\n-                        currentTest = INSTANCEOF_CHECK;\n-                    }\n-                }\n-                else if (currentLabel instanceof Integer ii) {\n-                    if (selectorType.equals(boolean.class)) {\n-                        testLabel = ii.intValue() == 1;\n-                        currentTest = BOOLEAN_EQ_CHECK;\n-                    } else {\n-                        currentTest = MethodHandles.explicitCastArguments(INTEGER_EQ_CHECK,\n-                                MethodType.methodType(boolean.class, selectorType, Integer.class));\n-                    }\n-                }\n-                else if (selectorType.isPrimitive() && currentLabel instanceof Long) {\n-                    currentTest = LONG_EQ_CHECK;\n-                }\n-                else if (selectorType.isPrimitive() && currentLabel instanceof Float) {\n-                    currentTest = FLOAT_EQ_CHECK;\n-                }\n-                else if (selectorType.isPrimitive() && currentLabel instanceof Double) {\n-                    currentTest = DOUBLE_EQ_CHECK;\n-                }\n-                else if (selectorType.isPrimitive() && currentLabel instanceof Boolean) {\n-                    currentTest = BOOLEAN_EQ_CHECK;\n-                }\n-                else if (currentLabel instanceof EnumDesc) {\n-                    currentTest = MethodHandles.insertArguments(ENUM_EQ_CHECK, 2, lookup, new ResolvedEnumLabel());\n-                    currentTest = MethodHandles.explicitCastArguments(currentTest,\n-                            MethodType.methodType(boolean.class, selectorType, EnumDesc.class));\n-                } else {\n-                    currentTest = OBJECT_EQ_CHECK;\n-                }\n-                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, testLabel),\n-                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, selectorType),\n-                                                   test);\n-            }\n-            testChains[i] = MethodHandles.dropArguments(test, 0, int.class);\n-        }\n-\n-        return MethodHandles.tableSwitch(MethodHandles.dropArguments(def, 0, int.class), testChains);\n-    }\n-\n-    \/*\n-     * Construct code that maps the given selector and repeat index to a case label number:\n-     * if (selector == null) return -1;\n-     * else return \"createRepeatIndexSwitch(labels)\"\n-     *\/\n-    private static MethodHandle createMethodHandleSwitch(MethodHandles.Lookup lookup, Object[] labels, Class<?> selectorType) {\n-        if (!selectorType.isPrimitive() && !selectorType.isEnum()) {\n-            selectorType = Object.class;\n-        }\n-\n-        MethodHandle mainTest;\n-        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0,  selectorType);\n-        if (labels.length > 0) {\n-            mainTest = createRepeatIndexSwitch(lookup, labels, selectorType);\n-        } else {\n-            mainTest = MethodHandles.dropArguments(def, 0, int.class);\n-        }\n-\n-        MethodHandle body;\n-        if (!selectorType.isPrimitive()) {\n-            var castedNullCheckMT = MethodHandles.explicitCastArguments(NULL_CHECK,\n-                    MethodType.methodType(boolean.class, selectorType));\n-            body = MethodHandles.guardWithTest(MethodHandles.dropArguments(castedNullCheckMT, 0, int.class),\n-                    MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, selectorType),\n-                    mainTest);\n-        } else {\n-            body = mainTest;\n-        }\n-\n-        MethodHandle switchImpl =\n-                MethodHandles.permuteArguments(body, MethodType.methodType(int.class, selectorType, int.class), 1, 0);\n-        return withIndexCheck(switchImpl, labels.length);\n-    }\n-\n-    \/\/<editor-fold desc=\"Equality checks for numerics and boolean\">\n-    private static boolean floatEqCheck(float value, Float constant) {\n-        if (Float.valueOf(value).equals(constant.floatValue())) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static boolean doubleEqCheck(double value, Double constant) {\n-        if (Double.valueOf(value).equals(constant.doubleValue())) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static boolean longEqCheck(long value, Long constant) {\n-        if (Long.valueOf(value).equals(constant.longValue())) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static boolean booleanEqCheck(boolean value, Boolean constant) {\n-        if (Boolean.valueOf(value).equals(constant.booleanValue())) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static boolean integerEqCheck(Object value, Integer constant) {\n-        if (value instanceof Number input && constant.intValue() == input.intValue()) {\n-            return true;\n-        } else if (value instanceof Character input && constant.intValue() == input.charValue()) {\n-            return true;\n-        }\n-        else if (value instanceof Boolean input && constant.intValue() == (input.booleanValue() ? 1 : 0)) {\n-            return true;\n-        }\n-        return false;\n-    }\n-    \/\/<\/editor-fold>\n-\n@@ -375,16 +205,0 @@\n-    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.checkUnconditionallyExactPrimitives\n-    private static boolean unconditionalExactnessCheck(Class<?> selectorType, Class<?> targetType) {\n-        Wrapper selectorWrapper = Wrapper.forBasicType(selectorType);\n-        Wrapper targetWrapper   = Wrapper.forBasicType(targetType);\n-        if (selectorType.isPrimitive() && targetType.equals(selectorWrapper.wrapperType())) {\n-            return true;\n-        }\n-        else if (selectorType.equals(targetType) ||\n-                ((selectorType.equals(byte.class) && !targetType.equals(char.class)) ||\n-                 (selectorType.equals(short.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))) ||\n-                 (selectorType.equals(char.class)  && (selectorWrapper.isStrictSubRangeOf(targetWrapper)))  ||\n-                 (selectorType.equals(int.class)   && (targetType.equals(double.class) || targetType.equals(long.class))) ||\n-                 (selectorType.equals(float.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))))) return true;\n-        return false;\n-    }\n-\n@@ -471,1 +285,1 @@\n-            \/\/else return \"createRepeatIndexSwitch(labels)\"\n+            \/\/else return \"typeSwitch(labels)\"\n@@ -476,1 +290,1 @@\n-                                                                            createRepeatIndexSwitch(lookup, labels, invocationType.parameterType(0)),\n+                                                                            generateInnerClass(lookup, invocationType.parameterType(0), labels),\n@@ -480,1 +294,1 @@\n-            target = createMethodHandleSwitch(lookup, labels, invocationType.parameterType(0));\n+            target = generateInnerClass(lookup, invocationType.parameterType(0), labels);\n@@ -501,1 +315,1 @@\n-            return EnumDesc.of(enumClassTemplate.describeConstable().get(), (String) label);\n+            return EnumDesc.of(enumClassTemplate.describeConstable().orElseThrow(), (String) label);\n@@ -530,3 +344,2 @@\n-    private static boolean enumEqCheck(Object value, EnumDesc<?> label, MethodHandles.Lookup lookup, ResolvedEnumLabel resolvedEnum) {\n-        if (resolvedEnum.resolvedEnum == null) {\n-            Object resolved;\n+    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n+        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n@@ -534,4 +347,19 @@\n-            try {\n-                if (!(value instanceof Enum<?> enumValue)) {\n-                    return false;\n-                }\n+        return MethodHandles.filterArguments(target, 1, checkIndex);\n+    }\n+\n+    private static final class ResolvedEnumLabels implements BiPredicate<Integer, Object> {\n+\n+        private final MethodHandles.Lookup lookup;\n+        private final EnumDesc<?>[] enumDescs;\n+        @Stable\n+        private Object[] resolvedEnum;\n+\n+        public ResolvedEnumLabels(MethodHandles.Lookup lookup, EnumDesc<?>[] enumDescs) {\n+            this.lookup = lookup;\n+            this.enumDescs = enumDescs;\n+            this.resolvedEnum = new Object[enumDescs.length];\n+        }\n+\n+        @Override\n+        public boolean test(Integer labelIndex, Object value) {\n+            Object result = resolvedEnum[labelIndex];\n@@ -539,1 +367,5 @@\n-                Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n+            if (result == null) {\n+                try {\n+                    if (!(value instanceof Enum<?> enumValue)) {\n+                        return false;\n+                    }\n@@ -541,2 +373,10 @@\n-                if (enumValue.getDeclaringClass() != clazz) {\n-                    return false;\n+                    EnumDesc<?> label = enumDescs[labelIndex];\n+                    Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n+\n+                    if (enumValue.getDeclaringClass() != clazz) {\n+                        return false;\n+                    }\n+\n+                    result = label.resolveConstantDesc(lookup);\n+                } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n+                    result = SENTINEL;\n@@ -545,3 +385,1 @@\n-                resolved = label.resolveConstantDesc(lookup);\n-            } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n-                resolved = SENTINEL;\n+                resolvedEnum[labelIndex] = result;\n@@ -550,1 +388,1 @@\n-            resolvedEnum.resolvedEnum = resolved;\n+            return result == value;\n@@ -552,2 +390,0 @@\n-\n-        return value == resolvedEnum.resolvedEnum;\n@@ -556,2 +392,4 @@\n-    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n-        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n+    private static final class EnumMap {\n+        @Stable\n+        public int[] map;\n+    }\n@@ -559,1 +397,248 @@\n-        return MethodHandles.filterArguments(target, 1, checkIndex);\n+    \/*\n+     * Construct test chains for labels inside switch, to handle switch repeats:\n+     * switch (idx) {\n+     *     case 0 -> if (selector matches label[0]) return 0;\n+     *     case 1 -> if (selector matches label[1]) return 1;\n+     *     ...\n+     * }\n+     *\/\n+    @SuppressWarnings(\"removal\")\n+    private static MethodHandle generateInnerClass(MethodHandles.Lookup caller, Class<?> selectorType, Object[] labels) {\n+        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n+        List<Class<?>> extraClassLabels = new ArrayList<>();\n+\n+        byte[] classBytes = Classfile.of().build(ClassDesc.of(typeSwitchClassName(caller.lookupClass())), clb -> {\n+            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n+               .withMethodBody(\"typeSwitch\",\n+                               TYPES_SWITCH_DESCRIPTOR,\n+                               Classfile.ACC_FINAL | Classfile.ACC_PUBLIC | Classfile.ACC_STATIC,\n+                               cb -> {\n+                    cb.aload(0);\n+                    Label nonNullLabel = cb.newLabel();\n+                    cb.if_nonnull(nonNullLabel);\n+                    cb.iconst_m1();\n+                    cb.ireturn();\n+                    cb.labelBinding(nonNullLabel);\n+                    if (labels.length == 0) {\n+                        cb.constantInstruction(0)\n+                          .ireturn();\n+                        return ;\n+                    }\n+                    cb.iload(1);\n+                    Label dflt = cb.newLabel();\n+                    record Element(Label target, Label next, Object caseLabel) {}\n+                    List<Element> cases = new ArrayList<>();\n+                    List<SwitchCase> switchCases = new ArrayList<>();\n+                    Object lastLabel = null;\n+                    for (int idx = labels.length - 1; idx >= 0; idx--) {\n+                        Object currentLabel = labels[idx];\n+                        Label target = cb.newLabel();\n+                        Label next;\n+                        if (lastLabel == null) {\n+                            next = dflt;\n+                        } else if (lastLabel.equals(currentLabel)) {\n+                            next = cases.getLast().next();\n+                        } else {\n+                            next = cases.getLast().target();\n+                        }\n+                        lastLabel = currentLabel;\n+                        cases.add(new Element(target, next, currentLabel));\n+                        switchCases.add(SwitchCase.of(idx, target));\n+                    }\n+                    cases = cases.reversed();\n+                    switchCases = switchCases.reversed();\n+                    cb.tableswitch(0, labels.length - 1, dflt, switchCases);\n+                    for (int idx = 0; idx < cases.size(); idx++) {\n+                        Element element = cases.get(idx);\n+                        Label next = element.next();\n+                        cb.labelBinding(element.target());\n+                        if (element.caseLabel() instanceof Class<?> classLabel) {\n+                            if (unconditionalExactnessCheck(selectorType, classLabel)) {\n+                                \/\/nothing - unconditionally use this case\n+                            } else if (classLabel.isPrimitive()) {\n+                                if (!selectorType.isPrimitive() && !Wrapper.isWrapperNumericOrBooleanType(selectorType)) {\n+                                    \/\/ Object o = ...\n+                                    \/\/ o instanceof Wrapped(float)\n+                                    cb.aload(0);\n+                                    cb.instanceof_(Wrapper.forBasicType(classLabel)\n+                                                          .wrapperType()\n+                                                          .describeConstable()\n+                                                          .orElseThrow());\n+                                    cb.ifeq(next);\n+                                } else if (!unconditionalExactnessCheck(Wrapper.asPrimitiveType(selectorType), classLabel)) {\n+                                    \/\/ Integer i = ... or int i = ...\n+                                    \/\/ o instanceof float\n+                                    Label notNumber = cb.newLabel();\n+                                    cb.aload(0);\n+                                    cb.instanceof_(ConstantDescs.CD_Number);\n+                                    if (selectorType == long.class || selectorType == float.class || selectorType == double.class) {\n+                                        cb.ifeq(next);\n+                                    } else {\n+                                        cb.ifeq(notNumber);\n+                                    }\n+                                    cb.aload(0);\n+                                    cb.checkcast(ConstantDescs.CD_Number);\n+                                    if (selectorType == long.class) {\n+                                        cb.invokevirtual(ConstantDescs.CD_Number,\n+                                                     \"longValue\",\n+                                                     MethodTypeDesc.of(ConstantDescs.CD_long));\n+                                    } else if (selectorType == float.class) {\n+                                        cb.invokevirtual(ConstantDescs.CD_Number,\n+                                                     \"floatValue\",\n+                                                     MethodTypeDesc.of(ConstantDescs.CD_float));\n+                                    } else if (selectorType == double.class) {\n+                                        cb.invokevirtual(ConstantDescs.CD_Number,\n+                                                     \"doubleValue\",\n+                                                     MethodTypeDesc.of(ConstantDescs.CD_double));\n+                                    } else {\n+                                        Label compare = cb.newLabel();\n+                                        cb.invokevirtual(ConstantDescs.CD_Number,\n+                                                         \"intValue\",\n+                                                         MethodTypeDesc.of(ConstantDescs.CD_int));\n+                                        cb.goto_(compare);\n+                                        cb.labelBinding(notNumber);\n+                                        cb.aload(0);\n+                                        cb.instanceof_(ConstantDescs.CD_Character);\n+                                        cb.ifeq(next);\n+                                        cb.aload(0);\n+                                        cb.checkcast(ConstantDescs.CD_Character);\n+                                        cb.invokevirtual(ConstantDescs.CD_Character,\n+                                                         \"charValue\",\n+                                                         MethodTypeDesc.of(ConstantDescs.CD_char));\n+                                        cb.labelBinding(compare);\n+                                    }\n+\n+                                    TypePairs typePair = TypePairs.of(Wrapper.asPrimitiveType(selectorType), classLabel);\n+                                    String methodName = typePairToName.get(typePair);\n+                                    cb.invokestatic(ExactConversionsSupport.class.describeConstable().orElseThrow(),\n+                                                    methodName,\n+                                                    MethodTypeDesc.of(ConstantDescs.CD_boolean, typePair.from.describeConstable().orElseThrow()));\n+                                    cb.ifeq(next);\n+                                }\n+                            } else {\n+                                Optional<ClassDesc> classLabelConstableOpt = classLabel.describeConstable();\n+                                if (classLabelConstableOpt.isPresent()) {\n+                                    cb.aload(0);\n+                                    cb.instanceof_(classLabelConstableOpt.orElseThrow());\n+                                    cb.ifeq(next);\n+                                } else {\n+                                    cb.aload(3);\n+                                    cb.constantInstruction(extraClassLabels.size());\n+                                    cb.invokeinterface(ConstantDescs.CD_List,\n+                                                       \"get\",\n+                                                       MethodTypeDesc.of(ConstantDescs.CD_Object,\n+                                                                         ConstantDescs.CD_int));\n+                                    cb.checkcast(ConstantDescs.CD_Class);\n+                                    cb.aload(0);\n+                                    cb.invokevirtual(ConstantDescs.CD_Class,\n+                                                     \"isInstance\",\n+                                                     MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                                       ConstantDescs.CD_Object));\n+                                    cb.ifeq(next);\n+                                    extraClassLabels.add(classLabel);\n+                                }\n+                            }\n+                        } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                            int enumIdx = enumDescs.size();\n+                            enumDescs.add(enumLabel);\n+                            cb.aload(2);\n+                            cb.constantInstruction(enumIdx);\n+                            cb.invokestatic(ConstantDescs.CD_Integer,\n+                                            \"valueOf\",\n+                                            MethodTypeDesc.of(ConstantDescs.CD_Integer,\n+                                                              ConstantDescs.CD_int));\n+                            cb.aload(0);\n+                            cb.invokeinterface(BiPredicate.class.describeConstable().orElseThrow(),\n+                                               \"test\",\n+                                               MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                                 ConstantDescs.CD_Object,\n+                                                                 ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof String stringLabel) {\n+                            cb.ldc(stringLabel);\n+                            cb.aload(0);\n+                            cb.invokevirtual(ConstantDescs.CD_Object,\n+                                             \"equals\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                               ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                            Label compare = cb.newLabel();\n+                            Label notNumber = cb.newLabel();\n+                            cb.aload(0);\n+                            cb.instanceof_(ConstantDescs.CD_Number);\n+                            cb.ifeq(notNumber);\n+                            cb.aload(0);\n+                            cb.checkcast(ConstantDescs.CD_Number);\n+                            cb.invokevirtual(ConstantDescs.CD_Number,\n+                                             \"intValue\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_int));\n+                            cb.goto_(compare);\n+                            cb.labelBinding(notNumber);\n+                            cb.aload(0);\n+                            cb.instanceof_(ConstantDescs.CD_Character);\n+                            cb.ifeq(next);\n+                            cb.aload(0);\n+                            cb.checkcast(ConstantDescs.CD_Character);\n+                            cb.invokevirtual(ConstantDescs.CD_Character,\n+                                             \"charValue\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_char));\n+                            cb.labelBinding(compare);\n+\n+                            cb.ldc(integerLabel);\n+                            cb.if_icmpne(next);\n+                        } else if (\/*selectorType.isPrimitive() && ??*\/\n+                                   (element.caseLabel() instanceof Long ||\n+                                    element.caseLabel() instanceof Float ||\n+                                    element.caseLabel() instanceof Double ||\n+                                    element.caseLabel() instanceof Boolean)) {\n+                            \/\/TODO: should call equals on the constant, not on the selector, check\n+                            if (element.caseLabel() instanceof Boolean c) {\n+                                cb.constantInstruction(c ? 1 : 0);\n+                            } else {\n+                                cb.constantInstruction((ConstantDesc) element.caseLabel());\n+                            }\n+                            cb.invokestatic(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                                            \"valueOf\",\n+                                            MethodTypeDesc.of(element.caseLabel().getClass().describeConstable().orElseThrow(),\n+                                                              Wrapper.asPrimitiveType(element.caseLabel().getClass()).describeConstable().orElseThrow()));\n+                            cb.aload(0);\n+                            cb.invokevirtual(ConstantDescs.CD_Object,\n+                                             \"equals\",\n+                                             MethodTypeDesc.of(ConstantDescs.CD_boolean,\n+                                                               ConstantDescs.CD_Object));\n+                            cb.ifeq(next);\n+                        } else {\n+                            throw new InternalError(\"Unsupported label type: \" +\n+                                                    element.caseLabel().getClass());\n+                        }\n+                        cb.constantInstruction(idx);\n+                        cb.ireturn();\n+                    }\n+                    cb.labelBinding(dflt);\n+                    cb.constantInstruction(cases.size());\n+                    cb.ireturn();\n+                });\n+        });\n+        writeClass(classBytes);\n+        try {\n+            \/\/ this class is linked at the indy callsite; so define a hidden nestmate\n+            MethodHandles.Lookup lookup;\n+            lookup = caller.defineHiddenClass(classBytes, true, NESTMATE, STRONG);\n+            MethodHandle typeSwitch = lookup.findStatic(lookup.lookupClass(),\n+                                                        \"typeSwitch\",\n+                                                        MethodType.methodType(int.class,\n+                                                                              Object.class,\n+                                                                              int.class,\n+                                                                              BiPredicate.class,\n+                                                                              List.class));\n+            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(EnumDesc[]::new)),\n+                                                       List.copyOf(extraClassLabels));\n+            typeSwitch = MethodHandles.explicitCastArguments(typeSwitch,\n+                                                             MethodType.methodType(int.class,\n+                                                                                   selectorType,\n+                                                                                   int.class));\n+            return typeSwitch;\n+        } catch (Throwable t) {\n+            throw new IllegalArgumentException(t);\n+        }\n@@ -562,3 +647,8 @@\n-    private static final class ResolvedEnumLabel {\n-        @Stable\n-        public Object resolvedEnum;\n+    \/\/based on src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java:\n+    private static String typeSwitchClassName(Class<?> targetClass) {\n+        String name = targetClass.getName();\n+        if (targetClass.isHidden()) {\n+            \/\/ use the original class name\n+            name = name.replace('\/', '_');\n+        }\n+        return name + \"$$TypeSwitch\";\n@@ -567,3 +657,14 @@\n-    private static final class EnumMap {\n-        @Stable\n-        public int[] map;\n+    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.checkUnconditionallyExactPrimitives\n+    private static boolean unconditionalExactnessCheck(Class<?> selectorType, Class<?> targetType) {\n+        Wrapper selectorWrapper = Wrapper.forBasicType(selectorType);\n+        Wrapper targetWrapper   = Wrapper.forBasicType(targetType);\n+        if (selectorType.isPrimitive() && targetType.equals(selectorWrapper.wrapperType())) {\n+            return true;\n+        }\n+        else if (selectorType.equals(targetType) ||\n+                ((selectorType.equals(byte.class) && !targetType.equals(char.class)) ||\n+                 (selectorType.equals(short.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))) ||\n+                 (selectorType.equals(char.class)  && (selectorWrapper.isStrictSubRangeOf(targetWrapper)))  ||\n+                 (selectorType.equals(int.class)   && (targetType.equals(double.class) || targetType.equals(long.class))) ||\n+                 (selectorType.equals(float.class) && (selectorWrapper.isStrictSubRangeOf(targetWrapper))))) return true;\n+        return false;\n@@ -581,2 +682,2 @@\n-        public static HashMap<TypePairs, String> initialize() {\n-            HashMap<TypePairs, String> typePairToName = new HashMap<>();\n+        public static Map<TypePairs, String> initialize() {\n+            Map<TypePairs, String> typePairToName = new HashMap<>();\n@@ -612,0 +713,9 @@\n+\n+    private static int idx;\n+    private static void writeClass(byte[] bytes) {\n+        try (java.io.OutputStream out = new java.io.FileOutputStream(\"\/tmp\/classes\" + idx++ + \".class\")) {\n+            out.write(bytes);\n+        } catch (java.io.IOException ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":371,"deletions":261,"binary":false,"changes":632,"status":"modified"},{"patch":"@@ -433,0 +433,5 @@\n+    \/** Query:  Is the given type a wrapper, such as {@code Integer}, {@code Byte}, etc excluding {@code Void} and {@code Object}? *\/\n+    public static boolean isWrapperNumericOrBooleanType(Class<?> type) {\n+        return isWrapperType(type) && findWrapperType(type) != VOID && findWrapperType(type) != OBJECT;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -504,1 +504,1 @@\n-            Type resolvedSelectorType = enumSelector || primitiveSelector ? seltype : syms.objectType;\n+            Type resolvedSelectorType = seltype;\n@@ -762,0 +762,20 @@\n+    private Symbol.DynamicVarSymbol makeBooleanConstant(DiagnosticPosition pos, int constant) {\n+        Assert.checkNonNull(currentClass);\n+\n+        List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n+                syms.stringType,\n+                new ClassType(syms.classType.getEnclosingType(),\n+                        List.of(syms.constantBootstrapsType),\n+                        syms.classType.tsym));\n+\n+        Name bootstrapName = names.fromString(\"getStaticFinal\");\n+        MethodSymbol bsm = rs.resolveInternalMethod(pos, env, syms.constantBootstrapsType,\n+                bootstrapName, bsm_staticArgs, List.nil());\n+\n+        return new Symbol.DynamicVarSymbol(constant == 0 ? names.fromString(\"FALSE\") : names.fromString(\"TRUE\"),\n+                syms.noSymbol,\n+                new Symbol.MethodHandleSymbol(bsm),\n+                types.boxedTypeOrType(syms.booleanType),\n+                new LoadableConstant[]{});\n+    }\n+\n@@ -1020,1 +1040,2 @@\n-                    case BYTE, CHAR, SHORT, INT, BOOLEAN -> LoadableConstant.Int((Integer) expr.type.constValue());\n+                    case BOOLEAN -> makeBooleanConstant(l.pos(), (Integer) expr.type.constValue());\n+                    case BYTE, CHAR, SHORT, INT -> LoadableConstant.Int((Integer) expr.type.constValue());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n@@ -31,0 +33,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -33,0 +36,1 @@\n+import jdk.internal.classfile.Classfile;\n@@ -45,0 +49,1 @@\n+ * @modules java.base\/jdk.internal.classfile\n@@ -113,3 +118,6 @@\n-        testType(\"\", 0, 0, String.class, String.class, String.class);\n-        testType(\"\", 1, 1, String.class, String.class, String.class);\n-        testType(\"\", 2, 2, String.class, String.class, String.class);\n+        testType(\"\", 0, 0, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 1, 1, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 2, 2, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 3, 3, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 3, 3, String.class, String.class, String.class, String.class, String.class);\n+        testType(\"\", 4, 4, String.class, String.class, String.class, String.class, String.class);\n@@ -345,0 +353,28 @@\n+    public void testHiddenClassAsCaseLabel() throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        byte[] classBytes = createClass();\n+        Class<?> classA = lookup.defineHiddenClass(classBytes, false).lookupClass();\n+        Class<?> classB = lookup.defineHiddenClass(classBytes, false).lookupClass();\n+        Object[] labels = new Object[] {\n+            classA,\n+            classB,\n+        };\n+        testType(classA.getConstructor().newInstance(), 0, 0, labels);\n+        testType(classB.getConstructor().newInstance(), 0, 1, labels);\n+    }\n+\n+    private static byte[] createClass() {\n+        return Classfile.of().build(ClassDesc.of(\"C\"), clb -> {\n+            clb.withFlags(AccessFlag.SYNTHETIC)\n+               .withMethodBody(\"<init>\",\n+                               MethodTypeDesc.of(ConstantDescs.CD_void),\n+                               Classfile.ACC_PUBLIC,\n+                               cb -> {\n+                                   cb.aload(0);\n+                                   cb.invokespecial(ConstantDescs.CD_Object,\n+                                                    \"<init>\",\n+                                                    MethodTypeDesc.of(ConstantDescs.CD_void));\n+                                   cb.return_();\n+                               });\n+                    });\n+    }\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -111,0 +111,5 @@\n+        assertEquals(1, testBooleanInEnhancedSwitchStatement(true));\n+        assertEquals(0, testBooleanInEnhancedSwitchStatement(false));\n+        assertEquals(1, testByteWrapperToIntUnconditionallyExact());\n+        assertEquals(1, testIntegerWrapperToFloat());\n+        assertEquals(-1, testIntegerWrapperToFloatInexact());\n@@ -540,0 +545,24 @@\n+    public static int testByteWrapperToIntUnconditionallyExact() {\n+        Byte b = Byte.valueOf((byte) 42);\n+        return switch (b) {\n+            case int p -> 1;\n+        };\n+    }\n+\n+    public static int testIntegerWrapperToFloat() {\n+        Integer i = Integer.valueOf(42);\n+        return switch (i) {\n+            case float p -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+    public static int testIntegerWrapperToFloatInexact() {\n+        Integer i = Integer.valueOf(Integer.MAX_VALUE);\n+        return switch (i) {\n+            case float p -> 1;\n+            default -> -1;\n+        };\n+    }\n+\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitch.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}