{"files":[{"patch":"@@ -3109,0 +3109,22 @@\n+\n+      \/\/ If a Load depends on the same memory state as a Store, we must make sure that\n+      \/\/ the Load is ordered before the Store.\n+      \/\/\n+      \/\/      mem\n+      \/\/       |\n+      \/\/    +--+--+\n+      \/\/    |     |\n+      \/\/    |    Load (n)\n+      \/\/    |\n+      \/\/   Store (mem_use)\n+      \/\/\n+      if (n->is_Load()) {\n+        Node* mem = n->in(MemNode::Memory);\n+        for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n+          Node* mem_use = mem->fast_out(i);\n+          if (mem_use->is_Store() && _vloop.in_bb(mem_use) && !visited.test(bb_idx(mem_use))) {\n+            stack.push(mem_use); \/\/ Ordering edge: Load (n) -> Store (mem_use)\n+          }\n+        }\n+      }\n+\n@@ -3114,1 +3136,1 @@\n-          stack.push(use);\n+          stack.push(use); \/\/ Ordering edge: n -> use\n@@ -3117,0 +3139,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -295,0 +295,13 @@\n+int VLoopDependencyGraph::find_max_pred_depth(const Node* n) const {\n+  int max_pred_depth = 0;\n+  if (!n->is_Phi()) { \/\/ ignore backedge\n+    for (PredsIterator it(*this, n); !it.done(); it.next()) {\n+      Node* pred = it.current();\n+      if (_vloop.in_bb(pred)) {\n+        max_pred_depth = MAX2(max_pred_depth, depth(pred));\n+      }\n+    }\n+  }\n+  return max_pred_depth;\n+}\n+\n@@ -301,8 +314,11 @@\n-    int max_pred_depth = 0;\n-    if (n->is_Phi()) {\n-      for (PredsIterator it(*this, n); !it.done(); it.next()) {\n-        Node* pred = it.current();\n-        if (_vloop.in_bb(pred)) {\n-          max_pred_depth = MAX2(max_pred_depth, depth(pred));\n-        }\n-      }\n+    set_depth(n, find_max_pred_depth(n) + 1);\n+  }\n+\n+#ifdef ASSERT\n+  for (int i = 0; i < _body.body().length(); i++) {\n+    Node* n = _body.body().at(i);\n+    int max_pred_depth = find_max_pred_depth(n);\n+    if (depth(n) != max_pred_depth + 1) {\n+      print();\n+      tty->print_cr(\"Incorrect depth: %d vs %d\", depth(n), max_pred_depth + 1);\n+      n->dump();\n@@ -310,1 +326,1 @@\n-    set_depth(n, max_pred_depth + 1);\n+    assert(depth(n) == max_pred_depth + 1, \"must have correct depth\");\n@@ -312,0 +328,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -556,0 +556,1 @@\n+  int find_max_pred_depth(const Node* n) const;\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+\/*\n+ * @test\n+ * @bug 8327978\n+ * @summary Test compile time for large compilation, where SuperWord takes especially much time.\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm\/timeout=30 -XX:LoopUnrollLimit=1000 -Xbatch\n+ *                              -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestLargeCompilation::test*\n+ *                              compiler.loopopts.superword.TestLargeCompilation\n+ *\/\n+\n+import java.util.Random;\n+\n+public class TestLargeCompilation {\n+    private static final Random random = new Random();\n+    static final int RANGE_CON = 1024 * 8;\n+\n+    static int init = 593436;\n+    static int limit = 599554;\n+    static int offset1 = -592394;\n+    static int offset2 = -592386;\n+    static final int offset3 = -592394;\n+    static final int stride =  4;\n+    static final int scale =   1;\n+    static final int hand_unrolling1 = 2;\n+    static final int hand_unrolling2 = 8;\n+    static final int hand_unrolling3 = 15;\n+\n+    public static void main(String[] args) {\n+        byte[] aB = generateB();\n+        byte[] bB = generateB();\n+        byte[] cB = generateB();\n+ \n+        for (int i = 1; i < 100; i++) {\n+            testUUBBBH(aB, bB, cB);\n+        }\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE_CON];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)random.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static Object[] testUUBBBH(byte[] a, byte[] b, byte[] c) {\n+        int h1 = hand_unrolling1;\n+        int h2 = hand_unrolling2;\n+        int h3 = hand_unrolling3;\n+\n+        for (int i = init; i < limit; i += stride) {\n+            if (h1 >=  1) { a[offset1 + i * scale +  0]++; }\n+            if (h1 >=  2) { a[offset1 + i * scale +  1]++; }\n+            if (h1 >=  3) { a[offset1 + i * scale +  2]++; }\n+            if (h1 >=  4) { a[offset1 + i * scale +  3]++; }\n+            if (h1 >=  5) { a[offset1 + i * scale +  4]++; }\n+            if (h1 >=  6) { a[offset1 + i * scale +  5]++; }\n+            if (h1 >=  7) { a[offset1 + i * scale +  6]++; }\n+            if (h1 >=  8) { a[offset1 + i * scale +  7]++; }\n+            if (h1 >=  9) { a[offset1 + i * scale +  8]++; }\n+            if (h1 >= 10) { a[offset1 + i * scale +  9]++; }\n+            if (h1 >= 11) { a[offset1 + i * scale + 10]++; }\n+            if (h1 >= 12) { a[offset1 + i * scale + 11]++; }\n+            if (h1 >= 13) { a[offset1 + i * scale + 12]++; }\n+            if (h1 >= 14) { a[offset1 + i * scale + 13]++; }\n+            if (h1 >= 15) { a[offset1 + i * scale + 14]++; }\n+            if (h1 >= 16) { a[offset1 + i * scale + 15]++; }\n+\n+            if (h2 >=  1) { b[offset2 + i * scale +  0]++; }\n+            if (h2 >=  2) { b[offset2 + i * scale +  1]++; }\n+            if (h2 >=  3) { b[offset2 + i * scale +  2]++; }\n+            if (h2 >=  4) { b[offset2 + i * scale +  3]++; }\n+            if (h2 >=  5) { b[offset2 + i * scale +  4]++; }\n+            if (h2 >=  6) { b[offset2 + i * scale +  5]++; }\n+            if (h2 >=  7) { b[offset2 + i * scale +  6]++; }\n+            if (h2 >=  8) { b[offset2 + i * scale +  7]++; }\n+            if (h2 >=  9) { b[offset2 + i * scale +  8]++; }\n+            if (h2 >= 10) { b[offset2 + i * scale +  9]++; }\n+            if (h2 >= 11) { b[offset2 + i * scale + 10]++; }\n+            if (h2 >= 12) { b[offset2 + i * scale + 11]++; }\n+            if (h2 >= 13) { b[offset2 + i * scale + 12]++; }\n+            if (h2 >= 14) { b[offset2 + i * scale + 13]++; }\n+            if (h2 >= 15) { b[offset2 + i * scale + 14]++; }\n+            if (h2 >= 16) { b[offset2 + i * scale + 15]++; }\n+\n+            if (h3 >=  1) { c[offset3 + i * scale +  0]++; }\n+            if (h3 >=  2) { c[offset3 + i * scale +  1]++; }\n+            if (h3 >=  3) { c[offset3 + i * scale +  2]++; }\n+            if (h3 >=  4) { c[offset3 + i * scale +  3]++; }\n+            if (h3 >=  5) { c[offset3 + i * scale +  4]++; }\n+            if (h3 >=  6) { c[offset3 + i * scale +  5]++; }\n+            if (h3 >=  7) { c[offset3 + i * scale +  6]++; }\n+            if (h3 >=  8) { c[offset3 + i * scale +  7]++; }\n+            if (h3 >=  9) { c[offset3 + i * scale +  8]++; }\n+            if (h3 >= 10) { c[offset3 + i * scale +  9]++; }\n+            if (h3 >= 11) { c[offset3 + i * scale + 10]++; }\n+            if (h3 >= 12) { c[offset3 + i * scale + 11]++; }\n+            if (h3 >= 13) { c[offset3 + i * scale + 12]++; }\n+            if (h3 >= 14) { c[offset3 + i * scale + 13]++; }\n+            if (h3 >= 15) { c[offset3 + i * scale + 14]++; }\n+            if (h3 >= 16) { c[offset3 + i * scale + 15]++; }\n+        }\n+        return new Object[]{ a, b, c };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestLargeCompilation.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}