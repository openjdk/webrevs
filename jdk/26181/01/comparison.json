{"files":[{"patch":"@@ -253,1 +253,1 @@\n-    public static final long DEFAULT = 1L<<43;\n+    public static final long DEFAULT = 1L<<43; \/\/ part of ExtendedStandardFlags, cannot be reused\n@@ -281,2 +281,2 @@\n-    \/*\n-     * Currently available: Bit 48.\n+    \/**\n+     * Flag to indicate sealed class\/interface declaration.\n@@ -284,0 +284,1 @@\n+    public static final long SEALED = 1L<<48; \/\/ part of ExtendedStandardFlags, cannot be reused\n@@ -392,5 +393,0 @@\n-    \/**\n-     * Flag to indicate sealed class\/interface declaration.\n-     *\/\n-    public static final long SEALED = 1L<<62; \/\/ ClassSymbols\n-\n@@ -415,1 +411,1 @@\n-    public static final long NON_SEALED = 1L<<63; \/\/ ClassSymbols\n+    public static final long NON_SEALED = 1L<<63;  \/\/ part of ExtendedStandardFlags, cannot be reused\n@@ -446,0 +442,1 @@\n+        \/\/NOTE: flags in ExtendedStandardFlags cannot be overlayed across Symbol kinds:\n@@ -553,1 +550,1 @@\n-        \/\/ Bit 48 is currently available\n+        SEALED(Flags.SEALED),\n@@ -562,1 +559,1 @@\n-        SEALED(Flags.SEALED),\n+        RESTRICTED(Flags.RESTRICTED),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8361570\n+ * @summary Verify no flags in ExtendedStandardFlags have overlays for different\n+ *          Symbol kinds.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n+ * @compile ExtendedStandardFlagsOverlayFlagsConflict.java\n+ * @run main ExtendedStandardFlagsOverlayFlagsConflict\n+ *\/\n+\n+import com.sun.tools.javac.code.Flags;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/* Flags in ExtendedStandardFlags are checked using masks, and if they have\n+ * Symbol-kind specific meaning, they can lead to confusing errors. Hence,\n+ * Flags in ExtendedStandardFlags should have the same meaning for all Symbols.\n+ *\/\n+public class ExtendedStandardFlagsOverlayFlagsConflict {\n+\n+    public static void main(String... args) throws Exception {\n+        ExtendedStandardFlagsOverlayFlagsConflict t =\n+                new ExtendedStandardFlagsOverlayFlagsConflict();\n+        t.run();\n+    }\n+\n+    public void run() throws Exception {\n+        Map<Long, List<Field>> value2FlagFields = new HashMap<>();\n+\n+        for (Field f : Flags.class.getFields()) {\n+            if (!Modifier.isStatic(f.getModifiers())) {\n+                continue;\n+            }\n+            if (f.getName().startsWith(\"ACC_\")) {\n+                continue;\n+            }\n+            long flag = ((Number) f.get(null)).longValue();\n+            value2FlagFields.computeIfAbsent(flag, _ -> new ArrayList<>())\n+                            .add(f);\n+        }\n+\n+        long pendingFlags2Check = Flags.ExtendedStandardFlags;\n+\n+        while (pendingFlags2Check != 0) {\n+            long flag = Long.highestOneBit(pendingFlags2Check);\n+            List<Field> flagFields = value2FlagFields.get(flag);\n+            if (flagFields.size() != 1) {\n+                throw new AssertionError(\"Flag: \" + flag +\n+                                         \" has more than one flag field: \" + flagFields);\n+            }\n+            pendingFlags2Check &= ~flag;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/flags\/ExtendedStandardFlagsOverlayFlagsConflict.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8361570\n+ * @summary Verify there's no fake sealed not allowed here error when sealed\n+ *          and requires-identity Flags clash\n+ * @modules java.base\/jdk.internal\n+ * @compile NoFalseSealedError.java\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.util.WeakHashMap;\n+\n+void main(String[] args) {\n+    new RequiresIdentity(null) {};\n+    new WeakReference<>(null) {};\n+    new WeakHashMap<>() {};\n+}\n+\n+static class RequiresIdentity {\n+    RequiresIdentity(@jdk.internal.RequiresIdentity Object o) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/flags\/NoFalseSealedError.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -135,1 +135,1 @@\n-                \"  public V put(@jdk.internal.RequiresIdentity sealed K key,\"\n+                \"  public V put(@jdk.internal.RequiresIdentity K key,\"\n@@ -157,1 +157,1 @@\n-                \"  public V put(sealed K arg0,\"\n+                \"  public V put(K arg0,\"\n","filename":"test\/langtools\/tools\/javac\/platform\/RequiresIdentityTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}