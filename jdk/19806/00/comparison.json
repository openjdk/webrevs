{"files":[{"patch":"@@ -1155,1 +1155,0 @@\n-  IfProjNode* new_predicate_proj = nullptr;\n@@ -1166,4 +1165,3 @@\n-    new_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr,\n-                                                     reason,\n-                                                     iff->Opcode());\n-    Node* ctrl = new_predicate_proj->in(0)->as_If()->in(0);\n+    IfProjNode* hoisted_check_predicate_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason,\n+                                                                           iff->Opcode());\n+    Node* ctrl = hoisted_check_predicate_proj->in(0)->as_If()->in(0);\n@@ -1180,1 +1178,1 @@\n-    IfNode* new_predicate_iff = new_predicate_proj->in(0)->as_If();\n+    IfNode* new_predicate_iff = hoisted_check_predicate_proj->in(0)->as_If();\n@@ -1184,1 +1182,6 @@\n-    C->print_method(PHASE_AFTER_LOOP_PREDICATION_IC, 4, new_predicate_proj->in(0));\n+    invar.map_ctrl(if_success_proj, hoisted_check_predicate_proj); \/\/ Mark hoisted check as invariant\n+\n+    \/\/ Eliminate the old If in the loop body.\n+    dominated_by(hoisted_check_predicate_proj, iff, negated);\n+\n+    C->print_method(PHASE_AFTER_LOOP_PREDICATION_IC, 4, hoisted_check_predicate_proj->in(0));\n@@ -1196,1 +1199,0 @@\n-    range_check_predicate = true;\n@@ -1200,0 +1202,1 @@\n+    IfTrueNode* hoisted_check_proj = if_success_proj->as_IfTrue();\n@@ -1268,2 +1271,10 @@\n-    new_predicate_proj = add_template_assertion_predicate(iff, loop, if_success_proj, parse_predicate_proj, upper_bound_proj, scale,\n-                                                          offset, init, limit, stride, rng, overflow, reason);\n+    IfTrueNode* template_assertion_predicate_proj =\n+        add_template_assertion_predicate(iff, loop, hoisted_check_proj, parse_predicate_proj, upper_bound_proj, scale,\n+                                         offset, init, limit, stride, rng, overflow, reason);\n+\n+    \/\/ Eliminate the old range check in the loop body.\n+    \/\/ When a range check is eliminated, data dependent nodes (Load and range check CastII nodes) are now dependent on 2\n+    \/\/ Hoisted Check Predicates (one for the start of the loop, one for the end) but we can only keep track of one control\n+    \/\/ dependency: pin the data dependent nodes.\n+    eliminate_hoisted_range_check(hoisted_check_proj, template_assertion_predicate_proj);\n+    invar.map_ctrl(hoisted_check_proj, template_assertion_predicate_proj); \/\/ Mark hoisted check as invariant\n@@ -1271,1 +1282,1 @@\n-    C->print_method(PHASE_AFTER_LOOP_PREDICATION_RC, 4, new_predicate_proj->in(0));\n+    C->print_method(PHASE_AFTER_LOOP_PREDICATION_RC, 4, template_assertion_predicate_proj->in(0));\n@@ -1284,9 +1295,0 @@\n-  assert(new_predicate_proj != nullptr, \"sanity\");\n-  \/\/ Success - attach condition (new_predicate_bol) to predicate if\n-  invar.map_ctrl(if_success_proj, new_predicate_proj); \/\/ so that invariance test can be appropriate\n-\n-  \/\/ Eliminate the old If in the loop body\n-  \/\/ If a range check is eliminated, data dependent nodes (Load and range check CastII nodes) are now dependent on 2\n-  \/\/ Hoisted Check Predicates (one for the start of the loop, one for the end) but we can only keep track of one control\n-  \/\/ dependency: pin the data dependent nodes.\n-  dominated_by(new_predicate_proj, iff, if_success_proj->_con != new_predicate_proj->_con, range_check_predicate);\n@@ -1298,0 +1300,6 @@\n+void PhaseIdealLoop::eliminate_hoisted_range_check(IfTrueNode* hoisted_check_proj,\n+                                                   IfTrueNode* template_assertion_predicate_proj) {\n+  _igvn.replace_input_of(hoisted_check_proj->in(0), 1, _igvn.intcon(1));\n+  rewire_safe_outputs_to_dominator(hoisted_check_proj, template_assertion_predicate_proj, true);\n+}\n+\n@@ -1301,1 +1309,1 @@\n-IfProjNode* PhaseIdealLoop::add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n+IfTrueNode* PhaseIdealLoop::add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n@@ -1315,1 +1323,1 @@\n-  IfProjNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n+  IfTrueNode* new_proj = create_new_if_for_predicate(parse_predicate_proj, nullptr, reason, overflow ? Op_If : iff->Opcode());\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":30,"deletions":22,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -1380,1 +1380,1 @@\n-  IfProjNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n+  IfTrueNode* add_template_assertion_predicate(IfNode* iff, IdealLoopTree* loop, IfProjNode* if_proj,\n@@ -1384,0 +1384,1 @@\n+  void eliminate_hoisted_range_check(IfTrueNode* hoisted_check_proj, IfTrueNode* template_assertion_predicate_proj);\n@@ -1538,0 +1539,1 @@\n+  void rewire_safe_outputs_to_dominator(Node* source, Node* dominator, bool pin_array_access_nodes);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -343,1 +343,3 @@\n-  if (iff->outcnt() != 2) return;\n+  if (iff->outcnt() != 2) {\n+    return;\n+  }\n@@ -350,1 +352,1 @@\n-  if (dp == nullptr)\n+  if (dp == nullptr) {\n@@ -352,0 +354,4 @@\n+  }\n+\n+  rewire_safe_outputs_to_dominator(dp, prevdom, pin_array_access_nodes);\n+}\n@@ -353,1 +359,2 @@\n-  IdealLoopTree* old_loop = get_loop(dp);\n+void PhaseIdealLoop::rewire_safe_outputs_to_dominator(Node* source, Node* dominator, const bool pin_array_access_nodes) {\n+  IdealLoopTree* old_loop = get_loop(source);\n@@ -355,2 +362,2 @@\n-  for (DUIterator_Fast imax, i = dp->fast_outs(imax); i < imax; i++) {\n-    Node* cd = dp->fast_out(i); \/\/ Control-dependent node\n+  for (DUIterator_Fast imax, i = source->fast_outs(imax); i < imax; i++) {\n+    Node* out = source->fast_out(i); \/\/ Control-dependent node\n@@ -358,3 +365,3 @@\n-    if (cd->depends_only_on_test() && _igvn.no_dependent_zero_check(cd)) {\n-      assert(cd->in(0) == dp, \"\");\n-      _igvn.replace_input_of(cd, 0, prevdom);\n+    if (out->depends_only_on_test() && _igvn.no_dependent_zero_check(out)) {\n+      assert(out->in(0) == source, \"must be control dependent on source\");\n+      _igvn.replace_input_of(out, 0, dominator);\n@@ -368,1 +375,1 @@\n-        Node* clone = cd->pin_array_access_node();\n+        Node* clone = out->pin_array_access_node();\n@@ -370,3 +377,3 @@\n-          clone = _igvn.register_new_node_with_optimizer(clone, cd);\n-          _igvn.replace_node(cd, clone);\n-          cd = clone;\n+          clone = _igvn.register_new_node_with_optimizer(clone, out);\n+          _igvn.replace_node(out, clone);\n+          out = clone;\n@@ -375,2 +382,2 @@\n-      set_early_ctrl(cd, false);\n-      IdealLoopTree* new_loop = get_loop(get_ctrl(cd));\n+      set_early_ctrl(out, false);\n+      IdealLoopTree* new_loop = get_loop(get_ctrl(out));\n@@ -379,1 +386,1 @@\n-          old_loop->_body.yank(cd);\n+          old_loop->_body.yank(out);\n@@ -382,1 +389,1 @@\n-          new_loop->_body.push(cd);\n+          new_loop->_body.push(out);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":23,"deletions":16,"binary":false,"changes":39,"status":"modified"}]}