{"files":[{"patch":"@@ -216,0 +216,2 @@\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  \/\/ StoreLoad achieves this.\n@@ -535,0 +537,2 @@\n+    \/\/ We need a full fence after clearing owner to avoid stranding.\n+    \/\/ StoreLoad achieves this.\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2732,0 +2732,2 @@\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  \/\/ StoreLoad achieves this.\n@@ -3007,0 +3009,2 @@\n+      \/\/ We need a full fence after clearing owner to avoid stranding.\n+      \/\/ StoreLoad achieves this.\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,0 +232,2 @@\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  \/\/ StoreLoad achieves this.\n@@ -561,0 +563,2 @@\n+    \/\/ We need a full fence after clearing owner to avoid stranding.\n+    \/\/ StoreLoad achieves this.\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3666,1 +3666,2 @@\n-  z_fence(); \/\/ membar(StoreLoad);\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  z_fence();\n@@ -3685,1 +3686,1 @@\n-  z_cr(currentHeader, Z_thread); \/\/ Set flag = NE\n+  z_ltgr(oop, oop); \/\/ Set flag = NE\n@@ -6428,1 +6429,2 @@\n-      z_fence(); \/\/ membar(StoreLoad);\n+      \/\/ We need a full fence after clearing owner to avoid stranding.\n+      z_fence();\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -476,0 +476,2 @@\n+  \/\/ We need a full fence after clearing owner to avoid stranding.\n+  \/\/ StoreLoad achieves this.\n@@ -805,0 +807,2 @@\n+    \/\/ We need a full fence after clearing owner to avoid stranding.\n+    \/\/ StoreLoad achieves this.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -714,1 +714,1 @@\n-  assert(mark.is_locked(), \"must be\");\n+  assert(!mark.is_unlocked(), \"must be\");\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-bool ObjectMonitor::TryLock_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark) {\n+bool ObjectMonitor::TryLockWithContentionMark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark) {\n@@ -358,1 +358,1 @@\n-  bool success = ObjectMonitor::TryLock_with_contention_mark(locking_thread, contention_mark);\n+  bool success = TryLockWithContentionMark(locking_thread, contention_mark);\n@@ -376,1 +376,1 @@\n-  bool success = ObjectMonitor::TryLock_with_contention_mark(locking_thread, contention_mark);\n+  bool success = TryLockWithContentionMark(locking_thread, contention_mark);\n@@ -385,2 +385,2 @@\n-bool ObjectMonitor::try_enter(JavaThread* current) {\n-  \/\/ TryLock avoids the CAS\n+bool ObjectMonitor::try_enter(JavaThread* current, bool check_owner) {\n+  \/\/ TryLock avoids the CAS and handles deflation.\n@@ -393,4 +393,8 @@\n-  if (r == TryLockResult::HasOwner && owner() == current) {\n-    _recursions++;\n-    return true;\n-  }\n+  \/\/ Set check_owner to false (it's default value is true) if you want\n+  \/\/ to use ObjectMonitor::try_enter() as a public way of doing TryLock().\n+  \/\/ Used this way in SharedRuntime::monitor_exit_helper().\n+  if (check_owner) {\n+    if (r == TryLockResult::HasOwner && owner() == current) {\n+      _recursions++;\n+      return true;\n+    }\n@@ -398,6 +402,7 @@\n-  void* cur = owner_raw();\n-  if (LockingMode == LM_LEGACY && current->is_lock_owned((address)cur)) {\n-    assert(_recursions == 0, \"internal state error\");\n-    _recursions = 1;\n-    set_owner_from_BasicLock(cur, current);  \/\/ Convert from BasicLock* to Thread*.\n-    return true;\n+    void* cur = owner_raw();\n+    if (LockingMode == LM_LEGACY && current->is_lock_owned((address)cur)) {\n+      assert(_recursions == 0, \"internal state error\");\n+      _recursions = 1;\n+      set_owner_from_BasicLock(cur, current);  \/\/ Convert from BasicLock* to Thread*.\n+      return true;\n+    }\n@@ -405,1 +410,0 @@\n-\n@@ -578,1 +582,1 @@\n-      if (TryLock_with_contention_mark(current, contention_mark)) {\n+      if (TryLockWithContentionMark(current, contention_mark)) {\n@@ -1223,7 +1227,0 @@\n-    \/\/\n-    void* owner = try_set_owner_from(nullptr, current);\n-    if (owner != nullptr) {\n-      if (owner != DEFLATER_MARKER) {\n-        \/\/ Owned by another thread, so we are done.\n-        return;\n-      }\n@@ -1231,37 +1228,4 @@\n-      \/\/ The deflator owns the lock.  Now try to cancel the async\n-      \/\/ deflation.  As part of the contended enter protocol,\n-      \/\/ contentions was incremented to a positive value before\n-      \/\/ EnterI() was called and that prevents the deflater thread\n-      \/\/ from winning the last part of the 2-part async deflation\n-      \/\/ protocol. After EnterI() returns to enter(), contentions is\n-      \/\/ decremented because the caller now owns the monitor. We need\n-      \/\/ to increment contentions an extra time here (done by the\n-      \/\/ ObjectMonitorContentionMark constructor) to prevent the\n-      \/\/ deflater thread from winning the last part of the 2-part\n-      \/\/ async deflation protocol after the regular decrement occurs\n-      \/\/ in enter().\n-      ObjectMonitorContentionMark contention_mark(this);\n-\n-      if (is_being_async_deflated()) {\n-        assert((intptr_t(_EntryList) | intptr_t(_cxq)) == 0 || _succ != nullptr, \"\");\n-        \/\/ Mr. Deflator won the race, so we are done.\n-        return;\n-      }\n-\n-      \/\/ Now try to take the ownership.\n-      if (try_set_owner_from(DEFLATER_MARKER, current) == DEFLATER_MARKER) {\n-        \/\/ We successfully cancelled the in-progress async deflation.\n-        \/\/ By extending the lifetime of the contention_mark, we\n-        \/\/ prevent the destructor from decrementing the contentions\n-        \/\/ counter when the contention_mark goes out of scope. Instead\n-        \/\/ ObjectMonitor::deflate_monitor() will decrement contentions\n-        \/\/ after it recognizes that the async deflation was cancelled.\n-        contention_mark.extend();\n-      } else {\n-        owner = try_set_owner_from(nullptr, current);\n-        if (owner != nullptr) {\n-          \/\/ The lock is owned by another thread, who is now\n-          \/\/ responsible for ensuring succession, so we are done.\n-          return;\n-        }\n-      }\n+    if (TryLock(current) != TryLockResult::Success) {\n+      \/\/ Some other thread acquired the lock (or the monitor was\n+      \/\/ deflated). Either way we are done.\n+      return;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":25,"deletions":61,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-  bool      try_enter(JavaThread* current);\n+  bool      try_enter(JavaThread* current, bool check_owner = true);\n@@ -359,3 +359,0 @@\n-  enum class TryLockResult { Interference = -1, HasOwner = 0, Success = 1 };\n-  TryLockResult  TryLock(JavaThread* current);\n-\n@@ -376,1 +373,0 @@\n-  bool      TryLock_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark);\n@@ -380,0 +376,7 @@\n+\n+\n+  enum class TryLockResult { Interference = -1, HasOwner = 0, Success = 1 };\n+\n+  bool           TryLockWithContentionMark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark);\n+  TryLockResult  TryLock(JavaThread* current);\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1970,1 +1970,1 @@\n-    if (m->TryLock(current) != ObjectMonitor::TryLockResult::Success) {\n+    if (!m->try_enter(current, false)) {\n@@ -1973,1 +1973,1 @@\n-      current->inc_held_monitor_count(-1);\n+      current->dec_held_monitor_count();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}