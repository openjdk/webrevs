{"files":[{"patch":"@@ -233,0 +233,1 @@\n+  position end  = from+size;\n@@ -234,0 +235,1 @@\n+  VMATreap::Range range(nullptr, nullptr);\n@@ -235,8 +237,21 @@\n-  VMATreap::Range range = _tree.find_enclosing_range(from);\n-  assert(range.start != nullptr && range.end != nullptr,\n-         \"Setting a memory tag must be done within existing range\");\n-  if (range.start == nullptr || range.end == nullptr) {\n-    log_debug(nmt)(\"set_tag called on non-existent range: \" PTR_FORMAT \" - \" PTR_FORMAT,\n-                   from, from+size);\n-    return SummaryDiff();\n-  }\n+  auto find_next_range = [&]() -> bool {\n+    range = _tree.find_enclosing_range(from);\n+    if ((range.start == nullptr && range.end == nullptr) ||\n+        (range.start != nullptr && range.end == nullptr)) {\n+      \/\/ There is no range containing the starting address\n+      assert(range.start->val().out.type() == StateType::Released, \"must be\");\n+      return false;\n+    } else if (range.start == nullptr && range.end != nullptr) {\n+      position found_end = pos(range.end);\n+      if (found_end >= end) {\n+        \/\/ The found address is outside of our range, we can end now.\n+        return false;\n+      }\n+      \/\/ There is at least one range [found_end, ?) which starts within [start, end)\n+      \/\/ Use this as the range instead.\n+      range = _tree.find_enclosing_range(found_end);\n+      remsize = end - found_end;\n+      from = found_end;\n+    }\n+    return true;\n+  };\n@@ -244,1 +259,7 @@\n-  position end = MIN2(from + remsize, pos(range.end));\n+  bool success = find_next_range();\n+  assert(range.start != nullptr && range.end != nullptr, \"must be\");\n+  if (!success) return SummaryDiff();\n+\n+  end = MIN2(from + remsize, pos(range.end));\n+  IntervalState& out = out_state(range.start);\n+  StateType type = out.type();\n@@ -246,1 +267,0 @@\n-  StateType type = out_state(range.start).type();\n@@ -250,1 +270,1 @@\n-    RegionData new_data = RegionData(out_state(range.start).stack(), tag);\n+    RegionData new_data = RegionData(out.stack(), tag);\n@@ -261,7 +281,5 @@\n-    \/\/ use find_enclosing_range repeatedly\n-    range = _tree.find_enclosing_range(from);\n-    assert(range.start != nullptr && range.end != nullptr,\n-           \"Setting a memory tag must be done within existing range.\");\n-    if (range.start == nullptr || range.end == nullptr) {\n-      break;\n-    }\n+    \/\/ use find_next_range repeatedly\n+    bool success = find_next_range();\n+    assert(range.start != nullptr && range.end != nullptr, \"must be\");\n+    if (!success) return diff;\n+\n@@ -269,1 +287,3 @@\n-    StateType type = out_state(range.start).type();\n+    IntervalState& out = out_state(range.start);\n+    StateType type = out.type();\n+\n@@ -271,1 +291,1 @@\n-      RegionData new_data = RegionData(out_state(range.start).stack(), tag);\n+      RegionData new_data = RegionData(out.stack(), tag);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":40,"deletions":20,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -208,1 +208,3 @@\n-  \/\/ Modify all ranges found in range [from, from+size) to have tag.\n+  \/\/ Given an interval and a tag, find all reserved and committed ranges within that\n+  \/\/ interval and set their tag to the one provided.\n+  \/\/ \n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -310,0 +310,1 @@\n+  \/\/ Small size optimization: \n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -440,0 +440,7 @@\n+\n+  {\n+    VMATree tree;\n+    Tree::RegionData class_shared(si, mtClassShared);\n+    tree.reserve_mapping(10, 10, class_shared);\n+    tree.set_tag(0, 100, mtCompiler);\n+  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}