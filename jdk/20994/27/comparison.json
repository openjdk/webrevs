{"files":[{"patch":"@@ -237,0 +237,4 @@\n+  int size() {\n+    return _node_count;\n+  }\n+\n@@ -307,0 +311,32 @@\n+  TreapNode* closest_gt(const K& key) {\n+    TreapNode* candidate = nullptr;\n+    TreapNode* pos = _root;\n+    while (pos != nullptr) {\n+      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r > 0) {\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_left;\n+      } else if (cmp_r <= 0) {\n+        pos = pos->_right;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  struct Range {\n+    TreapNode* start;\n+    TreapNode* end;\n+    Range(TreapNode* start, TreapNode* end)\n+    : start(start), end(end) {}\n+  };\n+\n+  \/\/ Return the range [start, end)\n+  \/\/ where start->key() <= addr < end->key().\n+  \/\/ Failure to find the range leads to start and\/or end being null.\n+  Range find_enclosing_range(K addr) {\n+    TreapNode* start = closest_leq(addr);\n+    TreapNode* end = closest_gt(addr);\n+    return Range(start, end);\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -85,1 +86,1 @@\n-    stB.out = leqA_n->val().out;\n+    stB.out = out_state(leqA_n);\n@@ -90,1 +91,1 @@\n-      stA.in = leqA_n->val().in;\n+      stA.in = in_state(leqA_n);\n@@ -116,1 +117,1 @@\n-      stA.in = leqA_n->val().out; \/\/ .. and the region's prior state is the incoming state\n+      stA.in = out_state(leqA_n); \/\/ .. and the region's prior state is the incoming state\n@@ -137,1 +138,1 @@\n-    stB.out = head->val().out;\n+    stB.out = out_state(head);\n@@ -218,0 +219,94 @@\n+\n+#ifdef ASSERT\n+void VMATree::print_on(outputStream* out) {\n+  visit_in_order([&](TreapNode* current) {\n+    out->print(SIZE_FORMAT \" (%s) - %s - \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n+               statetype_to_string(out_state(current).type()));\n+  });\n+  out->cr();\n+}\n+#endif\n+\n+VMATree::SummaryDiff VMATree::set_tag(const position start, const size size, const MemTag tag) {\n+  auto pos = [](TreapNode* n) { return n->key(); };\n+  position from = start;\n+  position end  = from+size;\n+  size_t remsize = size;\n+  VMATreap::Range range(nullptr, nullptr);\n+\n+  auto find_next_range = [&]() -> bool {\n+    range = _tree.find_enclosing_range(from);\n+    if ((range.start == nullptr && range.end == nullptr) ||\n+        (range.start != nullptr && range.end == nullptr)) {\n+      \/\/ There is no range containing the starting address\n+      assert(range.start->val().out.type() == StateType::Released, \"must be\");\n+      return false;\n+    } else if (range.start == nullptr && range.end != nullptr) {\n+      position found_end = pos(range.end);\n+      if (found_end >= end) {\n+        \/\/ The found address is outside of our range, we can end now.\n+        return false;\n+      }\n+      \/\/ There is at least one range [found_end, ?) which starts within [start, end)\n+      \/\/ Use this as the range instead.\n+      range = _tree.find_enclosing_range(found_end);\n+      remsize = end - found_end;\n+      from = found_end;\n+    }\n+    return true;\n+  };\n+\n+  bool success = find_next_range();\n+  if (!success) return SummaryDiff();\n+  assert(range.start != nullptr && range.end != nullptr, \"must be\");\n+\n+  end = MIN2(from + remsize, pos(range.end));\n+  IntervalState& out = out_state(range.start);\n+  StateType type = out.type();\n+\n+  SummaryDiff diff;\n+  \/\/ Ignore any released ranges, these must be mtNone and have no stack\n+  if (type != StateType::Released) {\n+    RegionData new_data = RegionData(out.stack(), tag);\n+    SummaryDiff result = register_mapping(from, end, type, new_data);\n+    diff.add(result);\n+  }\n+\n+  remsize = remsize - (end - from);\n+  from = end;\n+\n+  \/\/ If end < from + sz then there are multiple ranges for which to set the flag.\n+  while (end < from + remsize) {\n+    \/\/ Using register_mapping may invalidate the already found range, so we must\n+    \/\/ use find_next_range repeatedly\n+    bool success = find_next_range();\n+    if (!success) return diff;\n+    assert(range.start != nullptr && range.end != nullptr, \"must be\");\n+\n+    end = MIN2(from + remsize, pos(range.end));\n+    IntervalState& out = out_state(range.start);\n+    StateType type = out.type();\n+\n+    if (type != StateType::Released) {\n+      RegionData new_data = RegionData(out.stack(), tag);\n+      SummaryDiff result = register_mapping(from, end, type, new_data);\n+      diff.add(result);\n+    }\n+    remsize = remsize - (end - from);\n+    from = end;\n+  }\n+\n+  return diff;\n+}\n+\n+#ifdef ASSERT\n+void VMATree::SummaryDiff::print_on(outputStream* out) {\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    if (tag[i].reserve == 0 && tag[i].commit == 0) {\n+      continue;\n+    }\n+    out->print_cr(\"Tag %s R: \" INT64_FORMAT \" C: \" INT64_FORMAT, NMTUtil::tag_to_enum_name((MemTag)i), tag[i].reserve,\n+                  tag[i].commit);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":99,"deletions":4,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -33,0 +33,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -45,0 +46,1 @@\n+  using size = size_t;\n@@ -143,0 +145,8 @@\n+  static IntervalState& in_state(TreapNode* node) {\n+    return node->val().in;\n+  }\n+\n+  static IntervalState& out_state(TreapNode* node) {\n+    return node->val().out;\n+  }\n+\n@@ -165,0 +175,1 @@\n+\n@@ -172,0 +183,11 @@\n+\n+    void add(SummaryDiff& other) {\n+      for (int i = 0; i < mt_number_of_tags; i++) {\n+        tag[i].reserve += other.tag[i].reserve;\n+        tag[i].commit += other.tag[i].commit;\n+      }\n+    }\n+\n+#ifdef ASSERT\n+    void print_on(outputStream* out);\n+#endif\n@@ -178,2 +200,6 @@\n-  SummaryDiff reserve_mapping(position from, position sz, const RegionData& metadata) {\n-    return register_mapping(from, from + sz, StateType::Reserved, metadata, false);\n+  SummaryDiff reserve_mapping(position from, size size, const RegionData& metadata) {\n+    return register_mapping(from, from + size, StateType::Reserved, metadata, false);\n+  }\n+\n+  SummaryDiff commit_mapping(position from, size size, const RegionData& metadata, bool use_tag_inplace = false) {\n+    return register_mapping(from, from + size, StateType::Committed, metadata, use_tag_inplace);\n@@ -182,2 +208,7 @@\n-  SummaryDiff commit_mapping(position from, position sz, const RegionData& metadata, bool use_tag_inplace = false) {\n-    return register_mapping(from, from + sz, StateType::Committed, metadata, use_tag_inplace);\n+  \/\/ Given an interval and a tag, find all reserved and committed ranges within that\n+  \/\/ interval and set their tag to the one provided.\n+  \/\/ \n+  SummaryDiff set_tag(position from, size size, MemTag tag);\n+\n+  SummaryDiff uncommit_mapping(position from, size size, const RegionData& metadata) {\n+    return register_mapping(from, from + size, StateType::Reserved, metadata, true);\n@@ -186,2 +217,2 @@\n-  SummaryDiff uncommit_mapping(position from, position sz, const RegionData& metadata) {\n-    return register_mapping(from, from + sz, StateType::Reserved, metadata, true);\n+  SummaryDiff release_mapping(position from, size size) {\n+    return register_mapping(from, from + size, StateType::Released, VMATree::empty_regiondata);\n@@ -190,2 +221,2 @@\n-  SummaryDiff release_mapping(position from, position sz) {\n-    return register_mapping(from, from + sz, StateType::Released, VMATree::empty_regiondata);\n+  VMATreap& tree() {\n+    return _tree;\n@@ -199,0 +230,5 @@\n+\n+#ifdef ASSERT\n+  void print_on(outputStream* out);\n+#endif\n+\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -310,0 +310,1 @@\n+  \/\/ Small size optimization: \n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gtest\/gtest.h\"\n@@ -34,1 +35,1 @@\n-using Node = Tree::TreapNode;\n+using TreeNode = Tree::TreapNode;\n@@ -80,1 +81,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -133,1 +134,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -158,1 +159,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -190,1 +191,1 @@\n-  tree.visit_in_order([&](Node* node) {\n+  tree.visit_in_order([&](TreeNode* node) {\n@@ -230,1 +231,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -267,1 +268,1 @@\n-    treap(tree).visit_range_in_order(0, 99999, [&](Node* x) {\n+    treap(tree).visit_range_in_order(0, 99999, [&](TreeNode* x) {\n@@ -287,0 +288,182 @@\n+TEST_VM_F(NMTVMATreeTest, SetTag) {\n+  using State = VMATree::StateType;\n+  struct testrange {\n+    VMATree::position from;\n+    VMATree::position to;\n+    MemTag tag;\n+    NCS::StackIndex stack;\n+    State state;\n+  };\n+\n+  \/\/ Take a sorted list of testranges and check that those and only those are found in the tree.\n+  auto expect_equivalent_form = [&](auto& expected, VMATree& tree) {\n+    \/\/ With auto& our arrays do not deteriorate to pointers but are kept as testrange[N]\n+    \/\/ so this actually works!\n+    int len = sizeof(expected) \/ sizeof(testrange);\n+    VMATree::position previous_to = 0;\n+    for (int i = 0; i < len; i++) {\n+      testrange expect = expected[i];\n+      assert(previous_to == 0 || previous_to <= expect.from, \"the expected list must be sorted\");\n+      previous_to = expect.to;\n+\n+      VMATree::VMATreap::Range found = tree.tree().find_enclosing_range(expect.from);\n+      ASSERT_NE(nullptr, found.start);\n+      ASSERT_NE(nullptr, found.end);\n+      \/\/ Same region\n+      EXPECT_EQ(expect.from, found.start->key());\n+      EXPECT_EQ(expect.to, found.end->key());\n+      \/\/ Same tag\n+      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag());\n+      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag());\n+      \/\/ Same stack\n+      EXPECT_EQ(expect.stack, found.start->val().out.stack());\n+      EXPECT_EQ(expect.stack, found.end->val().in.stack());\n+      \/\/ Same state\n+      EXPECT_EQ(expect.state, found.start->val().out.type());\n+      EXPECT_EQ(expect.state, found.end->val().in.type());\n+    }\n+    \/\/ expected must cover all nodes\n+    EXPECT_EQ(len+1, tree.tree().size());\n+  };\n+  NCS::StackIndex si = NCS::StackIndex();\n+  Tree::RegionData rd(si, mtNone);\n+\n+  { \/\/ The gc\/cds case with only reserved data\n+    testrange expected[2]{\n+        {  0, 500,          mtGC, si, State::Reserved},\n+        {500, 600, mtClassShared, si, State::Reserved}\n+    };\n+    VMATree tree;\n+\n+    tree.reserve_mapping(0, 600, rd);\n+\n+    tree.set_tag(0, 500, mtGC);\n+    tree.set_tag(500, 100, mtClassShared);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Now let's add in some committed data\n+    testrange expected[]{\n+        {  0, 100,          mtGC, si, State::Reserved},\n+        {100, 225,          mtGC, si, State::Committed},\n+        {225, 500,          mtGC, si, State::Reserved},\n+        {500, 550, mtClassShared, si, State::Reserved},\n+        {550, 560, mtClassShared, si, State::Committed},\n+        {560, 565, mtClassShared, si, State::Reserved},\n+        {565, 575, mtClassShared, si, State::Committed},\n+        {575, 600, mtClassShared, si, State::Reserved}\n+    };\n+    VMATree tree;\n+\n+    tree.reserve_mapping(0, 600, rd);\n+    \/\/ The committed areas\n+    tree.commit_mapping(100, 125, rd);\n+    tree.commit_mapping(550, 10, rd);\n+    tree.commit_mapping(565, 10, rd);\n+    \/\/ OK, set tag\n+    tree.set_tag(0, 500, mtGC);\n+    tree.set_tag(500, 100, mtClassShared);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Setting the tag for adjacent regions with same stacks should merge the regions\n+    testrange expected[]{\n+        {0, 200, mtGC, si, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData gc(si, mtGC);\n+    Tree::RegionData compiler(si, mtCompiler);\n+    tree.reserve_mapping(0, 100, gc);\n+    tree.reserve_mapping(100, 100, compiler);\n+    tree.set_tag(0, 200, mtGC);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Setting the tag for adjacent regions with different stacks should NOT merge the regions\n+    NCS::StackIndex si1 = 1;\n+    NCS::StackIndex si2 = 2;\n+    testrange expected[]{\n+        {  0, 100, mtGC, si1, State::Reserved},\n+        {100, 200, mtGC, si2, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData gc(si1, mtGC);\n+    Tree::RegionData compiler(si2, mtCompiler);\n+    tree.reserve_mapping(0, 100, gc);\n+    tree.reserve_mapping(100, 100, compiler);\n+    tree.set_tag(0, 200, mtGC);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Setting the tag in the middle of a range causes a split\n+    testrange expected[]{\n+        {  0, 100, mtCompiler, si, State::Reserved},\n+        {100, 150,       mtGC, si, State::Reserved},\n+        {150, 200, mtCompiler, si, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData compiler(si, mtCompiler);\n+    tree.reserve_mapping(0, 200, compiler);\n+    tree.set_tag(100, 50, mtGC);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Setting the tag in between two ranges causes a split\n+    testrange expected[]{\n+        {  0,  75,       mtGC, si, State::Reserved},\n+        { 75, 125,    mtClass, si, State::Reserved},\n+        {125, 200, mtCompiler, si, State::Reserved},\n+    };\n+    VMATree tree;\n+    Tree::RegionData gc(si, mtGC);\n+    Tree::RegionData compiler(si, mtCompiler);\n+    tree.reserve_mapping(0, 100, gc);\n+    tree.reserve_mapping(100, 100, compiler);\n+    tree.set_tag(75, 50, mtClass);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Holes in the address range are acceptable and untouched\n+    testrange expected[]{\n+        { 0,  50,          mtGC, si, State::Reserved},\n+        {50,  75,        mtNone, si, State::Released},\n+        {75,  80,          mtGC, si, State::Reserved},\n+        {80, 100, mtClassShared, si, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData class_shared(si, mtClassShared);\n+    tree.reserve_mapping(0, 50, class_shared);\n+    tree.reserve_mapping(75, 25, class_shared);\n+    tree.set_tag(0, 80, mtGC);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Check that setting tag with 'hole' not consisting of any regions work\n+    testrange expected[]{\n+        {10, 20, mtCompiler, si, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData class_shared(si, mtClassShared);\n+    tree.reserve_mapping(10, 10, class_shared);\n+    tree.set_tag(0, 100, mtCompiler);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  { \/\/ Check that multiple holes still work\n+    testrange expected[]{\n+        { 0,   1,   mtGC, si, State::Reserved},\n+        { 1,  50, mtNone, si, State::Released},\n+        {50,  75,   mtGC, si, State::Reserved},\n+        {75,  99, mtNone, si, State::Released},\n+        {99, 100,   mtGC, si, State::Reserved}\n+    };\n+    VMATree tree;\n+    Tree::RegionData class_shared(si, mtClassShared);\n+    tree.reserve_mapping(0, 100, class_shared);\n+    tree.release_mapping(1, 49);\n+    tree.release_mapping(75, 24);\n+    tree.set_tag(0, 100, mtGC);\n+    expect_equivalent_form(expected, tree);\n+  }\n+}\n+\n@@ -333,1 +516,1 @@\n-  { \/\/ Adjacent reserved mappings with different flags\n+  { \/\/ Adjacent reserved mappings with different tags\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":191,"deletions":8,"binary":false,"changes":199,"status":"modified"}]}