{"files":[{"patch":"@@ -237,0 +237,4 @@\n+  int size() {\n+    return _node_count;\n+  }\n+\n@@ -307,0 +311,30 @@\n+  TreapNode* closest_gt(const K& key) {\n+    TreapNode* candidate = nullptr;\n+    TreapNode* pos = _root;\n+    while (pos != nullptr) {\n+      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r > 0) {\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_left;\n+      } else if (cmp_r <= 0) {\n+        pos = pos->_right;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  struct Range {\n+    TreapNode* start;\n+    TreapNode* end;\n+  };\n+\n+  \/\/ Return the range [start, end)\n+  \/\/ where start->key() <= addr < end->key().\n+  \/\/ Failure to find the range leads to start and\/or end being null.\n+  Range find_enclosing_range(K addr) {\n+    TreapNode* start = closest_leq(addr);\n+    TreapNode* end = closest_gt(addr);\n+    return Range{start, end};\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -85,1 +86,1 @@\n-    stB.out = leqA_n->val().out;\n+    stB.out = out_state(leqA_n);\n@@ -90,1 +91,1 @@\n-      stA.in = leqA_n->val().in;\n+      stA.in = in_state(leqA_n);\n@@ -116,1 +117,1 @@\n-      stA.in = leqA_n->val().out; \/\/ .. and the region's prior state is the incoming state\n+      stA.in = out_state(leqA_n); \/\/ .. and the region's prior state is the incoming state\n@@ -137,1 +138,1 @@\n-    stB.out = head->val().out;\n+    stB.out = out_state(head);\n@@ -218,0 +219,62 @@\n+\n+#ifdef ASSERT\n+void VMATree::print_on(outputStream* out) {\n+  visit_in_order([&](TreapNode* current) {\n+    out->print(SIZE_FORMAT \" (%s) - %s - \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n+               statetype_to_string(out_state(current).type()));\n+  });\n+  out->cr();\n+}\n+#endif\n+\n+VMATree::SummaryDiff VMATree::set_tag(position from, size size, MemTag tag) {\n+  VMATreap::Range range = _tree.find_enclosing_range(from);\n+  assert(range.start != nullptr && range.end != nullptr,\n+         \"Setting a memory tag must be done within existing range\");\n+  if (range.start == nullptr || range.end == nullptr) {\n+    log_debug(nmt)(\"set_tag called on non-existent range: \" PTR_FORMAT \" - \" PTR_FORMAT,\n+                   from, from+size);\n+    return SummaryDiff();\n+  }\n+\n+  StateType type = out_state(range.start).type();\n+  RegionData new_data = RegionData(out_state(range.start).stack(), tag);\n+\n+  position end = MIN2(from + size, pos(range.end));\n+  SummaryDiff diff = register_mapping(from, end, type, new_data);\n+  size = size - (end - from);\n+  from = end;\n+\n+  \/\/ If end < from + sz then there are multiple ranges for which to set the flag.\n+  while (end < from + size) {\n+    \/\/ Using register_mapping may invalidate the already found range, so we must\n+    \/\/ use find_enclosing_range repeatedly\n+    range = _tree.find_enclosing_range(from);\n+    assert(range.start != nullptr && range.end != nullptr,\n+           \"Setting a memory tag must be done within existing range.\");\n+    if (range.start == nullptr || range.end == nullptr) {\n+      break;\n+    }\n+    end = MIN2(from + size, pos(range.end));\n+    StateType type = out_state(range.start).type();\n+    RegionData new_data = RegionData(out_state(range.start).stack(), tag);\n+    SummaryDiff result = register_mapping(from, end, type, new_data);\n+    diff.add(result);\n+    size = size - (end - from);\n+    from = end;\n+  }\n+\n+  return diff;\n+}\n+\n+#ifdef ASSERT\n+void VMATree::SummaryDiff::print_on(outputStream* out) {\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    if (tag[i].reserve == 0 && tag[i].commit == 0) {\n+      continue;\n+    }\n+    out->print_cr(\"Tag %s R: \" INT64_FORMAT \" C: \" INT64_FORMAT, NMTUtil::tag_to_enum_name((MemTag)i), tag[i].reserve,\n+                  tag[i].commit);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":67,"deletions":4,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -33,0 +33,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -45,0 +46,1 @@\n+  using size = size_t;\n@@ -143,0 +145,12 @@\n+  static IntervalState& in_state(TreapNode* node) {\n+    return node->val().in;\n+  }\n+\n+  static IntervalState& out_state(TreapNode* node) {\n+    return node->val().out;\n+  }\n+\n+  static position pos(const TreapNode* node) {\n+    return node->key();\n+  }\n+\n@@ -165,0 +179,1 @@\n+\n@@ -172,0 +187,11 @@\n+\n+    void add(SummaryDiff& other) {\n+      for (int i = 0; i < mt_number_of_tags; i++) {\n+        tag[i].reserve += other.tag[i].reserve;\n+        tag[i].commit += other.tag[i].commit;\n+      }\n+    }\n+\n+#ifdef ASSERT\n+    void print_on(outputStream* out);\n+#endif\n@@ -186,0 +212,3 @@\n+  \/\/ Modify all ranges found in range [from, from+size) to have tag.\n+  SummaryDiff set_tag(position from, size size, MemTag tag);\n+\n@@ -190,1 +219,1 @@\n-  SummaryDiff release_mapping(position from, position sz) {\n+  SummaryDiff release_mapping(position from, size sz) {\n@@ -194,0 +223,4 @@\n+  VMATreap& tree() {\n+    return _tree;\n+  }\n+\n@@ -199,0 +232,5 @@\n+\n+#ifdef ASSERT\n+  void print_on(outputStream* out);\n+#endif\n+\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gtest\/gtest.h\"\n@@ -34,1 +35,1 @@\n-using Node = Tree::TreapNode;\n+using TreeNode = Tree::TreapNode;\n@@ -80,1 +81,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -133,1 +134,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -158,1 +159,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -190,1 +191,1 @@\n-  tree.visit_in_order([&](Node* node) {\n+  tree.visit_in_order([&](TreeNode* node) {\n@@ -230,1 +231,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -267,1 +268,1 @@\n-    treap(tree).visit_range_in_order(0, 99999, [&](Node* x) {\n+    treap(tree).visit_range_in_order(0, 99999, [&](TreeNode* x) {\n@@ -287,0 +288,75 @@\n+TEST_VM_F(NMTVMATreeTest, SetTag) {\n+  using State = VMATree::StateType;\n+  auto i = [](MemTag f) -> uint8_t { return (uint8_t)f; };\n+  struct testrange {\n+    VMATree::position from;\n+    VMATree::position to;\n+    MemTag tag;\n+    NCS::StackIndex stack;\n+    State state;\n+  };\n+\n+  \/\/ Take a list of testranges and check that those and only those are found in the tree.\n+  auto expect_equivalent_form = [&](auto& expected, VMATree& tree) {\n+    int len = sizeof(expected) \/ sizeof(testrange);\n+    for (int i = 0; i < len; i++) {\n+      testrange expect = expected[i];\n+      VMATree::VMATreap::Range found = tree.tree().find_enclosing_range(expect.from);\n+      ASSERT_NE(nullptr, found.start);\n+      ASSERT_NE(nullptr, found.end);\n+      \/\/ Same region\n+      EXPECT_EQ(expect.from, found.start->key());\n+      EXPECT_EQ(expect.to, found.end->key());\n+      \/\/ Same tag\n+      EXPECT_EQ(expect.tag, found.start->val().out.mem_tag());\n+      EXPECT_EQ(expect.tag, found.end->val().in.mem_tag());\n+      \/\/ Same stack\n+      EXPECT_EQ(expect.stack, found.start->val().out.stack());\n+      EXPECT_EQ(expect.stack, found.end->val().in.stack());\n+    }\n+    EXPECT_EQ(len+1, tree.tree().size());\n+  };\n+  NCS::StackIndex si = NCS::StackIndex();\n+  Tree::RegionData rd(si, mtNone);\n+  \/\/ The gc\/cds case with only reserved data\n+  {\n+    testrange expected[2]{\n+        {  0, 500,          mtGC, si, State::Reserved},\n+        {500, 600, mtClassShared, si, State::Reserved}\n+    };\n+    VMATree tree;\n+\n+    tree.reserve_mapping(0, 600, rd);\n+\n+    tree.set_tag(0, 500, mtGC);\n+    tree.set_tag(500, 100, mtClassShared);\n+    expect_equivalent_form(expected, tree);\n+  }\n+\n+  \/\/ Now let's add in some committed data\n+  {\n+    testrange expected[]{\n+        {  0, 100,          mtGC, si, State::Reserved},\n+        {100, 225,          mtGC, si, State::Committed},\n+        {225, 500,          mtGC, si, State::Reserved},\n+        {500, 550, mtClassShared, si, State::Reserved},\n+        {550, 560, mtClassShared, si, State::Committed},\n+        {560, 565, mtClassShared, si, State::Reserved},\n+        {565, 575, mtClassShared, si, State::Committed},\n+        {575, 600, mtClassShared, si, State::Reserved}\n+    };\n+    VMATree tree;\n+\n+    tree.reserve_mapping(0, 600, rd);\n+    \/\/ The committed areas\n+    tree.commit_mapping(100, 125, rd);\n+    tree.commit_mapping(550, 10, rd);\n+    tree.commit_mapping(565, 10, rd);\n+    \/\/ OK, set tag\n+    tree.set_tag(0, 500, mtGC);\n+    tree.set_tag(500, 100, mtClassShared);\n+\n+    expect_equivalent_form(expected, tree);\n+  }\n+}\n+\n@@ -333,1 +409,1 @@\n-  { \/\/ Adjacent reserved mappings with different flags\n+  { \/\/ Adjacent reserved mappings with different tags\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":84,"deletions":8,"binary":false,"changes":92,"status":"modified"}]}