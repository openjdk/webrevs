{"files":[{"patch":"@@ -307,0 +307,30 @@\n+  TreapNode* closest_gt(const K& key) {\n+    TreapNode* candidate = nullptr;\n+    TreapNode* pos = _root;\n+    while (pos != nullptr) {\n+      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n+      if (cmp_r > 0) {\n+        \/\/ Found a match, try to find a better one.\n+        candidate = pos;\n+        pos = pos->_left;\n+      } else if (cmp_r <= 0) {\n+        pos = pos->_right;\n+      }\n+    }\n+    return candidate;\n+  }\n+\n+  struct Range {\n+    TreapNode* start;\n+    TreapNode* end;\n+  };\n+\n+  \/\/ Return the range [start, end)\n+  \/\/ where start->key() <= addr < end->key().\n+  \/\/ Failure to find the range leads to start and\/or end being null.\n+  Range find_enclosing_range(K addr) {\n+    TreapNode* start = closest_leq(addr);\n+    TreapNode* end = closest_gt(addr);\n+    return Range{start, end};\n+  }\n+\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    stB.out = leqA_n->val().out;\n+    stB.out = out_state(leqA_n);\n@@ -90,1 +90,1 @@\n-      stA.in = leqA_n->val().in;\n+      stA.in = in_state(leqA_n);\n@@ -116,1 +116,1 @@\n-      stA.in = leqA_n->val().out; \/\/ .. and the region's prior state is the incoming state\n+      stA.in = out_state(leqA_n); \/\/ .. and the region's prior state is the incoming state\n@@ -137,1 +137,1 @@\n-    stB.out = head->val().out;\n+    stB.out = out_state(head);\n@@ -218,0 +218,54 @@\n+\n+#ifdef ASSERT\n+void VMATree::print_on(outputStream* out) {\n+  visit_in_order([&](TreapNode* current) {\n+    out->print(SIZE_FORMAT \" (%s) - %s - \", current->key(), NMTUtil::tag_to_name(out_state(current).mem_tag()),\n+               statetype_to_string(out_state(current).type()));\n+  });\n+  out->cr();\n+}\n+#endif\n+\n+VMATree::SummaryDiff VMATree::set_tag(position from, size size, MemTag tag) {\n+  VMATreap::Range range = _tree.find_enclosing_range(from);\n+  assert(range.start != nullptr && range.end != nullptr,\n+         \"Setting a memory tag must be done within existing range\");\n+  StateType type = out_state(range.start).type();\n+  RegionData new_data = RegionData(out_state(range.start).stack(), tag);\n+\n+  position end = MIN2(from + size, range.end->key());\n+  SummaryDiff diff = register_mapping(from, end, type, new_data);\n+  size = size - (end - from);\n+  from = end;\n+\n+  \/\/ If end < from + sz then there are multiple ranges for which to set the flag.\n+  while (end < from + size) {\n+    range = _tree.find_enclosing_range(from);\n+    assert(range.start != nullptr && range.end != nullptr,\n+           \"Setting a memory tag must be done within existing range.\");\n+    if (range.start == nullptr || range.end == nullptr) {\n+      break;\n+    }\n+    end = MIN2(from + size, range.end->key());\n+    StateType type = out_state(range.start).type();\n+    RegionData new_data = RegionData(out_state(range.start).stack(), tag);\n+    SummaryDiff result = register_mapping(from, end, type, new_data);\n+    diff.add(result);\n+    size = size - (end - from);\n+    from = end;\n+  }\n+\n+  return diff;\n+}\n+\n+#ifdef ASSERT\n+void VMATree::SummaryDiff::print_on(outputStream* out) {\n+  for (int i = 0; i < mt_number_of_tags; i++) {\n+    if (tag[i].reserve == 0 && tag[i].commit == 0) {\n+      continue;\n+    }\n+    out->print_cr(\"Tag %s R: \" INT64_FORMAT \" C: \" INT64_FORMAT, NMTUtil::tag_to_enum_name((MemTag)i), tag[i].reserve,\n+                  tag[i].commit);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":58,"deletions":4,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"nmt\/memTag.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"runtime\/os.hpp\"\n@@ -33,0 +33,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -45,0 +46,1 @@\n+  using size = size_t;\n@@ -143,0 +145,8 @@\n+  IntervalState& in_state(TreapNode* node) {\n+    return node->val().in;\n+  }\n+\n+  IntervalState& out_state(TreapNode* node) {\n+    return node->val().out;\n+  }\n+\n@@ -165,0 +175,1 @@\n+\n@@ -172,0 +183,11 @@\n+\n+    void add(SummaryDiff& other) {\n+      for (int i = 0; i < mt_number_of_tags; i++) {\n+        tag[i].reserve += other.tag[i].reserve;\n+        tag[i].commit += other.tag[i].commit;\n+      }\n+    }\n+\n+#ifdef ASSERT\n+    void print_on(outputStream* out);\n+#endif\n@@ -186,0 +208,2 @@\n+  SummaryDiff set_tag(position from, size size, MemTag tag);\n+\n@@ -190,1 +214,1 @@\n-  SummaryDiff release_mapping(position from, position sz) {\n+  SummaryDiff release_mapping(position from, size sz) {\n@@ -199,0 +223,5 @@\n+\n+#ifdef ASSERT\n+  void print_on(outputStream* out);\n+#endif\n+\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-using Node = Tree::TreapNode;\n+using TreeNode = Tree::TreapNode;\n@@ -80,1 +80,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -133,1 +133,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -158,1 +158,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -230,1 +230,1 @@\n-    treap(tree).visit_in_order([&](Node* x) {\n+    treap(tree).visit_in_order([&](TreeNode* x) {\n@@ -267,1 +267,1 @@\n-    treap(tree).visit_range_in_order(0, 99999, [&](Node* x) {\n+    treap(tree).visit_range_in_order(0, 99999, [&](TreeNode* x) {\n@@ -287,0 +287,62 @@\n+TEST_VM_F(NMTVMATreeTest, SetTag) {\n+  auto i = [](MemTag f) -> uint8_t { return (uint8_t)f; };\n+\n+  \/\/ The gc\/cds case with only reserved data\n+  {\n+    VMATree::SummaryDiff diff;\n+    Tree::RegionData rd(NCS::StackIndex(), mtNone);\n+    VMATree tree;\n+\n+    VMATree::SummaryDiff result = tree.reserve_mapping(0, 500, rd);\n+    diff.add(result);\n+    EXPECT_EQ(500, diff.tag[i(mtNone)].reserve);\n+\n+    result = tree.reserve_mapping(500, 100, rd);\n+    diff.add(result);\n+    EXPECT_EQ(600, diff.tag[i(mtNone)].reserve);\n+\n+    result = tree.set_tag(0, 500, mtGC);\n+    diff.add(result);\n+    EXPECT_EQ(100, diff.tag[i(mtNone)].reserve);\n+    EXPECT_EQ(500, diff.tag[i(mtGC)].reserve);\n+\n+    result = tree.set_tag(500, 100, mtClassShared);\n+    diff.add(result);\n+    EXPECT_EQ(0, diff.tag[i(mtNone)].reserve);\n+    EXPECT_EQ(500, diff.tag[i(mtGC)].reserve);\n+    EXPECT_EQ(100, diff.tag[i(mtClassShared)].reserve);\n+  }\n+\n+  \/\/ Now let's add in some committed data\n+  {\n+    VMATree::SummaryDiff diff;\n+    Tree::RegionData rd(NCS::StackIndex(), mtNone);\n+    VMATree tree;\n+\n+    VMATree::SummaryDiff result = tree.reserve_mapping(0, 600, rd);\n+    diff.add(result);\n+    EXPECT_EQ(600, diff.tag[i(mtNone)].reserve);\n+\n+    \/\/ The committed areas\n+    result = tree.commit_mapping(100, 125, rd);\n+    diff.add(result);\n+    result = tree.commit_mapping(550, 10, rd);\n+    diff.add(result);\n+    result = tree.commit_mapping(565, 10, rd);\n+    diff.add(result);\n+\n+    \/\/ OK, set tag\n+    result = tree.set_tag(0, 500, mtGC);\n+    diff.add(result);\n+    EXPECT_EQ(100, diff.tag[i(mtNone)].reserve);\n+    EXPECT_EQ(500, diff.tag[i(mtGC)].reserve);\n+    EXPECT_EQ(125, diff.tag[i(mtGC)].commit);\n+\n+    result = tree.set_tag(500, 100, mtClassShared);\n+    diff.add(result);\n+    EXPECT_EQ(0, diff.tag[i(mtNone)].reserve);\n+    EXPECT_EQ(100, diff.tag[i(mtClassShared)].reserve);\n+    EXPECT_EQ(20, diff.tag[i(mtClassShared)].commit);\n+  }\n+}\n+\n@@ -333,1 +395,1 @@\n-  { \/\/ Adjacent reserved mappings with different flags\n+  { \/\/ Adjacent reserved mappings with different tags\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":69,"deletions":7,"binary":false,"changes":76,"status":"modified"}]}