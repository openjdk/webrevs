{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.nio.ByteBuffer;\n@@ -38,2 +37,0 @@\n-import java.util.function.IntFunction;\n-import java.util.function.LongFunction;\n@@ -377,4 +374,0 @@\n-    public void copyTo(ByteBuffer buffer) {\n-        buffer.put(elems, 0, size());\n-    }\n-\n@@ -430,10 +423,0 @@\n-    \/**\n-     * Join head and tail into an exact-size byte buffer\n-     *\/\n-    static ByteBuffer joinToBuffer(IntFunction<ByteBuffer> allocator, BufWriterImpl head, BufWriterImpl tail) {\n-        ByteBuffer buffer = allocator.apply(head.size() + tail.size());\n-        head.copyTo(buffer);\n-        tail.copyTo(buffer);\n-        return buffer;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.nio.ByteBuffer;\n@@ -40,1 +39,0 @@\n-import java.util.function.IntFunction;\n@@ -204,28 +202,0 @@\n-    public ByteBuffer buildToByteBuffer(IntFunction<ByteBuffer> allocator) {\n-\n-        \/\/ The logic of this is very carefully ordered.  We want to avoid\n-        \/\/ repeated buffer copyings, so we accumulate lists of writers which\n-        \/\/ all get written later into the same buffer.  But, writing can often\n-        \/\/ trigger CP \/ BSM insertions, so we cannot run the CP writer or\n-        \/\/ BSM writers until everything else is written.\n-\n-        \/\/ Do this early because it might trigger CP activity\n-        ClassEntry superclass = computeSuperclass();\n-        int interfaceEntriesSize = interfaceEntries.size();\n-        ClassEntry[] ies = buildInterfaceEnties(interfaceEntriesSize);\n-\n-        var constantPool = this.constantPool;\n-        \/\/ We maintain two writers, and then we join them at the end\n-        int size = sizeHint == 0 ? 256 : sizeHint;\n-        BufWriterImpl head = new BufWriterImpl(constantPool, context, size);\n-        BufWriterImpl tail = new BufWriterImpl(constantPool, context, size, thisClassEntry, majorVersion);\n-\n-        populateTail(tail, constantPool);\n-\n-        \/\/ Now we can make the head\n-        populateHead(head, constantPool, superclass, interfaceEntriesSize, ies);\n-\n-        \/\/ Join head and tail into an exact-size buffer\n-        return BufWriterImpl.joinToBuffer(allocator, head, tail);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":31,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run junit BuildAndParseBuffersAndSegments\n+ * @run junit BuildAndParseSegments\n@@ -42,1 +42,1 @@\n-class BuildAndParseBuffersAndSegments {\n+class BuildAndParseSegments {\n@@ -49,1 +49,1 @@\n-        try (InputStream is = BuildAndParseBuffersAndSegments.class.getResourceAsStream(\"BuildAndParseBuffersAndSegments.class\")) {\n+        try (InputStream is = BuildAndParseSegments.class.getResourceAsStream(\"BuildAndParseSegments.class\")) {\n","filename":"test\/jdk\/jdk\/classfile\/BuildAndParseSegments.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/jdk\/classfile\/BuildAndParseBuffersAndSegments.java","status":"renamed"}]}