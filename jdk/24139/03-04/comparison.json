{"files":[{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.io.IOException;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.classfile.CompoundElement;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentAllocator;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * MemorySegmentBenchmark\n+ *\/\n+@Warmup(iterations = 3)\n+@Measurement(iterations = 5)\n+@Fork(value = 1)\n+@State(Scope.Benchmark)\n+public class MemorySegmentBenchmark {\n+    private ClassFile classFile;\n+    private byte[] inputBytes0;\n+    private ClassModel model0;\n+    private byte[] inputBytes1;\n+    private ClassModel model1;\n+    private MemorySegment outputSegment;\n+    private SegmentAllocator segmentAllocator;\n+\n+    @Setup\n+    public void setup() throws IOException {\n+        classFile = ClassFile.of();\n+        FileSystem jrtFs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+        inputBytes0 = Files.readAllBytes(\n+                jrtFs.getPath(\"modules\/java.base\/java\/util\/AbstractMap.class\"));\n+        inputBytes1 = Files.readAllBytes(\n+                jrtFs.getPath(\"modules\/java.base\/java\/util\/TreeMap.class\"));\n+        \/\/ preallocate a big-enough space and zero it\n+        outputSegment = Arena.ofAuto().allocate(1 << 20);\n+        model0 = classFile.parse(inputBytes0);\n+        model1 = classFile.parse(inputBytes1);\n+        segmentAllocator = (_, _) -> outputSegment;\n+        \/\/ expand the models\n+        consume(model0);\n+        consume(model1);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void emitWithoutCopy0(Blackhole bh) {\n+        classFile.transformClass(segmentAllocator, model0, ClassTransform.ACCEPT_ALL);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void emitWithCopy0(Blackhole bh) {\n+        outputSegment.copyFrom(MemorySegment.ofArray(classFile.transformClass(model0, ClassTransform.ACCEPT_ALL)));\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void emitWithoutCopy1(Blackhole bh) {\n+        classFile.transformClass(segmentAllocator, model1, ClassTransform.ACCEPT_ALL);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    public void emitWithCopy1(Blackhole bh) {\n+        outputSegment.copyFrom(MemorySegment.ofArray(classFile.transformClass(model1, ClassTransform.ACCEPT_ALL)));\n+    }\n+\n+    private static void consume(CompoundElement<?> parent) {\n+        parent.forEach(e -> {\n+            if (e instanceof CompoundElement<?> ce) consume(ce);\n+        });\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/MemorySegmentBenchmark.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"}]}