{"files":[{"patch":"@@ -45,0 +45,1 @@\n+import java.lang.foreign.SegmentAllocator;\n@@ -47,1 +48,0 @@\n-import java.nio.ByteBuffer;\n@@ -53,2 +53,0 @@\n-import java.util.function.IntFunction;\n-import java.util.function.LongFunction;\n@@ -527,21 +525,0 @@\n-    \/**\n-     * Parses a {@code class} file into a {@link ClassModel}.\n-     * <p>\n-     * Due to the on-demand nature of {@code class} file parsing, an {@link\n-     * IllegalArgumentException} may be thrown on any accessor method invocation\n-     * on the returned model or any structure returned by the accessors in the\n-     * structure hierarchy.\n-     * <p>\n-     * On return, the byte buffer's position and limit will be unchanged.\n-     *\n-     * @param bytes a byte buffer containing the bytes of the {@code class} file\n-     * @return the class model\n-     * @throws IllegalArgumentException if the {@code class} file is malformed\n-     *         or of a version {@linkplain #latestMajorVersion() not supported}\n-     *         by the current runtime\n-     * @implNote The implementation may or may not support parsing directly from\n-     *           a given buffer. In the latter case, the implementation may copy\n-     *           the buffer's contents to a temporary array before parsing.\n-     *\/\n-    ClassModel parse(ByteBuffer bytes);\n-\n@@ -616,51 +593,0 @@\n-    \/**\n-     * Builds a {@code class} file into a byte buffer.\n-     * <p>\n-     * The allocator function must allocate a buffer with a\n-     * {@linkplain ByteBuffer#remaining remaining size}\n-     * which is <em>at least<\/em> as large as the size given to it.\n-     * If the allocated buffer has a size which is smaller than the size provided\n-     * to the allocator function, an unspecified exception may be thrown.\n-     * The class file data will be written to the allocated byte buffer at its\n-     * initial position. The returned buffer will have a position corresponding\n-     * to the first byte after the class file data.\n-     *\n-     * @param allocator the buffer allocator function\n-     * @param thisClass the name of the class to build\n-     * @param handler a handler that receives a {@link ClassBuilder}\n-     * @return the {@code class} file bytes\n-     * @throws IllegalArgumentException if {@code thisClass} represents a\n-     *         primitive type or building encounters a failure\n-     *\/\n-    default ByteBuffer buildToByteBuffer(IntFunction<ByteBuffer> allocator,\n-                                         ClassDesc thisClass,\n-                                         Consumer<? super ClassBuilder> handler) {\n-        ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n-        return buildToByteBuffer(allocator, pool.classEntry(thisClass), pool, handler);\n-    }\n-\n-    \/**\n-     * Builds a {@code class} file into a byte buffer using the provided constant\n-     * pool builder.\n-     * <p>\n-     * The allocator function must allocate a buffer with a\n-     * {@linkplain ByteBuffer#remaining remaining size}\n-     * which is <em>at least<\/em> as large as the size given to it.\n-     * If the allocated buffer has a size which is smaller than the size provided\n-     * to the allocator function, an unspecified exception may be thrown.\n-     * The class file data will be written to the allocated byte buffer at its\n-     * initial position. The returned buffer will have a position corresponding\n-     * to the first byte after the class file data.\n-     *\n-     * @param allocator the buffer allocator function\n-     * @param thisClassEntry the name of the class to build\n-     * @param constantPool the constant pool builder\n-     * @param handler a handler that receives a {@link ClassBuilder}\n-     * @return the {@code class} file bytes\n-     * @throws IllegalArgumentException if building encounters a failure\n-     *\/\n-    ByteBuffer buildToByteBuffer(IntFunction<ByteBuffer> allocator,\n-                                 ClassEntry thisClassEntry,\n-                                 ConstantPoolBuilder constantPool,\n-                                 Consumer<? super ClassBuilder> handler);\n-\n@@ -683,1 +609,1 @@\n-    default MemorySegment buildToMemorySegment(LongFunction<MemorySegment> allocator,\n+    default MemorySegment buildToMemorySegment(SegmentAllocator allocator,\n@@ -701,1 +627,1 @@\n-    MemorySegment buildToMemorySegment(LongFunction<MemorySegment> allocator,\n+    MemorySegment buildToMemorySegment(SegmentAllocator allocator,\n@@ -767,50 +693,0 @@\n-    \/**\n-     * Builds a module descriptor into a byte buffer.\n-     * <p>\n-     * The allocator function must allocate a buffer with a\n-     * {@linkplain ByteBuffer#remaining remaining size}\n-     * which is <em>at least<\/em> as large as the size given to it.\n-     * If the allocated buffer has a size which is smaller than the size provided\n-     * to the allocator function, an unspecified exception may be thrown.\n-     * The class file data will be written to the allocated byte buffer at its\n-     * initial position. The returned buffer will have a position corresponding\n-     * to the first byte after the class file data.\n-     *\n-     * @param allocator the buffer allocator function\n-     * @param moduleAttribute the {@code Module} attribute\n-     * @return the {@code class} file bytes\n-     * @throws IllegalArgumentException if building encounters a failure\n-     *\/\n-    default ByteBuffer buildModuleToByteBuffer(IntFunction<ByteBuffer> allocator,\n-                                               ModuleAttribute moduleAttribute) {\n-        return buildModuleToByteBuffer(allocator, moduleAttribute, clb -> {});\n-    }\n-\n-    \/**\n-     * Builds a module descriptor into a byte buffer.\n-     * <p>\n-     * The allocator function must allocate a buffer with a\n-     * {@linkplain ByteBuffer#remaining remaining size}\n-     * which is <em>at least<\/em> as large as the size given to it.\n-     * If the allocated buffer has a size which is smaller than the size provided\n-     * to the allocator function, an unspecified exception may be thrown.\n-     * The class file data will be written to the allocated byte buffer at its\n-     * initial position. The returned buffer will have a position corresponding\n-     * to the first byte after the class file data.\n-     *\n-     * @param allocator the buffer allocator function\n-     * @param moduleAttribute the {@code Module} attribute\n-     * @param handler a handler that receives a {@link ClassBuilder}\n-     * @return the {@code class} file bytes\n-     * @throws IllegalArgumentException if building encounters a failure\n-     *\/\n-    default ByteBuffer buildModuleToByteBuffer(IntFunction<ByteBuffer> allocator,\n-                                               ModuleAttribute moduleAttribute,\n-                                               Consumer<? super ClassBuilder> handler) {\n-        return buildToByteBuffer(allocator, CD_module_info, clb -> {\n-            clb.withFlags(AccessFlag.MODULE);\n-            clb.with(moduleAttribute);\n-            handler.accept(clb);\n-        });\n-    }\n-\n@@ -825,1 +701,1 @@\n-    default MemorySegment buildModuleToMemorySegment(LongFunction<MemorySegment> allocator,\n+    default MemorySegment buildModuleToMemorySegment(SegmentAllocator allocator,\n@@ -839,1 +715,1 @@\n-    default MemorySegment buildModuleToMemorySegment(LongFunction<MemorySegment> allocator,\n+    default MemorySegment buildModuleToMemorySegment(SegmentAllocator allocator,\n@@ -964,117 +840,0 @@\n-    \/**\n-     * Transform one {@code class} file into a new {@code class} file according\n-     * to a {@link ClassTransform}.  The transform will receive each element of\n-     * this class, as well as a {@link ClassBuilder} for building the new class.\n-     * The transform is free to preserve, remove, or replace elements as it\n-     * sees fit.\n-     * <p>\n-     * This method behaves as if:\n-     * {@snippet lang=java :\n-     * ConstantPoolBuilder cpb = null; \/\/ @replace substring=null; replacement=...\n-     * this.build(model.thisClass(), cpb,\n-     *            clb -> clb.transform(model, transform));\n-     * }\n-     * where {@code cpb} is determined by {@link ConstantPoolSharingOption}.\n-     * <p>\n-     * The allocator function must allocate a buffer with a\n-     * {@linkplain ByteBuffer#remaining remaining size}\n-     * which is <em>at least<\/em> as large as the size given to it.\n-     * If the allocated buffer has a size which is smaller than the size provided\n-     * to the allocator function, an unspecified exception may be thrown.\n-     * The class file data will be written to the allocated byte buffer at its\n-     * initial position. The returned buffer will have a position corresponding\n-     * to the first byte after the class file data.\n-     *\n-     * @apiNote\n-     * This is named {@code transformClass} instead of {@code transform} for\n-     * consistency with {@link ClassBuilder#transformField}, {@link\n-     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n-     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n-     * more generic and powerful.\n-     *\n-     * @param allocator the buffer allocator function\n-     * @param model the class model to transform\n-     * @param transform the transform\n-     * @return the bytes of the new class\n-     * @throws IllegalArgumentException if building encounters a failure\n-     * @see ConstantPoolSharingOption\n-     *\/\n-    default ByteBuffer transformClassToByteBuffer(IntFunction<ByteBuffer> allocator, ClassModel model, ClassTransform transform) {\n-        return transformClassToByteBuffer(allocator, model, model.thisClass(), transform);\n-    }\n-\n-    \/**\n-     * Transform one {@code class} file into a new {@code class} file according\n-     * to a {@link ClassTransform}.  The transform will receive each element of\n-     * this class, as well as a {@link ClassBuilder} for building the new class.\n-     * The transform is free to preserve, remove, or replace elements as it\n-     * sees fit.\n-     * <p>\n-     * The allocator function must allocate a buffer with a\n-     * {@linkplain ByteBuffer#remaining remaining size}\n-     * which is <em>at least<\/em> as large as the size given to it.\n-     * If the allocated buffer has a size which is smaller than the size provided\n-     * to the allocator function, an unspecified exception may be thrown.\n-     * The class file data will be written to the allocated byte buffer at its\n-     * initial position. The returned buffer will have a position corresponding\n-     * to the first byte after the class file data.\n-     *\n-     * @apiNote\n-     * This is named {@code transformClass} instead of {@code transform} for\n-     * consistency with {@link ClassBuilder#transformField}, {@link\n-     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n-     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n-     * more generic and powerful.\n-     *\n-     * @param allocator the buffer allocator function\n-     * @param model the class model to transform\n-     * @param newClassName new class name\n-     * @param transform the transform\n-     * @return the bytes of the new class\n-     * @throws IllegalArgumentException if building encounters a failure\n-     * @see ConstantPoolSharingOption\n-     *\/\n-    default ByteBuffer transformClassToByteBuffer(IntFunction<ByteBuffer> allocator, ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n-        return transformClassToByteBuffer(allocator, model, TemporaryConstantPool.INSTANCE.classEntry(newClassName), transform);\n-    }\n-\n-    \/**\n-     * Transform one {@code class} file into a new {@code class} file according\n-     * to a {@link ClassTransform}.  The transform will receive each element of\n-     * this class, as well as a {@link ClassBuilder} for building the new class.\n-     * The transform is free to preserve, remove, or replace elements as it\n-     * sees fit.\n-     * <p>\n-     * This method behaves as if:\n-     * {@snippet lang=java :\n-     * ConstantPoolBuilder cpb = null; \/\/ @replace substring=null; replacement=...\n-     * this.build(newClassName, cpb, clb -> clb.transform(model, transform));\n-     * }\n-     * where {@code cpb} is determined by {@link ConstantPoolSharingOption}.\n-     * <p>\n-     * The allocator function must allocate a buffer with a\n-     * {@linkplain ByteBuffer#remaining remaining size}\n-     * which is <em>at least<\/em> as large as the size given to it.\n-     * If the allocated buffer has a size which is smaller than the size provided\n-     * to the allocator function, an unspecified exception may be thrown.\n-     * The class file data will be written to the allocated byte buffer at its\n-     * initial position. The returned buffer will have a position corresponding\n-     * to the first byte after the class file data.\n-     *\n-     * @apiNote\n-     * This is named {@code transformClass} instead of {@code transform} for\n-     * consistency with {@link ClassBuilder#transformField}, {@link\n-     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n-     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n-     * more generic and powerful.\n-     *\n-     * @param allocator the buffer allocator function\n-     * @param model the class model to transform\n-     * @param newClassName new class name\n-     * @param transform the transform\n-     * @return the bytes of the new class\n-     * @throws IllegalArgumentException if building encounters a failure\n-     * @see ConstantPoolSharingOption\n-     *\/\n-    ByteBuffer transformClassToByteBuffer(IntFunction<ByteBuffer> allocator, ClassModel model, ClassEntry newClassName, ClassTransform transform);\n-\n@@ -1116,1 +875,1 @@\n-    default MemorySegment transformClassToMemorySegment(LongFunction<MemorySegment> allocator, ClassModel model, ClassTransform transform) {\n+    default MemorySegment transformClassToMemorySegment(SegmentAllocator allocator, ClassModel model, ClassTransform transform) {\n@@ -1148,1 +907,1 @@\n-    default MemorySegment transformClassToMemorySegment(LongFunction<MemorySegment> allocator, ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n+    default MemorySegment transformClassToMemorySegment(SegmentAllocator allocator, ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n@@ -1187,1 +946,1 @@\n-    MemorySegment transformClassToMemorySegment(LongFunction<MemorySegment> allocator, ClassModel model, ClassEntry newClassName, ClassTransform transform);\n+    MemorySegment transformClassToMemorySegment(SegmentAllocator allocator, ClassModel model, ClassEntry newClassName, ClassTransform transform);\n@@ -1207,9 +966,0 @@\n-    \/**\n-     * Verify a {@code class} file.  All verification errors found will be returned.\n-     *\n-     * @param bytes the {@code class} file bytes to verify\n-     * @return a list of verification errors, or an empty list if no error is\n-     * found\n-     *\/\n-    List<VerifyError> verify(ByteBuffer bytes);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":8,"deletions":258,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.SegmentAllocator;\n@@ -442,2 +443,2 @@\n-    static MemorySegment joinToMemorySegment(LongFunction<MemorySegment> allocator, BufWriterImpl head, BufWriterImpl tail) {\n-        MemorySegment segment = allocator.apply((long)head.size() + tail.size());\n+    static MemorySegment joinToMemorySegment(SegmentAllocator allocator, BufWriterImpl head, BufWriterImpl tail) {\n+        MemorySegment segment = allocator.allocate((long)head.size() + tail.size());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.foreign.SegmentAllocator;\n@@ -39,1 +40,0 @@\n-import java.nio.ByteBuffer;\n@@ -43,2 +43,0 @@\n-import java.util.function.IntFunction;\n-import java.util.function.LongFunction;\n@@ -156,17 +154,0 @@\n-    @Override\n-    public ClassModel parse(final ByteBuffer bytes) {\n-        \/\/ defensive copy\n-        ByteBuffer dup = bytes.duplicate();\n-        byte[] array;\n-        if (dup.hasArray()) {\n-            array = dup.array();\n-            if (array.length == dup.limit() && dup.arrayOffset() == 0 && dup.position() == 0) {\n-                return parse(array);\n-            }\n-        }\n-        \/\/ must copy the bytes\n-        array = new byte[dup.remaining()];\n-        dup.get(array);\n-        return parse(array);\n-    }\n-\n@@ -184,12 +165,1 @@\n-    public ByteBuffer buildToByteBuffer(IntFunction<ByteBuffer> allocator,\n-                                        ClassEntry thisClassEntry,\n-                                        ConstantPoolBuilder constantPool,\n-                                        Consumer<? super ClassBuilder> handler) {\n-        thisClassEntry = AbstractPoolEntry.maybeClone(constantPool, thisClassEntry);\n-        DirectClassBuilder builder = new DirectClassBuilder((SplitConstantPool)constantPool, this, thisClassEntry);\n-        handler.accept(builder);\n-        return builder.buildToByteBuffer(allocator);\n-    }\n-\n-    @Override\n-    public MemorySegment buildToMemorySegment(LongFunction<MemorySegment> allocator,\n+    public MemorySegment buildToMemorySegment(SegmentAllocator allocator,\n@@ -213,8 +183,1 @@\n-    public ByteBuffer transformClassToByteBuffer(IntFunction<ByteBuffer> allocator, ClassModel model, ClassEntry newClassName, ClassTransform transform) {\n-        ConstantPoolBuilder constantPool = sharedConstantPool() ? ConstantPoolBuilder.of(model)\n-                                                                : ConstantPoolBuilder.of();\n-        return buildToByteBuffer(allocator, newClassName, constantPool, transformationHandler((ClassImpl) model, transform));\n-    }\n-\n-    @Override\n-    public MemorySegment transformClassToMemorySegment(LongFunction<MemorySegment> allocator, ClassModel model, ClassEntry newClassName, ClassTransform transform) {\n+    public MemorySegment transformClassToMemorySegment(SegmentAllocator allocator, ClassModel model, ClassEntry newClassName, ClassTransform transform) {\n@@ -259,9 +222,0 @@\n-    @Override\n-    public List<VerifyError> verify(ByteBuffer bytes) {\n-        try {\n-            return verify(parse(bytes));\n-        } catch (IllegalArgumentException parsingError) {\n-            return List.of(new VerifyError(parsingError.getMessage()));\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":3,"deletions":49,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.lang.foreign.SegmentAllocator;\n@@ -40,1 +41,0 @@\n-import java.util.function.LongFunction;\n@@ -232,1 +232,1 @@\n-    public MemorySegment buildToMemorySegment(LongFunction<MemorySegment> allocator) {\n+    public MemorySegment buildToMemorySegment(SegmentAllocator allocator) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-        testWithModel(classFile, classFile.parse(ByteBuffer.wrap(originalBytes)));\n@@ -58,5 +57,0 @@\n-        ByteBuffer direct = ByteBuffer.allocateDirect(originalBytes.length);\n-        direct.put(originalBytes);\n-        direct.rewind();\n-        testWithModel(classFile, classFile.parse(direct));\n-\n@@ -73,3 +67,1 @@\n-            ByteBuffer asDirectBuffer = classFile.transformClassToByteBuffer(ByteBuffer::allocateDirect, model, ClassTransform.ACCEPT_ALL);\n-            asDirectBuffer.rewind();\n-            MemorySegment asSegment = classFile.transformClassToMemorySegment(arena::allocate, model, ClassTransform.ACCEPT_ALL);\n+            MemorySegment asSegment = classFile.transformClassToMemorySegment(arena, model, ClassTransform.ACCEPT_ALL);\n@@ -79,1 +71,0 @@\n-            Assertions.assertEquals(ByteBuffer.wrap(asArray), asDirectBuffer);\n","filename":"test\/jdk\/jdk\/classfile\/BuildAndParseBuffersAndSegments.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"}]}