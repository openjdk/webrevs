{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.classfile.attribute.CharacterRangeInfo;\n@@ -31,2 +30,0 @@\n-import java.lang.classfile.attribute.LocalVariableInfo;\n-import java.lang.classfile.attribute.LocalVariableTypeInfo;\n@@ -47,0 +44,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -49,0 +47,1 @@\n+import java.nio.ByteBuffer;\n@@ -54,0 +53,2 @@\n+import java.util.function.IntFunction;\n+import java.util.function.LongFunction;\n@@ -526,0 +527,40 @@\n+    \/**\n+     * Parses a {@code class} file into a {@link ClassModel}.\n+     * <p>\n+     * Due to the on-demand nature of {@code class} file parsing, an {@link\n+     * IllegalArgumentException} may be thrown on any accessor method invocation\n+     * on the returned model or any structure returned by the accessors in the\n+     * structure hierarchy.\n+     * <p>\n+     * On return, the byte buffer's position and limit will be unchanged.\n+     *\n+     * @param bytes a byte buffer containing the bytes of the {@code class} file\n+     * @return the class model\n+     * @throws IllegalArgumentException if the {@code class} file is malformed\n+     *         or of a version {@linkplain #latestMajorVersion() not supported}\n+     *         by the current runtime\n+     * @implNote The implementation may or may not support parsing directly from\n+     *           a given buffer. In the latter case, the implementation may copy\n+     *           the buffer's contents to a temporary array before parsing.\n+     *\/\n+    ClassModel parse(ByteBuffer bytes);\n+\n+    \/**\n+     * Parses a {@code class} file into a {@link ClassModel}.\n+     * <p>\n+     * Due to the on-demand nature of {@code class} file parsing, an {@link\n+     * IllegalArgumentException} may be thrown on any accessor method invocation\n+     * on the returned model or any structure returned by the accessors in the\n+     * structure hierarchy.\n+     *\n+     * @param bytes a memory segment containing the bytes of the {@code class} file\n+     * @return the class model\n+     * @throws IllegalArgumentException if the {@code class} file is malformed\n+     *         or of a version {@linkplain #latestMajorVersion() not supported}\n+     *         by the current runtime\n+     * @implNote The implementation may or may not support parsing directly from\n+     *           a given memory segment. In the latter case, the implementation may copy\n+     *           the memory segment's contents to a temporary array before parsing.\n+     *\/\n+    ClassModel parse(MemorySegment bytes);\n+\n@@ -575,0 +616,90 @@\n+    \/**\n+     * Builds a {@code class} file into a byte buffer.\n+     * <p>\n+     * The allocator function must allocate a buffer with a\n+     * {@linkplain ByteBuffer#remaining remaining size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated buffer has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception may be thrown.\n+     * The class file data will be written to the allocated byte buffer at its\n+     * initial position. The returned buffer will have a position corresponding\n+     * to the first byte after the class file data.\n+     *\n+     * @param allocator the buffer allocator function\n+     * @param thisClass the name of the class to build\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if {@code thisClass} represents a\n+     *         primitive type or building encounters a failure\n+     *\/\n+    default ByteBuffer buildToByteBuffer(IntFunction<ByteBuffer> allocator,\n+                                         ClassDesc thisClass,\n+                                         Consumer<? super ClassBuilder> handler) {\n+        ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n+        return buildToByteBuffer(allocator, pool.classEntry(thisClass), pool, handler);\n+    }\n+\n+    \/**\n+     * Builds a {@code class} file into a byte buffer using the provided constant\n+     * pool builder.\n+     * <p>\n+     * The allocator function must allocate a buffer with a\n+     * {@linkplain ByteBuffer#remaining remaining size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated buffer has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception may be thrown.\n+     * The class file data will be written to the allocated byte buffer at its\n+     * initial position. The returned buffer will have a position corresponding\n+     * to the first byte after the class file data.\n+     *\n+     * @param allocator the buffer allocator function\n+     * @param thisClassEntry the name of the class to build\n+     * @param constantPool the constant pool builder\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if building encounters a failure\n+     *\/\n+    ByteBuffer buildToByteBuffer(IntFunction<ByteBuffer> allocator,\n+                                 ClassEntry thisClassEntry,\n+                                 ConstantPoolBuilder constantPool,\n+                                 Consumer<? super ClassBuilder> handler);\n+\n+    \/**\n+     * Builds a {@code class} file into a memory segment.\n+     * <p>\n+     * The allocator function must allocate a memory segment with a\n+     * {@linkplain MemorySegment#byteSize() size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated segment has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception or error may be thrown.\n+     *\n+     * @param allocator the segment allocator function\n+     * @param thisClass the name of the class to build\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if {@code thisClass} represents a\n+     *         primitive type or building encounters a failure\n+     *\/\n+    default MemorySegment buildToMemorySegment(LongFunction<MemorySegment> allocator,\n+                                               ClassDesc thisClass,\n+                                               Consumer<? super ClassBuilder> handler) {\n+        ConstantPoolBuilder pool = ConstantPoolBuilder.of();\n+        return buildToMemorySegment(allocator, pool.classEntry(thisClass), pool, handler);\n+    }\n+\n+    \/**\n+     * Builds a {@code class} file into a memory segment using the provided constant\n+     * pool builder.\n+     *\n+     * @param allocator the segment allocator function\n+     * @param thisClassEntry the name of the class to build\n+     * @param constantPool the constant pool builder\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if building encounters a failure\n+     *\/\n+    MemorySegment buildToMemorySegment(LongFunction<MemorySegment> allocator,\n+                                       ClassEntry thisClassEntry,\n+                                       ConstantPoolBuilder constantPool,\n+                                       Consumer<? super ClassBuilder> handler);\n+\n@@ -636,0 +767,82 @@\n+    \/**\n+     * Builds a module descriptor into a byte buffer.\n+     * <p>\n+     * The allocator function must allocate a buffer with a\n+     * {@linkplain ByteBuffer#remaining remaining size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated buffer has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception may be thrown.\n+     * The class file data will be written to the allocated byte buffer at its\n+     * initial position. The returned buffer will have a position corresponding\n+     * to the first byte after the class file data.\n+     *\n+     * @param allocator the buffer allocator function\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if building encounters a failure\n+     *\/\n+    default ByteBuffer buildModuleToByteBuffer(IntFunction<ByteBuffer> allocator,\n+                                               ModuleAttribute moduleAttribute) {\n+        return buildModuleToByteBuffer(allocator, moduleAttribute, clb -> {});\n+    }\n+\n+    \/**\n+     * Builds a module descriptor into a byte buffer.\n+     * <p>\n+     * The allocator function must allocate a buffer with a\n+     * {@linkplain ByteBuffer#remaining remaining size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated buffer has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception may be thrown.\n+     * The class file data will be written to the allocated byte buffer at its\n+     * initial position. The returned buffer will have a position corresponding\n+     * to the first byte after the class file data.\n+     *\n+     * @param allocator the buffer allocator function\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if building encounters a failure\n+     *\/\n+    default ByteBuffer buildModuleToByteBuffer(IntFunction<ByteBuffer> allocator,\n+                                               ModuleAttribute moduleAttribute,\n+                                               Consumer<? super ClassBuilder> handler) {\n+        return buildToByteBuffer(allocator, CD_module_info, clb -> {\n+            clb.withFlags(AccessFlag.MODULE);\n+            clb.with(moduleAttribute);\n+            handler.accept(clb);\n+        });\n+    }\n+\n+    \/**\n+     * Builds a module descriptor into a memory segment.\n+     *\n+     * @param allocator the segment allocator function\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if building encounters a failure\n+     *\/\n+    default MemorySegment buildModuleToMemorySegment(LongFunction<MemorySegment> allocator,\n+                                                     ModuleAttribute moduleAttribute) {\n+        return buildModuleToMemorySegment(allocator, moduleAttribute, clb -> {});\n+    }\n+\n+    \/**\n+     * Builds a module descriptor into a memory segment.\n+     *\n+     * @param allocator the segment allocator function\n+     * @param moduleAttribute the {@code Module} attribute\n+     * @param handler a handler that receives a {@link ClassBuilder}\n+     * @return the {@code class} file bytes\n+     * @throws IllegalArgumentException if building encounters a failure\n+     *\/\n+    default MemorySegment buildModuleToMemorySegment(LongFunction<MemorySegment> allocator,\n+                                                     ModuleAttribute moduleAttribute,\n+                                                     Consumer<? super ClassBuilder> handler) {\n+        return buildToMemorySegment(allocator, CD_module_info, clb -> {\n+            clb.withFlags(AccessFlag.MODULE);\n+            clb.with(moduleAttribute);\n+            handler.accept(clb);\n+        });\n+    }\n+\n@@ -751,0 +964,225 @@\n+    \/**\n+     * Transform one {@code class} file into a new {@code class} file according\n+     * to a {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     * <p>\n+     * This method behaves as if:\n+     * {@snippet lang=java :\n+     * ConstantPoolBuilder cpb = null; \/\/ @replace substring=null; replacement=...\n+     * this.build(model.thisClass(), cpb,\n+     *            clb -> clb.transform(model, transform));\n+     * }\n+     * where {@code cpb} is determined by {@link ConstantPoolSharingOption}.\n+     * <p>\n+     * The allocator function must allocate a buffer with a\n+     * {@linkplain ByteBuffer#remaining remaining size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated buffer has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception may be thrown.\n+     * The class file data will be written to the allocated byte buffer at its\n+     * initial position. The returned buffer will have a position corresponding\n+     * to the first byte after the class file data.\n+     *\n+     * @apiNote\n+     * This is named {@code transformClass} instead of {@code transform} for\n+     * consistency with {@link ClassBuilder#transformField}, {@link\n+     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n+     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n+     * more generic and powerful.\n+     *\n+     * @param allocator the buffer allocator function\n+     * @param model the class model to transform\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     * @throws IllegalArgumentException if building encounters a failure\n+     * @see ConstantPoolSharingOption\n+     *\/\n+    default ByteBuffer transformClassToByteBuffer(IntFunction<ByteBuffer> allocator, ClassModel model, ClassTransform transform) {\n+        return transformClassToByteBuffer(allocator, model, model.thisClass(), transform);\n+    }\n+\n+    \/**\n+     * Transform one {@code class} file into a new {@code class} file according\n+     * to a {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     * <p>\n+     * The allocator function must allocate a buffer with a\n+     * {@linkplain ByteBuffer#remaining remaining size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated buffer has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception may be thrown.\n+     * The class file data will be written to the allocated byte buffer at its\n+     * initial position. The returned buffer will have a position corresponding\n+     * to the first byte after the class file data.\n+     *\n+     * @apiNote\n+     * This is named {@code transformClass} instead of {@code transform} for\n+     * consistency with {@link ClassBuilder#transformField}, {@link\n+     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n+     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n+     * more generic and powerful.\n+     *\n+     * @param allocator the buffer allocator function\n+     * @param model the class model to transform\n+     * @param newClassName new class name\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     * @throws IllegalArgumentException if building encounters a failure\n+     * @see ConstantPoolSharingOption\n+     *\/\n+    default ByteBuffer transformClassToByteBuffer(IntFunction<ByteBuffer> allocator, ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n+        return transformClassToByteBuffer(allocator, model, TemporaryConstantPool.INSTANCE.classEntry(newClassName), transform);\n+    }\n+\n+    \/**\n+     * Transform one {@code class} file into a new {@code class} file according\n+     * to a {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     * <p>\n+     * This method behaves as if:\n+     * {@snippet lang=java :\n+     * ConstantPoolBuilder cpb = null; \/\/ @replace substring=null; replacement=...\n+     * this.build(newClassName, cpb, clb -> clb.transform(model, transform));\n+     * }\n+     * where {@code cpb} is determined by {@link ConstantPoolSharingOption}.\n+     * <p>\n+     * The allocator function must allocate a buffer with a\n+     * {@linkplain ByteBuffer#remaining remaining size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated buffer has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception may be thrown.\n+     * The class file data will be written to the allocated byte buffer at its\n+     * initial position. The returned buffer will have a position corresponding\n+     * to the first byte after the class file data.\n+     *\n+     * @apiNote\n+     * This is named {@code transformClass} instead of {@code transform} for\n+     * consistency with {@link ClassBuilder#transformField}, {@link\n+     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n+     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n+     * more generic and powerful.\n+     *\n+     * @param allocator the buffer allocator function\n+     * @param model the class model to transform\n+     * @param newClassName new class name\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     * @throws IllegalArgumentException if building encounters a failure\n+     * @see ConstantPoolSharingOption\n+     *\/\n+    ByteBuffer transformClassToByteBuffer(IntFunction<ByteBuffer> allocator, ClassModel model, ClassEntry newClassName, ClassTransform transform);\n+\n+    \/**\n+     * Transform one {@code class} file into a new {@code class} file according\n+     * to a {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     * <p>\n+     * This method behaves as if:\n+     * {@snippet lang=java :\n+     * ConstantPoolBuilder cpb = null; \/\/ @replace substring=null; replacement=...\n+     * this.build(model.thisClass(), cpb,\n+     *            clb -> clb.transform(model, transform));\n+     * }\n+     * where {@code cpb} is determined by {@link ConstantPoolSharingOption}.\n+     * <p>\n+     * The allocator function must allocate a memory segment with a\n+     * {@linkplain MemorySegment#byteSize() size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated segment has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception or error may be thrown.\n+     *\n+     * @apiNote\n+     * This is named {@code transformClass} instead of {@code transform} for\n+     * consistency with {@link ClassBuilder#transformField}, {@link\n+     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n+     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n+     * more generic and powerful.\n+     *\n+     * @param allocator the segment allocator function\n+     * @param model the class model to transform\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     * @throws IllegalArgumentException if building encounters a failure\n+     * @see ConstantPoolSharingOption\n+     *\/\n+    default MemorySegment transformClassToMemorySegment(LongFunction<MemorySegment> allocator, ClassModel model, ClassTransform transform) {\n+        return transformClassToMemorySegment(allocator, model, model.thisClass(), transform);\n+    }\n+\n+    \/**\n+     * Transform one {@code class} file into a new {@code class} file according\n+     * to a {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     * <p>\n+     * The allocator function must allocate a memory segment with a\n+     * {@linkplain MemorySegment#byteSize() size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated segment has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception or error may be thrown.\n+     *\n+     * @apiNote\n+     * This is named {@code transformClass} instead of {@code transform} for\n+     * consistency with {@link ClassBuilder#transformField}, {@link\n+     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n+     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n+     * more generic and powerful.\n+     *\n+     * @param allocator the buffer allocator function\n+     * @param model the class model to transform\n+     * @param newClassName new class name\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     * @throws IllegalArgumentException if building encounters a failure\n+     * @see ConstantPoolSharingOption\n+     *\/\n+    default MemorySegment transformClassToMemorySegment(LongFunction<MemorySegment> allocator, ClassModel model, ClassDesc newClassName, ClassTransform transform) {\n+        return transformClassToMemorySegment(allocator, model, TemporaryConstantPool.INSTANCE.classEntry(newClassName), transform);\n+    }\n+\n+    \/**\n+     * Transform one {@code class} file into a new {@code class} file according\n+     * to a {@link ClassTransform}.  The transform will receive each element of\n+     * this class, as well as a {@link ClassBuilder} for building the new class.\n+     * The transform is free to preserve, remove, or replace elements as it\n+     * sees fit.\n+     * <p>\n+     * This method behaves as if:\n+     * {@snippet lang=java :\n+     * ConstantPoolBuilder cpb = null; \/\/ @replace substring=null; replacement=...\n+     * this.build(newClassName, cpb, clb -> clb.transform(model, transform));\n+     * }\n+     * where {@code cpb} is determined by {@link ConstantPoolSharingOption}.\n+     * <p>\n+     * The allocator function must allocate a memory segment with a\n+     * {@linkplain MemorySegment#byteSize() size}\n+     * which is <em>at least<\/em> as large as the size given to it.\n+     * If the allocated segment has a size which is smaller than the size provided\n+     * to the allocator function, an unspecified exception or error may be thrown.\n+     *\n+     * @apiNote\n+     * This is named {@code transformClass} instead of {@code transform} for\n+     * consistency with {@link ClassBuilder#transformField}, {@link\n+     * ClassBuilder#transformMethod}, and {@link MethodBuilder#transformCode},\n+     * and to distinguish from {@link ClassFileBuilder#transform}, which is\n+     * more generic and powerful.\n+     *\n+     * @param allocator the buffer allocator function\n+     * @param model the class model to transform\n+     * @param newClassName new class name\n+     * @param transform the transform\n+     * @return the bytes of the new class\n+     * @throws IllegalArgumentException if building encounters a failure\n+     * @see ConstantPoolSharingOption\n+     *\/\n+    MemorySegment transformClassToMemorySegment(LongFunction<MemorySegment> allocator, ClassModel model, ClassEntry newClassName, ClassTransform transform);\n+\n@@ -769,0 +1207,18 @@\n+    \/**\n+     * Verify a {@code class} file.  All verification errors found will be returned.\n+     *\n+     * @param bytes the {@code class} file bytes to verify\n+     * @return a list of verification errors, or an empty list if no error is\n+     * found\n+     *\/\n+    List<VerifyError> verify(ByteBuffer bytes);\n+\n+    \/**\n+     * Verify a {@code class} file.  All verification errors found will be returned.\n+     *\n+     * @param bytes the {@code class} file bytes to verify\n+     * @return a list of verification errors, or an empty list if no error is\n+     * found\n+     *\/\n+    List<VerifyError> verify(MemorySegment bytes);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":459,"deletions":3,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteBuffer;\n@@ -34,0 +37,2 @@\n+import java.util.function.IntFunction;\n+import java.util.function.LongFunction;\n@@ -371,0 +376,8 @@\n+    public void copyTo(ByteBuffer buffer) {\n+        buffer.put(elems, 0, size());\n+    }\n+\n+    public void copyTo(MemorySegment segment, long offset) {\n+        MemorySegment.copy(elems, 0, segment, ValueLayout.JAVA_BYTE, offset, size());\n+    }\n+\n@@ -415,0 +428,20 @@\n+\n+    \/**\n+     * Join head and tail into an exact-size byte buffer\n+     *\/\n+    static ByteBuffer joinToBuffer(IntFunction<ByteBuffer> allocator, BufWriterImpl head, BufWriterImpl tail) {\n+        ByteBuffer buffer = allocator.apply(head.size() + tail.size());\n+        head.copyTo(buffer);\n+        tail.copyTo(buffer);\n+        return buffer;\n+    }\n+\n+    \/**\n+     * Join head and tail into an exact-size memory segment\n+     *\/\n+    static MemorySegment joinToMemorySegment(LongFunction<MemorySegment> allocator, BufWriterImpl head, BufWriterImpl tail) {\n+        MemorySegment segment = allocator.apply((long)head.size() + tail.size());\n+        head.copyTo(segment, 0);\n+        tail.copyTo(segment, head.size());\n+        return segment;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteBuffer;\n@@ -40,0 +43,2 @@\n+import java.util.function.IntFunction;\n+import java.util.function.LongFunction;\n@@ -42,0 +47,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -138,0 +144,29 @@\n+    @Override\n+    public ClassModel parse(final MemorySegment bytes) {\n+        AbstractMemorySegmentImpl amsi = (AbstractMemorySegmentImpl) bytes;\n+        if (amsi.unsafeGetBase() instanceof byte[] ba) {\n+            if (amsi.unsafeGetOffset() == 0 && amsi.byteSize() == ba.length) {\n+                return parse(ba);\n+            }\n+        }\n+        \/\/ must copy the bytes\n+        return parse(bytes.toArray(ValueLayout.JAVA_BYTE));\n+    }\n+\n+    @Override\n+    public ClassModel parse(final ByteBuffer bytes) {\n+        \/\/ defensive copy\n+        ByteBuffer dup = bytes.duplicate();\n+        byte[] array;\n+        if (dup.hasArray()) {\n+            array = dup.array();\n+            if (array.length == dup.limit() && dup.arrayOffset() == 0 && dup.position() == 0) {\n+                return parse(array);\n+            }\n+        }\n+        \/\/ must copy the bytes\n+        array = new byte[dup.remaining()];\n+        dup.get(array);\n+        return parse(array);\n+    }\n+\n@@ -148,0 +183,22 @@\n+    @Override\n+    public ByteBuffer buildToByteBuffer(IntFunction<ByteBuffer> allocator,\n+                                        ClassEntry thisClassEntry,\n+                                        ConstantPoolBuilder constantPool,\n+                                        Consumer<? super ClassBuilder> handler) {\n+        thisClassEntry = AbstractPoolEntry.maybeClone(constantPool, thisClassEntry);\n+        DirectClassBuilder builder = new DirectClassBuilder((SplitConstantPool)constantPool, this, thisClassEntry);\n+        handler.accept(builder);\n+        return builder.buildToByteBuffer(allocator);\n+    }\n+\n+    @Override\n+    public MemorySegment buildToMemorySegment(LongFunction<MemorySegment> allocator,\n+                                              ClassEntry thisClassEntry,\n+                                              ConstantPoolBuilder constantPool,\n+                                              Consumer<? super ClassBuilder> handler) {\n+        thisClassEntry = AbstractPoolEntry.maybeClone(constantPool, thisClassEntry);\n+        DirectClassBuilder builder = new DirectClassBuilder((SplitConstantPool)constantPool, this, thisClassEntry);\n+        handler.accept(builder);\n+        return builder.buildToMemorySegment(allocator);\n+    }\n+\n@@ -152,9 +209,26 @@\n-        return build(newClassName, constantPool,\n-                new Consumer<ClassBuilder>() {\n-                    @Override\n-                    public void accept(ClassBuilder builder) {\n-                        ((DirectClassBuilder) builder).setOriginal((ClassImpl)model);\n-                        ((DirectClassBuilder) builder).setSizeHint(((ClassImpl)model).classfileLength());\n-                        builder.transform((ClassImpl)model, transform);\n-                    }\n-                });\n+        return build(newClassName, constantPool, transformationHandler((ClassImpl) model, transform));\n+    }\n+\n+    @Override\n+    public ByteBuffer transformClassToByteBuffer(IntFunction<ByteBuffer> allocator, ClassModel model, ClassEntry newClassName, ClassTransform transform) {\n+        ConstantPoolBuilder constantPool = sharedConstantPool() ? ConstantPoolBuilder.of(model)\n+                                                                : ConstantPoolBuilder.of();\n+        return buildToByteBuffer(allocator, newClassName, constantPool, transformationHandler((ClassImpl) model, transform));\n+    }\n+\n+    @Override\n+    public MemorySegment transformClassToMemorySegment(LongFunction<MemorySegment> allocator, ClassModel model, ClassEntry newClassName, ClassTransform transform) {\n+        ConstantPoolBuilder constantPool = sharedConstantPool() ? ConstantPoolBuilder.of(model)\n+                                                                : ConstantPoolBuilder.of();\n+        return buildToMemorySegment(allocator, newClassName, constantPool, transformationHandler((ClassImpl) model, transform));\n+    }\n+\n+    private static Consumer<ClassBuilder> transformationHandler(final ClassImpl model, final ClassTransform transform) {\n+        return new Consumer<ClassBuilder>() {\n+            @Override\n+            public void accept(ClassBuilder builder) {\n+                ((DirectClassBuilder) builder).setOriginal(model);\n+                ((DirectClassBuilder) builder).setSizeHint(model.classfileLength());\n+                builder.transform(model, transform);\n+            }\n+        };\n@@ -185,0 +259,18 @@\n+    @Override\n+    public List<VerifyError> verify(ByteBuffer bytes) {\n+        try {\n+            return verify(parse(bytes));\n+        } catch (IllegalArgumentException parsingError) {\n+            return List.of(new VerifyError(parsingError.getMessage()));\n+        }\n+    }\n+\n+    @Override\n+    public List<VerifyError> verify(MemorySegment bytes) {\n+        try {\n+            return verify(parse(bytes));\n+        } catch (IllegalArgumentException parsingError) {\n+            return List.of(new VerifyError(parsingError.getMessage()));\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":101,"deletions":9,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n@@ -37,0 +39,2 @@\n+import java.util.function.IntFunction;\n+import java.util.function.LongFunction;\n@@ -181,0 +185,4 @@\n+        ClassEntry superclass = computeSuperclass();\n+        int interfaceEntriesSize = interfaceEntries.size();\n+        ClassEntry[] ies = buildInterfaceEnties(interfaceEntriesSize);\n+\n@@ -182,5 +190,52 @@\n-        ClassEntry superclass = superclassEntry;\n-        if (superclass != null)\n-            superclass = AbstractPoolEntry.maybeClone(constantPool, superclass);\n-        else if ((flags & ClassFile.ACC_MODULE) == 0 && !\"java\/lang\/Object\".equals(thisClassEntry.asInternalName()))\n-            superclass = constantPool.classEntry(ConstantDescs.CD_Object);\n+        \/\/ We maintain two writers, and then we join them at the end\n+        int size = sizeHint == 0 ? 256 : sizeHint;\n+        BufWriterImpl head = new BufWriterImpl(constantPool, context, size);\n+        BufWriterImpl tail = new BufWriterImpl(constantPool, context, size, thisClassEntry, majorVersion);\n+\n+        populateTail(tail, constantPool);\n+\n+        \/\/ Now we can make the head\n+        populateHead(head, constantPool, superclass, interfaceEntriesSize, ies);\n+\n+        \/\/ Join head and tail into an exact-size buffer\n+        return BufWriterImpl.join(head, tail);\n+    }\n+\n+    public ByteBuffer buildToByteBuffer(IntFunction<ByteBuffer> allocator) {\n+\n+        \/\/ The logic of this is very carefully ordered.  We want to avoid\n+        \/\/ repeated buffer copyings, so we accumulate lists of writers which\n+        \/\/ all get written later into the same buffer.  But, writing can often\n+        \/\/ trigger CP \/ BSM insertions, so we cannot run the CP writer or\n+        \/\/ BSM writers until everything else is written.\n+\n+        \/\/ Do this early because it might trigger CP activity\n+        ClassEntry superclass = computeSuperclass();\n+        int interfaceEntriesSize = interfaceEntries.size();\n+        ClassEntry[] ies = buildInterfaceEnties(interfaceEntriesSize);\n+\n+        var constantPool = this.constantPool;\n+        \/\/ We maintain two writers, and then we join them at the end\n+        int size = sizeHint == 0 ? 256 : sizeHint;\n+        BufWriterImpl head = new BufWriterImpl(constantPool, context, size);\n+        BufWriterImpl tail = new BufWriterImpl(constantPool, context, size, thisClassEntry, majorVersion);\n+\n+        populateTail(tail, constantPool);\n+\n+        \/\/ Now we can make the head\n+        populateHead(head, constantPool, superclass, interfaceEntriesSize, ies);\n+\n+        \/\/ Join head and tail into an exact-size buffer\n+        return BufWriterImpl.joinToBuffer(allocator, head, tail);\n+    }\n+\n+    public MemorySegment buildToMemorySegment(LongFunction<MemorySegment> allocator) {\n+\n+        \/\/ The logic of this is very carefully ordered.  We want to avoid\n+        \/\/ repeated buffer copyings, so we accumulate lists of writers which\n+        \/\/ all get written later into the same buffer.  But, writing can often\n+        \/\/ trigger CP \/ BSM insertions, so we cannot run the CP writer or\n+        \/\/ BSM writers until everything else is written.\n+\n+        \/\/ Do this early because it might trigger CP activity\n+        ClassEntry superclass = computeSuperclass();\n@@ -188,1 +243,1 @@\n-        ClassEntry[] ies = interfaceEntriesSize == 0 ? EMPTY_CLASS_ENTRY_ARRAY : buildInterfaceEnties(interfaceEntriesSize);\n+        ClassEntry[] ies = buildInterfaceEnties(interfaceEntriesSize);\n@@ -190,0 +245,1 @@\n+        var constantPool = this.constantPool;\n@@ -195,0 +251,30 @@\n+        populateTail(tail, constantPool);\n+\n+        \/\/ Now we can make the head\n+        populateHead(head, constantPool, superclass, interfaceEntriesSize, ies);\n+\n+        \/\/ Join head and tail into an exact-size buffer\n+        return BufWriterImpl.joinToMemorySegment(allocator, head, tail);\n+    }\n+\n+    private ClassEntry computeSuperclass() {\n+        var constantPool = this.constantPool;\n+        ClassEntry superclass = superclassEntry;\n+        if (superclass != null)\n+            superclass = AbstractPoolEntry.maybeClone(constantPool, superclass);\n+        else if ((flags & ClassFile.ACC_MODULE) == 0 && !\"java\/lang\/Object\".equals(thisClassEntry.asInternalName()))\n+            superclass = constantPool.classEntry(ConstantDescs.CD_Object);\n+        return superclass;\n+    }\n+\n+    private ClassEntry[] buildInterfaceEnties(int interfaceEntriesSize) {\n+        if (interfaceEntriesSize == 0) {\n+            return EMPTY_CLASS_ENTRY_ARRAY;\n+        }\n+        var ies = new ClassEntry[interfaceEntriesSize];\n+        for (int i = 0; i < interfaceEntriesSize; i++)\n+            ies[i] = AbstractPoolEntry.maybeClone(constantPool, interfaceEntries.get(i));\n+        return ies;\n+    }\n+\n+    private void populateTail(final BufWriterImpl tail, final SplitConstantPool constantPool) {\n@@ -207,0 +293,1 @@\n+    }\n@@ -208,1 +295,1 @@\n-        \/\/ Now we can make the head\n+    private void populateHead(final BufWriterImpl head, final SplitConstantPool constantPool, final ClassEntry superclass, final int interfaceEntriesSize, final ClassEntry[] ies) {\n@@ -217,10 +304,0 @@\n-\n-        \/\/ Join head and tail into an exact-size buffer\n-        return BufWriterImpl.join(head, tail);\n-    }\n-\n-    private ClassEntry[] buildInterfaceEnties(int interfaceEntriesSize) {\n-        var ies = new ClassEntry[interfaceEntriesSize];\n-        for (int i = 0; i < interfaceEntriesSize; i++)\n-            ies[i] = AbstractPoolEntry.maybeClone(constantPool, interfaceEntries.get(i));\n-        return ies;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":94,"deletions":17,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.ClassTransform;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteBuffer;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8352536\n+ * @summary Test parsing and generating non-array class data\n+ * @run junit BuildAndParseBuffersAndSegments\n+ *\/\n+class BuildAndParseBuffersAndSegments {\n+\n+    @Test\n+    public void testParseAndGenerate() throws IOException {\n+        ClassFile classFile = ClassFile.of();\n+        \/\/ use our own class, why not?\n+        byte[] originalBytes;\n+        try (InputStream is = BuildAndParseBuffersAndSegments.class.getResourceAsStream(\"BuildAndParseBuffersAndSegments.class\")) {\n+            originalBytes = is.readAllBytes();\n+        }\n+\n+        testWithModel(classFile, classFile.parse(originalBytes));\n+        testWithModel(classFile, classFile.parse(ByteBuffer.wrap(originalBytes)));\n+        testWithModel(classFile, classFile.parse(MemorySegment.ofArray(originalBytes)));\n+\n+        ByteBuffer direct = ByteBuffer.allocateDirect(originalBytes.length);\n+        direct.put(originalBytes);\n+        direct.rewind();\n+        testWithModel(classFile, classFile.parse(direct));\n+\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment = arena.allocate(ValueLayout.JAVA_BYTE, originalBytes.length);\n+            segment.copyFrom(MemorySegment.ofArray(originalBytes));\n+            testWithModel(classFile, classFile.parse(segment));\n+        }\n+    }\n+\n+    private static void testWithModel(final ClassFile classFile, final ClassModel model) {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ transform to an array, buffers, and segments, and compare them all for equality\n+            ByteBuffer asDirectBuffer = classFile.transformClassToByteBuffer(ByteBuffer::allocateDirect, model, ClassTransform.ACCEPT_ALL);\n+            asDirectBuffer.rewind();\n+            MemorySegment asSegment = classFile.transformClassToMemorySegment(arena::allocate, model, ClassTransform.ACCEPT_ALL);\n+            byte[] asArray = classFile.transformClass(model, ClassTransform.ACCEPT_ALL);\n+\n+            Assertions.assertEquals(-1, asSegment.mismatch(MemorySegment.ofArray(asArray)));\n+            Assertions.assertEquals(ByteBuffer.wrap(asArray), asDirectBuffer);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/BuildAndParseBuffersAndSegments.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}