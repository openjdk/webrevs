{"files":[{"patch":"@@ -113,1 +113,1 @@\n-  ADD_EXCL(\"java\/util\/Collections\",                      \"EMPTY_LIST\");           \/\/ E\n+  ADD_EXCL(\"java\/util\/Collections\",                      \"EMPTY_LIST\");            \/\/ E\n@@ -118,0 +118,2 @@\n+\n+  ADD_EXCL(\"jdk\/internal\/loader\/BootLoader\",             \"UNNAMED_MODULE\");        \/\/ A\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-    assert(ik->module()->is_named(), \"unexpected archived package entry for a class in an unnamed module\");\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -45,0 +46,1 @@\n+  ModuleEntry* _unnamed_module;\n@@ -55,1 +57,1 @@\n-  ArchivedClassLoaderData() : _packages(nullptr), _modules(nullptr) {}\n+  ArchivedClassLoaderData() : _packages(nullptr), _modules(nullptr), _unnamed_module(nullptr) {}\n@@ -60,0 +62,3 @@\n+  ModuleEntry* unnamed_module() {\n+    return _unnamed_module;\n+  }\n@@ -64,0 +69,1 @@\n+    f->do_ptr(&_unnamed_module);\n@@ -74,0 +80,2 @@\n+static int _platform_loader_root_index = -1;\n+static int _system_loader_root_index = -1;\n@@ -81,0 +89,1 @@\n+    loader_data->unnamed_module()->iterate_symbols(closure);\n@@ -94,0 +103,1 @@\n+    _unnamed_module = loader_data->unnamed_module()->allocate_archived_entry();\n@@ -103,0 +113,1 @@\n+    _unnamed_module->init_as_archived_entry();\n@@ -120,0 +131,6 @@\n+      if (_unnamed_module != nullptr) {\n+        oop module_oop = _unnamed_module->module_oop();\n+        assert(module_oop != nullptr, \"must be already set\");\n+        assert(_unnamed_module == java_lang_Module::module_entry(module_oop), \"must be already set\");\n+        assert(loader_data->class_loader() == java_lang_Module::loader(module_oop), \"must be set in dump time\");\n+      }\n@@ -130,0 +147,3 @@\n+    if (_unnamed_module != nullptr) {\n+      _unnamed_module->clear_archived_oops();\n+    }\n@@ -180,0 +200,1 @@\n+\n@@ -183,0 +204,1 @@\n+\n@@ -184,0 +206,3 @@\n+\n+  _platform_loader_root_index = HeapShared::append_root(SystemDictionary::java_platform_loader());\n+  _system_loader_root_index = HeapShared::append_root(SystemDictionary::java_system_loader());\n@@ -191,0 +216,3 @@\n+  f->do_int(&_platform_loader_root_index);\n+  f->do_int(&_system_loader_root_index);\n+}\n@@ -192,6 +220,5 @@\n-  if (f->reading() && CDSConfig::is_using_full_module_graph()) {\n-    \/\/ Must be done before ClassLoader::create_javabase()\n-    _archived_boot_loader_data.restore(null_class_loader_data(), true, false);\n-    ModuleEntryTable::set_javabase_moduleEntry(_archived_javabase_moduleEntry);\n-    aot_log_info(aot)(\"use_full_module_graph = true; java.base = \" INTPTR_FORMAT,\n-                  p2i(_archived_javabase_moduleEntry));\n+ModuleEntry* ClassLoaderDataShared::archived_boot_unnamed_module() {\n+  if (CDSConfig::is_using_full_module_graph()) {\n+    return _archived_boot_loader_data.unnamed_module();\n+  } else {\n+    return nullptr;\n@@ -201,0 +228,18 @@\n+ModuleEntry* ClassLoaderDataShared::archived_unnamed_module(ClassLoaderData* loader_data) {\n+  ModuleEntry* archived_module = nullptr;\n+\n+  if (!Universe::is_module_initialized() && CDSConfig::is_using_full_module_graph()) {\n+    precond(_platform_loader_root_index >= 0);\n+    precond(_system_loader_root_index >= 0);\n+\n+    if (loader_data->class_loader() == HeapShared::get_root(_platform_loader_root_index)) {\n+      archived_module = _archived_platform_loader_data.unnamed_module();\n+    } else if (loader_data->class_loader() == HeapShared::get_root(_system_loader_root_index)) {\n+      archived_module = _archived_system_loader_data.unnamed_module();\n+    }\n+  }\n+\n+  return archived_module;\n+}\n+\n+\n@@ -206,0 +251,13 @@\n+  if (_platform_loader_root_index >= 0) {\n+    HeapShared::clear_root(_platform_loader_root_index);\n+    HeapShared::clear_root(_system_loader_root_index);\n+  }\n+}\n+\n+\/\/ Must be done before ClassLoader::create_javabase()\n+void ClassLoaderDataShared::restore_archived_entries_for_null_class_loader_data() {\n+  precond(CDSConfig::is_using_full_module_graph());\n+  _archived_boot_loader_data.restore(null_class_loader_data(), true, false);\n+  ModuleEntryTable::set_javabase_moduleEntry(_archived_javabase_moduleEntry);\n+  aot_log_info(aot)(\"use_full_module_graph = true; java.base = \" INTPTR_FORMAT,\n+                    p2i(_archived_javabase_moduleEntry));\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":65,"deletions":7,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+class ModuleEntry;\n@@ -45,0 +46,1 @@\n+  static void restore_archived_entries_for_null_class_loader_data();\n@@ -48,0 +50,2 @@\n+  static ModuleEntry* archived_boot_unnamed_module();\n+  static ModuleEntry* archived_unnamed_module(ClassLoaderData* loader_data);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -320,0 +322,9 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+  ModuleEntry* archived_unnamed_module = ClassLoaderDataShared::archived_unnamed_module(cld);\n+  if (archived_unnamed_module != nullptr) {\n+    archived_unnamed_module->load_from_archive(cld);\n+    archived_unnamed_module->restore_archived_oops(cld);\n+    return archived_unnamed_module;\n+  }\n+#endif\n+\n@@ -336,0 +347,10 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n+  ModuleEntry* archived_unnamed_module = ClassLoaderDataShared::archived_boot_unnamed_module();\n+  if (archived_unnamed_module != nullptr) {\n+    archived_unnamed_module->load_from_archive(cld);\n+    \/\/ It's too early to call archived_unnamed_module->restore_archived_oops(cld).\n+    \/\/ We will do it inside Modules::set_bootloader_unnamed_module()\n+    return archived_unnamed_module;\n+  }\n+#endif\n+\n@@ -348,1 +369,0 @@\n-\n@@ -398,0 +418,4 @@\n+bool ModuleEntry::should_be_archived() const {\n+  return SystemDictionaryShared::is_builtin_loader(loader_data());\n+}\n+\n@@ -399,1 +423,2 @@\n-  assert(is_named(), \"unnamed packages\/modules are not archived\");\n+  precond(should_be_archived());\n+  precond(CDSConfig::is_dumping_full_module_graph());\n@@ -403,6 +428,1 @@\n-  if (CDSConfig::is_dumping_full_module_graph()) {\n-    archived_entry->_archived_module_index = HeapShared::append_root(module_oop());\n-  } else {\n-    archived_entry->_archived_module_index = -1;\n-  }\n-\n+  archived_entry->_archived_module_index = HeapShared::append_root(module_oop());\n@@ -492,1 +512,0 @@\n-  _shared_path_index = AOTClassLocationConfig::dumptime()->get_module_shared_path_index(_location);\n@@ -494,0 +513,1 @@\n+    _shared_path_index = AOTClassLocationConfig::dumptime()->get_module_shared_path_index(_location);\n@@ -496,0 +516,4 @@\n+  } else {\n+    \/\/ _shared_path_index is used only by SystemDictionary::is_shared_class_visible_impl()\n+    \/\/ for checking classes in named modules.\n+    _shared_path_index = -1;\n@@ -744,1 +768,1 @@\n-void ModuleEntry::print(outputStream* st) {\n+void ModuleEntry::print(outputStream* st) const {\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":34,"deletions":10,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-  const char* name_as_C_string() {\n+  const char* name_as_C_string() const {\n@@ -192,1 +192,1 @@\n-  void print(outputStream* st = tty);\n+  void print(outputStream* st = tty) const;\n@@ -200,0 +200,1 @@\n+  bool should_be_archived() const;\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -477,0 +477,1 @@\n+static bool _seen_boot_unnamed_module = false;\n@@ -512,10 +513,8 @@\n-      \/\/ We only archive two unnamed module oops (for platform and system loaders). These do NOT have an archived\n-      \/\/ ModuleEntry.\n-      \/\/\n-      \/\/ At runtime, these oops are fetched from java_lang_ClassLoader::unnamedModule(loader) and\n-      \/\/ are initialized in ClassLoaderData::ClassLoaderData() => ModuleEntry::create_unnamed_module(), where\n-      \/\/ a new ModuleEntry is allocated.\n-      assert(!loader_data->is_boot_class_loader_data(), \"unnamed module for boot loader should be not archived\");\n-      assert(!orig_module_ent->has_been_archived(), \"sanity\");\n-\n-      if (SystemDictionary::is_platform_class_loader(loader_data->class_loader())) {\n+      \/\/ We always archive unnamed module oop for boot, platform, and system loaders.\n+      precond(orig_module_ent->should_be_archived());\n+      precond(orig_module_ent->has_been_archived());\n+\n+      if (loader_data->is_boot_class_loader_data()) {\n+        assert(!_seen_boot_unnamed_module, \"only once\");\n+        _seen_boot_unnamed_module = true;\n+      } else if (SystemDictionary::is_platform_class_loader(loader_data->class_loader())) {\n@@ -528,2 +527,0 @@\n-        \/\/ The java.lang.Module oop and ModuleEntry of the unnamed module of the boot loader are\n-        \/\/ not in the archived module graph. These are always allocated at runtime.\n@@ -780,3 +777,12 @@\n-  unnamed_module->set_module_handle(boot_loader_data->add_handle(module));\n-  \/\/ Store pointer to the ModuleEntry in the unnamed module's java.lang.Module object.\n-  java_lang_Module::set_module_entry(module(), unnamed_module);\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+  if (CDSConfig::is_using_full_module_graph()) {\n+    precond(unnamed_module == ClassLoaderDataShared::archived_boot_unnamed_module());\n+    unnamed_module->restore_archived_oops(boot_loader_data);\n+  } else\n+#endif\n+  {\n+    unnamed_module->set_module_handle(boot_loader_data->add_handle(module));\n+    \/\/ Store pointer to the ModuleEntry in the unnamed module's java.lang.Module object.\n+    java_lang_Module::set_module_entry(module(), unnamed_module);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -221,0 +222,4 @@\n+bool PackageEntry::should_be_archived() const {\n+  return module()->should_be_archived();\n+}\n+\n@@ -222,1 +227,1 @@\n-  assert(!in_unnamed_module(), \"unnamed packages\/modules are not archived\");\n+  precond(should_be_archived());\n@@ -260,0 +265,6 @@\n+\n+  LogStreamHandle(Info, aot, package) st;\n+  if (st.is_enabled()) {\n+    st.print(\"archived \");\n+    print(&st);\n+  }\n@@ -283,1 +294,1 @@\n-    if (p->module()->is_named()) {\n+    if (p->should_be_archived()) {\n@@ -293,3 +304,1 @@\n-    if (p->module()->is_named()) {\n-      \/\/ We don't archive unnamed modules, or packages in unnamed modules. They will be\n-      \/\/ created on-demand at runtime as classes in such packages are loaded.\n+    if (p->should_be_archived()) {\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,0 +211,1 @@\n+  bool should_be_archived() const;\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  LOG_TAG(package) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n@@ -900,2 +901,0 @@\n-  ClassLoaderData::init_null_class_loader_data();\n-\n@@ -908,0 +907,8 @@\n+#endif\n+\n+  ClassLoaderData::init_null_class_loader_data();\n+\n+#if INCLUDE_CDS\n+  if (CDSConfig::is_using_full_module_graph()) {\n+    ClassLoaderDataShared::restore_archived_entries_for_null_class_loader_data();\n+  }\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+    private final Module unnamedModuleForBootLoader;\n@@ -55,0 +56,1 @@\n+        unnamedModuleForBootLoader = BootLoader.getUnnamedModule();\n@@ -85,0 +87,4 @@\n+    Module unnamedModuleForBootLoader() {\n+        return unnamedModuleForBootLoader;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/ArchivedClassLoaders.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,6 @@\n-        UNNAMED_MODULE = jla.defineUnnamedModule(null);\n+        ArchivedClassLoaders archivedClassLoaders = ArchivedClassLoaders.get();\n+        if (archivedClassLoaders != null) {\n+            UNNAMED_MODULE = archivedClassLoaders.unnamedModuleForBootLoader();\n+        } else {\n+            UNNAMED_MODULE = jla.defineUnnamedModule(null);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BootLoader.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}