{"files":[{"patch":"@@ -44,0 +44,2 @@\n+import java.nio.charset.StandardCharsets;\n+\n@@ -106,1 +108,1 @@\n-    public char[] digits = new char[MAX_COUNT];\n+    public byte[] digits = new byte[MAX_COUNT];\n@@ -108,1 +110,1 @@\n-    private char[] data;\n+    private byte[] data;\n@@ -157,1 +159,1 @@\n-            char[] data = new char[ArraysSupport.newLength(count, 1, count)];\n+            byte[] data = new byte[ArraysSupport.newLength(count, 1, count)];\n@@ -161,1 +163,1 @@\n-        digits[count++] = digit;\n+        digits[count++] = (byte) digit;\n@@ -191,1 +193,1 @@\n-        long v = Long.parseUnsignedLong(new String(digits, 0, count));\n+        long v = Long.parseUnsignedLong(new String(digits, 0, count, StandardCharsets.ISO_8859_1));\n@@ -216,5 +218,6 @@\n-       if (decimalAt == count) {\n-           return new BigDecimal(digits, 0, count);\n-       } else {\n-           return new BigDecimal(digits, 0, count).scaleByPowerOfTen(decimalAt - count);\n-       }\n+        BigDecimal value = new BigDecimal(new String(digits, 0, count, StandardCharsets.ISO_8859_1));\n+        if (decimalAt == count) {\n+            return value;\n+        } else {\n+            return value.scaleByPowerOfTen(decimalAt - count);\n+        }\n@@ -259,1 +262,1 @@\n-            char dig = digits[i], max = LONG_MIN_REP[i];\n+            byte dig = digits[i], max = LONG_MIN_REP[i];\n@@ -320,1 +323,0 @@\n-        String digitsString = fdConverter.toJavaFormatString();\n@@ -322,1 +324,3 @@\n-        set(isNegative, digitsString,\n+        byte[] chars = getDataChars(20);\n+        int len = fdConverter.getChars(chars);;\n+        set(isNegative, chars, len,\n@@ -334,1 +338,1 @@\n-    private void set(boolean isNegative, String s,\n+    private void set(boolean isNegative, byte[] source, int len,\n@@ -339,3 +343,0 @@\n-        int len = s.length();\n-        char[] source = getDataChars(len);\n-        s.getChars(0, len, source, 0);\n@@ -352,1 +353,1 @@\n-            char c = source[i++];\n+            byte c = source[i++];\n@@ -636,1 +637,1 @@\n-                digits[--left] = (char)('0' + (source % 10));\n+                digits[--left] = (byte)('0' + (source % 10));\n@@ -664,0 +665,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -668,1 +670,4 @@\n-        set(isNegative, s,\n+        int len = s.length();\n+        byte[] chars = getDataChars(len);\n+        s.getBytes(0, len, chars, 0);\n+        set(isNegative, chars, len,\n@@ -681,0 +686,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -686,1 +692,1 @@\n-        s.getChars(0, len, digits, 0);\n+        s.getBytes(0, len, digits, 0);\n@@ -737,1 +743,1 @@\n-            char[] newDigits = new char[digits.length];\n+            byte[] newDigits = new byte[digits.length];\n@@ -752,2 +758,2 @@\n-    private static int parseInt(char[] str, int offset, int strLen) {\n-        char c;\n+    private static int parseInt(byte[] str, int offset, int strLen) {\n+        byte c;\n@@ -775,1 +781,1 @@\n-    private static final char[] LONG_MIN_REP = \"9223372036854775808\".toCharArray();\n+    private static final byte[] LONG_MIN_REP = \"9223372036854775808\".getBytes(StandardCharsets.ISO_8859_1);\n@@ -782,1 +788,1 @@\n-        return \"0.\" + new String(digits, 0, count) + \"x10^\" + decimalAt;\n+        return \"0.\" + new String(digits, 0, count, StandardCharsets.ISO_8859_1) + \"x10^\" + decimalAt;\n@@ -787,1 +793,1 @@\n-            digits = new char[len];\n+            digits = new byte[len];\n@@ -791,1 +797,1 @@\n-    private char[] getDataChars(int length) {\n+    private byte[] getDataChars(int length) {\n@@ -793,1 +799,1 @@\n-            data = new char[length];\n+            data = new byte[length];\n","filename":"src\/java.base\/share\/classes\/java\/text\/DigitList.java","additions":35,"deletions":29,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -63,38 +63,0 @@\n-    \/**\n-     * Converts a double precision floating point value to a <code>String<\/code>.\n-     *\n-     * @param d The double precision value.\n-     * @return The value converted to a <code>String<\/code>.\n-     *\/\n-    public static String toJavaFormatString(double d) {\n-        return getBinaryToASCIIConverter(d).toJavaFormatString();\n-    }\n-\n-    \/**\n-     * Converts a single precision floating point value to a <code>String<\/code>.\n-     *\n-     * @param f The single precision value.\n-     * @return The value converted to a <code>String<\/code>.\n-     *\/\n-    public static String toJavaFormatString(float f) {\n-        return getBinaryToASCIIConverter(f).toJavaFormatString();\n-    }\n-\n-    \/**\n-     * Appends a double precision floating point value to an <code>Appendable<\/code>.\n-     * @param d The double precision value.\n-     * @param buf The <code>Appendable<\/code> with the value appended.\n-     *\/\n-    public static void appendTo(double d, Appendable buf) {\n-        getBinaryToASCIIConverter(d).appendTo(buf);\n-    }\n-\n-    \/**\n-     * Appends a single precision floating point value to an <code>Appendable<\/code>.\n-     * @param f The single precision value.\n-     * @param buf The <code>Appendable<\/code> with the value appended.\n-     *\/\n-    public static void appendTo(float f, Appendable buf) {\n-        getBinaryToASCIIConverter(f).appendTo(buf);\n-    }\n-\n@@ -134,1 +96,1 @@\n-    public static double parseDoubleSignlessDigits(int decExp, char[] digits, int length) {\n+    public static double parseDoubleSignlessDigits(int decExp, byte[] digits, int length) {\n@@ -143,11 +105,1 @@\n-        \/**\n-         * Converts a floating point value into an ASCII <code>String<\/code>.\n-         * @return The value converted to a <code>String<\/code>.\n-         *\/\n-        String toJavaFormatString();\n-\n-        \/**\n-         * Appends a floating point value to an <code>Appendable<\/code>.\n-         * @param buf The <code>Appendable<\/code> to receive the value.\n-         *\/\n-        void appendTo(Appendable buf);\n+        int getChars(byte[] result);\n@@ -212,13 +164,4 @@\n-        public String toJavaFormatString() {\n-            return image;\n-        }\n-\n-        @Override\n-        public void appendTo(Appendable buf) {\n-            if (buf instanceof StringBuilder) {\n-                ((StringBuilder) buf).append(image);\n-            } else if (buf instanceof StringBuffer) {\n-                ((StringBuffer) buf).append(image);\n-            } else {\n-                assert false;\n-            }\n+        @SuppressWarnings(\"deprecation\")\n+        public int getChars(byte[] chars) {\n+            image.getBytes(0, image.length(), chars, 0);\n+            return image.length();\n@@ -264,2 +207,2 @@\n-    private static final BinaryToASCIIConverter B2AC_POSITIVE_ZERO = new BinaryToASCIIBuffer(false, new char[]{'0'});\n-    private static final BinaryToASCIIConverter B2AC_NEGATIVE_ZERO = new BinaryToASCIIBuffer(true,  new char[]{'0'});\n+    private static final BinaryToASCIIConverter B2AC_POSITIVE_ZERO = new BinaryToASCIIBuffer(false, new byte[]{'0'});\n+    private static final BinaryToASCIIConverter B2AC_NEGATIVE_ZERO = new BinaryToASCIIBuffer(true,  new byte[]{'0'});\n@@ -275,2 +218,2 @@\n-        private final char[] digits;\n-        private final char[] buffer = new char[26];\n+        private final byte[] digits;\n+        private final byte[] buffer = new byte[26];\n@@ -296,1 +239,1 @@\n-            this.digits = new char[20];\n+            this.digits = new byte[20];\n@@ -302,1 +245,1 @@\n-        BinaryToASCIIBuffer(boolean isNegative, char[] digits){\n+        BinaryToASCIIBuffer(boolean isNegative, byte[] digits){\n@@ -310,18 +253,0 @@\n-        @Override\n-        public String toJavaFormatString() {\n-            int len = getChars(buffer);\n-            return new String(buffer, 0, len);\n-        }\n-\n-        @Override\n-        public void appendTo(Appendable buf) {\n-            int len = getChars(buffer);\n-            if (buf instanceof StringBuilder) {\n-                ((StringBuilder) buf).append(buffer, 0, len);\n-            } else if (buf instanceof StringBuffer) {\n-                ((StringBuffer) buf).append(buffer, 0, len);\n-            } else {\n-                assert false;\n-            }\n-        }\n-\n@@ -406,1 +331,1 @@\n-                    digits[digitno--] = (char)(c+'0');\n+                    digits[digitno--] = (byte)(c+'0');\n@@ -411,1 +336,1 @@\n-                digits[digitno] = (char)(c+'0');\n+                digits[digitno] = (byte)(c+'0');\n@@ -423,1 +348,1 @@\n-                    digits[digitno--] = (char)(c+'0');\n+                    digits[digitno--] = (byte) (c+'0');\n@@ -428,1 +353,1 @@\n-                digits[digitno] = (char)(c+'0');\n+                digits[digitno] = (byte)(c+'0');\n@@ -629,1 +554,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -657,1 +582,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -683,1 +608,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -711,1 +636,1 @@\n-                        digits[ndigit++] = (char)('0' + q);\n+                        digits[ndigit++] = (byte)('0' + q);\n@@ -744,1 +669,1 @@\n-                    digits[ndigit++] = (char)('0' + q);\n+                    digits[ndigit++] = (byte)('0' + q);\n@@ -761,1 +686,1 @@\n-                    digits[ndigit++] = (char)('0' + q);\n+                    digits[ndigit++] = (byte)('0' + q);\n@@ -815,1 +740,1 @@\n-            digits[i] = (char) (q + 1);\n+            digits[i] = (byte) (q + 1);\n@@ -848,8 +773,0 @@\n-        private static int insignificantDigits(long insignificant) {\n-            int i;\n-            for ( i = 0; insignificant >= 10L; i++ ) {\n-                insignificant \/= 10L;\n-            }\n-            return i;\n-        }\n-\n@@ -858,3 +775,0 @@\n-         * <pre>\n-         * insignificantDigitsForPow2(v) == insignificantDigits(1L<<v)\n-         * <\/pre>\n@@ -916,1 +830,1 @@\n-        private int getChars(char[] result) {\n+        public int getChars(byte[] result) {\n@@ -930,1 +844,1 @@\n-                    Arrays.fill(result,i,i+charLength,'0');\n+                    Arrays.fill(result, i, i + charLength, (byte) '0');\n@@ -938,1 +852,1 @@\n-                        System.arraycopy(digits, firstDigitIndex+charLength, result, i, t);\n+                        System.arraycopy(digits, firstDigitIndex + charLength, result, i, t);\n@@ -948,1 +862,1 @@\n-                    Arrays.fill(result, i, i-decExponent, '0');\n+                    Arrays.fill(result, i, i-decExponent, (byte) '0');\n@@ -972,1 +886,1 @@\n-                    result[i++] = (char) (e + '0');\n+                    result[i++] = (byte) (e + '0');\n@@ -974,2 +888,2 @@\n-                    result[i++] = (char) (e \/ 10 + '0');\n-                    result[i++] = (char) (e % 10 + '0');\n+                    result[i++] = (byte) (e \/ 10 + '0');\n+                    result[i++] = (byte) (e % 10 + '0');\n@@ -977,1 +891,1 @@\n-                    result[i++] = (char) (e \/ 100 + '0');\n+                    result[i++] = (byte) (e \/ 100 + '0');\n@@ -979,2 +893,2 @@\n-                    result[i++] = (char) (e \/ 10 + '0');\n-                    result[i++] = (char) (e % 10 + '0');\n+                    result[i++] = (byte) (e \/ 10 + '0');\n+                    result[i++] = (byte) (e % 10 + '0');\n@@ -1768,1 +1682,1 @@\n-        char[] digits = buf.digits;\n+        byte[] digits = buf.digits;\n@@ -1771,1 +1685,1 @@\n-            digits[i] = (char) ((f - 10 * q) + '0');\n+            digits[i] = (byte) ((f - 10 * q) + '0');\n@@ -1822,41 +1736,1 @@\n-    private static BinaryToASCIIConverter getBinaryToASCIIConverter(float f) {\n-        int fBits = Float.floatToRawIntBits( f );\n-        boolean isNegative = (fBits&FloatConsts.SIGN_BIT_MASK) != 0;\n-        int fractBits = fBits&FloatConsts.SIGNIF_BIT_MASK;\n-        int binExp = (fBits&FloatConsts.EXP_BIT_MASK) >> SINGLE_EXP_SHIFT;\n-        \/\/ Discover obvious special cases of NaN and Infinity.\n-        if ( binExp == (FloatConsts.EXP_BIT_MASK>>SINGLE_EXP_SHIFT) ) {\n-            if ( fractBits == 0L ){\n-                return isNegative ? B2AC_NEGATIVE_INFINITY : B2AC_POSITIVE_INFINITY;\n-            } else {\n-                return B2AC_NOT_A_NUMBER;\n-            }\n-        }\n-        \/\/ Finish unpacking\n-        \/\/ Normalize denormalized numbers.\n-        \/\/ Insert assumed high-order bit for normalized numbers.\n-        \/\/ Subtract exponent bias.\n-        int  nSignificantBits;\n-        if ( binExp == 0 ){\n-            if ( fractBits == 0 ){\n-                \/\/ not a denorm, just a 0!\n-                return isNegative ? B2AC_NEGATIVE_ZERO : B2AC_POSITIVE_ZERO;\n-            }\n-            int leadingZeros = Integer.numberOfLeadingZeros(fractBits);\n-            int shift = leadingZeros-(31-SINGLE_EXP_SHIFT);\n-            fractBits <<= shift;\n-            binExp = 1 - shift;\n-            nSignificantBits =  32 - leadingZeros; \/\/ recall binExp is  - shift count.\n-        } else {\n-            fractBits |= SINGLE_FRACT_HOB;\n-            nSignificantBits = SINGLE_EXP_SHIFT+1;\n-        }\n-        binExp -= FloatConsts.EXP_BIAS;\n-        BinaryToASCIIBuffer buf = getBinaryToASCIIBuffer();\n-        buf.setSign(isNegative);\n-        \/\/ call the routine that actually does all the hard work.\n-        buf.dtoa(binExp, ((long)fractBits)<<(EXP_SHIFT-SINGLE_EXP_SHIFT), nSignificantBits, true);\n-        return buf;\n-    }\n-\n-    static ASCIIToBinaryConverter readDoubleSignlessDigits(int decExp, char[] digits, int length) {\n+    static ASCIIToBinaryConverter readDoubleSignlessDigits(int decExp, byte[] digits, int length) {\n@@ -1871,1 +1745,1 @@\n-            buf[i] = (byte) digits[i];\n+            buf[i] = digits[i];\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":37,"deletions":163,"binary":false,"changes":200,"status":"modified"}]}