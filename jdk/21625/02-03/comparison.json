{"files":[{"patch":"@@ -35,0 +35,2 @@\n+import java.lang.classfile.instruction.BranchInstruction;\n+import java.lang.classfile.instruction.DiscontinuedInstruction;\n@@ -233,1 +235,1 @@\n-     * Default is {@code FIX_SHORT_JUMPS} to automatically rewrite jump\n+     * Default is {@link #FIX_SHORT_JUMPS} to automatically rewrite jump\n@@ -235,0 +237,6 @@\n+     * <p>\n+     * Due to physical restrictions, some types of instructions cannot encode\n+     * certain jump targets with bci offsets less than -32768 or greater than\n+     * 32767, as they use a {@code s2} to encode such an offset.  (The maximum\n+     * length of the {@code code} array is 65535.)  These types of instructions\n+     * are called \"short jumps\".\n@@ -236,0 +244,2 @@\n+     * @see BranchInstruction\n+     * @see DiscontinuedInstruction.JsrInstruction\n@@ -240,1 +250,6 @@\n-        \/** Automatically convert short jumps to long when necessary *\/\n+        \/**\n+         * Automatically convert short jumps to long when necessary.\n+         * <p>\n+         * For an invalid instruction model, a {@link CodeBuilder} may generate\n+         * another or a few other instructions to accomplish the same effect.\n+         *\/\n@@ -243,1 +258,6 @@\n-        \/** Fail if short jump overflows *\/\n+        \/**\n+         * Fail with an {@link IllegalArgumentException} if short jump overflows.\n+         * <p>\n+         * This is useful to ensure the physical accuracy of a generated {@code\n+         * class} file.\n+         *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,4 +37,3 @@\n- * Physically, instructions are discriminated unions identified by thier {@link\n- * #opcode() opcode()}.  The exact type of the instruction can be identified\n- * from {@link Opcode#kind() Opcode::kind}.  {@link #sizeInBytes() sizeInBytes()}\n- * indicates the exact size of such a discriminated union.\n+ * The {@link #opcode() opcode} identifies the operation of an instruction.\n+ * Each {@linkplain Opcode#kind() kind} of opcode has its own modeling interface\n+ * for instructions.\n@@ -57,1 +56,1 @@\n-     * {@return the opcode of this instruction}\n+     * {@return the operation of this instruction}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Instruction.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,5 +41,6 @@\n- * <dfn>{@index bci}<\/dfn>, also known as <dfn>{@index pc}<\/dfn>, the index into\n- * the {@code code} array; the actual cursor position is immediately before the\n- * given index, so a label at the beginning of the instructions has bci {@code 0},\n- * and a label at the end of the instructions has bci {@link CodeAttribute#codeLength\n- * codeLength() + 1}.  The bci can be inspected through {@link CodeAttribute#labelToBci\n+ * <dfn>{@index bci}<\/dfn> (bytecode index), also known as <dfn>{@index pc}<\/dfn>\n+ * (program counter), the index into the {@code code} array; the actual cursor\n+ * position is immediately before the given index, so a label at the beginning\n+ * of the instructions has bci {@code 0}, and a label at the end of the\n+ * instructions has bci {@link CodeAttribute#codeLength codeLength() + 1}.  The\n+ * bci can be inspected through {@link CodeAttribute#labelToBci\n@@ -53,1 +54,1 @@\n- * Many models in {@code java.lang.classfile} refer to labels.  To write a\n+ * Many models in {@link java.lang.classfile} refer to labels.  To write a\n@@ -70,1 +71,1 @@\n- * <li>Send a {@link LabelTarget} to a {@code CodeBuilder}.\n+ * <li>Send a read {@link LabelTarget} to a {@code CodeBuilder}.\n@@ -78,1 +79,0 @@\n- * @see LabelTarget\n@@ -80,4 +80,1 @@\n- * @see CodeBuilder#newBoundLabel CodeBuilder::newBoundLabel\n- * @see CodeBuilder#startLabel CodeBuilder::startLabel\n- * @see CodeBuilder#endLabel CodeBuilder::endLabel\n- * @see CodeBuilder.BlockCodeBuilder#breakLabel BlockCodeBuilder::breakLabel\n+ * @see CodeBuilder#labelBinding CodeBuilder::labelBinding\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Label.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+ * <p>\n+ * An opcode describes the operation of an instruction.\n@@ -52,0 +54,1 @@\n+     * @see Kind#NOP\n@@ -60,0 +63,1 @@\n+     * @see Kind#CONSTANT\n@@ -68,0 +72,1 @@\n+     * @see Kind#CONSTANT\n@@ -76,0 +81,1 @@\n+     * @see Kind#CONSTANT\n@@ -84,0 +90,1 @@\n+     * @see Kind#CONSTANT\n@@ -92,0 +99,1 @@\n+     * @see Kind#CONSTANT\n@@ -100,0 +108,1 @@\n+     * @see Kind#CONSTANT\n@@ -108,0 +117,1 @@\n+     * @see Kind#CONSTANT\n@@ -116,0 +126,1 @@\n+     * @see Kind#CONSTANT\n@@ -120,1 +131,1 @@\n-     * Push {@link TypeKind#LONG long} constant {@code 0}.\n+     * Push {@link TypeKind#LONG long} constant {@code 0L}.\n@@ -124,0 +135,1 @@\n+     * @see Kind#CONSTANT\n@@ -128,1 +140,1 @@\n-     * Push {@link TypeKind#LONG long} constant {@code 1}.\n+     * Push {@link TypeKind#LONG long} constant {@code 1L}.\n@@ -132,0 +144,1 @@\n+     * @see Kind#CONSTANT\n@@ -136,1 +149,1 @@\n-     * Push {@link TypeKind#FLOAT float} constant {@code 0}.\n+     * Push {@link TypeKind#FLOAT float} constant {@code 0.0F}.\n@@ -140,0 +153,1 @@\n+     * @see Kind#CONSTANT\n@@ -144,1 +158,1 @@\n-     * Push {@link TypeKind#FLOAT float} constant {@code 1}.\n+     * Push {@link TypeKind#FLOAT float} constant {@code 1.0F}.\n@@ -148,0 +162,1 @@\n+     * @see Kind#CONSTANT\n@@ -152,1 +167,1 @@\n-     * Push {@link TypeKind#FLOAT float} constant {@code 2}.\n+     * Push {@link TypeKind#FLOAT float} constant {@code 2.0F}.\n@@ -156,0 +171,1 @@\n+     * @see Kind#CONSTANT\n@@ -160,1 +176,1 @@\n-     * Push {@link TypeKind#DOUBLE double} constant {@code 0}.\n+     * Push {@link TypeKind#DOUBLE double} constant {@code 0.0D}.\n@@ -164,0 +180,1 @@\n+     * @see Kind#CONSTANT\n@@ -168,1 +185,1 @@\n-     * Push {@link TypeKind#DOUBLE double} constant {@code 1}.\n+     * Push {@link TypeKind#DOUBLE double} constant {@code 1.0D}.\n@@ -172,0 +189,1 @@\n+     * @see Kind#CONSTANT\n@@ -181,0 +199,1 @@\n+     * @see Kind#CONSTANT\n@@ -190,0 +209,1 @@\n+     * @see Kind#CONSTANT\n@@ -198,0 +218,1 @@\n+     * @see Kind#CONSTANT\n@@ -206,0 +227,1 @@\n+     * @see Kind#CONSTANT\n@@ -215,0 +237,1 @@\n+     * @see Kind#CONSTANT\n@@ -222,0 +245,1 @@\n+     * @see Kind#LOAD\n@@ -229,0 +253,1 @@\n+     * @see Kind#LOAD\n@@ -236,0 +261,1 @@\n+     * @see Kind#LOAD\n@@ -243,0 +269,1 @@\n+     * @see Kind#LOAD\n@@ -250,0 +277,1 @@\n+     * @see Kind#LOAD\n@@ -257,0 +285,1 @@\n+     * @see Kind#LOAD\n@@ -264,0 +293,1 @@\n+     * @see Kind#LOAD\n@@ -271,0 +301,1 @@\n+     * @see Kind#LOAD\n@@ -278,0 +309,1 @@\n+     * @see Kind#LOAD\n@@ -285,0 +317,1 @@\n+     * @see Kind#LOAD\n@@ -292,0 +325,1 @@\n+     * @see Kind#LOAD\n@@ -299,0 +333,1 @@\n+     * @see Kind#LOAD\n@@ -306,0 +341,1 @@\n+     * @see Kind#LOAD\n@@ -313,0 +349,1 @@\n+     * @see Kind#LOAD\n@@ -320,0 +357,1 @@\n+     * @see Kind#LOAD\n@@ -327,0 +365,1 @@\n+     * @see Kind#LOAD\n@@ -334,0 +373,1 @@\n+     * @see Kind#LOAD\n@@ -341,0 +381,1 @@\n+     * @see Kind#LOAD\n@@ -348,0 +389,1 @@\n+     * @see Kind#LOAD\n@@ -355,0 +397,1 @@\n+     * @see Kind#LOAD\n@@ -362,0 +405,1 @@\n+     * @see Kind#LOAD\n@@ -369,0 +413,1 @@\n+     * @see Kind#LOAD\n@@ -376,0 +421,1 @@\n+     * @see Kind#LOAD\n@@ -383,0 +429,1 @@\n+     * @see Kind#LOAD\n@@ -390,0 +437,1 @@\n+     * @see Kind#LOAD\n@@ -397,0 +445,1 @@\n+     * @see Kind#ARRAY_LOAD\n@@ -404,0 +453,1 @@\n+     * @see Kind#ARRAY_LOAD\n@@ -411,0 +461,1 @@\n+     * @see Kind#ARRAY_LOAD\n@@ -418,0 +469,1 @@\n+     * @see Kind#ARRAY_LOAD\n@@ -425,0 +477,1 @@\n+     * @see Kind#ARRAY_LOAD\n@@ -432,0 +485,1 @@\n+     * @see Kind#ARRAY_LOAD\n@@ -439,0 +493,1 @@\n+     * @see Kind#ARRAY_LOAD\n@@ -446,0 +501,1 @@\n+     * @see Kind#ARRAY_LOAD\n@@ -453,0 +509,1 @@\n+     * @see Kind#STORE\n@@ -460,0 +517,1 @@\n+     * @see Kind#STORE\n@@ -467,0 +525,1 @@\n+     * @see Kind#STORE\n@@ -474,0 +533,1 @@\n+     * @see Kind#STORE\n@@ -479,1 +539,1 @@\n-     * Can also store the {@code returnAddress} type.\n+     * Can also store the {@link TypeKind##returnAddress returnAddress} type.\n@@ -482,0 +542,1 @@\n+     * @see Kind#STORE\n@@ -489,0 +550,1 @@\n+     * @see Kind#STORE\n@@ -496,0 +558,1 @@\n+     * @see Kind#STORE\n@@ -503,0 +566,1 @@\n+     * @see Kind#STORE\n@@ -510,0 +574,1 @@\n+     * @see Kind#STORE\n@@ -517,0 +582,1 @@\n+     * @see Kind#STORE\n@@ -524,0 +590,1 @@\n+     * @see Kind#STORE\n@@ -531,0 +598,1 @@\n+     * @see Kind#STORE\n@@ -538,0 +606,1 @@\n+     * @see Kind#STORE\n@@ -545,0 +614,1 @@\n+     * @see Kind#STORE\n@@ -552,0 +622,1 @@\n+     * @see Kind#STORE\n@@ -559,0 +630,1 @@\n+     * @see Kind#STORE\n@@ -566,0 +638,1 @@\n+     * @see Kind#STORE\n@@ -573,0 +646,1 @@\n+     * @see Kind#STORE\n@@ -580,0 +654,1 @@\n+     * @see Kind#STORE\n@@ -587,0 +662,1 @@\n+     * @see Kind#STORE\n@@ -594,0 +670,1 @@\n+     * @see Kind#STORE\n@@ -599,1 +676,1 @@\n-     * Can also store the {@code returnAddress} type.\n+     * Can also store the {@link TypeKind##returnAddress returnAddress} type.\n@@ -602,0 +679,1 @@\n+     * @see Kind#STORE\n@@ -607,1 +685,1 @@\n-     * Can also store the {@code returnAddress} type.\n+     * Can also store the {@link TypeKind##returnAddress returnAddress} type.\n@@ -610,0 +688,1 @@\n+     * @see Kind#STORE\n@@ -615,1 +694,1 @@\n-     * Can also store the {@code returnAddress} type.\n+     * Can also store the {@link TypeKind##returnAddress returnAddress} type.\n@@ -618,0 +697,1 @@\n+     * @see Kind#STORE\n@@ -623,1 +703,1 @@\n-     * Can also store the {@code returnAddress} type.\n+     * Can also store the {@link TypeKind##returnAddress returnAddress} type.\n@@ -626,0 +706,1 @@\n+     * @see Kind#STORE\n@@ -633,0 +714,1 @@\n+     * @see Kind#ARRAY_STORE\n@@ -640,0 +722,1 @@\n+     * @see Kind#ARRAY_STORE\n@@ -647,0 +730,1 @@\n+     * @see Kind#ARRAY_STORE\n@@ -654,0 +738,1 @@\n+     * @see Kind#ARRAY_STORE\n@@ -661,0 +746,1 @@\n+     * @see Kind#ARRAY_STORE\n@@ -668,0 +754,1 @@\n+     * @see Kind#ARRAY_STORE\n@@ -675,0 +762,1 @@\n+     * @see Kind#ARRAY_STORE\n@@ -682,0 +770,1 @@\n+     * @see Kind#ARRAY_STORE\n@@ -689,0 +778,1 @@\n+     * @see Kind#STACK\n@@ -696,0 +786,1 @@\n+     * @see Kind#STACK\n@@ -703,0 +794,1 @@\n+     * @see Kind#STACK\n@@ -710,0 +802,1 @@\n+     * @see Kind#STACK\n@@ -717,0 +810,1 @@\n+     * @see Kind#STACK\n@@ -724,0 +818,1 @@\n+     * @see Kind#STACK\n@@ -732,0 +827,1 @@\n+     * @see Kind#STACK\n@@ -740,0 +836,1 @@\n+     * @see Kind#STACK\n@@ -747,0 +844,1 @@\n+     * @see Kind#STACK\n@@ -754,0 +852,1 @@\n+     * @see Kind#OPERATOR\n@@ -761,0 +860,1 @@\n+     * @see Kind#OPERATOR\n@@ -768,0 +868,1 @@\n+     * @see Kind#OPERATOR\n@@ -775,0 +876,1 @@\n+     * @see Kind#OPERATOR\n@@ -782,0 +884,1 @@\n+     * @see Kind#OPERATOR\n@@ -789,0 +892,1 @@\n+     * @see Kind#OPERATOR\n@@ -796,0 +900,1 @@\n+     * @see Kind#OPERATOR\n@@ -803,0 +908,1 @@\n+     * @see Kind#OPERATOR\n@@ -810,0 +916,1 @@\n+     * @see Kind#OPERATOR\n@@ -817,0 +924,1 @@\n+     * @see Kind#OPERATOR\n@@ -824,0 +932,1 @@\n+     * @see Kind#OPERATOR\n@@ -831,0 +940,1 @@\n+     * @see Kind#OPERATOR\n@@ -838,0 +948,1 @@\n+     * @see Kind#OPERATOR\n@@ -845,0 +956,1 @@\n+     * @see Kind#OPERATOR\n@@ -852,0 +964,1 @@\n+     * @see Kind#OPERATOR\n@@ -859,0 +972,1 @@\n+     * @see Kind#OPERATOR\n@@ -866,0 +980,1 @@\n+     * @see Kind#OPERATOR\n@@ -873,0 +988,1 @@\n+     * @see Kind#OPERATOR\n@@ -880,0 +996,1 @@\n+     * @see Kind#OPERATOR\n@@ -887,0 +1004,1 @@\n+     * @see Kind#OPERATOR\n@@ -894,0 +1012,1 @@\n+     * @see Kind#OPERATOR\n@@ -901,0 +1020,1 @@\n+     * @see Kind#OPERATOR\n@@ -908,0 +1028,1 @@\n+     * @see Kind#OPERATOR\n@@ -915,0 +1036,1 @@\n+     * @see Kind#OPERATOR\n@@ -922,0 +1044,1 @@\n+     * @see Kind#OPERATOR\n@@ -929,0 +1052,1 @@\n+     * @see Kind#OPERATOR\n@@ -936,0 +1060,1 @@\n+     * @see Kind#OPERATOR\n@@ -943,0 +1068,1 @@\n+     * @see Kind#OPERATOR\n@@ -950,0 +1076,1 @@\n+     * @see Kind#OPERATOR\n@@ -957,0 +1084,1 @@\n+     * @see Kind#OPERATOR\n@@ -967,0 +1095,1 @@\n+     * @see Kind#OPERATOR\n@@ -974,0 +1103,1 @@\n+     * @see Kind#OPERATOR\n@@ -984,0 +1114,1 @@\n+     * @see Kind#OPERATOR\n@@ -991,0 +1122,1 @@\n+     * @see Kind#OPERATOR\n@@ -1001,0 +1133,1 @@\n+     * @see Kind#OPERATOR\n@@ -1008,0 +1141,1 @@\n+     * @see Kind#OPERATOR\n@@ -1015,0 +1149,1 @@\n+     * @see Kind#INCREMENT\n@@ -1023,0 +1158,1 @@\n+     * @see Kind#CONVERT\n@@ -1031,0 +1167,1 @@\n+     * @see Kind#CONVERT\n@@ -1039,0 +1176,1 @@\n+     * @see Kind#CONVERT\n@@ -1047,0 +1185,1 @@\n+     * @see Kind#CONVERT\n@@ -1054,0 +1193,1 @@\n+     * @see Kind#CONVERT\n@@ -1061,0 +1201,1 @@\n+     * @see Kind#CONVERT\n@@ -1069,0 +1210,1 @@\n+     * @see Kind#CONVERT\n@@ -1077,0 +1219,1 @@\n+     * @see Kind#CONVERT\n@@ -1085,0 +1228,1 @@\n+     * @see Kind#CONVERT\n@@ -1093,0 +1237,1 @@\n+     * @see Kind#CONVERT\n@@ -1100,0 +1245,1 @@\n+     * @see Kind#CONVERT\n@@ -1108,0 +1254,1 @@\n+     * @see Kind#CONVERT\n@@ -1118,0 +1265,1 @@\n+     * @see Kind#CONVERT\n@@ -1128,0 +1276,1 @@\n+     * @see Kind#CONVERT\n@@ -1138,0 +1287,1 @@\n+     * @see Kind#CONVERT\n@@ -1146,0 +1296,1 @@\n+     * @see Kind#OPERATOR\n@@ -1155,0 +1306,1 @@\n+     * @see Kind#OPERATOR\n@@ -1164,0 +1316,1 @@\n+     * @see Kind#OPERATOR\n@@ -1173,0 +1326,1 @@\n+     * @see Kind#OPERATOR\n@@ -1182,0 +1336,1 @@\n+     * @see Kind#OPERATOR\n@@ -1189,0 +1344,1 @@\n+     * @see Kind#BRANCH\n@@ -1196,0 +1352,1 @@\n+     * @see Kind#BRANCH\n@@ -1203,0 +1360,1 @@\n+     * @see Kind#BRANCH\n@@ -1210,0 +1368,1 @@\n+     * @see Kind#BRANCH\n@@ -1217,0 +1376,1 @@\n+     * @see Kind#BRANCH\n@@ -1224,0 +1384,1 @@\n+     * @see Kind#BRANCH\n@@ -1231,0 +1392,1 @@\n+     * @see Kind#BRANCH\n@@ -1238,0 +1400,1 @@\n+     * @see Kind#BRANCH\n@@ -1245,0 +1408,1 @@\n+     * @see Kind#BRANCH\n@@ -1252,0 +1416,1 @@\n+     * @see Kind#BRANCH\n@@ -1259,0 +1424,1 @@\n+     * @see Kind#BRANCH\n@@ -1266,0 +1432,1 @@\n+     * @see Kind#BRANCH\n@@ -1274,0 +1441,1 @@\n+     * @see Kind#BRANCH\n@@ -1282,0 +1450,1 @@\n+     * @see Kind#BRANCH\n@@ -1289,0 +1458,1 @@\n+     * @see Kind#BRANCH\n@@ -1296,1 +1466,0 @@\n-     * @see DiscontinuedInstruction.JsrInstruction\n@@ -1299,0 +1468,1 @@\n+     * @see Kind#DISCONTINUED_JSR\n@@ -1306,1 +1476,0 @@\n-     * @see DiscontinuedInstruction.RetInstruction\n@@ -1309,0 +1478,1 @@\n+     * @see Kind#DISCONTINUED_RET\n@@ -1316,0 +1486,1 @@\n+     * @see Kind#TABLE_SWITCH\n@@ -1323,0 +1494,1 @@\n+     * @see Kind#LOOKUP_SWITCH\n@@ -1330,0 +1502,1 @@\n+     * @see Kind#RETURN\n@@ -1337,0 +1510,1 @@\n+     * @see Kind#RETURN\n@@ -1344,0 +1518,1 @@\n+     * @see Kind#RETURN\n@@ -1351,0 +1526,1 @@\n+     * @see Kind#RETURN\n@@ -1358,0 +1534,1 @@\n+     * @see Kind#RETURN\n@@ -1365,0 +1542,1 @@\n+     * @see Kind#RETURN\n@@ -1372,0 +1550,1 @@\n+     * @see Kind#FIELD_ACCESS\n@@ -1379,0 +1558,1 @@\n+     * @see Kind#FIELD_ACCESS\n@@ -1386,0 +1566,1 @@\n+     * @see Kind#FIELD_ACCESS\n@@ -1393,0 +1574,1 @@\n+     * @see Kind#FIELD_ACCESS\n@@ -1400,0 +1582,1 @@\n+     * @see Kind#INVOKE\n@@ -1408,0 +1591,1 @@\n+     * @see Kind#INVOKE\n@@ -1415,0 +1599,1 @@\n+     * @see Kind#INVOKE\n@@ -1422,0 +1607,1 @@\n+     * @see Kind#INVOKE\n@@ -1429,0 +1615,1 @@\n+     * @see Kind#INVOKE_DYNAMIC\n@@ -1436,0 +1623,1 @@\n+     * @see Kind#NEW_OBJECT\n@@ -1443,0 +1631,1 @@\n+     * @see Kind#NEW_PRIMITIVE_ARRAY\n@@ -1446,1 +1635,2 @@\n-    \/** Create new array of {@link TypeKind#REFERENCE reference}.\n+    \/**\n+     * Create new array of {@link TypeKind#REFERENCE reference}.\n@@ -1449,0 +1639,1 @@\n+     * @see Kind#NEW_REF_ARRAY\n@@ -1456,0 +1647,1 @@\n+     * @see Kind#OPERATOR\n@@ -1463,0 +1655,1 @@\n+     * @see Kind#THROW_EXCEPTION\n@@ -1471,0 +1664,1 @@\n+     * @see Kind#TYPE_CHECK\n@@ -1479,0 +1673,1 @@\n+     * @see Kind#TYPE_CHECK\n@@ -1486,0 +1681,1 @@\n+     * @see Kind#MONITOR\n@@ -1493,0 +1689,1 @@\n+     * @see Kind#MONITOR\n@@ -1500,0 +1697,1 @@\n+     * @see Kind#NEW_MULTI_ARRAY\n@@ -1507,0 +1705,1 @@\n+     * @see Kind#BRANCH\n@@ -1514,0 +1713,1 @@\n+     * @see Kind#BRANCH\n@@ -1521,0 +1721,1 @@\n+     * @see Kind#BRANCH\n@@ -1528,1 +1729,0 @@\n-     * @see DiscontinuedInstruction.JsrInstruction\n@@ -1531,0 +1731,1 @@\n+     * @see Kind#DISCONTINUED_JSR\n@@ -1540,0 +1741,1 @@\n+     * @see Kind#LOAD\n@@ -1549,0 +1751,1 @@\n+     * @see Kind#LOAD\n@@ -1558,0 +1761,1 @@\n+     * @see Kind#LOAD\n@@ -1567,0 +1771,1 @@\n+     * @see Kind#LOAD\n@@ -1576,0 +1781,1 @@\n+     * @see Kind#LOAD\n@@ -1585,0 +1791,1 @@\n+     * @see Kind#STORE\n@@ -1594,0 +1801,1 @@\n+     * @see Kind#STORE\n@@ -1603,0 +1811,1 @@\n+     * @see Kind#STORE\n@@ -1612,0 +1821,1 @@\n+     * @see Kind#STORE\n@@ -1618,1 +1828,1 @@\n-     * Can also store the {@code returnAddress} type.\n+     * Can also store the {@link TypeKind##returnAddress returnAddress} type.\n@@ -1622,0 +1832,1 @@\n+     * @see Kind#STORE\n@@ -1626,1 +1837,1 @@\n-     * (Discontinued) Return from subroutine (wide index) last used in major\n+     * (Discontinued) Return from subroutine (wide index); last used in major\n@@ -1630,1 +1841,0 @@\n-     * @see DiscontinuedInstruction.RetInstruction\n@@ -1634,0 +1844,1 @@\n+     * @see Kind#DISCONTINUED_RET\n@@ -1643,0 +1854,1 @@\n+     * @see Kind#INCREMENT\n@@ -1647,1 +1859,2 @@\n-     * Kinds of opcodes.\n+     * Kinds of opcodes.  Each kind of opcode has its own modeling interface\n+     * for its instructions.\n@@ -2096,1 +2309,2 @@\n-     * {@return instruction kind}\n+     * {@return operation kind}  Each kind of operation has its own modeling\n+     * interface to model instructions belonging to that kind.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Opcode.java","additions":235,"deletions":21,"binary":false,"changes":256,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+import java.lang.classfile.instruction.LoadInstruction;\n+import java.lang.classfile.instruction.NewPrimitiveArrayInstruction;\n+import java.lang.classfile.instruction.StoreInstruction;\n@@ -36,7 +39,11 @@\n- * Describes the data types Java Virtual Machine operates on.\n- * This omits {@code returnAddress} (JVMS {@jvms 2.3.3}),\n- * which is only used by discontinued {@link\n- * DiscontinuedInstruction.JsrInstruction jsr} and {@link\n- * DiscontinuedInstruction.RetInstruction ret} instructions,\n- * and includes {@link #VOID void} (JVMS {@jvms 4.3.3}), which\n- * appears as a method return type.\n+ * Describes the data types Java Virtual Machine operates on.  This omits {@code\n+ * returnAddress} (JVMS {@jvms 2.3.3}) and includes {@link #VOID void} (JVMS\n+ * {@jvms 4.3.3}), which appears as a method return type.\n+ * <p>\n+ * The <code>{@index returnAddress}<\/code> type is only used by discontinued\n+ * {@linkplain DiscontinuedInstruction.JsrInstruction jump subroutine} and\n+ * {@linkplain DiscontinuedInstruction.RetInstruction return from subroutine}\n+ * instructions.  Jump subroutine instructions push {@code returnAddress} to the\n+ * operand stack; {@link StoreInstruction astore} instructions store {@code\n+ * returnAddress} from the operand stack to local variables; return from\n+ * subroutine instructions load {@code returnAddress} from local variables.\n@@ -167,0 +174,1 @@\n+     *\n@@ -168,0 +176,2 @@\n+     * @see NewPrimitiveArrayInstruction\n+     * @see #fromNewarrayCode(int) fromNewarrayCode(int)\n@@ -178,0 +188,1 @@\n+     *\n@@ -188,0 +199,3 @@\n+     *\n+     * @see LoadInstruction\n+     * @see StoreInstruction\n@@ -196,0 +210,1 @@\n+     *\n@@ -199,0 +214,2 @@\n+     * @see NewPrimitiveArrayInstruction\n+     * @see #newarrayCode() newarrayCode()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeKind.java","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * Conceptually, an array load instruction is a record:\n+ * An array load instruction can be viewed as a record:\n@@ -46,1 +46,1 @@\n- * ArrayLoadInstruction(TypeKind) \/\/ @link substring=\"TypeKind\" target=\"#typeKind()\"\n+ * ArrayLoadInstruction(TypeKind typeKind) \/\/ @link substring=\"typeKind\" target=\"#typeKind\"\n@@ -48,11 +48,2 @@\n- * where the {@code TypeKind} is not {@link TypeKind#BOOLEAN boolean} or\n- * {@link TypeKind#VOID void}.  Boolean arrays use the {@link TypeKind#BYTE\n- * byte} kind instruction.\n- * <p>\n- * Physically, an array load instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link substring=\"ArrayLoadInstruction\" target=\"#of(Opcode)\" :\n- * ArrayLoadInstruction(Opcode) \/\/ @link substring=\"Opcode\" target=\"#opcode()\"\n- * }\n- * where the {@code Opcode} is of the array load kind.  The component type of\n- * the array is intrinsic to the opcode.\n+ * where {@code typeKind} is not {@link TypeKind#VOID void}, and {@link\n+ * TypeKind#BOOLEAN boolean} is converted to {@link TypeKind#BYTE byte}.\n@@ -60,0 +51,1 @@\n+ * @see Opcode.Kind#ARRAY_LOAD\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayLoadInstruction.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * Conceptually, an array store instruction is a record:\n+ * An array store instruction can be viewed as a record:\n@@ -46,1 +46,1 @@\n- * ArrayStoreInstruction(TypeKind) \/\/ @link substring=\"TypeKind\" target=\"#typeKind()\"\n+ * ArrayStoreInstruction(TypeKind typeKind) \/\/ @link substring=\"typeKind\" target=\"#typeKind\"\n@@ -48,11 +48,2 @@\n- * where the {@code TypeKind} is not {@link TypeKind#BOOLEAN boolean} or\n- * {@link TypeKind#VOID void}.  Boolean arrays use the {@link TypeKind#BYTE\n- * byte} kind instruction.\n- * <p>\n- * Physically, an array store instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link substring=\"ArrayStoreInstruction\" target=\"#of(Opcode)\" :\n- * ArrayStoreInstruction(Opcode) \/\/ @link substring=\"Opcode\" target=\"#opcode()\"\n- * }\n- * where the {@code Opcode} is of the array store kind.  The component type of\n- * the array is intrinsic to the opcode.\n+ * where {@code typeKind} is not {@link TypeKind#VOID void}, and {@link\n+ * TypeKind#BOOLEAN boolean} is converted to {@link TypeKind#BYTE byte}.\n@@ -60,0 +51,1 @@\n+ * @see Opcode.Kind#ARRAY_STORE\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayStoreInstruction.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n- * Conceptually, a branch instruction is a record:\n+ * A branch instruction can be viewed as a record:\n@@ -40,4 +40,5 @@\n- * \/\/ @link region substring=\"BranchInstruction\" target=\"#of\"\n- * \/\/ @link substring=\"Opcode\" target=\"#opcode()\" :\n- * BranchInstruction(Opcode, Label) \/\/ @link substring=\"Label\" target=\"#target()\"\n- * \/\/ @end\n+ * \/\/ @link substring=\"BranchInstruction\" target=\"#of\":\n+ * BranchInstruction(\n+ *     Opcode opcode, \/\/ @link substring=\"Opcode\" target=\"#opcode()\"\n+ *     Label target \/\/ @link substring=\"Label\" target=\"#target()\"\n+ * )\n@@ -45,1 +46,0 @@\n- * where the {@code Opcode} is of the branch kind.\n@@ -47,12 +47,4 @@\n- * Physically, a branch instruction has the same structure; however, some types\n- * of instructions use a {@code s2} to encode the target, which is insufficient\n- * to encode targets with bci offsets less than {@code -32768} or greater than\n- * {@code 32767}.  Such instructions have a {@linkplain Opcode#sizeIfFixed()\n- * size} of {@code 3} bytes.\n- * <p>\n- * In such cases, if the {@link ClassFile.ShortJumpsOption#FIX_SHORT_JUMPS\n- * FIX_SHORT_JUMPS} option is set, a {@link CodeBuilder} will convert this\n- * instruction to other instructions to achieve the same effect.  Otherwise,\n- * {@link ClassFile.ShortJumpsOption#FAIL_ON_SHORT_JUMPS FAIL_ON_SHORT_JUMPS}\n- * option can ensure the physical accuracy of the generated {@code class} file\n- * and fail if an exact representation is not possible.\n+ * Due to physical restrictions, some types of instructions cannot encode labels\n+ * too far away in the list of code elements.  In such cases, the {@link\n+ * ClassFile.ShortJumpsOption} controls how an invalid branch instruction model\n+ * is written by a {@link CodeBuilder}.\n@@ -60,0 +52,1 @@\n+ * @see Opcode.Kind#BRANCH\n@@ -61,0 +54,1 @@\n+ * @see ClassFile.ShortJumpsOption\n@@ -67,1 +61,1 @@\n-     * {@return the target of the branch}\n+     * {@return the branch target of this instruction}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/BranchInstruction.java","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -40,4 +40,4 @@\n- * A pseudo-instruction which models a single entry in the\n- * {@link CharacterRangeTableAttribute}.  Delivered as a {@link CodeElement}\n- * during traversal of the elements of a {@link CodeModel}, according to\n- * the setting of the {@link ClassFile.DebugElementsOption} option.\n+ * A pseudo-instruction which models a single entry in the {@link\n+ * CharacterRangeTableAttribute CharacterRangeTable} attribute.  Delivered as a\n+ * {@link CodeElement} during traversal of the elements of a {@link CodeModel},\n+ * according to the setting of the {@link ClassFile.DebugElementsOption} option.\n@@ -45,1 +45,1 @@\n- * Conceptually, a character range entry is a record:\n+ * A character range entry can be viewed a record:\n@@ -47,12 +47,8 @@\n- * \/\/ @link region=0 substring=\"CharacterRange\" target=\"#of\"\n- * \/\/ @link region=1 substring=\"Label startScope\" target=\"#startScope\"\n- * \/\/ @link region=2 substring=\"Label endScope\" target=\"#endScope\"\n- * \/\/ @link region=3 substring=\"int characterRangeStart\" target=\"#characterRangeStart\"\n- * \/\/ @link region=4 substring=\"int characterRangeEnd\" target=\"#characterRangeEnd\"\n- * \/\/ @link substring=\"int flags\" target=\"#flags()\" :\n- * CharacterRange(Label startScope, Label endScope, int characterRangeStart, int characterRangeEnd, int flags)\n- * \/\/ @end region=0\n- * \/\/ @end region=1\n- * \/\/ @end region=2\n- * \/\/ @end region=3\n- * \/\/ @end region=4\n+ * \/\/ @link substring=\"CharacterRange\" target=\"#of\":\n+ * CharacterRange(\n+ *     Label startScope, \/\/ @link substring=\"startScope\" target=\"#startScope\"\n+ *     Label endScope, \/\/ @link substring=\"endScope\" target=\"#endScope\"\n+ *     int characterRangeStart, \/\/ @link substring=\"characterRangeStart\" target=\"#characterRangeStart\"\n+ *     int characterRangeEnd, \/\/ @link substring=\"characterRangeEnd\" target=\"#characterRangeEnd\"\n+ *     int flags \/\/ @link substring=\"flags\" target=\"#flags\"\n+ * )\n@@ -61,2 +57,4 @@\n- * Physically, a character range has the same structure; it is modeled by a\n- * {@link CharacterRangeInfo}.\n+ * Another model, {@link CharacterRangeInfo}, also models a character range\n+ * entry;  it has no dependency on a {@code CodeModel} and represents of bci\n+ * values as {@code int}s instead of {@code Label}s, and is used as components\n+ * of a {@link CharacterRangeTableAttribute}.\n@@ -64,1 +62,0 @@\n- * @see CharacterRangeTableAttribute\n@@ -67,0 +64,1 @@\n+ * @see ClassFile.DebugElementsOption\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/CharacterRange.java","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * Conceptually, a constant-load instruction is a record:\n+ * A constant-load instruction can be viewed as a record:\n@@ -52,1 +52,1 @@\n- * ConstantInstruction(ConstantDesc) \/\/ @link substring=\"ConstantDesc\" target=\"#constantValue()\"\n+ * ConstantInstruction(ConstantDesc constantValue) \/\/ @link substring=\"constantValue\" target=\"#constantValue()\"\n@@ -54,5 +54,0 @@\n- * The {@linkplain #typeKind() computational type} is derived from the {@code\n- * ConstantDesc}.\n- * <p>\n- * Physically, a constant-load instruction is polymorphic; nested interfaces in\n- * this interface model different constant instructions as records.\n@@ -60,0 +55,1 @@\n+ * @see Opcode.Kind#CONSTANT\n@@ -73,0 +69,1 @@\n+     * This is derived from the {@link #constantValue() constantValue}.\n@@ -82,1 +79,1 @@\n-     * Conceptually, an intrinsic constant instruction is a record:\n+     * An intrinsic constant instruction can be viewed as a record:\n@@ -85,1 +82,1 @@\n-     * IntrinsicConstantInstruction(Opcode) \/\/ @link substring=\"Opcode\" target=\"#opcode()\"\n+     * IntrinsicConstantInstruction(Opcode opcode) \/\/ @link substring=\"opcode\" target=\"#opcode()\"\n@@ -87,6 +84,6 @@\n-     * where the {@code Opcode} is of the constant kind and has a fixed size\n-     * of 1.  The constant value and the computational type are intrinsic to\n-     * the {@code Opcode}.\n-     * <p>\n-     * Physically, an intrinsic constant instruction is the same as its\n-     * conceptual representation.\n+     * where:\n+     * <dl>\n+     * <dt>{@link #opcode() opcode}<\/dt>\n+     * <dd>Must be of the constant kind and have a {@linkplain\n+     * Opcode#sizeIfFixed() fixed size} of 1.<\/dd>\n+     * <\/dl>\n@@ -94,0 +91,2 @@\n+     * @see Opcode.Kind#CONSTANT\n+     * @see ConstantInstruction#ofIntrinsic ConstantInstruction::ofIntrinsic\n@@ -110,1 +109,1 @@\n-     * Physically, an argument constant instruction is a record:\n+     * An argument constant instruction can be viewed a record:\n@@ -112,4 +111,5 @@\n-     * \/\/ @link region substring=\"ArgumentConstantInstruction\" target=\"#ofArgument\"\n-     * \/\/ @link substring=\"Opcode\" target=\"#opcode()\" :\n-     * ArgumentConstantInstruction(Opcode, int) \/\/ @link substring=\"int\" target=\"#constantValue()\"\n-     * \/\/ @end\n+     * \/\/ @link substring=\"ArgumentConstantInstruction\" target=\"#ofArgument\" :\n+     * ArgumentConstantInstruction(\n+     *     Opcode opcode, \/\/ @link substring=\"opcode\" target=\"#opcode()\"\n+     *     int constantValue \/\/ @link substring=\"constantValue\" target=\"#constantValue()\"\n+     * )\n@@ -117,4 +117,7 @@\n-     * where the {@code Opcode} is either {@code bipush} or {@code sipush}.\n-     * The {@code int} must be in the range of {@code byte} for {@code bipush},\n-     * and in the range of {@code short} for {@code sipush}.  The {@linkplain\n-     * #typeKind() computational type} is trivially {@code int}.\n+     * where:\n+     * <ul>\n+     * <li>{@code opcode} must be one of {@code bipush} or {@code sipush}.\n+     * <li>{@code constantValue} must be in the range of {@code byte}, {@code\n+     * [-128, 127]}, for {@code bipush},  and in the range of {@code short},\n+     * {@code [-32768, 32767]}, for {@code sipush}.\n+     * <\/ul>\n@@ -122,0 +125,2 @@\n+     * @see Opcode.Kind#CONSTANT\n+     * @see ConstantInstruction#ofArgument ConstantInstruction::ofArgument\n@@ -141,4 +146,3 @@\n-     * Models a \"load constant\" instruction, which encodes the\n-     * constant value in the constant pool.  Includes {@link\n-     * Opcode#LDC ldc} and {@link Opcode#LDC_W ldc_w}, and\n-     * {@link Opcode#LDC2_W ldc2_w} instructions.\n+     * Models a \"load constant\" instruction, which encodes the  constant value\n+     * in the constant pool.  Includes {@link Opcode#LDC ldc} and {@link\n+     * Opcode#LDC_W ldc_w}, and {@link Opcode#LDC2_W ldc2_w} instructions.\n@@ -146,2 +150,1 @@\n-     * Conceptually, besides the more generic record for all constant-load\n-     * instructions, a load constant instruction are these records:\n+     * A load constant instruction can be viewed as one of these records:\n@@ -150,1 +153,1 @@\n-     * LoadConstantInstruction(ConstantDesc) \/\/ @link substring=\"ConstantDesc\" target=\"#constantValue()\"\n+     * LoadConstantInstruction(ConstantDesc constantValue) \/\/ @link substring=\"constantValue\" target=\"#constantValue()\"\n@@ -152,1 +155,1 @@\n-     * LoadConstantInstruction(LoadableConstantEntry) \/\/ @link substring=\"LoadableConstantEntry\" target=\"#constantEntry()\"\n+     * LoadConstantInstruction(LoadableConstantEntry constantEntry) \/\/ @link substring=\"constantEntry\" target=\"#constantEntry()\"\n@@ -155,18 +158,3 @@\n-     * Note that though both the generic constant-load record and the \"load\n-     * constant\" record holds a {@code ConstantDesc}, the physical representation\n-     * for the generic instruction may be more optimized, avoiding extra constant\n-     * pool entries and using smaller instructions.\n-     * <p>\n-     * Physically, a load constant instruction is a record:\n-     * {@snippet lang=text :\n-     * \/\/ @link region substring=\"LoadConstantInstruction\" target=\"#ofLoad\"\n-     * \/\/ @link substring=\"Opcode\" target=\"#opcode()\" :\n-     * LoadConstantInstruction(Opcode, LoadableConstantEntry) \/\/ @link substring=\"LoadableConstantEntry\" target=\"#constantEntry()\"\n-     * \/\/ @end\n-     * }\n-     * where the {@code Opcode} must be {@code ldc} or {@code ldc_w} if the\n-     * entry is not of {@code long} or {@code double} types, or it must be\n-     * {@code ldc2_w} if the entry is of {@code long} or {@code double} type.\n-     * Additionally, {@code ldc} cannot be used if the {@linkplain\n-     * LoadableConstantEntry#index() index} of the {@code LoadableConstantEntry}\n-     * is not in the range of {@code [0, 255]}.\n+     * Though the generic constant-load model and the \"load constant\" model both\n+     * hold a {@code constantValue}, the generic instruction may be more optimized,\n+     * avoiding extra constant pool entries and using smaller-sized instructions.\n@@ -174,1 +162,3 @@\n-     * @see CodeBuilder#ldc(LoadableConstantEntry) CodeBuilder::ldc\n+     * @see Opcode.Kind#CONSTANT\n+     * @see ConstantInstruction#ofLoad ConstantInstruction::ofLoad\n+     * @see CodeBuilder#ldc CodeBuilder::ldc\n@@ -209,0 +199,4 @@\n+     * <p>\n+     * {@code value} must be in the range of {@code byte}, {@code [-128, 127]},\n+     * for {@link Opcode#BIPUSH},  and in the range of {@code short}, {@code\n+     * [-32768, 32767]}, for {@link Opcode#SIPUSH}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ConstantInstruction.java","additions":45,"deletions":51,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -46,4 +46,5 @@\n- * \/\/ @link region substring=\"ConvertInstruction\" target=\"#of(TypeKind, TypeKind)\" :\n- * \/\/ @link substring=\"TypeKind fromType\" target=\"#fromType\" :\n- * ConvertInstruction(TypeKind fromType, TypeKind toType) \/\/ @link substring=\"TypeKind toType\" target=\"#toType\"\n- * \/\/ @end\n+ * \/\/ @link substring=\"ConvertInstruction\" target=\"#of(TypeKind, TypeKind)\" :\n+ * ConvertInstruction(\n+ *     TypeKind fromType, \/\/ @link substring=\"fromType\" target=\"#fromType\"\n+ *     TypeKind toType \/\/ @link substring=\"toType\" target=\"#toType\"\n+ * )\n@@ -57,8 +58,0 @@\n- * <p>\n- * Physically, a primitive conversion instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link substring=\"ConvertInstruction\" target=\"#of(Opcode)\" :\n- * ConvertInstruction(Opcode opcode) \/\/ @link substring=\"Opcode\" target=\"#opcode\"\n- * }\n- * where the {@code Opcode} is of the convert kind.  The {@code fromType} and\n- * {@code toType} are intrinsic to the {@code Opcode}.\n@@ -66,0 +59,1 @@\n+ * @see Opcode.Kind#CONVERT\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ConvertInstruction.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-     * Conceptually, a jump subroutine instruction is a record:\n+     * A jump subroutine instruction can be viewed as a record:\n@@ -61,1 +61,1 @@\n-     * JsrInstruction(Label) \/\/ @link substring=\"Label\" target=\"#target()\"\n+     * JsrInstruction(Label target) \/\/ @link substring=\"target\" target=\"#target()\"\n@@ -64,19 +64,4 @@\n-     * Physically, a jump subroutine instruction is a record:\n-     * {@snippet lang=text :\n-     * \/\/ @link region substring=\"JsrInstruction\" target=\"#of(Opcode, Label)\"\n-     * \/\/ @link substring=\"Opcode\" target=\"#opcode()\" :\n-     * JsrInstruction(Opcode, Label) \/\/ @link substring=\"Label\" target=\"#target()\"\n-     * \/\/ @end\n-     * }\n-     * where the {@code Opcode} must be {@link Opcode#JSR jsr} or {@link\n-     * Opcode#JSR_W jsr_w}.  However, {@code jsr} only uses a {@code s2} to\n-     * encode its target, which is insufficient to encode targets with bci\n-     * offsets less than {@code -32768} or greater than {@code 32767}.\n-     * <p>\n-     * In such cases, if the {@link ClassFile.ShortJumpsOption#FIX_SHORT_JUMPS\n-     * FIX_SHORT_JUMPS} option is set, a {@link CodeBuilder} will convert a\n-     * {@code jsr} instruction to a {@code jsr_w} instruction to achieve the\n-     * same effect.  Otherwise, {@link ClassFile.ShortJumpsOption#FAIL_ON_SHORT_JUMPS\n-     * FAIL_ON_SHORT_JUMPS} option can ensure the physical accuracy of the\n-     * generated {@code class} file and fail if an exact representation is not\n-     * possible.\n+     * Due to physical restrictions, {@link Opcode#JSR jsr} instructions cannot\n+     * encode labels too far away in the list of code elements.  In such cases,\n+     * the {@link ClassFile.ShortJumpsOption} controls how an invalid {@code jsr}\n+     * instruction model is written by a {@link CodeBuilder}.\n@@ -84,2 +69,4 @@\n-     * {@link StoreInstruction astore} series of instructions can operate on the\n-     * {@code returnAddress} type from jump subroutine instructions.\n+     * Jump subroutine instructions push a {@link TypeKind##returnAddress\n+     * returnAddress} value to the operand stack, and {@link StoreInstruction\n+     * astore} series of instructions can then store this value to a local\n+     * variable slot.\n@@ -87,0 +74,1 @@\n+     * @see Opcode.Kind#DISCONTINUED_JSR\n@@ -102,2 +90,2 @@\n-         * The explicit {@code op} argument allows creating {@code jsr_w}\n-         * instructions to avoid {@code target} overflow.\n+         * The explicit {@code op} argument allows creating {@link Opcode#JSR_W\n+         * jsr_w} instructions to avoid short jumps.\n@@ -134,1 +122,1 @@\n-     * Conceptually, a return from subroutine instruction is a record:\n+     * A return from subroutine instruction can be viewed as a record:\n@@ -137,1 +125,1 @@\n-     * RetInstruction(int slot) \/\/ @link substring=\"int slot\" target=\"#slot()\"\n+     * RetInstruction(int slot) \/\/ @link substring=\"slot\" target=\"#slot()\"\n@@ -139,3 +127,1 @@\n-     * where the {@code slot}, a local variable slot, has a {@code returnAddress}\n-     * computational type previously stored by an {@link StoreInstruction astore}\n-     * instruction.\n+     * where {@code slot} must be within {@code [0, 65535]}.\n@@ -143,10 +129,3 @@\n-     * Physically, a return from subroutine instruction is a record:\n-     * {@snippet lang=text :\n-     * \/\/ @link region substring=\"RetInstruction\" target=\"#of(Opcode, int)\"\n-     * \/\/ @link substring=\"Opcode\" target=\"#opcode()\" :\n-     * RetInstruction(Opcode, int slot) \/\/ @link substring=\"int slot\" target=\"#slot()\"\n-     * \/\/ @end\n-     * }\n-     * where the {@code Opcode} must be {@link Opcode#RET ret} or {@link\n-     * Opcode#RET_W wide ret}.  In addition, if {@code slot} is greater than 255,\n-     * {@code Opcode} must be {@code wide ret}.\n+     * {@link StoreInstruction astore} series of instructions store a {@link\n+     * TypeKind##returnAddress returnAddress} value to a local variable slot,\n+     * making the slot usable by a return from subroutine instruction.\n@@ -154,0 +133,2 @@\n+     * @jvms 6.5.ret <em>ret<\/em>\n+     * @see Opcode.Kind#DISCONTINUED_RET\n@@ -162,0 +143,1 @@\n+         * The value is within {@code [0, 65535]}.\n@@ -167,0 +149,4 @@\n+         * <p>\n+         * {@code slot} must be in the closed range of {@code [0, 255]} for\n+         * {@link Opcode#RET ret}, or within {@code [0, 65535]} for {@link\n+         * Opcode#RET_W wide ret}.\n@@ -186,0 +172,2 @@\n+         * <p>\n+         * {@code slot} must be within {@code [0, 65535]}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":28,"deletions":40,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -39,4 +40,4 @@\n- * of a {@code Code} attribute.  Catch (JVMS {@jvms 3.12}) and finally (JVMS\n- * {@jvms 3.14}) blocks in Java source code compile to exception table entries.\n- * Delivered as a {@link CodeElement} when traversing the contents of a {@link\n- * CodeModel}.\n+ * of a {@link CodeAttribute Code} attribute.  Catch (JVMS {@jvms 3.12}) and\n+ * finally (JVMS {@jvms 3.14}) blocks in Java source code compile to exception\n+ * table entries.  Delivered as a {@link CodeElement} when traversing the\n+ * contents of a {@link CodeModel}.\n@@ -44,1 +45,1 @@\n- * Conceptually, an exception table entry is a record:\n+ * An exception table entry can be viewed as a record:\n@@ -46,8 +47,7 @@\n- * \/\/ @link region=0 substring=\"ExceptionCatch\" target=\"#of(Label, Label, Label, Optional)\" :\n- * \/\/ @link region=1 substring=\"Label handler\" target=\"#handler\" :\n- * \/\/ @link region=2 substring=\"Label tryStart\" target=\"#tryStart\" :\n- * \/\/ @link substring=\"Label tryEnd\" target=\"#tryEnd\" :\n- * ExceptionCatch(Label handler, Label tryStart, Label tryEnd, Optional<ClassEntry> catchType) \/\/ @link substring=\"Optional<ClassEntry> catchType\" target=\"#catchType\"\n- * \/\/ @end region=0\n- * \/\/ @end region=1\n- * \/\/ @end region=2\n+ * \/\/ @link substring=\"ExceptionCatch\" target=\"#of(Label, Label, Label, Optional)\" :\n+ * ExceptionCatch(\n+ *     Label handler, \/\/ @link substring=\"handler\" target=\"#handler\"\n+ *     Label tryStart, \/\/ @link substring=\"tryStart\" target=\"#tryStart\"\n+ *     Label tryEnd, \/\/ @link substring=\"tryEnd\" target=\"#tryEnd\"\n+ *     Optional<ClassEntry> catchType \/\/ @link substring=\"catchType\" target=\"#catchType\"\n+ * )\n@@ -55,4 +55,0 @@\n- * <p>\n- * Physically, an exception table entry has the same structure.  The labels are\n- * encoded as {@code u2} bci, and the {@code catchType} is a union of the\n- * class entry index or zero for catching all types of throwable.\n@@ -82,2 +78,2 @@\n-     * {@return the type of the exception to catch, or empty if this handler is\n-     * unconditional}\n+     * {@return the type of the exception to catch, or empty if this handler\n+     * catches everything}\n@@ -101,1 +97,1 @@\n-     * {@return an exception table pseudo-instruction for an unconditional handler}\n+     * {@return an exception table pseudo-instruction to catch everything}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ExceptionCatch.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -38,1 +37,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -50,1 +48,1 @@\n- * Conceptually, a field access instruction is a record:\n+ * A field access instruction can be viewed as a record:\n@@ -52,10 +50,5 @@\n- * \/\/ @link region substring=\"FieldInstruction\" target=\"#of(Opcode, FieldRefEntry)\"\n- * \/\/ @link substring=\"Opcode\" target=\"#opcode()\" :\n- * FieldInstruction(Opcode, FieldRefEntry) \/\/ @link substring=\"FieldRefEntry\" target=\"#field()\"\n- * \/\/ @end\n- * \/\/ @link region=1 substring=\"FieldRefEntry\" target=\"ConstantPoolBuilder#fieldRefEntry(ClassDesc, String, ClassDesc)\"\n- * \/\/ @link region=2 substring=\"ClassDesc owner\" target=\"#owner()\"\n- * \/\/ @link substring=\"String name\" target=\"#name()\" :\n- * FieldRefEntry(ClassDesc owner, String name, ClassDesc type) \/\/ @link substring=\"ClassDesc type\" target=\"#typeSymbol()\"\n- * \/\/ @end region=1\n- * \/\/ @end region=2\n+ * \/\/ @link substring=\"FieldInstruction\" target=\"#of(Opcode, FieldRefEntry)\" :\n+ * FieldInstruction(\n+ *     Opcode opcode, \/\/ @link substring=\"opcode\" target=\"#opcode()\"\n+ *     FieldRefEntry field, \/\/ @link substring=\"field\" target=\"#field()\"\n+ * )\n@@ -63,5 +56,0 @@\n- * where the {@code opcode} is of the field access kind, the {@code owner} is a\n- * class or interface, the {@code name} is a simple name, and the {@code type}\n- * is not {@link ConstantDescs#CD_void void}.\n- * <p>\n- * Physically, a field access instruction has the same structure.\n@@ -69,0 +57,1 @@\n+ * @see Opcode.Kind#FIELD_ACCESS\n@@ -81,4 +70,0 @@\n-     *\n-     * @apiNote\n-     * A symbolic descriptor for the owner is available through {@link\n-     * ClassEntry#asSymbol() owner().asSymbol()}.\n@@ -92,4 +77,0 @@\n-     *\n-     * @apiNote\n-     * A string value for the name is available through {@link\n-     * Utf8Entry#stringValue() name().stringValue()}.\n@@ -141,0 +122,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#FIELD_ACCESS}.\n@@ -156,0 +139,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#FIELD_ACCESS}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/FieldInstruction.java","additions":11,"deletions":26,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * Conceptually, a local variable increment instruction is a record:\n+ * A local variable increment instruction can be viewed as a record:\n@@ -43,4 +43,5 @@\n- * \/\/ @link region substring=\"IncrementInstruction\" target=\"#of\"\n- * \/\/ @link substring=\"int slot\" target=\"#slot()\" :\n- * IncrementInstruction(int slot, int constant) \/\/ @link substring=\"int constant\" target=\"#constant()\"\n- * \/\/ @end\n+ * \/\/ @link substring=\"IncrementInstruction\" target=\"#of\" :\n+ * IncrementInstruction(\n+ *     int slot, \/\/ @link substring=\"slot\" target=\"#slot()\"\n+ *     int constant \/\/ @link substring=\"constant\" target=\"#constant()\"\n+ * )\n@@ -48,15 +49,5 @@\n- * where the {@code slot} is a valid local variable index, and the {@code constant}\n- * must be in the range {@code [-32768, 32767]}.\n- * <p>\n- * Physically, a local variable increment instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link region=1 substring=\"Opcode\" target=\"#opcode()\"\n- * \/\/ @link substring=\"int slot\" target=\"#slot()\" :\n- * IncrementInstruction(Opcode, int slot, int constant) \/\/ @link substring=\"int constant\" target=\"#constant()\"\n- * \/\/ @end region=1\n- * }\n- * where the {@code Opcode} must be {@link Opcode#IINC iinc} or {@link\n- * Opcode#IINC_W wide iinc}; it must not be {@code iinc} if {@code slot}\n- * is greater than {@code 255} or {@code constant} is less than {@code -255} or\n- * greater than {@code 127}.  Same restrictions for {@code slot} and {@code\n- * constant} apply.\n+ * where\n+ * <ul>\n+ * <li>{@code slot} must be within {@code [0, 65535]}.\n+ * <li>{@code constant} must be within {@code [-32768, 32767]}.\n+ * <\/ul>\n@@ -64,0 +55,1 @@\n+ * @see Opcode.Kind#INCREMENT\n@@ -83,0 +75,4 @@\n+     * <ul>\n+     * <li>{@code slot} must be within {@code [0, 65535]}.\n+     * <li>{@code constant} must be within {@code [-32768, 32767]}.\n+     * <\/ul>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/IncrementInstruction.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.classfile.constantpool.ClassEntry;\n@@ -46,3 +45,4 @@\n- * Models an {@link Opcode#INVOKEDYNAMIC invokedynamic} instruction in the {@code\n- * code} array of a {@code Code} attribute.  Delivered as a {@link CodeElement}\n- * when traversing the elements of a {@link CodeModel}.\n+ * Models a dynamically-computed call site invocation instruction in the\n+ * {@code code} array of a {@code Code} attribute.  The corresponding opcode is\n+ * {@link Opcode#INVOKEDYNAMIC invokedynamic}.  Delivered as a {@link\n+ * CodeElement} when traversing the elements of a {@link CodeModel}.\n@@ -50,7 +50,2 @@\n- * Conceptually, an {@code invokedynamic} instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link substring=\"InvokeDynamicInstruction\" target=\"CodeBuilder#invokedynamic(DynamicCallSiteDesc)\" :\n- * InvokeDynamicInstruction(DynamicCallSiteDesc) \/\/ @link substring=\"DynamicCallSiteDesc\" target=\"#invokedynamic()\"\n- * }\n- * <p>\n- * Physically, an {@code invokedynamic} instruction is a record:\n+ * A dynamically-computed call site invocation instruction can be viewed as a\n+ * record:\n@@ -59,1 +54,1 @@\n- * InvokeDynamicInstruction(Opcode, InvokeDynamicEntry) \/\/ @link substring=\"InvokeDynamicEntry\" target=\"#invokedynamic()\"\n+ * InvokeDynamicInstruction(InvokeDynamicEntry invokedynamic) \/\/ @link substring=\"invokedynamic\" target=\"#invokedynamic()\"\n@@ -61,1 +56,0 @@\n- * where the {@code Opcode} is always {@code invokedynamic}.\n@@ -63,0 +57,1 @@\n+ * @see Opcode.Kind#INVOKE_DYNAMIC\n@@ -71,4 +66,0 @@\n-     *\n-     * @apiNote\n-     * A symbolic descriptor for the dynamically-computed call site is available\n-     * through {@link InvokeDynamicEntry#asSymbol() invokedynamic().asSymbol()}.\n@@ -80,4 +71,0 @@\n-     *\n-     * @apiNote\n-     * A string value for the invocation name is available through {@link\n-     * Utf8Entry#stringValue() name().stringValue()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/InvokeDynamicInstruction.java","additions":8,"deletions":21,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n@@ -40,1 +39,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -55,16 +53,5 @@\n- * \/\/ @link region substring=\"InvokeInstruction\" target=\"#of(Opcode, MemberRefEntry)\"\n- * \/\/ @link substring=\"Opcode\" target=\"#opcode()\" :\n- * InvokeInstruction(Opcode, MethodRefEntry | InterfaceMethodRefEntry method) \/\/ @link substring=\"MethodRefEntry | InterfaceMethodRefEntry method\" target=\"#method()\"\n- * \/\/ @end\n- * \/\/ @link region=1a substring=\"MethodRefEntry\" target=\"ConstantPoolBuilder#methodRefEntry(ClassDesc, String, MethodTypeDesc)\"\n- * \/\/ @link region=2a substring=\"ClassDesc owner\" target=\"#owner()\"\n- * \/\/ @link substring=\"String name\" target=\"#name()\" :\n- * MethodRefEntry(ClassDesc owner, String name, MethodTypeDesc type) \/\/ @link substring=\"MethodTypeDesc type\" target=\"#typeSymbol()\"\n- * \/\/ @end region=1a\n- * \/\/ @end region=2a\n- * \/\/ @link region=1b substring=\"InterfaceMethodRefEntry\" target=\"ConstantPoolBuilder#interfaceMethodRefEntry(ClassDesc, String, MethodTypeDesc)\"\n- * \/\/ @link region=2b substring=\"ClassDesc owner\" target=\"#owner()\"\n- * \/\/ @link substring=\"String name\" target=\"#name()\" :\n- * InterfaceMethodRefEntry(ClassDesc owner, String name, MethodTypeDesc type) \/\/ @link substring=\"MethodTypeDesc type\" target=\"#typeSymbol()\"\n- * \/\/ @end region=1b\n- * \/\/ @end region=2b\n+ * \/\/ @link substring=\"InvokeInstruction\" target=\"#of(Opcode, MemberRefEntry)\" :\n+ * InvokeInstruction(\n+ *     Opcode opcode, \/\/ @link substring=\"opcode\" target=\"#opcode()\"\n+ *     MethodRefEntry | InterfaceMethodRefEntry method) \/\/ @link substring=\"method\" target=\"#method()\"\n+ * )\n@@ -72,5 +59,1 @@\n- * where the {@code opcode} is of the method invocation kind, the {@code owner}\n- * is a class or interface, the {@code name} is a simple name or {@value\n- * ConstantDescs#INIT_NAME}.\n- * <p>\n- * The {@code method} must be an {@code InterfaceMethodRefEntry} for {@link\n+ * where {@code method} must be an {@code InterfaceMethodRefEntry} for {@link\n@@ -81,10 +64,0 @@\n- * <p>\n- * Physically, a method invocation instruction has the same structure for\n- * {@code invokestatic}, {@code invokevirtual}, and {@code invokespecial}.\n- * {@code invokeinterface} has another structure:\n- * {@snippet lang=text :\n- * \/\/ @link substring=\"InterfaceMethodRefEntry method\" target=\"#method()\" :\n- * InvokeInstruction(Opcode.INVOKEINTERFACE, InterfaceMethodRefEntry, int count) \/\/ @link substring=\"int count\" target=\"#count\"\n- * }\n- * The {@code count}, an unsigned byte, must be set according to the {@link\n- * #typeSymbol() type}.  There is another trailing 1-byte padding of value 0.\n@@ -92,0 +65,1 @@\n+ * @see Opcode.Kind#INVOKE\n@@ -109,2 +83,2 @@\n-     * {@return the {@code count} value of an {@link Opcode#INVOKEINTERFACE invokeinterface} instruction,\n-     * or {@code 0} for {@code invokespecial}, {@code invokestatic} and {@code invokevirtual} instructions}\n+     * {@return the {@code count} value of an {@code invokeinterface} instruction,\n+     * or {@code 0} for other instructions}\n@@ -123,4 +97,0 @@\n-     *\n-     * @apiNote\n-     * A symbolic descriptor for the owner is available through {@link\n-     * ClassEntry#asSymbol() owner().asSymbol()}.\n@@ -134,4 +104,0 @@\n-     *\n-     * @apiNote\n-     * A string value for the name is available through {@link\n-     * Utf8Entry#stringValue() name().stringValue()}.\n@@ -168,1 +134,1 @@\n-     *         {@link Opcode.Kind#INVOKE}.\n+     *         {@link Opcode.Kind#INVOKE}\n@@ -184,0 +150,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#INVOKE}\n@@ -201,0 +169,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#INVOKE}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/InvokeInstruction.java","additions":14,"deletions":44,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.classfile.attribute.CodeAttribute;\n@@ -38,4 +39,6 @@\n- * A pseudo-instruction which models a single entry in the\n- * {@link LineNumberTableAttribute}.  Delivered as a {@link CodeElement}\n- * during traversal of the elements of a {@link CodeModel}, according to\n- * the setting of the {@link ClassFile.LineNumbersOption} option.\n+ * A pseudo-instruction which indicates the code for a given line number starts\n+ * after the current position in a {@link CodeAttribute Code} attribute.  This\n+ * models a single entry in the {@link LineNumberTableAttribute LineNumberTable}\n+ * attribute.  Delivered as a {@link CodeElement} during traversal of the\n+ * elements of a {@link CodeModel}, according to the setting of the {@link\n+ * ClassFile.LineNumbersOption} option.\n@@ -43,1 +46,1 @@\n- * Conceptually, a line number entry is a record:\n+ * A line number entry can be viewed as a record:\n@@ -49,2 +52,4 @@\n- * Physically, a line number entry is a different record of {@code (Label, int line)};\n- * it is modeled by a {@link LineNumberInfo}.\n+ * Another model, {@link LineNumberInfo}, also models a line number entry; it\n+ * has no dependency on a {@code CodeModel} and represents of bci values as\n+ * {@code int}s instead of order of pseudo-instructions in the elements of a\n+ * {@code CodeModel}, and is used as components of a {@link LineNumberTableAttribute}.\n@@ -58,0 +63,1 @@\n+ * @see ClassFile.LineNumbersOption\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LineNumber.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * Conceptually, a local variable load instruction is a record:\n+ * A local variable load instruction can be viewed as a record:\n@@ -46,4 +46,5 @@\n- * \/\/ @link region substring=\"LoadInstruction\" target=\"#of(TypeKind, int)\"\n- * \/\/ @link substring=\"TypeKind\" target=\"#typeKind\" :\n- * LoadInstruction(TypeKind, int slot) \/\/ @link substring=\"int slot\" target=\"#slot\"\n- * \/\/ @end\n+ * \/\/ @link substring=\"LoadInstruction\" target=\"#of(TypeKind, int)\" :\n+ * LoadInstruction(\n+ *     TypeKind typeKind, \/\/ @link substring=\"typeKind\" target=\"#typeKind\"\n+ *     int slot \/\/ @link substring=\"slot\" target=\"#slot\"\n+ * )\n@@ -51,19 +52,2 @@\n- * where the {@code TypeKind} is {@linkplain TypeKind##computational-type\n- * computational}.  Multiple instructions, such as {@code aload_0}, {@code\n- * aload 0}, and {@code wide aload 0}, may match such a record, but they\n- * are functionally equivalent.\n- * <p>\n- * Physically, load variable instructions are polymorphic, discriminated by\n- * their opcode:\n- * {@snippet lang=text :\n- * LoadInstruction(Opcode) \/\/ @link substring=\"Opcode\" target=\"#opcode\"\n- * \/\/ @link region substring=\"LoadInstruction\" target=\"#of(Opcode, int)\"\n- * \/\/ @link substring=\"Opcode\" target=\"#opcode\" :\n- * LoadInstruction(Opcode, int slot) \/\/ @link substring=\"int slot\" target=\"#slot\"\n- * \/\/ @end\n- * }\n- * the first form requires the {@code slot} to be intrinsic to the {@code Opcode};\n- * such opcodes have an {@linkplain Opcode#sizeIfFixed() instruction size} of {@code 1}.\n- * Otherwise, the {@code slot} must be compatible with the {@code Opcode}, such\n- * that if the opcode is not {@linkplain Opcode#isWide() wide}, the {@code slot}\n- * must be no greater than {@code 255}.\n+ * where {@code TypeKind} is {@linkplain TypeKind##computational-type\n+ * computational}, and {@code slot} is within {@code [0, 65535]}.\n@@ -71,0 +55,1 @@\n+ * @see Opcode.Kind#LOAD\n@@ -80,0 +65,1 @@\n+     * The value is within {@code [0, 65535]}.\n@@ -91,0 +77,3 @@\n+     * {@code kind} is {@linkplain TypeKind#asLoadable() converted} to its\n+     * computational type.\n+     * {@code slot} must be within {@code [0, 65535]}.\n@@ -104,0 +93,9 @@\n+     * <p>\n+     * The range of {@code slot} is restricted by the {@code op} and its\n+     * {@linkplain Opcode#sizeIfFixed() size}:\n+     * <ul>\n+     * <li>If {@code op} has size 1, {@code slot} must be exactly the slot value\n+     * implied by the opcode.\n+     * <li>If {@code op} has size 2, {@code slot} must be within {@code [0, 255]}.\n+     * <li>If {@code op} has size 4, {@code slot} must be within {@code [0, 65535]}.\n+     * <\/ul>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LoadInstruction.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -44,4 +44,4 @@\n- * A pseudo-instruction which models a single entry in the\n- * {@link LocalVariableTableAttribute}.  Delivered as a {@link CodeElement}\n- * during traversal of the elements of a {@link CodeModel}, according to\n- * the setting of the {@link ClassFile.DebugElementsOption} option.\n+ * A pseudo-instruction which models a single entry in the {@link\n+ * LocalVariableTableAttribute LocalVariableTable} attribute.  Delivered as a\n+ * {@link CodeElement} during traversal of the elements of a {@link CodeModel},\n+ * according to the setting of the {@link ClassFile.DebugElementsOption} option.\n@@ -49,1 +49,1 @@\n- * Conceptually, a local variable table entry is a record:\n+ * A local variable entry can be viewed a record:\n@@ -51,10 +51,8 @@\n- * \/\/ @link region=0 substring=\"LocalVariable\" target=\"#of(int, String, ClassDesc, Label, Label)\"\n- * \/\/ @link region=1 substring=\"int slot\" target=\"#slot\"\n- * \/\/ @link region=2 substring=\"String name\" target=\"#name\"\n- * \/\/ @link region=3 substring=\"ClassDesc type\" target=\"#typeSymbol\"\n- * \/\/ @link substring=\"Label startScope\" target=\"#startScope\" :\n- * LocalVariable(int slot, String name, ClassDesc type, Label startScope, Label endScope) \/\/ @link substring=\"Label endScope\" target=\"#endScope\"\n- * \/\/ @end region=0\n- * \/\/ @end region=1\n- * \/\/ @end region=2\n- * \/\/ @end region=3\n+ * \/\/ @link substring=\"LocalVariable\" target=\"#of(int, String, ClassDesc, Label, Label)\" :\n+ * LocalVariable(\n+ *     int slot, \/\/ @link substring=\"slot\" target=\"#slot\"\n+ *     String name, \/\/ @link substring=\"name\" target=\"#name\"\n+ *     ClassDesc type, \/\/ @link substring=\"type\" target=\"#type\"\n+ *     Label startScope, \/\/ @link substring=\"startScope\" target=\"#startScope\"\n+ *     Label endScope \/\/ @link substring=\"endScope\" target=\"#endScope\"\n+ * )\n@@ -62,1 +60,1 @@\n- * Where {@code type} must be non-{@code void}.\n+ * Where {@code slot} is within {@code [0, 65535]}.\n@@ -64,16 +62,4 @@\n- * Physically, a local variable table entry modeled by a {@link LocalVariableInfo}.\n- * It is a record:\n- * {@snippet lang=text :\n- * \/\/ @link region=0 substring=\"LocalVariable\" target=\"#of(int, Utf8Entry, Utf8Entry, Label, Label)\"\n- * \/\/ @link region=1 substring=\"int slot\" target=\"#slot\"\n- * \/\/ @link region=2 substring=\"Utf8Entry name\" target=\"#name\"\n- * \/\/ @link region=3 substring=\"Utf8Entry type\" target=\"#type\"\n- * \/\/ @link substring=\"Label startScope\" target=\"#startScope\" :\n- * LocalVariable(Label startScope, Label endScope, Utf8Entry name, Utf8Entry type, int slot) \/\/ @link substring=\"Label endScope\" target=\"#endScope\"\n- * \/\/ @end region=0\n- * \/\/ @end region=1\n- * \/\/ @end region=2\n- * \/\/ @end region=3\n- * }\n- * Where the {@code endScope} is encoded as a nonnegative bci offset to\n- * {@code startScope}, a bci value.\n+ * Another model, {@link LocalVariableInfo}, also models a local variable\n+ * entry; it has no dependency on a {@code CodeModel} and represents of bci\n+ * values as {@code int}s instead of {@code Label}s, and is used as components\n+ * of a {@link LocalVariableTableAttribute}.\n@@ -82,3 +68,3 @@\n- * Local variable table entries are used for all local variables in Java source\n- * code.  If a local variable has a parameterized type, a type argument, or an\n- * array type of one of the previous types, a local variable type table entry is\n+ * {@code LocalVariable} is used for all local variables in Java source code.\n+ * If a local variable has a parameterized type, a type argument, or an array\n+ * type of one of the previous types, a {@link LocalVariableType} should be\n@@ -87,1 +73,0 @@\n- * @see LocalVariableTableAttribute\n@@ -90,0 +75,1 @@\n+ * @see ClassFile.DebugElementsOption\n@@ -96,0 +82,1 @@\n+     * The value is within {@code [0, 65535]}.\n@@ -101,4 +88,0 @@\n-     *\n-     * @apiNote\n-     * A string value for the name is available through {@link\n-     * Utf8Entry#stringValue() name().stringValue()}.\n@@ -136,0 +119,1 @@\n+     * {@code slot} must be within {@code [0, 65535]}.\n@@ -151,0 +135,1 @@\n+     * {@code slot} must be within {@code [0, 65535]}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariable.java","additions":25,"deletions":40,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -38,3 +38,3 @@\n- * LocalVariableTypeTableAttribute}.  Delivered as a {@link CodeElement} during\n- * traversal of the elements of a {@link CodeModel}, according to the setting of\n- * the {@link ClassFile.DebugElementsOption} option.\n+ * LocalVariableTypeTableAttribute LocalVariableTypeTable} attribute.  Delivered\n+ * as a {@link CodeElement} during traversal of the elements of a {@link CodeModel},\n+ * according to the setting of the {@link ClassFile.DebugElementsOption} option.\n@@ -42,1 +42,1 @@\n- * Conceptually, a local variable type table entry is a record:\n+ * A local variable type entry can be viewed as a record:\n@@ -44,10 +44,8 @@\n- * \/\/ @link region=0 substring=\"LocalVariableType\" target=\"#of(int, String, Signature, Label, Label)\"\n- * \/\/ @link region=1 substring=\"int slot\" target=\"#slot\"\n- * \/\/ @link region=2 substring=\"String name\" target=\"#name\"\n- * \/\/ @link region=3 substring=\"Signature signature\" target=\"#signatureSymbol\"\n- * \/\/ @link substring=\"Label startScope\" target=\"#startScope\" :\n- * LocalVariableType(int slot, String name, Signature signature, Label startScope, Label endScope) \/\/ @link substring=\"Label endScope\" target=\"#endScope\"\n- * \/\/ @end region=0\n- * \/\/ @end region=1\n- * \/\/ @end region=2\n- * \/\/ @end region=3\n+ * \/\/ @link substring=\"LocalVariableType\" target=\"#of(int, String, Signature, Label, Label)\" :\n+ * LocalVariableType(\n+ *     int slot, \/\/ @link substring=\"slot\" target=\"#slot\"\n+ *     String name, \/\/ @link substring=\"name\" target=\"#name\"\n+ *     Signature signature, \/\/ @link substring=\"signature\" target=\"#signatureSymbol\"\n+ *     Label startScope, \/\/ @link substring=\"startScope\" target=\"#startScope\"\n+ *     Label endScope \/\/ @link substring=\"endScope\" target=\"#endScope\"\n+ * )\n@@ -55,1 +53,1 @@\n- * Where {@code signature} must be non-{@code void}.\n+ * Where {@code slot} is within {@code [0, 65535]}.\n@@ -57,16 +55,4 @@\n- * Physically, a local variable type table entry modeled by a {@link LocalVariableTypeInfo}.\n- * It is a record:\n- * {@snippet lang=text :\n- * \/\/ @link region=0 substring=\"LocalVariableType\" target=\"#of(int, Utf8Entry, Utf8Entry, Label, Label)\"\n- * \/\/ @link region=1 substring=\"int slot\" target=\"#slot\"\n- * \/\/ @link region=2 substring=\"Utf8Entry name\" target=\"#name\"\n- * \/\/ @link region=3 substring=\"Utf8Entry signature\" target=\"#signature\"\n- * \/\/ @link substring=\"Label startScope\" target=\"#startScope\" :\n- * LocalVariableType(Label startScope, Label endScope, Utf8Entry name, Utf8Entry signature, int slot) \/\/ @link substring=\"Label endScope\" target=\"#endScope\"\n- * \/\/ @end region=0\n- * \/\/ @end region=1\n- * \/\/ @end region=2\n- * \/\/ @end region=3\n- * }\n- * Where the {@code endScope} is encoded as a nonnegative bci offset to\n- * {@code startScope}, a bci value.\n+ * Another model, {@link LocalVariableTypeInfo}, also models a local variable\n+ * type entry; it has no dependency on a {@code CodeModel} and represents of bci\n+ * values as {@code int}s instead of {@code Label}s, and is used as components\n+ * of a {@link LocalVariableTypeTableAttribute}.\n@@ -75,4 +61,4 @@\n- * Local variable type table entry is used if a local variable has a parameterized\n- * type, a type argument, or an array type of one of the previous types as its type.\n- * A local variable table entry with the erased type should still be created for\n- * that local variable.\n+ * {@code LocalVariableType} is used if a local variable has a parameterized\n+ * type, a type argument, or an array type of one of the previous types as its\n+ * type.  A {@link LocalVariable} with the erased type should still be created\n+ * for that local variable.\n@@ -80,1 +66,0 @@\n- * @see LocalVariableTypeTableAttribute\n@@ -83,0 +68,1 @@\n+ * @see ClassFile.DebugElementsOption\n@@ -89,0 +75,1 @@\n+     * The value is within {@code [0, 65535]}.\n@@ -94,4 +81,0 @@\n-     *\n-     * @apiNote\n-     * A string value for the name is available through {@link\n-     * Utf8Entry#stringValue() name().stringValue()}.\n@@ -129,0 +112,1 @@\n+     * {@code slot} must be within {@code [0, 65535]}.\n@@ -144,0 +128,1 @@\n+     * {@code slot} must be within {@code [0, 65535]}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariableType.java","additions":25,"deletions":40,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * Conceptually, a {@code lookupswitch} instruction is a record:\n+ * A lookup switch instruction can be viewed as a record:\n@@ -44,4 +44,5 @@\n- * \/\/ @link region substring=\"LookupSwitchInstruction\" target=\"#of\"\n- * \/\/ @link substring=\"Label defaultTarget\" target=\"#defaultTarget\" :\n- * LookupSwitchInstruction(Label defaultTarget, List<SwitchCase> cases) \/\/ @link substring=\"List<SwitchCase> cases\" target=\"#cases()\"\n- * \/\/ @end\n+ * \/\/ @link substring=\"LookupSwitchInstruction\" target=\"#of\" :\n+ * LookupSwitchInstruction(\n+ *     Label defaultTarget, \/\/ @link substring=\"defaultTarget\" target=\"#defaultTarget\"\n+ *     List<SwitchCase> cases \/\/ @link substring=\"cases\" target=\"#cases()\"\n+ * )\n@@ -49,2 +50,2 @@\n- * If elements in {@code cases} are not sorted ascending by their {@linkplain\n- * SwitchCase#caseValue value}, a sorted version of the {@code cases} list\n+ * If elements in {@code cases} are not sorted ascending by their {@link\n+ * SwitchCase#caseValue caseValue}, a sorted version of the {@code cases} list\n@@ -52,11 +53,0 @@\n- * <p>\n- * Physically, a {@code lookupswitch} instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link region substring=\"LookupSwitchInstruction\" target=\"#of\"\n- * \/\/ @link substring=\"Label defaultTarget\" target=\"#defaultTarget\" :\n- * LookupSwitchInstruction(Opcode.LOOKUPSWITCH, padding, Label defaultTarget, List<SwitchCase> cases) \/\/ @link substring=\"List<SwitchCase> cases\" target=\"#cases()\"\n- * \/\/ @end\n- * }\n- * The {@code padding} is 0 to 3 bytes of any value, making the default target\n- * 4-byte aligned to the beginning of the {@code code} array.  It also requires\n- * the elements in {@code cases} to be sorted ascending by their value.\n@@ -64,0 +54,1 @@\n+ * @see Opcode.Kind#LOOKUP_SWITCH\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LookupSwitchInstruction.java","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * Conceptually and physically, a monitor instruction is a record:\n+ * A monitor instruction can be viewed record:\n@@ -46,1 +46,1 @@\n- * MonitorInstruction(Opcode) \/\/ @link substring=\"Opcode\" target=\"#opcode\"\n+ * MonitorInstruction(Opcode opcode) \/\/ @link substring=\"opcode\" target=\"#opcode\"\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/MonitorInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -43,1 +42,1 @@\n- * Conceptually, a {@code multianewarray} instruction is a record:\n+ * A new multi-dimensional array instruction can be viewed as a record:\n@@ -45,4 +44,5 @@\n- * \/\/ @link region substring=\"NewMultiArrayInstruction\" target=\"CodeBuilder#multianewarray(ClassDesc, int)\"\n- * \/\/ @link substring=\"ClassDesc arrayType\" target=\"#arrayType\" :\n- * NewMultiArrayInstruction(ClassDesc arrayType, int dimensions) \/\/ @link substring=\"int dimensions\" target=\"#dimensions\"\n- * \/\/ @end\n+ * \/\/ @link substring=\"NewMultiArrayInstruction\" target=\"#of\" :\n+ * NewMultiArrayInstruction(\n+ *     ClassEntry arrayType, \/\/ @link substring=\"arrayType\" target=\"#arrayType\"\n+ *     int dimensions \/\/ @link substring=\"dimensions\" target=\"#dimensions\"\n+ * )\n@@ -51,8 +51,0 @@\n- * <p>\n- * Physically, a {@code multianewarray} instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link region substring=\"NewMultiArrayInstruction\" target=\"#of\"\n- * \/\/ @link substring=\"ClassEntry arrayType\" target=\"#arrayType\" :\n- * NewMultiArrayInstruction(Opcode.MULTIANEWARRAY, ClassEntry arrayType, int dimensions) \/\/ @link substring=\"int dimensions\" target=\"#dimensions\"\n- * \/\/ @end\n- * }\n@@ -60,0 +52,1 @@\n+ * @see Opcode.Kind#NEW_MULTI_ARRAY\n@@ -70,4 +63,0 @@\n-     *\n-     * @apiNote\n-     * A symbolic descriptor for the type of the array is available through\n-     * {@link ClassEntry#asSymbol() arrayType().asSymbol()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewMultiArrayInstruction.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * Conceptually, a {@code new} instruction is a record:\n+ * A new object instruction can be viewed as a record:\n@@ -43,9 +43,2 @@\n- * \/\/ @link substring=\"NewObjectInstruction\" target=\"CodeBuilder#new_(ClassDesc)\" :\n- * NewObjectInstruction(ClassDesc) \/\/ @link substring=\"ClassDesc\" target=\"#className\"\n- * }\n- * where the {@code ClassDesc} is a non-abstract class.\n- * <p>\n- * Physically, a {@code new} instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link substring=\"NewObjectInstruction\" target=\"#of(ClassEntry)\" :\n- * NewObjectInstruction(Opcode.NEW, ClassEntry) \/\/ @link substring=\"ClassEntry\" target=\"#className\"\n+ * \/\/ @link substring=\"NewObjectInstruction\" target=\"#of\" :\n+ * NewObjectInstruction(ClassEntry className) \/\/ @link substring=\"className\" target=\"#className\"\n@@ -53,0 +46,1 @@\n+ * where the {@code className} is a non-abstract class.\n@@ -54,0 +48,1 @@\n+ * @see Opcode.Kind#NEW_OBJECT\n@@ -63,4 +58,0 @@\n-     *\n-     * @apiNote\n-     * A symbolic descriptor for the type of the object is available through\n-     * {@link ClassEntry#asSymbol() className().asSymbol()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewObjectInstruction.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.classfile.constantpool.ClassEntry;\n@@ -42,1 +41,1 @@\n- * Conceptually, a {@code newarray} instruction is a record:\n+ * A new primitive array instruction can be viewed as a record:\n@@ -45,1 +44,1 @@\n- * NewPrimitiveArrayInstruction(TypeKind) \/\/ @link substring=\"TypeKind\" target=\"#typeKind\"\n+ * NewPrimitiveArrayInstruction(TypeKind typeKind) \/\/ @link substring=\"typeKind\" target=\"#typeKind\"\n@@ -47,8 +46,1 @@\n- * where the {@code TypeKind} is primitive and not {@code void}.\n- * <p>\n- * Physically, a {@code newarray} instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link substring=\"NewPrimitiveArrayInstruction\" target=\"#of\" :\n- * NewPrimitiveArrayInstruction(Opcode.NEWARRAY, int code) \/\/ @link substring=\"int code\" target=\"TypeKind#newarrayCode()\"\n- * }\n- * where the code is a valid new array code.\n+ * where {@code typeKind} is primitive and not {@code void}.\n@@ -56,0 +48,1 @@\n+ * @see Opcode.Kind#NEW_PRIMITIVE_ARRAY\n@@ -76,2 +69,3 @@\n-     * @throws IllegalArgumentException when the {@code typeKind} is not a legal\n-     *                                  primitive array component type\n+     * @throws IllegalArgumentException when {@code typeKind} is not primitive\n+     *         or is {@code void}\n+     * @see TypeKind#fromNewarrayCode(int) TypeKind::fromNewarrayCode\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewPrimitiveArrayInstruction.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -41,8 +41,1 @@\n- * Conceptually, an {@code anewarray} instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link substring=\"NewReferenceArrayInstruction\" target=\"CodeBuilder#anewarray(ClassDesc)\" :\n- * NewReferenceArrayInstruction(ClassDesc) \/\/ @link substring=\"ClassDesc\" target=\"#componentType\"\n- * }\n- * where the {@code ClassDesc} is not primitive.\n- * <p>\n- * Physically, an {@code anewarray} instruction is a record:\n+ * A new reference array instruction can be viewed as a record:\n@@ -51,1 +44,1 @@\n- * NewReferenceArrayInstruction(Opcode.ANEWARRAY, ClassEntry) \/\/ @link substring=\"ClassEntry\" target=\"#componentType\"\n+ * NewReferenceArrayInstruction(ClassEntry componentType) \/\/ @link substring=\"componentType\" target=\"#componentType\"\n@@ -54,0 +47,1 @@\n+ * @see Opcode.Kind#NEW_REF_ARRAY\n@@ -62,4 +56,0 @@\n-     *\n-     * @apiNote\n-     * A symbolic descriptor for the component type of the array is available\n-     * through {@link ClassEntry#asSymbol() componentType().asSymbol()}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewReferenceArrayInstruction.java","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * Conceptually and physically, a no-op instruction is a record:\n+ * A no-op instruction can be viewed as a record:\n@@ -43,1 +43,1 @@\n- * NopInstruction(Opcode.NOP)\n+ * NopInstruction()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NopInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * Conceptually and physically, an operator instruction is a record:\n+ * An operator instruction can be viewed as a record:\n@@ -45,1 +45,1 @@\n- * OperatorInstruction(Opcode) \/\/ @link substring=\"Opcode\" target=\"#opcode()\"\n+ * OperatorInstruction(Opcode opcode) \/\/ @link substring=\"opcode\" target=\"#opcode()\"\n@@ -47,1 +47,0 @@\n- * The {@link #typeKind() typeKind()} attribute is intrinsic to the opcode.\n@@ -49,0 +48,1 @@\n+ * @see Opcode.Kind#OPERATOR\n@@ -55,0 +55,1 @@\n+     * This is derived from the {@link #opcode opcode}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/OperatorInstruction.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * Conceptually, a return-from-method instruction is a record:\n+ * A return-from-method instruction can be viewed a record:\n@@ -47,1 +47,1 @@\n- * ReturnInstruction(TypeKind) \/\/ @link substring=\"TypeKind\" target=\"#typeKind()\"\n+ * ReturnInstruction(TypeKind typeKind) \/\/ @link substring=\"typeKind\" target=\"#typeKind()\"\n@@ -49,1 +49,1 @@\n- * where the {@code TypeKind} is {@linkplain TypeKind##computational-type\n+ * where {@code typeKind} is {@linkplain TypeKind##computational-type\n@@ -51,8 +51,0 @@\n- * <p>\n- * Physically, an return-from-method instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link substring=\"ReturnInstruction\" target=\"#of(Opcode)\" :\n- * ReturnInstruction(Opcode) \/\/ @link substring=\"Opcode\" target=\"#opcode()\"\n- * }\n- * where the {@code Opcode} is of the return kind.  The computational type\n- * type of the instruction is intrinsic to the opcode.\n@@ -60,0 +52,1 @@\n+ * @see Opcode.Kind#RETURN\n@@ -74,0 +67,2 @@\n+     * {@code typeKind} is {@linkplain TypeKind#asLoadable() converted} to its\n+     * computational type.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ReturnInstruction.java","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * Conceptually and physically, a stack manipulation instruction is a record:\n+ * A stack manipulation instruction can be viewed as a record:\n@@ -44,1 +44,1 @@\n- * StackInstruction(Opcode) \/\/ @link substring=\"Opcode\" target=\"#opcode()\"\n+ * StackInstruction(Opcode opcode) \/\/ @link substring=\"opcode\" target=\"#opcode()\"\n@@ -46,2 +46,0 @@\n- * All attributes of stack manipulation instructions are intrinsic to the\n- * opcode.\n@@ -49,0 +47,1 @@\n+ * @see Opcode.Kind#STACK\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/StackInstruction.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * Conceptually, a local variable store instruction is a record:\n+ * A local variable store instruction can be viewed as a record:\n@@ -46,4 +46,5 @@\n- * \/\/ @link region substring=\"StoreInstruction\" target=\"#of(TypeKind, int)\"\n- * \/\/ @link substring=\"TypeKind\" target=\"#typeKind\" :\n- * StoreInstruction(TypeKind, int slot) \/\/ @link substring=\"int slot\" target=\"#slot\"\n- * \/\/ @end\n+ * \/\/ @link substring=\"StoreInstruction\" target=\"#of(TypeKind, int)\" :\n+ * StoreInstruction(\n+ *     TypeKind typeKind, \/\/ @link substring=\"typeKind\" target=\"#typeKind\"\n+ *     int slot \/\/ @link substring=\"slot\" target=\"#slot\"\n+ * )\n@@ -51,4 +52,2 @@\n- * where the {@code TypeKind} is {@linkplain TypeKind##computational-type\n- * computational}.  Multiple instructions, such as {@code astore_0}, {@code\n- * astore 0}, and {@code wide astore 0}, may match such a record, but they\n- * are functionally equivalent.\n+ * where {@code TypeKind} is {@linkplain TypeKind##computational-type\n+ * computational}, and {@code slot} is within {@code [0, 65535]}.\n@@ -56,18 +55,4 @@\n- * Physically, store variable instructions are polymorphic, discriminated by\n- * their opcode:\n- * {@snippet lang=text :\n- * StoreInstruction(Opcode) \/\/ @link substring=\"Opcode\" target=\"#opcode\"\n- * \/\/ @link region substring=\"StoreInstruction\" target=\"#of(Opcode, int)\"\n- * \/\/ @link substring=\"Opcode\" target=\"#opcode\" :\n- * StoreInstruction(Opcode, int slot) \/\/ @link substring=\"int slot\" target=\"#slot\"\n- * \/\/ @end\n- * }\n- * the first form requires the {@code slot} to be intrinsic to the {@code Opcode};\n- * such opcodes have an {@linkplain Opcode#sizeIfFixed() instruction size} of {@code 1}.\n- * Otherwise, the {@code slot} must be compatible with the {@code Opcode}, such\n- * that if the opcode is not {@linkplain Opcode#isWide() wide}, the {@code slot}\n- * must be no greater than {@code 255}.\n- * <p>\n- * {@code astore} series of instructions can operate on the {@code returnAddress}\n- * type from {@linkplain DiscontinuedInstruction.JsrInstruction jump subroutine\n- * instructions}.\n+ * {@code astore} series of instructions, or {@code reference} type store\n+ * instructions, can also operate on the {@link TypeKind##returnAddress\n+ * returnAddress} type from discontinued {@linkplain\n+ * DiscontinuedInstruction.JsrInstruction jump subroutine instructions}.\n@@ -75,0 +60,1 @@\n+ * @see Opcode.Kind#STORE\n@@ -83,0 +69,1 @@\n+     * The value is within {@code [0, 65535]}.\n@@ -96,0 +83,3 @@\n+     * {@code kind} is {@linkplain TypeKind#asLoadable() converted} to its\n+     * computational type.\n+     * {@code slot} must be within {@code [0, 65535]}.\n@@ -109,0 +99,9 @@\n+     * <p>\n+     * The range of {@code slot} is restricted by the {@code op} and its\n+     * {@linkplain Opcode#sizeIfFixed() size}:\n+     * <ul>\n+     * <li>If {@code op} has size 1, {@code slot} must be exactly the slot value\n+     * implied by the opcode.\n+     * <li>If {@code op} has size 2, {@code slot} must be within {@code [0, 255]}.\n+     * <li>If {@code op} has size 4, {@code slot} must be within {@code [0, 65535]}.\n+     * <\/ul>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/StoreInstruction.java","additions":26,"deletions":27,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * Conceptually, a switch case is a record:\n+ * A switch case can be viewed as a record:\n@@ -37,4 +37,5 @@\n- * \/\/ @link region substring=\"SwitchCase\" target=\"#of\"\n- * \/\/ @link substring=\"Label target\" target=\"#target\" :\n- * SwitchCase(int caseValue, Label target) \/\/ @link substring=\"int caseValue\" target=\"#caseValue\"\n- * \/\/ @end\n+ * \/\/ @link substring=\"SwitchCase\" target=\"#of\" :\n+ * SwitchCase(\n+ *     int caseValue, \/\/ @link substring=\"caseValue\" target=\"#caseValue\"\n+ *     Label target \/\/ @link substring=\"target\" target=\"#target\"\n+ * )\n@@ -42,8 +43,0 @@\n- * <p>\n- * Physically, a switch case is represented differently in a {@code lookupswitch}\n- * versus in a {@code tableswitch}.  In a {@code lookupswitch}, a switch case\n- * is as its conceptual representation, a tuple of lookup key and jump target.\n- * A {@code tableswitch} instead knows a {@link TableSwitchInstruction#lowValue\n- * lowValue}, and the lookup value of the case is implicitly {@code lowValue\n- * + index}, where {@code index} is the index of the case into the array of\n- * cases.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/SwitchCase.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- * Conceptually, a {@code tableswitch} instruction is a record:\n+ * A table switch instruction can be viewed a record:\n@@ -44,4 +44,7 @@\n- * \/\/ @link region=0 substring=\"TableSwitchInstruction\" target=\"CodeBuilder#tableswitch(Label, List)\"\n- * \/\/ @link substring=\"Label defaultTarget\" target=\"#defaultTarget\" :\n- * TableSwitchInstruction(Label defaultTarget, List<SwitchCase> cases) \/\/ @link substring=\"List<SwitchCase> cases\" target=\"#cases()\"\n- * \/\/ @end region=0\n+ * \/\/ @link substring=\"TableSwitchInstruction\" target=\"#of\" :\n+ * TableSwitchInstruction(\n+ *     int lowValue, \/\/ @link substring=\"int lowValue\" target=\"#lowValue\"\n+ *     int highValue, \/\/ @link substring=\"int highValue\" target=\"#highValue\"\n+ *     Label defaultTarget, \/\/ @link substring=\"defaultTarget\" target=\"#defaultTarget\"\n+ *     List<SwitchCase> cases \/\/ @link substring=\"cases\" target=\"#cases()\"\n+ * )\n@@ -49,2 +52,0 @@\n- * Where the {@link #lowValue lowValue} and {@link #highValue highValue} are\n- * derived from the list of cases.\n@@ -52,19 +53,3 @@\n- * Physically, a {@code tableswich} instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link region=0 substring=\"TableSwitchInstruction\" target=\"#of\"\n- * \/\/ @link region=1 substring=\"int lowValue\" target=\"#lowValue\"\n- * \/\/ @link region=2 substring=\"int highValue\" target=\"#highValue\"\n- * \/\/ @link substring=\"Label defaultTarget\" target=\"#defaultTarget\" :\n- * TableSwitchInstruction(Opcode.TABLESWITCH, padding, Label defaultTarget, int lowValue, int highValue, List<Label> cases) \/\/ @link substring=\"List<Label> cases\" target=\"#cases()\"\n- * \/\/ @end region=0\n- * \/\/ @end region=1\n- * \/\/ @end region=2\n- * }\n- * The {@code padding} is 0 to 3 bytes of any value, making the default target\n- * 4-byte aligned to the beginning of the {@code code} array.  The {@code cases}\n- * list has an implicit length equal to {@code highValue - lowValue + 1}, and\n- * the case at {@code index} has value {@code lowValue + index}.\n- * <p>\n- * When read from {@code class} files, the {@code List<SwitchCase> cases}\n- * may omit cases that duplicate the default target.  The list is sorted\n- * ascending by the values.\n+ * When read from {@code class} files, the {@code cases} may omit cases that\n+ * duplicate the default target.  The list is sorted ascending by the {@link\n+ * SwitchCase#caseValue() caseValue}.\n@@ -72,6 +57,5 @@\n- * When writing, the order in the {@code List<SwitchCase> cases} list does not\n- * matter, as there is only one valid order in the physical representation of\n- * table switch entries.  Treatment of elements in {@code List<SwitchCase> cases}\n- * whose {@linkplain SwitchCase#caseValue value} is less than {@code lowValue}\n- * or greater than {@code highValue}, and elements whose value duplicates that\n- * of another, is not specified.\n+ * When writing to {@code class} file, the order in the {@code cases} list does\n+ * not matter, as there is only one valid order in the physical representation\n+ * of table switch entries.  Treatment of elements in {@code cases} whose value\n+ * is less than {@code lowValue} or greater than {@code highValue}, and elements\n+ * whose value duplicates that of another, is not specified.\n@@ -79,0 +63,1 @@\n+ * @see Opcode.Kind#TABLE_SWITCH\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/TableSwitchInstruction.java","additions":17,"deletions":32,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * Conceptually and physically, a stack manipulation instruction is a record:\n+ * A throw instruction can be viewed as a record:\n@@ -43,1 +43,1 @@\n- * ThrowInstruction(Opcode.ATHROW)\n+ * ThrowInstruction()\n@@ -46,0 +46,1 @@\n+ * @see Opcode.Kind#THROW_EXCEPTION\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ThrowInstruction.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- * Conceptually, a type check instruction is a record:\n+ * A type check instruction can be viewed as a record:\n@@ -50,13 +50,5 @@\n- * \/\/ @link region substring=\"TypeCheckInstruction\" target=\"#of(Opcode, ClassDesc)\"\n- * \/\/ @link substring=\"Opcode\" target=\"#opcode\" :\n- * TypeCheckInstruction(Opcode, ClassDesc) \/\/ @link substring=\"ClassDesc\" target=\"#type\"\n- * \/\/ @end\n- * }\n- * where the {@code ClassDesc} is not primitive.\n- * <p>\n- * Physically, a type check instruction is a record:\n- * {@snippet lang=text :\n- * \/\/ @link region substring=\"TypeCheckInstruction\" target=\"#of(Opcode, ClassEntry)\"\n- * \/\/ @link substring=\"Opcode\" target=\"#opcode\" :\n- * TypeCheckInstruction(Opcode, ClassEntry) \/\/ @link substring=\"ClassEntry\" target=\"#type\"\n- * \/\/ @end\n+ * \/\/ @link substring=\"TypeCheckInstruction\" target=\"#of(Opcode, ClassEntry)\" :\n+ * TypeCheckInstruction(\n+ *     Opcode opcode, \/\/ @link substring=\"opcode\" target=\"#opcode\"\n+ *     ClassEntry type \/\/ @link substring=\"type\" target=\"#type\"\n+ * )\n@@ -73,4 +65,0 @@\n-     *\n-     * @apiNote\n-     * A symbolic descriptor for the type checked is available through {@link\n-     * ClassEntry#asSymbol() type().asSymbol()}.\n@@ -87,1 +75,1 @@\n-     *         {@link Opcode.Kind#TYPE_CHECK}.\n+     *         {@link Opcode.Kind#TYPE_CHECK}\n@@ -100,0 +88,2 @@\n+     * @throws IllegalArgumentException if the opcode kind is not\n+     *         {@link Opcode.Kind#TYPE_CHECK}, or if {@code type} is primitive\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/TypeCheckInstruction.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"}]}