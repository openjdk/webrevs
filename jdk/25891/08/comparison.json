{"files":[{"patch":"@@ -469,1 +469,2 @@\n-  if (!Metaspace::contains(klass)) {\n+  Metaspace::FailureHint hint = Metaspace::FailureHint::unknown;\n+  if (!Metaspace::klass_is_live(klass, true, &hint)) {\n@@ -471,1 +472,2 @@\n-                          \"is not in metaspace\", p2i(klass), p2i(obj));\n+                          \"is an invalid klass pointer, not in metaspace, or refers to a dead klass (Hint: %u)\",\n+                          p2i(klass), p2i(obj), (unsigned)hint);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -238,0 +238,1 @@\n+  const Klass* k = nullptr;\n@@ -251,1 +252,3 @@\n-    return Metaspace::contains(mark.klass_without_asserts());\n+    k = mark.klass_without_asserts();\n+  } else {\n+    k = object->klass_without_asserts();\n@@ -254,1 +257,1 @@\n-  return Metaspace::contains(object->klass_without_asserts());\n+  return Metaspace::klass_is_live(k, true);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -133,0 +133,16 @@\n+void ShenandoahAsserts::vprintf_failure(SafeLevel level, oop obj, void *interior_loc, oop loc,\n+                                        const char *phase, const char *file, int line, const char *fmt,\n+                                        va_list args) {\n+  stringStream ss(512);\n+  ss.vprint(fmt, args);\n+  print_failure(level, obj, interior_loc, loc, phase, ss.base(), file, line);\n+}\n+\n+void ShenandoahAsserts::printf_failure(SafeLevel level, oop obj, void* interior_loc, oop loc,\n+                                       const char* phase, const char* file, int line, const char* fmt, ...) {\n+  va_list args;\n+  va_start(args, fmt);\n+  vprintf_failure(level, obj, interior_loc, loc, phase, file, line, fmt, args);\n+  va_end(args);\n+}\n+\n@@ -218,0 +234,1 @@\n+  Metaspace::FailureHint hint = Metaspace::FailureHint::unknown;\n@@ -229,2 +246,2 @@\n-                  \"oop within heap bounds but at unreadable location\",\n-                  file, line);\n+                  \"Object klass pointer should not be null\",\n+                  file,line);\n@@ -300,4 +317,4 @@\n-  if (!Metaspace::contains(obj_klass)) {\n-    print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n-                  \"Object klass pointer must go to metaspace\",\n-                  file,line);\n+  if (!Metaspace::klass_is_live(obj_klass, true, &hint)) {\n+    printf_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                   file, line, \"Object klass \" PTR_FORMAT \": invalid klass pointer or dead\/invalid Klass (hint: %u)\",\n+                   p2i(obj_klass), (unsigned)hint);\n@@ -318,5 +335,5 @@\n-    const Metadata* klass = fwd->metadata_field(java_lang_Class::klass_offset());\n-    if (klass != nullptr && !Metaspace::contains(klass)) {\n-      print_failure(_safe_all, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n-                    \"Mirrored instance class should point to Metaspace\",\n-                    file, line);\n+    const Klass* klass = (const Klass*) fwd->metadata_field(java_lang_Class::klass_offset());\n+    if (klass != nullptr && !Metaspace::klass_is_live(klass, false \/* possibly not encodable *\/, &hint)) {\n+      printf_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                     file, line, \"Mirrored instance klass \" PTR_FORMAT \": invalid klass pointer or dead\/invalid Klass (hint: %u)\",\n+                     p2i(klass), (unsigned)hint);\n@@ -324,6 +341,5 @@\n-\n-    const Metadata* array_klass = fwd->metadata_field(java_lang_Class::array_klass_offset());\n-    if (array_klass != nullptr && !Metaspace::contains(array_klass)) {\n-      print_failure(_safe_all, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n-                    \"Mirrored array class should point to Metaspace\",\n-                    file, line);\n+    const Klass* array_klass = (const Klass*) fwd->metadata_field(java_lang_Class::array_klass_offset());\n+    if (array_klass != nullptr && !Metaspace::klass_is_live(array_klass, true, &hint)) {\n+      printf_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                     file, line, \"Mirrored array klass \" PTR_FORMAT \": invalid klass pointer or dead\/invalid Klass (hint: %u)\",\n+                     p2i(array_klass), (unsigned)hint);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":33,"deletions":17,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -51,0 +51,8 @@\n+  static void vprintf_failure(SafeLevel level, oop obj, void *interior_loc, oop loc,\n+                              const char *phase, const char *file, int line, const char *fmt,\n+                              va_list args) ATTRIBUTE_PRINTF(8, 0);\n+\n+  static void printf_failure(SafeLevel level, oop obj, void *interior_loc, oop loc,\n+                              const char *phase, const char *file, int line, const char *fmt, ...)\n+                              ATTRIBUTE_PRINTF(8, 9);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -114,0 +114,9 @@\n+  void check_v(ShenandoahAsserts::SafeLevel level, oop obj, bool test, const char* fmt, ...) ATTRIBUTE_PRINTF(5, 6) {\n+    if (!test) {\n+      va_list args;\n+      va_start(args, fmt);\n+      ShenandoahAsserts::vprintf_failure(level, obj, _interior_loc, _loc, _phase, __FILE__, __LINE__, fmt, args);\n+      va_end(args);\n+    }\n+  }\n+\n@@ -144,0 +153,2 @@\n+    Metaspace::FailureHint hint = Metaspace::FailureHint::unknown;\n+\n@@ -164,0 +175,3 @@\n+    check_v(ShenandoahAsserts::_safe_unknown, obj, Metaspace::klass_is_live(obj_klass, true, &hint),\n+            \"Object klass (\" PTR_FORMAT \"): invalid klass pointer or dead\/invalid Klass (hint: %u)\", p2i(obj_klass), (unsigned)hint);\n+\n@@ -225,2 +239,4 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, Metaspace::contains(fwd_klass),\n-             \"Forwardee klass pointer must go to metaspace\");\n+      check_v(ShenandoahAsserts::_safe_oop, obj, Metaspace::klass_is_live(fwd_klass, true, &hint),\n+             \"Forwardee klass pointer (\" PTR_FORMAT \"): invalid klass pointer or dead\/invalid Klass (hint: %u)\",\n+             p2i(fwd_klass), (unsigned)hint);\n+\n@@ -258,9 +274,10 @@\n-      const Metadata* klass = fwd->metadata_field(java_lang_Class::klass_offset());\n-      check(ShenandoahAsserts::_safe_oop, obj,\n-            klass == nullptr || Metaspace::contains(klass),\n-            \"Mirrored instance class should point to Metaspace\");\n-\n-      const Metadata* array_klass = obj->metadata_field(java_lang_Class::array_klass_offset());\n-      check(ShenandoahAsserts::_safe_oop, obj,\n-            array_klass == nullptr || Metaspace::contains(array_klass),\n-            \"Mirrored array class should point to Metaspace\");\n+      const Klass* const klass = (const Klass*) fwd->metadata_field(java_lang_Class::klass_offset());\n+      check_v(ShenandoahAsserts::_safe_oop, obj,\n+              klass == nullptr || Metaspace::klass_is_live(klass, false \/* possibly not encodable *\/, &hint),\n+             \"Instance class mirror (\" PTR_FORMAT \"): invalid klass pointer or dead\/invalid Klass (hint: %u)\",\n+             p2i(obj_klass), (unsigned)hint);\n+      const Klass* const array_klass = (const Klass*) fwd->metadata_field(java_lang_Class::array_klass_offset());\n+      check_v(ShenandoahAsserts::_safe_oop, obj,\n+            array_klass == nullptr || Metaspace::klass_is_live(array_klass, true, &hint),\n+            \"Array class mirror (\" PTR_FORMAT \"): invalid klass pointer or dead\/invalid Klass (hint: %u)\",\n+            p2i(array_klass), (unsigned)hint);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"memory\/metaspace\/metaspaceZapper.hpp\"\n@@ -56,0 +57,2 @@\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/metadata.hpp\"\n@@ -1047,0 +1050,55 @@\n+\n+bool Metaspace::metadata_is_live(const Metadata* md, FailureHint* hint) {\n+  if (!contains(md)) {\n+    (*hint) = FailureHint::outside;\n+    return false;\n+  }\n+#ifdef ASSERT\n+  if (!is_aligned(md, metaspace::AllocationAlignmentByteSize)) {\n+    (*hint) = FailureHint::inside_but_misaligned;\n+    return false;\n+  }\n+  unsigned token;\n+  if (!md->get_metadata_token_safely(&token)) {\n+    (*hint) = FailureHint::inside_but_unreadable;\n+    return false;\n+  }\n+  if ((token & Metadata::common_prefix) != Metadata::common_prefix) {\n+    if (token == metaspace::Zapper::zap_pattern_chunk) {\n+      (*hint) = FailureHint::inside_but_dead_chunk;\n+    } else if (token == metaspace::Zapper::zap_pattern_block) {\n+      (*hint) = FailureHint::inside_but_dead_block;\n+    } else {\n+      (*hint) = FailureHint::inside_but_invalid_token;\n+    }\n+    return false;\n+  }\n+#endif\n+  return true;\n+}\n+\n+bool Metaspace::klass_is_live(const Klass* k, bool must_have_narrow_klass_id) {\n+  FailureHint ignored = Metaspace::FailureHint::unknown;\n+  return klass_is_live(k, must_have_narrow_klass_id, &ignored);\n+}\n+\n+bool Metaspace::klass_is_live(const Klass* k, bool must_have_narrow_klass_id, FailureHint* hint) {\n+  if (!metadata_is_live(k, hint)) {\n+    return false;\n+  }\n+#ifdef ASSERT\n+  \/\/ Some more specific tests for Klass\n+  if (UseCompressedClassPointers && must_have_narrow_klass_id &&\n+      !CompressedKlassPointers::is_encodable(k)) {\n+    (*hint) = FailureHint::nklass_not_encodable;\n+    return false;\n+  }\n+  const unsigned token = k->get_metadata_token();\n+  if (token != Metadata::array_klass_token &&\n+      token != Metadata::instance_klass_token) {\n+    (*hint) = FailureHint::inside_but_invalid_token;\n+    return false;\n+  }\n+#endif\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class Metadata;\n@@ -157,0 +158,44 @@\n+  \/\/ For metadata_is_live and klass_is_live\n+  enum class FailureHint {\n+    unknown = 0,\n+    \/\/ outside class space\/metaspace\n+    outside,\n+    \/\/ inside but does not meet alignment requirements (esp. for Klass)\n+    inside_but_misaligned,\n+    \/\/ inside but in the uncommitted part of metaspace\n+    \/\/ (potentially released after class unloading, or never committed in the first place)\n+    inside_but_unreadable,\n+    \/\/ inside, but marked as a dead chunk\n+    \/\/ (likely released after class unloading)\n+    inside_but_dead_chunk,\n+    \/\/ inside, but marked as a dead block\n+    \/\/ (possibly prematurely returned block, e.g., after class redefinition)\n+    inside_but_dead_block,\n+    \/\/ inside, but the token is invalid (overwriter, maybe?)\n+    inside_but_invalid_token,\n+    \/\/ a klass needs to be encodable but is not (either outside of encoding range,\n+    \/\/ so, not in class space nor in CDS archive range) or misaligned\n+    nklass_not_encodable\n+  };\n+\n+  \/\/ xxx_is_live functions returns true if the pointer given points to\n+  \/\/ valid metadata. In release builds, it is equivalent to Metaspace::contains. In debug\n+  \/\/ builds, it checks that:\n+  \/\/ - the specified metadata is inside class-space or metaspace in committed, readable memory\n+  \/\/ - not marked as dead space (i.e., not returned prematurely via Metaspace::deallocate)\n+  \/\/ - correctly aligned for the type (esp. Klass)\n+  \/\/ - Metadata token is valid specific to this type\n+  \/\/ Note: Uses SafeFetch, so it's fine to use it on questionable pointers.\n+\n+  \/\/ Checks if an assumed klass location points to live metaspace (including Klass). Optional hint\n+  \/\/ argument returns failure details.\n+  static bool metadata_is_live(const Metadata* md, FailureHint* hint);\n+\n+  \/\/ Checks if an assumed klass location points to a live klass.\n+  \/\/ Set \"must_have_narrow_klass_id\" to true if you know the klass should be encodable by narrow Klass,\n+  \/\/ e.g., if you grabbed the Klass* from an oop header. Set to false if you don't know (if it could\n+  \/\/ be abstract or interface, which don't have a narrow Klass).\n+  \/\/ Optional hint argument returns failure details.\n+  static bool klass_is_live(const Klass* k, bool must_have_narrow_klass_id, FailureHint* hint);\n+  static bool klass_is_live(const Klass* k, bool must_have_narrow_klass_id);\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"memory\/metaspace\/metaspaceZapper.hpp\"\n@@ -79,0 +80,2 @@\n+    MetaWord* base() { return (MetaWord*) this; }\n+    const MetaWord* base() const { return (MetaWord*) this; }\n@@ -96,0 +99,3 @@\n+  \/\/ for tests\n+  static constexpr size_t header_wordsize = sizeof(Block) \/ BytesPerWord;\n+\n@@ -126,2 +132,1 @@\n-  static const uintptr_t canary = 0xFFEEFFEE;\n-  static void write_canary(MetaWord* p, size_t word_size) {\n+  static void zap_block(Block* b, size_t word_size) {\n@@ -129,1 +134,1 @@\n-      ((uintptr_t*)p)[word_size - 1] = canary;\n+      Zapper::zap_payload(b, word_size, Zapper::zap_pattern_block);\n@@ -132,3 +137,4 @@\n-  static bool check_canary(const Block* b, size_t word_size) {\n-    return word_size == 1 || \/\/ 1-word-sized blocks have no space for a canary\n-           ((const uintptr_t*)b)[word_size - 1] == canary;\n+  static bool check_block_zap(const Block* b, size_t word_size) {\n+    return word_size <= header_wordsize || \/\/ 1-word-sized blocks have no space for a canary\n+           ( Zapper::is_zapped_location(b->base() + header_wordsize) &&\n+             Zapper::is_zapped_location(b->base() + word_size - header_wordsize) );\n@@ -152,1 +158,0 @@\n-    DEBUG_ONLY(write_canary(p, word_size);)\n@@ -158,0 +163,1 @@\n+    DEBUG_ONLY(zap_block(new_head, word_size);)\n@@ -172,1 +178,1 @@\n-      assert(check_canary(b, real_word_size),\n+      assert(check_block_zap(b, real_word_size),\n@@ -197,1 +203,1 @@\n-        assert(check_canary(b, s), \"\");\n+        assert(check_block_zap(b, s), \"\");\n","filename":"src\/hotspot\/share\/memory\/metaspace\/binList.hpp","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  \": canary \" INTPTR_FORMAT \\\n+  \": canary \" UINTX_FORMAT_X_0 \\\n@@ -50,1 +50,1 @@\n-  (n)->_canary, \\\n+  (uintptr_t)((n)->_canary), \\\n@@ -93,1 +93,1 @@\n-  if (n->_canary != Node::_canary_value) {\n+  if (!Zapper::is_zapped_location(&(n->_canary))) {\n@@ -139,0 +139,7 @@\n+      \/\/ Check if part of the payload was overwritten (the canary was checked\n+      \/\/ before in verify_node_pointer)\n+      if (!Zapper::is_zapped_location(n->end() - 1)) {\n+        os::print_hex_dump(tty, (address)n, (address)n + sizeof(Node), 1);\n+        tree_assert(false, \"Invalid node: @\" PTR_FORMAT \" node end overwritten?\", p2i(n));\n+      }\n+\n@@ -182,4 +189,0 @@\n-void BlockTree::zap_block(MetaBlock bl) {\n-  memset(bl.base(), 0xF3, bl.word_size() * sizeof(MetaWord));\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"memory\/metaspace\/metaspaceZapper.hpp\"\n@@ -80,8 +81,3 @@\n-    static const intptr_t _canary_value =\n-        NOT_LP64(0x4e4f4445) LP64_ONLY(0x4e4f44454e4f4445ULL); \/\/ \"NODE\" resp \"NODENODE\"\n-\n-    \/\/ Note: we afford us the luxury of an always-there canary value.\n-    \/\/  The space for that is there (these nodes are only used to manage larger blocks).\n-    \/\/  It is initialized in debug and release, but only automatically tested\n-    \/\/  in debug.\n-    const intptr_t _canary;\n+    \/\/ A leading canary section that is zapped with the same metaspace zap pattern\n+    \/\/ as the rest of the payload following the header (and all of dead\/unsused metaspace).\n+    MetaWord _canary;\n@@ -103,0 +99,4 @@\n+    const MetaWord* base() const { return (MetaWord*) this; }\n+    MetaWord* base()             { return (MetaWord*) this; }\n+    const MetaWord* end() const  { return base() + _word_size; }\n+\n@@ -104,1 +104,1 @@\n-      _canary(_canary_value),\n+      _canary(0),\n@@ -113,0 +113,9 @@\n+    void zap() {\n+      \/\/ Zap first word of header and payload that follows\n+      Zapper::zap_location(&_canary, Zapper::zap_pattern_block);\n+      Zapper::zap_payload(this, _word_size, Zapper::zap_pattern_block);\n+    }\n+    bool check_zap() const {\n+      return Zapper::is_zapped_location(&_canary) &&\n+             Zapper::is_zapped_location(end() - 1);\n+    }\n@@ -114,3 +123,3 @@\n-      return _canary == _canary_value &&\n-        _word_size >= sizeof(Node) &&\n-        _word_size < chunklevel::MAX_CHUNK_WORD_SIZE;\n+      return _word_size > sizeof(Node) && \/\/ at least one word larger\n+             _word_size < chunklevel::MAX_CHUNK_WORD_SIZE \/\/ but not larger than a root chunk\n+             DEBUG_ONLY(&& check_zap());\n@@ -121,0 +130,2 @@\n+  STATIC_ASSERT(is_aligned(sizeof(Node), sizeof(MetaWord)));\n+\n@@ -131,3 +142,6 @@\n-  \/\/ Minimum word size a block has to be to be added to this structure (note ceil division).\n-  const static size_t MinWordSize =\n-      (sizeof(Node) + sizeof(MetaWord) - 1) \/ sizeof(MetaWord);\n+  \/\/ Public only for tests\n+  static constexpr size_t header_wordsize = sizeof(Node) \/ sizeof(MetaWord);\n+\n+  \/\/ Minimum word size a block has to be to be added to this structure\n+  \/\/ (Node size + at least one word; smaller blocks -> BinList)\n+  constexpr static size_t MinWordSize = header_wordsize + 1;\n@@ -338,1 +352,0 @@\n-  void zap_block(MetaBlock block);\n@@ -349,1 +362,0 @@\n-    DEBUG_ONLY(zap_block(block);)\n@@ -358,0 +370,1 @@\n+    DEBUG_ONLY(n->zap();)\n@@ -386,2 +399,0 @@\n-\n-      DEBUG_ONLY(zap_block(result);)\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.hpp","additions":30,"deletions":19,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+  DEBUG_ONLY(c->zap();)\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/metaspace\/metaspaceZapper.hpp\"\n@@ -186,0 +187,6 @@\n+\/\/ Zaps the chunk itself\n+void Metachunk::zap() {\n+  \/\/ Only committed portion, obviously\n+  Zapper::zap_memory(base(), committed_words(), Zapper::zap_pattern_chunk);\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metachunk.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -343,0 +343,1 @@\n+  \/\/ Zaps the header (this structure); Note: physically disjunct from the actual chunk!\n@@ -344,0 +345,2 @@\n+  \/\/ Zaps the chunk itself\n+  void zap();\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metachunk.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"memory\/metaspace\/metaspaceCommon.hpp\"\n+#include \"memory\/metaspace\/metaspaceZapper.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+namespace metaspace {\n+\n+\/\/ Pre C++17, we need to define static constexpr members\n+constexpr uintptr_t Zapper::zap_pattern_chunk;\n+constexpr uintptr_t Zapper::zap_pattern_block;\n+\n+} \/\/ namespace metaspace\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceZapper.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_METASPACE_METASPACEZAPPER_HPP\n+#define SHARE_MEMORY_METASPACE_METASPACEZAPPER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+namespace metaspace {\n+\n+class Zapper : public AllStatic {\n+public:\n+\n+  static constexpr uintptr_t zap_pattern_chunk = NOT_LP64(0xdead) LP64_ONLY(0xdeadccccdeadccccULL);\n+  static constexpr uintptr_t zap_pattern_block = NOT_LP64(0xdead) LP64_ONLY(0xdeadbbbbdeadbbbbULL);\n+\n+  static void zap_memory(MetaWord* start, size_t word_size, uintptr_t pattern) {\n+    for (size_t pos = 0; pos < word_size; pos ++) {\n+      zap_location(start + pos, pattern);\n+    }\n+  }\n+\n+  static void zap_location(MetaWord* p, uintptr_t pattern) { ((uintptr_t*)p)[0] = pattern; }\n+  static bool is_zapped_location(const MetaWord* p) { return ((uintptr_t*)p)[0] == zap_pattern_chunk || ((uintptr_t*)p)[0] == zap_pattern_block; }\n+\n+  \/\/ Given a header followed by a variable-sized payload with a total (including header) word_size,\n+  \/\/ zap the payload while leaving the header alone\n+  template <class HEADER>\n+  static void zap_payload(HEADER* p, size_t word_size, uintptr_t pattern) {\n+    const size_t start = align_up(sizeof(HEADER), sizeof(MetaWord)) \/ sizeof(MetaWord);\n+    for (size_t pos = start; pos < word_size; pos ++) {\n+      zap_location((MetaWord*)p + pos, pattern);\n+    }\n+  }\n+\n+};\n+\n+} \/\/ namespace metaspace\n+\n+#endif \/\/ SHARE_MEMORY_METASPACE_METASPACEZAPPER_HPP\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceZapper.hpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+  NOT_PRODUCT(set_metadata_token(array_klass_token);)\n@@ -105,0 +106,1 @@\n+  NOT_PRODUCT(set_metadata_token(array_klass_token);)\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,0 +260,4 @@\n+  static inline bool in_encoding_range(const void* addr) {\n+    return (address)addr >= _klass_range_start && (address)addr < _klass_range_end;\n+  }\n+\n@@ -271,2 +275,1 @@\n-    return (address)addr >= _klass_range_start && (address)addr < _klass_range_end &&\n-        is_aligned(addr, klass_alignment_in_bytes());\n+    return in_encoding_range(addr) && is_aligned(addr, klass_alignment_in_bytes());\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+  NOT_PRODUCT(set_metadata_token(instance_klass_token);)\n@@ -553,0 +554,1 @@\n+  NOT_PRODUCT(set_metadata_token(instance_klass_token);)\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1098,8 +1098,3 @@\n-  if (!is_aligned(k, sizeof(MetaWord))) return false;\n-  if ((size_t)k < os::min_page_size()) return false;\n-\n-  if (!os::is_readable_range(k, k + 1)) return false;\n-  if (!Metaspace::contains(k)) return false;\n-\n-  if (!Symbol::is_valid(k->name())) return false;\n-  return ClassLoaderDataGraph::is_valid(k->class_loader_data());\n+  return Metaspace::klass_is_live(k, false) &&\n+         Symbol::is_valid(k->name()) &&\n+         ClassLoaderDataGraph::is_valid(k->class_loader_data());\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/safefetch.hpp\"\n@@ -51,0 +52,15 @@\n+\n+#ifndef PRODUCT\n+\n+\/\/ Return token (read using SafeFetch). In case of a fault, returns Metadata::access_error.\n+bool Metadata::get_metadata_token_safely(unsigned* out) const {\n+  const int segfault = 0x3a0c3f2; \/\/ arbitrary random number\n+  unsigned result = SafeFetch32((int*)&_token, 0x3a0c3f2);\n+  if (result == segfault) {\n+    return false;\n+  }\n+  (*out) = result;\n+  return true;\n+}\n+\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/oops\/metadata.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, IBM Corporation. All rights reserved.\n@@ -34,5 +35,0 @@\n-  \/\/ Debugging hook to check that the metadata has not been deleted.\n-  NOT_PRODUCT(int _valid;)\n- public:\n-  NOT_PRODUCT(Metadata() : _valid(0) {})\n-  NOT_PRODUCT(bool is_valid() const { return _valid == 0; })\n@@ -40,0 +36,21 @@\n+#ifndef PRODUCT\n+  uint32_t _token;\n+\n+protected:\n+  Metadata() : _token(common_prefix) {}\n+  void set_metadata_token(uint32_t v) { _token = v; }\n+\n+public:\n+  static constexpr uint32_t common_prefix        = 0x3E7A'0000;\n+  static constexpr uint32_t common_prefix_mask   = 0xFFFF'0000;\n+  static constexpr uint32_t instance_klass_token = 0x3E7A'0101;\n+  static constexpr uint32_t array_klass_token    = 0x3E7A'0102;\n+\n+  unsigned get_metadata_token() const { return _token; }\n+  bool is_valid() const { return (get_metadata_token() & common_prefix_mask) == common_prefix; }\n+\n+  \/\/ Return token via SafeFetch. Returns true if token could be read, false if not.\n+  bool get_metadata_token_safely(unsigned* out) const;\n+#endif \/\/ !PRODUCT\n+\n+public:\n@@ -88,0 +105,2 @@\n+#undef BUILD32\n+\n","filename":"src\/hotspot\/share\/oops\/metadata.hpp","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/metaspace\/metaspaceZapper.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -98,0 +100,11 @@\n+\/\/ using metaspace zapper\n+\n+#ifdef ASSERT\n+\/\/ Helper function checks if region x is zapped\n+void check_metaspace_zap(const MetaWord* start, size_t size) {\n+  size_t interval = MAX2((size_t)1, size \/ 256);\n+  for (const MetaWord* p = start; p < start + size; p += interval) {\n+    ASSERT_TRUE(metaspace::Zapper::is_zapped_location(p));\n+  }\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestCommon.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -219,0 +219,3 @@\n+\/\/ Check an area for being zapped with the metaspace zap pattern\n+DEBUG_ONLY(void check_metaspace_zap(const MetaWord* start, size_t size);)\n+\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestCommon.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,7 @@\n+#ifdef ASSERT\n+template <class BINLISTTYPE>\n+void check_block_zap(const MetaWord* p, size_t size) {\n+  check_metaspace_zap(p + BINLISTTYPE::header_wordsize, size - BINLISTTYPE::header_wordsize);\n+}\n+#endif\n+\n@@ -92,0 +99,1 @@\n+    DEBUG_ONLY(check_block_zap<BINLISTTYPE>(p, real_size);)\n@@ -117,0 +125,1 @@\n+          DEBUG_ONLY(check_block_zap<BINLISTTYPE>(p, real_size);)\n@@ -128,0 +137,1 @@\n+          DEBUG_ONLY(check_block_zap<BINLISTTYPE>(p, real_size);)\n","filename":"test\/hotspot\/gtest\/metaspace\/test_binlist.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+using metaspace::Zapper;\n@@ -68,0 +69,6 @@\n+#ifdef ASSERT\n+void check_node_zap(const MetaWord* p, size_t size) {\n+  check_metaspace_zap(p + BlockTree::header_wordsize, size - BlockTree::header_wordsize);\n+}\n+#endif\n+\n@@ -77,1 +84,1 @@\n-  ASSERT_LE(BlockTree::MinWordSize, (size_t)6); \/\/ Sanity check. Adjust if Node is changed.\n+  ASSERT_LE(BlockTree::MinWordSize, (size_t)7); \/\/ Sanity check. Adjust if Node is changed.\n@@ -97,0 +104,1 @@\n+    DEBUG_ONLY(memset(arr, 0, sizes[i]);)\n@@ -99,0 +107,1 @@\n+    DEBUG_ONLY(check_node_zap(arr, sizes[i]);)\n@@ -105,0 +114,1 @@\n+    DEBUG_ONLY(check_node_zap(p, sizes[i]);)\n@@ -141,0 +151,1 @@\n+    DEBUG_ONLY(check_node_zap(p, real_size);)\n","filename":"test\/hotspot\/gtest\/metaspace\/test_blocktree.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -430,0 +430,17 @@\n+#ifdef ASSERT\n+\/\/ Test ChunkManager::get_chunk\n+TEST_VM(metaspace, chunk_zap) {\n+  ChunkGtestContext context;\n+  Metachunk* c = nullptr;\n+  RandSizeGenerator rand(1, K);\n+  for (chunklevel_t l = LOWEST_CHUNK_LEVEL; l < HIGHEST_CHUNK_LEVEL; l++) {\n+    context.alloc_chunk_expect_success(&c, HIGHEST_CHUNK_LEVEL);\n+    for (size_t s = 0; s < c->word_size(); s += rand.get()) {\n+      c->ensure_committed(s);\n+      c->zap();\n+      check_metaspace_zap(c->base(), c->committed_words());\n+    }\n+    context.return_chunk(c);\n+  }\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metachunk.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}