{"files":[{"patch":"@@ -132,1 +132,1 @@\n-     * {@code sp} is encoded in ISO-8859-1. There each {@code byte} corresponds\n+     * {@code da} is encoded in ISO-8859-1. There each {@code byte} corresponds\n@@ -137,1 +137,1 @@\n-     * @param sp the index of the <em>byte (not character!)<\/em> from the source array to start reading from\n+     * @param sp the index of the <em>character (not byte!)<\/em> from the source array to start reading from\n@@ -143,2 +143,0 @@\n-     * @throws ArrayIndexOutOfBoundsException if any of the provided sub-ranges are\n-     *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n@@ -150,2 +148,10 @@\n-        Preconditions.checkFromIndexSize(sp, len << 1, sa.length, Preconditions.AIOOBE_FORMATTER);\n-        Preconditions.checkFromIndexSize(dp, len, da.length, Preconditions.AIOOBE_FORMATTER);\n+        if ((sp | dp | len) < 0 ||\n+                \/\/ Halving the length of `sa` to obtain the number of characters:\n+                len > (sa.length >> 1) - sp ||\n+                dp >= da.length) {\n+            \/\/ Not checking the `len < da.length - dp` invariant, since \"as many\n+            \/\/ codepoints as possible\" contract still holds with a `da` of\n+            \/\/ insufficient capacity, and the compiler intrinsic matches this\n+            \/\/ behavior too.\n+            return 0;\n+        }\n@@ -180,2 +186,0 @@\n-     * @throws ArrayIndexOutOfBoundsException if any of the provided sub-ranges are\n-     *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n@@ -187,2 +191,7 @@\n-        Preconditions.checkFromIndexSize(sp, len, sa.length, Preconditions.AIOOBE_FORMATTER);\n-        Preconditions.checkFromIndexSize(dp, len, da.length, Preconditions.AIOOBE_FORMATTER);\n+        if ((sp | dp | len) < 0 || len > sa.length - sp || dp >= da.length) {\n+            \/\/ Not checking the `len < da.length - dp` invariant, since \"as many\n+            \/\/ codepoints as possible\" contract still holds with a `da` of\n+            \/\/ insufficient capacity, and the compiler intrinsic matches this\n+            \/\/ behavior too.\n+            return 0;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.function.BiFunction;\n@@ -39,1 +38,0 @@\n-import jdk.internal.util.Preconditions;\n@@ -158,2 +156,0 @@\n-         * @throws ArrayIndexOutOfBoundsException if any of the provided sub-ranges are\n-         *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n@@ -165,2 +161,7 @@\n-            Preconditions.checkFromIndexSize(sp, len, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkFromIndexSize(dp, len, da.length, Preconditions.AIOOBE_FORMATTER);\n+            if ((sp | dp | len) < 0 || len > sa.length - sp || dp >= da.length) {\n+                \/\/ Not checking the `len < da.length - dp` invariant, since \"as many\n+                \/\/ codepoints as possible\" contract still holds with a `da` of\n+                \/\/ insufficient capacity, and the compiler intrinsic matches this\n+                \/\/ behavior too.\n+                return 0;\n+            }\n@@ -201,1 +202,1 @@\n-                int ret = len <= 0 ? 0 : encodeISOArray(sa, sp, da, dp, len);\n+                int ret = encodeISOArray(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ISO_8859_1.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @requires vm.debug == true & vm.flavor == \"server\"\n+ * @requires vm.debug == true & vm.flavor == \"server\" & !vm.graal.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestVerifyIntrinsicChecks.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}