{"files":[{"patch":"@@ -6424,4 +6424,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2828,4 +2828,8 @@\n-\/\/ - sun\/nio\/cs\/ISO_8859_1$Encoder.implEncodeISOArray\n-\/\/     return the number of characters copied.\n-\/\/ - java\/lang\/StringUTF16.compress\n-\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n+\/\/ - sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes byte[] (containing UTF-16) to byte[] in ISO-8859-1\n+\/\/\n+\/\/ - java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n+\/\/   Encodes char[] to byte[] in ASCII\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6014,26 +6014,40 @@\n-\/\/ encode char[] to byte[] in ISO_8859_1 or ASCII\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeISOArray(byte[] sa, int sp,\n-   \/\/byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = StringUTF16.getChar(sa, sp++);\n-   \/\/    if (c > '\\u00FF')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n-   \/\/\n-   \/\/@IntrinsicCandidate\n-   \/\/private static int implEncodeAsciiArray(char[] sa, int sp,\n-   \/\/    byte[] da, int dp, int len) {\n-   \/\/  int i = 0;\n-   \/\/  for (; i < len; i++) {\n-   \/\/    char c = sa[sp++];\n-   \/\/    if (c >= '\\u0080')\n-   \/\/      break;\n-   \/\/    da[dp++] = (byte)c;\n-   \/\/  }\n-   \/\/  return i;\n-   \/\/}\n+\/\/ Encode given char[]\/byte[] to byte[] in ISO_8859_1 or ASCII\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/     int i = 0;\n+\/\/     for (; i < len; i++) {\n+\/\/         char c = sa[sp++];\n+\/\/         if (c > '\\u00FF')\n+\/\/             break;\n+\/\/         da[dp++] = (byte) c;\n+\/\/     }\n+\/\/     return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeISOArray0(\n+\/\/         byte[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = StringUTF16.getChar(sa, sp++);\n+\/\/     if (c > '\\u00FF')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n+\/\/\n+\/\/ @IntrinsicCandidate\n+\/\/ int java.lang.StringCoding.encodeAsciiArray0(\n+\/\/         char[] sa, int sp, byte[] da, int dp, int len) {\n+\/\/   int i = 0;\n+\/\/   for (; i < len; i++) {\n+\/\/     char c = sa[sp++];\n+\/\/     if (c >= '\\u0080')\n+\/\/       break;\n+\/\/     da[dp++] = (byte) c;\n+\/\/   }\n+\/\/   return i;\n+\/\/ }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":40,"deletions":26,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n+   do_name(     countPositives_name,                       \"countPositives0\")                                           \\\n@@ -423,1 +423,1 @@\n-   do_name(     encodeISOArray_name,                             \"implEncodeISOArray\")                                  \\\n+   do_name(     encodeISOArray_name,                             \"encodeISOArray0\")                                     \\\n@@ -429,1 +429,1 @@\n-   do_name(     encodeAsciiArray_name,                           \"implEncodeAsciiArray\")                                \\\n+   do_name(     encodeAsciiArray_name,                           \"encodeAsciiArray0\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -665,0 +665,3 @@\n+  develop(bool, VerifyIntrinsicChecks, false,                               \\\n+          \"Verify in intrinsic that Java level checks work as expected\")    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -941,1 +941,5 @@\n-void LibraryCallKit::generate_string_range_check(Node* array, Node* offset, Node* count, bool char_count) {\n+void LibraryCallKit::generate_string_range_check(Node* array,\n+                                                 Node* offset,\n+                                                 Node* count,\n+                                                 bool char_count,\n+                                                 bool halt) {\n@@ -959,4 +963,11 @@\n-    PreserveJVMState pjvms(this);\n-    set_control(_gvn.transform(bailout));\n-    uncommon_trap(Deoptimization::Reason_intrinsic,\n-                  Deoptimization::Action_maybe_recompile);\n+    if (halt) {\n+      Node* frame = _gvn.transform(new ParmNode(C->start(), TypeFunc::FramePtr));\n+      Node* bailoutN = _gvn.transform(bailout);\n+      Node* halt = _gvn.transform(new HaltNode(bailoutN, frame, \"unexpected guard failure in intrinsic\"));\n+      C->root()->add_req(halt);\n+    } else {\n+      PreserveJVMState pjvms(this);\n+      set_control(_gvn.transform(bailout));\n+      uncommon_trap(Deoptimization::Reason_intrinsic,\n+                    Deoptimization::Action_maybe_recompile);\n+    }\n@@ -1120,0 +1131,1 @@\n+\/\/ int java.lang.StringCoding#countPositives0(byte[] ba, int off, int len)\n@@ -1131,6 +1143,6 @@\n-  ba = must_be_not_null(ba, true);\n-\n-  \/\/ Range checks\n-  generate_string_range_check(ba, offset, len, false);\n-  if (stopped()) {\n-    return true;\n+  if (VerifyIntrinsicChecks) {\n+    ba = must_be_not_null(ba, true);\n+    generate_string_range_check(ba, offset, len, false, true);\n+    if (stopped()) {\n+      return true;\n+    }\n@@ -1138,0 +1150,1 @@\n+\n@@ -6110,0 +6123,3 @@\n+\/\/ int sun.nio.cs.ISO_8859_1.Encoder#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len)\n+\/\/ int java.lang.StringCoding#encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len)\n@@ -6120,2 +6136,8 @@\n-  src = must_be_not_null(src, true);\n-  dst = must_be_not_null(dst, true);\n+  \/\/ Cast source & target arrays to not-null\n+  if (VerifyIntrinsicChecks) {\n+    src = must_be_not_null(src, true);\n+    dst = must_be_not_null(dst, true);\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n@@ -6138,0 +6160,9 @@\n+  \/\/ Check source & target bounds\n+  if (VerifyIntrinsicChecks) {\n+    generate_string_range_check(src, src_offset, length, src_elem == T_BYTE, true);\n+    generate_string_range_check(dst, dst_offset, length, false, true);\n+    if (stopped()) {\n+      return true;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":44,"deletions":13,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -143,1 +143,2 @@\n-                                    Node* length, bool char_count);\n+                                    Node* length, bool char_count,\n+                                    bool halt = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1022,1 +1022,1 @@\n-            int ret = StringCoding.implEncodeISOArray(val, sp, dst, dp, len);\n+            int ret = StringCoding.encodeISOArray(val, sp, dst, dp, len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.util.Preconditions;\n@@ -31,0 +32,6 @@\n+import java.util.function.BiFunction;\n+\n+import static java.util.Objects.requireNonNull;\n+import static jdk.internal.util.Preconditions.AIOOBE_FORMATTER;\n+import static jdk.internal.util.Preconditions.checkFromIndexSize;\n+\n@@ -41,1 +48,1 @@\n-    public static int countNonZeroAscii(String s) {\n+    static int countNonZeroAscii(String s) {\n@@ -53,1 +60,1 @@\n-    public static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n+    private static int countNonZeroAsciiLatin1(byte[] ba, int off, int len) {\n@@ -66,1 +73,1 @@\n-    public static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n+    private static int countNonZeroAsciiUTF16(byte[] ba, int off, int strlen) {\n@@ -77,1 +84,1 @@\n-    public static boolean hasNegatives(byte[] ba, int off, int len) {\n+    static boolean hasNegatives(byte[] ba, int off, int len) {\n@@ -88,0 +95,7 @@\n+     *\n+     * @param ba a byte array\n+     * @param off the index of the first byte to start reading from\n+     * @param len the total number of bytes to read\n+     * @throws NullPointerException if {@code ba} is null\n+     * @throws ArrayIndexOutOfBoundsException if the provided sub-range is\n+     *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n@@ -89,0 +103,5 @@\n+    static int countPositives(byte[] ba, int off, int len) {\n+        checkFromIndexSize(off, len, requireNonNull(ba, \"ba\").length, AIOOBE_FORMATTER);\n+        return countPositives0(ba, off, len);\n+    }\n+\n@@ -90,1 +109,1 @@\n-    public static int countPositives(byte[] ba, int off, int len) {\n+    private static int countPositives0(byte[] ba, int off, int len) {\n@@ -100,0 +119,36 @@\n+    \/**\n+     * Encodes as many ISO-8859-1 codepoints as possible from the source byte\n+     * array containing characters encoded in UTF-16, into the destination byte\n+     * array, assuming that the encoding is ISO-8859-1 compatible.\n+     *\n+     * @apiNote\n+     *\n+     * {@code sa} denotes the {@code byte[]} backing a {@link String}. When\n+     * {@linkplain String#COMPACT_STRINGS compact strings} are disabled, a\n+     * {@code char} is always represented by 2 bytes, i.e.,\n+     * encoded in UTF-16. When enabled, if the content is ISO-8859-1, a\n+     * {@code char} is represented by 1 byte; otherwise again by 2 bytes.\n+     * <p>\n+     * This method assumes that {@code sa} is encoded in UTF-16, and hence,\n+     * each {@code char} maps to 2 bytes.\n+     * <\/p><p>\n+     * {@code sp} is encoded in ISO-8859-1. There each {@code byte} corresponds\n+     * to a {@code char}.\n+     * <\/p>\n+     *\n+     * @param sa the source byte array containing characters encoded in UTF-16\n+     * @param sp the index of the <em>byte (not character!)<\/em> from the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the total number of <em>characters (not bytes!)<\/em> to be encoded\n+     * @return the total number of <em>characters (not bytes!)<\/em> successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     * @throws ArrayIndexOutOfBoundsException if any of the provided sub-ranges are\n+     *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n+     *\/\n+    static int encodeISOArray(byte[] sa, int sp, byte[] da, int dp, int len) {\n+        checkFromIndexSize(sp, len << 1, requireNonNull(sa, \"sa\").length, AIOOBE_FORMATTER);\n+        checkFromIndexSize(dp, len, requireNonNull(da, \"da\").length, AIOOBE_FORMATTER);\n+        return encodeISOArray0(sa, sp, da, dp, len);\n+    }\n+\n@@ -101,2 +156,1 @@\n-    public static int implEncodeISOArray(byte[] sa, int sp,\n-                                         byte[] da, int dp, int len) {\n+    private static int encodeISOArray0(byte[] sa, int sp, byte[] da, int dp, int len) {\n@@ -108,1 +162,1 @@\n-            da[dp++] = (byte)c;\n+            da[dp++] = (byte) c;\n@@ -113,0 +167,21 @@\n+    \/**\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n+     *\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the total number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     * @throws ArrayIndexOutOfBoundsException if any of the provided sub-ranges are\n+     *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n+     *\/\n+    static int encodeAsciiArray(char[] sa, int sp, byte[] da, int dp, int len) {\n+        checkFromIndexSize(sp, len, requireNonNull(sa, \"sa\").length, AIOOBE_FORMATTER);\n+        checkFromIndexSize(dp, len, requireNonNull(da, \"da\").length, AIOOBE_FORMATTER);\n+        return encodeAsciiArray0(sa, sp, da, dp, len);\n+    }\n+\n@@ -114,3 +189,1 @@\n-    public static int implEncodeAsciiArray(char[] sa, int sp,\n-                                           byte[] da, int dp, int len)\n-    {\n+    private static int encodeAsciiArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n@@ -122,1 +195,1 @@\n-            da[dp++] = (byte)c;\n+            da[dp++] = (byte) c;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":86,"deletions":13,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import java.util.concurrent.ScheduledExecutorService;\n@@ -2156,2 +2155,2 @@\n-            public int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n-                return StringCoding.implEncodeAsciiArray(src, srcOff, dst, dstOff, len);\n+            public int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len) {\n+                return StringCoding.encodeAsciiArray(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.function.BiFunction;\n@@ -420,5 +421,3 @@\n-     * Encodes as many ASCII codepoints as possible from the source array into\n-     * the destination byte array, assuming that the encoding is ASCII\n-     * compatible.\n-     * <p>\n-     * <b>WARNING: This method does not perform any bound checks.<\/b>\n+     * Encodes as many ASCII codepoints as possible from the source\n+     * character array into the destination byte array, assuming that\n+     * the encoding is ASCII compatible.\n@@ -426,3 +425,11 @@\n-     * @return the number of bytes successfully encoded, or 0 if none\n-     *\/\n-    int uncheckedEncodeASCII(char[] src, int srcOff, byte[] dst, int dstOff, int len);\n+     * @param sa the source character array\n+     * @param sp the index of the source array to start reading from\n+     * @param da the target byte array\n+     * @param dp the index of the target array to start writing to\n+     * @param len the total number of characters to be encoded\n+     * @return the total number of characters successfully encoded\n+     * @throws NullPointerException if any of the provided arrays is null\n+     * @throws ArrayIndexOutOfBoundsException if any of the provided sub-ranges are\n+     *         {@linkplain jdk.internal.util.Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n+     *\/\n+    int encodeASCII(char[] sa, int sp, byte[] da, int dp, int len);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n@@ -554,1 +554,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(len, da.length));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/CESU_8.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n@@ -689,1 +689,1 @@\n-                int n = JLA.uncheckedEncodeASCII(src, sp, dst, dp, len);\n+                int n = JLA.encodeASCII(src, sp, dst, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import java.util.Objects;\n+import java.util.function.BiFunction;\n@@ -41,0 +41,4 @@\n+import static java.util.Objects.requireNonNull;\n+import static jdk.internal.util.Preconditions.AIOOBE_FORMATTER;\n+import static jdk.internal.util.Preconditions.checkFromIndexSize;\n+\n@@ -145,8 +149,19 @@\n-        \/\/ Method possible replaced with a compiler intrinsic.\n-        private static int encodeISOArray(char[] sa, int sp,\n-                                          byte[] da, int dp, int len) {\n-            if (len <= 0) {\n-                return 0;\n-            }\n-            encodeISOArrayCheck(sa, sp, da, dp, len);\n-            return implEncodeISOArray(sa, sp, da, dp, len);\n+        \/**\n+         * Encodes as many ISO-8859-1 codepoints as possible from the source\n+         * character array into the destination byte array, assuming that\n+         * the encoding is ISO-8859-1 compatible.\n+         *\n+         * @param sa the source character array\n+         * @param sp the index of the source array to start reading from\n+         * @param da the target byte array\n+         * @param dp the index of the target array to start writing to\n+         * @param len the total number of characters to be encoded\n+         * @return the total number of characters successfully encoded\n+         * @throws NullPointerException if any of the provided arrays is null\n+         * @throws ArrayIndexOutOfBoundsException if any of the provided sub-ranges are\n+         *         {@linkplain Preconditions#checkFromIndexSize(int, int, int, BiFunction) out of bounds}\n+         *\/\n+        private static int encodeISOArray(char[] sa, int sp, byte[] da, int dp, int len) {\n+            checkFromIndexSize(sp, len, requireNonNull(sa, \"sa\").length, AIOOBE_FORMATTER);\n+            checkFromIndexSize(dp, len, requireNonNull(da, \"da\").length, AIOOBE_FORMATTER);\n+            return encodeISOArray0(sa, sp, da, dp, len);\n@@ -156,3 +171,1 @@\n-        private static int implEncodeISOArray(char[] sa, int sp,\n-                                              byte[] da, int dp, int len)\n-        {\n+        private static int encodeISOArray0(char[] sa, int sp, byte[] da, int dp, int len) {\n@@ -164,1 +177,1 @@\n-                da[dp++] = (byte)c;\n+                da[dp++] = (byte) c;\n@@ -169,11 +182,0 @@\n-        private static void encodeISOArrayCheck(char[] sa, int sp,\n-                                                byte[] da, int dp, int len) {\n-            Objects.requireNonNull(sa);\n-            Objects.requireNonNull(da);\n-            Preconditions.checkIndex(sp, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkIndex(dp, da.length, Preconditions.AIOOBE_FORMATTER);\n-\n-            Preconditions.checkIndex(sp + len - 1, sa.length, Preconditions.AIOOBE_FORMATTER);\n-            Preconditions.checkIndex(dp + len - 1, da.length, Preconditions.AIOOBE_FORMATTER);\n-        }\n-\n@@ -199,1 +201,1 @@\n-                int ret = encodeISOArray(sa, sp, da, dp, len);\n+                int ret = len <= 0 ? 0 : encodeISOArray(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ISO_8859_1.java","additions":27,"deletions":25,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-                int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, len);\n+                int n = JLA.encodeASCII(sa, sp, da, dp, len);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/US_ASCII.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-            int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n+            int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(sl - sp, dl - dp));\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/UTF_8.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-                    int n = JLA.uncheckedEncodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n+                    int n = JLA.encodeASCII(sa, sp, da, dp, Math.min(dl - dp, sl - sp));\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/EUC_JP.java.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}