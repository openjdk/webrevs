{"files":[{"patch":"@@ -38,13 +38,17 @@\n-class CloseScopedMemoryFindOopClosure : public OopClosure {\n-  oop _deopt;\n-  bool _found;\n-\n-public:\n-  CloseScopedMemoryFindOopClosure(jobject deopt) :\n-      _deopt(JNIHandles::resolve(deopt)),\n-      _found(false) {}\n-\n-  template <typename T>\n-  void do_oop_work(T* p) {\n-    if (_found) {\n-      return;\n+static bool is_in_scoped_access(JavaThread* jt, oop session) {\n+  const int max_critical_stack_depth = 10;\n+  int depth = 0;\n+  for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n+    Method* m = stream.method();\n+    if (m->is_scoped()) {\n+      StackValueCollection* locals = stream.asJavaVFrame()->locals();\n+      for (int i = 0; i < locals->size(); i++) {\n+        StackValue* var = locals->at(i);\n+        if (var->type() == T_OBJECT) {\n+          if (var->get_obj() == session) {\n+            assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n+            return true;\n+          }\n+        }\n+      }\n+      break;\n@@ -52,2 +56,4 @@\n-    if (RawAccess<>::oop_load(p) == _deopt) {\n-      _found = true;\n+    depth++;\n+#ifndef ASSERT\n+    if (depth >= max_critical_stack_depth) {\n+      break;\n@@ -55,0 +61,1 @@\n+#endif\n@@ -57,3 +64,5 @@\n-  virtual void do_oop(oop* p) {\n-    do_oop_work(p);\n-  }\n+  return false;\n+}\n+\n+class ScopedAsyncExceptionHandshake : public AsyncExceptionHandshake {\n+  OopHandle _session;\n@@ -61,2 +70,7 @@\n-  virtual void do_oop(narrowOop* p) {\n-    do_oop_work(p);\n+public:\n+  ScopedAsyncExceptionHandshake(OopHandle& session, OopHandle& error)\n+    : AsyncExceptionHandshake(error),\n+      _session(session) {}\n+\n+  ~ScopedAsyncExceptionHandshake() {\n+    _session.release(Universe::vm_global());\n@@ -65,2 +79,7 @@\n-  bool found() {\n-    return _found;\n+  virtual void do_thread(Thread* thread) {\n+    JavaThread* jt = JavaThread::cast(thread);\n+    ResourceMark rm;\n+    if (is_in_scoped_access(jt, _session.resolve())) {\n+      \/\/ Throw exception to unwind out from the scoped access\n+      AsyncExceptionHandshake::do_thread(thread);\n+    }\n@@ -71,1 +90,2 @@\n-  jobject _deopt;\n+  jobject _session;\n+  jobject _error;\n@@ -74,3 +94,1 @@\n-  jboolean _found;\n-\n-  CloseScopedMemoryClosure(jobject deopt, jobject exception)\n+  CloseScopedMemoryClosure(jobject session, jobject error)\n@@ -78,2 +96,2 @@\n-    , _deopt(deopt)\n-    , _found(false) {}\n+    , _session(session)\n+    , _error(error) {}\n@@ -82,1 +100,0 @@\n-\n@@ -86,0 +103,1 @@\n+      \/\/ No frames; not in a scoped memory access\n@@ -100,11 +118,4 @@\n-    if (_deopt != nullptr && last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n-      CloseScopedMemoryFindOopClosure cl(_deopt);\n-      CompiledMethod* cm = last_frame.cb()->as_compiled_method();\n-\n-      \/* FIXME: this doesn't work if reachability fences are violated by C2\n-      last_frame.oops_do(&cl, nullptr, &register_map);\n-      if (cl.found()) {\n-           \/\/Found the deopt oop in a compiled method; deoptimize.\n-           Deoptimization::deoptimize(jt, last_frame);\n-      }\n-      so... we unconditionally deoptimize, for now: *\/\n+    if (last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n+      \/\/ FIXME: we would like to conditionally deoptimize only if the corresponding\n+      \/\/ _session is reachable from the frame, but reachabilityFence doesn't currently\n+      \/\/ work the way it should. Therefore we deopt unconditionally for now.\n@@ -114,24 +125,14 @@\n-    const int max_critical_stack_depth = 10;\n-    int depth = 0;\n-    for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n-      Method* m = stream.method();\n-      if (m->is_scoped()) {\n-        StackValueCollection* locals = stream.asJavaVFrame()->locals();\n-        for (int i = 0; i < locals->size(); i++) {\n-          StackValue* var = locals->at(i);\n-          if (var->type() == T_OBJECT) {\n-            if (var->get_obj() == JNIHandles::resolve(_deopt)) {\n-              assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n-              _found = true;\n-              return;\n-            }\n-          }\n-        }\n-        break;\n-      }\n-      depth++;\n-#ifndef ASSERT\n-      if (depth >= max_critical_stack_depth) {\n-        break;\n-      }\n-#endif\n+    if (jt->has_async_exception_condition()) {\n+      \/\/ Target thread just about to throw an async exception using async handshakes,\n+      \/\/ we will then unwind out from the scoped memory access.\n+      return;\n+    }\n+\n+    if (is_in_scoped_access(jt, JNIHandles::resolve(_session))) {\n+      \/\/ We have found that the target thread is inside of a scoped access.\n+      \/\/ An asynchronous handshake is sent to the target thread, telling it\n+      \/\/ to throw an exception, which will unwind the target thread out from\n+      \/\/ the scoped access.\n+      OopHandle session(Universe::vm_global(), JNIHandles::resolve(_session));\n+      OopHandle error(Universe::vm_global(), JNIHandles::resolve(_error));\n+      jt->install_async_exception(new ScopedAsyncExceptionHandshake(session, error));\n@@ -149,2 +150,2 @@\n-JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception))\n-  CloseScopedMemoryClosure cl(deopt, exception);\n+JVM_ENTRY(void, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject session, jobject error))\n+  CloseScopedMemoryClosure cl(session, error);\n@@ -152,1 +153,0 @@\n-  return !cl._found;\n@@ -160,2 +160,2 @@\n-#define MEMACCESS \"ScopedMemoryAccess\"\n-#define SCOPE PKG_FOREIGN \"MemorySessionImpl;\"\n+#define SCOPED_SESSION PKG_FOREIGN \"MemorySessionImpl;\"\n+#define SCOPED_ERROR PKG_MISC \"ScopedMemoryAccess$ScopedAccessError;\"\n@@ -167,1 +167,1 @@\n-    {CC \"closeScope0\",   CC \"(\" SCOPE \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+  {CC \"closeScope0\", CC \"(\" SCOPED_SESSION SCOPED_ERROR \")V\", FN_PTR(ScopedMemoryAccess_closeScope)},\n@@ -175,2 +175,2 @@\n-#undef MEMACCESS\n-#undef SCOPE\n+#undef SCOPED_SESSION\n+#undef SCOPED_ERROR\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":72,"deletions":72,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -73,1 +73,6 @@\n-\n+\/\/ Note that scoped accesses (cf. scopedMemoryAccess.cpp) can install\n+\/\/ an async handshake on the entry to an Unsafe method. When that happens,\n+\/\/ it is expected that we are not allowed to touch the underlying memory\n+\/\/ that might have gotten unmapped. Therefore, we check at the entry\n+\/\/ to unsafe functions, if we have such async exception conditions,\n+\/\/ and return immediately if that is the case.\n@@ -75,1 +80,1 @@\n-  JVM_ENTRY(static result_type, header)\n+  JVM_ENTRY(static result_type, header) if (JavaThread::current()->has_async_exception_condition()) {return (result_type)0;}\n@@ -78,1 +83,1 @@\n-  JVM_LEAF(static result_type, header)\n+  JVM_LEAF(static result_type, header) if (JavaThread::current()->has_async_exception_condition()) {return (result_type)0;}\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n@@ -231,0 +230,1 @@\n+  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-    static final int CLOSING = -1;\n-    static final int CLOSED = -2;\n+    static final int CLOSED = -1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSING);\n+        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSED);\n@@ -86,5 +86,1 @@\n-        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-        STATE.setVolatile(this, success ? CLOSED : OPEN);\n-        if (!success) {\n-            throw alreadyAcquired(1);\n-        }\n+        SCOPED_MEMORY_ACCESS.closeScope(this, ALREADY_CLOSED);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-    public boolean closeScope(MemorySessionImpl session) {\n-        return closeScope0(session);\n+    public void closeScope(MemorySessionImpl session, ScopedAccessError error) {\n+        closeScope0(session, error);\n@@ -90,1 +90,1 @@\n-    native boolean closeScope0(MemorySessionImpl session);\n+    native void closeScope0(MemorySessionImpl session, ScopedAccessError error);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-            outer: while (segment.scope().isAlive()) {\n+            while (segment.scope().isAlive()) {\n@@ -105,6 +105,9 @@\n-                    long delay = System.currentTimeMillis() - start.get();\n-                    System.out.println(\"Accessor #\" + id + \" suspending - elapsed (ms): \" + delay);\n-                    backoff();\n-                    delay = System.currentTimeMillis() - start.get();\n-                    System.out.println(\"Accessor #\" + id + \" resuming - elapsed (ms): \" + delay);\n-                    continue outer;\n+                    if (!failed.get()) {\n+                        \/\/ ignore - this means segment was alive, but was closed while we were accessing it\n+                        \/\/ next isAlive test should fail\n+                        assertFalse(segment.scope().isAlive());\n+                        failed.set(true);\n+                    } else {\n+                        \/\/ rethrow!\n+                        throw ex;\n+                    }\n@@ -249,8 +252,1 @@\n-            while (true) {\n-                try {\n-                    arena.close();\n-                    break;\n-                } catch (IllegalStateException ex) {\n-                    Thread.onSpinWait();\n-                }\n-            }\n+            arena.close(); \/\/ This should NOT throw\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"}]}