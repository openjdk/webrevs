{"files":[{"patch":"@@ -38,32 +38,0 @@\n-class CloseScopedMemoryFindOopClosure : public OopClosure {\n-  oop _deopt;\n-  bool _found;\n-\n-public:\n-  CloseScopedMemoryFindOopClosure(jobject deopt) :\n-      _deopt(JNIHandles::resolve(deopt)),\n-      _found(false) {}\n-\n-  template <typename T>\n-  void do_oop_work(T* p) {\n-    if (_found) {\n-      return;\n-    }\n-    if (RawAccess<>::oop_load(p) == _deopt) {\n-      _found = true;\n-    }\n-  }\n-\n-  virtual void do_oop(oop* p) {\n-    do_oop_work(p);\n-  }\n-\n-  virtual void do_oop(narrowOop* p) {\n-    do_oop_work(p);\n-  }\n-\n-  bool found() {\n-    return _found;\n-  }\n-};\n-\n@@ -150,11 +118,4 @@\n-    if (_session != nullptr && last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n-      CloseScopedMemoryFindOopClosure cl(_session);\n-      CompiledMethod* cm = last_frame.cb()->as_compiled_method();\n-\n-      \/* FIXME: this doesn't work if reachability fences are violated by C2\n-      last_frame.oops_do(&cl, nullptr, &register_map);\n-      if (cl.found()) {\n-           \/\/Found the deopt oop in a compiled method; deoptimize.\n-           Deoptimization::deoptimize(jt, last_frame);\n-      }\n-      so... we unconditionally deoptimize, for now: *\/\n+    if (last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n+      \/\/ FIXME: we would like to conditionally deoptimize only if the corresponding\n+      \/\/ _session is reachable from the frame, but reachabilityFence doesn't currently\n+      \/\/ work the way it should. Therefore we deopt unconditionally for now.\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":4,"deletions":43,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    public static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::alreadyClosed);\n+    static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::alreadyClosed);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        SCOPED_MEMORY_ACCESS.closeScope(this);\n+        SCOPED_MEMORY_ACCESS.closeScope(this, ALREADY_CLOSED);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-    public void closeScope(MemorySessionImpl session) {\n-        closeScope0(session, MemorySessionImpl.ALREADY_CLOSED);\n+    public void closeScope(MemorySessionImpl session, ScopedAccessError error) {\n+        closeScope0(session, error);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}