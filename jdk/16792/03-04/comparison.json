{"files":[{"patch":"@@ -85,0 +85,1 @@\n+\/\/\n@@ -88,1 +89,9 @@\n-\/\/ as the memory will be freed after the handshake is installed.\n+\/\/ as the memory will be freed after the handshake is installed. We must notice\n+\/\/ the installed handshake and return early before doing the memory access to prevent\n+\/\/ accesses to freed memory.\n+\/\/\n+\/\/ Note also that we MUST do a scoped memory access in the VM (or Java) thread\n+\/\/ state. Since we rely on a handshake to check for threads that are accessing\n+\/\/ scoped memory, and we need the handshaking thread to wait until we get to a\n+\/\/ safepoint, in order to make sure we are not in the middle of accessing memory\n+\/\/ that is about to be freed. (i.e. there can be no UNSAFE_LEAF_SCOPED)\n@@ -411,19 +420,2 @@\n-  if (srcObj == nullptr && dstObj == nullptr) {\n-    \/\/ Both src & dst are in native memory\n-    address src = (address)srcOffset;\n-    address dst = (address)dstOffset;\n-\n-    {\n-      GuardUnsafeAccess guard(thread);\n-      \/\/ Transitioning to native state below checks NSV, but doesn't actually do a safepoint poll.\n-      \/\/ So, this is safe to ignore, as no async exception handshake can actually be installed.\n-      PauseNoSafepointVerifier pnsv(&nsv);\n-      \/\/ Transition to native state. Since the source and destination are both in native memory\n-      \/\/ the copy may potentially be very large, and we don't want to disable GC if we can avoid it.\n-      ThreadToNativeFromVM ttn(thread);\n-      Copy::conjoint_swap(src, dst, sz, esz);\n-    }\n-  } else {\n-    \/\/ At least one of src\/dst are on heap, transition to VM to access raw pointers\n-    oop srcp = JNIHandles::resolve(srcObj);\n-    oop dstp = JNIHandles::resolve(dstObj);\n+  oop srcp = JNIHandles::resolve(srcObj);\n+  oop dstp = JNIHandles::resolve(dstObj);\n@@ -431,2 +423,2 @@\n-    address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);\n-    address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);\n+  address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);\n+  address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);\n@@ -434,4 +426,3 @@\n-    {\n-      GuardUnsafeAccess guard(thread);\n-      Copy::conjoint_swap(src, dst, sz, esz);\n-    }\n+  {\n+    GuardUnsafeAccess guard(thread);\n+    Copy::conjoint_swap(src, dst, sz, esz);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":17,"deletions":26,"binary":false,"changes":43,"status":"modified"}]}