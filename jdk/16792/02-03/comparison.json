{"files":[{"patch":"@@ -73,0 +73,6 @@\n+#define UNSAFE_ENTRY(result_type, header) \\\n+  JVM_ENTRY(static result_type, header)\n+\n+#define UNSAFE_LEAF(result_type, header) \\\n+  JVM_LEAF(static result_type, header)\n+\n@@ -79,5 +85,8 @@\n-#define UNSAFE_ENTRY(result_type, header) \\\n-  JVM_ENTRY(static result_type, header) if (JavaThread::current()->has_async_exception_condition()) {return (result_type)0;}\n-\n-#define UNSAFE_LEAF(result_type, header) \\\n-  JVM_LEAF(static result_type, header) if (JavaThread::current()->has_async_exception_condition()) {return (result_type)0;}\n+\/\/ We also use NoSafepointVerifier to block potential safepoints.\n+\/\/ It would be problematic if an async exception handshake were installed later on\n+\/\/ during another safepoint in the function, but before the memory access happens,\n+\/\/ as the memory will be freed after the handshake is installed.\n+#define UNSAFE_ENTRY_SCOPED(result_type, header) \\\n+  JVM_ENTRY(static result_type, header) \\\n+  if (thread->has_async_exception_condition()) {return (result_type)0;} \\\n+  NoSafepointVerifier nsv;\n@@ -287,1 +296,1 @@\n-UNSAFE_ENTRY(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n+UNSAFE_ENTRY_SCOPED(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n@@ -291,1 +300,1 @@\n-UNSAFE_ENTRY(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n@@ -310,1 +319,1 @@\n-UNSAFE_ENTRY(java_type, Unsafe_Get##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n+UNSAFE_ENTRY_SCOPED(java_type, Unsafe_Get##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n@@ -314,1 +323,1 @@\n-UNSAFE_ENTRY(void, Unsafe_Put##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_Put##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n@@ -370,1 +379,1 @@\n-UNSAFE_ENTRY(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {\n@@ -379,1 +388,1 @@\n-UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {\n@@ -398,5 +407,1 @@\n-\/\/ This function is a leaf since if the source and destination are both in native memory\n-\/\/ the copy may potentially be very large, and we don't want to disable GC if we can avoid it.\n-\/\/ If either source or destination (or both) are on the heap, the function will enter VM using\n-\/\/ JVM_ENTRY_FROM_LEAF\n-UNSAFE_LEAF(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {\n@@ -412,1 +417,0 @@\n-      JavaThread* thread = JavaThread::thread_from_jni_environment(env);\n@@ -414,0 +418,6 @@\n+      \/\/ Transitioning to native state below checks NSV, but doesn't actually do a safepoint poll.\n+      \/\/ So, this is safe to ignore, as no async exception handshake can actually be installed.\n+      PauseNoSafepointVerifier pnsv(&nsv);\n+      \/\/ Transition to native state. Since the source and destination are both in native memory\n+      \/\/ the copy may potentially be very large, and we don't want to disable GC if we can avoid it.\n+      ThreadToNativeFromVM ttn(thread);\n@@ -418,0 +428,2 @@\n+    oop srcp = JNIHandles::resolve(srcObj);\n+    oop dstp = JNIHandles::resolve(dstObj);\n@@ -419,3 +431,2 @@\n-    JVM_ENTRY_FROM_LEAF(env, void, Unsafe_CopySwapMemory0) {\n-      oop srcp = JNIHandles::resolve(srcObj);\n-      oop dstp = JNIHandles::resolve(dstObj);\n+    address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);\n+    address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);\n@@ -423,8 +434,4 @@\n-      address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);\n-      address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);\n-\n-      {\n-        GuardUnsafeAccess guard(thread);\n-        Copy::conjoint_swap(src, dst, sz, esz);\n-      }\n-    } JVM_END\n+    {\n+      GuardUnsafeAccess guard(thread);\n+      Copy::conjoint_swap(src, dst, sz, esz);\n+    }\n@@ -726,1 +733,1 @@\n-UNSAFE_ENTRY(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n+UNSAFE_ENTRY_SCOPED(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n@@ -732,1 +739,1 @@\n-UNSAFE_ENTRY(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n+UNSAFE_ENTRY_SCOPED(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n@@ -747,1 +754,1 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n+UNSAFE_ENTRY_SCOPED(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n@@ -753,1 +760,1 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n+UNSAFE_ENTRY_SCOPED(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":39,"deletions":32,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -409,8 +409,0 @@\n-#define JVM_ENTRY_FROM_LEAF(env, result_type, header)                \\\n-  { {                                                                \\\n-    JavaThread* thread=JavaThread::thread_from_jni_environment(env); \\\n-    ThreadInVMfromNative __tiv(thread);                              \\\n-    debug_only(VMNativeEntryWrapper __vew;)                          \\\n-    VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -51,0 +52,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -180,0 +182,24 @@\n+    static class SegmentSwappyCopyAccessor extends AbstractSegmentAccessor {\n+\n+        MemorySegment first, second;\n+        ValueLayout sourceLayout, destLayout;\n+        long count;\n+\n+\n+        SegmentSwappyCopyAccessor(int id, MemorySegment segment, Arena _unused) {\n+            super(id, segment);\n+            long split = segment.byteSize() \/ 2;\n+            first = segment.asSlice(0, split);\n+            sourceLayout = JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN);\n+            second = segment.asSlice(split);\n+            destLayout = JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n+            count = Math.min(first.byteSize() \/ sourceLayout.byteSize(),\n+                second.byteSize() \/ destLayout.byteSize());\n+        }\n+\n+        @Override\n+        public void doAccess() {\n+            MemorySegment.copy(first, sourceLayout, 0L, second, destLayout, 0L, count);\n+        }\n+    }\n+\n@@ -267,0 +293,1 @@\n+                { \"SegmentSwappyCopyAccessor\", (AccessorFactory)SegmentSwappyCopyAccessor::new },\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"}]}