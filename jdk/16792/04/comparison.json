{"files":[{"patch":"@@ -38,13 +38,17 @@\n-class CloseScopedMemoryFindOopClosure : public OopClosure {\n-  oop _deopt;\n-  bool _found;\n-\n-public:\n-  CloseScopedMemoryFindOopClosure(jobject deopt) :\n-      _deopt(JNIHandles::resolve(deopt)),\n-      _found(false) {}\n-\n-  template <typename T>\n-  void do_oop_work(T* p) {\n-    if (_found) {\n-      return;\n+static bool is_in_scoped_access(JavaThread* jt, oop session) {\n+  const int max_critical_stack_depth = 10;\n+  int depth = 0;\n+  for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n+    Method* m = stream.method();\n+    if (m->is_scoped()) {\n+      StackValueCollection* locals = stream.asJavaVFrame()->locals();\n+      for (int i = 0; i < locals->size(); i++) {\n+        StackValue* var = locals->at(i);\n+        if (var->type() == T_OBJECT) {\n+          if (var->get_obj() == session) {\n+            assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n+            return true;\n+          }\n+        }\n+      }\n+      break;\n@@ -52,2 +56,4 @@\n-    if (RawAccess<>::oop_load(p) == _deopt) {\n-      _found = true;\n+    depth++;\n+#ifndef ASSERT\n+    if (depth >= max_critical_stack_depth) {\n+      break;\n@@ -55,0 +61,1 @@\n+#endif\n@@ -57,3 +64,5 @@\n-  virtual void do_oop(oop* p) {\n-    do_oop_work(p);\n-  }\n+  return false;\n+}\n+\n+class ScopedAsyncExceptionHandshake : public AsyncExceptionHandshake {\n+  OopHandle _session;\n@@ -61,2 +70,7 @@\n-  virtual void do_oop(narrowOop* p) {\n-    do_oop_work(p);\n+public:\n+  ScopedAsyncExceptionHandshake(OopHandle& session, OopHandle& error)\n+    : AsyncExceptionHandshake(error),\n+      _session(session) {}\n+\n+  ~ScopedAsyncExceptionHandshake() {\n+    _session.release(Universe::vm_global());\n@@ -65,2 +79,7 @@\n-  bool found() {\n-    return _found;\n+  virtual void do_thread(Thread* thread) {\n+    JavaThread* jt = JavaThread::cast(thread);\n+    ResourceMark rm;\n+    if (is_in_scoped_access(jt, _session.resolve())) {\n+      \/\/ Throw exception to unwind out from the scoped access\n+      AsyncExceptionHandshake::do_thread(thread);\n+    }\n@@ -71,1 +90,2 @@\n-  jobject _deopt;\n+  jobject _session;\n+  jobject _error;\n@@ -74,3 +94,1 @@\n-  jboolean _found;\n-\n-  CloseScopedMemoryClosure(jobject deopt, jobject exception)\n+  CloseScopedMemoryClosure(jobject session, jobject error)\n@@ -78,2 +96,2 @@\n-    , _deopt(deopt)\n-    , _found(false) {}\n+    , _session(session)\n+    , _error(error) {}\n@@ -82,1 +100,0 @@\n-\n@@ -86,0 +103,1 @@\n+      \/\/ No frames; not in a scoped memory access\n@@ -100,11 +118,4 @@\n-    if (_deopt != nullptr && last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n-      CloseScopedMemoryFindOopClosure cl(_deopt);\n-      CompiledMethod* cm = last_frame.cb()->as_compiled_method();\n-\n-      \/* FIXME: this doesn't work if reachability fences are violated by C2\n-      last_frame.oops_do(&cl, nullptr, &register_map);\n-      if (cl.found()) {\n-           \/\/Found the deopt oop in a compiled method; deoptimize.\n-           Deoptimization::deoptimize(jt, last_frame);\n-      }\n-      so... we unconditionally deoptimize, for now: *\/\n+    if (last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n+      \/\/ FIXME: we would like to conditionally deoptimize only if the corresponding\n+      \/\/ _session is reachable from the frame, but reachabilityFence doesn't currently\n+      \/\/ work the way it should. Therefore we deopt unconditionally for now.\n@@ -114,24 +125,14 @@\n-    const int max_critical_stack_depth = 10;\n-    int depth = 0;\n-    for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n-      Method* m = stream.method();\n-      if (m->is_scoped()) {\n-        StackValueCollection* locals = stream.asJavaVFrame()->locals();\n-        for (int i = 0; i < locals->size(); i++) {\n-          StackValue* var = locals->at(i);\n-          if (var->type() == T_OBJECT) {\n-            if (var->get_obj() == JNIHandles::resolve(_deopt)) {\n-              assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n-              _found = true;\n-              return;\n-            }\n-          }\n-        }\n-        break;\n-      }\n-      depth++;\n-#ifndef ASSERT\n-      if (depth >= max_critical_stack_depth) {\n-        break;\n-      }\n-#endif\n+    if (jt->has_async_exception_condition()) {\n+      \/\/ Target thread just about to throw an async exception using async handshakes,\n+      \/\/ we will then unwind out from the scoped memory access.\n+      return;\n+    }\n+\n+    if (is_in_scoped_access(jt, JNIHandles::resolve(_session))) {\n+      \/\/ We have found that the target thread is inside of a scoped access.\n+      \/\/ An asynchronous handshake is sent to the target thread, telling it\n+      \/\/ to throw an exception, which will unwind the target thread out from\n+      \/\/ the scoped access.\n+      OopHandle session(Universe::vm_global(), JNIHandles::resolve(_session));\n+      OopHandle error(Universe::vm_global(), JNIHandles::resolve(_error));\n+      jt->install_async_exception(new ScopedAsyncExceptionHandshake(session, error));\n@@ -149,2 +150,2 @@\n-JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception))\n-  CloseScopedMemoryClosure cl(deopt, exception);\n+JVM_ENTRY(void, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject session, jobject error))\n+  CloseScopedMemoryClosure cl(session, error);\n@@ -152,1 +153,0 @@\n-  return !cl._found;\n@@ -160,2 +160,2 @@\n-#define MEMACCESS \"ScopedMemoryAccess\"\n-#define SCOPE PKG_FOREIGN \"MemorySessionImpl;\"\n+#define SCOPED_SESSION PKG_FOREIGN \"MemorySessionImpl;\"\n+#define SCOPED_ERROR PKG_MISC \"ScopedMemoryAccess$ScopedAccessError;\"\n@@ -167,1 +167,1 @@\n-    {CC \"closeScope0\",   CC \"(\" SCOPE \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+  {CC \"closeScope0\", CC \"(\" SCOPED_SESSION SCOPED_ERROR \")V\", FN_PTR(ScopedMemoryAccess_closeScope)},\n@@ -175,2 +175,2 @@\n-#undef MEMACCESS\n-#undef SCOPE\n+#undef SCOPED_SESSION\n+#undef SCOPED_ERROR\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":72,"deletions":72,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-\n@@ -80,0 +79,24 @@\n+\/\/ Note that scoped accesses (cf. scopedMemoryAccess.cpp) can install\n+\/\/ an async handshake on the entry to an Unsafe method. When that happens,\n+\/\/ it is expected that we are not allowed to touch the underlying memory\n+\/\/ that might have gotten unmapped. Therefore, we check at the entry\n+\/\/ to unsafe functions, if we have such async exception conditions,\n+\/\/ and return immediately if that is the case.\n+\/\/\n+\/\/ We also use NoSafepointVerifier to block potential safepoints.\n+\/\/ It would be problematic if an async exception handshake were installed later on\n+\/\/ during another safepoint in the function, but before the memory access happens,\n+\/\/ as the memory will be freed after the handshake is installed. We must notice\n+\/\/ the installed handshake and return early before doing the memory access to prevent\n+\/\/ accesses to freed memory.\n+\/\/\n+\/\/ Note also that we MUST do a scoped memory access in the VM (or Java) thread\n+\/\/ state. Since we rely on a handshake to check for threads that are accessing\n+\/\/ scoped memory, and we need the handshaking thread to wait until we get to a\n+\/\/ safepoint, in order to make sure we are not in the middle of accessing memory\n+\/\/ that is about to be freed. (i.e. there can be no UNSAFE_LEAF_SCOPED)\n+#define UNSAFE_ENTRY_SCOPED(result_type, header) \\\n+  JVM_ENTRY(static result_type, header) \\\n+  if (thread->has_async_exception_condition()) {return (result_type)0;} \\\n+  NoSafepointVerifier nsv;\n+\n@@ -282,1 +305,1 @@\n-UNSAFE_ENTRY(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n+UNSAFE_ENTRY_SCOPED(java_type, Unsafe_Get##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n@@ -286,1 +309,1 @@\n-UNSAFE_ENTRY(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_Put##Type(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n@@ -305,1 +328,1 @@\n-UNSAFE_ENTRY(java_type, Unsafe_Get##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n+UNSAFE_ENTRY_SCOPED(java_type, Unsafe_Get##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset)) { \\\n@@ -309,1 +332,1 @@\n-UNSAFE_ENTRY(void, Unsafe_Put##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_Put##Type##Volatile(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, java_type x)) { \\\n@@ -365,1 +388,1 @@\n-UNSAFE_ENTRY(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_SetMemory0(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong size, jbyte value)) {\n@@ -374,1 +397,1 @@\n-UNSAFE_ENTRY(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_CopyMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size)) {\n@@ -393,5 +416,1 @@\n-\/\/ This function is a leaf since if the source and destination are both in native memory\n-\/\/ the copy may potentially be very large, and we don't want to disable GC if we can avoid it.\n-\/\/ If either source or destination (or both) are on the heap, the function will enter VM using\n-\/\/ JVM_ENTRY_FROM_LEAF\n-UNSAFE_LEAF(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {\n+UNSAFE_ENTRY_SCOPED(void, Unsafe_CopySwapMemory0(JNIEnv *env, jobject unsafe, jobject srcObj, jlong srcOffset, jobject dstObj, jlong dstOffset, jlong size, jlong elemSize)) {\n@@ -401,16 +420,2 @@\n-  if (srcObj == nullptr && dstObj == nullptr) {\n-    \/\/ Both src & dst are in native memory\n-    address src = (address)srcOffset;\n-    address dst = (address)dstOffset;\n-\n-    {\n-      JavaThread* thread = JavaThread::thread_from_jni_environment(env);\n-      GuardUnsafeAccess guard(thread);\n-      Copy::conjoint_swap(src, dst, sz, esz);\n-    }\n-  } else {\n-    \/\/ At least one of src\/dst are on heap, transition to VM to access raw pointers\n-\n-    JVM_ENTRY_FROM_LEAF(env, void, Unsafe_CopySwapMemory0) {\n-      oop srcp = JNIHandles::resolve(srcObj);\n-      oop dstp = JNIHandles::resolve(dstObj);\n+  oop srcp = JNIHandles::resolve(srcObj);\n+  oop dstp = JNIHandles::resolve(dstObj);\n@@ -418,2 +423,2 @@\n-      address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);\n-      address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);\n+  address src = (address)index_oop_from_field_offset_long(srcp, srcOffset);\n+  address dst = (address)index_oop_from_field_offset_long(dstp, dstOffset);\n@@ -421,5 +426,3 @@\n-      {\n-        GuardUnsafeAccess guard(thread);\n-        Copy::conjoint_swap(src, dst, sz, esz);\n-      }\n-    } JVM_END\n+  {\n+    GuardUnsafeAccess guard(thread);\n+    Copy::conjoint_swap(src, dst, sz, esz);\n@@ -721,1 +724,1 @@\n-UNSAFE_ENTRY(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n+UNSAFE_ENTRY_SCOPED(jint, Unsafe_CompareAndExchangeInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n@@ -727,1 +730,1 @@\n-UNSAFE_ENTRY(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n+UNSAFE_ENTRY_SCOPED(jlong, Unsafe_CompareAndExchangeLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n@@ -742,1 +745,1 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n+UNSAFE_ENTRY_SCOPED(jboolean, Unsafe_CompareAndSetInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) {\n@@ -748,1 +751,1 @@\n-UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n+UNSAFE_ENTRY_SCOPED(jboolean, Unsafe_CompareAndSetLong(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jlong e, jlong x)) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":42,"deletions":39,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -409,8 +409,0 @@\n-#define JVM_ENTRY_FROM_LEAF(env, result_type, header)                \\\n-  { {                                                                \\\n-    JavaThread* thread=JavaThread::thread_from_jni_environment(env); \\\n-    ThreadInVMfromNative __tiv(thread);                              \\\n-    debug_only(VMNativeEntryWrapper __vew;)                          \\\n-    VM_ENTRY_BASE_FROM_LEAF(result_type, header, thread)\n-\n-\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n@@ -231,0 +230,1 @@\n+  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-    static final int CLOSING = -1;\n-    static final int CLOSED = -2;\n+    static final int CLOSED = -1;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSING);\n+        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSED);\n@@ -86,5 +86,1 @@\n-        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-        STATE.setVolatile(this, success ? CLOSED : OPEN);\n-        if (!success) {\n-            throw alreadyAcquired(1);\n-        }\n+        SCOPED_MEMORY_ACCESS.closeScope(this, ALREADY_CLOSED);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-    public boolean closeScope(MemorySessionImpl session) {\n-        return closeScope0(session);\n+    public void closeScope(MemorySessionImpl session, ScopedAccessError error) {\n+        closeScope0(session, error);\n@@ -90,1 +90,1 @@\n-    native boolean closeScope0(MemorySessionImpl session);\n+    native void closeScope0(MemorySessionImpl session, ScopedAccessError error);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.foreign.ValueLayout;\n@@ -51,0 +52,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -101,1 +103,1 @@\n-            outer: while (segment.scope().isAlive()) {\n+            while (segment.scope().isAlive()) {\n@@ -105,6 +107,9 @@\n-                    long delay = System.currentTimeMillis() - start.get();\n-                    System.out.println(\"Accessor #\" + id + \" suspending - elapsed (ms): \" + delay);\n-                    backoff();\n-                    delay = System.currentTimeMillis() - start.get();\n-                    System.out.println(\"Accessor #\" + id + \" resuming - elapsed (ms): \" + delay);\n-                    continue outer;\n+                    if (!failed.get()) {\n+                        \/\/ ignore - this means segment was alive, but was closed while we were accessing it\n+                        \/\/ next isAlive test should fail\n+                        assertFalse(segment.scope().isAlive());\n+                        failed.set(true);\n+                    } else {\n+                        \/\/ rethrow!\n+                        throw ex;\n+                    }\n@@ -177,0 +182,24 @@\n+    static class SegmentSwappyCopyAccessor extends AbstractSegmentAccessor {\n+\n+        MemorySegment first, second;\n+        ValueLayout sourceLayout, destLayout;\n+        long count;\n+\n+\n+        SegmentSwappyCopyAccessor(int id, MemorySegment segment, Arena _unused) {\n+            super(id, segment);\n+            long split = segment.byteSize() \/ 2;\n+            first = segment.asSlice(0, split);\n+            sourceLayout = JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN);\n+            second = segment.asSlice(split);\n+            destLayout = JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n+            count = Math.min(first.byteSize() \/ sourceLayout.byteSize(),\n+                second.byteSize() \/ destLayout.byteSize());\n+        }\n+\n+        @Override\n+        public void doAccess() {\n+            MemorySegment.copy(first, sourceLayout, 0L, second, destLayout, 0L, count);\n+        }\n+    }\n+\n@@ -249,8 +278,1 @@\n-            while (true) {\n-                try {\n-                    arena.close();\n-                    break;\n-                } catch (IllegalStateException ex) {\n-                    Thread.onSpinWait();\n-                }\n-            }\n+            arena.close(); \/\/ This should NOT throw\n@@ -271,0 +293,1 @@\n+                { \"SegmentSwappyCopyAccessor\", (AccessorFactory)SegmentSwappyCopyAccessor::new },\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":38,"deletions":15,"binary":false,"changes":53,"status":"modified"}]}