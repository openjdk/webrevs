{"files":[{"patch":"@@ -70,2 +70,31 @@\n-class CloseScopedMemoryClosure : public HandshakeClosure {\n-  jobject _deopt;\n+static bool is_in_scoped_access(JavaThread* jt, oop session) {\n+  const int max_critical_stack_depth = 10;\n+  int depth = 0;\n+  for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n+    Method* m = stream.method();\n+    if (m->is_scoped()) {\n+      StackValueCollection* locals = stream.asJavaVFrame()->locals();\n+      for (int i = 0; i < locals->size(); i++) {\n+        StackValue* var = locals->at(i);\n+        if (var->type() == T_OBJECT) {\n+          if (var->get_obj() == session) {\n+            assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n+            return true;\n+          }\n+        }\n+      }\n+      break;\n+    }\n+    depth++;\n+#ifndef ASSERT\n+    if (depth >= max_critical_stack_depth) {\n+      break;\n+    }\n+#endif\n+  }\n+\n+  return false;\n+}\n+\n+class ScopedAsyncExceptionHandshake : public AsyncExceptionHandshake {\n+  OopHandle _session;\n@@ -74,1 +103,21 @@\n-  jboolean _found;\n+  ScopedAsyncExceptionHandshake(OopHandle& session, OopHandle& error)\n+    : AsyncExceptionHandshake(error),\n+      _session(session) {}\n+\n+  ~ScopedAsyncExceptionHandshake() {\n+    _session.release(Universe::vm_global());\n+  }\n+\n+  virtual void do_thread(Thread* thread) {\n+    JavaThread* jt = JavaThread::cast(thread);\n+    ResourceMark rm;\n+    if (is_in_scoped_access(jt, _session.resolve())) {\n+      \/\/ Throw exception to unwind out from the scoped access\n+      AsyncExceptionHandshake::do_thread(thread);\n+    }\n+  }\n+};\n+\n+class CloseScopedMemoryClosure : public HandshakeClosure {\n+  jobject _session;\n+  jobject _error;\n@@ -76,1 +125,2 @@\n-  CloseScopedMemoryClosure(jobject deopt, jobject exception)\n+public:\n+  CloseScopedMemoryClosure(jobject session, jobject error)\n@@ -78,2 +128,2 @@\n-    , _deopt(deopt)\n-    , _found(false) {}\n+    , _session(session)\n+    , _error(error) {}\n@@ -82,1 +132,0 @@\n-\n@@ -86,0 +135,1 @@\n+      \/\/ No frames; not in a scoped memory access\n@@ -100,2 +150,2 @@\n-    if (_deopt != nullptr && last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n-      CloseScopedMemoryFindOopClosure cl(_deopt);\n+    if (_session != nullptr && last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n+      CloseScopedMemoryFindOopClosure cl(_session);\n@@ -114,24 +164,14 @@\n-    const int max_critical_stack_depth = 10;\n-    int depth = 0;\n-    for (vframeStream stream(jt); !stream.at_end(); stream.next()) {\n-      Method* m = stream.method();\n-      if (m->is_scoped()) {\n-        StackValueCollection* locals = stream.asJavaVFrame()->locals();\n-        for (int i = 0; i < locals->size(); i++) {\n-          StackValue* var = locals->at(i);\n-          if (var->type() == T_OBJECT) {\n-            if (var->get_obj() == JNIHandles::resolve(_deopt)) {\n-              assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n-              _found = true;\n-              return;\n-            }\n-          }\n-        }\n-        break;\n-      }\n-      depth++;\n-#ifndef ASSERT\n-      if (depth >= max_critical_stack_depth) {\n-        break;\n-      }\n-#endif\n+    if (jt->has_async_exception_condition()) {\n+      \/\/ Target thread just about to throw an async exception using async handshakes,\n+      \/\/ we will then unwind out from the scoped memory access.\n+      return;\n+    }\n+\n+    if (is_in_scoped_access(jt, JNIHandles::resolve(_session))) {\n+      \/\/ We have found that the target thread is inside of a scoped access.\n+      \/\/ An asynchronous handshake is sent to the target thread, telling it\n+      \/\/ to throw an exception, which will unwind the target thread out from\n+      \/\/ the scoped access.\n+      OopHandle session(Universe::vm_global(), JNIHandles::resolve(_session));\n+      OopHandle error(Universe::vm_global(), JNIHandles::resolve(_error));\n+      jt->install_async_exception(new ScopedAsyncExceptionHandshake(session, error));\n@@ -149,2 +189,2 @@\n-JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception))\n-  CloseScopedMemoryClosure cl(deopt, exception);\n+JVM_ENTRY(void, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject session, jobject error))\n+  CloseScopedMemoryClosure cl(session, error);\n@@ -152,1 +192,0 @@\n-  return !cl._found;\n@@ -160,2 +199,2 @@\n-#define MEMACCESS \"ScopedMemoryAccess\"\n-#define SCOPE PKG_FOREIGN \"MemorySessionImpl;\"\n+#define SCOPED_SESSION PKG_FOREIGN \"MemorySessionImpl;\"\n+#define SCOPED_ERROR PKG_MISC \"ScopedMemoryAccess$ScopedAccessError;\"\n@@ -167,1 +206,1 @@\n-    {CC \"closeScope0\",   CC \"(\" SCOPE \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+  {CC \"closeScope0\", CC \"(\" SCOPED_SESSION SCOPED_ERROR \")V\", FN_PTR(ScopedMemoryAccess_closeScope)},\n@@ -175,2 +214,2 @@\n-#undef MEMACCESS\n-#undef SCOPE\n+#undef SCOPED_SESSION\n+#undef SCOPED_ERROR\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":80,"deletions":41,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -73,1 +73,6 @@\n-\n+\/\/ Note that scoped accesses (cf. scopedMemoryAccess.cpp) can install\n+\/\/ an async handshake on the entry to an Unsafe method. When that happens,\n+\/\/ it is expected that we are not allowed to touch the underlying memory\n+\/\/ that might have gotten unmapped. Therefore, we check at the entry\n+\/\/ to unsafe functions, if we have such async exception conditions,\n+\/\/ and return immediately if that is the case.\n@@ -75,1 +80,1 @@\n-  JVM_ENTRY(static result_type, header)\n+  JVM_ENTRY(static result_type, header) if (JavaThread::current()->has_async_exception_condition()) {return (result_type)0;}\n@@ -78,1 +83,1 @@\n-  JVM_LEAF(static result_type, header)\n+  JVM_LEAF(static result_type, header) if (JavaThread::current()->has_async_exception_condition()) {return (result_type)0;}\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n@@ -231,0 +230,1 @@\n+  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-    static final int CLOSING = -1;\n-    static final int CLOSED = -2;\n+    static final int CLOSED = -1;\n@@ -64,1 +63,1 @@\n-    static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::alreadyClosed);\n+    public static final ScopedMemoryAccess.ScopedAccessError ALREADY_CLOSED = new ScopedMemoryAccess.ScopedAccessError(MemorySessionImpl::alreadyClosed);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSING);\n+        int prevState = (int) STATE.compareAndExchange(this, OPEN, CLOSED);\n@@ -86,5 +86,1 @@\n-        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-        STATE.setVolatile(this, success ? CLOSED : OPEN);\n-        if (!success) {\n-            throw alreadyAcquired(1);\n-        }\n+        SCOPED_MEMORY_ACCESS.closeScope(this);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,2 +86,2 @@\n-    public boolean closeScope(MemorySessionImpl session) {\n-        return closeScope0(session);\n+    public void closeScope(MemorySessionImpl session) {\n+        closeScope0(session, MemorySessionImpl.ALREADY_CLOSED);\n@@ -90,1 +90,1 @@\n-    native boolean closeScope0(MemorySessionImpl session);\n+    native void closeScope0(MemorySessionImpl session, ScopedAccessError error);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-            outer: while (segment.scope().isAlive()) {\n+            while (segment.scope().isAlive()) {\n@@ -105,6 +105,8 @@\n-                    long delay = System.currentTimeMillis() - start.get();\n-                    System.out.println(\"Accessor #\" + id + \" suspending - elapsed (ms): \" + delay);\n-                    backoff();\n-                    delay = System.currentTimeMillis() - start.get();\n-                    System.out.println(\"Accessor #\" + id + \" resuming - elapsed (ms): \" + delay);\n-                    continue outer;\n+                    if (!failed.get()) {\n+                        \/\/ ignore - this means segment was alive, but was closed while we were accessing it\n+                        \/\/ next isAlive test should fail\n+                        failed.set(true);\n+                    } else {\n+                        \/\/ rethrow!\n+                        throw ex;\n+                    }\n@@ -249,8 +251,1 @@\n-            while (true) {\n-                try {\n-                    arena.close();\n-                    break;\n-                } catch (IllegalStateException ex) {\n-                    Thread.onSpinWait();\n-                }\n-            }\n+            arena.close(); \/\/ This should NOT throw\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"}]}