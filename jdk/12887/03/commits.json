[{"commit":{"message":"Respond to feedback\n\nMoves comment to the record declaration."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"42035af70fdf8e8767d327da56434b207d30bc6f"},{"commit":{"message":"Respond to feedback\n\nStores superclasses and parents in sets, not lists."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"f41aefbcbd4c8f262c39f8ecedd0039ae91da967"},{"commit":{"message":"Merge branch 'master' into 8300517"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java"}],"sha":"0c47a72d190b67d1cbef16e7a01f28eedd27be29"},{"commit":{"message":"Clarify some assertions"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"c0dfb165d67ee38a459250e1b218d58ef8a48d7c"},{"commit":{"message":"Respond to feedback"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/doclet\/package-info.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"3ad7fafa44ce9eaab35270cc29dbb01556755374"},{"commit":{"message":"Remove trailing whitespace (to please jcheck)"},"files":[{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/TestSpecifiedBy.java"}],"sha":"2050dab18b1971590de0144d30ef8137d77c3008"},{"commit":{"message":"Comment method accessibility for inheritance"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"3c8b968228fcee844110e67fb32bccaf5460a678"},{"commit":{"message":"Rename VisibleMemberTable.isInherited for clarity\n\nIt's about _access control_ and has nothing to do with inheritance."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"d63b574046cce3996cfb7fa2c516bf379f9156b9"},{"commit":{"message":"Add FIXMEs to VisibleMemberTable.computeVisibleMethods"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"67105b40e6fe961c5a9f28ea8e2e0cd3c82cb417"},{"commit":{"message":"Comment VisibleMemberTable.computeVisibleMethods"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"e6db13c2865218af196da043c01407004fa62001"},{"commit":{"message":"Improve VisibleMemberTable.computeVisibleMethods\n\nSplits the first loop and improves inline comments for clarity."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"2a0eb4f294aa283ac8cd9ff14c560f9a14b670b4"},{"commit":{"message":"Replace isEnclosureInterface with a better method"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"b7f4d0247d2f8bb6dff5dd08a5b2e1158562bd8b"},{"commit":{"message":"Document Utils.isPackagePrivate\n\nAlso, trivially optimizes the implementation. Quick stats for calls to\nUtils.isPackagePrivate during `make docs`, to back up the optimization.\n\nTotal calls: 942669. In those calls, the passed element was:\n\n public:    902587\n protected:  35085\n private:        0"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"93e49da6d0fb0f44a8ac158ff898eee7cd137531"},{"commit":{"message":"Re-document VisibleMemberTable.getOverriddenMethod"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"0a6ba1e19e5662f9efb87fd19821b48acf0f2bd9"},{"commit":{"message":"Removed unused Utils.isSubclassOf"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"1f1e09c9b46b63f75af48277440abf2424b3d3f0"},{"commit":{"message":"Add a test retroactively\n\nThe test asserts this behaviour:\njdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java:267\n\n20+ years later than the behaviour was introduced."},"files":[{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/TestSpecifiedBy.java"}],"sha":"c7a003892f8237666539fdd9794372805ccadf63"},{"commit":{"message":"Simplify MethodWriterImpl.addImplementsInfo"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java"}],"sha":"9881e746b63946abd4d1d0dab0fe07e4f909334c"},{"commit":{"message":"Simplify HtmlDocletWriter.addMethodInfo\n\nThe eventual goal is to treat implemented and overridden method\nuniformly."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java"}],"sha":"1b9640cf96608f0dc683da95a0d8713950f6b69a"},{"commit":{"message":"Simplify HtmlDocletWriter.addMethodInfo"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java"}],"sha":"a1df5fe7e7e674a10d55ea979d2021a98c843db1"},{"commit":{"message":"Simplify HtmlDocletWriter.addMethodInfo\n\nCarefully splits \"implements info\" and \"overridden\". Removes an obvious\ncomment and adds a note that captures a non-obvious behaviour. The tests\npass.\n\nFWIW, I did some archaeology on pre-2007 code. Although, I cannot easily\nrun or compile that code, from the source and publicly available JDK\nAPI documentation I believe that the feature has evolved as follows:\n\n  1. Print the \"Overrides:\" item which links to a class method that\n     the class being documented overrides.\n  2. Print \"Specified by:\" above \"Overrides:\". There's only one\n     \"Specified by:\" item which links to the first method that the\n     method being documented overrides in the directly implemented\/\n     extended interfaces. (Re: first. The iteration order is not\n     obvious, but likely is the order of appearance in the extends\/\n     implements clause in source.)\n  3. Search for the method to link to in \"Specified by:\" by walking the\n     inheritance hierarchy upwards (4216836).\n  4. Use \"Specified by:\" instead of \"Override:\" for an abstract method\n     of an abstract class (4318787).\n  5. Search for the _most specific_ method to link to in \"Specified by:\"\n     using ImplementedMethods (4289528).\n  6. Print \"Specified by:\" for _multiple methods_. The methods are those\n     from ImplementedMethods data structure (5029946)."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java"}],"sha":"db9cf22edeed352f6def82d07fc3aaea3f54d3ef"},{"commit":{"message":"Simplify HtmlDocletWriter.addMethodInfo"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java"}],"sha":"a9599e3a12f0f29fdabad60b12c717e637da02e3"},{"commit":{"message":"Simplify HtmlDocletWriter.addMethodInfo"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java"}],"sha":"da06c3b745f552403a54efc1bdf13ef95c38aa56"},{"commit":{"message":"Remove WorkArounds.overrides(ExecutableElement)\n\nIntroduced to solve 8174839, the WorkArounds.overrides method\ncomplicates reasoning and increases the gap between jdk.javadoc and\njavax.lang.model. Both qualities are undesirable and could be avoided\nif 8174839 is approached differently.\n\nBelow are quick analysis and conclusion\/suggestion. The analysis is\nbased on the stacktrace attached to 8174839, the repo snapshot\nimmediately preceding the commit for 8174839 and the commit itself.\n\nDisclaimer: I haven't verified analysis using the debugger.\n\nAnalysis\n========\n\n8174839 was caused by an attempt to use a null link generated for the\ntype mirror corresponding to an element that owns a method\noverridden by the given method. Null link could only be generated if\nthat type mirror was itself null. The type mirror was null because\nWorkArounds.overriddenType which was in charge of finding that type\nmirror could not find the type whose method overrode the method in\nquestion. Such a method could not be found because\nWorkArounds.overriddenType factored in return types,\nwhich were incompatible.\n\nOn the other hand, the overridden method itself -- not its owner -- was\nsuccessfully found because it was searched by Elements.overrides which\ndoes NOT factor in return types.\n\nThe link was generated because an overridden method was found,\nbut the link was null because the overridden type wasn't found.\n\nSo there's a discrepancy\/miscoordination.\n\nConclusion\/Suggestion\n=====================\n\n8174839 removed discrepancy by changing both search mechanisms to factor\nin return types. The result was two nonstandard mechanisms in place of\none standard (jx.l.m.Elements.overrides).\n\nAn alternative and probably better solution is to remove the discrepancy\nthe other way around: by replacing those mechanisms with\nElements.override even though it currently does not factor in return\ntypes.\n\nIncompatible return types for overridden methods is only a problem if\nrunning javadoc on non-compilable source. But javadoc should only be\nrun on compilable source. If it's not, it shouldn't crash, but it also\nshouldn't try to compensate for bad source: garbage in, garbage out.\nIf Elements.overrides believe the method is overridden, fine, let's\ngenerate a link to the overridden method.\n\nThe initial problem was NullPointerException, not problematic source."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/TestBadOverride.java"}],"sha":"761df6a46707b0116a1d9f44be083c8651922e00"},{"commit":{"message":"Refactor Utils.overriddenMethod"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"5ccf850b45e5059d31de9cd51ca9be06e861d90a"},{"commit":{"message":"Consolidate Utils.{overriddenMethod,overriddenType}"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"eaa360b153217a5e1b28e1d286dd1dfb0920d26a"},{"commit":{"message":"Simplify Utils.getFirstVisibleSuperClass\n\nAdd guarding asserts for now."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"5c69b2f6699f231bdc8990b38087e26840a6b175"},{"commit":{"message":"Simplify Utils.getFirstVisibleSuperClass"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"3c59145a978e7ab24d5e8bb3abb5e57d2fd210eb"},{"commit":{"message":"! Simplify Utils.getFirstVisibleSuperClass\n\nNot sure why it was checking for qualified names; perhaps, to avoid\nloops, which seem to be guarding against broken source. Loops are\nmore robustly detected by maintaining a set of already seen\nTypeElements.\n\nAnyway, tests pass.\n\nThe good news is that some classes now show better type hierarchy.\nFor example:\n\n    Class ByteVector\n\n    java.lang.Object\n      jdk.incubator.vector.Vector<Byte>\n                           ^^^^^^^^^^^^\n        jdk.incubator.vector.ByteVector\n\n    public abstract class ByteVector\n    extends Vector<Byte>\n            ^^^^^^^^^^^^\n\nThis is similar to what interfaces already had:\n\n    Class StringBuilder\n\n    java.lang.Object\n      java.lang.StringBuilder\n\n    All Implemented Interfaces:\n    Serializable, Appendable, CharSequence, Comparable<StringBuilder>\n                                            ^^^^^^^^^^^^^^^^^^^^^^^^^"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"3336221b437188b971ae0a696193950d5e4d6033"},{"commit":{"message":"Simplify Utils.getFirstVisibleSuperClass\n\n* The removed `typeUtils.isSameType(type, superType)` condition was\nhistorically guarding from passing interfaces or reaching\njava.lang.Object. Both cases are handled differently now. Because\nthe condition had no effect, it was removed. However, when removed,\na couple of issues surfaced and were captured as 8302545 and 8302542.\n\nUntil either 8302545 has been resolved or --ignore-source-errors has\nbeen removed, I slightly amended containingModule and containingPackage\nmethods to account for possible RootPackageSymbol being passed.\n\nAmending Utils.containingPackage was NOT necessary, but was done for\nrobustness.\n\nNot sure how relevant it is to run javadoc with --ignore-source-errors\nthough. Again: people should not run javadoc on source that does not\ncompile. But if they run, javadoc should fail-fast and not try to\nrecover and proceed no matter what.\n\n* Fixed a typo in the IgnoreSourceErrors test. (FWIW, there used to be\n\"ignore-errors\" options in AOT and build.)"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"},{"filename":"test\/langtools\/jdk\/javadoc\/tool\/IgnoreSourceErrors.java"}],"sha":"67047490ea5718d35bb3c282474b78a81f661b7d"},{"commit":{"message":"Remove now-unused Utils.isNoType"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"7cc61af7204ea5a767ebc14ed9bae288dca1bb34"},{"commit":{"message":"Simplify Utils.overriddenMethod\n\nRemoves misleading getSuperType, which returned java.lang.Object if\npassed java.lang.Object."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"750d3e81e1b145d1c9cbe6ad3585d4f0645cf9ed"},{"commit":{"message":"Increase test coverage\n\nTests for interface methods that override java.lang.Object methods."},"files":[{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/pkg3\/I.java"}],"sha":"6c9c46c67612d9d50bd9b2ea48053db17e816e5c"},{"commit":{"message":"Don't care about static \"overrides\"\n\nTrust jx.l.m to filter those out and user not to run javadoc on\nnon-compiling source."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"e44c70757fd367acad2f350c2e948bdabe2d1fc2"},{"commit":{"message":"Inline Utils.getType"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"e1a3d82dbf107f02b1ae9b61896be6259d6dcda1"},{"commit":{"message":"Refactor ImplementedMethods"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"e29cb158839df976562bd12c91b1dbdb0ced20d7"},{"commit":{"message":"Remove redundant data structure\n\nTo simplify reasoning."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"60ea5dbfcd8a46eb60b4082c014ad9f96c4f9959"},{"commit":{"message":"Refactor ImplementedMethods"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"5a27e177647958393d48e9646bac2bacd58784f5"},{"commit":{"message":"Simplify ImplementedMethods"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"0683c9e26144fb7fcf6d72f6505c669c75ec9b07"},{"commit":{"message":"Rename and simplify findMethod further"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"c198b61398518bd0da1dcc25cd69c40cfe52a415"},{"commit":{"message":"Simplify findMethod"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"6a40e1f7acebbf8d529da88c8b0c8e3519165c35"},{"commit":{"message":"Inline executableMembersEqual"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"2c3e29fe12f5e22e83eb4a2a2b420ca80cac3e39"},{"commit":{"message":"Move methods from Utils to VisibleMemberTable (1)\n\nThose methods are used only by VisibleMemberTable."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"38543d27d2ac6fbdfdb72306f400861dc3034b49"},{"commit":{"message":"! Do not \"implement\" static, interface methods\n\nThis commit obsoletes 8186693.\n\nA static method of an interface can neither be inherited nor hidden:\nJLS 8.4.8, 8.4.8.2, 9.1.3.\n\nThe only affected test is fixed, but the results of `make docs`\nslightly differ. This is because before this fix, @see tags were\n\"inherited\" from \"hidden\" static methods of interfaces.\n\nHere's the list of affected files in the JDK documentation:\n\n  java.base\/java\/time\n    LocalDate.html\n    LocalDateTime.html\n    ZonedDateTime.html\n  java.base\/java\/time\/chrono\n    HijrahDate.html\n    JapaneseDate.html\n    MinguoDate.html\n    ThaiBuddhistDate.html\n\nThe \"inherited\" method in all of those files is:\n\n    public static LocalDate from(TemporalAccessor temporal)\n\nWhile propagating @see information across static methods might be\nuseful and\/or desirable behaviour, it's linked to an incorrect code,\nwhich had to be fixed. If that behavior needs to be re-introduced,\nwe should investigate it separately.\n\nFWIW, the symptoms of documentation inheritance, such as appearance of\n\"Description copied from\" and inheriting @see information, do NOT\nappear even for a validly hidden method: a static method of a class.\nSo more reasons to fix it for invalidly hidden methods.\n\nArchaeologically relevant bug fixes: 8139101, 8186703."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java"}],"sha":"35988a82a575ba44bac1dd1742b60a48a0209e27"},{"commit":{"message":"Make isNotSimpleOverride private"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"21077cca8a16deccddb767c83609625eb9e8e14a"},{"commit":{"message":"Rename OverriddenMethodInfo"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"92462ea4692a92c6fe9aba64a0fe1e70558b8e1a"},{"commit":{"message":"Incrementally clarify"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"8eb155158709d76cd6da9d6f7c14a87a9a3a2db3"},{"commit":{"message":"Rename and clarify, add temporary FIXMEs\n\nRenames some variables and methods, removes or clarifies some comments."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"c2a9c06ac8ebf68503fa7f02a7d454efc159d85e"},{"commit":{"message":"Inline Utils.getSuperClass\n\nThat method is solely used by VisibleMemberTable."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"69ea5fe104c6c2bbcda683f6328c92e89b96d405"},{"commit":{"message":"Simplify Utils.getSuperClass\n\nSimplification is based on jx.l.m and JLS itself:\n\n  1. Any class except for java.lang.Object has a superclass\n  2. An interface or the java.lang.Object class has NoType(kind=NONE)\n     as the superclass type\n  3. Element of NoType is null"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"1281d4e4cd8b6559fe0966bf2d16799cc323aebf"},{"commit":{"message":"Remove useless Map.getOrDefault"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"aaffc540642d76a06f2a09f52bc10f890011c7db"},{"commit":{"message":"Make some members private\n\nWhile those members are used privately anyway, making them officially\nprivate aids reasoning when reading code.\n\nThis commit also fixes a few whitespace issues."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"656399bfe63cc12a14a3b1ea0241644a94173232"},{"commit":{"message":"Add missing and clarify existing comments\n\nDoes not change code for now; just comments it."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"a6537d203c8271772f35bb959abf0c23b4c00b91"},{"commit":{"message":"Fix a typo in an option name"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolOptions.java"}],"sha":"b059107c0b24cd35c3cc3219395638977a453548"},{"commit":{"message":"Clarify what an \"included\" element is\n\nThe original sentence lacked a comma that when added still didn't make\nthe sentence clear:\n\n> if it is specified if it contains a specified\n\nThis commit restructures that sentence to clarify that \"is selected\"\nrelates to all selection alternatives (1), not just the last one (2):\n\n1. (specified OR nests-specified OR nested-in-specified) AND selected\n2. specified OR nests-specified OR (nested-in-specified AND selected)\n\nThe following locations corroborate that the restructured sentence (1)\nis accurate:\n\n * jdk\/javadoc\/internal\/tool\/ElementsTable.java:1048\n   Covers (i) is a specified element and (ii) is enclosed in a\n   specified element\n * (??? need to find what covers (iii) contains a specified element)"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/doclet\/package-info.java"}],"sha":"ff68a3e680a79f9e316e8e98b40c4fb56ae224e1"}]