{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,4 +82,7 @@\n- *   <dd>An element is considered to be <em>included<\/em>, if it is\n- *       <em>specified<\/em> if it contains a <em>specified<\/em> element,\n- *       or it is enclosed in a <em>specified<\/em> element, and is <em>selected<\/em>.\n- *       Included elements will be documented.\n+ *   <dd>An element is considered to be <em>included<\/em>, if it is <em>selected<\/em> and any of the following is true:\n+ *     <ul>\n+ *       <li>the element is <em>specified<\/em>, or\n+ *       <li>the element contains a <em>specified<\/em> element, or\n+ *       <li>the element is enclosed in a <em>specified<\/em> element.\n+ *     <\/ul>\n+ *     Included elements will be documented.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/doclet\/package-info.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -292,17 +292,24 @@\n-        TypeElement enclosing = utils.getEnclosingTypeElement(method);\n-        List<? extends TypeMirror> intfacs = enclosing.getInterfaces();\n-        ExecutableElement overriddenMethod = utils.overriddenMethod(method);\n-        VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);\n-        \/\/ Check whether there is any implementation or overridden info to be\n-        \/\/ printed. If no overridden or implementation info needs to be\n-        \/\/ printed, do not print this section.\n-        if ((!intfacs.isEmpty()\n-                && !vmt.getImplementedMethods(method).isEmpty())\n-                || overriddenMethod != null) {\n-            MethodWriterImpl.addImplementsInfo(this, method, dl);\n-            if (overriddenMethod != null) {\n-                MethodWriterImpl.addOverridden(this,\n-                        utils.overriddenType(method),\n-                        overriddenMethod,\n-                        dl);\n-            }\n+        var enclosing = (TypeElement) method.getEnclosingElement();\n+        var overrideInfo = utils.overriddenMethod(method);\n+        var enclosingVmt = configuration.getVisibleMemberTable(enclosing);\n+        var implementedMethods = enclosingVmt.getImplementedMethods(method);\n+        if ((!enclosing.getInterfaces().isEmpty()\n+                && !implementedMethods.isEmpty())\n+                || overrideInfo != null) {\n+            \/\/ TODO note that if there are any overridden interface methods throughout the\n+            \/\/   hierarchy, !enclosingVmt.getImplementedMethods(method).isEmpty(), their information\n+            \/\/   will be printed if *any* of the below is true:\n+            \/\/     * the enclosing has _directly_ implemented interfaces\n+            \/\/     * the overridden method is not null\n+            \/\/   If both are false, the information will not be printed: there will be no\n+            \/\/   \"Specified by\" documentation. The examples of that can be seen in documentation\n+            \/\/   for these methods:\n+            \/\/     * ForkJoinPool.execute(java.lang.Runnable)\n+            \/\/  This is a long-standing bug, which must be fixed separately: JDK-8302316\n+            MethodWriterImpl.addImplementsInfo(this, method, implementedMethods, dl);\n+        }\n+        if (overrideInfo != null) {\n+            MethodWriterImpl.addOverridden(this,\n+                    overrideInfo.overriddenMethodOwner(),\n+                    overrideInfo.overriddenMethod(),\n+                    dl);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Collection;\n@@ -296,3 +297,4 @@\n-     * @param writer the writer for the method\n-     * @param method the method\n-     * @param dl     the definition list\n+     * @param writer  the writer for the method\n+     * @param method  the method\n+     * @param methods implemented methods\n+     * @param dl      the definition list\n@@ -302,0 +304,1 @@\n+                                            Collection<ExecutableElement> methods,\n@@ -304,1 +307,1 @@\n-        if (utils.isStatic(method) || writer.options.noComment()) {\n+        if (writer.options.noComment()) {\n@@ -308,2 +311,2 @@\n-        VisibleMemberTable vmt = writer.configuration\n-                .getVisibleMemberTable(utils.getEnclosingTypeElement(method));\n+        var enclosing = (TypeElement) method.getEnclosingElement();\n+        VisibleMemberTable vmt = writer.configuration.getVisibleMemberTable(enclosing);\n@@ -312,1 +315,1 @@\n-        implementedMethods.addAll(vmt.getImplementedMethods(method));\n+        implementedMethods.addAll(methods);\n@@ -315,1 +318,1 @@\n-            intfac = utils.getDeclaredType(utils.getEnclosingTypeElement(method), intfac);\n+            intfac = utils.getDeclaredType(enclosing, intfac);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -576,1 +576,1 @@\n-                if (overriddenMethod != null)\n+                if (overriddenMethod != null) {\n@@ -578,0 +578,1 @@\n+                }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,68 +197,0 @@\n-    \/\/ TODO:  need to re-implement this using j.l.m. correctly!, this has\n-    \/\/        implications on testInterface, the note here is that javac's supertype\n-    \/\/        does the right thing returning Parameters in scope.\n-    \/*\n-     * Returns the closest superclass (not the superinterface) that contains\n-     * a method that is both:\n-     *\n-     *   - overridden by the specified method, and\n-     *   - is not itself a *simple* override\n-     *\n-     * If no such class can be found, returns null.\n-     *\n-     * If the specified method belongs to an interface, the only considered\n-     * superclass is java.lang.Object no matter how many other interfaces\n-     * that interface extends.\n-     *\/\n-    public DeclaredType overriddenType(ExecutableElement method) {\n-        if (utils.isStatic(method)) {\n-            return null;\n-        }\n-        MethodSymbol sym = (MethodSymbol) method;\n-        ClassSymbol origin = (ClassSymbol) sym.owner;\n-        for (Type t = javacTypes.supertype(origin.type);\n-             t.hasTag(TypeTag.CLASS);\n-             t = javacTypes.supertype(t)) {\n-            ClassSymbol c = (ClassSymbol) t.tsym;\n-            for (Symbol sym2 : c.members().getSymbolsByName(sym.name)) {\n-                if (sym.overrides(sym2, origin, javacTypes, true)) {\n-                    \/\/ Ignore those methods that may be a simple override\n-                    \/\/ and allow the real API method to be found.\n-                    if (utils.isSimpleOverride((MethodSymbol)sym2)) {\n-                        continue;\n-                    }\n-                    assert t.hasTag(TypeTag.CLASS) && !t.isInterface();\n-                    return (Type.ClassType) t;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/\/ TODO: the method jx.l.m.Elements::overrides does not check\n-    \/\/ the return type, see JDK-8174840 until that is resolved,\n-    \/\/ use a  copy of the same method, with a return type check.\n-\n-    \/\/ Note: the rider.overrides call in this method *must* be consistent\n-    \/\/ with the call in overrideType(....), the method above.\n-    public boolean overrides(ExecutableElement e1, ExecutableElement e2, TypeElement cls) {\n-        MethodSymbol rider = (MethodSymbol)e1;\n-        MethodSymbol ridee = (MethodSymbol)e2;\n-        ClassSymbol origin = (ClassSymbol)cls;\n-\n-        return rider.name == ridee.name &&\n-\n-               \/\/ not reflexive as per JLS\n-               rider != ridee &&\n-\n-               \/\/ we don't care if ridee is static, though that wouldn't\n-               \/\/ compile\n-               !rider.isStatic() &&\n-\n-               \/\/ Symbol.overrides assumes the following\n-               ridee.isMemberOf(origin, javacTypes) &&\n-\n-               \/\/ check access, signatures and check return types\n-               rider.overrides(ridee, origin, javacTypes, true);\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -188,57 +188,0 @@\n-    \/**\n-     * Search for the given method in the given class.\n-     *\n-     * @param te     Class to search into.\n-     * @param method Method to be searched.\n-     *\n-     * @return Method found, null otherwise.\n-     *\/\n-    public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {\n-        for (ExecutableElement m : getMethods(te)) {\n-            if (executableMembersEqual(method, m)) {\n-                return m;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Test whether a class is a subclass of another class.\n-     *\n-     * @param t1 the candidate subclass\n-     * @param t2 the candidate superclass\n-     * @return true if t1 is a superclass of t2\n-     *\/\n-    public boolean isSubclassOf(TypeElement t1, TypeElement t2) {\n-        return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));\n-    }\n-\n-    \/**\n-     * @param e1 the first method to compare.\n-     * @param e2 the second method to compare.\n-     * @return true if member1 overrides\/hides or is overridden\/hidden by member2.\n-     *\/\n-    public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {\n-        \/\/ TODO: investigate if Elements.hides(..) will work here.\n-        if (isStatic(e1) && isStatic(e2)) {\n-            List<? extends VariableElement> parameters1 = e1.getParameters();\n-            List<? extends VariableElement> parameters2 = e2.getParameters();\n-            if (e1.getSimpleName().equals(e2.getSimpleName()) &&\n-                    parameters1.size() == parameters2.size()) {\n-                for (int j = 0; j < parameters1.size(); j++) {\n-                    VariableElement v1 = parameters1.get(j);\n-                    VariableElement v2 = parameters2.get(j);\n-                    if (!typeUtils.isSameType(v1.asType(), v2.asType())) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-            return false;\n-        } else {\n-            return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||\n-                    elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||\n-                    e1.equals(e2);\n-        }\n-    }\n-\n@@ -336,0 +279,8 @@\n+    \/*\n+     * A contemporary JLS term for \"package private\" or \"default access\" is\n+     * \"package access\". For example: \"a member is declared with package\n+     * access\" or \"a member has package access\".\n+     *\n+     * This is to avoid confusion with unrelated _default_ methods which\n+     * appeared in JDK 8.\n+     *\/\n@@ -337,1 +288,4 @@\n-        return !(isPublic(e) || isPrivate(e) || isProtected(e));\n+        var m = e.getModifiers();\n+        return !m.contains(Modifier.PUBLIC)\n+                && !m.contains(Modifier.PROTECTED)\n+                && !m.contains(Modifier.PRIVATE);\n@@ -426,4 +380,0 @@\n-    public boolean isNoType(TypeMirror t) {\n-        return t.getKind() == NONE;\n-    }\n-\n@@ -663,0 +613,3 @@\n+    public record OverrideInfo(ExecutableElement overriddenMethod,\n+                               DeclaredType overriddenMethodOwner) { }\n+\n@@ -664,0 +617,5 @@\n+     * The record is used to pass the method along with the type where that method is visible.\n+     * Passing the type explicitly allows to preserve a complete type information, including\n+     * parameterization, which is otherwise unavailable without computation similar to what\n+     * this method does.\n+     *\n@@ -676,23 +634,8 @@\n-    public DeclaredType overriddenType(ExecutableElement method) {\n-        return configuration.workArounds.overriddenType(method);\n-    }\n-\n-    private  TypeMirror getType(TypeMirror t) {\n-        return (isNoType(t)) ? getObjectType() : t;\n-    }\n-\n-    public TypeMirror getSuperType(TypeElement te) {\n-        TypeMirror t = te.getSuperclass();\n-        return getType(t);\n-    }\n-\n-    public ExecutableElement overriddenMethod(ExecutableElement method) {\n-        if (isStatic(method)) {\n-            return null;\n-        }\n-        final TypeElement origin = getEnclosingTypeElement(method);\n-        for (TypeMirror t = getSuperType(origin);\n-             t.getKind() == DECLARED;\n-             t = getSuperType(asTypeElement(t))) {\n-            TypeElement te = asTypeElement(t);\n-            if (te == null) {\n+    public OverrideInfo overriddenMethod(ExecutableElement method) {\n+        var t = method.getEnclosingElement().asType();\n+        \/\/ in this context, consider java.lang.Object to be the superclass of an interface\n+        while (true) {\n+            var supertypes = typeUtils.directSupertypes(t);\n+            if (supertypes.isEmpty()) {\n+                \/\/ reached the top of the hierarchy\n+                assert typeUtils.isSameType(getObjectType(), t);\n@@ -701,0 +644,4 @@\n+            t = supertypes.get(0);\n+            \/\/ if non-empty, the first element is always the superclass\n+            var te = (TypeElement) ((DeclaredType) t).asElement();\n+            assert te.getKind().isClass();\n@@ -703,2 +650,2 @@\n-                ExecutableElement ee = (ExecutableElement)e;\n-                if (configuration.workArounds.overrides(method, ee, origin) &&\n+                var ee = (ExecutableElement) e;\n+                if (elementUtils.overrides(method, ee, (TypeElement) method.getEnclosingElement()) &&\n@@ -706,1 +653,1 @@\n-                    return ee;\n+                    return new OverrideInfo(ee, (DeclaredType) t);\n@@ -709,2 +656,0 @@\n-            if (typeUtils.isSameType(t, getObjectType()))\n-                return null;\n@@ -712,1 +657,0 @@\n-        return null;\n@@ -1066,11 +1010,0 @@\n-    public TypeElement getSuperClass(TypeElement te) {\n-        if (checkType(te)) {\n-            return null;\n-        }\n-        TypeMirror superclass = te.getSuperclass();\n-        if (isNoType(superclass) && isClass(te)) {\n-            superclass = getObjectType();\n-        }\n-        return asTypeElement(superclass);\n-    }\n-\n@@ -1096,17 +1029,16 @@\n-        List<? extends TypeMirror> superTypes = typeUtils.directSupertypes(type);\n-        TypeMirror superType = superTypes.isEmpty() ? getObjectType() : superTypes.get(0);\n-        TypeElement superClass = asTypeElement(superType);\n-        \/\/ skip \"hidden\" classes\n-        while ((superClass != null && hasHiddenTag(superClass))\n-                || (superClass != null &&  !isPublic(superClass) && !isLinkable(superClass))) {\n-            TypeMirror supersuperType = superClass.getSuperclass();\n-            TypeElement supersuperClass = asTypeElement(supersuperType);\n-            if (supersuperClass == null\n-                    || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {\n-                break;\n-            }\n-            superType = supersuperType;\n-            superClass = supersuperClass;\n-        }\n-        if (typeUtils.isSameType(type, superType)) {\n-            return null;\n+        \/\/ TODO: this computation should be eventually delegated to VisibleMemberTable\n+        Set<TypeElement> alreadySeen = null;\n+        \/\/ create a set iff assertions are enabled, to assert that no class\n+        \/\/ appears more than once in a superclass hierarchy\n+        assert (alreadySeen = new HashSet<>()) != null;\n+        for (var t = type; ;) {\n+            var supertypes = typeUtils.directSupertypes(t);\n+            if (supertypes.isEmpty()) { \/\/ end of hierarchy\n+                return null;\n+            }\n+            t = supertypes.get(0); \/\/ if non-empty, the first element is always the superclass\n+            var te = asTypeElement(t);\n+            assert alreadySeen.add(te); \/\/ it should be the first time we see `te`\n+            if (!hasHiddenTag(te) && (isPublic(te) || isLinkable(te))) {\n+                return t;\n+            }\n@@ -1114,1 +1046,0 @@\n-        return superType;\n@@ -1117,1 +1048,0 @@\n-\n@@ -2459,0 +2389,6 @@\n+        \/\/ TODO: remove this short-circuit after JDK-8302545 has been fixed\n+        \/\/  or --ignore-source-errors has been removed\n+        if (e.getKind() == ElementKind.PACKAGE\n+                && e.getEnclosingElement() == null) {\n+            return null;\n+        }\n@@ -2463,0 +2399,5 @@\n+        \/\/ TODO: remove this short-circuit after JDK-8302545 has been fixed\n+        \/\/  or --ignore-source-errors has been removed\n+        if (e.getKind() == ElementKind.PACKAGE) {\n+            return (PackageElement) e;\n+        }\n@@ -2806,1 +2747,4 @@\n-        return new DocFinder(this::overriddenMethod, this::implementedMethods);\n+        return new DocFinder(e -> {\n+            var i = overriddenMethod(e);\n+            return i == null ? null : i.overriddenMethod();\n+        }, this::implementedMethods);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":66,"deletions":122,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -144,0 +144,1 @@\n+    \/** The class or interface described by this table. *\/\n@@ -145,0 +146,4 @@\n+    \/**\n+     * The superclass of {@link #te} or null if {@code te} is an\n+     * interface or {@code java.lang.Object}.\n+     *\/\n@@ -152,0 +157,1 @@\n+    \/** Tables for direct and indirect superclasses. *\/\n@@ -153,0 +159,4 @@\n+    \/**\n+     * Tables for direct and indirect superinterfaces.\n+     * Tables for superinterfaces might not be unique.\n+     *\/\n@@ -154,0 +164,7 @@\n+    \/**\n+     * Tables for direct superclass and direct superinterfaces.\n+     *\n+     * The position of a table for the superclass in the list is unspecified.\n+     * Tables for the superinterfaces might not be unique (i.e. an interface\n+     * may be added from different lineages).\n+     *\/\n@@ -159,2 +176,6 @@\n-    \/\/ Keeps track of method overrides\n-    private final Map<ExecutableElement, OverriddenMethodInfo> overriddenMethodTable\n+    \/\/  FIXME: Figure out why it is one-one and not one-to-many.\n+    \/**\n+     * Maps a method m declared in {@code te} to a visible method m' in a\n+     * {@code te}'s supertype such that m overrides m'.\n+     *\/\n+    private final Map<ExecutableElement, OverrideInfo> overriddenMethodTable\n@@ -169,1 +190,1 @@\n-        parent = utils.getSuperClass(te);\n+        parent = (TypeElement) utils.typeUtils.asElement(te.getSuperclass());\n@@ -188,1 +209,1 @@\n-    List<VisibleMemberTable> getAllSuperclasses() {\n+    private List<VisibleMemberTable> getAllSuperclasses() {\n@@ -193,1 +214,1 @@\n-    List<VisibleMemberTable> getAllSuperinterfaces() {\n+    private List<VisibleMemberTable> getAllSuperinterfaces() {\n@@ -230,1 +251,0 @@\n-\n@@ -264,3 +284,11 @@\n-     * Returns the overridden method, if it is simply overriding or the\n-     * method is a member of a package private type, this method is\n-     * primarily used to determine the location of a possible comment.\n+     * Returns the method overridden by the provided method, or {@code null}.\n+     *\n+     * Sometimes it's not possible to link to a method that a link, linkplain,\n+     * or see tag mentions. This is because the method is a \"simple override\"\n+     * and, thus, has no useful documentation, or because the method is\n+     * declared in a type that has package access and, thus, has no visible\n+     * documentation.\n+     *\n+     * Call this method to determine if any of the above is the case. If the\n+     * call returns a method element, link to that method element instead of\n+     * the provided method.\n@@ -269,1 +297,1 @@\n-     * @return the method found or null\n+     * @return the method found or {@code null}\n@@ -272,0 +300,1 @@\n+        \/\/ TODO: consider possible ambiguities: multiple overridden methods\n@@ -273,2 +302,2 @@\n-\n-        OverriddenMethodInfo found = overriddenMethodTable.get(e);\n+        assert !overriddenMethodTable.containsKey(null);\n+        OverrideInfo found = overriddenMethodTable.get(e);\n@@ -288,1 +317,1 @@\n-    public boolean isNotSimpleOverride(ExecutableElement e) {\n+    private boolean isNotSimpleOverride(ExecutableElement e) {\n@@ -423,1 +452,1 @@\n-            \/\/ Add direct superinterfaces of a superclass, if any.\n+            \/\/ Add direct and indirect superinterfaces of a superclass.\n@@ -472,1 +501,1 @@\n-        return isInherited(e) && !isMemberHidden(e, kind, lmt);\n+        return isAccessible(e) && !isMemberHidden(e, kind, lmt);\n@@ -475,1 +504,1 @@\n-    private boolean isInherited(Element e) {\n+    private boolean isAccessible(Element e) {\n@@ -519,0 +548,11 @@\n+    \/\/ This method computes data structures related to method members\n+    \/\/ of a class or an interface.\n+    \/\/\n+    \/\/ TODO The computation is performed manually, by applying JLS rules.\n+    \/\/  While jdk.javadoc does need custom and specialized data structures,\n+    \/\/  this method does not feel DRY. It should be possible to improve\n+    \/\/  it by delegating some, if not most, of the JLS wrestling to\n+    \/\/  javax.lang.model. For example, while it cannot help us get the\n+    \/\/  structures, such as overriddenMethodTable, javax.lang.model can\n+    \/\/  help us get all method members of a class or an interface t by calling\n+    \/\/  ElementFilter.methodsIn(Elements.getAllMembers(t)).\n@@ -520,1 +560,23 @@\n-        Set<Element> inheritedMethods = new LinkedHashSet<>();\n+        \/\/ parentMethods is a union of visible methods from all parents.\n+        \/\/ It is used to figure out which methods this type should inherit.\n+        \/\/ Inherited methods are those parent methods that remain after all\n+        \/\/ methods that cannot be inherited are eliminated.\n+        Set<Element> parentMethods = new LinkedHashSet<>();\n+        for (var p : parents) {\n+            \/\/ Lists of visible methods from different parents may share some\n+            \/\/ methods. These are the methods that the parents inherited from\n+            \/\/ their common ancestor.\n+            \/\/\n+            \/\/ Such methods won't result in duplicates in parentMethods as we\n+            \/\/ purposefully don't track duplicates.\n+            \/\/ FIXME: add a test to assert the order (LinkedHashSet)\n+            parentMethods.addAll(p.getAllVisibleMembers(Kind.METHODS));\n+        }\n+\n+        \/\/ overriddenByTable maps an ancestor (grandparent and above) method\n+        \/\/ to parent methods that override it:\n+        \/\/\n+        \/\/ key\n+        \/\/ : a method overridden by one or more parent methods\n+        \/\/ value\n+        \/\/ : a list of parent methods that override the key\n@@ -522,1 +584,1 @@\n-        for (VisibleMemberTable pvmt : parents) {\n+        for (var p : parents) {\n@@ -524,1 +586,1 @@\n-            pvmt.overriddenMethodTable.forEach((method, methodInfo) -> {\n+            p.overriddenMethodTable.forEach((method, methodInfo) -> {\n@@ -526,1 +588,1 @@\n-                    List<ExecutableElement> list = overriddenByTable.computeIfAbsent(methodInfo.overriddenMethod,\n+                    var list = overriddenByTable.computeIfAbsent(methodInfo.overriddenMethod,\n@@ -531,1 +593,0 @@\n-            inheritedMethods.addAll(pvmt.getAllVisibleMembers(Kind.METHODS));\n@@ -534,5 +595,2 @@\n-        \/\/ Filter out inherited methods that:\n-        \/\/ a. cannot be overridden (private instance members)\n-        \/\/ b. are overridden and should not be visible in this type\n-        \/\/ c. are hidden in the type being considered\n-        \/\/ see allowInheritedMethod, which performs the above actions\n+        \/\/ filter out methods that aren't inherited\n+        \/\/\n@@ -542,1 +600,1 @@\n-        List<Element> inheritedMethodsList = inheritedMethods.stream()\n+        List<Element> inheritedMethods = parentMethods.stream()\n@@ -546,6 +604,4 @@\n-        \/\/ Filter out the local methods, that do not override or simply\n-        \/\/ overrides a super method, or those methods that should not\n-        \/\/ be visible.\n-        Predicate<ExecutableElement> isVisible = m -> {\n-            OverriddenMethodInfo p = overriddenMethodTable.getOrDefault(m, null);\n-            return p == null || !p.simpleOverride;\n+        \/\/ filter out \"simple overrides\" from local methods\n+        Predicate<ExecutableElement> nonSimpleOverride = m -> {\n+            OverrideInfo i = overriddenMethodTable.get(m);\n+            return i == null || !i.simpleOverride;\n@@ -557,1 +613,1 @@\n-                .filter(isVisible);\n+                .filter(nonSimpleOverride);\n@@ -561,1 +617,2 @@\n-        List<Element> list = Stream.concat(localStream, inheritedMethodsList.stream())\n+        \/\/ FIXME add a test to assert the order or remove that part of the comment above ^\n+        List<Element> list = Stream.concat(localStream, inheritedMethods.stream())\n@@ -567,1 +624,1 @@\n-        \/\/ Copy over overridden tables from the lineage, and finish up.\n+        \/\/ copy over overridden tables from the lineage\n@@ -569,0 +626,7 @@\n+            \/\/ a key in overriddenMethodTable is a method _declared_ in the respective parent;\n+            \/\/ no two _different_ parents can share a declared method, by definition;\n+            \/\/ if parents in the list are different (i.e. the list of parents doesn't contain duplicates),\n+            \/\/   then no keys are equal and thus no replace happens\n+            \/\/ if the list of parents contains duplicates, values for the equal keys are equal,\n+            \/\/   so no harm if they are replaced in the map\n+            assert putAllIsNonReplacing(overriddenMethodTable, pvmt.overriddenMethodTable);\n@@ -573,3 +637,8 @@\n-    boolean isEnclosureInterface(Element e) {\n-        TypeElement enclosing = utils.getEnclosingTypeElement(e);\n-        return utils.isPlainInterface(enclosing);\n+    private static <K, V> boolean putAllIsNonReplacing(Map<K, V> dst, Map<K, V> src) {\n+        for (var e : src.entrySet()) {\n+            if (dst.containsKey(e.getKey())\n+                    && !Objects.equals(dst.get(e.getKey()), e.getValue())) {\n+                return false;\n+            }\n+        }\n+        return true;\n@@ -578,4 +647,16 @@\n-    boolean allowInheritedMethod(ExecutableElement inheritedMethod,\n-                                 Map<ExecutableElement, List<ExecutableElement>> overriddenByTable,\n-                                 LocalMemberTable lmt) {\n-        if (!isInherited(inheritedMethod))\n+    private boolean allowInheritedMethod(ExecutableElement inheritedMethod,\n+                                         Map<ExecutableElement, List<ExecutableElement>> overriddenByTable,\n+                                         LocalMemberTable lmt) {\n+        \/\/ JLS 8.4.8: A class does not inherit private or static methods from\n+        \/\/ its superinterface types.\n+        \/\/\n+        \/\/ JLS 9.4.1: An interface does not inherit private or static methods\n+        \/\/ from its superinterfaces.\n+        \/\/\n+        \/\/ JLS 8.4.8: m is public, protected, or declared with package access\n+        \/\/ in the same package as C\n+        \/\/\n+        \/\/ JLS 9.4: A method in the body of an interface declaration may be\n+        \/\/ declared public or private. If no access modifier is given, the\n+        \/\/ method is implicitly public.\n+        if (!isAccessible(inheritedMethod))\n@@ -585,1 +666,1 @@\n-        final boolean inInterface = isEnclosureInterface(inheritedMethod);\n+        final boolean inInterface = isDeclaredInInterface(inheritedMethod);\n@@ -587,1 +668,1 @@\n-        \/\/ Static methods in interfaces are never documented.\n+        \/\/ Static interface methods are never inherited (JLS 8.4.8 and 9.1.3)\n@@ -604,1 +685,1 @@\n-                        .anyMatch(this::isEnclosureInterface);\n+                        .anyMatch(this::isDeclaredInInterface);\n@@ -613,0 +694,1 @@\n+        \/\/ List contains overloads and probably something else, but one match is enough, hence short-circuiting\n@@ -617,1 +699,1 @@\n-            \/\/ a \"hidden\" tag.\n+            \/\/ a \"hidden\" tag. \/\/ FIXME I cannot see where @hidden is ignored\n@@ -631,0 +713,2 @@\n+                assert utils.getEnclosingTypeElement(lMethod).equals(te);\n+\n@@ -634,0 +718,3 @@\n+                    \/\/ FIXME\n+                    \/\/  is simpleOverride=false here to force to be used because\n+                    \/\/  it cannot be linked to, because package-private?\n@@ -635,1 +722,1 @@\n-                            l -> new OverriddenMethodInfo(inheritedMethod, false));\n+                            l -> new OverrideInfo(inheritedMethod, false));\n@@ -647,1 +734,1 @@\n-                        l -> new OverriddenMethodInfo(inheritedMethod, simpleOverride));\n+                        l -> new OverrideInfo(inheritedMethod, simpleOverride));\n@@ -654,0 +741,4 @@\n+    private boolean isDeclaredInInterface(ExecutableElement e) {\n+        return e.getEnclosingElement().getKind() == ElementKind.INTERFACE;\n+    }\n+\n@@ -739,1 +830,1 @@\n-     * This class encapsulates the details of local members, orderedMembers\n+     * This class encapsulates the details of local members. orderedMembers\n@@ -741,1 +832,1 @@\n-     * HashMap is maintained for performance optimization to lookup\n+     * HashMap is maintained for performance optimization to look up\n@@ -757,1 +848,1 @@\n-\n+            \/\/ elements directly declared by te\n@@ -786,1 +877,1 @@\n-                            addMember(e, Kind.CONSTRUCTORS);\n+                        addMember(e, Kind.CONSTRUCTORS);\n@@ -857,2 +948,2 @@\n-    record PropertyMembers(ExecutableElement propertyMethod, VariableElement field,\n-                           ExecutableElement getter, ExecutableElement setter) { }\n+    private record PropertyMembers(ExecutableElement propertyMethod, VariableElement field,\n+                                   ExecutableElement getter, ExecutableElement setter) { }\n@@ -991,15 +1082,25 @@\n-        private final Map<ExecutableElement, TypeMirror> interfaces = new HashMap<>();\n-        private final LinkedHashSet<ExecutableElement> methods = new LinkedHashSet<>();\n-\n-        public ImplementedMethods(ExecutableElement method) {\n-            \/\/ ExecutableElement.getEnclosingElement() returns \"the class or\n-            \/\/ interface defining the executable\", which has to be TypeElement\n-            TypeElement typeElement = (TypeElement) method.getEnclosingElement();\n-            Set<TypeMirror> intfacs = utils.getAllInterfaces(typeElement);\n-            for (TypeMirror interfaceType : intfacs) {\n-                \/\/ TODO: this method also finds static methods which are pseudo-inherited;\n-                \/\/  this needs to be fixed\n-                ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);\n-                if (found != null && !methods.contains(found)) {\n-                    methods.add(found);\n-                    interfaces.put(found, interfaceType);\n+        private final Map<ExecutableElement, TypeMirror> interfaces = new LinkedHashMap<>();\n+\n+        public ImplementedMethods(ExecutableElement implementer) {\n+            var typeElement = (TypeElement) implementer.getEnclosingElement();\n+            for (TypeMirror i : utils.getAllInterfaces(typeElement)) {\n+                TypeElement dst = utils.asTypeElement(i); \/\/ a type element to look an implemented method in\n+                ExecutableElement implemented = findImplementedMethod(dst, implementer);\n+                if (implemented == null) {\n+                    continue;\n+                }\n+                var prev = interfaces.put(implemented, i);\n+                \/\/ no two type elements declare the same method\n+                assert prev == null;\n+                \/\/ dst can be generic, while i might be parameterized; but they\n+                \/\/ must the same type element. For example, if dst is Set<T>,\n+                \/\/ then i is Set<String>\n+                assert Objects.equals(((DeclaredType) i).asElement(), dst);\n+            }\n+        }\n+\n+        private ExecutableElement findImplementedMethod(TypeElement te, ExecutableElement implementer) {\n+            var typeElement = (TypeElement) implementer.getEnclosingElement();\n+            for (var m : utils.getMethods(te)) {\n+                if (utils.elementUtils.overrides(implementer, m, typeElement)) {\n+                    return m;\n@@ -1008,0 +1109,1 @@\n+            return null;\n@@ -1023,1 +1125,1 @@\n-            return methods;\n+            return interfaces.keySet();\n@@ -1031,2 +1133,18 @@\n-    private record OverriddenMethodInfo(ExecutableElement overriddenMethod,\n-                                        boolean simpleOverride) {\n+    \/*\n+     * (Here \"override\" used as a noun, not a verb, for a short and descriptive\n+     * name. Sadly, we cannot use \"Override\" as a complete name because a clash\n+     * with @java.lang.Override would make it inconvenient.)\n+     *\n+     * Used to provide additional attributes to the otherwise boolean\n+     * \"overrides(a, b)\" relationship.\n+     *\n+     * Overriding method could be a key in a map and an instance of this\n+     * record could be the value.\n+     *\/\n+    private record OverrideInfo(ExecutableElement overriddenMethod,\n+                                boolean simpleOverride) {\n+        @Override \/\/ for debugging\n+        public String toString() {\n+            return overriddenMethod.getEnclosingElement()\n+                    + \"::\" + overriddenMethod + \", simple=\" + simpleOverride;\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":191,"deletions":73,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-     * Argument for command-line option {@code -xclasses}.\n+     * Argument for command-line option {@code -Xclasses}.\n@@ -796,1 +796,1 @@\n-     * Argument for command-line option {@code -xclasses}.\n+     * Argument for command-line option {@code -Xclasses}.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolOptions.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -147,0 +147,10 @@\n+                \"\"\"\n+                    <section class=\"detail\" id=\"staticMethod()\">\n+                    <h3>staticMethod<\/h3>\n+                    <div class=\"member-signature\"><span class=\"modifiers\">public static<\/span>&nbsp;\\\n+                    <span class=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">staticMethod<\/span\\\n+                    >()<\/div>\n+                    \"\"\"\n+        );\n+\n+        checkOutput(\"pkg\/ClassWithStaticMembers.html\", false,\n@@ -304,0 +314,55 @@\n+\n+    @Test\n+    public void test3() {\n+        javadoc(\"-d\", \"out-3\",\n+                \"--no-platform-links\", \/\/ disable links to simplify output matching\n+                \"-sourcepath\", testSrc,\n+                \"pkg3\");\n+\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"pkg3\/I.html\", true,\n+                \"\"\"\n+                <li>\n+                <section class=\"detail\" id=\"hashCode()\">\n+                <h3>hashCode<\/h3>\n+                <div class=\"member-signature\"><span class=\"return-type\">\\\n+                int<\/span>&nbsp;<span class=\"element-name\">hashCode<\/span>()<\/div>\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code>hashCode<\/code>&nbsp;in class&nbsp;<code>java.lang.Object<\/code><\/dd>\n+                <\/dl>\n+                <\/section>\n+                <\/li>\n+                <li>\n+                <section class=\"detail\" id=\"equals(java.lang.Object)\">\n+                <h3>equals<\/h3>\n+                <div class=\"member-signature\"><span class=\"return-type\">\\\n+                boolean<\/span>&nbsp;<span class=\"element-name\">equals<\/span>\\\n+                <wbr><span class=\"parameters\">(java.lang.Object&nbsp;obj)<\/span><\/div>\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code>equals<\/code>&nbsp;in class&nbsp;<code>java.lang.Object<\/code><\/dd>\n+                <\/dl>\n+                <\/section>\n+                <\/li>\n+                <li>\n+                <section class=\"detail\" id=\"toString()\">\n+                <h3>toString<\/h3>\n+                <div class=\"member-signature\"><span class=\"return-type\">\\\n+                java.lang.String<\/span>&nbsp;<span class=\"element-name\">toString<\/span>()<\/div>\n+                <dl class=\"notes\">\n+                <dt>Overrides:<\/dt>\n+                <dd><code>toString<\/code>&nbsp;in class&nbsp;<code>java.lang.Object<\/code><\/dd>\n+                <\/dl>\n+                <\/section>\n+                <\/li>\n+                <li>\n+                <section class=\"detail\" id=\"clone()\">\n+                <h3>clone<\/h3>\n+                <div class=\"member-signature\"><span class=\"return-type\">\\\n+                java.lang.Object<\/span>&nbsp;<span class=\"element-name\">clone<\/span>()<\/div>\n+                <\/section>\n+                <\/li>\n+                \"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package pkg3;\n+\n+public interface I {\n+\n+    int hashCode();\n+\n+    boolean equals(Object obj);\n+\n+    String toString();\n+\n+    \/\/ No matter what your IDE might show you, from JLS 9.6.4.4 it follows that\n+    \/\/ the \"clone\" (as well as currently deprecated \"finalize\") method cannot\n+    \/\/ be overridden by an interface method in the same way \"hashCode\", \"equals\"\n+    \/\/ and \"toString\" can. This is because \"clone\" is not public.\n+    Object clone();\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/pkg3\/I.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,10 +52,2 @@\n-        checkExit(Exit.OK);\n-\n-        checkOutput(\"pkg4\/Foo.html\", true,\n-                \"\"\"\n-                    <section class=\"detail\" id=\"toString()\">\n-                    <h3>toString<\/h3>\n-                    <div class=\"member-signature\"><span class=\"modifiers\">public<\/span>&nbsp;<span c\\\n-                    lass=\"return-type\">void<\/span>&nbsp;<span class=\"element-name\">toString<\/span>()<\/div>\n-                    <div class=\"block\">Why can't I do this ?<\/div>\n-                    <\/section>\"\"\");\n+        \/\/ explicitly configure \"no crash\" check, which is the main interest of this test\n+        setAutomaticCheckNoStacktrace(true);\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/TestBadOverride.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4318787\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build toolbox.ToolBox javadoc.tester.*\n+ * @run main TestSpecifiedBy\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class TestSpecifiedBy extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSpecifiedBy().runTests();\n+    }\n+\n+    private final ToolBox tb = new ToolBox();\n+\n+    @Test\n+    public void test(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                package pkg;\n+\n+                public abstract class A {\n+                    public abstract void m();\n+                }\n+                \"\"\", \"\"\"\n+                package pkg;\n+\n+                public class B extends A {\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package pkg;\n+\n+                public abstract class C extends A {\n+                    public void m() { }\n+                }\n+                \"\"\", \"\"\"\n+                package pkg;\n+\n+                public abstract class D extends A {\n+                    public abstract void m();\n+                }\n+                \"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+\n+        checkExit(Exit.OK);\n+        \/\/ check that the terminology for an overridden abstract method of an\n+        \/\/ abstract class is the same as that of an overridden interface method;\n+        \/\/ no matter who the overrider is, the overridden method should be\n+        \/\/ listed under \"Specified by\", not \"Overrides\"\n+        for (var f : List.of(\"pkg\/B.html\", \"pkg\/C.html\", \"pkg\/D.html\"))\n+            checkOutput(f, true,\n+                    \"\"\"\n+                    <dl class=\"notes\">\n+                    <dt>Specified by:<\/dt>\n+                    <dd><code><a href=\"A.html#m()\">m<\/a><\/code>&nbsp;in class&nbsp;\\\n+                    <code><a href=\"A.html\" title=\"class in pkg\">A<\/a><\/code><\/dd>\n+                    <\/dl>\n+                    \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/TestSpecifiedBy.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary test --ignore-errors works correctly\n+ * @summary test --ignore-source-errors works correctly\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/IgnoreSourceErrors.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}